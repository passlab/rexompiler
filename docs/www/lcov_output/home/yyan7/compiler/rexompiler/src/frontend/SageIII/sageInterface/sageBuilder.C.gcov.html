<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface/sageBuilder.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface</a> - sageBuilder.C<span style="font-size: 80%;"> (source / <a href="sageBuilder.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3047</td>
            <td class="headerCovTableEntry">6075</td>
            <td class="headerCovTableEntryLo">50.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">327</td>
            <td class="headerCovTableEntry">638</td>
            <td class="headerCovTableEntryLo">51.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // tps (01/14/2010) : Switching from rose.h to sage3</a>
<a name="2"><span class="lineNum">       2 </span>            : // test cases are put into tests/nonsmoke/functional/roseTests/astInterfaceTests</a>
<a name="3"><span class="lineNum">       3 </span>            : // Last modified, by Liao, Jan 10, 2008</a>
<a name="4"><span class="lineNum">       4 </span>            : </a>
<a name="5"><span class="lineNum">       5 </span>            : // includes &quot;sageBuilder.h&quot;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : #include &lt;rose_config.h&gt;</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="11"><span class="lineNum">      11 </span>            :    #include &quot;roseAdapter.h&quot;</a>
<a name="12"><span class="lineNum">      12 </span>            :    #include &quot;markLhsValues.h&quot;</a>
<a name="13"><span class="lineNum">      13 </span>            : // #include &quot;sageBuilder.h&quot;</a>
<a name="14"><span class="lineNum">      14 </span>            :    #include &lt;fstream&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            :    #include &lt;boost/algorithm/string/trim.hpp&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            :    #include &lt;boost/foreach.hpp&gt;</a>
<a name="17"><span class="lineNum">      17 </span>            :    #include &quot;Outliner.hh&quot;</a>
<a name="18"><span class="lineNum">      18 </span>            : #else</a>
<a name="19"><span class="lineNum">      19 </span>            : // #include &quot;sageBuilder.h&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            :    #include &lt;fstream&gt;</a>
<a name="21"><span class="lineNum">      21 </span>            :    #include &lt;boost/algorithm/string/trim.hpp&gt;</a>
<a name="22"><span class="lineNum">      22 </span>            :    #include &lt;boost/foreach.hpp&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            :    #include &quot;transformationSupport.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #endif</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : </a>
<a name="28"><span class="lineNum">      28 </span>            : // DQ (4/3/2012): Added so that I can enforce some rules as the AST is constructed.</a>
<a name="29"><span class="lineNum">      29 </span>            : #include &quot;AstConsistencyTests.h&quot;</a>
<a name="30"><span class="lineNum">      30 </span>            : </a>
<a name="31"><span class="lineNum">      31 </span>            : // DQ (2/27/2014): We need this feature to support the function: fixupCopyOfAstFromSeparateFileInNewTargetAst()</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &quot;RoseAst.h&quot;</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : // DQ (3/31/2012): Is this going to be an issue for C++11 use with ROSE?</a>
<a name="35"><span class="lineNum">      35 </span>            : #define foreach BOOST_FOREACH</a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : </a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : // DQ (2/17/2013): This is a operation on the global AST that we don't need to do too often</a>
<a name="40"><span class="lineNum">      40 </span>            : // depending on the grainularity sought for the debugging information.  It is done on the</a>
<a name="41"><span class="lineNum">      41 </span>            : // whole AST once after construction (in edgRose.C), but is not needed more than that</a>
<a name="42"><span class="lineNum">      42 </span>            : // since it is a performance issue.</a>
<a name="43"><span class="lineNum">      43 </span>            : #define BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS 0</a>
<a name="44"><span class="lineNum">      44 </span>            : #define BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP 0</a>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<a name="46"><span class="lineNum">      46 </span>            : using namespace std;</a>
<a name="47"><span class="lineNum">      47 </span>            : using namespace Rose;</a>
<a name="48"><span class="lineNum">      48 </span>            : using namespace SageInterface;</a>
<a name="49"><span class="lineNum">      49 </span>            : using namespace Rose::Diagnostics;</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : </a>
<a name="52"><span class="lineNum">      52 </span>            : namespace EDG_ROSE_Translation</a>
<a name="53"><span class="lineNum">      53 </span>            :    {</a>
<a name="54"><span class="lineNum">      54 </span>            :   // DQ (6/3/2019): The case of outlining to a seperate file will have transformations</a>
<a name="55"><span class="lineNum">      55 </span>            :   // that this checking will fail on because it is for the typical case of checking the</a>
<a name="56"><span class="lineNum">      56 </span>            :   // AST for transformations after construction of the AST from an typical input file.</a>
<a name="57"><span class="lineNum">      57 </span>            : #if defined(ROSE_BUILD_CXX_LANGUAGE_SUPPORT) &amp;&amp; !defined(ROSE_USE_CLANG_FRONTEND)</a>
<a name="58"><span class="lineNum">      58 </span>            :   // DQ (6/3/2019): Use the definition in the EDG edgRose.C file if C/C++ support IS defined.</a>
<a name="59"><span class="lineNum">      59 </span>            :      extern bool suppress_detection_of_transformations;</a>
<a name="60"><span class="lineNum">      60 </span>            : #else</a>
<a name="61"><span class="lineNum">      61 </span>            :   // DQ (6/3/2019): Allow this to be the definition if C/C++ support is NOT defined.</a>
<a name="62"><span class="lineNum">      62 </span>            :      bool suppress_detection_of_transformations;</a>
<a name="63"><span class="lineNum">      63 </span>            : #endif</a>
<a name="64"><span class="lineNum">      64 </span>            :    }</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            : // MS 2015: utility functions used in the implementation of SageBuilder functions, but are not exposed in the SageBuilder-Interface.</a>
<a name="67"><span class="lineNum">      67 </span>            : namespace SageBuilder {</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            : // DQ (3/24/2016): Adding Robb's message mechanism (data member and function).</a>
<a name="70"><span class="lineNum">      70 </span>            : Sawyer::Message::Facility mlog;</a>
<a name="71"><span class="lineNum">      71 </span>            : void</a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">        356 : initDiagnostics()</span></a>
<a name="73"><span class="lineNum">      73 </span>            :    {</a>
<a name="74"><span class="lineNum">      74 </span><span class="lineCov">        356 :      static bool initialized = false;</span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">        356 :      if (!initialized)</span></a>
<a name="76"><span class="lineNum">      76 </span>            :         {</a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">        356 :           initialized = true;</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">        356 :           Rose::Diagnostics::initAndRegister(&amp;mlog, &quot;Rose::SageBuilder&quot;);</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">        712 :           mlog.comment(&quot;building abstract syntax trees&quot;);</span></a>
<a name="80"><span class="lineNum">      80 </span>            :         }</a>
<a name="81"><span class="lineNum">      81 </span><span class="lineCov">        356 :    }</span></a>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<a name="83"><span class="lineNum">      83 </span>            : </a>
<a name="84"><span class="lineNum">      84 </span>            : template &lt;class actualFunction&gt;</a>
<a name="85"><span class="lineNum">      85 </span>            : actualFunction*</a>
<a name="86"><span class="lineNum">      86 </span>            : buildNondefiningFunctionDeclaration_T (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateArgumentPtrList* templateArgumentsList, SgTemplateParameterPtrList* templateParameterList, SgStorageModifier::storage_modifier_enum sm);</a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span>            : // DQ (8/11/2013): Note that the specification of the SgTemplateArgumentPtrList is somewhat redundant with the required parameter first_nondefinng_declaration (I think).</a>
<a name="89"><span class="lineNum">      89 </span>            : //! A template function for function declaration builders</a>
<a name="90"><span class="lineNum">      90 </span>            : template &lt;class actualFunction&gt;</a>
<a name="91"><span class="lineNum">      91 </span>            : actualFunction*</a>
<a name="92"><span class="lineNum">      92 </span>            : // buildDefiningFunctionDeclaration_T (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, bool isMemberFunction, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, unsigned int functionConstVolatileFlags = 0);</a>
<a name="93"><span class="lineNum">      93 </span>            : // buildDefiningFunctionDeclaration_T (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, actualFunction* first_nondefinng_declaration);</a>
<a name="94"><span class="lineNum">      94 </span>            : buildDefiningFunctionDeclaration_T (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, actualFunction* first_nondefinng_declaration, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span>            : //! Function to reset scopes in SgDeclarationStatement IR nodes.</a>
<a name="97"><span class="lineNum">      97 </span>            : // ROSE_DLL_API void resetDeclaration(SgDeclarationStatement* classDeclaration_copy, SgDeclarationStatement* classDeclaration_original);</a>
<a name="98"><span class="lineNum">      98 </span>            : template &lt;class T&gt; ROSE_DLL_API void resetDeclaration(T* classDeclaration_copy, T* classDeclaration_original, SgScopeStatement* targetScope);</a>
<a name="99"><span class="lineNum">      99 </span>            : </a>
<a name="100"><span class="lineNum">     100 </span>            : }; // SageBuilder namespace</a>
<a name="101"><span class="lineNum">     101 </span>            : </a>
<a name="102"><span class="lineNum">     102 </span>            : //---------------------------------------------</a>
<a name="103"><span class="lineNum">     103 </span>            : // scope stack interfaces</a>
<a name="104"><span class="lineNum">     104 </span>            : //   hide actual implementation of the stack</a>
<a name="105"><span class="lineNum">     105 </span>            : //---------------------------------------------</a>
<a name="106"><span class="lineNum">     106 </span>            : </a>
<a name="107"><span class="lineNum">     107 </span>            : // DQ (1/18/2008): Added declaration in source file with Liao.</a>
<a name="108"><span class="lineNum">     108 </span>            : // std::list&lt;SgScopeStatement*&gt; SageBuilder::ScopeStack;</a>
<a name="109"><span class="lineNum">     109 </span>            : std::list&lt;SgScopeStatement*&gt; SageBuilder::ScopeStack(0);</a>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<a name="111"><span class="lineNum">     111 </span>            : </a>
<a name="112"><span class="lineNum">     112 </span>            : // DQ (11/30/2010): Added support for building Fortran case insensitive symbol table handling.</a>
<a name="113"><span class="lineNum">     113 </span>            : // Support for construction of case sensitive/insensitive symbol table handling in scopes.</a>
<a name="114"><span class="lineNum">     114 </span>            : // CR (3/22/2020): Setting this variable to properly reflect language properties</a>
<a name="115"><span class="lineNum">     115 </span>            : // was removed in 2017. I would like to remove it from SageBuilder.</a>
<a name="116"><span class="lineNum">     116 </span>            : bool SageBuilder::symbol_table_case_insensitive_semantics = false;</a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            : //! C++ SageBuilder namespace specific state for storage of the source code position state</a>
<a name="120"><span class="lineNum">     120 </span>            : // (used to control how the source code positon is defined for IR nodes built within the SageBuilder interface).</a>
<a name="121"><span class="lineNum">     121 </span>            : // Set the default to be to mark everything as a transformation.</a>
<a name="122"><span class="lineNum">     122 </span>            : // SageBuilder::SourcePositionClassification SageBuilder::SourcePositionClassificationMode = SageBuilder::e_sourcePositionError;</a>
<a name="123"><span class="lineNum">     123 </span>            : SageBuilder::SourcePositionClassification SageBuilder::SourcePositionClassificationMode = SageBuilder::e_sourcePositionTransformation;</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<a name="127"><span class="lineNum">     127 </span>            : // ROSE_DLL_API SgMemberFunctionDeclaration* buildConstructor ( const SgName &amp; typeName, SgClassType* initializedName_classType, SgClassDefinition* classDefinition);</a>
<a name="128"><span class="lineNum">     128 </span>            : // SgMemberFunctionDeclaration* SageBuilder::buildConstructor ( const SgName &amp; typeName, SgClassType* classType, SgClassDefinition* classDefinition)</a>
<a name="129"><span class="lineNum">     129 </span>            : SgMemberFunctionDeclaration*</a>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 : SageBuilder::buildDefaultConstructor (SgClassType* classType)</span></a>
<a name="131"><span class="lineNum">     131 </span>            :    {</a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classType != NULL);</span></a>
<a name="133"><span class="lineNum">     133 </span>            : </a>
<a name="134"><span class="lineNum">     134 </span><span class="lineNoCov">          0 :      SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :      SgName className = classDeclaration-&gt;get_name();</span></a>
<a name="138"><span class="lineNum">     138 </span>            : </a>
<a name="139"><span class="lineNum">     139 </span>            : #if 1</a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :      printf (&quot;In SageBuilder::buildDefaultConstructor(): building default constructor for class = %s \n&quot;,className.str());</span></a>
<a name="141"><span class="lineNum">     141 </span>            : #endif</a>
<a name="142"><span class="lineNum">     142 </span>            : </a>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 :      SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :      SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="147"><span class="lineNum">     147 </span>            : </a>
<a name="148"><span class="lineNum">     148 </span>            :   // SgExprListExp* exprListExp = SageBuilder::buildExprListExp();</a>
<a name="149"><span class="lineNum">     149 </span>            :   // ROSE_ASSERT(exprListExp != NULL);</a>
<a name="150"><span class="lineNum">     150 </span>            :   // SgFunctionParameterTypeList* functionParameterTypeList = SageBuilder::buildFunctionParameterTypeList(exprListExp);</a>
<a name="151"><span class="lineNum">     151 </span>            :   // ROSE_ASSERT(functionParameterTypeList != NULL);</a>
<a name="152"><span class="lineNum">     152 </span>            :   // SgMemberFunctionType* memberFunctionType = SageBuilder::buildMemberFunctionType(return_type, functionParameterTypeList, initializedName_classType, mfunc_specifier, ref_qualifiers);</a>
<a name="153"><span class="lineNum">     153 </span>            : </a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :      SgFunctionParameterList*     functionParameterList     = SageBuilder::buildFunctionParameterList();</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(functionParameterList != NULL);</span></a>
<a name="156"><span class="lineNum">     156 </span>            : </a>
<a name="157"><span class="lineNum">     157 </span>            :   // Constructors are specified with type void internally, though the type name is not output.</a>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :      SgType* return_type = SageBuilder::buildVoidType();</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            :   // unsigned int mfunc_specifier = 0;</a>
<a name="162"><span class="lineNum">     162 </span>            :   // unsigned int ref_qualifiers  = 0;</a>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :      SgExprListExp* decoratorList            = NULL;</span></a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :      bool buildTemplateInstantiation         = false;</span></a>
<a name="166"><span class="lineNum">     166 </span>            : </a>
<a name="167"><span class="lineNum">     167 </span>            :   // These are zero for a constructor.</a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 :      unsigned int functionConstVolatileFlags = 0;</span></a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :      SgTemplateArgumentPtrList templateArgumentsList;</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :      SgMemberFunctionDeclaration* first_nondefining_declaration = buildNondefiningMemberFunctionDeclaration (className, return_type, functionParameterList,</span></a>
<a name="173"><span class="lineNum">     173 </span>            :           classDefinition, decoratorList, functionConstVolatileFlags, buildTemplateInstantiation, &amp;templateArgumentsList);</a>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :      first_nondefining_declaration-&gt;get_specialFunctionModifier().setConstructor();</span></a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(first_nondefining_declaration-&gt;get_specialFunctionModifier().isConstructor() == true);</span></a>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<a name="179"><span class="lineNum">     179 </span>            :   // DQ (11/10/2020): Need to make sure that the firstNondefiningDeclaration is being used (reset is needed).</a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 :      if (first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() != first_nondefining_declaration)</span></a>
<a name="181"><span class="lineNum">     181 </span>            :         {</a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :           first_nondefining_declaration = isSgMemberFunctionDeclaration(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="183"><span class="lineNum">     183 </span>            :         }</a>
<a name="184"><span class="lineNum">     184 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() == first_nondefining_declaration);</span></a>
<a name="185"><span class="lineNum">     185 </span>            : </a>
<a name="186"><span class="lineNum">     186 </span><span class="lineNoCov">          0 :      SgMemberFunctionDeclaration* memberFunctionDeclaration = SageBuilder::buildDefiningMemberFunctionDeclaration (className, return_type, functionParameterList,</span></a>
<a name="187"><span class="lineNum">     187 </span>            :           classDefinition, decoratorList, buildTemplateInstantiation, functionConstVolatileFlags, first_nondefining_declaration, &amp;templateArgumentsList);</a>
<a name="188"><span class="lineNum">     188 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionDeclaration != NULL);</span></a>
<a name="189"><span class="lineNum">     189 </span>            : </a>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 :      memberFunctionDeclaration-&gt;get_specialFunctionModifier().setConstructor();</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionDeclaration-&gt;get_specialFunctionModifier().isConstructor() == true);</span></a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span>            :   // We return the default constructor and the use should insert it, I think.</a>
<a name="194"><span class="lineNum">     194 </span>            :   // classDefinition-&gt;prepend_statement(memberFunctionDeclaration);</a>
<a name="195"><span class="lineNum">     195 </span>            : </a>
<a name="196"><span class="lineNum">     196 </span>            :   // Mark the constructor as public.</a>
<a name="197"><span class="lineNum">     197 </span><span class="lineNoCov">          0 :      memberFunctionDeclaration-&gt;get_declarationModifier().get_accessModifier().setPublic();</span></a>
<a name="198"><span class="lineNum">     198 </span>            : </a>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (memberFunctionDeclaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true);</span></a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span>            : #if 0</a>
<a name="202"><span class="lineNum">     202 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="203"><span class="lineNum">     203 </span>            :      ROSE_ABORT();</a>
<a name="204"><span class="lineNum">     204 </span>            : #endif</a>
<a name="205"><span class="lineNum">     205 </span>            : </a>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 :      return memberFunctionDeclaration;</span></a>
<a name="207"><span class="lineNum">     207 </span>            :    }</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span>            : </a>
<a name="211"><span class="lineNum">     211 </span>            : </a>
<a name="212"><span class="lineNum">     212 </span>            : </a>
<a name="213"><span class="lineNum">     213 </span>            : //! Get the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).</a>
<a name="214"><span class="lineNum">     214 </span>            : SageBuilder::SourcePositionClassification</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">   39123100 : SageBuilder::getSourcePositionClassificationMode()</span></a>
<a name="216"><span class="lineNum">     216 </span>            :    {</a>
<a name="217"><span class="lineNum">     217 </span>            : #if 0</a>
<a name="218"><span class="lineNum">     218 </span>            :      printf (&quot;In getSourcePositionClassificationMode(): returning mode = %s \n&quot;,display(SourcePositionClassificationMode).c_str());</a>
<a name="219"><span class="lineNum">     219 </span>            : #endif</a>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">   39123100 :      return SourcePositionClassificationMode;</span></a>
<a name="222"><span class="lineNum">     222 </span>            :    }</a>
<a name="223"><span class="lineNum">     223 </span>            : </a>
<a name="224"><span class="lineNum">     224 </span>            : //! Set the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).</a>
<a name="225"><span class="lineNum">     225 </span>            : void</a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">       3299 : SageBuilder::setSourcePositionClassificationMode(SageBuilder::SourcePositionClassification X)</span></a>
<a name="227"><span class="lineNum">     227 </span>            :    {</a>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">       3299 :      SourcePositionClassificationMode = X;</span></a>
<a name="229"><span class="lineNum">     229 </span><span class="lineCov">       3299 :    }</span></a>
<a name="230"><span class="lineNum">     230 </span>            : </a>
<a name="231"><span class="lineNum">     231 </span>            : string</a>
<a name="232"><span class="lineNum">     232 </span><span class="lineNoCov">          0 : SageBuilder::display(SourcePositionClassification &amp; scp)</span></a>
<a name="233"><span class="lineNum">     233 </span>            :    {</a>
<a name="234"><span class="lineNum">     234 </span>            :   // DQ (11/19/2012): This function is build to support debugging the value of the statically defined mode.</a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :      string s;</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineNoCov">          0 :      switch(scp)</span></a>
<a name="238"><span class="lineNum">     238 </span>            :         {</a>
<a name="239"><span class="lineNum">     239 </span><span class="lineNoCov">          0 :           case e_sourcePositionError:                s = &quot;e_sourcePositionError&quot;;                break;</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :           case e_sourcePositionDefault:              s = &quot;e_sourcePositionDefault&quot;;              break;</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 :           case e_sourcePositionTransformation:       s = &quot;e_sourcePositionTransformation&quot;;       break;</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineNoCov">          0 :           case e_sourcePositionCompilerGenerated:    s = &quot;e_sourcePositionCompilerGenerated&quot;;    break;</span></a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :           case e_sourcePositionNullPointers:         s = &quot;e_sourcePositionNullPointers&quot;;         break;</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :           case e_sourcePositionFrontendConstruction: s = &quot;e_sourcePositionFrontendConstruction&quot;; break;</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :           case e_sourcePosition_last:                s = &quot;e_sourcePosition_last&quot;;                break;</span></a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached in SageBuilder::display(SourcePositionClassification &amp; scp): scp = %d \n&quot;,scp);</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="251"><span class="lineNum">     251 </span>            :              }</a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span>            :         }</a>
<a name="254"><span class="lineNum">     254 </span>            : </a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :      return s;</span></a>
<a name="256"><span class="lineNum">     256 </span>            :    }</a>
<a name="257"><span class="lineNum">     257 </span>            : </a>
<a name="258"><span class="lineNum">     258 </span>            : </a>
<a name="259"><span class="lineNum">     259 </span>            : // DQ (5/21/2013): Added function to support hidding the implementation in the SgScopeStatement API.</a>
<a name="260"><span class="lineNum">     260 </span>            : // template &lt;class T&gt; SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function (const SgName &amp; name, const SgType* func_type)</a>
<a name="261"><span class="lineNum">     261 </span>            : template &lt;class T&gt;</a>
<a name="262"><span class="lineNum">     262 </span>            : SgFunctionSymbol*</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">    1509955 : SgScopeStatement::find_symbol_by_type_of_function (const SgName &amp; name, const SgType* func_type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)</span></a>
<a name="264"><span class="lineNum">     264 </span>            :    {</a>
<a name="265"><span class="lineNum">     265 </span>            :   // DQ (3/13/2012): This is to address the fact that there are 6 different types of functions in ROSE:</a>
<a name="266"><span class="lineNum">     266 </span>            :   //    1) SgFunctionDeclaration</a>
<a name="267"><span class="lineNum">     267 </span>            :   //    2) SgMemberFunctionDeclaration</a>
<a name="268"><span class="lineNum">     268 </span>            :   //    3) SgTemplateFunctionDeclaration</a>
<a name="269"><span class="lineNum">     269 </span>            :   //    4) SgTemplateMemberFunctionDeclaration</a>
<a name="270"><span class="lineNum">     270 </span>            :   //    5) SgTemplateFunctionInstntiationDeclaration</a>
<a name="271"><span class="lineNum">     271 </span>            :   //    6) SgTemplateMemberFunctionInstntiationDeclaration</a>
<a name="272"><span class="lineNum">     272 </span>            :   // And 4 different types of function symbols:</a>
<a name="273"><span class="lineNum">     273 </span>            :   //    1) SgFunctionSymbol</a>
<a name="274"><span class="lineNum">     274 </span>            :   //    2) SgMemberFunctionSymbol</a>
<a name="275"><span class="lineNum">     275 </span>            :   //    3) SgTemplateFunctionSymbol</a>
<a name="276"><span class="lineNum">     276 </span>            :   //    4) SgTemplateMemberFunctionSymbol</a>
<a name="277"><span class="lineNum">     277 </span>            :   // Note that both:</a>
<a name="278"><span class="lineNum">     278 </span>            :   //    SgTemplateFunctionInstntiationDeclaration</a>
<a name="279"><span class="lineNum">     279 </span>            :   //    SgTemplateMemberFunctionInstntiationDeclaration</a>
<a name="280"><span class="lineNum">     280 </span>            :   // map to</a>
<a name="281"><span class="lineNum">     281 </span>            :   //    SgFunctionSymbol</a>
<a name="282"><span class="lineNum">     282 </span>            :   //    SgMemberFunctionSymbol</a>
<a name="283"><span class="lineNum">     283 </span>            :   // respectively.</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            :   // Check if there is a function symbol of any kind, then narrow the selection.</a>
<a name="286"><span class="lineNum">     286 </span>            :   // SgFunctionSymbol* func_symbol = lookup_function_symbol(name,func_type);</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineCov">    1509955 :      SgFunctionSymbol* func_symbol = NULL;</span></a>
<a name="288"><span class="lineNum">     288 </span>            : </a>
<a name="289"><span class="lineNum">     289 </span>            :   // if (func_symbol == NULL)</a>
<a name="290"><span class="lineNum">     290 </span>            :         {</a>
<a name="291"><span class="lineNum">     291 </span>            :        // Use the static variant as a selector.</a>
<a name="292"><span class="lineNum">     292 </span>            :           switch((VariantT)T::static_variant)</a>
<a name="293"><span class="lineNum">     293 </span>            :              {</a>
<a name="294"><span class="lineNum">     294 </span>            :                case V_SgFunctionDeclaration:</a>
<a name="295"><span class="lineNum">     295 </span>            :                case V_SgProcedureHeaderStatement:</a>
<a name="296"><span class="lineNum">     296 </span>            :                case V_SgTemplateInstantiationFunctionDecl:</a>
<a name="297"><span class="lineNum">     297 </span>            :                   {</a>
<a name="298"><span class="lineNum">     298 </span>            : #if 0</a>
<a name="299"><span class="lineNum">     299 </span>            :                  // printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgFunctionDeclaration or SgTemplateInstantiationFunctionDecl function: name = %s \n&quot;,name.str());</a>
<a name="300"><span class="lineNum">     300 </span>            :                     printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function&lt;%s&gt;(): This is a SgFunctionDeclaration or SgTemplateInstantiationFunctionDecl function: name = %s \n&quot;,</a>
<a name="301"><span class="lineNum">     301 </span>            :                          Cxx_GrammarTerminalNames[T::static_variant].name.c_str(),name.str());</a>
<a name="302"><span class="lineNum">     302 </span>            :                     printf (&quot;   --- templateArgumentsList = %p \n&quot;,templateArgumentsList);</a>
<a name="303"><span class="lineNum">     303 </span>            : #endif</a>
<a name="304"><span class="lineNum">     304 </span>            :                  // DQ (8/11/2013): Verify that the template arguments are provided for the correct cases and not for the incorrect cases.</a>
<a name="305"><span class="lineNum">     305 </span>            :                     if ((VariantT)T::static_variant == V_SgTemplateInstantiationFunctionDecl)</a>
<a name="306"><span class="lineNum">     306 </span>            :                        {</a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">       3105 :                          ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="308"><span class="lineNum">     308 </span>            :                        }</a>
<a name="309"><span class="lineNum">     309 </span>            :                       else</a>
<a name="310"><span class="lineNum">     310 </span>            :                        {</a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">    1433376 :                          ROSE_ASSERT(templateArgumentsList == NULL);</span></a>
<a name="312"><span class="lineNum">     312 </span>            :                        }</a>
<a name="313"><span class="lineNum">     313 </span>            : </a>
<a name="314"><span class="lineNum">     314 </span>            :                  // DQ (5/21/2013): Calling the SgScopeStatement API.</a>
<a name="315"><span class="lineNum">     315 </span>            :                  // func_symbol = find_nontemplate_function(name,func_type);</a>
<a name="316"><span class="lineNum">     316 </span>            :                  // func_symbol = lookup_nontemplate_function_symbol(name,func_type);</a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">    1436481 :                     func_symbol = lookup_nontemplate_function_symbol(name,func_type,templateArgumentsList);</span></a>
<a name="318"><span class="lineNum">     318 </span>            : #if 0</a>
<a name="319"><span class="lineNum">     319 </span>            :                  // DQ (3/20/2017): Comment this debugging code out, note that the assertion it supports in left in place.</a>
<a name="320"><span class="lineNum">     320 </span>            :                     if (isSgTemplateFunctionSymbol(func_symbol) != NULL)</a>
<a name="321"><span class="lineNum">     321 </span>            :                        {</a>
<a name="322"><span class="lineNum">     322 </span>            :                          printf (&quot;ERROR: func_symbol == SgTemplateFunctionSymbol in find_symbol_by_type_of_function(): case V_SgFunctionDeclaration: \n&quot;);</a>
<a name="323"><span class="lineNum">     323 </span>            :                          SgFunctionDeclaration* functionDeclaration = func_symbol-&gt;get_declaration();</a>
<a name="324"><span class="lineNum">     324 </span>            :                          ROSE_ASSERT(functionDeclaration != NULL);</a>
<a name="325"><span class="lineNum">     325 </span>            :                          printf (&quot;   --- functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="326"><span class="lineNum">     326 </span>            :                          ROSE_ASSERT(functionDeclaration-&gt;get_file_info() != NULL);</a>
<a name="327"><span class="lineNum">     327 </span>            :                          functionDeclaration-&gt;get_file_info()-&gt;display(&quot;func_symbol == SgTemplateFunctionSymbol&quot;);</a>
<a name="328"><span class="lineNum">     328 </span>            :                        }</a>
<a name="329"><span class="lineNum">     329 </span>            : #endif</a>
<a name="330"><span class="lineNum">     330 </span>            :                  // DQ (5/22/2013): This function symbol should not be a SgTemplateFunctionSymbol (associated with a template function.  It should be an instantiated template.</a>
<a name="331"><span class="lineNum">     331 </span><span class="lineCov">    1436481 :                     ROSE_ASSERT(isSgTemplateFunctionSymbol(func_symbol) == NULL);</span></a>
<a name="332"><span class="lineNum">     332 </span>            :                     break;</a>
<a name="333"><span class="lineNum">     333 </span>            :                   }</a>
<a name="334"><span class="lineNum">     334 </span>            : </a>
<a name="335"><span class="lineNum">     335 </span>            :                case V_SgMemberFunctionDeclaration:</a>
<a name="336"><span class="lineNum">     336 </span>            :                case V_SgTemplateInstantiationMemberFunctionDecl:</a>
<a name="337"><span class="lineNum">     337 </span>            :                   {</a>
<a name="338"><span class="lineNum">     338 </span>            : #if 0</a>
<a name="339"><span class="lineNum">     339 </span>            :                     printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgMemberFunctionDeclaration or SgTemplateInstantiationMemberFunctionDecl function \n&quot;);</a>
<a name="340"><span class="lineNum">     340 </span>            : #endif</a>
<a name="341"><span class="lineNum">     341 </span>            :                  // DQ (5/21/2013): there is no SgScopeStatement API that calls this function.</a>
<a name="342"><span class="lineNum">     342 </span>            :                  // printf (&quot;WARNING: There is no SgScopeStatement API that calls this function: find_nontemplate_member_function(). \n&quot;);</a>
<a name="343"><span class="lineNum">     343 </span>            : </a>
<a name="344"><span class="lineNum">     344 </span>            :                  // DQ (8/11/2013): Verify that the template arguments are provided for the correct cases and not for the incorrect cases.</a>
<a name="345"><span class="lineNum">     345 </span>            :                     if ((VariantT)T::static_variant == V_SgTemplateInstantiationMemberFunctionDecl)</a>
<a name="346"><span class="lineNum">     346 </span>            :                        {</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">      25580 :                          ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="348"><span class="lineNum">     348 </span>            :                        }</a>
<a name="349"><span class="lineNum">     349 </span>            :                       else</a>
<a name="350"><span class="lineNum">     350 </span>            :                        {</a>
<a name="351"><span class="lineNum">     351 </span><span class="lineCov">       9855 :                          ROSE_ASSERT(templateArgumentsList == NULL);</span></a>
<a name="352"><span class="lineNum">     352 </span>            :                        }</a>
<a name="353"><span class="lineNum">     353 </span>            : #if 0</a>
<a name="354"><span class="lineNum">     354 </span>            :                  // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList</a>
<a name="355"><span class="lineNum">     355 </span>            :                  // to the lookup_nontemplate_member_function_symbol() function.</a>
<a name="356"><span class="lineNum">     356 </span>            :                     ROSE_ASSERT(templateArgumentsList == NULL);</a>
<a name="357"><span class="lineNum">     357 </span>            : #endif</a>
<a name="358"><span class="lineNum">     358 </span>            :                  // func_symbol = find_nontemplate_member_function(name,func_type);</a>
<a name="359"><span class="lineNum">     359 </span>            :                  // ROSE_ASSERT(isSgNamespaceDefinitionStatement(this) == NULL);</a>
<a name="360"><span class="lineNum">     360 </span>            :                  // func_symbol = get_symbol_table()-&gt;find_nontemplate_member_function(name,func_type);</a>
<a name="361"><span class="lineNum">     361 </span>            :                  // func_symbol = lookup_nontemplate_member_function_symbol(name,func_type);</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">      35435 :                     func_symbol = lookup_nontemplate_member_function_symbol(name,func_type,templateArgumentsList);</span></a>
<a name="363"><span class="lineNum">     363 </span>            :                     break;</a>
<a name="364"><span class="lineNum">     364 </span>            :                   }</a>
<a name="365"><span class="lineNum">     365 </span>            : </a>
<a name="366"><span class="lineNum">     366 </span>            :                case V_SgTemplateFunctionDeclaration:</a>
<a name="367"><span class="lineNum">     367 </span>            :                   {</a>
<a name="368"><span class="lineNum">     368 </span>            : #if 0</a>
<a name="369"><span class="lineNum">     369 </span>            :                     printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgTemplateFunctionDeclaration function \n&quot;);</a>
<a name="370"><span class="lineNum">     370 </span>            : #endif</a>
<a name="371"><span class="lineNum">     371 </span>            :                  // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList</a>
<a name="372"><span class="lineNum">     372 </span>            :                  // to the lookup_template_function_symbol() function.</a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">       7720 :                     ROSE_ASSERT(templateArgumentsList == NULL);</span></a>
<a name="374"><span class="lineNum">     374 </span>            : </a>
<a name="375"><span class="lineNum">     375 </span>            :                  // DQ (8/11/2013): I think this should always be non-null.</a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">       7720 :                     ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span>            :                  // DQ (8/7/2013): Adding support to permit template function overloading on template parameters.</a>
<a name="379"><span class="lineNum">     379 </span>            :                  // Note that the template arguments are being handed in as templateSpecializationArgumentList since this is the matching list.</a>
<a name="380"><span class="lineNum">     380 </span>            :                  // However, we might expect template parameter.</a>
<a name="381"><span class="lineNum">     381 </span>            : </a>
<a name="382"><span class="lineNum">     382 </span>            :                  // DQ (8/7/2013): Adding support for template function overloading using template parameters (info passed as template arguments for specialization).</a>
<a name="383"><span class="lineNum">     383 </span>            :                  // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="384"><span class="lineNum">     384 </span>            :                  // In this case these are unavailable from this point.</a>
<a name="385"><span class="lineNum">     385 </span>            :                  // DQ (5/21/2013): Calling the SgScopeStatement API.</a>
<a name="386"><span class="lineNum">     386 </span>            :                  // func_symbol = find_template_function(name,func_type);</a>
<a name="387"><span class="lineNum">     387 </span>            :                  // func_symbol = lookup_template_function_symbol(name,func_type);</a>
<a name="388"><span class="lineNum">     388 </span>            :                  // func_symbol = lookup_template_function_symbol(name,func_type,NULL,NULL);</a>
<a name="389"><span class="lineNum">     389 </span>            :                  // func_symbol = lookup_template_function_symbol(name,func_type,NULL,templateArgumentsList);</a>
<a name="390"><span class="lineNum">     390 </span><span class="lineCov">       7720 :                     func_symbol = lookup_template_function_symbol(name,func_type,templateParameterList);</span></a>
<a name="391"><span class="lineNum">     391 </span>            : </a>
<a name="392"><span class="lineNum">     392 </span>            :                     break;</a>
<a name="393"><span class="lineNum">     393 </span>            :                   }</a>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<a name="395"><span class="lineNum">     395 </span>            :                case V_SgTemplateMemberFunctionDeclaration:</a>
<a name="396"><span class="lineNum">     396 </span>            :                   {</a>
<a name="397"><span class="lineNum">     397 </span>            : #if 0</a>
<a name="398"><span class="lineNum">     398 </span>            :                     printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgTemplateMemberFunctionDeclaration function \n&quot;);</a>
<a name="399"><span class="lineNum">     399 </span>            : #endif</a>
<a name="400"><span class="lineNum">     400 </span>            :                  // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList</a>
<a name="401"><span class="lineNum">     401 </span>            :                  // to the lookup_template_member_function_symbol() function.</a>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">      30319 :                     ROSE_ASSERT(templateArgumentsList == NULL);</span></a>
<a name="403"><span class="lineNum">     403 </span>            : </a>
<a name="404"><span class="lineNum">     404 </span>            :                  // DQ (8/11/2013): I think this sould always be non-null.</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">      30319 :                     ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :                  // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="408"><span class="lineNum">     408 </span>            :                  // In this case these are unavailable from this point.</a>
<a name="409"><span class="lineNum">     409 </span>            :                  // DQ (5/21/2013): Calling the SgScopeStatement API.</a>
<a name="410"><span class="lineNum">     410 </span>            :                  // func_symbol = find_template_member_function(name,func_type);</a>
<a name="411"><span class="lineNum">     411 </span>            :                  // func_symbol = lookup_template_member_function_symbol(name,func_type);</a>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">      30319 :                     func_symbol = lookup_template_member_function_symbol(name,func_type,templateParameterList);</span></a>
<a name="413"><span class="lineNum">     413 </span>            :                     break;</a>
<a name="414"><span class="lineNum">     414 </span>            :                   }</a>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<a name="416"><span class="lineNum">     416 </span>            :                default:</a>
<a name="417"><span class="lineNum">     417 </span>            :                   {</a>
<a name="418"><span class="lineNum">     418 </span>            :                     printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): default reached --- variantT(T::static_variant) = %d \n&quot;,T::static_variant);</a>
<a name="419"><span class="lineNum">     419 </span>            :                     ROSE_ABORT();</a>
<a name="420"><span class="lineNum">     420 </span>            :                   }</a>
<a name="421"><span class="lineNum">     421 </span>            :              }</a>
<a name="422"><span class="lineNum">     422 </span>            :         }</a>
<a name="423"><span class="lineNum">     423 </span>            : </a>
<a name="424"><span class="lineNum">     424 </span>            : #if 0</a>
<a name="425"><span class="lineNum">     425 </span>            :      if (func_symbol != NULL)</a>
<a name="426"><span class="lineNum">     426 </span>            :           printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): func_symbol = %p = %s \n&quot;,func_symbol,func_symbol-&gt;class_name().c_str());</a>
<a name="427"><span class="lineNum">     427 </span>            :        else</a>
<a name="428"><span class="lineNum">     428 </span>            :           printf (&quot;In SgScopeStatement::find_symbol_by_type_of_function(): func_symbol = %p \n&quot;,func_symbol);</a>
<a name="429"><span class="lineNum">     429 </span>            : #endif</a>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<a name="431"><span class="lineNum">     431 </span>            :   // return isSgFunctionSymbol(func_symbol);</a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">    1509955 :      return func_symbol;</span></a>
<a name="433"><span class="lineNum">     433 </span>            :    }</a>
<a name="434"><span class="lineNum">     434 </span>            : </a>
<a name="435"><span class="lineNum">     435 </span>            : </a>
<a name="436"><span class="lineNum">     436 </span>            : // explicit instantiation of find_symbol_by_type_of_function</a>
<a name="437"><span class="lineNum">     437 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgTemplateFunctionDeclaration&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="438"><span class="lineNum">     438 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgTemplateInstantiationMemberFunctionDecl&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="439"><span class="lineNum">     439 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgTemplateInstantiationFunctionDecl&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="440"><span class="lineNum">     440 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgMemberFunctionDeclaration&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="441"><span class="lineNum">     441 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgTemplateMemberFunctionDeclaration&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="442"><span class="lineNum">     442 </span>            : template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function&lt;SgFunctionDeclaration&gt;(SgName const&amp;, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);</a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span>            : void</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">      71821 : SageBuilder::pushScopeStack (SgScopeStatement* stmt)</span></a>
<a name="446"><span class="lineNum">     446 </span>            :    {</a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">      71821 :      ROSE_ASSERT(stmt != NULL);</span></a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span>            : #if 0</a>
<a name="450"><span class="lineNum">     450 </span>            :   // DQ (9/28/2009): This is part of testing for GNU 4.0.x (other versions of g++ work fine).</a>
<a name="451"><span class="lineNum">     451 </span>            :      ROSE_ASSERT(stmt != NULL);</a>
<a name="452"><span class="lineNum">     452 </span>            :      if (stmt != NULL)</a>
<a name="453"><span class="lineNum">     453 </span>            :         {</a>
<a name="454"><span class="lineNum">     454 </span>            :        // Calling any member function is a way to test the pointer.</a>
<a name="455"><span class="lineNum">     455 </span>            :           stmt-&gt;class_name();</a>
<a name="456"><span class="lineNum">     456 </span>            :         }</a>
<a name="457"><span class="lineNum">     457 </span>            : #endif</a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">      71821 :      ScopeStack.push_back(stmt);</span></a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span>            : #if 0</a>
<a name="462"><span class="lineNum">     462 </span>            :   // Debugging code to output the scope stack.</a>
<a name="463"><span class="lineNum">     463 </span>            :      printf (&quot;SageBuilder::pushScopeStack(): Scope stack: \n&quot;);</a>
<a name="464"><span class="lineNum">     464 </span>            :      int counter = 0;</a>
<a name="465"><span class="lineNum">     465 </span>            :      for (std::list&lt;SgScopeStatement*&gt;::iterator i = ScopeStack.begin(); i != ScopeStack.end(); i++)</a>
<a name="466"><span class="lineNum">     466 </span>            :         {</a>
<a name="467"><span class="lineNum">     467 </span>            :           printf (&quot;   --- i = %d: %p = %s \n&quot;,counter,*i,(*i)-&gt;class_name().c_str());</a>
<a name="468"><span class="lineNum">     468 </span>            :           counter++;</a>
<a name="469"><span class="lineNum">     469 </span>            :         }</a>
<a name="470"><span class="lineNum">     470 </span>            : #endif</a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">      71821 :    }</span></a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span>            : #if 0</a>
<a name="474"><span class="lineNum">     474 </span>            : // DQ (3/20/2017): This function is not called (the function above is the more useful one that is used).</a>
<a name="475"><span class="lineNum">     475 </span>            : void SageBuilder::pushScopeStack (SgNode* node)</a>
<a name="476"><span class="lineNum">     476 </span>            :    {</a>
<a name="477"><span class="lineNum">     477 </span>            :      SgScopeStatement* stmt = isSgScopeStatement(node);</a>
<a name="478"><span class="lineNum">     478 </span>            : </a>
<a name="479"><span class="lineNum">     479 </span>            :   // DQ (9/26/2012): Added assertion.</a>
<a name="480"><span class="lineNum">     480 </span>            :      ROSE_ASSERT(stmt != NULL);</a>
<a name="481"><span class="lineNum">     481 </span>            : </a>
<a name="482"><span class="lineNum">     482 </span>            : #if 0</a>
<a name="483"><span class="lineNum">     483 </span>            :      printf (&quot;Inside of SageBuilder::pushScopeStack(scope = %p = %s) \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="484"><span class="lineNum">     484 </span>            : #endif</a>
<a name="485"><span class="lineNum">     485 </span>            : </a>
<a name="486"><span class="lineNum">     486 </span>            :      pushScopeStack(stmt);</a>
<a name="487"><span class="lineNum">     487 </span>            :    }</a>
<a name="488"><span class="lineNum">     488 </span>            : #endif</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">      71821 : void SageBuilder::popScopeStack()</span></a>
<a name="491"><span class="lineNum">     491 </span>            :    {</a>
<a name="492"><span class="lineNum">     492 </span>            :   // we want to warning users  double freeing happens</a>
<a name="493"><span class="lineNum">     493 </span>            :   // if (!ScopeStack.empty())</a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span>            :   // DQ (7/30/2013): Added assertion.</a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">      71821 :      ROSE_ASSERT(ScopeStack.empty() == false);</span></a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span>            : #if 0</a>
<a name="499"><span class="lineNum">     499 </span>            :      printf (&quot;Inside of SageBuilder::popScopeStack(): ScopeStack.back() = %p = %s \n&quot;,ScopeStack.back(),ScopeStack.back()-&gt;class_name().c_str());</a>
<a name="500"><span class="lineNum">     500 </span>            : #endif</a>
<a name="501"><span class="lineNum">     501 </span>            : </a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">      71821 :      ScopeStack.pop_back();</span></a>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<a name="504"><span class="lineNum">     504 </span>            : #if 0</a>
<a name="505"><span class="lineNum">     505 </span>            :   // Debugging code to output the scope stack.</a>
<a name="506"><span class="lineNum">     506 </span>            :      printf (&quot;SageBuilder::popScopeStack(): Scope stack: \n&quot;);</a>
<a name="507"><span class="lineNum">     507 </span>            :      int counter = 0;</a>
<a name="508"><span class="lineNum">     508 </span>            :      for (std::list&lt;SgScopeStatement*&gt;::iterator i = ScopeStack.begin(); i != ScopeStack.end(); i++)</a>
<a name="509"><span class="lineNum">     509 </span>            :         {</a>
<a name="510"><span class="lineNum">     510 </span>            :           printf (&quot;   --- i = %d: %p = %s \n&quot;,counter,*i,(*i)-&gt;class_name().c_str());</a>
<a name="511"><span class="lineNum">     511 </span>            :           counter++;</a>
<a name="512"><span class="lineNum">     512 </span>            :         }</a>
<a name="513"><span class="lineNum">     513 </span>            : #endif</a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">      71821 :    }</span></a>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">   16618100 : SgScopeStatement* SageBuilder::topScopeStack()</span></a>
<a name="517"><span class="lineNum">     517 </span>            :    {</a>
<a name="518"><span class="lineNum">     518 </span>            :   // DQ (9/28/2009): Test if this is an empty stack, and if so return NULL (ScopeStack.back() should be undefined for this case).</a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">   16618100 :      if (ScopeStack.empty() == true)</span></a>
<a name="520"><span class="lineNum">     520 </span>            :          return NULL;</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span>            :   // DQ (9/28/2009): This is part of testing for GNU 4.0.x (other versions of g++ work fine).</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">   16615100 :      SgScopeStatement* tempScope = ScopeStack.back();</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">   16615100 :      if (tempScope != NULL)</span></a>
<a name="525"><span class="lineNum">     525 </span>            :         {</a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">   17222700 :           tempScope-&gt;class_name();</span></a>
<a name="527"><span class="lineNum">     527 </span>            :         }</a>
<a name="528"><span class="lineNum">     528 </span>            : </a>
<a name="529"><span class="lineNum">     529 </span>            :   // return ScopeStack.back();</a>
<a name="530"><span class="lineNum">     530 </span>            :      return tempScope;</a>
<a name="531"><span class="lineNum">     531 </span>            :    }</a>
<a name="532"><span class="lineNum">     532 </span>            : </a>
<a name="533"><span class="lineNum">     533 </span>            : </a>
<a name="534"><span class="lineNum">     534 </span>            : SgScopeStatement*</a>
<a name="535"><span class="lineNum">     535 </span><span class="lineCov">     884427 : SageBuilder::getGlobalScopeFromScopeStack()</span></a>
<a name="536"><span class="lineNum">     536 </span>            :    {</a>
<a name="537"><span class="lineNum">     537 </span>            :   // This function adds new support within the internal scope stack mechanism.</a>
<a name="538"><span class="lineNum">     538 </span>            : </a>
<a name="539"><span class="lineNum">     539 </span>            :   // DQ (3/20/2017): This branch is never taken and can be reported as an error (this improves code coverage).</a>
<a name="540"><span class="lineNum">     540 </span>            :   // DQ (3/11/2012): Test if this is an empty stack, and if so return NULL (ScopeStack.back() should be undefined for this case).</a>
<a name="541"><span class="lineNum">     541 </span>            :   // if (ScopeStack.empty() == true)</a>
<a name="542"><span class="lineNum">     542 </span>            :   //      return NULL;</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">     884427 :      ROSE_ASSERT(ScopeStack.empty() == false);</span></a>
<a name="544"><span class="lineNum">     544 </span>            : </a>
<a name="545"><span class="lineNum">     545 </span>            :   // The SgGlobal scope should be the first (front) element in the list (the current scope at the end (back) of the list).</a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">     884427 :      SgScopeStatement* tempScope = ScopeStack.front();</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineCov">     884427 :      ROSE_ASSERT(isSgGlobal(tempScope) != NULL);</span></a>
<a name="548"><span class="lineNum">     548 </span>            : </a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">     884427 :      return tempScope;</span></a>
<a name="550"><span class="lineNum">     550 </span>            :    }</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span>            : #if 0</a>
<a name="553"><span class="lineNum">     553 </span>            : // DQ (3/20/2017): This function is not used.</a>
<a name="554"><span class="lineNum">     554 </span>            : bool SageBuilder::isInScopeStack(SgScopeStatement * scope) {</a>
<a name="555"><span class="lineNum">     555 </span>            :   std::list&lt;SgScopeStatement *&gt;::const_iterator it_scope_stack = ScopeStack.begin();</a>
<a name="556"><span class="lineNum">     556 </span>            :   while (it_scope_stack != ScopeStack.end()) {</a>
<a name="557"><span class="lineNum">     557 </span>            :     if (*it_scope_stack == scope) return true;</a>
<a name="558"><span class="lineNum">     558 </span>            :     it_scope_stack++;</a>
<a name="559"><span class="lineNum">     559 </span>            :   }</a>
<a name="560"><span class="lineNum">     560 </span>            :   return false;</a>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<a name="562"><span class="lineNum">     562 </span>            : #endif</a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span>            : #if 0</a>
<a name="565"><span class="lineNum">     565 </span>            : // DQ (3/20/2017): This function is not used.</a>
<a name="566"><span class="lineNum">     566 </span>            : std::string SageBuilder::stringFromScopeStack() {</a>
<a name="567"><span class="lineNum">     567 </span>            :   std::ostringstream res;</a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span>            :   std::list&lt;SgScopeStatement *&gt;::const_iterator it_scope_stack = ScopeStack.begin();</a>
<a name="570"><span class="lineNum">     570 </span>            :   while (it_scope_stack != ScopeStack.end()) {</a>
<a name="571"><span class="lineNum">     571 </span>            :     res &lt;&lt; *it_scope_stack &lt;&lt; &quot; = &quot; &lt;&lt; (*it_scope_stack)-&gt;class_name() &lt;&lt; std::endl;</a>
<a name="572"><span class="lineNum">     572 </span>            :     it_scope_stack++;</a>
<a name="573"><span class="lineNum">     573 </span>            :   }</a>
<a name="574"><span class="lineNum">     574 </span>            : </a>
<a name="575"><span class="lineNum">     575 </span>            :   return res.str();</a>
<a name="576"><span class="lineNum">     576 </span>            : }</a>
<a name="577"><span class="lineNum">     577 </span>            : #endif</a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span><span class="lineCov">      74491 : bool SageBuilder::emptyScopeStack()</span></a>
<a name="580"><span class="lineNum">     580 </span>            :    {</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">      74491 :      return ScopeStack.empty();</span></a>
<a name="582"><span class="lineNum">     582 </span>            :    }</a>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<a name="584"><span class="lineNum">     584 </span><span class="lineNoCov">          0 : void SageBuilder::clearScopeStack()</span></a>
<a name="585"><span class="lineNum">     585 </span>            :    {</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineNoCov">          0 :      ScopeStack.clear();</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span><span class="lineCov">        759 : bool SageBuilder::inSwitchScope()</span></a>
<a name="590"><span class="lineNum">     590 </span>            :    {</a>
<a name="591"><span class="lineNum">     591 </span>            :   // DQ (11/26/2012): This is used to turn off some pragma processing which is a problem in switch statements.</a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">        759 :      bool returnVar = false;</span></a>
<a name="593"><span class="lineNum">     593 </span><span class="lineCov">        759 :      std::list&lt;SgScopeStatement*&gt;::iterator i;</span></a>
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">       3561 :      for (i = ScopeStack.begin(); i != ScopeStack.end(); i++)</span></a>
<a name="595"><span class="lineNum">     595 </span>            :         {</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineCov">       2802 :           if (isSgSwitchStatement(*i) != NULL)</span></a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :                returnVar = true;</span></a>
<a name="598"><span class="lineNum">     598 </span>            :         }</a>
<a name="599"><span class="lineNum">     599 </span>            : </a>
<a name="600"><span class="lineNum">     600 </span><span class="lineCov">        759 :      return returnVar;</span></a>
<a name="601"><span class="lineNum">     601 </span>            :    }</a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span>            : #if 0</a>
<a name="604"><span class="lineNum">     604 </span>            : // DQ (3/20/2017): These functions are not used (suggest using the API in the symbol table initialization).</a>
<a name="605"><span class="lineNum">     605 </span>            : void SageBuilder::setCaseInsensitive()</a>
<a name="606"><span class="lineNum">     606 </span>            :    {</a>
<a name="607"><span class="lineNum">     607 </span>            :      symbol_table_case_insensitive_semantics = true;</a>
<a name="608"><span class="lineNum">     608 </span>            :    }</a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            : // DQ (3/20/2017): These functions are not used (suggest using the API in the symbol table initialization).</a>
<a name="611"><span class="lineNum">     611 </span>            : void SageBuilder::setCaseSensitive()</a>
<a name="612"><span class="lineNum">     612 </span>            :    {</a>
<a name="613"><span class="lineNum">     613 </span>            :      symbol_table_case_insensitive_semantics = false;</a>
<a name="614"><span class="lineNum">     614 </span>            :    }</a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span>            : // DQ (3/20/2017): These functions are not used (suggest using the API in the symbol table initialization).</a>
<a name="617"><span class="lineNum">     617 </span>            : void SageBuilder::setCaseFromScope(SgScopeStatement* scope)</a>
<a name="618"><span class="lineNum">     618 </span>            :    {</a>
<a name="619"><span class="lineNum">     619 </span>            :      ROSE_ASSERT(scope != NULL);</a>
<a name="620"><span class="lineNum">     620 </span>            : </a>
<a name="621"><span class="lineNum">     621 </span>            :      symbol_table_case_insensitive_semantics = scope-&gt;isCaseInsensitive();</a>
<a name="622"><span class="lineNum">     622 </span>            :    }</a>
<a name="623"><span class="lineNum">     623 </span>            : #endif</a>
<a name="624"><span class="lineNum">     624 </span>            : </a>
<a name="625"><span class="lineNum">     625 </span>            : </a>
<a name="626"><span class="lineNum">     626 </span>            : // *******************************************************************************</a>
<a name="627"><span class="lineNum">     627 </span>            : // *******************************  Build Functions  *****************************</a>
<a name="628"><span class="lineNum">     628 </span>            : // *******************************************************************************</a>
<a name="629"><span class="lineNum">     629 </span>            : SgName</a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">     104982 : SageBuilder::appendTemplateArgumentsToName( const SgName &amp; name, const SgTemplateArgumentPtrList &amp; templateArgumentsList)</span></a>
<a name="631"><span class="lineNum">     631 </span>            :    {</a>
<a name="632"><span class="lineNum">     632 </span>            :   // DQ (7/23/2012): This function is somewhat redundant with the SgDeclarationStatement::resetTemplateNameSupport() in that</a>
<a name="633"><span class="lineNum">     633 </span>            :   // they both have to generate identical names.  this was a problem and thus this code is seneitive to &quot; ,&quot; instead of &quot;,&quot;</a>
<a name="634"><span class="lineNum">     634 </span>            :   // below.</a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span>            :   // DQ (7/23/2012): This is one of three locations where the template arguments are assembled and where</a>
<a name="637"><span class="lineNum">     637 </span>            :   // the name generated identically (in each case) is critical.  Not clear how to best refactor this code.</a>
<a name="638"><span class="lineNum">     638 </span>            :   // The other two are:</a>
<a name="639"><span class="lineNum">     639 </span>            :   //      Unparse_ExprStmt::unparseTemplateArgumentList()</a>
<a name="640"><span class="lineNum">     640 </span>            :   // and in:</a>
<a name="641"><span class="lineNum">     641 </span>            :   //      void SgDeclarationStatement::resetTemplateNameSupport ( bool &amp; nameResetFromMangledForm, SgName &amp; name )</a>
<a name="642"><span class="lineNum">     642 </span>            :   // It is less clear how to refactor this code.</a>
<a name="643"><span class="lineNum">     643 </span>            : </a>
<a name="644"><span class="lineNum">     644 </span>            : #define DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST 0</a>
<a name="645"><span class="lineNum">     645 </span>            : </a>
<a name="646"><span class="lineNum">     646 </span>            : #if DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST</a>
<a name="647"><span class="lineNum">     647 </span>            :      printf (&quot;In SageBuilder::appendTemplateArgumentsToName(): CRITICAL FUNCTION TO BE REFACTORED (name = %s) \n&quot;,name.str());</a>
<a name="648"><span class="lineNum">     648 </span>            : #endif</a>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<a name="650"><span class="lineNum">     650 </span>            :   // DQ (3/10/2018): This is now partially redundant with SgTemplateArgumentList::unparseToStringSupport().</a>
<a name="651"><span class="lineNum">     651 </span>            : #if 0</a>
<a name="652"><span class="lineNum">     652 </span>            :      printf (&quot;In SageBuilder::appendTemplateArgumentsToName: this is now partially redundant with SgTemplateArgumentList::unparseToStringSupport() \n&quot;);</a>
<a name="653"><span class="lineNum">     653 </span>            : #endif</a>
<a name="654"><span class="lineNum">     654 </span>            : </a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">     104982 :      SgUnparse_Info *info = new SgUnparse_Info();</span></a>
<a name="656"><span class="lineNum">     656 </span><span class="lineCov">     104982 :      ROSE_ASSERT(info != NULL);</span></a>
<a name="657"><span class="lineNum">     657 </span>            : </a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">     104982 :      info-&gt;set_language(SgFile::e_Cxx_language);</span></a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">     104982 :      info-&gt;set_requiresGlobalNameQualification();</span></a>
<a name="660"><span class="lineNum">     660 </span>            : </a>
<a name="661"><span class="lineNum">     661 </span>            :   // DQ (4/28/2017): For template arguments we never want to output the definitions of classes, and enums.</a>
<a name="662"><span class="lineNum">     662 </span><span class="lineCov">     104982 :      info-&gt;set_SkipClassDefinition();</span></a>
<a name="663"><span class="lineNum">     663 </span><span class="lineCov">     104982 :      info-&gt;set_SkipEnumDefinition();</span></a>
<a name="664"><span class="lineNum">     664 </span><span class="lineCov">     104982 :      info-&gt;set_use_generated_name_for_template_arguments(true);</span></a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">     104982 :      bool emptyArgumentList = templateArgumentsList.empty();</span></a>
<a name="667"><span class="lineNum">     667 </span>            : </a>
<a name="668"><span class="lineNum">     668 </span>            :   // DQ (9/24/2012): Don't add &quot;&lt; &gt;&quot; if there are no template arguments (see test2012_221.C).</a>
<a name="669"><span class="lineNum">     669 </span>            :   // SgName returnName = name + &quot; &lt; &quot;;</a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">     104982 :      SgName returnName = name;</span></a>
<a name="671"><span class="lineNum">     671 </span><span class="lineCov">     104982 :      if (emptyArgumentList == false)</span></a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">      48521 :           returnName += &quot; &lt; &quot;;</span></a>
<a name="673"><span class="lineNum">     673 </span>            : </a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">     104982 :      SgTemplateArgumentPtrList::const_iterator i = templateArgumentsList.begin();</span></a>
<a name="675"><span class="lineNum">     675 </span><span class="lineCov">     104982 :      bool need_separator = false;</span></a>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">     186755 :      while (i != templateArgumentsList.end())</span></a>
<a name="677"><span class="lineNum">     677 </span>            :         {</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">      81773 :           if ((*i)-&gt;get_argumentType() == SgTemplateArgument::start_of_pack_expansion_argument)</span></a>
<a name="679"><span class="lineNum">     679 </span>            :              {</a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">       4805 :                i++;</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">       4805 :                continue;</span></a>
<a name="682"><span class="lineNum">     682 </span>            :              }</a>
<a name="683"><span class="lineNum">     683 </span>            : </a>
<a name="684"><span class="lineNum">     684 </span><span class="lineCov">      76968 :           if (need_separator)</span></a>
<a name="685"><span class="lineNum">     685 </span>            :              {</a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">      28697 :                returnName += &quot; , &quot;;</span></a>
<a name="687"><span class="lineNum">     687 </span>            :              }</a>
<a name="688"><span class="lineNum">     688 </span>            : </a>
<a name="689"><span class="lineNum">     689 </span>            : #if DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST</a>
<a name="690"><span class="lineNum">     690 </span>            :           printf (&quot;In SageBuilder::appendTemplateArgumentsToName(): (top of loop) templateArgumentsList element *i = %p = %s returnName = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),returnName.str());</a>
<a name="691"><span class="lineNum">     691 </span>            : #endif</a>
<a name="692"><span class="lineNum">     692 </span>            : #if 0</a>
<a name="693"><span class="lineNum">     693 </span>            :           string s = string(&quot;/* templateArgument is explicitlySpecified = &quot;) + (((*i)-&gt;get_explicitlySpecified() == true) ? &quot;true&quot; : &quot;false&quot;) + &quot; */&quot;;</a>
<a name="694"><span class="lineNum">     694 </span>            : #endif</a>
<a name="695"><span class="lineNum">     695 </span>            : </a>
<a name="696"><span class="lineNum">     696 </span>            :        // DQ (9/15/2012): We need to communicate that the language so that SgBoolVal will not be unparsed to &quot;1&quot; instead of &quot;true&quot; (see test2012_215.C).</a>
<a name="697"><span class="lineNum">     697 </span>            :        // Calling the unparseToString (SgUnparse_Info *info) function instead of the version not taking an argument.</a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">      76968 :           returnName += (*i)-&gt;unparseToString(info);</span></a>
<a name="699"><span class="lineNum">     699 </span>            : </a>
<a name="700"><span class="lineNum">     700 </span>            : #if DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST</a>
<a name="701"><span class="lineNum">     701 </span>            :           printf (&quot;In SageBuilder::appendTemplateArgumentsToName(): (after appending template name) *i = %p returnName = %s \n&quot;,*i,returnName.str());</a>
<a name="702"><span class="lineNum">     702 </span>            : #endif</a>
<a name="703"><span class="lineNum">     703 </span><span class="lineCov">      76968 :           need_separator = true;</span></a>
<a name="704"><span class="lineNum">     704 </span><span class="lineCov">      76968 :           i++;</span></a>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<a name="706"><span class="lineNum">     706 </span>            : #if DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST</a>
<a name="707"><span class="lineNum">     707 </span>            :           printf (&quot;In SageBuilder::appendTemplateArgumentsToName(): (bottom of loop) returnName = %s \n&quot;,returnName.str());</a>
<a name="708"><span class="lineNum">     708 </span>            : #endif</a>
<a name="709"><span class="lineNum">     709 </span>            :         }</a>
<a name="710"><span class="lineNum">     710 </span>            : </a>
<a name="711"><span class="lineNum">     711 </span>            :   // DQ (9/24/2012): Don't add &quot;&lt; &gt;&quot; if there are no templte arguments.</a>
<a name="712"><span class="lineNum">     712 </span>            :   // returnName += &quot; &gt; &quot;;</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">     104982 :      if (emptyArgumentList == false)</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">      48521 :           returnName += &quot; &gt; &quot;;</span></a>
<a name="715"><span class="lineNum">     715 </span>            : </a>
<a name="716"><span class="lineNum">     716 </span>            : #if DEBUG_APPEND_TEMPLATE_ARGUMENT_LIST</a>
<a name="717"><span class="lineNum">     717 </span>            :      printf (&quot;Leaving SageBuilder::appendTemplateArgumentsToName(): returnName = %s \n&quot;,returnName.str());</a>
<a name="718"><span class="lineNum">     718 </span>            : #endif</a>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">     104982 :      delete info;</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">     104982 :      info = NULL;</span></a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span>            : #if 0</a>
<a name="724"><span class="lineNum">     724 </span>            :   // DQ (4/2/2018): Debugging cae of template instantiation function appearing in std namespace with two symbols.</a>
<a name="725"><span class="lineNum">     725 </span>            :      if (name == &quot;getline&quot;)</a>
<a name="726"><span class="lineNum">     726 </span>            :         {</a>
<a name="727"><span class="lineNum">     727 </span>            :           printf (&quot;Leaving SageBuilder::appendTemplateArgumentsToName(): Found input function named: name = %s returnName = %s \n&quot;,name.str(),returnName.str());</a>
<a name="728"><span class="lineNum">     728 </span>            :         }</a>
<a name="729"><span class="lineNum">     729 </span>            : #endif</a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span><span class="lineCov">     104982 :      return returnName;</span></a>
<a name="732"><span class="lineNum">     732 </span>            :    }</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            : </a>
<a name="735"><span class="lineNum">     735 </span>            : SgName</a>
<a name="736"><span class="lineNum">     736 </span><span class="lineNoCov">          0 : SageBuilder::unparseTemplateArgumentToString (SgTemplateArgument* templateArgument)</span></a>
<a name="737"><span class="lineNum">     737 </span>            :    {</a>
<a name="738"><span class="lineNum">     738 </span>            :   // DQ (3/10/2018): This is now redundant with SgTemplateArgument::unparseToStringSupport().</a>
<a name="739"><span class="lineNum">     739 </span>            :   // DQ (3/9/2018): Added function to support debugging.</a>
<a name="740"><span class="lineNum">     740 </span>            : </a>
<a name="741"><span class="lineNum">     741 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(templateArgument != NULL);</span></a>
<a name="742"><span class="lineNum">     742 </span>            : </a>
<a name="743"><span class="lineNum">     743 </span>            : #if 0</a>
<a name="744"><span class="lineNum">     744 </span>            :      printf (&quot;In SageBuilder::unparseTemplateArgumentToString: this is redundant with SgTemplateArgument::unparseToStringSupport() \n&quot;);</a>
<a name="745"><span class="lineNum">     745 </span>            : #endif</a>
<a name="746"><span class="lineNum">     746 </span>            : </a>
<a name="747"><span class="lineNum">     747 </span><span class="lineNoCov">          0 :      SgUnparse_Info *info = new SgUnparse_Info();</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(info != NULL);</span></a>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<a name="750"><span class="lineNum">     750 </span><span class="lineNoCov">          0 :      info-&gt;set_language(SgFile::e_Cxx_language);</span></a>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<a name="752"><span class="lineNum">     752 </span>            :   // DQ (4/28/2017): For template arguments we never want to output the definitions of classes, and enums.</a>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 :      info-&gt;set_SkipClassDefinition();</span></a>
<a name="754"><span class="lineNum">     754 </span><span class="lineNoCov">          0 :      info-&gt;set_SkipEnumDefinition();</span></a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :      info-&gt;set_use_generated_name_for_template_arguments(true);</span></a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span><span class="lineNoCov">          0 :      SgName returnName = templateArgument-&gt;unparseToString(info);</span></a>
<a name="758"><span class="lineNum">     758 </span>            : </a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :      delete info;</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :      info = NULL;</span></a>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<a name="762"><span class="lineNum">     762 </span><span class="lineNoCov">          0 :      return returnName;</span></a>
<a name="763"><span class="lineNum">     763 </span>            :    }</a>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<a name="765"><span class="lineNum">     765 </span>            : </a>
<a name="766"><span class="lineNum">     766 </span>            : SgTemplateArgumentPtrList*</a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">    2360250 : SageBuilder::getTemplateArgumentList( SgDeclarationStatement* decl )</span></a>
<a name="768"><span class="lineNum">     768 </span>            :    {</a>
<a name="769"><span class="lineNum">     769 </span>            :   // DQ (9/13/2012): This function returns the SgTemplateArgumentPtrList. Both template declarations and template instanatiations have them.</a>
<a name="770"><span class="lineNum">     770 </span>            :   // In a template instantiation it is the templateArguments field and from template declarations it is the templateSpecializationArguments field.</a>
<a name="771"><span class="lineNum">     771 </span>            : </a>
<a name="772"><span class="lineNum">     772 </span><span class="lineCov">    2360250 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span>            : #if 0</a>
<a name="775"><span class="lineNum">     775 </span>            :      printf (&quot;In SageBuilder::getTemplateArgumentList(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="776"><span class="lineNum">     776 </span>            : #endif</a>
<a name="777"><span class="lineNum">     777 </span>            : </a>
<a name="778"><span class="lineNum">     778 </span><span class="lineCov">    2360250 :      SgTemplateArgumentPtrList* templateArgumentsList = NULL;</span></a>
<a name="779"><span class="lineNum">     779 </span>            : </a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">    2360250 :      switch(decl-&gt;variantT())</span></a>
<a name="781"><span class="lineNum">     781 </span>            :         {</a>
<a name="782"><span class="lineNum">     782 </span>            :        // DQ (4/9/2018): Added support for namespace alias.</a>
<a name="783"><span class="lineNum">     783 </span>            :           case V_SgNamespaceAliasDeclarationStatement:</a>
<a name="784"><span class="lineNum">     784 </span>            :        // DQ (8/17/2013): These cases do not use templates.</a>
<a name="785"><span class="lineNum">     785 </span>            :        // This function has to handle these cases because it is called in a general context</a>
<a name="786"><span class="lineNum">     786 </span>            :        // on many types of declarations as part of the name qualification support.</a>
<a name="787"><span class="lineNum">     787 </span>            :           case V_SgNamespaceDeclarationStatement:</a>
<a name="788"><span class="lineNum">     788 </span>            :           case V_SgEnumDeclaration:</a>
<a name="789"><span class="lineNum">     789 </span>            :           case V_SgVariableDeclaration:</a>
<a name="790"><span class="lineNum">     790 </span>            :           case V_SgTypedefDeclaration:</a>
<a name="791"><span class="lineNum">     791 </span>            :              {</a>
<a name="792"><span class="lineNum">     792 </span>            :                templateArgumentsList = NULL;</a>
<a name="793"><span class="lineNum">     793 </span>            :                break;</a>
<a name="794"><span class="lineNum">     794 </span>            :              }</a>
<a name="795"><span class="lineNum">     795 </span>            : </a>
<a name="796"><span class="lineNum">     796 </span>            :        // DQ (8/11/2013): Added cases for SgFunctionDeclaration and SgMemberFunctionDeclaration</a>
<a name="797"><span class="lineNum">     797 </span>            :        // I forget why we needed this case...</a>
<a name="798"><span class="lineNum">     798 </span>            :           case V_SgProcedureHeaderStatement:</a>
<a name="799"><span class="lineNum">     799 </span>            :           case V_SgFunctionDeclaration:</a>
<a name="800"><span class="lineNum">     800 </span>            :           case V_SgMemberFunctionDeclaration:</a>
<a name="801"><span class="lineNum">     801 </span>            :           case V_SgClassDeclaration:</a>
<a name="802"><span class="lineNum">     802 </span>            :              {</a>
<a name="803"><span class="lineNum">     803 </span>            :                templateArgumentsList = NULL;</a>
<a name="804"><span class="lineNum">     804 </span>            :                break;</a>
<a name="805"><span class="lineNum">     805 </span>            :              }</a>
<a name="806"><span class="lineNum">     806 </span>            : </a>
<a name="807"><span class="lineNum">     807 </span><span class="lineCov">     216980 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="808"><span class="lineNum">     808 </span><span class="lineCov">     216980 :              {</span></a>
<a name="809"><span class="lineNum">     809 </span>            : #if 0</a>
<a name="810"><span class="lineNum">     810 </span>            :                printf (&quot;In SageBuilder::getTemplateArgumentList(): templateArguments = %s \n&quot;,isSgTemplateInstantiationDecl(decl)-&gt;unparseNameToString().c_str());</a>
<a name="811"><span class="lineNum">     811 </span>            : #endif</a>
<a name="812"><span class="lineNum">     812 </span><span class="lineCov">     216980 :                templateArgumentsList = &amp;(isSgTemplateInstantiationDecl(decl)-&gt;get_templateArguments());</span></a>
<a name="813"><span class="lineNum">     813 </span><span class="lineCov">     216980 :                break;</span></a>
<a name="814"><span class="lineNum">     814 </span>            :              }</a>
<a name="815"><span class="lineNum">     815 </span>            : </a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">      89316 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="817"><span class="lineNum">     817 </span><span class="lineCov">      89316 :              {</span></a>
<a name="818"><span class="lineNum">     818 </span><span class="lineCov">      89316 :                templateArgumentsList = &amp;(isSgTemplateClassDeclaration(decl)-&gt;get_templateSpecializationArguments());</span></a>
<a name="819"><span class="lineNum">     819 </span><span class="lineCov">      89316 :                break;</span></a>
<a name="820"><span class="lineNum">     820 </span>            :              }</a>
<a name="821"><span class="lineNum">     821 </span>            : </a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">      15971 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineCov">      15971 :              {</span></a>
<a name="824"><span class="lineNum">     824 </span><span class="lineCov">      15971 :                templateArgumentsList = &amp;(isSgTemplateInstantiationFunctionDecl(decl)-&gt;get_templateArguments());</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineCov">      15971 :                break;</span></a>
<a name="826"><span class="lineNum">     826 </span>            :              }</a>
<a name="827"><span class="lineNum">     827 </span>            : </a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">       4341 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">       4341 :              {</span></a>
<a name="830"><span class="lineNum">     830 </span><span class="lineCov">       4341 :                templateArgumentsList = &amp;(isSgTemplateFunctionDeclaration(decl)-&gt;get_templateSpecializationArguments());</span></a>
<a name="831"><span class="lineNum">     831 </span><span class="lineCov">       4341 :                break;</span></a>
<a name="832"><span class="lineNum">     832 </span>            :              }</a>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<a name="834"><span class="lineNum">     834 </span><span class="lineCov">      80408 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineCov">      80408 :              {</span></a>
<a name="836"><span class="lineNum">     836 </span><span class="lineCov">      80408 :                templateArgumentsList = &amp;(isSgTemplateInstantiationMemberFunctionDecl(decl)-&gt;get_templateArguments());</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineCov">      80408 :                break;</span></a>
<a name="838"><span class="lineNum">     838 </span>            :              }</a>
<a name="839"><span class="lineNum">     839 </span>            : </a>
<a name="840"><span class="lineNum">     840 </span><span class="lineCov">      13335 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="841"><span class="lineNum">     841 </span><span class="lineCov">      13335 :              {</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">      13335 :                templateArgumentsList = &amp;(isSgTemplateMemberFunctionDeclaration(decl)-&gt;get_templateSpecializationArguments());</span></a>
<a name="843"><span class="lineNum">     843 </span><span class="lineCov">      13335 :                break;</span></a>
<a name="844"><span class="lineNum">     844 </span>            :              }</a>
<a name="845"><span class="lineNum">     845 </span>            : </a>
<a name="846"><span class="lineNum">     846 </span><span class="lineCov">       1143 :           case V_SgTemplateVariableDeclaration:</span></a>
<a name="847"><span class="lineNum">     847 </span><span class="lineCov">       1143 :              {</span></a>
<a name="848"><span class="lineNum">     848 </span><span class="lineCov">       1143 :                templateArgumentsList = &amp;(isSgTemplateVariableDeclaration(decl)-&gt;get_templateSpecializationArguments());</span></a>
<a name="849"><span class="lineNum">     849 </span><span class="lineCov">       1143 :                break;</span></a>
<a name="850"><span class="lineNum">     850 </span>            :              }</a>
<a name="851"><span class="lineNum">     851 </span>            : </a>
<a name="852"><span class="lineNum">     852 </span>            :        // DQ (11/10/2014): Added support for template typedef declarations.</a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">        302 :           case V_SgTemplateTypedefDeclaration:</span></a>
<a name="854"><span class="lineNum">     854 </span><span class="lineCov">        302 :              {</span></a>
<a name="855"><span class="lineNum">     855 </span><span class="lineCov">        302 :                templateArgumentsList = &amp;(isSgTemplateTypedefDeclaration(decl)-&gt;get_templateSpecializationArguments());</span></a>
<a name="856"><span class="lineNum">     856 </span><span class="lineCov">        302 :                break;</span></a>
<a name="857"><span class="lineNum">     857 </span>            :              }</a>
<a name="858"><span class="lineNum">     858 </span>            : </a>
<a name="859"><span class="lineNum">     859 </span>            :        // DQ (11/10/2014): Added support for template typedef declarations.</a>
<a name="860"><span class="lineNum">     860 </span><span class="lineCov">       4350 :           case V_SgTemplateInstantiationTypedefDeclaration:</span></a>
<a name="861"><span class="lineNum">     861 </span><span class="lineCov">       4350 :              {</span></a>
<a name="862"><span class="lineNum">     862 </span><span class="lineCov">       4350 :                templateArgumentsList = &amp;(isSgTemplateInstantiationTypedefDeclaration(decl)-&gt;get_templateArguments());</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineCov">       4350 :                break;</span></a>
<a name="864"><span class="lineNum">     864 </span>            :              }</a>
<a name="865"><span class="lineNum">     865 </span>            : </a>
<a name="866"><span class="lineNum">     866 </span>            :           case V_SgTemplateDeclaration:</a>
<a name="867"><span class="lineNum">     867 </span>            :              {</a>
<a name="868"><span class="lineNum">     868 </span>            :                templateArgumentsList = NULL;</a>
<a name="869"><span class="lineNum">     869 </span>            :                break;</a>
<a name="870"><span class="lineNum">     870 </span>            :              }</a>
<a name="871"><span class="lineNum">     871 </span>            : #if 0</a>
<a name="872"><span class="lineNum">     872 </span>            :      // DQ (12/14/2016): Added new case</a>
<a name="873"><span class="lineNum">     873 </span>            :         case V_SgFunctionDeclaration:</a>
<a name="874"><span class="lineNum">     874 </span>            :              {</a>
<a name="875"><span class="lineNum">     875 </span>            :                SgFunctionDeclaration* function_declaration = isSgFunctionDeclaration(decl);</a>
<a name="876"><span class="lineNum">     876 </span>            :                printf (&quot;In SageBuilder::getTemplateArgumentList(): function name = %s \n&quot;,function_declaration-&gt;get_name().str());</a>
<a name="877"><span class="lineNum">     877 </span>            : </a>
<a name="878"><span class="lineNum">     878 </span>            :                function_declaration-&gt;get_file_info()-&gt;display(&quot;Not clear that we should need this case since there would not be any template arguments: debug&quot;);</a>
<a name="879"><span class="lineNum">     879 </span>            : </a>
<a name="880"><span class="lineNum">     880 </span>            :                printf (&quot;Error: Not clear that we should need this case since there would not be any template arguments \n&quot;);</a>
<a name="881"><span class="lineNum">     881 </span>            :                ROSE_ABORT();</a>
<a name="882"><span class="lineNum">     882 </span>            :                break;</a>
<a name="883"><span class="lineNum">     883 </span>            :              }</a>
<a name="884"><span class="lineNum">     884 </span>            : #endif</a>
<a name="885"><span class="lineNum">     885 </span>            : </a>
<a name="886"><span class="lineNum">     886 </span><span class="lineCov">      48318 :           case V_SgNonrealDecl:</span></a>
<a name="887"><span class="lineNum">     887 </span><span class="lineCov">      48318 :              {</span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineCov">      48318 :                templateArgumentsList = &amp;(isSgNonrealDecl(decl)-&gt;get_tpl_args());</span></a>
<a name="889"><span class="lineNum">     889 </span><span class="lineCov">      48318 :                break;</span></a>
<a name="890"><span class="lineNum">     890 </span>            :              }</a>
<a name="891"><span class="lineNum">     891 </span>            : </a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="893"><span class="lineNum">     893 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="894"><span class="lineNum">     894 </span><span class="lineNoCov">          0 :                printf (&quot;getTemplateArgumentList(): Default reached in switch: decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</span></a>
<a name="895"><span class="lineNum">     895 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="896"><span class="lineNum">     896 </span>            :              }</a>
<a name="897"><span class="lineNum">     897 </span>            :         }</a>
<a name="898"><span class="lineNum">     898 </span>            : </a>
<a name="899"><span class="lineNum">     899 </span>            :   // DQ (9/16/2012): We would like to support this test, if possible.</a>
<a name="900"><span class="lineNum">     900 </span>            :   // ROSE_ASSERT(templateParameterList != NULL);</a>
<a name="901"><span class="lineNum">     901 </span>            : </a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">    2360250 :      return templateArgumentsList;</span></a>
<a name="903"><span class="lineNum">     903 </span>            :    }</a>
<a name="904"><span class="lineNum">     904 </span>            : </a>
<a name="905"><span class="lineNum">     905 </span>            : </a>
<a name="906"><span class="lineNum">     906 </span>            : </a>
<a name="907"><span class="lineNum">     907 </span>            : SgTemplateParameterPtrList*</a>
<a name="908"><span class="lineNum">     908 </span><span class="lineCov">    2192150 : SageBuilder::getTemplateParameterList( SgDeclarationStatement* decl )</span></a>
<a name="909"><span class="lineNum">     909 </span>            :    {</a>
<a name="910"><span class="lineNum">     910 </span>            :   // DQ (9/16/2012): This function returns the SgTemplateParameterPtrList that is associated with template declarations.</a>
<a name="911"><span class="lineNum">     911 </span>            :   // For all other cases it returns NULL (or is an error).</a>
<a name="912"><span class="lineNum">     912 </span>            : </a>
<a name="913"><span class="lineNum">     913 </span><span class="lineCov">    2192150 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="914"><span class="lineNum">     914 </span>            : </a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">    2192150 :      SgTemplateParameterPtrList* templateParameterList = NULL;</span></a>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<a name="917"><span class="lineNum">     917 </span>            : #if 0</a>
<a name="918"><span class="lineNum">     918 </span>            :      printf (&quot;In SageBuilder::getTemplateParameterList(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="919"><span class="lineNum">     919 </span>            : #endif</a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">    2192150 :      switch(decl-&gt;variantT())</span></a>
<a name="922"><span class="lineNum">     922 </span>            :         {</a>
<a name="923"><span class="lineNum">     923 </span>            :        // DQ (4/9/2018): Added support for namespace alias.</a>
<a name="924"><span class="lineNum">     924 </span>            :           case V_SgNamespaceAliasDeclarationStatement:</a>
<a name="925"><span class="lineNum">     925 </span>            :        // DQ (8/17/2013): These cases do not use templates.</a>
<a name="926"><span class="lineNum">     926 </span>            :        // This function has to handle these cases because it is called in a general context</a>
<a name="927"><span class="lineNum">     927 </span>            :        // on many types of declarations as part of the name qualification support.</a>
<a name="928"><span class="lineNum">     928 </span>            :           case V_SgNamespaceDeclarationStatement:</a>
<a name="929"><span class="lineNum">     929 </span>            :           case V_SgEnumDeclaration:</a>
<a name="930"><span class="lineNum">     930 </span>            :           case V_SgVariableDeclaration:</a>
<a name="931"><span class="lineNum">     931 </span>            :           case V_SgTypedefDeclaration:</a>
<a name="932"><span class="lineNum">     932 </span>            :              {</a>
<a name="933"><span class="lineNum">     933 </span>            :                templateParameterList = NULL;</a>
<a name="934"><span class="lineNum">     934 </span>            :                break;</a>
<a name="935"><span class="lineNum">     935 </span>            :              }</a>
<a name="936"><span class="lineNum">     936 </span>            : </a>
<a name="937"><span class="lineNum">     937 </span>            :        // DQ (8/12/2013): This function has to be supported when called using any kind of declaration (at least SgFunctionDeclaration and SgClassDeclaration).</a>
<a name="938"><span class="lineNum">     938 </span>            :        // DQ (9/16/2012): I think it should be an error to call this function for a SgClassDeclaration.</a>
<a name="939"><span class="lineNum">     939 </span>            :           case V_SgProcedureHeaderStatement:</a>
<a name="940"><span class="lineNum">     940 </span>            :           case V_SgFunctionDeclaration:</a>
<a name="941"><span class="lineNum">     941 </span>            :           case V_SgMemberFunctionDeclaration:</a>
<a name="942"><span class="lineNum">     942 </span>            :           case V_SgClassDeclaration:</a>
<a name="943"><span class="lineNum">     943 </span>            :              {</a>
<a name="944"><span class="lineNum">     944 </span>            :                templateParameterList = NULL;</a>
<a name="945"><span class="lineNum">     945 </span>            :                break;</a>
<a name="946"><span class="lineNum">     946 </span>            :              }</a>
<a name="947"><span class="lineNum">     947 </span>            : </a>
<a name="948"><span class="lineNum">     948 </span>            :        // DQ (11/10/2014): Added support for template typedef declarations.</a>
<a name="949"><span class="lineNum">     949 </span>            :           case V_SgTemplateInstantiationTypedefDeclaration:</a>
<a name="950"><span class="lineNum">     950 </span>            : </a>
<a name="951"><span class="lineNum">     951 </span>            :        // DQ (8/12/2013): This function has to be supported when called using any kind of declaration (at least SgFunctionDeclaration and SgClassDeclaration).</a>
<a name="952"><span class="lineNum">     952 </span>            :        // DQ (9/16/2012): I think it should be an error to call this function for these types of declarations.</a>
<a name="953"><span class="lineNum">     953 </span>            :           case V_SgTemplateInstantiationDecl:</a>
<a name="954"><span class="lineNum">     954 </span>            :           case V_SgTemplateInstantiationFunctionDecl:</a>
<a name="955"><span class="lineNum">     955 </span>            :           case V_SgTemplateInstantiationMemberFunctionDecl:</a>
<a name="956"><span class="lineNum">     956 </span>            :              {</a>
<a name="957"><span class="lineNum">     957 </span>            :                templateParameterList = NULL;</a>
<a name="958"><span class="lineNum">     958 </span>            :                break;</a>
<a name="959"><span class="lineNum">     959 </span>            :              }</a>
<a name="960"><span class="lineNum">     960 </span>            : </a>
<a name="961"><span class="lineNum">     961 </span><span class="lineCov">      52598 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">      52598 :              {</span></a>
<a name="963"><span class="lineNum">     963 </span><span class="lineCov">      52598 :                templateParameterList = &amp;(isSgTemplateClassDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="964"><span class="lineNum">     964 </span><span class="lineCov">      52598 :                break;</span></a>
<a name="965"><span class="lineNum">     965 </span>            :              }</a>
<a name="966"><span class="lineNum">     966 </span>            : </a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">      32077 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineCov">      32077 :              {</span></a>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">      32077 :                templateParameterList = &amp;(isSgTemplateFunctionDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="970"><span class="lineNum">     970 </span><span class="lineCov">      32077 :                break;</span></a>
<a name="971"><span class="lineNum">     971 </span>            :              }</a>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<a name="973"><span class="lineNum">     973 </span><span class="lineCov">      85079 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="974"><span class="lineNum">     974 </span><span class="lineCov">      85079 :              {</span></a>
<a name="975"><span class="lineNum">     975 </span><span class="lineCov">      85079 :                templateParameterList = &amp;(isSgTemplateMemberFunctionDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="976"><span class="lineNum">     976 </span><span class="lineCov">      85079 :                break;</span></a>
<a name="977"><span class="lineNum">     977 </span>            :              }</a>
<a name="978"><span class="lineNum">     978 </span>            : </a>
<a name="979"><span class="lineNum">     979 </span><span class="lineCov">       1143 :           case V_SgTemplateVariableDeclaration:</span></a>
<a name="980"><span class="lineNum">     980 </span><span class="lineCov">       1143 :              {</span></a>
<a name="981"><span class="lineNum">     981 </span><span class="lineCov">       1143 :                templateParameterList = &amp;(isSgTemplateVariableDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="982"><span class="lineNum">     982 </span><span class="lineCov">       1143 :                break;</span></a>
<a name="983"><span class="lineNum">     983 </span>            :              }</a>
<a name="984"><span class="lineNum">     984 </span>            : </a>
<a name="985"><span class="lineNum">     985 </span>            :        // DQ (11/10/2014): Added support for template typedef declarations.</a>
<a name="986"><span class="lineNum">     986 </span><span class="lineCov">        302 :           case V_SgTemplateTypedefDeclaration:</span></a>
<a name="987"><span class="lineNum">     987 </span><span class="lineCov">        302 :              {</span></a>
<a name="988"><span class="lineNum">     988 </span><span class="lineCov">        302 :                templateParameterList = &amp;(isSgTemplateTypedefDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="989"><span class="lineNum">     989 </span><span class="lineCov">        302 :                break;</span></a>
<a name="990"><span class="lineNum">     990 </span>            :              }</a>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<a name="992"><span class="lineNum">     992 </span><span class="lineCov">      48318 :           case V_SgNonrealDecl:</span></a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">      48318 :              {</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineCov">      48318 :                templateParameterList = &amp;(isSgNonrealDecl(decl)-&gt;get_tpl_params());</span></a>
<a name="995"><span class="lineNum">     995 </span><span class="lineCov">      48318 :                break;</span></a>
<a name="996"><span class="lineNum">     996 </span>            :              }</a>
<a name="997"><span class="lineNum">     997 </span>            : </a>
<a name="998"><span class="lineNum">     998 </span><span class="lineNoCov">          0 :           case V_SgTemplateDeclaration:</span></a>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineNoCov">          0 :                templateParameterList = &amp;(isSgTemplateDeclaration(decl)-&gt;get_templateParameters());</span></a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1002"><span class="lineNum">    1002 </span>            :              }</a>
<a name="1003"><span class="lineNum">    1003 </span>            : </a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                printf (&quot;getTemplateParameterList(): Default reached in switch: decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</span></a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1008"><span class="lineNum">    1008 </span>            :              }</a>
<a name="1009"><span class="lineNum">    1009 </span>            :         }</a>
<a name="1010"><span class="lineNum">    1010 </span>            : </a>
<a name="1011"><span class="lineNum">    1011 </span>            :   // DQ (9/16/2012): We would like to support this test, if possible.</a>
<a name="1012"><span class="lineNum">    1012 </span>            :   // ROSE_ASSERT(templateParameterList != NULL);</a>
<a name="1013"><span class="lineNum">    1013 </span>            : </a>
<a name="1014"><span class="lineNum">    1014 </span><span class="lineCov">    2192150 :      return templateParameterList;</span></a>
<a name="1015"><span class="lineNum">    1015 </span>            :    }</a>
<a name="1016"><span class="lineNum">    1016 </span>            : </a>
<a name="1017"><span class="lineNum">    1017 </span>            : </a>
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<a name="1019"><span class="lineNum">    1019 </span>            : void</a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineCov">      39662 : SageBuilder::setTemplateArgumentParents( SgDeclarationStatement* decl )</span></a>
<a name="1021"><span class="lineNum">    1021 </span>            :    {</a>
<a name="1022"><span class="lineNum">    1022 </span>            :   // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).</a>
<a name="1023"><span class="lineNum">    1023 </span>            : </a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineCov">      39662 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<a name="1026"><span class="lineNum">    1026 </span>            : #if 0</a>
<a name="1027"><span class="lineNum">    1027 </span>            :      printf (&quot;In setTemplateArgumentParents(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1028"><span class="lineNum">    1028 </span>            : #endif</a>
<a name="1029"><span class="lineNum">    1029 </span>            : </a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineCov">      39662 :      SgTemplateArgumentPtrList* templateArgumentsList = getTemplateArgumentList(decl);</span></a>
<a name="1031"><span class="lineNum">    1031 </span>            : </a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">      39662 :      if (templateArgumentsList != NULL)</span></a>
<a name="1033"><span class="lineNum">    1033 </span>            :         {</a>
<a name="1034"><span class="lineNum">    1034 </span><span class="lineCov">      39662 :           SgDeclarationStatement* first_decl = decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="1035"><span class="lineNum">    1035 </span><span class="lineCov">      39662 :           ROSE_ASSERT(first_decl != NULL);</span></a>
<a name="1036"><span class="lineNum">    1036 </span>            : </a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">      39662 :           SgTemplateArgumentPtrList::iterator i = templateArgumentsList-&gt;begin();</span></a>
<a name="1038"><span class="lineNum">    1038 </span><span class="lineCov">      72189 :           while (i != templateArgumentsList-&gt;end())</span></a>
<a name="1039"><span class="lineNum">    1039 </span>            :              {</a>
<a name="1040"><span class="lineNum">    1040 </span><span class="lineCov">      32527 :                SgNode* parent = (*i)-&gt;get_parent();</span></a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineCov">      32527 :                if (parent== NULL)</span></a>
<a name="1042"><span class="lineNum">    1042 </span>            :                   {</a>
<a name="1043"><span class="lineNum">    1043 </span>            :                  // (*i)-&gt;set_parent(decl);</a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                     (*i)-&gt;set_parent(first_decl);</span></a>
<a name="1045"><span class="lineNum">    1045 </span>            :                   }</a>
<a name="1046"><span class="lineNum">    1046 </span>            :                  else</a>
<a name="1047"><span class="lineNum">    1047 </span>            :                   {</a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineCov">      32527 :                     SgScopeStatement* scope = isSgScopeStatement(parent);</span></a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineCov">      32527 :                     if (scope != NULL)</span></a>
<a name="1050"><span class="lineNum">    1050 </span>            :                        {</a>
<a name="1051"><span class="lineNum">    1051 </span>            :                       // Template Arguments should have had there parents set to a scope when they were build, we want</a>
<a name="1052"><span class="lineNum">    1052 </span>            :                       // to refine that now that the declaration which we want them to be specified in has been build.</a>
<a name="1053"><span class="lineNum">    1053 </span>            : #if 0</a>
<a name="1054"><span class="lineNum">    1054 </span>            :                          printf (&quot;In setTemplateArgumentParents(): Reset the template argument parent from scope = %p = %s to decl = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str(),decl,decl-&gt;class_name().c_str());</a>
<a name="1055"><span class="lineNum">    1055 </span>            : #endif</a>
<a name="1056"><span class="lineNum">    1056 </span>            :                       // (*i)-&gt;set_parent(decl);</a>
<a name="1057"><span class="lineNum">    1057 </span><span class="lineCov">      17054 :                          (*i)-&gt;set_parent(first_decl);</span></a>
<a name="1058"><span class="lineNum">    1058 </span>            :                        }</a>
<a name="1059"><span class="lineNum">    1059 </span>            :                       else</a>
<a name="1060"><span class="lineNum">    1060 </span>            :                        {</a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineCov">      15473 :                          SgDeclarationStatement* declaration = isSgDeclarationStatement(parent);</span></a>
<a name="1062"><span class="lineNum">    1062 </span>            :                          if (declaration != NULL)</a>
<a name="1063"><span class="lineNum">    1063 </span>            :                             {</a>
<a name="1064"><span class="lineNum">    1064 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1065"><span class="lineNum">    1065 </span>            :                               printf (&quot;In setTemplateArgumentParents(): Template argument already set to declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1066"><span class="lineNum">    1066 </span>            : #endif</a>
<a name="1067"><span class="lineNum">    1067 </span>            :                             }</a>
<a name="1068"><span class="lineNum">    1068 </span>            :                            else</a>
<a name="1069"><span class="lineNum">    1069 </span>            :                             {</a>
<a name="1070"><span class="lineNum">    1070 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="1071"><span class="lineNum">    1071 </span>            :                               printf (&quot;Error: In setTemplateArgumentParents(): I think it is an error for the template argument parent to be set to %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="1072"><span class="lineNum">    1072 </span>            : #endif</a>
<a name="1073"><span class="lineNum">    1073 </span>            :                             }</a>
<a name="1074"><span class="lineNum">    1074 </span>            :                        }</a>
<a name="1075"><span class="lineNum">    1075 </span>            :                   }</a>
<a name="1076"><span class="lineNum">    1076 </span>            : </a>
<a name="1077"><span class="lineNum">    1077 </span><span class="lineCov">      32527 :                i++;</span></a>
<a name="1078"><span class="lineNum">    1078 </span>            :              }</a>
<a name="1079"><span class="lineNum">    1079 </span>            :         }</a>
<a name="1080"><span class="lineNum">    1080 </span>            : </a>
<a name="1081"><span class="lineNum">    1081 </span><span class="lineCov">      39662 :      testTemplateArgumentParents(decl);</span></a>
<a name="1082"><span class="lineNum">    1082 </span><span class="lineCov">      39662 :    }</span></a>
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<a name="1084"><span class="lineNum">    1084 </span>            : </a>
<a name="1085"><span class="lineNum">    1085 </span>            : void</a>
<a name="1086"><span class="lineNum">    1086 </span><span class="lineCov">      30408 : SageBuilder::setTemplateParameterParents( SgDeclarationStatement* decl )</span></a>
<a name="1087"><span class="lineNum">    1087 </span>            :    {</a>
<a name="1088"><span class="lineNum">    1088 </span>            :   // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).</a>
<a name="1089"><span class="lineNum">    1089 </span>            : </a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineCov">      30408 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="1091"><span class="lineNum">    1091 </span>            : </a>
<a name="1092"><span class="lineNum">    1092 </span>            : #if 0</a>
<a name="1093"><span class="lineNum">    1093 </span>            :      printf (&quot;In setTemplateParameterParents(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1094"><span class="lineNum">    1094 </span>            : #endif</a>
<a name="1095"><span class="lineNum">    1095 </span>            : </a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">      30408 :      SgTemplateParameterPtrList* templateParameterList = getTemplateParameterList(decl);</span></a>
<a name="1097"><span class="lineNum">    1097 </span>            : </a>
<a name="1098"><span class="lineNum">    1098 </span>            : #if 0</a>
<a name="1099"><span class="lineNum">    1099 </span>            :      printf (&quot;In setTemplateParameterParents(): templateParameterList = %p \n&quot;,templateParameterList);</a>
<a name="1100"><span class="lineNum">    1100 </span>            : #endif</a>
<a name="1101"><span class="lineNum">    1101 </span>            : </a>
<a name="1102"><span class="lineNum">    1102 </span><span class="lineCov">      30408 :      if (templateParameterList != NULL)</span></a>
<a name="1103"><span class="lineNum">    1103 </span>            :         {</a>
<a name="1104"><span class="lineNum">    1104 </span><span class="lineCov">      30408 :           SgDeclarationStatement* first_decl = decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="1105"><span class="lineNum">    1105 </span><span class="lineCov">      30408 :           ROSE_ASSERT(first_decl != NULL);</span></a>
<a name="1106"><span class="lineNum">    1106 </span>            : </a>
<a name="1107"><span class="lineNum">    1107 </span>            : #if 0</a>
<a name="1108"><span class="lineNum">    1108 </span>            :           printf (&quot;In setTemplateParameterParents(): first_decl = %p = %s \n&quot;,first_decl,first_decl-&gt;class_name().c_str());</a>
<a name="1109"><span class="lineNum">    1109 </span>            : #endif</a>
<a name="1110"><span class="lineNum">    1110 </span>            : </a>
<a name="1111"><span class="lineNum">    1111 </span><span class="lineCov">      30408 :           SgTemplateParameterPtrList::iterator i = templateParameterList-&gt;begin();</span></a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineCov">      58347 :           while (i != templateParameterList-&gt;end())</span></a>
<a name="1113"><span class="lineNum">    1113 </span>            :              {</a>
<a name="1114"><span class="lineNum">    1114 </span><span class="lineCov">      27939 :                SgNode* parent = (*i)-&gt;get_parent();</span></a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineCov">      27939 :                if (parent == NULL)</span></a>
<a name="1116"><span class="lineNum">    1116 </span>            :                   {</a>
<a name="1117"><span class="lineNum">    1117 </span>            : #if 0</a>
<a name="1118"><span class="lineNum">    1118 </span>            :                     printf (&quot;########### In setTemplateParameterParents(): Setting the template parameter to have a non-null parent: first_decl = %p = %s \n&quot;,first_decl,first_decl-&gt;class_name().c_str());</a>
<a name="1119"><span class="lineNum">    1119 </span>            : #endif</a>
<a name="1120"><span class="lineNum">    1120 </span>            :                  // (*i)-&gt;set_parent(decl);</a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineCov">      19041 :                     (*i)-&gt;set_parent(first_decl);</span></a>
<a name="1122"><span class="lineNum">    1122 </span>            :                   }</a>
<a name="1123"><span class="lineNum">    1123 </span>            :                  else</a>
<a name="1124"><span class="lineNum">    1124 </span>            :                   {</a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineCov">       8898 :                     SgScopeStatement* scope = isSgScopeStatement(parent);</span></a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineCov">       8898 :                     if (scope != NULL)</span></a>
<a name="1127"><span class="lineNum">    1127 </span>            :                        {</a>
<a name="1128"><span class="lineNum">    1128 </span>            :                       // Template Arguments should have had their parents set to a scope when they were build, we want</a>
<a name="1129"><span class="lineNum">    1129 </span>            :                       // to refine that now that the declaration which we want them to be specified in has been build.</a>
<a name="1130"><span class="lineNum">    1130 </span>            : #if 0</a>
<a name="1131"><span class="lineNum">    1131 </span>            :                          printf (&quot;Reset the template parameter parent from scope = %p = %s to decl = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str(),decl,decl-&gt;class_name().c_str());</a>
<a name="1132"><span class="lineNum">    1132 </span>            : #endif</a>
<a name="1133"><span class="lineNum">    1133 </span>            :                       // (*i)-&gt;set_parent(decl);</a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                          (*i)-&gt;set_parent(first_decl);</span></a>
<a name="1135"><span class="lineNum">    1135 </span>            :                        }</a>
<a name="1136"><span class="lineNum">    1136 </span>            :                       else</a>
<a name="1137"><span class="lineNum">    1137 </span>            :                        {</a>
<a name="1138"><span class="lineNum">    1138 </span>            : #if 0</a>
<a name="1139"><span class="lineNum">    1139 </span>            :                          SgDeclarationStatement* declaration = isSgDeclarationStatement(parent);</a>
<a name="1140"><span class="lineNum">    1140 </span>            :                          if (declaration != NULL)</a>
<a name="1141"><span class="lineNum">    1141 </span>            :                             {</a>
<a name="1142"><span class="lineNum">    1142 </span>            :                               printf (&quot;Template argument already set to declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="1143"><span class="lineNum">    1143 </span>            :                             }</a>
<a name="1144"><span class="lineNum">    1144 </span>            :                            else</a>
<a name="1145"><span class="lineNum">    1145 </span>            :                             {</a>
<a name="1146"><span class="lineNum">    1146 </span>            :                               printf (&quot;Error: I think it is an error for the template argument parent to be set to %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="1147"><span class="lineNum">    1147 </span>            :                             }</a>
<a name="1148"><span class="lineNum">    1148 </span>            : #endif</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                        }</a>
<a name="1150"><span class="lineNum">    1150 </span>            :                   }</a>
<a name="1151"><span class="lineNum">    1151 </span>            : </a>
<a name="1152"><span class="lineNum">    1152 </span><span class="lineCov">      27939 :                i++;</span></a>
<a name="1153"><span class="lineNum">    1153 </span>            :              }</a>
<a name="1154"><span class="lineNum">    1154 </span>            :         }</a>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineCov">      30408 :      testTemplateParameterParents(decl);</span></a>
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">      30408 :    }</span></a>
<a name="1158"><span class="lineNum">    1158 </span>            : </a>
<a name="1159"><span class="lineNum">    1159 </span>            : </a>
<a name="1160"><span class="lineNum">    1160 </span>            : void</a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">     210411 : SageBuilder::testTemplateArgumentParents( SgDeclarationStatement* decl )</span></a>
<a name="1162"><span class="lineNum">    1162 </span>            :    {</a>
<a name="1163"><span class="lineNum">    1163 </span>            :   // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).</a>
<a name="1164"><span class="lineNum">    1164 </span>            : </a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineCov">     210411 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="1166"><span class="lineNum">    1166 </span>            : </a>
<a name="1167"><span class="lineNum">    1167 </span>            : #if 0</a>
<a name="1168"><span class="lineNum">    1168 </span>            :      printf (&quot;In testTemplateArgumentParents(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1169"><span class="lineNum">    1169 </span>            : #endif</a>
<a name="1170"><span class="lineNum">    1170 </span>            : </a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineCov">     210411 :      SgTemplateArgumentPtrList* templateArgumentsList = getTemplateArgumentList(decl);</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            :   // ROSE_ASSERT(templateArgumentsList != NULL);</a>
<a name="1173"><span class="lineNum">    1173 </span>            : </a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineCov">     210411 :      if (templateArgumentsList != NULL)</span></a>
<a name="1175"><span class="lineNum">    1175 </span>            :         {</a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineCov">     156085 :           SgTemplateArgumentPtrList::iterator i = templateArgumentsList-&gt;begin();</span></a>
<a name="1177"><span class="lineNum">    1177 </span><span class="lineCov">     314078 :           while (i != templateArgumentsList-&gt;end())</span></a>
<a name="1178"><span class="lineNum">    1178 </span>            :              {</a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineCov">     157993 :                SgNode* parent = (*i)-&gt;get_parent();</span></a>
<a name="1180"><span class="lineNum">    1180 </span><span class="lineCov">     157993 :                if (parent == NULL)</span></a>
<a name="1181"><span class="lineNum">    1181 </span>            :                   {</a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: In testTemplateArgumentParents(): decl = %p = %s has template argument = %p with null parent \n&quot;,decl,decl-&gt;class_name().c_str(),*i);</span></a>
<a name="1183"><span class="lineNum">    1183 </span>            :                   }</a>
<a name="1184"><span class="lineNum">    1184 </span><span class="lineCov">     157993 :                ROSE_ASSERT(parent != NULL);</span></a>
<a name="1185"><span class="lineNum">    1185 </span>            : </a>
<a name="1186"><span class="lineNum">    1186 </span>            :             // DQ (9/16/2012): Adding new test.</a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineCov">     157993 :                ROSE_ASSERT(decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="1188"><span class="lineNum">    1188 </span>            : #if 0</a>
<a name="1189"><span class="lineNum">    1189 </span>            :             // DQ (2/16/2014): This happens because the templates arguments are shared across multiple template instantiations and there parent pointers can only match a single template instantiation.</a>
<a name="1190"><span class="lineNum">    1190 </span>            :                if (parent != decl-&gt;get_firstNondefiningDeclaration())</a>
<a name="1191"><span class="lineNum">    1191 </span>            :                   {</a>
<a name="1192"><span class="lineNum">    1192 </span>            :                     printf (&quot;Error: In testTemplateArgumentParents(): decl = %p = %s has template argument = %p with parent = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str(),*i,parent,parent-&gt;class_name().c_str());</a>
<a name="1193"><span class="lineNum">    1193 </span>            :                     printf (&quot;  --- decl                                    = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1194"><span class="lineNum">    1194 </span>            :                     printf (&quot;  --- decl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,decl-&gt;get_firstNondefiningDeclaration(),decl-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="1195"><span class="lineNum">    1195 </span>            :                   }</a>
<a name="1196"><span class="lineNum">    1196 </span>            : #endif</a>
<a name="1197"><span class="lineNum">    1197 </span>            :             // DQ (1/30/2013): Commented this test out so that we could reuse SgTemplateArguments and</a>
<a name="1198"><span class="lineNum">    1198 </span>            :             // assure that the mapping from EDG a_template_arg_ptr's to SgTemplateArgument's was 1-to-1.</a>
<a name="1199"><span class="lineNum">    1199 </span>            :             // It is not clear if we can relax this constraint in the future.</a>
<a name="1200"><span class="lineNum">    1200 </span>            :             // ROSE_ASSERT(parent == decl-&gt;get_firstNondefiningDeclaration());</a>
<a name="1201"><span class="lineNum">    1201 </span>            : </a>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineCov">     157993 :                i++;</span></a>
<a name="1203"><span class="lineNum">    1203 </span>            :              }</a>
<a name="1204"><span class="lineNum">    1204 </span>            :         }</a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineCov">     210411 :    }</span></a>
<a name="1206"><span class="lineNum">    1206 </span>            : </a>
<a name="1207"><span class="lineNum">    1207 </span>            : </a>
<a name="1208"><span class="lineNum">    1208 </span>            : void</a>
<a name="1209"><span class="lineNum">    1209 </span><span class="lineCov">      60816 : SageBuilder::testTemplateParameterParents( SgDeclarationStatement* decl )</span></a>
<a name="1210"><span class="lineNum">    1210 </span>            :    {</a>
<a name="1211"><span class="lineNum">    1211 </span>            :   // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).</a>
<a name="1212"><span class="lineNum">    1212 </span>            : </a>
<a name="1213"><span class="lineNum">    1213 </span><span class="lineCov">      60816 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="1214"><span class="lineNum">    1214 </span>            : </a>
<a name="1215"><span class="lineNum">    1215 </span>            : #if 0</a>
<a name="1216"><span class="lineNum">    1216 </span>            :      printf (&quot;In testTemplateParameterParents(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1217"><span class="lineNum">    1217 </span>            : #endif</a>
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineCov">      60816 :      SgTemplateParameterPtrList* templateParameterList = getTemplateParameterList(decl);</span></a>
<a name="1220"><span class="lineNum">    1220 </span>            : </a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineCov">      60816 :      if (templateParameterList != NULL)</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            :         {</a>
<a name="1223"><span class="lineNum">    1223 </span><span class="lineCov">      60816 :           SgTemplateParameterPtrList::iterator i = templateParameterList-&gt;begin();</span></a>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineCov">     116694 :           while (i != templateParameterList-&gt;end())</span></a>
<a name="1225"><span class="lineNum">    1225 </span>            :              {</a>
<a name="1226"><span class="lineNum">    1226 </span><span class="lineCov">      55878 :                SgNode* parent = (*i)-&gt;get_parent();</span></a>
<a name="1227"><span class="lineNum">    1227 </span><span class="lineCov">      55878 :                if (parent == NULL)</span></a>
<a name="1228"><span class="lineNum">    1228 </span>            :                   {</a>
<a name="1229"><span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: In testTemplateParameterParents(): decl = %p = %s has template argument = %p with null parent \n&quot;,decl,decl-&gt;class_name().c_str(),*i);</span></a>
<a name="1230"><span class="lineNum">    1230 </span>            :                   }</a>
<a name="1231"><span class="lineNum">    1231 </span><span class="lineCov">      55878 :                ROSE_ASSERT(parent != NULL);</span></a>
<a name="1232"><span class="lineNum">    1232 </span>            : </a>
<a name="1233"><span class="lineNum">    1233 </span>            :             // DQ (9/16/2012): Adding new test.</a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineCov">      55878 :                ROSE_ASSERT(decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineCov">      55878 :                if (parent != decl-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="1236"><span class="lineNum">    1236 </span>            :                   {</a>
<a name="1237"><span class="lineNum">    1237 </span>            : #if 0</a>
<a name="1238"><span class="lineNum">    1238 </span>            :                  // DQ (2/7/2015): This message is output a lot for C++11 test projects/ShiftCalculus/simpleCNS.cpp (also test2014_83.C and test2014_84.C).</a>
<a name="1239"><span class="lineNum">    1239 </span>            :                     printf (&quot;Error: In testTemplateParameterParents(): decl = %p = %s has template argument = %p with parent = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str(),*i,parent,parent-&gt;class_name().c_str());</a>
<a name="1240"><span class="lineNum">    1240 </span>            : #endif</a>
<a name="1241"><span class="lineNum">    1241 </span>            :                   }</a>
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<a name="1243"><span class="lineNum">    1243 </span>            :             // DQ (8/22/2013): Since these are now shared, it makes less sense to expect these to have such simple parent relationships.</a>
<a name="1244"><span class="lineNum">    1244 </span>            :             // This commit of work on ROSE added caching to template parameters so that we could support pointer equality for tests</a>
<a name="1245"><span class="lineNum">    1245 </span>            :             // of template parameter equality in the symbol table handling (this was a technique previously used for template arguments).</a>
<a name="1246"><span class="lineNum">    1246 </span>            :             // This test fails in the mergeTest_04.C test , but only on the GNU 4.4.x compiler (passes on the GNU 4.2.4 compiler).</a>
<a name="1247"><span class="lineNum">    1247 </span>            :             // ROSE_ASSERT(parent == decl-&gt;get_firstNondefiningDeclaration());</a>
<a name="1248"><span class="lineNum">    1248 </span>            : </a>
<a name="1249"><span class="lineNum">    1249 </span><span class="lineCov">      55878 :                i++;</span></a>
<a name="1250"><span class="lineNum">    1250 </span>            :              }</a>
<a name="1251"><span class="lineNum">    1251 </span>            :         }</a>
<a name="1252"><span class="lineNum">    1252 </span><span class="lineCov">      60816 :    }</span></a>
<a name="1253"><span class="lineNum">    1253 </span>            : </a>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<a name="1255"><span class="lineNum">    1255 </span>            : void</a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineCov">      29104 : SageBuilder::setTemplateArgumentsInDeclaration( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateArgumentsList_input )</span></a>
<a name="1257"><span class="lineNum">    1257 </span>            :    {</a>
<a name="1258"><span class="lineNum">    1258 </span>            :   // DQ (9/16/2012): Setup the template arguments for any type of template instantiation.</a>
<a name="1259"><span class="lineNum">    1259 </span>            : </a>
<a name="1260"><span class="lineNum">    1260 </span>            : #if 0</a>
<a name="1261"><span class="lineNum">    1261 </span>            :      printf (&quot;In setTemplateArgumentsInDeclaration(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1262"><span class="lineNum">    1262 </span>            :   // printf (&quot;   --- unparseNameToString() = %s \n&quot;,decl-&gt;unparseNameToString().c_str());</a>
<a name="1263"><span class="lineNum">    1263 </span>            : #endif</a>
<a name="1264"><span class="lineNum">    1264 </span>            : </a>
<a name="1265"><span class="lineNum">    1265 </span><span class="lineCov">      29104 :      ROSE_ASSERT(templateArgumentsList_input != NULL);</span></a>
<a name="1266"><span class="lineNum">    1266 </span>            : </a>
<a name="1267"><span class="lineNum">    1267 </span>            :   // DQ (2/19/2018): Need to modify this function to take templated typedefs.</a>
<a name="1268"><span class="lineNum">    1268 </span>            :   //</a>
<a name="1269"><span class="lineNum">    1269 </span>            :   //    Do this in the morning...</a>
<a name="1270"><span class="lineNum">    1270 </span>            :   //</a>
<a name="1271"><span class="lineNum">    1271 </span>            : </a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineCov">      29104 :      ROSE_ASSERT(decl-&gt;variantT() == V_SgTemplateInstantiationDecl ||</span></a>
<a name="1273"><span class="lineNum">    1273 </span>            :                  decl-&gt;variantT() == V_SgTemplateInstantiationFunctionDecl ||</a>
<a name="1274"><span class="lineNum">    1274 </span>            :                  decl-&gt;variantT() == V_SgTemplateInstantiationMemberFunctionDecl ||</a>
<a name="1275"><span class="lineNum">    1275 </span>            :                  decl-&gt;variantT() == V_SgTemplateInstantiationTypedefDeclaration);</a>
<a name="1276"><span class="lineNum">    1276 </span>            : </a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">      29104 :      SgTemplateArgumentPtrList* templateArgumentsList_from_declaration = getTemplateArgumentList(decl);</span></a>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineCov">      29104 :      if (templateArgumentsList_from_declaration != NULL)</span></a>
<a name="1280"><span class="lineNum">    1280 </span>            :         {</a>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineCov">      29104 :           *templateArgumentsList_from_declaration = *templateArgumentsList_input;</span></a>
<a name="1282"><span class="lineNum">    1282 </span>            : </a>
<a name="1283"><span class="lineNum">    1283 </span>            :        // Set the parents.</a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineCov">      29104 :           setTemplateArgumentParents(decl);</span></a>
<a name="1285"><span class="lineNum">    1285 </span>            :         }</a>
<a name="1286"><span class="lineNum">    1286 </span>            :        else</a>
<a name="1287"><span class="lineNum">    1287 </span>            :         {</a>
<a name="1288"><span class="lineNum">    1288 </span>            : #if 0</a>
<a name="1289"><span class="lineNum">    1289 </span>            :           printf (&quot;In setTemplateArgumentsInDeclaration(): Setup of template arguments not supported for decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1290"><span class="lineNum">    1290 </span>            : #endif</a>
<a name="1291"><span class="lineNum">    1291 </span>            :         }</a>
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<a name="1293"><span class="lineNum">    1293 </span><span class="lineCov">      29104 :      testTemplateArgumentParents(decl);</span></a>
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<a name="1295"><span class="lineNum">    1295 </span>            : #if 0</a>
<a name="1296"><span class="lineNum">    1296 </span>            :   // printf (&quot;Leaving setTemplateArgumentsInDeclaration(): unparseNameToString() = %s \n&quot;,decl-&gt;unparseNameToString().c_str());</a>
<a name="1297"><span class="lineNum">    1297 </span>            : #endif</a>
<a name="1298"><span class="lineNum">    1298 </span><span class="lineCov">      29104 :    }</span></a>
<a name="1299"><span class="lineNum">    1299 </span>            : </a>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<a name="1301"><span class="lineNum">    1301 </span>            : void</a>
<a name="1302"><span class="lineNum">    1302 </span><span class="lineCov">      10558 : SageBuilder::setTemplateSpecializationArgumentsInDeclaration( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateSpecializationArgumentsList_input )</span></a>
<a name="1303"><span class="lineNum">    1303 </span>            :    {</a>
<a name="1304"><span class="lineNum">    1304 </span>            :   // DQ (9/16/2012): Setup the template arguments for any type of template declaration</a>
<a name="1305"><span class="lineNum">    1305 </span>            : </a>
<a name="1306"><span class="lineNum">    1306 </span>            : #if 0</a>
<a name="1307"><span class="lineNum">    1307 </span>            :      printf (&quot;In setTemplateSpecializationArgumentsInDeclaration(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1308"><span class="lineNum">    1308 </span>            : #endif</a>
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineCov">      10558 :      ROSE_ASSERT(templateSpecializationArgumentsList_input != NULL);</span></a>
<a name="1311"><span class="lineNum">    1311 </span>            : </a>
<a name="1312"><span class="lineNum">    1312 </span><span class="lineCov">      10558 :      ROSE_ASSERT(decl-&gt;variantT() == V_SgTemplateClassDeclaration          || decl-&gt;variantT() == V_SgTemplateFunctionDeclaration ||</span></a>
<a name="1313"><span class="lineNum">    1313 </span>            :                  decl-&gt;variantT() == V_SgTemplateMemberFunctionDeclaration || decl-&gt;variantT() == V_SgTemplateVariableDeclaration );</a>
<a name="1314"><span class="lineNum">    1314 </span>            : </a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineCov">      10558 :      SgTemplateArgumentPtrList* templateSpecializationArgumentsList_from_declaration = getTemplateArgumentList(decl);</span></a>
<a name="1316"><span class="lineNum">    1316 </span>            : </a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineCov">      10558 :      if (templateSpecializationArgumentsList_from_declaration != NULL)</span></a>
<a name="1318"><span class="lineNum">    1318 </span>            :         {</a>
<a name="1319"><span class="lineNum">    1319 </span><span class="lineCov">      10558 :           *templateSpecializationArgumentsList_from_declaration = *templateSpecializationArgumentsList_input;</span></a>
<a name="1320"><span class="lineNum">    1320 </span>            : </a>
<a name="1321"><span class="lineNum">    1321 </span>            :        // Set the parents.</a>
<a name="1322"><span class="lineNum">    1322 </span><span class="lineCov">      10558 :           setTemplateArgumentParents(decl);</span></a>
<a name="1323"><span class="lineNum">    1323 </span>            :         }</a>
<a name="1324"><span class="lineNum">    1324 </span>            :        else</a>
<a name="1325"><span class="lineNum">    1325 </span>            :         {</a>
<a name="1326"><span class="lineNum">    1326 </span>            : #if 0</a>
<a name="1327"><span class="lineNum">    1327 </span>            :           printf (&quot;In setTemplateSpecializationArgumentsInDeclaration(): Setup of template arguments not supported for decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1328"><span class="lineNum">    1328 </span>            : #endif</a>
<a name="1329"><span class="lineNum">    1329 </span>            :         }</a>
<a name="1330"><span class="lineNum">    1330 </span>            : </a>
<a name="1331"><span class="lineNum">    1331 </span><span class="lineCov">      10558 :      testTemplateArgumentParents(decl);</span></a>
<a name="1332"><span class="lineNum">    1332 </span><span class="lineCov">      10558 :    }</span></a>
<a name="1333"><span class="lineNum">    1333 </span>            : </a>
<a name="1334"><span class="lineNum">    1334 </span>            : </a>
<a name="1335"><span class="lineNum">    1335 </span>            : void</a>
<a name="1336"><span class="lineNum">    1336 </span><span class="lineCov">      30408 : SageBuilder::setTemplateParametersInDeclaration( SgDeclarationStatement* decl, SgTemplateParameterPtrList* templateParameterList_input )</span></a>
<a name="1337"><span class="lineNum">    1337 </span>            :    {</a>
<a name="1338"><span class="lineNum">    1338 </span>            :   // DQ (9/16/2012): Setup the template parameters for any type of template declaration.</a>
<a name="1339"><span class="lineNum">    1339 </span>            : </a>
<a name="1340"><span class="lineNum">    1340 </span>            : #if 0</a>
<a name="1341"><span class="lineNum">    1341 </span>            :      printf (&quot;In setTemplateParametersInDeclaration(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1342"><span class="lineNum">    1342 </span>            : #endif</a>
<a name="1343"><span class="lineNum">    1343 </span>            : </a>
<a name="1344"><span class="lineNum">    1344 </span><span class="lineCov">      30408 :      ROSE_ASSERT(templateParameterList_input != NULL);</span></a>
<a name="1345"><span class="lineNum">    1345 </span>            : </a>
<a name="1346"><span class="lineNum">    1346 </span><span class="lineCov">      30408 :      ROSE_ASSERT(decl-&gt;variantT() == V_SgTemplateClassDeclaration          || decl-&gt;variantT() == V_SgTemplateFunctionDeclaration ||</span></a>
<a name="1347"><span class="lineNum">    1347 </span>            :                  decl-&gt;variantT() == V_SgTemplateMemberFunctionDeclaration || decl-&gt;variantT() == V_SgTemplateVariableDeclaration );</a>
<a name="1348"><span class="lineNum">    1348 </span>            : </a>
<a name="1349"><span class="lineNum">    1349 </span><span class="lineCov">      30408 :      SgTemplateParameterPtrList* templateParameterList_from_declaration = getTemplateParameterList(decl);</span></a>
<a name="1350"><span class="lineNum">    1350 </span>            : </a>
<a name="1351"><span class="lineNum">    1351 </span><span class="lineCov">      30408 :      if (templateParameterList_from_declaration != NULL)</span></a>
<a name="1352"><span class="lineNum">    1352 </span>            :         {</a>
<a name="1353"><span class="lineNum">    1353 </span>            :        // DQ (7/16/2017): Commented out this failing assertion (just now getting this function to be called).</a>
<a name="1354"><span class="lineNum">    1354 </span>            :        // ROSE_ASSERT(templateParameterList_from_declaration-&gt;empty() == true);</a>
<a name="1355"><span class="lineNum">    1355 </span>            : </a>
<a name="1356"><span class="lineNum">    1356 </span><span class="lineCov">      30408 :           *templateParameterList_from_declaration = *templateParameterList_input;</span></a>
<a name="1357"><span class="lineNum">    1357 </span>            : </a>
<a name="1358"><span class="lineNum">    1358 </span>            :        // Set the parents.</a>
<a name="1359"><span class="lineNum">    1359 </span><span class="lineCov">      30408 :           setTemplateParameterParents(decl);</span></a>
<a name="1360"><span class="lineNum">    1360 </span>            :         }</a>
<a name="1361"><span class="lineNum">    1361 </span>            :        else</a>
<a name="1362"><span class="lineNum">    1362 </span>            :         {</a>
<a name="1363"><span class="lineNum">    1363 </span>            : #if 0</a>
<a name="1364"><span class="lineNum">    1364 </span>            :           printf (&quot;In setTemplateParameterInDeclaration(): Setup of template parameters not supported for decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="1365"><span class="lineNum">    1365 </span>            : #endif</a>
<a name="1366"><span class="lineNum">    1366 </span>            :         }</a>
<a name="1367"><span class="lineNum">    1367 </span>            : </a>
<a name="1368"><span class="lineNum">    1368 </span><span class="lineCov">      30408 :      testTemplateParameterParents(decl);</span></a>
<a name="1369"><span class="lineNum">    1369 </span><span class="lineCov">      30408 :    }</span></a>
<a name="1370"><span class="lineNum">    1370 </span>            : </a>
<a name="1371"><span class="lineNum">    1371 </span>            : </a>
<a name="1372"><span class="lineNum">    1372 </span>            : </a>
<a name="1373"><span class="lineNum">    1373 </span>            : // Only used to build parameter arguments for function ??</a>
<a name="1374"><span class="lineNum">    1374 </span>            : // should be transparently generated for most variable declaration builder</a>
<a name="1375"><span class="lineNum">    1375 </span>            : // deferred symbol insertion, scope setting , etc</a>
<a name="1376"><span class="lineNum">    1376 </span>            : // do them when it is actually used with the  parameterList!!</a>
<a name="1377"><span class="lineNum">    1377 </span>            : SgInitializedName *</a>
<a name="1378"><span class="lineNum">    1378 </span><span class="lineCov">       2477 : SageBuilder::buildInitializedName ( const SgName &amp; name, SgType* type, SgInitializer* init /* = NULL */)</span></a>
<a name="1379"><span class="lineNum">    1379 </span>            : {</a>
<a name="1380"><span class="lineNum">    1380 </span>            : #if 0</a>
<a name="1381"><span class="lineNum">    1381 </span>            :   // If the scope was not specified, then get it from the scope stack.</a>
<a name="1382"><span class="lineNum">    1382 </span>            :      if (scope == NULL)</a>
<a name="1383"><span class="lineNum">    1383 </span>            :           scope = SageBuilder::topScopeStack();</a>
<a name="1384"><span class="lineNum">    1384 </span>            : //     ROSE_ASSERT(scope != NULL);</a>
<a name="1385"><span class="lineNum">    1385 </span>            : #endif</a>
<a name="1386"><span class="lineNum">    1386 </span>            :      //foo(int);  empty name is possible here!!</a>
<a name="1387"><span class="lineNum">    1387 </span>            :      //ROSE_ASSERT(name.is_null() == false);</a>
<a name="1388"><span class="lineNum">    1388 </span><span class="lineCov">       2477 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="1389"><span class="lineNum">    1389 </span>            : </a>
<a name="1390"><span class="lineNum">    1390 </span><span class="lineCov">       2477 :      SgInitializedName* initializedName = new SgInitializedName(name,type,init);</span></a>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineCov">       2477 :      ROSE_ASSERT(initializedName);</span></a>
<a name="1392"><span class="lineNum">    1392 </span>            : #if 0</a>
<a name="1393"><span class="lineNum">    1393 </span>            :     //TODO prototype parameter has no symbol associated!!</a>
<a name="1394"><span class="lineNum">    1394 </span>            :     //TODO  scope is also different: SgFunctionDefinition or scope of SgFunctionDeclaration</a>
<a name="1395"><span class="lineNum">    1395 </span>            :     SgVariableSymbol * symbol_1 = new SgVariableSymbol(initializedName);</a>
<a name="1396"><span class="lineNum">    1396 </span>            :     ROSE_ASSERT(symbol_1);</a>
<a name="1397"><span class="lineNum">    1397 </span>            :     scope-&gt;insert_symbol(name, symbol_1);</a>
<a name="1398"><span class="lineNum">    1398 </span>            :     initializedName-&gt;set_scope(scope);</a>
<a name="1399"><span class="lineNum">    1399 </span>            : #endif</a>
<a name="1400"><span class="lineNum">    1400 </span><span class="lineCov">       2477 :     setSourcePositionAtRootAndAllChildren(initializedName);</span></a>
<a name="1401"><span class="lineNum">    1401 </span><span class="lineCov">       2477 :     return initializedName;</span></a>
<a name="1402"><span class="lineNum">    1402 </span>            : }</a>
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<a name="1404"><span class="lineNum">    1404 </span>            : SgInitializedName *</a>
<a name="1405"><span class="lineNum">    1405 </span><span class="lineCov">          2 : SageBuilder::buildInitializedName ( const std::string &amp; name, SgType* type)</span></a>
<a name="1406"><span class="lineNum">    1406 </span>            :    {</a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">          4 :      SgName var_name(name);</span></a>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineCov">          4 :      return buildInitializedName(var_name,type);</span></a>
<a name="1409"><span class="lineNum">    1409 </span>            :    }</a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span>            : SgInitializedName *</a>
<a name="1412"><span class="lineNum">    1412 </span><span class="lineCov">          2 : SageBuilder::buildInitializedName ( const char* name, SgType* type)</span></a>
<a name="1413"><span class="lineNum">    1413 </span>            :    {</a>
<a name="1414"><span class="lineNum">    1414 </span>            :   // DQ (3/20/2017): Call the version of the function that takes a string as part of migration away from this function that takes a const char*.</a>
<a name="1415"><span class="lineNum">    1415 </span>            :   // This also provides a test of the string based version of this function (for code coverage).</a>
<a name="1416"><span class="lineNum">    1416 </span>            :   // SgName var_name(name);</a>
<a name="1417"><span class="lineNum">    1417 </span><span class="lineCov">          2 :      string var_name(name);</span></a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineCov">          2 :      return buildInitializedName(var_name,type);</span></a>
<a name="1419"><span class="lineNum">    1419 </span>            :    }</a>
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<a name="1421"><span class="lineNum">    1421 </span>            : SgInitializedName *</a>
<a name="1422"><span class="lineNum">    1422 </span><span class="lineCov">    6336880 : SageBuilder::buildInitializedName_nfi ( const SgName &amp; name, SgType* type, SgInitializer* init)</span></a>
<a name="1423"><span class="lineNum">    1423 </span>            :    {</a>
<a name="1424"><span class="lineNum">    1424 </span><span class="lineCov">    6336880 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="1425"><span class="lineNum">    1425 </span>            : </a>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineCov">    6336880 :      SgInitializedName* initializedName = new SgInitializedName(name,type,init);</span></a>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineCov">    6336880 :      ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<a name="1429"><span class="lineNum">    1429 </span>            :   // DQ (9/4/2013): Added test.</a>
<a name="1430"><span class="lineNum">    1430 </span><span class="lineCov">    6336880 :      ROSE_ASSERT(init == NULL || init-&gt;get_parent() == initializedName);</span></a>
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineCov">    6336880 :      setOneSourcePositionNull(initializedName);</span></a>
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineCov">    6336880 :      return initializedName;</span></a>
<a name="1435"><span class="lineNum">    1435 </span>            :    }</a>
<a name="1436"><span class="lineNum">    1436 </span>            : </a>
<a name="1437"><span class="lineNum">    1437 </span>            : //-----------------------------------------------</a>
<a name="1438"><span class="lineNum">    1438 </span>            : // could have two declarations for a same variable</a>
<a name="1439"><span class="lineNum">    1439 </span>            : // extern int i;</a>
<a name="1440"><span class="lineNum">    1440 </span>            : //  int i;</a>
<a name="1441"><span class="lineNum">    1441 </span>            : SgVariableDeclaration*</a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineCov">        789 : SageBuilder::buildVariableDeclaration (const SgName &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)</span></a>
<a name="1443"><span class="lineNum">    1443 </span>            :  //(const SgName &amp; name, SgType* type, SgInitializer * varInit= NULL, SgScopeStatement* scope = NULL)</a>
<a name="1444"><span class="lineNum">    1444 </span>            : {</a>
<a name="1445"><span class="lineNum">    1445 </span><span class="lineCov">        789 :   if (scope == NULL)</span></a>
<a name="1446"><span class="lineNum">    1446 </span><span class="lineCov">         25 :     scope = SageBuilder::topScopeStack();</span></a>
<a name="1447"><span class="lineNum">    1447 </span>            : //   ROSE_ASSERT(scope != NULL); // enable bottomup construction: scope can be unknown</a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineCov">        789 :    ROSE_ASSERT(name.is_null() == false);</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineCov">        789 :    ROSE_ASSERT(type != NULL);</span></a>
<a name="1450"><span class="lineNum">    1450 </span>            : </a>
<a name="1451"><span class="lineNum">    1451 </span><span class="lineCov">        789 :   SgVariableDeclaration * varDecl = new SgVariableDeclaration(name, type, varInit);</span></a>
<a name="1452"><span class="lineNum">    1452 </span><span class="lineCov">        789 :   ROSE_ASSERT(varDecl);</span></a>
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<a name="1454"><span class="lineNum">    1454 </span>            : // DQ (8/21/2011): Note that the default is to set the declaration modifier's access modifier to be</a>
<a name="1455"><span class="lineNum">    1455 </span>            : // default (which is the same as public).  So the effect it to set it to be public.  This is ignored</a>
<a name="1456"><span class="lineNum">    1456 </span>            : // by the unparser for most languguages in ROSE.</a>
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<a name="1458"><span class="lineNum">    1458 </span>            : // DQ (8/21/2011): Debugging declarations should have default settings (should not be marked as public).</a>
<a name="1459"><span class="lineNum">    1459 </span>            : // ROSE_ASSERT(varDecl-&gt;get_declarationModifier().get_accessModifier().isPublic() == false);</a>
<a name="1460"><span class="lineNum">    1460 </span>            : </a>
<a name="1461"><span class="lineNum">    1461 </span><span class="lineCov">        789 :   varDecl-&gt;set_firstNondefiningDeclaration(varDecl);</span></a>
<a name="1462"><span class="lineNum">    1462 </span>            : </a>
<a name="1463"><span class="lineNum">    1463 </span><span class="lineCov">        789 :   if (scope!=NULL)</span></a>
<a name="1464"><span class="lineNum">    1464 </span>            :   {</a>
<a name="1465"><span class="lineNum">    1465 </span>            :     // Liao 12/13/2010</a>
<a name="1466"><span class="lineNum">    1466 </span>            :     // Fortran subroutine/function parameters have corresponding variable declarations in the body</a>
<a name="1467"><span class="lineNum">    1467 </span>            :     // For this declaration, it should use the initialized names of the parameters instead of creating new ones</a>
<a name="1468"><span class="lineNum">    1468 </span>            :     // The symbol of the init name should be under SgFunctionDefinition, instead of the function body block</a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineCov">        779 :     bool isFortranParameter = false;</span></a>
<a name="1470"><span class="lineNum">    1470 </span><span class="lineCov">        779 :     if (SageInterface::is_Fortran_language())</span></a>
<a name="1471"><span class="lineNum">    1471 </span>            :     {</a>
<a name="1472"><span class="lineNum">    1472 </span><span class="lineCov">          1 :       SgFunctionDefinition * f_def = getEnclosingProcedure (scope);</span></a>
<a name="1473"><span class="lineNum">    1473 </span><span class="lineCov">          1 :       if (f_def != NULL)</span></a>
<a name="1474"><span class="lineNum">    1474 </span>            :       {</a>
<a name="1475"><span class="lineNum">    1475 </span>            :      // DQ (5/21/2013): Removed direct reference to symbol table (namespace handling is only supported at the SgScopeStatement level).</a>
<a name="1476"><span class="lineNum">    1476 </span>            :      // SgSymbolTable * st = f_def-&gt;get_symbol_table();</a>
<a name="1477"><span class="lineNum">    1477 </span>            :      // ROSE_ASSERT (st != NULL);</a>
<a name="1478"><span class="lineNum">    1478 </span>            :      // SgVariableSymbol * v_symbol = st-&gt;find_variable(name);</a>
<a name="1479"><span class="lineNum">    1479 </span><span class="lineCov">          1 :         SgVariableSymbol * v_symbol = f_def-&gt;lookup_variable_symbol(name);</span></a>
<a name="1480"><span class="lineNum">    1480 </span><span class="lineCov">          1 :         if (v_symbol != NULL) // find a function parameter with the same name</span></a>
<a name="1481"><span class="lineNum">    1481 </span>            :         {</a>
<a name="1482"><span class="lineNum">    1482 </span>            :           // replace the default one with the one from parameter</a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineNoCov">          0 :           SgInitializedName *default_initName = varDecl-&gt;get_decl_item (name);</span></a>
<a name="1484"><span class="lineNum">    1484 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (default_initName != NULL);</span></a>
<a name="1485"><span class="lineNum">    1485 </span><span class="lineNoCov">          0 :           SgInitializedName * new_initName = v_symbol-&gt;get_declaration();</span></a>
<a name="1486"><span class="lineNum">    1486 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (new_initName != NULL);</span></a>
<a name="1487"><span class="lineNum">    1487 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (default_initName != new_initName);</span></a>
<a name="1488"><span class="lineNum">    1488 </span>            : </a>
<a name="1489"><span class="lineNum">    1489 </span><span class="lineNoCov">          0 :           SgInitializedNamePtrList&amp;  n_list= varDecl-&gt;get_variables();</span></a>
<a name="1490"><span class="lineNum">    1490 </span><span class="lineNoCov">          0 :           std::replace (n_list.begin(), n_list.end(),default_initName, new_initName );</span></a>
<a name="1491"><span class="lineNum">    1491 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (varDecl-&gt;get_decl_item (name)==new_initName); //ensure the new one can be found</span></a>
<a name="1492"><span class="lineNum">    1492 </span>            : </a>
<a name="1493"><span class="lineNum">    1493 </span>            :           // change the function argument's old parent to the variable declaration</a>
<a name="1494"><span class="lineNum">    1494 </span><span class="lineNoCov">          0 :           SgNode * old_parent = new_initName-&gt;get_parent();</span></a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineNoCov">          0 :           ROSE_ASSERT  (old_parent != NULL);</span></a>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineNoCov">          0 :           ROSE_ASSERT  (isSgFunctionParameterList(old_parent) != NULL);</span></a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineNoCov">          0 :           new_initName-&gt;set_parent(varDecl); // adjust parent from SgFunctionParameterList to SgVariableDeclaration</span></a>
<a name="1498"><span class="lineNum">    1498 </span>            : </a>
<a name="1499"><span class="lineNum">    1499 </span>            :        // DQ (1/25/2011): Deleting these causes problems if I use this function in the Fortran support...</a>
<a name="1500"><span class="lineNum">    1500 </span>            :        // delete (default_initName-&gt;get_declptr()); // delete the var definition</a>
<a name="1501"><span class="lineNum">    1501 </span>            :        // delete (default_initName-&gt;get_declptr()); // relink the var definition</a>
<a name="1502"><span class="lineNum">    1502 </span>            : </a>
<a name="1503"><span class="lineNum">    1503 </span><span class="lineNoCov">          0 :           SgVariableDefinition * var_def = isSgVariableDefinition(default_initName-&gt;get_declptr()) ;</span></a>
<a name="1504"><span class="lineNum">    1504 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (var_def != NULL);</span></a>
<a name="1505"><span class="lineNum">    1505 </span><span class="lineNoCov">          0 :           var_def-&gt;set_parent(new_initName);</span></a>
<a name="1506"><span class="lineNum">    1506 </span><span class="lineNoCov">          0 :           var_def-&gt;set_vardefn(new_initName);</span></a>
<a name="1507"><span class="lineNum">    1507 </span><span class="lineNoCov">          0 :           new_initName-&gt;set_declptr(var_def); // it was set to SgProcedureHeaderStatement as a function argument</span></a>
<a name="1508"><span class="lineNum">    1508 </span>            : </a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineNoCov">          0 :           delete (default_initName); // must delete the old one to pass AST consistency test</span></a>
<a name="1510"><span class="lineNum">    1510 </span>            : </a>
<a name="1511"><span class="lineNum">    1511 </span>            :        // DQ (12/13/2011): Is this executed...</a>
<a name="1512"><span class="lineNum">    1512 </span>            :           //printf (&quot;Is this executed \n&quot;);</a>
<a name="1513"><span class="lineNum">    1513 </span>            :           //ROSE_ASSERT(false);</a>
<a name="1514"><span class="lineNum">    1514 </span>            : </a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineNoCov">          0 :           isFortranParameter = true;</span></a>
<a name="1516"><span class="lineNum">    1516 </span>            :         }</a>
<a name="1517"><span class="lineNum">    1517 </span>            :       }</a>
<a name="1518"><span class="lineNum">    1518 </span>            :     }</a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     if (! isFortranParameter) // No need to add symbol to the function body if it is a Fortran parameter</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            :                               // The symbol should already exist under function definition for the parameter</a>
<a name="1521"><span class="lineNum">    1521 </span><span class="lineCov">        779 :       fixVariableDeclaration(varDecl,scope);</span></a>
<a name="1522"><span class="lineNum">    1522 </span>            :   }</a>
<a name="1523"><span class="lineNum">    1523 </span>            : </a>
<a name="1524"><span class="lineNum">    1524 </span><span class="lineCov">        789 :   SgInitializedName *initName = varDecl-&gt;get_decl_item (name);</span></a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">        789 :   ROSE_ASSERT(initName != NULL);</span></a>
<a name="1526"><span class="lineNum">    1526 </span><span class="lineCov">        789 :   ROSE_ASSERT((initName-&gt;get_declptr())!=NULL);</span></a>
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<a name="1528"><span class="lineNum">    1528 </span>            :   //bug 119, SgVariableDefintion's File_info is needed for deep copy to work</a>
<a name="1529"><span class="lineNum">    1529 </span>            :   // AstQuery based setSourcePositionForTransformation() cannot access all child nodes</a>
<a name="1530"><span class="lineNum">    1530 </span>            :   // have to set SgVariableDefintion explicitly</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">        789 :   SgDeclarationStatement* variableDefinition_original = initName-&gt;get_declptr();</span></a>
<a name="1532"><span class="lineNum">    1532 </span><span class="lineCov">        789 :   setOneSourcePositionForTransformation(variableDefinition_original);</span></a>
<a name="1533"><span class="lineNum">    1533 </span><span class="lineCov">        789 :   ROSE_ASSERT((variableDefinition_original-&gt;get_startOfConstruct()) !=NULL);</span></a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineCov">        789 :   ROSE_ASSERT((variableDefinition_original-&gt;get_endOfConstruct())!=NULL);</span></a>
<a name="1535"><span class="lineNum">    1535 </span>            : </a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineCov">        789 :   setSourcePositionAtRootAndAllChildren(varDecl);</span></a>
<a name="1537"><span class="lineNum">    1537 </span>            :   //ROSE_ASSERT (isSgVariableDefinition(initName-&gt;get_declptr())-&gt;get_startOfConstruct()!=NULL);</a>
<a name="1538"><span class="lineNum">    1538 </span>            : </a>
<a name="1539"><span class="lineNum">    1539 </span>            : </a>
<a name="1540"><span class="lineNum">    1540 </span>            :   // DQ (4/16/2015): This is replaced with a better implementation.</a>
<a name="1541"><span class="lineNum">    1541 </span>            :   // DQ (4/15/2015): We should reset the isModified flags as part of the transforamtion</a>
<a name="1542"><span class="lineNum">    1542 </span>            :   // because we have added statements explicitly marked as transformations.</a>
<a name="1543"><span class="lineNum">    1543 </span>            :   // checkIsModifiedFlag(varDecl);</a>
<a name="1544"><span class="lineNum">    1544 </span><span class="lineCov">        789 :      unsetNodesMarkedAsModified(varDecl);</span></a>
<a name="1545"><span class="lineNum">    1545 </span>            : </a>
<a name="1546"><span class="lineNum">    1546 </span><span class="lineCov">        789 :   return varDecl;</span></a>
<a name="1547"><span class="lineNum">    1547 </span>            : }</a>
<a name="1548"><span class="lineNum">    1548 </span>            : </a>
<a name="1549"><span class="lineNum">    1549 </span>            : //-----------------------------------------------</a>
<a name="1550"><span class="lineNum">    1550 </span>            : // could have two declarations for a same variable</a>
<a name="1551"><span class="lineNum">    1551 </span>            : // extern int i;</a>
<a name="1552"><span class="lineNum">    1552 </span>            : //  int i;</a>
<a name="1553"><span class="lineNum">    1553 </span>            : // SgVariableDeclaration* SageBuilder::buildVariableDeclaration_nfi (const SgName &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope, bool builtFromUseOnly)</a>
<a name="1554"><span class="lineNum">    1554 </span>            : SgVariableDeclaration*</a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineCov">      32005 : SageBuilder::buildVariableDeclaration_nfi (const SgName &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope, bool builtFromUseOnly, SgStorageModifier::storage_modifier_enum sm)</span></a>
<a name="1556"><span class="lineNum">    1556 </span>            :  //(const SgName &amp; name, SgType* type, SgInitializer * varInit= NULL, SgScopeStatement* scope = NULL)</a>
<a name="1557"><span class="lineNum">    1557 </span>            :    {</a>
<a name="1558"><span class="lineNum">    1558 </span>            : </a>
<a name="1559"><span class="lineNum">    1559 </span>            : #define DEBUG_BUILD_VARIABLE_DECLARATION 0</a>
<a name="1560"><span class="lineNum">    1560 </span>            : </a>
<a name="1561"><span class="lineNum">    1561 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1562"><span class="lineNum">    1562 </span>            :      printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): name = %s scope = %p varInit = %p \n&quot;,name.str(),scope,varInit);</a>
<a name="1563"><span class="lineNum">    1563 </span>            :      if (scope != NULL)</a>
<a name="1564"><span class="lineNum">    1564 </span>            :         {</a>
<a name="1565"><span class="lineNum">    1565 </span>            :           printf (&quot; --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="1566"><span class="lineNum">    1566 </span>            :         }</a>
<a name="1567"><span class="lineNum">    1567 </span>            : #endif</a>
<a name="1568"><span class="lineNum">    1568 </span>            : </a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">      32005 :      if (scope == NULL)</span></a>
<a name="1570"><span class="lineNum">    1570 </span>            :         {</a>
<a name="1571"><span class="lineNum">    1571 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1572"><span class="lineNum">    1572 </span>            :           printf (&quot;Scope determined from the SageBuilder::topScopeStack() \n&quot;);</a>
<a name="1573"><span class="lineNum">    1573 </span>            : #endif</a>
<a name="1574"><span class="lineNum">    1574 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="1575"><span class="lineNum">    1575 </span>            :         }</a>
<a name="1576"><span class="lineNum">    1576 </span>            : </a>
<a name="1577"><span class="lineNum">    1577 </span><span class="lineCov">      32005 :      ROSE_ASSERT (scope != NULL);</span></a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineCov">      32005 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="1579"><span class="lineNum">    1579 </span>            : </a>
<a name="1580"><span class="lineNum">    1580 </span>            :   // DQ (6/27/20`19): Older simpler version of code.</a>
<a name="1581"><span class="lineNum">    1581 </span>            :   // SgVariableDeclaration * varDecl = new SgVariableDeclaration(name, type, varInit);</a>
<a name="1582"><span class="lineNum">    1582 </span>            : </a>
<a name="1583"><span class="lineNum">    1583 </span>            :   // DQ (7/18/2012): Added debugging code (should fail for test2011_75.C).</a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineCov">      32005 :      SgVariableSymbol* variableSymbol = scope-&gt;lookup_variable_symbol(name);</span></a>
<a name="1585"><span class="lineNum">    1585 </span>            :   // ROSE_ASSERT(variableSymbol == NULL);</a>
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<a name="1587"><span class="lineNum">    1587 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1588"><span class="lineNum">    1588 </span>            :      printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): variableSymbol = %p \n&quot;,variableSymbol);</a>
<a name="1589"><span class="lineNum">    1589 </span>            : #endif</a>
<a name="1590"><span class="lineNum">    1590 </span>            : </a>
<a name="1591"><span class="lineNum">    1591 </span>            :   // If there was a previous use of the variable, then there will be an existing symbol with it's declaration pointing to the SgInitializedName object.</a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineCov">      32005 :      SgVariableDeclaration * varDecl = NULL;</span></a>
<a name="1593"><span class="lineNum">    1593 </span><span class="lineCov">      32005 :      if (variableSymbol == NULL)</span></a>
<a name="1594"><span class="lineNum">    1594 </span>            :         {</a>
<a name="1595"><span class="lineNum">    1595 </span><span class="lineCov">      31612 :           varDecl = new SgVariableDeclaration(name, type, varInit);</span></a>
<a name="1596"><span class="lineNum">    1596 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1597"><span class="lineNum">    1597 </span>            :           SgInitializedName* tmp_initializedName = getFirstInitializedName(varDecl);</a>
<a name="1598"><span class="lineNum">    1598 </span>            :           ROSE_ASSERT(tmp_initializedName != NULL);</a>
<a name="1599"><span class="lineNum">    1599 </span>            :           printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): variableSymbol == NULL: varDecl = %p: initializedName = %p = %s \n&quot;,varDecl,tmp_initializedName,tmp_initializedName-&gt;get_name().str());</a>
<a name="1600"><span class="lineNum">    1600 </span>            :           printf (&quot; --- tmp_initializedName-&gt;get_initptr() = %p \n&quot;,tmp_initializedName-&gt;get_initptr());</a>
<a name="1601"><span class="lineNum">    1601 </span>            : #endif</a>
<a name="1602"><span class="lineNum">    1602 </span>            :        // DQ (6/25/2019): This is a new feature to input the builtFromUseOnly function optional parameter.</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">      31612 :           if (builtFromUseOnly == true)</span></a>
<a name="1604"><span class="lineNum">    1604 </span>            :              {</a>
<a name="1605"><span class="lineNum">    1605 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1606"><span class="lineNum">    1606 </span>            :                printf (&quot;In buildVariableDeclaration_nfi(): this is the first reference to this variable: building a new SgVariableDeclaration: varDecl = %p name = %s \n&quot;,varDecl,name.str());</a>
<a name="1607"><span class="lineNum">    1607 </span>            : #endif</a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineCov">        255 :                varDecl-&gt;set_builtFromUseOnly(true);</span></a>
<a name="1609"><span class="lineNum">    1609 </span>            :              }</a>
<a name="1610"><span class="lineNum">    1610 </span>            :         }</a>
<a name="1611"><span class="lineNum">    1611 </span>            :        else</a>
<a name="1612"><span class="lineNum">    1612 </span>            :         {</a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineCov">        393 :           SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineCov">        393 :           ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="1615"><span class="lineNum">    1615 </span>            : </a>
<a name="1616"><span class="lineNum">    1616 </span>            :        // DQ (9/11/2020): check if this is null and a possible cause of isSgVariableDeclaration() returning an uninitialized value (caught by valgrind).</a>
<a name="1617"><span class="lineNum">    1617 </span>            :        // ROSE_ASSERT(initializedName-&gt;get_parent() != NULL);</a>
<a name="1618"><span class="lineNum">    1618 </span>            : </a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">        393 :           SgVariableDeclaration* associatedVariableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</span></a>
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<a name="1621"><span class="lineNum">    1621 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1622"><span class="lineNum">    1622 </span>            :           printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): initializedName-&gt;get_parent() = %p \n&quot;,initializedName-&gt;get_parent());</a>
<a name="1623"><span class="lineNum">    1623 </span>            :           if (initializedName-&gt;get_parent() != NULL)</a>
<a name="1624"><span class="lineNum">    1624 </span>            :              {</a>
<a name="1625"><span class="lineNum">    1625 </span>            :                printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): initializedName-&gt;get_parent() = %p = %s \n&quot;,initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1626"><span class="lineNum">    1626 </span>            :              }</a>
<a name="1627"><span class="lineNum">    1627 </span>            :           printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): associatedVariableDeclaration = %p \n&quot;,associatedVariableDeclaration);</a>
<a name="1628"><span class="lineNum">    1628 </span>            : #endif</a>
<a name="1629"><span class="lineNum">    1629 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1630"><span class="lineNum">    1630 </span>            :        // DQ (6/24/2019): If this has been previously built as part of a variable use (in a class declaration),</a>
<a name="1631"><span class="lineNum">    1631 </span>            :        // then it should not be attached to the class definition as a variable declaration yet, and we should reuse it.</a>
<a name="1632"><span class="lineNum">    1632 </span>            :           if (associatedVariableDeclaration != NULL &amp;&amp; associatedVariableDeclaration-&gt;get_parent() != NULL)</a>
<a name="1633"><span class="lineNum">    1633 </span>            :              {</a>
<a name="1634"><span class="lineNum">    1634 </span>            :                printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): associatedVariableDeclaration-&gt;get_parent() = %p = %s \n&quot;,</a>
<a name="1635"><span class="lineNum">    1635 </span>            :                     associatedVariableDeclaration-&gt;get_parent(),associatedVariableDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1636"><span class="lineNum">    1636 </span>            :              }</a>
<a name="1637"><span class="lineNum">    1637 </span>            : #endif</a>
<a name="1638"><span class="lineNum">    1638 </span>            :        // DQ (6/25/2019): This is a new feature to input the builtFromUseOnly function optional parameter.</a>
<a name="1639"><span class="lineNum">    1639 </span><span class="lineCov">        393 :           if (builtFromUseOnly == true)</span></a>
<a name="1640"><span class="lineNum">    1640 </span>            :              {</a>
<a name="1641"><span class="lineNum">    1641 </span>            : #if 0</a>
<a name="1642"><span class="lineNum">    1642 </span>            :             // DQ (12/2/2019): Commented out output spew (from new tool).</a>
<a name="1643"><span class="lineNum">    1643 </span>            :                printf (&quot;In buildVariableDeclaration_nfi(): this is a later reference to this variable (after the initial variable declaration and symbol): initializedName = %p name = %s \n&quot;,initializedName,name.str());</a>
<a name="1644"><span class="lineNum">    1644 </span>            : #endif</a>
<a name="1645"><span class="lineNum">    1645 </span>            :             // varDecl-&gt;set_builtFromUseOnly(true);</a>
<a name="1646"><span class="lineNum">    1646 </span>            : #if 0</a>
<a name="1647"><span class="lineNum">    1647 </span>            :             // DQ (7/12/2019): This may be overly conservative when used by the outlining to a seperate file.</a>
<a name="1648"><span class="lineNum">    1648 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1649"><span class="lineNum">    1649 </span>            :                ROSE_ABORT();</a>
<a name="1650"><span class="lineNum">    1650 </span>            : #endif</a>
<a name="1651"><span class="lineNum">    1651 </span>            :              }</a>
<a name="1652"><span class="lineNum">    1652 </span>            : </a>
<a name="1653"><span class="lineNum">    1653 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1654"><span class="lineNum">    1654 </span>            :           printf (&quot;associatedVariableDeclaration = %p \n&quot;,associatedVariableDeclaration);</a>
<a name="1655"><span class="lineNum">    1655 </span>            :           if (associatedVariableDeclaration != NULL)</a>
<a name="1656"><span class="lineNum">    1656 </span>            :              {</a>
<a name="1657"><span class="lineNum">    1657 </span>            :                printf (&quot;associatedVariableDeclaration-&gt;get_builtFromUseOnly() = %s \n&quot;,associatedVariableDeclaration-&gt;get_builtFromUseOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1658"><span class="lineNum">    1658 </span>            :              }</a>
<a name="1659"><span class="lineNum">    1659 </span>            : #endif</a>
<a name="1660"><span class="lineNum">    1660 </span>            : </a>
<a name="1661"><span class="lineNum">    1661 </span>            : #if 0</a>
<a name="1662"><span class="lineNum">    1662 </span>            :        // DQ (9/11/2020): Added to test valgrind.</a>
<a name="1663"><span class="lineNum">    1663 </span>            :           if (associatedVariableDeclaration != NULL)</a>
<a name="1664"><span class="lineNum">    1664 </span>            :              {</a>
<a name="1665"><span class="lineNum">    1665 </span>            :                printf (&quot;associatedVariableDeclaration test: true branch: associatedVariableDeclaration-&gt;get_builtFromUseOnly() = %s \n&quot;,</a>
<a name="1666"><span class="lineNum">    1666 </span>            :                     associatedVariableDeclaration-&gt;get_builtFromUseOnly() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1667"><span class="lineNum">    1667 </span>            :             // ROSE_ASSERT(associatedVariableDeclaration-&gt;get_builtFromUseOnly() == true);</a>
<a name="1668"><span class="lineNum">    1668 </span>            :              }</a>
<a name="1669"><span class="lineNum">    1669 </span>            :             else</a>
<a name="1670"><span class="lineNum">    1670 </span>            :              {</a>
<a name="1671"><span class="lineNum">    1671 </span>            :                printf (&quot;associatedVariableDeclaration test: false branch \n&quot;);</a>
<a name="1672"><span class="lineNum">    1672 </span>            :              }</a>
<a name="1673"><span class="lineNum">    1673 </span>            : </a>
<a name="1674"><span class="lineNum">    1674 </span>            :        // DQ (9/11/2020): Added to test valgrind.</a>
<a name="1675"><span class="lineNum">    1675 </span>            :           if ((associatedVariableDeclaration != NULL) &amp;&amp;</a>
<a name="1676"><span class="lineNum">    1676 </span>            :               (associatedVariableDeclaration-&gt;get_builtFromUseOnly() == true))</a>
<a name="1677"><span class="lineNum">    1677 </span>            :              {</a>
<a name="1678"><span class="lineNum">    1678 </span>            :                printf (&quot;test get_builtFromUseOnly(): true branch \n&quot;);</a>
<a name="1679"><span class="lineNum">    1679 </span>            :                ROSE_ASSERT(associatedVariableDeclaration-&gt;get_builtFromUseOnly() == true);</a>
<a name="1680"><span class="lineNum">    1680 </span>            :              }</a>
<a name="1681"><span class="lineNum">    1681 </span>            :             else</a>
<a name="1682"><span class="lineNum">    1682 </span>            :              {</a>
<a name="1683"><span class="lineNum">    1683 </span>            :                printf (&quot;test get_builtFromUseOnly(): false branch \n&quot;);</a>
<a name="1684"><span class="lineNum">    1684 </span>            :              }</a>
<a name="1685"><span class="lineNum">    1685 </span>            : #endif</a>
<a name="1686"><span class="lineNum">    1686 </span>            : </a>
<a name="1687"><span class="lineNum">    1687 </span>            :        // DQ (6/25/2019): Trigger the reuse of the available variable declaration.</a>
<a name="1688"><span class="lineNum">    1688 </span>            :        // bool reuseTheAssociatedVariableDeclaration = associatedVariableDeclaration-&gt;get_builtFromUseOnly();</a>
<a name="1689"><span class="lineNum">    1689 </span><span class="lineCov">        393 :           bool reuseTheAssociatedVariableDeclaration = ((associatedVariableDeclaration != NULL) &amp;&amp; (associatedVariableDeclaration-&gt;get_builtFromUseOnly() == true));</span></a>
<a name="1690"><span class="lineNum">    1690 </span>            :        // if (associatedVariableDeclaration != NULL)</a>
<a name="1691"><span class="lineNum">    1691 </span>            :        // if (reuseTheAssociatedVariableDeclaration == true &amp;&amp; associatedVariableDeclaration != NULL)</a>
<a name="1692"><span class="lineNum">    1692 </span><span class="lineCov">        393 :           if (reuseTheAssociatedVariableDeclaration == true)</span></a>
<a name="1693"><span class="lineNum">    1693 </span>            :              {</a>
<a name="1694"><span class="lineNum">    1694 </span>            :             // Build a seperate SgVariableDeclaration so that we can avoid sharing the SgInitializedName</a>
<a name="1695"><span class="lineNum">    1695 </span>            :             // (and it's possible initializer which would be an error for the secondary declaration</a>
<a name="1696"><span class="lineNum">    1696 </span>            :             // (the declaration in the class for the case of a static declaration))</a>
<a name="1697"><span class="lineNum">    1697 </span>            : </a>
<a name="1698"><span class="lineNum">    1698 </span><span class="lineCov">        291 :                ROSE_ASSERT(associatedVariableDeclaration != NULL);</span></a>
<a name="1699"><span class="lineNum">    1699 </span>            : </a>
<a name="1700"><span class="lineNum">    1700 </span>            :             // DQ (6/24/2019): Fix this to use the associatedVariableDeclaration.</a>
<a name="1701"><span class="lineNum">    1701 </span>            :             // varDecl = new SgVariableDeclaration(name, type, varInit);</a>
<a name="1702"><span class="lineNum">    1702 </span><span class="lineCov">        291 :                varDecl = associatedVariableDeclaration;</span></a>
<a name="1703"><span class="lineNum">    1703 </span>            : </a>
<a name="1704"><span class="lineNum">    1704 </span>            :             // DQ (6/25/2019): Mark this variable declaration so that it will not be reused again.</a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">        291 :                varDecl-&gt;set_builtFromUseOnly(false);</span></a>
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<a name="1707"><span class="lineNum">    1707 </span>            :             // DQ (6/24/2019): Set the parent to NULL, since we are reusing this variable declaration and it would not have been set correctly before.</a>
<a name="1708"><span class="lineNum">    1708 </span><span class="lineCov">        291 :                varDecl-&gt;set_parent(NULL);</span></a>
<a name="1709"><span class="lineNum">    1709 </span>            : </a>
<a name="1710"><span class="lineNum">    1710 </span>            :             // DQ (6/24/2019): this veriable declaration that is being reused, should not have had an initializer (check this).</a>
<a name="1711"><span class="lineNum">    1711 </span><span class="lineCov">        291 :                SgInitializedName* variable = getFirstInitializedName(varDecl);</span></a>
<a name="1712"><span class="lineNum">    1712 </span><span class="lineCov">        291 :                ROSE_ASSERT(variable != NULL);</span></a>
<a name="1713"><span class="lineNum">    1713 </span>            : </a>
<a name="1714"><span class="lineNum">    1714 </span>            :             // DQ (6/25/2019): See Cxx11_tests/test2019_121.C and Cxx11_tests/test2019_482.C.</a>
<a name="1715"><span class="lineNum">    1715 </span>            :             // ROSE_ASSERT(variable-&gt;get_initptr() == NULL);</a>
<a name="1716"><span class="lineNum">    1716 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1717"><span class="lineNum">    1717 </span>            :                if (variable-&gt;get_initptr() != NULL)</a>
<a name="1718"><span class="lineNum">    1718 </span>            :                   {</a>
<a name="1719"><span class="lineNum">    1719 </span>            :                     printf (&quot;Found initializer associated with variable declaration being reused: variable = %p name = %s \n&quot;,variable,variable-&gt;get_name().str());</a>
<a name="1720"><span class="lineNum">    1720 </span>            :                   }</a>
<a name="1721"><span class="lineNum">    1721 </span>            : #endif</a>
<a name="1722"><span class="lineNum">    1722 </span>            :             // DQ (7/3/2019): Reuse in a conditional will have a valid initializer.</a>
<a name="1723"><span class="lineNum">    1723 </span>            :             // ROSE_ASSERT(variable-&gt;get_initptr() == NULL);</a>
<a name="1724"><span class="lineNum">    1724 </span>            :              }</a>
<a name="1725"><span class="lineNum">    1725 </span>            :             else</a>
<a name="1726"><span class="lineNum">    1726 </span>            :              {</a>
<a name="1727"><span class="lineNum">    1727 </span>            :             // DQ (6/25/2019): We can't reuse the existing SgInitializedName, because it could have been initialized in the other SgVariableDeclaration.</a>
<a name="1728"><span class="lineNum">    1728 </span>            : #if 0</a>
<a name="1729"><span class="lineNum">    1729 </span>            :                printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): We can't reuse the existing SgInitializedName: initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="1730"><span class="lineNum">    1730 </span>            :                printf (&quot; --- initializedName-&gt;get_initptr() = %p \n&quot;,initializedName-&gt;get_initptr());</a>
<a name="1731"><span class="lineNum">    1731 </span>            : #endif</a>
<a name="1732"><span class="lineNum">    1732 </span>            :             // DQ (6/26/2019): Added assertion.</a>
<a name="1733"><span class="lineNum">    1733 </span><span class="lineCov">        102 :                ROSE_ASSERT(reuseTheAssociatedVariableDeclaration == false);</span></a>
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<a name="1735"><span class="lineNum">    1735 </span>            :             // DQ (6/27/2019): If the SgInitializedName was generated from the convert_variable_use() function in the</a>
<a name="1736"><span class="lineNum">    1736 </span>            :             // EDG/ROSE translation, then where was not associated SgVariableDeclaration built (an inconsistancy).</a>
<a name="1737"><span class="lineNum">    1737 </span>            :             // So we want to check for the parent being a scope statement (e.g. SgIfStmt or other statement that can</a>
<a name="1738"><span class="lineNum">    1738 </span>            :             // accept a conditional expression where in C++ it can alternatively declare a variable.</a>
<a name="1739"><span class="lineNum">    1739 </span><span class="lineCov">        102 :                if (associatedVariableDeclaration == NULL)</span></a>
<a name="1740"><span class="lineNum">    1740 </span>            :                   {</a>
<a name="1741"><span class="lineNum">    1741 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(initializedName-&gt;get_parent() != NULL);</span></a>
<a name="1742"><span class="lineNum">    1742 </span><span class="lineNoCov">          0 :                     SgScopeStatement* scopeStatement = isSgScopeStatement(initializedName-&gt;get_parent());</span></a>
<a name="1743"><span class="lineNum">    1743 </span><span class="lineNoCov">          0 :                     if (scopeStatement != NULL)</span></a>
<a name="1744"><span class="lineNum">    1744 </span>            :                        {</a>
<a name="1745"><span class="lineNum">    1745 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1746"><span class="lineNum">    1746 </span>            :                          printf (&quot;scopeStatement = %p = %s \n&quot;,scopeStatement,scopeStatement-&gt;class_name().c_str());</a>
<a name="1747"><span class="lineNum">    1747 </span>            : #endif</a>
<a name="1748"><span class="lineNum">    1748 </span>            :                        }</a>
<a name="1749"><span class="lineNum">    1749 </span>            :                       else</a>
<a name="1750"><span class="lineNum">    1750 </span>            :                        {</a>
<a name="1751"><span class="lineNum">    1751 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1752"><span class="lineNum">    1752 </span>            :                          printf (&quot;initializedName-&gt;get_parent() = %p = %s \n&quot;,initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1753"><span class="lineNum">    1753 </span>            : #endif</a>
<a name="1754"><span class="lineNum">    1754 </span>            :                        }</a>
<a name="1755"><span class="lineNum">    1755 </span>            :                   }</a>
<a name="1756"><span class="lineNum">    1756 </span>            : </a>
<a name="1757"><span class="lineNum">    1757 </span>            :             // DQ (6/27/2019): In some case we want to reuse the associated SgInitializedName node.</a>
<a name="1758"><span class="lineNum">    1758 </span>            :             // For example: variable declarations in conditionals (e.g. SgIfStmt, and other scope statements).</a>
<a name="1759"><span class="lineNum">    1759 </span>            :             // DQ (6/26/2019): Build an additional variable to support another reference to the original variable.</a>
<a name="1760"><span class="lineNum">    1760 </span>            :             // Note: we need another one because either one can have an initializer that cannot be shared in the AST.</a>
<a name="1761"><span class="lineNum">    1761 </span>            :             // SgInitializedName* additional_variable = buildInitializedName_nfi(name,type,varInit);</a>
<a name="1762"><span class="lineNum">    1762 </span><span class="lineCov">        102 :                SgInitializedName* additional_variable = NULL;</span></a>
<a name="1763"><span class="lineNum">    1763 </span>            : </a>
<a name="1764"><span class="lineNum">    1764 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1765"><span class="lineNum">    1765 </span>            :                printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): initializedName-&gt;get_scope()     = %p = %s \n&quot;,initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="1766"><span class="lineNum">    1766 </span>            : #endif</a>
<a name="1767"><span class="lineNum">    1767 </span><span class="lineCov">        102 :                SgScopeStatement* scopeStatement = isSgScopeStatement(initializedName-&gt;get_parent());</span></a>
<a name="1768"><span class="lineNum">    1768 </span>            :             // ROSE_ASSERT(additional_variable-&gt;get_scope() != NULL);</a>
<a name="1769"><span class="lineNum">    1769 </span><span class="lineCov">        102 :                if (scopeStatement != NULL)</span></a>
<a name="1770"><span class="lineNum">    1770 </span>            :                   {</a>
<a name="1771"><span class="lineNum">    1771 </span><span class="lineNoCov">          0 :                     additional_variable = initializedName;</span></a>
<a name="1772"><span class="lineNum">    1772 </span>            : </a>
<a name="1773"><span class="lineNum">    1773 </span>            :                  // DQ (6/28/2019): Support case when the borrowed SgInitializedName has a valid initializer.</a>
<a name="1774"><span class="lineNum">    1774 </span>            :                  // DQ (6/26/2019): Adding the initializer.</a>
<a name="1775"><span class="lineNum">    1775 </span>            :                  // ROSE_ASSERT(additional_variable-&gt;get_initptr() == NULL);</a>
<a name="1776"><span class="lineNum">    1776 </span>            :                  // additional_variable-&gt;set_initptr(varInit);</a>
<a name="1777"><span class="lineNum">    1777 </span><span class="lineNoCov">          0 :                     if (additional_variable-&gt;get_initptr() != NULL)</span></a>
<a name="1778"><span class="lineNum">    1778 </span>            :                        {</a>
<a name="1779"><span class="lineNum">    1779 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1780"><span class="lineNum">    1780 </span>            :                          printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): borrowed SgInitializedName is alread initialized \n&quot;);</a>
<a name="1781"><span class="lineNum">    1781 </span>            :                          printf (&quot; --- additional_variable-&gt;get_initptr() = %p \n&quot;,additional_variable-&gt;get_initptr());</a>
<a name="1782"><span class="lineNum">    1782 </span>            :                          printf (&quot; --- varInit = %p \n&quot;,varInit);</a>
<a name="1783"><span class="lineNum">    1783 </span>            : #endif</a>
<a name="1784"><span class="lineNum">    1784 </span>            :                       // DQ (6/28/2019): when this is assertion is false, we have constructed a redundant initializer (debugging this).</a>
<a name="1785"><span class="lineNum">    1785 </span>            :                          // PP (7/22/2019) faults in CUDA code</a>
<a name="1786"><span class="lineNum">    1786 </span>            :                          // ROSE_ASSERT(varInit == NULL);</a>
<a name="1787"><span class="lineNum">    1787 </span>            :                        }</a>
<a name="1788"><span class="lineNum">    1788 </span>            :                       else</a>
<a name="1789"><span class="lineNum">    1789 </span>            :                        {</a>
<a name="1790"><span class="lineNum">    1790 </span><span class="lineNoCov">          0 :                          additional_variable-&gt;set_initptr(varInit);</span></a>
<a name="1791"><span class="lineNum">    1791 </span>            :                        }</a>
<a name="1792"><span class="lineNum">    1792 </span>            : </a>
<a name="1793"><span class="lineNum">    1793 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION || 0</a>
<a name="1794"><span class="lineNum">    1794 </span>            :                     printf (&quot; --- additional_variable-&gt;get_scope() = %p = %s \n&quot;,additional_variable-&gt;get_scope(),additional_variable-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="1795"><span class="lineNum">    1795 </span>            :                     printf (&quot; --- Reusing the SgInitializedName (not associated with a previous SgVariableDeclaration where the parent is a SgScopeStatement) \n&quot;);</a>
<a name="1796"><span class="lineNum">    1796 </span>            : #endif</a>
<a name="1797"><span class="lineNum">    1797 </span>            :                   }</a>
<a name="1798"><span class="lineNum">    1798 </span>            :                  else</a>
<a name="1799"><span class="lineNum">    1799 </span>            :                   {</a>
<a name="1800"><span class="lineNum">    1800 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1801"><span class="lineNum">    1801 </span>            :                     printf (&quot; --- Building a new SgInitializedName \n&quot;);</a>
<a name="1802"><span class="lineNum">    1802 </span>            : #endif</a>
<a name="1803"><span class="lineNum">    1803 </span><span class="lineCov">        102 :                     additional_variable = buildInitializedName_nfi(name,type,varInit);</span></a>
<a name="1804"><span class="lineNum">    1804 </span>            :                   }</a>
<a name="1805"><span class="lineNum">    1805 </span>            : </a>
<a name="1806"><span class="lineNum">    1806 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1807"><span class="lineNum">    1807 </span>            :                ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</a>
<a name="1808"><span class="lineNum">    1808 </span>            : #endif</a>
<a name="1809"><span class="lineNum">    1809 </span>            :             // DQ (6/26/2019): Set the scopes to be the same (a symbol already exists at this point).</a>
<a name="1810"><span class="lineNum">    1810 </span>            :             // additional_variable-&gt;set_scope(initializedName-&gt;get_scope());</a>
<a name="1811"><span class="lineNum">    1811 </span>            :             // initializedName-&gt;set_scope(additional_variable-&gt;get_scope());</a>
<a name="1812"><span class="lineNum">    1812 </span>            :             // additional_variable-&gt;set_scope(initializedName-&gt;get_scope());</a>
<a name="1813"><span class="lineNum">    1813 </span>            : </a>
<a name="1814"><span class="lineNum">    1814 </span>            :             // DQ (6/26/2019): Set the pointer to the original version of this variable (unless we reused the SgInitializedName above).</a>
<a name="1815"><span class="lineNum">    1815 </span><span class="lineCov">        102 :                if (additional_variable != initializedName)</span></a>
<a name="1816"><span class="lineNum">    1816 </span>            :                   {</a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineCov">        102 :                     additional_variable-&gt;set_prev_decl_item(initializedName);</span></a>
<a name="1818"><span class="lineNum">    1818 </span>            :                   }</a>
<a name="1819"><span class="lineNum">    1819 </span>            : </a>
<a name="1820"><span class="lineNum">    1820 </span>            :             // If there is not an associated SgVariableDeclaration then reuse the existing SgInitializedName.</a>
<a name="1821"><span class="lineNum">    1821 </span>            :             // varDecl = new SgVariableDeclaration(initializedName);</a>
<a name="1822"><span class="lineNum">    1822 </span><span class="lineCov">        102 :                varDecl = new SgVariableDeclaration(additional_variable);</span></a>
<a name="1823"><span class="lineNum">    1823 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1824"><span class="lineNum">    1824 </span>            :                ROSE_ASSERT(initializedName-&gt;get_parent() != NULL);</a>
<a name="1825"><span class="lineNum">    1825 </span>            :                printf (&quot;initializedName-&gt;get_parent()     = %p = %s \n&quot;,initializedName-&gt;get_parent(),initializedName-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1826"><span class="lineNum">    1826 </span>            :                ROSE_ASSERT(additional_variable-&gt;get_parent() != NULL);</a>
<a name="1827"><span class="lineNum">    1827 </span>            :                printf (&quot;additional_variable-&gt;get_parent() = %p = %s \n&quot;,additional_variable-&gt;get_parent(),additional_variable-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1828"><span class="lineNum">    1828 </span>            : #endif</a>
<a name="1829"><span class="lineNum">    1829 </span>            :             // DQ (6/26/2019): Set the parent of the first SgInitializedName to that of the second SgInitializedName.</a>
<a name="1830"><span class="lineNum">    1830 </span>            :             // This is an issue for the range for initialization: see test2019_483.C.</a>
<a name="1831"><span class="lineNum">    1831 </span>            :             // initializedName-&gt;set_parent(additional_variable-&gt;get_parent());</a>
<a name="1832"><span class="lineNum">    1832 </span>            : </a>
<a name="1833"><span class="lineNum">    1833 </span>            : #if 0</a>
<a name="1834"><span class="lineNum">    1834 </span>            :                SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(additional_variable-&gt;get_parent());</a>
<a name="1835"><span class="lineNum">    1835 </span>            :                if (variableDeclaration != NULL)</a>
<a name="1836"><span class="lineNum">    1836 </span>            :                   {</a>
<a name="1837"><span class="lineNum">    1837 </span>            : #if 0</a>
<a name="1838"><span class="lineNum">    1838 </span>            :                     printf (&quot;Found SgVariableDeclaration at additional_variable-&gt;get_parent() \n&quot;);</a>
<a name="1839"><span class="lineNum">    1839 </span>            :                     ROSE_ASSERT(variableDeclaration-&gt;get_parent() != NULL);</a>
<a name="1840"><span class="lineNum">    1840 </span>            :                     printf (&quot;  --- variableDeclaration-&gt;get_parent() = %p = %s \n&quot;,variableDeclaration-&gt;get_parent(),variableDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1841"><span class="lineNum">    1841 </span>            : #endif</a>
<a name="1842"><span class="lineNum">    1842 </span>            :                     SgRangeBasedForStatement* rangeBasedForStatement = isSgRangeBasedForStatement(variableDeclaration-&gt;get_parent());</a>
<a name="1843"><span class="lineNum">    1843 </span>            :                     if (rangeBasedForStatement != NULL)</a>
<a name="1844"><span class="lineNum">    1844 </span>            :                        {</a>
<a name="1845"><span class="lineNum">    1845 </span>            : #if 0</a>
<a name="1846"><span class="lineNum">    1846 </span>            :                          printf (&quot;Found SgRangeBasedForStatement at variableDeclaration-&gt;get_parent(): set scope of initializedName \n&quot;);</a>
<a name="1847"><span class="lineNum">    1847 </span>            : #endif</a>
<a name="1848"><span class="lineNum">    1848 </span>            :                          initializedName-&gt;set_scope(rangeBasedForStatement);</a>
<a name="1849"><span class="lineNum">    1849 </span>            :                        }</a>
<a name="1850"><span class="lineNum">    1850 </span>            :                   }</a>
<a name="1851"><span class="lineNum">    1851 </span>            : #endif</a>
<a name="1852"><span class="lineNum">    1852 </span>            :             // DQ (6/26/2019): Adding assertion after setting of the SgRangeBasedForStatement before processing the children.</a>
<a name="1853"><span class="lineNum">    1853 </span><span class="lineCov">        102 :                ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="1854"><span class="lineNum">    1854 </span>            : </a>
<a name="1855"><span class="lineNum">    1855 </span>            :             // DQ (6/26/2019): Set the pointer to the original version of this variable (unless we reused the SgInitializedName above).</a>
<a name="1856"><span class="lineNum">    1856 </span><span class="lineCov">        102 :                if (additional_variable != initializedName)</span></a>
<a name="1857"><span class="lineNum">    1857 </span>            :                   {</a>
<a name="1858"><span class="lineNum">    1858 </span><span class="lineCov">        102 :                     additional_variable-&gt;set_scope(initializedName-&gt;get_scope());</span></a>
<a name="1859"><span class="lineNum">    1859 </span>            :                   }</a>
<a name="1860"><span class="lineNum">    1860 </span>            : #if 0</a>
<a name="1861"><span class="lineNum">    1861 </span>            :             // DQ (6/25/2019): This step overwrites the non-null pointer to the initializer with a null pointer to the initializer in Cxx11_tests/test2019_482.C.</a>
<a name="1862"><span class="lineNum">    1862 </span>            :                if (initializedName-&gt;get_initptr() != NULL &amp;&amp; varInit == NULL)</a>
<a name="1863"><span class="lineNum">    1863 </span>            :                   {</a>
<a name="1864"><span class="lineNum">    1864 </span>            :                     printf (&quot;ERROR: This step overwrites the non-null pointer to the initializer with a null pointer to the initializer in Cxx11_tests/test2019_482.C \n&quot;);</a>
<a name="1865"><span class="lineNum">    1865 </span>            :                     ROSE_ABORT();</a>
<a name="1866"><span class="lineNum">    1866 </span>            :                   }</a>
<a name="1867"><span class="lineNum">    1867 </span>            : #endif</a>
<a name="1868"><span class="lineNum">    1868 </span>            :             // DQ (7/14/2014): Set the variable initialized (see test2014_107.C, also required for boost for_each support)).</a>
<a name="1869"><span class="lineNum">    1869 </span>            :             // initializedName-&gt;set_initptr(varInit);</a>
<a name="1870"><span class="lineNum">    1870 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1871"><span class="lineNum">    1871 </span>            :                printf (&quot;In SageBuilder::buildVariableDeclaration_nfi(): After sharing the exisitng SgInitializedName: initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="1872"><span class="lineNum">    1872 </span>            :                printf (&quot; --- initializedName-&gt;get_initptr()     = %p \n&quot;,initializedName-&gt;get_initptr());</a>
<a name="1873"><span class="lineNum">    1873 </span>            :                printf (&quot; --- additional_variable-&gt;get_initptr() = %p \n&quot;,additional_variable-&gt;get_initptr());</a>
<a name="1874"><span class="lineNum">    1874 </span>            : #endif</a>
<a name="1875"><span class="lineNum">    1875 </span>            :              }</a>
<a name="1876"><span class="lineNum">    1876 </span>            :         }</a>
<a name="1877"><span class="lineNum">    1877 </span>            : </a>
<a name="1878"><span class="lineNum">    1878 </span>            :   // DQ (11/3/2012): The SgInitializedName inside the SgVariableDeclaration must have valid source position object (even if default initialized).</a>
<a name="1879"><span class="lineNum">    1879 </span><span class="lineCov">      32005 :      SgInitializedName* variable = getFirstInitializedName(varDecl);</span></a>
<a name="1880"><span class="lineNum">    1880 </span><span class="lineCov">      32005 :      ROSE_ASSERT(variable != NULL);</span></a>
<a name="1881"><span class="lineNum">    1881 </span><span class="lineCov">      32005 :      setSourcePosition(variable);</span></a>
<a name="1882"><span class="lineNum">    1882 </span>            : </a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineCov">      32005 :      ROSE_ASSERT(varDecl != NULL);</span></a>
<a name="1884"><span class="lineNum">    1884 </span>            : </a>
<a name="1885"><span class="lineNum">    1885 </span><span class="lineCov">      32005 :      varDecl-&gt;set_firstNondefiningDeclaration(varDecl);</span></a>
<a name="1886"><span class="lineNum">    1886 </span>            : </a>
<a name="1887"><span class="lineNum">    1887 </span><span class="lineCov">      32005 :      varDecl-&gt;get_declarationModifier().get_storageModifier().set_modifier(sm);</span></a>
<a name="1888"><span class="lineNum">    1888 </span>            : </a>
<a name="1889"><span class="lineNum">    1889 </span>            :   // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).</a>
<a name="1890"><span class="lineNum">    1890 </span><span class="lineCov">      32005 :      ROSE_ASSERT(varDecl-&gt;get_parent() == NULL);</span></a>
<a name="1891"><span class="lineNum">    1891 </span>            : </a>
<a name="1892"><span class="lineNum">    1892 </span><span class="lineCov">      32005 :      if (name != &quot;&quot;)</span></a>
<a name="1893"><span class="lineNum">    1893 </span>            :         {</a>
<a name="1894"><span class="lineNum">    1894 </span>            :        // Anonymous bit fields should not have symbols</a>
<a name="1895"><span class="lineNum">    1895 </span><span class="lineCov">      31629 :           fixVariableDeclaration(varDecl,scope);</span></a>
<a name="1896"><span class="lineNum">    1896 </span>            : </a>
<a name="1897"><span class="lineNum">    1897 </span>            :        // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).</a>
<a name="1898"><span class="lineNum">    1898 </span>            :        // ROSE_ASSERT(varDecl-&gt;get_parent() == NULL);</a>
<a name="1899"><span class="lineNum">    1899 </span>            :         }</a>
<a name="1900"><span class="lineNum">    1900 </span>            :        else</a>
<a name="1901"><span class="lineNum">    1901 </span>            :         {</a>
<a name="1902"><span class="lineNum">    1902 </span>            :        // DQ (7/12/2012): This is not correct for C++ (to use the input scope), so don't set it here (unless we use the current scope instead of scope).</a>
<a name="1903"><span class="lineNum">    1903 </span>            :        // Yes, let's set it to the current top of the scope stack.  This might be a problem if the scope stack is not being used...</a>
<a name="1904"><span class="lineNum">    1904 </span>            : </a>
<a name="1905"><span class="lineNum">    1905 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1906"><span class="lineNum">    1906 </span>            :        // DQ (6/25/2018): I think this is incorrect for test2018_109.C.</a>
<a name="1907"><span class="lineNum">    1907 </span>            :           SgScopeStatement* current_scope = topScopeStack();</a>
<a name="1908"><span class="lineNum">    1908 </span>            :           printf (&quot;  --- Setting parent using topScopeStack() = %p = %s = %s \n&quot;,current_scope,current_scope-&gt;class_name().c_str(),SageInterface::get_name(current_scope).c_str());</a>
<a name="1909"><span class="lineNum">    1909 </span>            : #endif</a>
<a name="1910"><span class="lineNum">    1910 </span><span class="lineCov">        376 :           varDecl-&gt;set_parent(topScopeStack());</span></a>
<a name="1911"><span class="lineNum">    1911 </span><span class="lineCov">        376 :           ROSE_ASSERT(varDecl-&gt;get_parent() != NULL);</span></a>
<a name="1912"><span class="lineNum">    1912 </span>            :         }</a>
<a name="1913"><span class="lineNum">    1913 </span>            : </a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineCov">      32005 :      SgInitializedName *initName = varDecl-&gt;get_decl_item (name);</span></a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineCov">      32005 :      ROSE_ASSERT(initName);</span></a>
<a name="1916"><span class="lineNum">    1916 </span><span class="lineCov">      32005 :      ROSE_ASSERT(initName-&gt;get_declptr() != NULL);</span></a>
<a name="1917"><span class="lineNum">    1917 </span>            : </a>
<a name="1918"><span class="lineNum">    1918 </span>            :   // DQ (5/17/2013): Added test.</a>
<a name="1919"><span class="lineNum">    1919 </span><span class="lineCov">      32005 :      if (initName-&gt;get_scope() == NULL)</span></a>
<a name="1920"><span class="lineNum">    1920 </span>            :         {</a>
<a name="1921"><span class="lineNum">    1921 </span>            :        // Make this a warning for the few places where this fails.</a>
<a name="1922"><span class="lineNum">    1922 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1923"><span class="lineNum">    1923 </span>            :           printf (&quot;WARNING: Note in buildVariableDeclaration_nfi(): initName-&gt;get_scope() == NULL \n&quot;);</a>
<a name="1924"><span class="lineNum">    1924 </span>            : #endif</a>
<a name="1925"><span class="lineNum">    1925 </span>            :         }</a>
<a name="1926"><span class="lineNum">    1926 </span>            :   // ROSE_ASSERT(initName-&gt;get_scope() != NULL);</a>
<a name="1927"><span class="lineNum">    1927 </span>            : </a>
<a name="1928"><span class="lineNum">    1928 </span>            :   // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).</a>
<a name="1929"><span class="lineNum">    1929 </span>            :   // ROSE_ASSERT(varDecl-&gt;get_parent() == NULL);</a>
<a name="1930"><span class="lineNum">    1930 </span>            : </a>
<a name="1931"><span class="lineNum">    1931 </span>            : #if 1</a>
<a name="1932"><span class="lineNum">    1932 </span>            :   // bug 119, SgVariableDefintion's File_info is needed for deep copy to work</a>
<a name="1933"><span class="lineNum">    1933 </span>            :   // AstQuery based setSourcePositionForTransformation() cannot access all child nodes</a>
<a name="1934"><span class="lineNum">    1934 </span>            :   // have to set SgVariableDefintion explicitly</a>
<a name="1935"><span class="lineNum">    1935 </span><span class="lineCov">      32005 :      SgVariableDefinition* variableDefinition_original = isSgVariableDefinition(initName-&gt;get_declptr());</span></a>
<a name="1936"><span class="lineNum">    1936 </span><span class="lineCov">      32005 :      ROSE_ASSERT(variableDefinition_original != NULL);</span></a>
<a name="1937"><span class="lineNum">    1937 </span><span class="lineCov">      32005 :      setOneSourcePositionNull(variableDefinition_original);</span></a>
<a name="1938"><span class="lineNum">    1938 </span>            : #endif</a>
<a name="1939"><span class="lineNum">    1939 </span><span class="lineCov">      32005 :      setOneSourcePositionNull(varDecl);</span></a>
<a name="1940"><span class="lineNum">    1940 </span>            : </a>
<a name="1941"><span class="lineNum">    1941 </span>            : #if 0</a>
<a name="1942"><span class="lineNum">    1942 </span>            :   // DQ (1/2/2010): Set the defining declaration to itself.</a>
<a name="1943"><span class="lineNum">    1943 </span>            :      if (varDecl-&gt;get_definingDeclaration() == NULL)</a>
<a name="1944"><span class="lineNum">    1944 </span>            :           varDecl-&gt;set_definingDeclaration(varDecl);</a>
<a name="1945"><span class="lineNum">    1945 </span>            : #endif</a>
<a name="1946"><span class="lineNum">    1946 </span>            : </a>
<a name="1947"><span class="lineNum">    1947 </span>            :   // DQ (7/12/2012): The parent should be set to the current scope (not the same as that specified</a>
<a name="1948"><span class="lineNum">    1948 </span>            :   // in the scope (since that applies to the variable (SgInitializedName) not the SgVariableDeclaration).</a>
<a name="1949"><span class="lineNum">    1949 </span>            :   // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).</a>
<a name="1950"><span class="lineNum">    1950 </span>            :   // ROSE_ASSERT(varDecl-&gt;get_parent() == NULL);</a>
<a name="1951"><span class="lineNum">    1951 </span>            :   // Liao, 1/23/2013, quick fix for now, this condition is a mirror to the code setting parent in SageInterface::fixVariableDeclaration()</a>
<a name="1952"><span class="lineNum">    1952 </span><span class="lineCov">      32005 :      if (topScopeStack() != NULL)</span></a>
<a name="1953"><span class="lineNum">    1953 </span>            :         {</a>
<a name="1954"><span class="lineNum">    1954 </span><span class="lineCov">      32005 :           ROSE_ASSERT(varDecl-&gt;get_parent() != NULL);</span></a>
<a name="1955"><span class="lineNum">    1955 </span>            :         }</a>
<a name="1956"><span class="lineNum">    1956 </span>            : </a>
<a name="1957"><span class="lineNum">    1957 </span>            :   // ROSE_ASSERT (varDecl-&gt;get_declarationModifier().get_accessModifier().isPublic() == false);</a>
<a name="1958"><span class="lineNum">    1958 </span>            : </a>
<a name="1959"><span class="lineNum">    1959 </span>            :   // DQ (4/16/2015): This is replaced with a better implementation.</a>
<a name="1960"><span class="lineNum">    1960 </span>            :   // DQ (4/15/2015): We should reset the isModified flags as part of the transforamtion</a>
<a name="1961"><span class="lineNum">    1961 </span>            :   // because we have added statements explicitly marked as transformations.</a>
<a name="1962"><span class="lineNum">    1962 </span>            :   // checkIsModifiedFlag(varDecl);</a>
<a name="1963"><span class="lineNum">    1963 </span><span class="lineCov">      32005 :      unsetNodesMarkedAsModified(varDecl);</span></a>
<a name="1964"><span class="lineNum">    1964 </span>            : </a>
<a name="1965"><span class="lineNum">    1965 </span>            :   // DQ (6/25/2018): Added assertion.</a>
<a name="1966"><span class="lineNum">    1966 </span><span class="lineCov">      32005 :      ROSE_ASSERT(varDecl != NULL);</span></a>
<a name="1967"><span class="lineNum">    1967 </span>            : </a>
<a name="1968"><span class="lineNum">    1968 </span>            : #if DEBUG_BUILD_VARIABLE_DECLARATION</a>
<a name="1969"><span class="lineNum">    1969 </span>            :      printf (&quot;Leaving buildVariableDeclaration_nfi(): varDecl = %p varDecl-&gt;get_parent() = %p \n&quot;,varDecl,varDecl-&gt;get_parent());</a>
<a name="1970"><span class="lineNum">    1970 </span>            : #endif</a>
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<a name="1972"><span class="lineNum">    1972 </span><span class="lineCov">      32005 :      return varDecl;</span></a>
<a name="1973"><span class="lineNum">    1973 </span>            :    }</a>
<a name="1974"><span class="lineNum">    1974 </span>            : </a>
<a name="1975"><span class="lineNum">    1975 </span>            : </a>
<a name="1976"><span class="lineNum">    1976 </span>            : SgVariableDefinition*</a>
<a name="1977"><span class="lineNum">    1977 </span><span class="lineCov">      34364 : SageBuilder::buildVariableDefinition_nfi (SgVariableDeclaration* decl, SgInitializedName* init_name,  SgInitializer *init)</span></a>
<a name="1978"><span class="lineNum">    1978 </span>            : {</a>
<a name="1979"><span class="lineNum">    1979 </span>            : // refactored from ROSETTA/Grammar/Statement.code SgVariableDeclaration::append_variable ()</a>
<a name="1980"><span class="lineNum">    1980 </span>            : </a>
<a name="1981"><span class="lineNum">    1981 </span><span class="lineCov">      34364 :   ROSE_ASSERT (decl!=NULL);</span></a>
<a name="1982"><span class="lineNum">    1982 </span><span class="lineCov">      34364 :   ROSE_ASSERT (init_name !=NULL);</span></a>
<a name="1983"><span class="lineNum">    1983 </span>            :   // init can be NULL</a>
<a name="1984"><span class="lineNum">    1984 </span>            : </a>
<a name="1985"><span class="lineNum">    1985 </span><span class="lineCov">      34364 :   SgVariableDefinition *defn_stmt = NULL;</span></a>
<a name="1986"><span class="lineNum">    1986 </span><span class="lineCov">      34364 :   if (!isSgFunctionType(init_name-&gt;get_type()))</span></a>
<a name="1987"><span class="lineNum">    1987 </span>            :   {</a>
<a name="1988"><span class="lineNum">    1988 </span><span class="lineCov">      34364 :     Sg_File_Info* copyOfFileInfo = NULL;</span></a>
<a name="1989"><span class="lineNum">    1989 </span><span class="lineCov">      34364 :     if (decl-&gt;get_file_info() != NULL)</span></a>
<a name="1990"><span class="lineNum">    1990 </span>            :     {</a>
<a name="1991"><span class="lineNum">    1991 </span><span class="lineCov">        952 :       copyOfFileInfo = new Sg_File_Info(*(decl-&gt;get_file_info()));</span></a>
<a name="1992"><span class="lineNum">    1992 </span><span class="lineCov">        952 :       ROSE_ASSERT (copyOfFileInfo != NULL);</span></a>
<a name="1993"><span class="lineNum">    1993 </span>            : </a>
<a name="1994"><span class="lineNum">    1994 </span>            :       // Note that the SgVariableDefinition will connect the new IR node into the AST.</a>
<a name="1995"><span class="lineNum">    1995 </span><span class="lineCov">        952 :       defn_stmt = new SgVariableDefinition(copyOfFileInfo, init_name, init);</span></a>
<a name="1996"><span class="lineNum">    1996 </span><span class="lineCov">        952 :       assert (defn_stmt != NULL);</span></a>
<a name="1997"><span class="lineNum">    1997 </span>            : </a>
<a name="1998"><span class="lineNum">    1998 </span><span class="lineCov">        952 :       copyOfFileInfo-&gt;set_parent(defn_stmt);</span></a>
<a name="1999"><span class="lineNum">    1999 </span>            : </a>
<a name="2000"><span class="lineNum">    2000 </span>            :       // DQ (3/13/2007): We can't enforce that the endOfConstruct is set (if the interface using the startOfConstruct is used.</a>
<a name="2001"><span class="lineNum">    2001 </span>            :       // DQ (2/3/2007): Need to build the endOfConstruct position as well.</a>
<a name="2002"><span class="lineNum">    2002 </span>            :       // ROSE_ASSERT(this-&gt;get_endOfConstruct() != NULL);</a>
<a name="2003"><span class="lineNum">    2003 </span><span class="lineCov">        952 :       if (decl-&gt;get_endOfConstruct() != NULL)</span></a>
<a name="2004"><span class="lineNum">    2004 </span>            :       {</a>
<a name="2005"><span class="lineNum">    2005 </span><span class="lineCov">        952 :         Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(decl-&gt;get_endOfConstruct()));</span></a>
<a name="2006"><span class="lineNum">    2006 </span><span class="lineCov">        952 :         defn_stmt-&gt;set_endOfConstruct(copyOfEndOfConstruct);</span></a>
<a name="2007"><span class="lineNum">    2007 </span><span class="lineCov">        952 :         copyOfEndOfConstruct-&gt;set_parent(defn_stmt);</span></a>
<a name="2008"><span class="lineNum">    2008 </span>            :       }</a>
<a name="2009"><span class="lineNum">    2009 </span>            :     }</a>
<a name="2010"><span class="lineNum">    2010 </span>            :     else</a>
<a name="2011"><span class="lineNum">    2011 </span>            :     {</a>
<a name="2012"><span class="lineNum">    2012 </span>            :       // Note that the SgVariableDefinition will connect the new IR node into the AST.</a>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineCov">      33412 :       defn_stmt = new SgVariableDefinition(init_name, init);</span></a>
<a name="2014"><span class="lineNum">    2014 </span>            :     }</a>
<a name="2015"><span class="lineNum">    2015 </span><span class="lineCov">      34364 :     ROSE_ASSERT(defn_stmt != NULL);</span></a>
<a name="2016"><span class="lineNum">    2016 </span>            :   }</a>
<a name="2017"><span class="lineNum">    2017 </span>            :   else</a>
<a name="2018"><span class="lineNum">    2018 </span>            :     defn_stmt = NULL;</a>
<a name="2019"><span class="lineNum">    2019 </span><span class="lineCov">      34364 :   return defn_stmt ;</span></a>
<a name="2020"><span class="lineNum">    2020 </span>            : }</a>
<a name="2021"><span class="lineNum">    2021 </span>            : </a>
<a name="2022"><span class="lineNum">    2022 </span>            : </a>
<a name="2023"><span class="lineNum">    2023 </span>            : SgTemplateVariableDeclaration*</a>
<a name="2024"><span class="lineNum">    2024 </span><span class="lineCov">          4 : SageBuilder::buildTemplateVariableDeclaration (const SgName &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)</span></a>
<a name="2025"><span class="lineNum">    2025 </span>            : {</a>
<a name="2026"><span class="lineNum">    2026 </span><span class="lineCov">          4 :   SgTemplateVariableDeclaration* res = buildTemplateVariableDeclaration_nfi(name, type, varInit, scope);</span></a>
<a name="2027"><span class="lineNum">    2027 </span><span class="lineCov">          4 :   setOneSourcePositionForTransformation(res);</span></a>
<a name="2028"><span class="lineNum">    2028 </span><span class="lineCov">          4 :   return res;</span></a>
<a name="2029"><span class="lineNum">    2029 </span>            : }</a>
<a name="2030"><span class="lineNum">    2030 </span>            : </a>
<a name="2031"><span class="lineNum">    2031 </span>            : // DQ (12/6/2011): Adding support for template declarations into the AST.</a>
<a name="2032"><span class="lineNum">    2032 </span>            : // SgTemplateDeclaration*</a>
<a name="2033"><span class="lineNum">    2033 </span>            : // SgVariableDeclaration*</a>
<a name="2034"><span class="lineNum">    2034 </span>            : // SgTemplateVariableDeclaration* buildTemplateVariableDeclaration_nfi(const SgName &amp; name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope);</a>
<a name="2035"><span class="lineNum">    2035 </span>            : SgTemplateVariableDeclaration*</a>
<a name="2036"><span class="lineNum">    2036 </span><span class="lineCov">        909 : SageBuilder::buildTemplateVariableDeclaration_nfi (const SgName &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)</span></a>
<a name="2037"><span class="lineNum">    2037 </span>            :    {</a>
<a name="2038"><span class="lineNum">    2038 </span><span class="lineCov">        909 :      ROSE_ASSERT (scope != NULL);</span></a>
<a name="2039"><span class="lineNum">    2039 </span><span class="lineCov">        909 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="2040"><span class="lineNum">    2040 </span>            : </a>
<a name="2041"><span class="lineNum">    2041 </span><span class="lineCov">        909 :      SgTemplateVariableDeclaration * varDecl = new SgTemplateVariableDeclaration(name, type, varInit);</span></a>
<a name="2042"><span class="lineNum">    2042 </span><span class="lineCov">        909 :      ROSE_ASSERT(varDecl);</span></a>
<a name="2043"><span class="lineNum">    2043 </span>            : </a>
<a name="2044"><span class="lineNum">    2044 </span><span class="lineCov">        909 :      varDecl-&gt;set_firstNondefiningDeclaration(varDecl);</span></a>
<a name="2045"><span class="lineNum">    2045 </span>            : </a>
<a name="2046"><span class="lineNum">    2046 </span>            :   // DQ (11/3/2012): The SgInitializedName inside the SgVariableDeclaration must have valid source position object (even if default initialized).</a>
<a name="2047"><span class="lineNum">    2047 </span><span class="lineCov">        909 :      SgInitializedName* variable = getFirstInitializedName(varDecl);</span></a>
<a name="2048"><span class="lineNum">    2048 </span><span class="lineCov">        909 :      ROSE_ASSERT(variable != NULL);</span></a>
<a name="2049"><span class="lineNum">    2049 </span><span class="lineCov">        909 :      setSourcePosition(variable);</span></a>
<a name="2050"><span class="lineNum">    2050 </span>            : </a>
<a name="2051"><span class="lineNum">    2051 </span><span class="lineCov">        909 :      if (name != &quot;&quot;)</span></a>
<a name="2052"><span class="lineNum">    2052 </span>            :         {</a>
<a name="2053"><span class="lineNum">    2053 </span>            :        // Anonymous bit fields should not have symbols</a>
<a name="2054"><span class="lineNum">    2054 </span><span class="lineCov">        909 :           fixVariableDeclaration(varDecl,scope);</span></a>
<a name="2055"><span class="lineNum">    2055 </span>            :         }</a>
<a name="2056"><span class="lineNum">    2056 </span>            : </a>
<a name="2057"><span class="lineNum">    2057 </span><span class="lineCov">        909 :      SgInitializedName *initName = varDecl-&gt;get_decl_item (name);</span></a>
<a name="2058"><span class="lineNum">    2058 </span><span class="lineCov">        909 :      ROSE_ASSERT(initName);</span></a>
<a name="2059"><span class="lineNum">    2059 </span><span class="lineCov">        909 :      ROSE_ASSERT((initName-&gt;get_declptr())!=NULL);</span></a>
<a name="2060"><span class="lineNum">    2060 </span>            : </a>
<a name="2061"><span class="lineNum">    2061 </span>            :   // bug 119, SgVariableDefintion's File_info is needed for deep copy to work</a>
<a name="2062"><span class="lineNum">    2062 </span>            :   // AstQuery based setSourcePositionForTransformation() cannot access all child nodes</a>
<a name="2063"><span class="lineNum">    2063 </span>            :   // have to set SgVariableDefintion explicitly</a>
<a name="2064"><span class="lineNum">    2064 </span><span class="lineCov">        909 :      SgVariableDefinition* variableDefinition_original = isSgVariableDefinition(initName-&gt;get_declptr());</span></a>
<a name="2065"><span class="lineNum">    2065 </span><span class="lineCov">        909 :      ROSE_ASSERT(variableDefinition_original != NULL);</span></a>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineCov">        909 :      setOneSourcePositionNull(variableDefinition_original);</span></a>
<a name="2067"><span class="lineNum">    2067 </span>            : </a>
<a name="2068"><span class="lineNum">    2068 </span><span class="lineCov">        909 :      setOneSourcePositionNull(varDecl);</span></a>
<a name="2069"><span class="lineNum">    2069 </span>            : </a>
<a name="2070"><span class="lineNum">    2070 </span>            : #if 0</a>
<a name="2071"><span class="lineNum">    2071 </span>            : // DQ (1/2/2010): Set the defining declaration to itself.</a>
<a name="2072"><span class="lineNum">    2072 </span>            :      if (varDecl-&gt;get_definingDeclaration() == NULL)</a>
<a name="2073"><span class="lineNum">    2073 </span>            :           varDecl-&gt;set_definingDeclaration(varDecl);</a>
<a name="2074"><span class="lineNum">    2074 </span>            : #endif</a>
<a name="2075"><span class="lineNum">    2075 </span>            : </a>
<a name="2076"><span class="lineNum">    2076 </span>            :   // ROSE_ASSERT (varDecl-&gt;get_declarationModifier().get_accessModifier().isPublic() == false);</a>
<a name="2077"><span class="lineNum">    2077 </span><span class="lineCov">        909 :      return varDecl;</span></a>
<a name="2078"><span class="lineNum">    2078 </span>            :    }</a>
<a name="2079"><span class="lineNum">    2079 </span>            : </a>
<a name="2080"><span class="lineNum">    2080 </span>            : SgVariableDeclaration*</a>
<a name="2081"><span class="lineNum">    2081 </span><span class="lineCov">        756 : SageBuilder::buildVariableDeclaration(const std::string &amp; name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)</span></a>
<a name="2082"><span class="lineNum">    2082 </span>            : {</a>
<a name="2083"><span class="lineNum">    2083 </span><span class="lineCov">       1512 :   SgName name2(name);</span></a>
<a name="2084"><span class="lineNum">    2084 </span><span class="lineCov">       1512 :   return buildVariableDeclaration(name2,type, varInit,scope);</span></a>
<a name="2085"><span class="lineNum">    2085 </span>            : }</a>
<a name="2086"><span class="lineNum">    2086 </span>            : </a>
<a name="2087"><span class="lineNum">    2087 </span>            : SgVariableDeclaration*</a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineCov">         18 : SageBuilder::buildVariableDeclaration(const char* name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)</span></a>
<a name="2089"><span class="lineNum">    2089 </span>            : {</a>
<a name="2090"><span class="lineNum">    2090 </span><span class="lineCov">         36 :   SgName name2(name);</span></a>
<a name="2091"><span class="lineNum">    2091 </span><span class="lineCov">         36 :   return buildVariableDeclaration(name2,type, varInit,scope);</span></a>
<a name="2092"><span class="lineNum">    2092 </span>            : }</a>
<a name="2093"><span class="lineNum">    2093 </span>            : </a>
<a name="2094"><span class="lineNum">    2094 </span>            : //!Build a typedef declaration, such as: typedef int myint;</a>
<a name="2095"><span class="lineNum">    2095 </span>            : SgTypedefDeclaration*</a>
<a name="2096"><span class="lineNum">    2096 </span><span class="lineCov">          2 : SageBuilder::buildTypedefDeclaration(const std::string&amp; name, SgType* base_type, SgScopeStatement* scope /*= NULL*/, bool has_defining_base/*= false*/)</span></a>
<a name="2097"><span class="lineNum">    2097 </span>            : {</a>
<a name="2098"><span class="lineNum">    2098 </span><span class="lineCov">          2 :   SgTypedefDeclaration* type_decl = buildTypedefDeclaration_nfi(name, base_type, scope, has_defining_base);</span></a>
<a name="2099"><span class="lineNum">    2099 </span><span class="lineCov">          2 :   setOneSourcePositionForTransformation(type_decl);</span></a>
<a name="2100"><span class="lineNum">    2100 </span>            : </a>
<a name="2101"><span class="lineNum">    2101 </span>            : // DQ (1/2/2010): Set the defining declaration to itself.</a>
<a name="2102"><span class="lineNum">    2102 </span>            : // type_decl-&gt;set_definingDeclaration(type_decl);</a>
<a name="2103"><span class="lineNum">    2103 </span>            : </a>
<a name="2104"><span class="lineNum">    2104 </span><span class="lineCov">          2 :   return type_decl;</span></a>
<a name="2105"><span class="lineNum">    2105 </span>            : }</a>
<a name="2106"><span class="lineNum">    2106 </span>            : </a>
<a name="2107"><span class="lineNum">    2107 </span>            : //!Build a typedef declaration, such as: typedef int myint;</a>
<a name="2108"><span class="lineNum">    2108 </span>            : // The side effects include: creating SgTypedefType, SgTypedefSymbol, and add SgTypedefType to the base type</a>
<a name="2109"><span class="lineNum">    2109 </span>            : SgTypedefDeclaration*</a>
<a name="2110"><span class="lineNum">    2110 </span><span class="lineCov">      55080 : SageBuilder::buildTypedefDeclaration_nfi(const std::string&amp; name, SgType* base_type,  SgScopeStatement* scope /*= NULL*/, bool has_defining_base/*=false*/)</span></a>
<a name="2111"><span class="lineNum">    2111 </span>            :    {</a>
<a name="2112"><span class="lineNum">    2112 </span><span class="lineCov">      55080 :      ROSE_ASSERT (base_type != NULL);</span></a>
<a name="2113"><span class="lineNum">    2113 </span>            : </a>
<a name="2114"><span class="lineNum">    2114 </span>            : #if 0</a>
<a name="2115"><span class="lineNum">    2115 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): base_type = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str());</a>
<a name="2116"><span class="lineNum">    2116 </span>            : #endif</a>
<a name="2117"><span class="lineNum">    2117 </span>            : </a>
<a name="2118"><span class="lineNum">    2118 </span><span class="lineCov">      55080 :      if (scope == NULL )</span></a>
<a name="2119"><span class="lineNum">    2119 </span>            :         {</a>
<a name="2120"><span class="lineNum">    2120 </span><span class="lineCov">      54758 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="2121"><span class="lineNum">    2121 </span>            :         }</a>
<a name="2122"><span class="lineNum">    2122 </span>            : </a>
<a name="2123"><span class="lineNum">    2123 </span>            :   // We don't yet support bottom up construction for this node yet</a>
<a name="2124"><span class="lineNum">    2124 </span><span class="lineCov">      55080 :      ROSE_ASSERT(scope!=NULL);</span></a>
<a name="2125"><span class="lineNum">    2125 </span>            : </a>
<a name="2126"><span class="lineNum">    2126 </span><span class="lineCov">      55080 :      SgDeclarationStatement* base_decl = NULL;</span></a>
<a name="2127"><span class="lineNum">    2127 </span>            : </a>
<a name="2128"><span class="lineNum">    2128 </span>            :   // Handle the case where this is a pointer, reference, or typedef to another type.</a>
<a name="2129"><span class="lineNum">    2129 </span>            :   // if (isSgNamedType(base_type))</a>
<a name="2130"><span class="lineNum">    2130 </span>            :   // SgNamedType* namedType = isSgNamedType(base_type-&gt;stripType());</a>
<a name="2131"><span class="lineNum">    2131 </span><span class="lineCov">      55080 :      SgType* stripedBaseType = base_type-&gt;stripType();</span></a>
<a name="2132"><span class="lineNum">    2132 </span><span class="lineCov">      55080 :      ROSE_ASSERT(stripedBaseType != NULL);</span></a>
<a name="2133"><span class="lineNum">    2133 </span>            : </a>
<a name="2134"><span class="lineNum">    2134 </span>            : #if 0</a>
<a name="2135"><span class="lineNum">    2135 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): stripedBaseType = %p = %s \n&quot;,stripedBaseType,stripedBaseType-&gt;class_name().c_str());</a>
<a name="2136"><span class="lineNum">    2136 </span>            : #endif</a>
<a name="2137"><span class="lineNum">    2137 </span>            : </a>
<a name="2138"><span class="lineNum">    2138 </span><span class="lineCov">      55080 :      SgNamedType* namedType = isSgNamedType(stripedBaseType);</span></a>
<a name="2139"><span class="lineNum">    2139 </span><span class="lineCov">      55080 :      if (namedType != NULL)</span></a>
<a name="2140"><span class="lineNum">    2140 </span>            :         {</a>
<a name="2141"><span class="lineNum">    2141 </span>            :        // DQ (12/28/2019): the problem with getting the base declaration from the type is that it forces sharing</a>
<a name="2142"><span class="lineNum">    2142 </span>            :        // of the base declaration when the typedef has a defining declaration for a base type in multiple files.</a>
<a name="2143"><span class="lineNum">    2143 </span>            : #if 0</a>
<a name="2144"><span class="lineNum">    2144 </span>            :           printf (&quot;NOTE: Using the base declaration from the type forces sharing of the base declaration across multiple translation units \n&quot;);</a>
<a name="2145"><span class="lineNum">    2145 </span>            : #endif</a>
<a name="2146"><span class="lineNum">    2146 </span>            :        // DQ (3/20/2012): Use this to set the value of base_decl (which was previously unset).</a>
<a name="2147"><span class="lineNum">    2147 </span>            :        // isSgNamedType(base_type)-&gt;get_declaration();</a>
<a name="2148"><span class="lineNum">    2148 </span>            :        // base_decl = isSgNamedType(base_type)-&gt;get_declaration();</a>
<a name="2149"><span class="lineNum">    2149 </span><span class="lineCov">      12331 :           base_decl = namedType-&gt;get_declaration();</span></a>
<a name="2150"><span class="lineNum">    2150 </span>            : </a>
<a name="2151"><span class="lineNum">    2151 </span>            :        // DQ (3/20/2012): All named types should have a valid declaration!</a>
<a name="2152"><span class="lineNum">    2152 </span><span class="lineCov">      12331 :           ROSE_ASSERT(base_decl != NULL);</span></a>
<a name="2153"><span class="lineNum">    2153 </span>            : #if 0</a>
<a name="2154"><span class="lineNum">    2154 </span>            :           printf (&quot;In buildTypedefDeclaration_nfi(): base_decl = %p = %s \n&quot;,base_decl,base_decl-&gt;class_name().c_str());</a>
<a name="2155"><span class="lineNum">    2155 </span>            :           if (base_decl-&gt;get_definingDeclaration() != NULL)</a>
<a name="2156"><span class="lineNum">    2156 </span>            :              {</a>
<a name="2157"><span class="lineNum">    2157 </span>            :                printf (&quot;base_decl-&gt;get_definingDeclaration() = %p parent = %p \n&quot;,base_decl-&gt;get_definingDeclaration(),base_decl-&gt;get_definingDeclaration()-&gt;get_parent());</a>
<a name="2158"><span class="lineNum">    2158 </span>            :              }</a>
<a name="2159"><span class="lineNum">    2159 </span>            :           if (base_decl == base_decl-&gt;get_definingDeclaration())</a>
<a name="2160"><span class="lineNum">    2160 </span>            :              {</a>
<a name="2161"><span class="lineNum">    2161 </span>            :                printf (&quot;base_decl matches the defining declaration = %p parent = %p \n&quot;,base_decl,base_decl-&gt;get_parent());</a>
<a name="2162"><span class="lineNum">    2162 </span>            :              }</a>
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<a name="2164"><span class="lineNum">    2164 </span>            :           if (base_decl-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="2165"><span class="lineNum">    2165 </span>            :              {</a>
<a name="2166"><span class="lineNum">    2166 </span>            :                printf (&quot;base_decl-&gt;get_firstNondefiningDeclaration() = %p parent = %p \n&quot;,base_decl-&gt;get_firstNondefiningDeclaration(),base_decl-&gt;get_firstNondefiningDeclaration()-&gt;get_parent());</a>
<a name="2167"><span class="lineNum">    2167 </span>            :              }</a>
<a name="2168"><span class="lineNum">    2168 </span>            :           if (base_decl == base_decl-&gt;get_firstNondefiningDeclaration())</a>
<a name="2169"><span class="lineNum">    2169 </span>            :              {</a>
<a name="2170"><span class="lineNum">    2170 </span>            :                printf (&quot;base_decl matches the firstNondefining declaration = %p parent = %p \n&quot;,base_decl,base_decl-&gt;get_parent());</a>
<a name="2171"><span class="lineNum">    2171 </span>            :              }</a>
<a name="2172"><span class="lineNum">    2172 </span>            : #endif</a>
<a name="2173"><span class="lineNum">    2173 </span>            :         }</a>
<a name="2174"><span class="lineNum">    2174 </span>            : </a>
<a name="2175"><span class="lineNum">    2175 </span>            : #if 0</a>
<a name="2176"><span class="lineNum">    2176 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): base_decl = %p \n&quot;,base_decl);</a>
<a name="2177"><span class="lineNum">    2177 </span>            : #endif</a>
<a name="2178"><span class="lineNum">    2178 </span>            : </a>
<a name="2179"><span class="lineNum">    2179 </span>            :   // DQ (3/20/2012): I don't remember why we need to provide the symbol for the scope of the</a>
<a name="2180"><span class="lineNum">    2180 </span>            :   // parent rather then the scope. But as I recall there was a special corner of C++ that</a>
<a name="2181"><span class="lineNum">    2181 </span>            :   // required this sort of support.</a>
<a name="2182"><span class="lineNum">    2182 </span><span class="lineCov">      55080 :      SgSymbol* parent_scope = NULL;</span></a>
<a name="2183"><span class="lineNum">    2183 </span>            : #ifndef ROSE_USE_CLANG_FRONTEND</a>
<a name="2184"><span class="lineNum">    2184 </span><span class="lineCov">      55080 :      if (scope != NULL)</span></a>
<a name="2185"><span class="lineNum">    2185 </span>            :         {</a>
<a name="2186"><span class="lineNum">    2186 </span>            : #if 0</a>
<a name="2187"><span class="lineNum">    2187 </span>            :           printf (&quot;In buildTypedefDeclaration_nfi(): scope = %p = %s calling get_symbol_from_symbol_table() \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="2188"><span class="lineNum">    2188 </span>            : #endif</a>
<a name="2189"><span class="lineNum">    2189 </span><span class="lineCov">      55080 :           ROSE_ASSERT(scope-&gt;get_parent() != NULL);</span></a>
<a name="2190"><span class="lineNum">    2190 </span><span class="lineCov">      55080 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(scope-&gt;get_parent());</span></a>
<a name="2191"><span class="lineNum">    2191 </span>            : #if 0</a>
<a name="2192"><span class="lineNum">    2192 </span>            :           printf (&quot;declaration = %p \n&quot;,declaration);</a>
<a name="2193"><span class="lineNum">    2193 </span>            : #endif</a>
<a name="2194"><span class="lineNum">    2194 </span>            : </a>
<a name="2195"><span class="lineNum">    2195 </span>            :           // PP (3/9/22)</a>
<a name="2196"><span class="lineNum">    2196 </span>            :           // In Ada, discriminated type may not have been fully built yet.</a>
<a name="2197"><span class="lineNum">    2197 </span>            :           //   this is because a the discriminated type obtains the name of the underlying</a>
<a name="2198"><span class="lineNum">    2198 </span>            :           //   declaration.</a>
<a name="2199"><span class="lineNum">    2199 </span><span class="lineCov">      55080 :           if (declaration)</span></a>
<a name="2200"><span class="lineNum">    2200 </span>            :              {</a>
<a name="2201"><span class="lineNum">    2201 </span>            : #if 1</a>
<a name="2202"><span class="lineNum">    2202 </span><span class="lineCov">      11062 :                mprintf (&quot;Found a valid declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="2203"><span class="lineNum">    2203 </span>            : #endif</a>
<a name="2204"><span class="lineNum">    2204 </span>            : </a>
<a name="2205"><span class="lineNum">    2205 </span><span class="lineCov">      11062 :                ROSE_ASSERT(declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2206"><span class="lineNum">    2206 </span>            : </a>
<a name="2207"><span class="lineNum">    2207 </span>            :             // parent_scope = declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</a>
<a name="2208"><span class="lineNum">    2208 </span><span class="lineCov">      11062 :                parent_scope = declaration-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span><span class="lineCov">      11062 :                ROSE_ASSERT(parent_scope != NULL);</span></a>
<a name="2211"><span class="lineNum">    2211 </span>            :              }</a>
<a name="2212"><span class="lineNum">    2212 </span>            :         }</a>
<a name="2213"><span class="lineNum">    2213 </span>            : #endif</a>
<a name="2214"><span class="lineNum">    2214 </span>            : </a>
<a name="2215"><span class="lineNum">    2215 </span>            : #if 0</a>
<a name="2216"><span class="lineNum">    2216 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): parent_scope = %p \n&quot;,parent_scope);</a>
<a name="2217"><span class="lineNum">    2217 </span>            : #endif</a>
<a name="2218"><span class="lineNum">    2218 </span>            : </a>
<a name="2219"><span class="lineNum">    2219 </span>            : #if 0</a>
<a name="2220"><span class="lineNum">    2220 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): base_decl = %p \n&quot;,base_decl);</a>
<a name="2221"><span class="lineNum">    2221 </span>            : #endif</a>
<a name="2222"><span class="lineNum">    2222 </span>            : </a>
<a name="2223"><span class="lineNum">    2223 </span>            :   // SgTypedefDeclaration (Sg_File_Info *startOfConstruct, SgName name=&quot;&quot;, SgType *base_type=NULL, SgTypedefType *type=NULL, SgDeclarationStatement *declaration=NULL, SgSymbol *parent_scope=NULL)</a>
<a name="2224"><span class="lineNum">    2224 </span>            :   // SgTypedefDeclaration (SgName name=&quot;&quot;, SgType *base_type=NULL, SgTypedefType *type=NULL, SgDeclarationStatement *declaration=NULL, SgSymbol *parent_scope=NULL)</a>
<a name="2225"><span class="lineNum">    2225 </span>            :   //</a>
<a name="2226"><span class="lineNum">    2226 </span>            :   // Create the first nondefining declaration (note that the typedef type is always a NULL input value).</a>
<a name="2227"><span class="lineNum">    2227 </span>            :   // SgTypedefDeclaration* type_decl = new SgTypedefDeclaration(SgName(name),base_type,NULL, NULL, NULL);</a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineCov">      55080 :      SgTypedefDeclaration* type_decl = new SgTypedefDeclaration(SgName(name), base_type, NULL, base_decl, parent_scope);</span></a>
<a name="2229"><span class="lineNum">    2229 </span><span class="lineCov">      55080 :      ROSE_ASSERT(type_decl != NULL);</span></a>
<a name="2230"><span class="lineNum">    2230 </span>            : </a>
<a name="2231"><span class="lineNum">    2231 </span>            :   // TV (08/17/2018): moved it before building type as SgTypedefType::createType uses SgTemplateTypedefDeclaration::get_mangled_name which requires the scope to be set (else name of the associated type might not be unique)</a>
<a name="2232"><span class="lineNum">    2232 </span><span class="lineCov">      55080 :      type_decl-&gt;set_scope(scope);</span></a>
<a name="2233"><span class="lineNum">    2233 </span><span class="lineCov">      55080 :      type_decl-&gt;set_parent(scope);</span></a>
<a name="2234"><span class="lineNum">    2234 </span>            : </a>
<a name="2235"><span class="lineNum">    2235 </span>            : #if 0</a>
<a name="2236"><span class="lineNum">    2236 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): type_decl = %p type_decl-&gt;get_declaration() = %p \n&quot;,type_decl,type_decl-&gt;get_declaration());</a>
<a name="2237"><span class="lineNum">    2237 </span>            : #endif</a>
<a name="2238"><span class="lineNum">    2238 </span>            : </a>
<a name="2239"><span class="lineNum">    2239 </span>            : #if 0</a>
<a name="2240"><span class="lineNum">    2240 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): calling SgTypedefType::createType() using this = %p = %s \n&quot;,type_decl,type_decl-&gt;class_name().c_str());</a>
<a name="2241"><span class="lineNum">    2241 </span>            : #endif</a>
<a name="2242"><span class="lineNum">    2242 </span>            : </a>
<a name="2243"><span class="lineNum">    2243 </span>            :   // DQ (2/27/2018): Add this call here to reflect change to the constructor semantics.</a>
<a name="2244"><span class="lineNum">    2244 </span><span class="lineCov">      55080 :      type_decl-&gt;set_type(SgTypedefType::createType(type_decl));</span></a>
<a name="2245"><span class="lineNum">    2245 </span>            : </a>
<a name="2246"><span class="lineNum">    2246 </span>            : #if 0</a>
<a name="2247"><span class="lineNum">    2247 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): DONE calling SgTypedefType::createType() using this = %p = %s \n&quot;,type_decl,type_decl-&gt;class_name().c_str());</a>
<a name="2248"><span class="lineNum">    2248 </span>            : #endif</a>
<a name="2249"><span class="lineNum">    2249 </span>            : </a>
<a name="2250"><span class="lineNum">    2250 </span>            : #if 0</a>
<a name="2251"><span class="lineNum">    2251 </span>            :  // DQ (2/27/2018): The constructor semantics now require the type to be built after the IR node has been built.</a>
<a name="2252"><span class="lineNum">    2252 </span>            :  // Make this fail so that we can detect it an fix it properly later.</a>
<a name="2253"><span class="lineNum">    2253 </span>            :     printf (&quot;In SageBuilder::buildTypedefDeclaration_nfi(): ERROR: The constructor semantics now require the type to be built after the IR node has been built \n&quot;);</a>
<a name="2254"><span class="lineNum">    2254 </span>            :     ROSE_ABORT();</a>
<a name="2255"><span class="lineNum">    2255 </span>            : #endif</a>
<a name="2256"><span class="lineNum">    2256 </span>            : #if 0</a>
<a name="2257"><span class="lineNum">    2257 </span>            :      printf (&quot;In buildTypedefDeclaration_nfi(): After SgTypedefDeclaration constructor: type_decl-&gt;get_scope() = %p \n&quot;,type_decl-&gt;get_scope());</a>
<a name="2258"><span class="lineNum">    2258 </span>            : #endif</a>
<a name="2259"><span class="lineNum">    2259 </span>            : </a>
<a name="2260"><span class="lineNum">    2260 </span>            :   // DQ (3/20/2012): Comment ouly, these are always set this way. first defining is a self reference, and defining is always NULL (required for AST consistancy)).</a>
<a name="2261"><span class="lineNum">    2261 </span><span class="lineCov">      55080 :      type_decl-&gt;set_firstNondefiningDeclaration (type_decl);</span></a>
<a name="2262"><span class="lineNum">    2262 </span><span class="lineCov">      55080 :      type_decl-&gt;set_definingDeclaration(NULL);</span></a>
<a name="2263"><span class="lineNum">    2263 </span>            : </a>
<a name="2264"><span class="lineNum">    2264 </span>            :   // Set the source code position information.</a>
<a name="2265"><span class="lineNum">    2265 </span><span class="lineCov">      55080 :      setOneSourcePositionNull(type_decl);</span></a>
<a name="2266"><span class="lineNum">    2266 </span>            : </a>
<a name="2267"><span class="lineNum">    2267 </span>            :   // Liao 11/29/2012, for typedef struct Frame {int x;} st_frame; We have to set parent for the struct.</a>
<a name="2268"><span class="lineNum">    2268 </span>            :   // AstPostProcessing() has resetParentPointers(). But it is kind of too late.</a>
<a name="2269"><span class="lineNum">    2269 </span><span class="lineCov">      55080 :      if (SgClassDeclaration* base_class = isSgClassDeclaration(base_decl))</span></a>
<a name="2270"><span class="lineNum">    2270 </span>            :         {</a>
<a name="2271"><span class="lineNum">    2271 </span><span class="lineCov">       7889 :           SgClassDeclaration* def_class = isSgClassDeclaration(base_class-&gt;get_definingDeclaration());</span></a>
<a name="2272"><span class="lineNum">    2272 </span><span class="lineCov">       7889 :           SgClassDeclaration* nondef_class = isSgClassDeclaration(base_class-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="2273"><span class="lineNum">    2273 </span>            :        // Dan and Liao, 12/3/2012, handle test2003_08.C nested typedef</a>
<a name="2274"><span class="lineNum">    2274 </span><span class="lineCov">       7889 :           if (has_defining_base)</span></a>
<a name="2275"><span class="lineNum">    2275 </span>            :              {</a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineCov">          1 :                if (def_class != NULL)</span></a>
<a name="2277"><span class="lineNum">    2277 </span><span class="lineCov">          1 :                     if (def_class-&gt;get_parent() == NULL)</span></a>
<a name="2278"><span class="lineNum">    2278 </span><span class="lineCov">          1 :                          def_class-&gt;set_parent(type_decl);</span></a>
<a name="2279"><span class="lineNum">    2279 </span>            :              }</a>
<a name="2280"><span class="lineNum">    2280 </span>            :             else</a>
<a name="2281"><span class="lineNum">    2281 </span>            :              {</a>
<a name="2282"><span class="lineNum">    2282 </span><span class="lineCov">       7888 :                if (nondef_class != NULL)</span></a>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineCov">       7888 :                     if (nondef_class-&gt;get_parent() == NULL)</span></a>
<a name="2284"><span class="lineNum">    2284 </span>            :                        {</a>
<a name="2285"><span class="lineNum">    2285 </span><span class="lineCov">       3742 :                          nondef_class-&gt;set_parent(type_decl);</span></a>
<a name="2286"><span class="lineNum">    2286 </span>            :                        }</a>
<a name="2287"><span class="lineNum">    2287 </span>            :              }</a>
<a name="2288"><span class="lineNum">    2288 </span>            :         }</a>
<a name="2289"><span class="lineNum">    2289 </span>            : </a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineCov">      55080 :      SgTypedefSymbol* typedef_symbol = new SgTypedefSymbol(type_decl);</span></a>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineCov">      55080 :      ROSE_ASSERT(typedef_symbol);</span></a>
<a name="2292"><span class="lineNum">    2292 </span>            : </a>
<a name="2293"><span class="lineNum">    2293 </span><span class="lineCov">      55080 :      scope-&gt;insert_symbol(SgName(name),typedef_symbol);</span></a>
<a name="2294"><span class="lineNum">    2294 </span>            : </a>
<a name="2295"><span class="lineNum">    2295 </span>            : #if 0</a>
<a name="2296"><span class="lineNum">    2296 </span>            :   // DQ (3/20/2012): This is always false...since base_decl is never reset from NULL (above).</a>
<a name="2297"><span class="lineNum">    2297 </span>            : </a>
<a name="2298"><span class="lineNum">    2298 </span>            :   // TODO double check when to create defining declaration</a>
<a name="2299"><span class="lineNum">    2299 </span>            :   // I tried two cases so far and the simplest typedef int MYINT will not have defining typedef declaration</a>
<a name="2300"><span class="lineNum">    2300 </span>            :   // the complex typedef struct frame {} frame; has a defining typedef declaration</a>
<a name="2301"><span class="lineNum">    2301 </span>            :   // base declaration should be associated with defining typedef declaration</a>
<a name="2302"><span class="lineNum">    2302 </span>            :      if (base_decl != NULL)</a>
<a name="2303"><span class="lineNum">    2303 </span>            :         {</a>
<a name="2304"><span class="lineNum">    2304 </span>            :           SgTypedefDeclaration* def_type_decl = new SgTypedefDeclaration(SgName(name),base_type,type_decl-&gt;get_type(), base_decl, NULL);</a>
<a name="2305"><span class="lineNum">    2305 </span>            :           def_type_decl-&gt;set_firstNondefiningDeclaration(type_decl);</a>
<a name="2306"><span class="lineNum">    2306 </span>            :           type_decl-&gt;set_definingDeclaration(def_type_decl);</a>
<a name="2307"><span class="lineNum">    2307 </span>            :           setOneSourcePositionNull(def_type_decl);</a>
<a name="2308"><span class="lineNum">    2308 </span>            :         }</a>
<a name="2309"><span class="lineNum">    2309 </span>            : #endif</a>
<a name="2310"><span class="lineNum">    2310 </span>            : </a>
<a name="2311"><span class="lineNum">    2311 </span>            : #if 0</a>
<a name="2312"><span class="lineNum">    2312 </span>            :   // DQ (3/20/2012): Test the base_decl.</a>
<a name="2313"><span class="lineNum">    2313 </span>            :      if (base_decl != NULL)</a>
<a name="2314"><span class="lineNum">    2314 </span>            :         {</a>
<a name="2315"><span class="lineNum">    2315 </span>            :           printf (&quot;In buildTypedefDeclaration_nfi(): base_decl-&gt;get_definingDeclaration()         = %p \n&quot;,base_decl-&gt;get_definingDeclaration());</a>
<a name="2316"><span class="lineNum">    2316 </span>            :           if (base_decl-&gt;get_definingDeclaration() != NULL)</a>
<a name="2317"><span class="lineNum">    2317 </span>            :              {</a>
<a name="2318"><span class="lineNum">    2318 </span>            :                printf (&quot;In buildTypedefDeclaration_nfi(): base_decl-&gt;get_definingDeclaration()-&gt;get_parent()         = %p \n&quot;,base_decl-&gt;get_definingDeclaration()-&gt;get_parent());</a>
<a name="2319"><span class="lineNum">    2319 </span>            :              }</a>
<a name="2320"><span class="lineNum">    2320 </span>            :           printf (&quot;In buildTypedefDeclaration_nfi(): base_decl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,base_decl-&gt;get_firstNondefiningDeclaration());</a>
<a name="2321"><span class="lineNum">    2321 </span>            :           if (base_decl-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="2322"><span class="lineNum">    2322 </span>            :              {</a>
<a name="2323"><span class="lineNum">    2323 </span>            :                printf (&quot;In buildTypedefDeclaration_nfi(): base_decl-&gt;get_firstNondefiningDeclaration()-&gt;get_parent() = %p \n&quot;,base_decl-&gt;get_firstNondefiningDeclaration()-&gt;get_parent());</a>
<a name="2324"><span class="lineNum">    2324 </span>            :              }</a>
<a name="2325"><span class="lineNum">    2325 </span>            :         }</a>
<a name="2326"><span class="lineNum">    2326 </span>            : #endif</a>
<a name="2327"><span class="lineNum">    2327 </span>            : </a>
<a name="2328"><span class="lineNum">    2328 </span>            : #if 0</a>
<a name="2329"><span class="lineNum">    2329 </span>            :   // DQ (1/2/2010): Set the defining declaration to itself. (BAD IDEA).</a>
<a name="2330"><span class="lineNum">    2330 </span>            :      if (type_decl-&gt;get_definingDeclaration() == NULL)</a>
<a name="2331"><span class="lineNum">    2331 </span>            :           type_decl-&gt;set_definingDeclaration(type_decl);</a>
<a name="2332"><span class="lineNum">    2332 </span>            : #endif</a>
<a name="2333"><span class="lineNum">    2333 </span>            : </a>
<a name="2334"><span class="lineNum">    2334 </span>            : #if 0</a>
<a name="2335"><span class="lineNum">    2335 </span>            :      printf (&quot;Leaving buildTypedefDeclaration_nfi(): type_decl = %p type_decl-&gt;get_declaration() = %p \n&quot;,type_decl,type_decl-&gt;get_declaration());</a>
<a name="2336"><span class="lineNum">    2336 </span>            : #endif</a>
<a name="2337"><span class="lineNum">    2337 </span>            : </a>
<a name="2338"><span class="lineNum">    2338 </span><span class="lineCov">      55080 :      return type_decl;</span></a>
<a name="2339"><span class="lineNum">    2339 </span>            :    }</a>
<a name="2340"><span class="lineNum">    2340 </span>            : </a>
<a name="2341"><span class="lineNum">    2341 </span>            : </a>
<a name="2342"><span class="lineNum">    2342 </span>            : SgTemplateTypedefDeclaration*</a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineCov">        892 : SageBuilder::buildTemplateTypedefDeclaration_nfi(const SgName &amp; name, SgType* base_type, SgScopeStatement* scope, bool has_defining_base )</span></a>
<a name="2344"><span class="lineNum">    2344 </span>            :    {</a>
<a name="2345"><span class="lineNum">    2345 </span>            :   // DQ (11/2/2014): Adding support for templated typedef.</a>
<a name="2346"><span class="lineNum">    2346 </span>            : </a>
<a name="2347"><span class="lineNum">    2347 </span><span class="lineCov">        892 :      ROSE_ASSERT (base_type != NULL);</span></a>
<a name="2348"><span class="lineNum">    2348 </span>            : </a>
<a name="2349"><span class="lineNum">    2349 </span>            : #if 0</a>
<a name="2350"><span class="lineNum">    2350 </span>            :      printf (&quot;In buildTemplateTypedefDeclaration_nfi(): base_type = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str());</a>
<a name="2351"><span class="lineNum">    2351 </span>            : #endif</a>
<a name="2352"><span class="lineNum">    2352 </span>            : </a>
<a name="2353"><span class="lineNum">    2353 </span><span class="lineCov">        892 :      if (scope == NULL )</span></a>
<a name="2354"><span class="lineNum">    2354 </span>            :         {</a>
<a name="2355"><span class="lineNum">    2355 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="2356"><span class="lineNum">    2356 </span>            :         }</a>
<a name="2357"><span class="lineNum">    2357 </span>            : </a>
<a name="2358"><span class="lineNum">    2358 </span>            :   // We don't yet support bottom up construction for this node yet</a>
<a name="2359"><span class="lineNum">    2359 </span><span class="lineCov">        892 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="2360"><span class="lineNum">    2360 </span>            : </a>
<a name="2361"><span class="lineNum">    2361 </span><span class="lineCov">        892 :      SgDeclarationStatement* base_decl = NULL;</span></a>
<a name="2362"><span class="lineNum">    2362 </span>            : </a>
<a name="2363"><span class="lineNum">    2363 </span>            :   // DQ (3/20/2012): I don't remember why we need to provide the symbol for the scope of the</a>
<a name="2364"><span class="lineNum">    2364 </span>            :   // parent rather then the scope. But as I recall there was a special corner of C++ that</a>
<a name="2365"><span class="lineNum">    2365 </span>            :   // required this sort of support.</a>
<a name="2366"><span class="lineNum">    2366 </span><span class="lineCov">        892 :      SgSymbol* parent_scope = NULL;</span></a>
<a name="2367"><span class="lineNum">    2367 </span><span class="lineCov">        892 :      if (scope != NULL)</span></a>
<a name="2368"><span class="lineNum">    2368 </span>            :         {</a>
<a name="2369"><span class="lineNum">    2369 </span>            : #if 0</a>
<a name="2370"><span class="lineNum">    2370 </span>            :           printf (&quot;In buildTemplateTypedefDeclaration_nfi(): scope = %p = %s calling get_symbol_from_symbol_table() \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="2371"><span class="lineNum">    2371 </span>            : #endif</a>
<a name="2372"><span class="lineNum">    2372 </span><span class="lineCov">        892 :           ROSE_ASSERT(scope-&gt;get_parent() != NULL);</span></a>
<a name="2373"><span class="lineNum">    2373 </span><span class="lineCov">        892 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(scope-&gt;get_parent());</span></a>
<a name="2374"><span class="lineNum">    2374 </span>            : #if 0</a>
<a name="2375"><span class="lineNum">    2375 </span>            :           printf (&quot;declaration = %p \n&quot;,declaration);</a>
<a name="2376"><span class="lineNum">    2376 </span>            : #endif</a>
<a name="2377"><span class="lineNum">    2377 </span><span class="lineCov">        892 :           if (declaration != NULL)</span></a>
<a name="2378"><span class="lineNum">    2378 </span>            :              {</a>
<a name="2379"><span class="lineNum">    2379 </span>            : #if 0</a>
<a name="2380"><span class="lineNum">    2380 </span>            :                printf (&quot;Found a valid declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="2381"><span class="lineNum">    2381 </span>            : #endif</a>
<a name="2382"><span class="lineNum">    2382 </span><span class="lineCov">        860 :                ROSE_ASSERT(declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2383"><span class="lineNum">    2383 </span>            :             // parent_scope = declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</a>
<a name="2384"><span class="lineNum">    2384 </span><span class="lineCov">        860 :                parent_scope = declaration-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="2385"><span class="lineNum">    2385 </span>            : </a>
<a name="2386"><span class="lineNum">    2386 </span><span class="lineCov">        860 :                ROSE_ASSERT(parent_scope != NULL);</span></a>
<a name="2387"><span class="lineNum">    2387 </span>            :              }</a>
<a name="2388"><span class="lineNum">    2388 </span>            : #if 0</a>
<a name="2389"><span class="lineNum">    2389 </span>            :           printf (&quot;Check on the symbol associatd with the declaration associated with the base type \n&quot;);</a>
<a name="2390"><span class="lineNum">    2390 </span>            : #endif</a>
<a name="2391"><span class="lineNum">    2391 </span>            :        // DQ (2/28/2018): check out if the symbol associated with the declaration used for the base type used in this typedef has a symbol.</a>
<a name="2392"><span class="lineNum">    2392 </span><span class="lineCov">        892 :           SgNamedType* namedType = isSgNamedType(base_type);</span></a>
<a name="2393"><span class="lineNum">    2393 </span>            : </a>
<a name="2394"><span class="lineNum">    2394 </span>            :        // DQ (3/4/2018): This might not always be true (sure enough it fails for Cxx11_tests/test2014_58.C).</a>
<a name="2395"><span class="lineNum">    2395 </span>            :        // ROSE_ASSERT(namedType != NULL);</a>
<a name="2396"><span class="lineNum">    2396 </span>            : </a>
<a name="2397"><span class="lineNum">    2397 </span><span class="lineCov">        892 :           if (namedType != NULL)</span></a>
<a name="2398"><span class="lineNum">    2398 </span>            :              {</a>
<a name="2399"><span class="lineNum">    2399 </span><span class="lineCov">        782 :                SgDeclarationStatement* declarationStatement = namedType-&gt;get_declaration();</span></a>
<a name="2400"><span class="lineNum">    2400 </span>            : </a>
<a name="2401"><span class="lineNum">    2401 </span>            :             // This might not always be true.</a>
<a name="2402"><span class="lineNum">    2402 </span><span class="lineCov">        782 :                ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="2403"><span class="lineNum">    2403 </span><span class="lineCov">        782 :                if (declarationStatement != NULL)</span></a>
<a name="2404"><span class="lineNum">    2404 </span>            :                   {</a>
<a name="2405"><span class="lineNum">    2405 </span>            : #if 0</a>
<a name="2406"><span class="lineNum">    2406 </span>            :                     printf (&quot;Found declaration for base_type = %p = %s declarationStatement = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str(),declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="2407"><span class="lineNum">    2407 </span>            : #endif</a>
<a name="2408"><span class="lineNum">    2408 </span><span class="lineCov">        782 :                     SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(declarationStatement);</span></a>
<a name="2409"><span class="lineNum">    2409 </span><span class="lineCov">        782 :                     if (templateInstantiationDecl != NULL)</span></a>
<a name="2410"><span class="lineNum">    2410 </span>            :                        {</a>
<a name="2411"><span class="lineNum">    2411 </span><span class="lineNoCov">          0 :                          SgName name = templateInstantiationDecl-&gt;get_name();</span></a>
<a name="2412"><span class="lineNum">    2412 </span>            : #if 0</a>
<a name="2413"><span class="lineNum">    2413 </span>            :                          printf (&quot;templateInstantiationDecl = %p scope = %p = %s for name = %s \n&quot;,templateInstantiationDecl,scope,scope-&gt;class_name().c_str(),name.str());</a>
<a name="2414"><span class="lineNum">    2414 </span>            : #endif</a>
<a name="2415"><span class="lineNum">    2415 </span>            :                       // DQ (2/28/2018): Added debugging to track down redundnat symbol.</a>
<a name="2416"><span class="lineNum">    2416 </span><span class="lineNoCov">          0 :                          if (scope-&gt;lookup_template_typedef_symbol(name) != NULL)</span></a>
<a name="2417"><span class="lineNum">    2417 </span>            :                             {</a>
<a name="2418"><span class="lineNum">    2418 </span><span class="lineNoCov">          0 :                               printf (&quot;Error: it appears that there is already a symbol in scope = %p = %s for name = %s \n&quot;,scope,scope-&gt;class_name().c_str(),name.str());</span></a>
<a name="2419"><span class="lineNum">    2419 </span>            :                             }</a>
<a name="2420"><span class="lineNum">    2420 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(name) == NULL);</span></a>
<a name="2421"><span class="lineNum">    2421 </span>            :                        }</a>
<a name="2422"><span class="lineNum">    2422 </span>            : #if 0</a>
<a name="2423"><span class="lineNum">    2423 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2424"><span class="lineNum">    2424 </span>            :                     ROSE_ABORT();</a>
<a name="2425"><span class="lineNum">    2425 </span>            : #endif</a>
<a name="2426"><span class="lineNum">    2426 </span>            :                   }</a>
<a name="2427"><span class="lineNum">    2427 </span>            :              }</a>
<a name="2428"><span class="lineNum">    2428 </span>            :         }</a>
<a name="2429"><span class="lineNum">    2429 </span>            : </a>
<a name="2430"><span class="lineNum">    2430 </span>            : #if 0</a>
<a name="2431"><span class="lineNum">    2431 </span>            :      printf (&quot;In buildTemplateTypedefDeclaration_nfi(): parent_scope = %p \n&quot;,parent_scope);</a>
<a name="2432"><span class="lineNum">    2432 </span>            :      if (parent_scope != NULL)</a>
<a name="2433"><span class="lineNum">    2433 </span>            :         {</a>
<a name="2434"><span class="lineNum">    2434 </span>            :           printf (&quot;parent_scope) = %p = %s \n&quot;,parent_scope,parent_scope-&gt;class_name().c_str());</a>
<a name="2435"><span class="lineNum">    2435 </span>            :         }</a>
<a name="2436"><span class="lineNum">    2436 </span>            : #endif</a>
<a name="2437"><span class="lineNum">    2437 </span>            : </a>
<a name="2438"><span class="lineNum">    2438 </span>            :   // We need to add the template parameter and partial specialization support to the SgTemplateTypedefDeclaration IR node.</a>
<a name="2439"><span class="lineNum">    2439 </span>            :   // SgTemplateTypedefDeclaration* type_decl = new SgTemplateTypedefDeclaration(SgName(name), base_type, NULL, base_decl, parent_scope);</a>
<a name="2440"><span class="lineNum">    2440 </span><span class="lineCov">        892 :      SgTemplateTypedefDeclaration* type_decl = new SgTemplateTypedefDeclaration(name, base_type, NULL, base_decl, parent_scope);</span></a>
<a name="2441"><span class="lineNum">    2441 </span><span class="lineCov">        892 :      ROSE_ASSERT(type_decl != NULL);</span></a>
<a name="2442"><span class="lineNum">    2442 </span>            : </a>
<a name="2443"><span class="lineNum">    2443 </span>            :   // TV (08/17/2018): moved it before building type as SgTypedefType::createType uses SgTemplateTypedefDeclaration::get_mangled_name which requires the scope to be set (else name of the associated type might not be unique)</a>
<a name="2444"><span class="lineNum">    2444 </span><span class="lineCov">        892 :      type_decl-&gt;set_scope(scope);</span></a>
<a name="2445"><span class="lineNum">    2445 </span><span class="lineCov">        892 :      type_decl-&gt;set_parent(scope);</span></a>
<a name="2446"><span class="lineNum">    2446 </span>            : </a>
<a name="2447"><span class="lineNum">    2447 </span>            :   // DQ (2/27/2018): We now have to set the type explicitly.</a>
<a name="2448"><span class="lineNum">    2448 </span><span class="lineCov">        892 :      ROSE_ASSERT(type_decl-&gt;get_type() == NULL);</span></a>
<a name="2449"><span class="lineNum">    2449 </span>            : </a>
<a name="2450"><span class="lineNum">    2450 </span>            : #if 0</a>
<a name="2451"><span class="lineNum">    2451 </span>            :      printf (&quot;!!!!! In buildTemplateTypedefDeclaration_nfi(): Building the SgTypedefType for SgTemplateTypedefDeclaration type_decl = %p = %s \n&quot;,</a>
<a name="2452"><span class="lineNum">    2452 </span>            :           type_decl,type_decl-&gt;get_name().str());</a>
<a name="2453"><span class="lineNum">    2453 </span>            : #endif</a>
<a name="2454"><span class="lineNum">    2454 </span>            : </a>
<a name="2455"><span class="lineNum">    2455 </span><span class="lineCov">        892 :      SgTypedefType* typedefType = SgTypedefType::createType(type_decl);</span></a>
<a name="2456"><span class="lineNum">    2456 </span><span class="lineCov">        892 :      ROSE_ASSERT(typedefType != NULL);</span></a>
<a name="2457"><span class="lineNum">    2457 </span>            : </a>
<a name="2458"><span class="lineNum">    2458 </span>            : #if 0</a>
<a name="2459"><span class="lineNum">    2459 </span>            :      printf (&quot;!!!!! In buildTemplateTypedefDeclaration_nfi(): DONE: building the SgTypedefType for SgTemplateTypedefDeclaration type_decl = %p = %s typedefType = %p \n&quot;,</a>
<a name="2460"><span class="lineNum">    2460 </span>            :           type_decl,type_decl-&gt;get_name().str(),typedefType);</a>
<a name="2461"><span class="lineNum">    2461 </span>            : #endif</a>
<a name="2462"><span class="lineNum">    2462 </span>            : </a>
<a name="2463"><span class="lineNum">    2463 </span>            :   // DQ (2/27/2018): It is an inconsistancy for the type to be set here.</a>
<a name="2464"><span class="lineNum">    2464 </span><span class="lineCov">        892 :      type_decl-&gt;set_type(typedefType);</span></a>
<a name="2465"><span class="lineNum">    2465 </span>            : </a>
<a name="2466"><span class="lineNum">    2466 </span>            :   // DQ (2/27/2018): This should be non-null, since we just built the new type.</a>
<a name="2467"><span class="lineNum">    2467 </span><span class="lineCov">        892 :      ROSE_ASSERT(type_decl-&gt;get_type() != NULL);</span></a>
<a name="2468"><span class="lineNum">    2468 </span>            : </a>
<a name="2469"><span class="lineNum">    2469 </span>            : #if 0</a>
<a name="2470"><span class="lineNum">    2470 </span>            :      printf (&quot;In buildTemplateTypedefDeclaration_nfi(): After SgTemplateTypedefDeclaration constructor: type_decl-&gt;get_scope() = %p \n&quot;,type_decl-&gt;get_scope());</a>
<a name="2471"><span class="lineNum">    2471 </span>            : #endif</a>
<a name="2472"><span class="lineNum">    2472 </span>            : </a>
<a name="2473"><span class="lineNum">    2473 </span>            :   // DQ (3/20/2012): Comment ouly, these are always set this way. first defining is a self reference, and defining is always NULL (required for AST consistancy)).</a>
<a name="2474"><span class="lineNum">    2474 </span><span class="lineCov">        892 :      type_decl-&gt;set_firstNondefiningDeclaration (type_decl);</span></a>
<a name="2475"><span class="lineNum">    2475 </span><span class="lineCov">        892 :      type_decl-&gt;set_definingDeclaration(NULL);</span></a>
<a name="2476"><span class="lineNum">    2476 </span>            : </a>
<a name="2477"><span class="lineNum">    2477 </span>            :   // Set the source code position information.</a>
<a name="2478"><span class="lineNum">    2478 </span><span class="lineCov">        892 :      setOneSourcePositionNull(type_decl);</span></a>
<a name="2479"><span class="lineNum">    2479 </span>            : </a>
<a name="2480"><span class="lineNum">    2480 </span>            : //     if (scope != NULL)</a>
<a name="2481"><span class="lineNum">    2481 </span>            : //        {</a>
<a name="2482"><span class="lineNum">    2482 </span>            : #if 0</a>
<a name="2483"><span class="lineNum">    2483 </span>            :           printf (&quot;Test 2: Check on the symbol associatd with the declaration associated with the base type \n&quot;);</a>
<a name="2484"><span class="lineNum">    2484 </span>            : #endif</a>
<a name="2485"><span class="lineNum">    2485 </span>            :        // DQ (2/28/2018): check out if the symbol associated with the declaration used for the base type used in this typedef has a symbol.</a>
<a name="2486"><span class="lineNum">    2486 </span><span class="lineCov">        892 :           SgNamedType* namedType = isSgNamedType(base_type);</span></a>
<a name="2487"><span class="lineNum">    2487 </span>            : </a>
<a name="2488"><span class="lineNum">    2488 </span>            :        // DQ (3/4/2018): This might not always be true (sure enough it fails for Cxx11_tests/test2014_58.C).</a>
<a name="2489"><span class="lineNum">    2489 </span>            :        // ROSE_ASSERT(namedType != NULL);</a>
<a name="2490"><span class="lineNum">    2490 </span>            : </a>
<a name="2491"><span class="lineNum">    2491 </span><span class="lineCov">        892 :           if (namedType != NULL)</span></a>
<a name="2492"><span class="lineNum">    2492 </span>            :              {</a>
<a name="2493"><span class="lineNum">    2493 </span><span class="lineCov">        782 :                SgDeclarationStatement* declarationStatement = namedType-&gt;get_declaration();</span></a>
<a name="2494"><span class="lineNum">    2494 </span>            : </a>
<a name="2495"><span class="lineNum">    2495 </span>            :             // This might not always be true.</a>
<a name="2496"><span class="lineNum">    2496 </span><span class="lineCov">        782 :                ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="2497"><span class="lineNum">    2497 </span><span class="lineCov">        782 :                if (declarationStatement != NULL)</span></a>
<a name="2498"><span class="lineNum">    2498 </span>            :                   {</a>
<a name="2499"><span class="lineNum">    2499 </span>            : #if 0</a>
<a name="2500"><span class="lineNum">    2500 </span>            :                     printf (&quot;Found declaration for base_type = %p = %s declarationStatement = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str(),declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="2501"><span class="lineNum">    2501 </span>            : #endif</a>
<a name="2502"><span class="lineNum">    2502 </span><span class="lineCov">        782 :                     SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(declarationStatement);</span></a>
<a name="2503"><span class="lineNum">    2503 </span><span class="lineCov">        782 :                     if (templateInstantiationDecl != NULL)</span></a>
<a name="2504"><span class="lineNum">    2504 </span>            :                        {</a>
<a name="2505"><span class="lineNum">    2505 </span><span class="lineNoCov">          0 :                          SgName name = templateInstantiationDecl-&gt;get_name();</span></a>
<a name="2506"><span class="lineNum">    2506 </span>            : #if 0</a>
<a name="2507"><span class="lineNum">    2507 </span>            :                          printf (&quot;templateInstantiationDecl = %p scope = %p = %s for name = %s \n&quot;,templateInstantiationDecl,scope,scope-&gt;class_name().c_str(),name.str());</a>
<a name="2508"><span class="lineNum">    2508 </span>            : #endif</a>
<a name="2509"><span class="lineNum">    2509 </span>            :                       // DQ (2/28/2018): Added debugging to track down redundnat symbol.</a>
<a name="2510"><span class="lineNum">    2510 </span><span class="lineNoCov">          0 :                          if (scope-&gt;lookup_template_typedef_symbol(name) != NULL)</span></a>
<a name="2511"><span class="lineNum">    2511 </span>            :                             {</a>
<a name="2512"><span class="lineNum">    2512 </span><span class="lineNoCov">          0 :                               printf (&quot;Error: it appears that there is already a symbol in scope = %p = %s for name = %s \n&quot;,scope,scope-&gt;class_name().c_str(),name.str());</span></a>
<a name="2513"><span class="lineNum">    2513 </span>            :                             }</a>
<a name="2514"><span class="lineNum">    2514 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(name) == NULL);</span></a>
<a name="2515"><span class="lineNum">    2515 </span>            :                        }</a>
<a name="2516"><span class="lineNum">    2516 </span>            : #if 0</a>
<a name="2517"><span class="lineNum">    2517 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2518"><span class="lineNum">    2518 </span>            :                     ROSE_ABORT();</a>
<a name="2519"><span class="lineNum">    2519 </span>            : #endif</a>
<a name="2520"><span class="lineNum">    2520 </span>            :                   }</a>
<a name="2521"><span class="lineNum">    2521 </span>            :              }</a>
<a name="2522"><span class="lineNum">    2522 </span>            : </a>
<a name="2523"><span class="lineNum">    2523 </span>            :        // SgTypedefSymbol* typedef_symbol = new SgTypedefSymbol(type_decl);</a>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineCov">        892 :           SgTemplateTypedefSymbol* typedef_symbol = new SgTemplateTypedefSymbol(type_decl);</span></a>
<a name="2525"><span class="lineNum">    2525 </span><span class="lineCov">        892 :           ROSE_ASSERT(typedef_symbol);</span></a>
<a name="2526"><span class="lineNum">    2526 </span>            : </a>
<a name="2527"><span class="lineNum">    2527 </span>            :        // DQ (5/16/2013): This is the code we want now that we have implemented the namespace support behind the scope symbol bable interface.</a>
<a name="2528"><span class="lineNum">    2528 </span>            :        // scope-&gt;insert_symbol(SgName(name),typedef_symbol);</a>
<a name="2529"><span class="lineNum">    2529 </span><span class="lineCov">        892 :           scope-&gt;insert_symbol(name, typedef_symbol);</span></a>
<a name="2530"><span class="lineNum">    2530 </span>            : </a>
<a name="2531"><span class="lineNum">    2531 </span>            : </a>
<a name="2532"><span class="lineNum">    2532 </span><span class="lineCov">        892 :           ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(name) != NULL);</span></a>
<a name="2533"><span class="lineNum">    2533 </span>            : //        }</a>
<a name="2534"><span class="lineNum">    2534 </span>            : </a>
<a name="2535"><span class="lineNum">    2535 </span>            : #if 0</a>
<a name="2536"><span class="lineNum">    2536 </span>            :   // We have to setup the template arguments (need specialization and partial specialization support).</a>
<a name="2537"><span class="lineNum">    2537 </span>            :      printf (&quot;Template parameters not setup in buildTemplateTypedefDeclaration_nfi() \n&quot;);</a>
<a name="2538"><span class="lineNum">    2538 </span>            : #endif</a>
<a name="2539"><span class="lineNum">    2539 </span>            : </a>
<a name="2540"><span class="lineNum">    2540 </span>            : #if 0</a>
<a name="2541"><span class="lineNum">    2541 </span>            :      printf (&quot;Leaving buildTemplateTypedefDeclaration_nfi(): type_decl-&gt;get_name()             = %s \n&quot;,type_decl-&gt;get_name().str());</a>
<a name="2542"><span class="lineNum">    2542 </span>            :      printf (&quot;Leaving buildTemplateTypedefDeclaration_nfi(): type_decl-&gt;get_type()             = %p \n&quot;,type_decl-&gt;get_type());</a>
<a name="2543"><span class="lineNum">    2543 </span>            :      printf (&quot;Leaving buildTemplateTypedefDeclaration_nfi(): type_decl-&gt;get_type()-&gt;get_name() = %s \n&quot;,type_decl-&gt;get_type()-&gt;get_name().str());</a>
<a name="2544"><span class="lineNum">    2544 </span>            : #endif</a>
<a name="2545"><span class="lineNum">    2545 </span>            : </a>
<a name="2546"><span class="lineNum">    2546 </span>            : #if 0</a>
<a name="2547"><span class="lineNum">    2547 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2548"><span class="lineNum">    2548 </span>            :      ROSE_ABORT();</a>
<a name="2549"><span class="lineNum">    2549 </span>            : #endif</a>
<a name="2550"><span class="lineNum">    2550 </span>            : </a>
<a name="2551"><span class="lineNum">    2551 </span><span class="lineCov">        892 :      return type_decl;</span></a>
<a name="2552"><span class="lineNum">    2552 </span>            :    }</a>
<a name="2553"><span class="lineNum">    2553 </span>            : </a>
<a name="2554"><span class="lineNum">    2554 </span>            : ROSE_DLL_API SgTemplateInstantiationTypedefDeclaration*</a>
<a name="2555"><span class="lineNum">    2555 </span><span class="lineCov">       1040 : SageBuilder::buildTemplateInstantiationTypedefDeclaration_nfi(SgName &amp; name, SgType* base_type, SgScopeStatement* scope, bool has_defining_base, SgTemplateTypedefDeclaration* templateTypedefDeclaration, SgTemplateArgumentPtrList &amp; templateArgumentsList)</span></a>
<a name="2556"><span class="lineNum">    2556 </span>            :    {</a>
<a name="2557"><span class="lineNum">    2557 </span><span class="lineCov">       1040 :      ROSE_ASSERT (base_type != NULL);</span></a>
<a name="2558"><span class="lineNum">    2558 </span>            :   // ROSE_ASSERT(templateArgumentList != NULL);</a>
<a name="2559"><span class="lineNum">    2559 </span>            : </a>
<a name="2560"><span class="lineNum">    2560 </span>            : #if 0</a>
<a name="2561"><span class="lineNum">    2561 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): name = %s base_type = %p = %s \n&quot;,name.str(),base_type,base_type-&gt;class_name().c_str());</a>
<a name="2562"><span class="lineNum">    2562 </span>            : #endif</a>
<a name="2563"><span class="lineNum">    2563 </span>            : </a>
<a name="2564"><span class="lineNum">    2564 </span><span class="lineCov">       2080 :      SgName nameWithoutTemplateArguments = name;</span></a>
<a name="2565"><span class="lineNum">    2565 </span><span class="lineCov">       2080 :      SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;</span></a>
<a name="2566"><span class="lineNum">    2566 </span><span class="lineCov">       1040 :      nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,templateArgumentsList);</span></a>
<a name="2567"><span class="lineNum">    2567 </span>            : </a>
<a name="2568"><span class="lineNum">    2568 </span>            : #if 0</a>
<a name="2569"><span class="lineNum">    2569 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): nameWithoutTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="2570"><span class="lineNum">    2570 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): nameWithTemplateArguments    = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="2571"><span class="lineNum">    2571 </span>            : #endif</a>
<a name="2572"><span class="lineNum">    2572 </span>            : </a>
<a name="2573"><span class="lineNum">    2573 </span>            :   // We don't yet support bottom up construction for this node yet</a>
<a name="2574"><span class="lineNum">    2574 </span><span class="lineCov">       1040 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="2575"><span class="lineNum">    2575 </span>            : </a>
<a name="2576"><span class="lineNum">    2576 </span><span class="lineCov">       1040 :      SgDeclarationStatement* base_decl = NULL;</span></a>
<a name="2577"><span class="lineNum">    2577 </span>            : </a>
<a name="2578"><span class="lineNum">    2578 </span>            :   // DQ (3/20/2012): I don't remember why we need to provide the symbol for the scope of the</a>
<a name="2579"><span class="lineNum">    2579 </span>            :   // parent rather then the scope. But as I recall there was a special corner of C++ that</a>
<a name="2580"><span class="lineNum">    2580 </span>            :   // required this sort of support.</a>
<a name="2581"><span class="lineNum">    2581 </span><span class="lineCov">       1040 :      SgSymbol* parent_scope = NULL;</span></a>
<a name="2582"><span class="lineNum">    2582 </span><span class="lineCov">       1040 :      if (scope != NULL)</span></a>
<a name="2583"><span class="lineNum">    2583 </span>            :         {</a>
<a name="2584"><span class="lineNum">    2584 </span>            : #if 0</a>
<a name="2585"><span class="lineNum">    2585 </span>            :           printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): scope = %p = %s calling get_symbol_from_symbol_table() \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="2586"><span class="lineNum">    2586 </span>            : #endif</a>
<a name="2587"><span class="lineNum">    2587 </span><span class="lineCov">       1040 :           ROSE_ASSERT(scope-&gt;get_parent() != NULL);</span></a>
<a name="2588"><span class="lineNum">    2588 </span><span class="lineCov">       1040 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(scope-&gt;get_parent());</span></a>
<a name="2589"><span class="lineNum">    2589 </span>            : #if 0</a>
<a name="2590"><span class="lineNum">    2590 </span>            :           printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): declaration = %p \n&quot;,declaration);</a>
<a name="2591"><span class="lineNum">    2591 </span>            : #endif</a>
<a name="2592"><span class="lineNum">    2592 </span><span class="lineCov">       1040 :           if (declaration != NULL)</span></a>
<a name="2593"><span class="lineNum">    2593 </span>            :              {</a>
<a name="2594"><span class="lineNum">    2594 </span>            : #if 0</a>
<a name="2595"><span class="lineNum">    2595 </span>            :                printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): Found a valid declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="2596"><span class="lineNum">    2596 </span>            : #endif</a>
<a name="2597"><span class="lineNum">    2597 </span><span class="lineCov">       1008 :                ROSE_ASSERT(declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2598"><span class="lineNum">    2598 </span>            :             // parent_scope = declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</a>
<a name="2599"><span class="lineNum">    2599 </span><span class="lineCov">       1008 :                parent_scope = declaration-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="2600"><span class="lineNum">    2600 </span>            : </a>
<a name="2601"><span class="lineNum">    2601 </span><span class="lineCov">       1008 :                ROSE_ASSERT(parent_scope != NULL);</span></a>
<a name="2602"><span class="lineNum">    2602 </span>            :              }</a>
<a name="2603"><span class="lineNum">    2603 </span>            :         }</a>
<a name="2604"><span class="lineNum">    2604 </span>            : </a>
<a name="2605"><span class="lineNum">    2605 </span>            :   // DQ (11/5/2014): I think this might be set afterward.</a>
<a name="2606"><span class="lineNum">    2606 </span><span class="lineCov">       1040 :      ROSE_ASSERT(templateTypedefDeclaration != NULL);</span></a>
<a name="2607"><span class="lineNum">    2607 </span>            : </a>
<a name="2608"><span class="lineNum">    2608 </span>            : #if 0</a>
<a name="2609"><span class="lineNum">    2609 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): parent_scope = %p \n&quot;,parent_scope);</a>
<a name="2610"><span class="lineNum">    2610 </span>            : #endif</a>
<a name="2611"><span class="lineNum">    2611 </span>            : </a>
<a name="2612"><span class="lineNum">    2612 </span><span class="lineCov">       1040 :      SgTemplateTypedefSymbol* prexisting_template_typedef_symbol = scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments);</span></a>
<a name="2613"><span class="lineNum">    2613 </span><span class="lineCov">       1040 :      if (prexisting_template_typedef_symbol != NULL)</span></a>
<a name="2614"><span class="lineNum">    2614 </span>            :         {</a>
<a name="2615"><span class="lineNum">    2615 </span><span class="lineCov">        438 :           SgDeclarationStatement* declarationStatement = prexisting_template_typedef_symbol-&gt;get_declaration();</span></a>
<a name="2616"><span class="lineNum">    2616 </span><span class="lineCov">        438 :           ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="2617"><span class="lineNum">    2617 </span><span class="lineCov">        438 :           SgTemplateInstantiationTypedefDeclaration* return_declaration = isSgTemplateInstantiationTypedefDeclaration(declarationStatement);</span></a>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineCov">        438 :           ROSE_ASSERT(return_declaration != NULL);</span></a>
<a name="2619"><span class="lineNum">    2619 </span><span class="lineCov">        438 :           return return_declaration;</span></a>
<a name="2620"><span class="lineNum">    2620 </span>            :         }</a>
<a name="2621"><span class="lineNum">    2621 </span><span class="lineCov">        602 :      ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) == NULL);</span></a>
<a name="2622"><span class="lineNum">    2622 </span>            : </a>
<a name="2623"><span class="lineNum">    2623 </span>            : #if 0</a>
<a name="2624"><span class="lineNum">    2624 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): calling SgTemplateInstantiationTypedefDeclaration constructor \n&quot;);</a>
<a name="2625"><span class="lineNum">    2625 </span>            : #endif</a>
<a name="2626"><span class="lineNum">    2626 </span>            : </a>
<a name="2627"><span class="lineNum">    2627 </span>            :   // DQ (2/25/2018): Not clear if we want to use the template name with arguments.</a>
<a name="2628"><span class="lineNum">    2628 </span>            :   // Calling: SgTemplateInstantiationTypedefDeclaration(SgName, SgType*, SgTypedefType*, SgDeclarationStatement*, SgSymbol*, SgTemplateTypedefDeclaration*, SgTemplateArgumentPtrList)</a>
<a name="2629"><span class="lineNum">    2629 </span><span class="lineCov">        602 :      SgTypedefType* typedefType = NULL;</span></a>
<a name="2630"><span class="lineNum">    2630 </span><span class="lineCov">        602 :      SgTemplateInstantiationTypedefDeclaration* type_decl =</span></a>
<a name="2631"><span class="lineNum">    2631 </span><span class="lineCov">       1204 :           new SgTemplateInstantiationTypedefDeclaration(nameWithTemplateArguments, base_type, typedefType, base_decl, parent_scope, templateTypedefDeclaration, templateArgumentsList);</span></a>
<a name="2632"><span class="lineNum">    2632 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl != NULL);</span></a>
<a name="2633"><span class="lineNum">    2633 </span>            : </a>
<a name="2634"><span class="lineNum">    2634 </span>            :   // DQ (2/27/2018): This is a change in the constructor semantics, we now have to build the type explicitly.</a>
<a name="2635"><span class="lineNum">    2635 </span>            :   // printf (&quot;We now have to build the type explicitly \n&quot;);</a>
<a name="2636"><span class="lineNum">    2636 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_type() == NULL);</span></a>
<a name="2637"><span class="lineNum">    2637 </span>            : </a>
<a name="2638"><span class="lineNum">    2638 </span>            : </a>
<a name="2639"><span class="lineNum">    2639 </span>            :   // DQ (2/27/2018): Set the template name that this instantiation is using.</a>
<a name="2640"><span class="lineNum">    2640 </span><span class="lineCov">        602 :      type_decl-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="2641"><span class="lineNum">    2641 </span>            : </a>
<a name="2642"><span class="lineNum">    2642 </span>            : </a>
<a name="2643"><span class="lineNum">    2643 </span>            :   // ROSE_ASSERT(parent_scope != NULL);</a>
<a name="2644"><span class="lineNum">    2644 </span>            :   // type_decl-&gt;set_parent(parent_scope);</a>
<a name="2645"><span class="lineNum">    2645 </span><span class="lineCov">        602 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="2646"><span class="lineNum">    2646 </span>            :   // type_decl-&gt;set_parent(scope);</a>
<a name="2647"><span class="lineNum">    2647 </span><span class="lineCov">        602 :      type_decl-&gt;set_scope(scope);</span></a>
<a name="2648"><span class="lineNum">    2648 </span>            : </a>
<a name="2649"><span class="lineNum">    2649 </span>            :   // DQ (3/1/2018): A bug in the name of the template with arguments has been detected (extra spaces in</a>
<a name="2650"><span class="lineNum">    2650 </span>            :   // the name generated by type_decl-&gt;resetTemplateName()), make sure that we have a consistant naming.</a>
<a name="2651"><span class="lineNum">    2651 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_name() == nameWithTemplateArguments);</span></a>
<a name="2652"><span class="lineNum">    2652 </span>            : </a>
<a name="2653"><span class="lineNum">    2653 </span>            :   // DQ (2/28/2018): Added debugging to track down redundnat symbol.</a>
<a name="2654"><span class="lineNum">    2654 </span><span class="lineCov">        602 :      if (scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) != NULL)</span></a>
<a name="2655"><span class="lineNum">    2655 </span>            :         {</a>
<a name="2656"><span class="lineNum">    2656 </span><span class="lineNoCov">          0 :           printf (&quot;Error: it appears that there is already a symbol in scope = %p = %s for name = %s \n&quot;,scope,scope-&gt;class_name().c_str(),name.str());</span></a>
<a name="2657"><span class="lineNum">    2657 </span>            :         }</a>
<a name="2658"><span class="lineNum">    2658 </span><span class="lineCov">        602 :      ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) == NULL);</span></a>
<a name="2659"><span class="lineNum">    2659 </span>            : </a>
<a name="2660"><span class="lineNum">    2660 </span>            : </a>
<a name="2661"><span class="lineNum">    2661 </span>            :   // DQ (2/26/2018): Can we assert this?</a>
<a name="2662"><span class="lineNum">    2662 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_type() == NULL);</span></a>
<a name="2663"><span class="lineNum">    2663 </span>            : </a>
<a name="2664"><span class="lineNum">    2664 </span><span class="lineCov">        602 :      SgTypedefType* new_typedefType = SgTypedefType::createType(type_decl);</span></a>
<a name="2665"><span class="lineNum">    2665 </span><span class="lineCov">        602 :      ROSE_ASSERT(new_typedefType != NULL);</span></a>
<a name="2666"><span class="lineNum">    2666 </span>            : </a>
<a name="2667"><span class="lineNum">    2667 </span><span class="lineCov">        602 :      type_decl-&gt;set_type(new_typedefType);</span></a>
<a name="2668"><span class="lineNum">    2668 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_type() != NULL);</span></a>
<a name="2669"><span class="lineNum">    2669 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_scope() != NULL);</span></a>
<a name="2670"><span class="lineNum">    2670 </span>            : </a>
<a name="2671"><span class="lineNum">    2671 </span><span class="lineCov">        602 :      type_decl-&gt;set_firstNondefiningDeclaration (type_decl);</span></a>
<a name="2672"><span class="lineNum">    2672 </span><span class="lineCov">        602 :      type_decl-&gt;set_definingDeclaration(NULL);</span></a>
<a name="2673"><span class="lineNum">    2673 </span>            : </a>
<a name="2674"><span class="lineNum">    2674 </span><span class="lineCov">        602 :      setOneSourcePositionNull(type_decl);</span></a>
<a name="2675"><span class="lineNum">    2675 </span>            : </a>
<a name="2676"><span class="lineNum">    2676 </span><span class="lineCov">        602 :      SgName mangled_name = type_decl-&gt;get_mangled_name();</span></a>
<a name="2677"><span class="lineNum">    2677 </span>            : #if 0</a>
<a name="2678"><span class="lineNum">    2678 </span>            :      printf (&quot;In buildTemplateInstantiationTypedefDeclaration_nfi(): mangled_name                 = %s \n&quot;,mangled_name.str());</a>
<a name="2679"><span class="lineNum">    2679 </span>            : #endif</a>
<a name="2680"><span class="lineNum">    2680 </span><span class="lineCov">        602 :      setTemplateArgumentsInDeclaration(type_decl,&amp;templateArgumentsList);</span></a>
<a name="2681"><span class="lineNum">    2681 </span>            : </a>
<a name="2682"><span class="lineNum">    2682 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2683"><span class="lineNum">    2683 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="2684"><span class="lineNum">    2684 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_firstNondefiningDeclaration() == type_decl);</span></a>
<a name="2685"><span class="lineNum">    2685 </span>            : </a>
<a name="2686"><span class="lineNum">    2686 </span><span class="lineCov">        602 :      ROSE_ASSERT(type_decl-&gt;get_type() != NULL);</span></a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineCov">        602 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="2688"><span class="lineNum">    2688 </span>            : </a>
<a name="2689"><span class="lineNum">    2689 </span><span class="lineCov">        602 :      if (scope != NULL)</span></a>
<a name="2690"><span class="lineNum">    2690 </span>            :         {</a>
<a name="2691"><span class="lineNum">    2691 </span><span class="lineCov">        602 :           if (scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) != NULL)</span></a>
<a name="2692"><span class="lineNum">    2692 </span>            :              {</a>
<a name="2693"><span class="lineNum">    2693 </span><span class="lineNoCov">          0 :                printf (&quot;Error: it appears that there is already a symbol in scope = %p = %s for nameWithTemplateArguments = %s \n&quot;,scope,scope-&gt;class_name().c_str(),nameWithTemplateArguments.str());</span></a>
<a name="2694"><span class="lineNum">    2694 </span>            :              }</a>
<a name="2695"><span class="lineNum">    2695 </span><span class="lineCov">        602 :           ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) == NULL);</span></a>
<a name="2696"><span class="lineNum">    2696 </span>            : </a>
<a name="2697"><span class="lineNum">    2697 </span><span class="lineCov">        602 :           SgTemplateTypedefSymbol* typedef_symbol = new SgTemplateTypedefSymbol(type_decl);</span></a>
<a name="2698"><span class="lineNum">    2698 </span><span class="lineCov">        602 :           ROSE_ASSERT(typedef_symbol);</span></a>
<a name="2699"><span class="lineNum">    2699 </span>            : </a>
<a name="2700"><span class="lineNum">    2700 </span><span class="lineCov">        602 :           scope-&gt;insert_symbol(nameWithTemplateArguments,typedef_symbol);</span></a>
<a name="2701"><span class="lineNum">    2701 </span><span class="lineCov">        602 :           type_decl-&gt;set_scope(scope);</span></a>
<a name="2702"><span class="lineNum">    2702 </span><span class="lineCov">        602 :           type_decl-&gt;set_parent(scope);</span></a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">        602 :           ROSE_ASSERT(scope-&gt;lookup_template_typedef_symbol(nameWithTemplateArguments) != NULL);</span></a>
<a name="2704"><span class="lineNum">    2704 </span>            :         }</a>
<a name="2705"><span class="lineNum">    2705 </span>            : </a>
<a name="2706"><span class="lineNum">    2706 </span><span class="lineCov">        602 :      return type_decl;</span></a>
<a name="2707"><span class="lineNum">    2707 </span>            :    }</a>
<a name="2708"><span class="lineNum">    2708 </span>            : </a>
<a name="2709"><span class="lineNum">    2709 </span>            : </a>
<a name="2710"><span class="lineNum">    2710 </span>            : </a>
<a name="2711"><span class="lineNum">    2711 </span>            : </a>
<a name="2712"><span class="lineNum">    2712 </span>            : </a>
<a name="2713"><span class="lineNum">    2713 </span>            : //-----------------------------------------------</a>
<a name="2714"><span class="lineNum">    2714 </span>            : // Assertion `definingDeclaration != NULL || firstNondefiningDeclaration != NULL'</a>
<a name="2715"><span class="lineNum">    2715 </span>            : SgFunctionParameterList *</a>
<a name="2716"><span class="lineNum">    2716 </span><span class="lineCov">         20 : SageBuilder::buildFunctionParameterList(SgInitializedName* in1, SgInitializedName* in2, SgInitializedName* in3, SgInitializedName* in4, SgInitializedName* in5, SgInitializedName* in6, SgInitializedName* in7, SgInitializedName* in8, SgInitializedName* in9, SgInitializedName* in10)</span></a>
<a name="2717"><span class="lineNum">    2717 </span>            : {</a>
<a name="2718"><span class="lineNum">    2718 </span><span class="lineCov">         20 :   SgFunctionParameterList *parameterList = new SgFunctionParameterList();</span></a>
<a name="2719"><span class="lineNum">    2719 </span><span class="lineCov">         20 :   ROSE_ASSERT (parameterList);</span></a>
<a name="2720"><span class="lineNum">    2720 </span>            : </a>
<a name="2721"><span class="lineNum">    2721 </span><span class="lineCov">         20 :   parameterList-&gt;set_definingDeclaration (NULL);</span></a>
<a name="2722"><span class="lineNum">    2722 </span><span class="lineCov">         20 :   parameterList-&gt;set_firstNondefiningDeclaration (parameterList);</span></a>
<a name="2723"><span class="lineNum">    2723 </span>            : </a>
<a name="2724"><span class="lineNum">    2724 </span><span class="lineCov">         20 :   setOneSourcePositionForTransformation(parameterList);</span></a>
<a name="2725"><span class="lineNum">    2725 </span>            : </a>
<a name="2726"><span class="lineNum">    2726 </span><span class="lineCov">         20 :   if (in1) appendArg(parameterList, in1);</span></a>
<a name="2727"><span class="lineNum">    2727 </span><span class="lineCov">         20 :   if (in2) appendArg(parameterList, in2);</span></a>
<a name="2728"><span class="lineNum">    2728 </span><span class="lineCov">         20 :   if (in3) appendArg(parameterList, in3);</span></a>
<a name="2729"><span class="lineNum">    2729 </span><span class="lineCov">         20 :   if (in4) appendArg(parameterList, in4);</span></a>
<a name="2730"><span class="lineNum">    2730 </span><span class="lineCov">         20 :   if (in5) appendArg(parameterList, in5);</span></a>
<a name="2731"><span class="lineNum">    2731 </span><span class="lineCov">         20 :   if (in6) appendArg(parameterList, in6);</span></a>
<a name="2732"><span class="lineNum">    2732 </span><span class="lineCov">         20 :   if (in7) appendArg(parameterList, in7);</span></a>
<a name="2733"><span class="lineNum">    2733 </span><span class="lineCov">         20 :   if (in8) appendArg(parameterList, in8);</span></a>
<a name="2734"><span class="lineNum">    2734 </span><span class="lineCov">         20 :   if (in9) appendArg(parameterList, in9);</span></a>
<a name="2735"><span class="lineNum">    2735 </span><span class="lineCov">         20 :   if (in10) appendArg(parameterList, in10);</span></a>
<a name="2736"><span class="lineNum">    2736 </span>            : </a>
<a name="2737"><span class="lineNum">    2737 </span><span class="lineCov">         20 :   return parameterList;</span></a>
<a name="2738"><span class="lineNum">    2738 </span>            : }</a>
<a name="2739"><span class="lineNum">    2739 </span>            : </a>
<a name="2740"><span class="lineNum">    2740 </span>            : SgFunctionParameterList *</a>
<a name="2741"><span class="lineNum">    2741 </span><span class="lineCov">    2321710 : SageBuilder::buildFunctionParameterList_nfi() {</span></a>
<a name="2742"><span class="lineNum">    2742 </span><span class="lineCov">    2321710 :   SgFunctionParameterList *parameterList = new SgFunctionParameterList();</span></a>
<a name="2743"><span class="lineNum">    2743 </span><span class="lineCov">    2321710 :   ROSE_ASSERT (parameterList);</span></a>
<a name="2744"><span class="lineNum">    2744 </span><span class="lineCov">    2321710 :   parameterList-&gt;set_definingDeclaration (NULL);</span></a>
<a name="2745"><span class="lineNum">    2745 </span><span class="lineCov">    2321710 :   parameterList-&gt;set_firstNondefiningDeclaration (parameterList);</span></a>
<a name="2746"><span class="lineNum">    2746 </span>            : </a>
<a name="2747"><span class="lineNum">    2747 </span><span class="lineCov">    2321710 :   setOneSourcePositionNull(parameterList);</span></a>
<a name="2748"><span class="lineNum">    2748 </span>            : </a>
<a name="2749"><span class="lineNum">    2749 </span><span class="lineCov">    2321710 :   return parameterList;</span></a>
<a name="2750"><span class="lineNum">    2750 </span>            : }</a>
<a name="2751"><span class="lineNum">    2751 </span>            : </a>
<a name="2752"><span class="lineNum">    2752 </span>            : //-----------------------------------------------</a>
<a name="2753"><span class="lineNum">    2753 </span>            : SgCtorInitializerList *</a>
<a name="2754"><span class="lineNum">    2754 </span><span class="lineNoCov">          0 : SageBuilder::buildCtorInitializerList_nfi() {</span></a>
<a name="2755"><span class="lineNum">    2755 </span><span class="lineNoCov">          0 :   SgCtorInitializerList *ctorInitList = new SgCtorInitializerList();</span></a>
<a name="2756"><span class="lineNum">    2756 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ctorInitList);</span></a>
<a name="2757"><span class="lineNum">    2757 </span><span class="lineNoCov">          0 :   ctorInitList-&gt;set_definingDeclaration (NULL);</span></a>
<a name="2758"><span class="lineNum">    2758 </span><span class="lineNoCov">          0 :   ctorInitList-&gt;set_firstNondefiningDeclaration (ctorInitList);</span></a>
<a name="2759"><span class="lineNum">    2759 </span>            : </a>
<a name="2760"><span class="lineNum">    2760 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(ctorInitList);</span></a>
<a name="2761"><span class="lineNum">    2761 </span>            : </a>
<a name="2762"><span class="lineNum">    2762 </span><span class="lineNoCov">          0 :   return ctorInitList;</span></a>
<a name="2763"><span class="lineNum">    2763 </span>            : }</a>
<a name="2764"><span class="lineNum">    2764 </span>            : </a>
<a name="2765"><span class="lineNum">    2765 </span>            : //-----------------------------------------------</a>
<a name="2766"><span class="lineNum">    2766 </span>            : // no type vs. void type ?</a>
<a name="2767"><span class="lineNum">    2767 </span>            : SgFunctionParameterTypeList *</a>
<a name="2768"><span class="lineNum">    2768 </span><span class="lineCov">    1161210 : SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList* paralist)</span></a>
<a name="2769"><span class="lineNum">    2769 </span>            :    {</a>
<a name="2770"><span class="lineNum">    2770 </span>            :   // DQ (8/19/2012): I am not a fan of this sort of codeing style either (NULL pointers as inputs should be an error).</a>
<a name="2771"><span class="lineNum">    2771 </span><span class="lineCov">    1161210 :      if (paralist == NULL)</span></a>
<a name="2772"><span class="lineNum">    2772 </span>            :         {</a>
<a name="2773"><span class="lineNum">    2773 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: In buildFunctionParameterTypeList(): Accepting NULL input and returning NULL pointer. \n&quot;);</span></a>
<a name="2774"><span class="lineNum">    2774 </span>            : </a>
<a name="2775"><span class="lineNum">    2775 </span><span class="lineNoCov">          0 :           return NULL;</span></a>
<a name="2776"><span class="lineNum">    2776 </span>            :         }</a>
<a name="2777"><span class="lineNum">    2777 </span>            : </a>
<a name="2778"><span class="lineNum">    2778 </span>            :   // DQ (8/18/2012): This is a problem, any valid list (even zero length) should result in a valid return list of types (even zero length).</a>
<a name="2779"><span class="lineNum">    2779 </span>            :   // if (paralist-&gt;get_args().size()==0)</a>
<a name="2780"><span class="lineNum">    2780 </span>            :   //      return NULL;</a>
<a name="2781"><span class="lineNum">    2781 </span>            : </a>
<a name="2782"><span class="lineNum">    2782 </span><span class="lineCov">    1161210 :      SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;</span></a>
<a name="2783"><span class="lineNum">    2783 </span><span class="lineCov">    1161210 :      ROSE_ASSERT(typePtrList != NULL);</span></a>
<a name="2784"><span class="lineNum">    2784 </span>            : </a>
<a name="2785"><span class="lineNum">    2785 </span>            : #if 0</a>
<a name="2786"><span class="lineNum">    2786 </span>            :      printf (&quot;In SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList*): SgFunctionParameterTypeList* typePtrList = %p \n&quot;,typePtrList);</a>
<a name="2787"><span class="lineNum">    2787 </span>            : #endif</a>
<a name="2788"><span class="lineNum">    2788 </span>            : </a>
<a name="2789"><span class="lineNum">    2789 </span><span class="lineCov">    2322430 :      SgInitializedNamePtrList args = paralist-&gt;get_args();</span></a>
<a name="2790"><span class="lineNum">    2790 </span><span class="lineCov">    1161210 :      SgInitializedNamePtrList::const_iterator i;</span></a>
<a name="2791"><span class="lineNum">    2791 </span><span class="lineCov">    4325680 :      for(i = args.begin(); i != args.end(); i++)</span></a>
<a name="2792"><span class="lineNum">    2792 </span><span class="lineCov">    3164470 :           (typePtrList-&gt;get_arguments()).push_back( (*i)-&gt;get_type() );</span></a>
<a name="2793"><span class="lineNum">    2793 </span>            : </a>
<a name="2794"><span class="lineNum">    2794 </span>            : #if 0</a>
<a name="2795"><span class="lineNum">    2795 </span>            :      printf (&quot;In SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList*): calling setSourcePositionAtRootAndAllChildren() \n&quot;);</a>
<a name="2796"><span class="lineNum">    2796 </span>            : #endif</a>
<a name="2797"><span class="lineNum">    2797 </span>            : </a>
<a name="2798"><span class="lineNum">    2798 </span><span class="lineCov">    1161210 :      setSourcePositionAtRootAndAllChildren(typePtrList);</span></a>
<a name="2799"><span class="lineNum">    2799 </span>            : </a>
<a name="2800"><span class="lineNum">    2800 </span>            : #if 0</a>
<a name="2801"><span class="lineNum">    2801 </span>            :      printf (&quot;DONE: In SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList*): calling setSourcePositionAtRootAndAllChildren() \n&quot;);</a>
<a name="2802"><span class="lineNum">    2802 </span>            : #endif</a>
<a name="2803"><span class="lineNum">    2803 </span>            : </a>
<a name="2804"><span class="lineNum">    2804 </span><span class="lineCov">    1161210 :      return typePtrList;</span></a>
<a name="2805"><span class="lineNum">    2805 </span>            :    }</a>
<a name="2806"><span class="lineNum">    2806 </span>            : </a>
<a name="2807"><span class="lineNum">    2807 </span>            : </a>
<a name="2808"><span class="lineNum">    2808 </span>            : SgFunctionParameterTypeList *</a>
<a name="2809"><span class="lineNum">    2809 </span><span class="lineCov">          4 : SageBuilder::buildFunctionParameterTypeList (SgExprListExp * expList)</span></a>
<a name="2810"><span class="lineNum">    2810 </span>            :    {</a>
<a name="2811"><span class="lineNum">    2811 </span><span class="lineCov">          4 :      if (expList ==NULL) return NULL;</span></a>
<a name="2812"><span class="lineNum">    2812 </span><span class="lineCov">          8 :      SgExpressionPtrList expPtrList = expList-&gt;get_expressions();</span></a>
<a name="2813"><span class="lineNum">    2813 </span>            : </a>
<a name="2814"><span class="lineNum">    2814 </span><span class="lineCov">          4 :      SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;</span></a>
<a name="2815"><span class="lineNum">    2815 </span><span class="lineCov">          4 :      ROSE_ASSERT(typePtrList);</span></a>
<a name="2816"><span class="lineNum">    2816 </span>            : </a>
<a name="2817"><span class="lineNum">    2817 </span>            : #if 0</a>
<a name="2818"><span class="lineNum">    2818 </span>            :      printf (&quot;In SageBuilder::buildFunctionParameterTypeList(SgExprListExp*): SgFunctionParameterTypeList* typePtrList = %p \n&quot;,typePtrList);</a>
<a name="2819"><span class="lineNum">    2819 </span>            : #endif</a>
<a name="2820"><span class="lineNum">    2820 </span>            : </a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineCov">          4 :      SgExpressionPtrList::const_iterator i;</span></a>
<a name="2822"><span class="lineNum">    2822 </span><span class="lineCov">          7 :      for (i=expPtrList.begin();i!=expPtrList.end();i++)</span></a>
<a name="2823"><span class="lineNum">    2823 </span>            :         {</a>
<a name="2824"><span class="lineNum">    2824 </span><span class="lineCov">          3 :           typePtrList-&gt;get_arguments().push_back( (*i)-&gt;get_type() );</span></a>
<a name="2825"><span class="lineNum">    2825 </span>            :         }</a>
<a name="2826"><span class="lineNum">    2826 </span>            : </a>
<a name="2827"><span class="lineNum">    2827 </span><span class="lineCov">          4 :      setSourcePositionAtRootAndAllChildren(typePtrList);</span></a>
<a name="2828"><span class="lineNum">    2828 </span>            : </a>
<a name="2829"><span class="lineNum">    2829 </span><span class="lineCov">          4 :      return typePtrList;</span></a>
<a name="2830"><span class="lineNum">    2830 </span>            :    }</a>
<a name="2831"><span class="lineNum">    2831 </span>            : </a>
<a name="2832"><span class="lineNum">    2832 </span>            : SgFunctionParameterTypeList *</a>
<a name="2833"><span class="lineNum">    2833 </span><span class="lineCov">          2 : SageBuilder::buildFunctionParameterTypeList(SgType* type0, SgType* type1, SgType* type2, SgType* type3,</span></a>
<a name="2834"><span class="lineNum">    2834 </span>            :                                             SgType* type4, SgType* type5, SgType* type6, SgType* type7)</a>
<a name="2835"><span class="lineNum">    2835 </span>            :    {</a>
<a name="2836"><span class="lineNum">    2836 </span><span class="lineCov">          2 :      SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;</span></a>
<a name="2837"><span class="lineNum">    2837 </span><span class="lineCov">          2 :      ROSE_ASSERT(typePtrList);</span></a>
<a name="2838"><span class="lineNum">    2838 </span>            : </a>
<a name="2839"><span class="lineNum">    2839 </span>            : #if 0</a>
<a name="2840"><span class="lineNum">    2840 </span>            :      printf (&quot;In SageBuilder::buildFunctionParameterTypeList(SgType*,SgType*,...): SgFunctionParameterTypeList* typePtrList = %p \n&quot;,typePtrList);</a>
<a name="2841"><span class="lineNum">    2841 </span>            : #endif</a>
<a name="2842"><span class="lineNum">    2842 </span>            : </a>
<a name="2843"><span class="lineNum">    2843 </span><span class="lineCov">          2 :      SgTypePtrList &amp; types = typePtrList-&gt;get_arguments();</span></a>
<a name="2844"><span class="lineNum">    2844 </span>            : </a>
<a name="2845"><span class="lineNum">    2845 </span><span class="lineCov">          2 :      if (type0 != NULL) types.push_back(type0);</span></a>
<a name="2846"><span class="lineNum">    2846 </span><span class="lineCov">          2 :      if (type1 != NULL) types.push_back(type1);</span></a>
<a name="2847"><span class="lineNum">    2847 </span><span class="lineCov">          2 :      if (type2 != NULL) types.push_back(type2);</span></a>
<a name="2848"><span class="lineNum">    2848 </span><span class="lineCov">          2 :      if (type3 != NULL) types.push_back(type3);</span></a>
<a name="2849"><span class="lineNum">    2849 </span><span class="lineCov">          2 :      if (type4 != NULL) types.push_back(type4);</span></a>
<a name="2850"><span class="lineNum">    2850 </span><span class="lineCov">          2 :      if (type5 != NULL) types.push_back(type5);</span></a>
<a name="2851"><span class="lineNum">    2851 </span><span class="lineCov">          2 :      if (type6 != NULL) types.push_back(type6);</span></a>
<a name="2852"><span class="lineNum">    2852 </span><span class="lineCov">          2 :      if (type7 != NULL) types.push_back(type7);</span></a>
<a name="2853"><span class="lineNum">    2853 </span>            : </a>
<a name="2854"><span class="lineNum">    2854 </span><span class="lineCov">          2 :      return typePtrList;</span></a>
<a name="2855"><span class="lineNum">    2855 </span>            :    }</a>
<a name="2856"><span class="lineNum">    2856 </span>            : </a>
<a name="2857"><span class="lineNum">    2857 </span>            : //-----------------------------------------------</a>
<a name="2858"><span class="lineNum">    2858 </span>            : // build function type,</a>
<a name="2859"><span class="lineNum">    2859 </span>            : //</a>
<a name="2860"><span class="lineNum">    2860 </span>            : // insert into symbol table when not duplicated</a>
<a name="2861"><span class="lineNum">    2861 </span>            : SgFunctionType *</a>
<a name="2862"><span class="lineNum">    2862 </span><span class="lineCov">    2284540 : SageBuilder::buildFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList)</span></a>
<a name="2863"><span class="lineNum">    2863 </span>            :    {</a>
<a name="2864"><span class="lineNum">    2864 </span><span class="lineCov">    2284540 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="2865"><span class="lineNum">    2865 </span>            : </a>
<a name="2866"><span class="lineNum">    2866 </span>            :   // DQ (8/19/2012): Can we enforce this?</a>
<a name="2867"><span class="lineNum">    2867 </span><span class="lineCov">    2284540 :      ROSE_ASSERT(typeList != NULL);</span></a>
<a name="2868"><span class="lineNum">    2868 </span>            : </a>
<a name="2869"><span class="lineNum">    2869 </span>            : #if 0</a>
<a name="2870"><span class="lineNum">    2870 </span>            :      printf (&quot;Inside of SageBuilder::buildFunctionType(SgType,SgFunctionParameterTypeList) \n&quot;);</a>
<a name="2871"><span class="lineNum">    2871 </span>            :      printf (&quot;Inside of SageBuilder::buildFunctionType() return_type = %s \n&quot;,return_type-&gt;get_mangled().str());</a>
<a name="2872"><span class="lineNum">    2872 </span>            :      printf (&quot;Inside of SageBuilder::buildFunctionType() typeList-&gt;get_arguments().size() = %&quot; PRIuPTR &quot; \n&quot;,typeList-&gt;get_arguments().size());</a>
<a name="2873"><span class="lineNum">    2873 </span>            :      for (size_t i=0; i &lt; typeList-&gt;get_arguments().size(); i++)</a>
<a name="2874"><span class="lineNum">    2874 </span>            :         {</a>
<a name="2875"><span class="lineNum">    2875 </span>            :           ROSE_ASSERT(typeList-&gt;get_arguments()[i] != NULL);</a>
<a name="2876"><span class="lineNum">    2876 </span>            :           printf (&quot;   --- typeList-&gt;get_arguments()[%zu] = %p = %s \n&quot;,i,typeList-&gt;get_arguments()[i],typeList-&gt;get_arguments()[i]-&gt;class_name().c_str());</a>
<a name="2877"><span class="lineNum">    2877 </span>            :         }</a>
<a name="2878"><span class="lineNum">    2878 </span>            : #endif</a>
<a name="2879"><span class="lineNum">    2879 </span>            : #if 0</a>
<a name="2880"><span class="lineNum">    2880 </span>            :   // DQ (1/21/2014): Activate this test to see how we are building SgFunctionType with return type as SgFunctionType (see test2014_53.c).</a>
<a name="2881"><span class="lineNum">    2881 </span>            :      printf (&quot;Inside of SageBuilder::buildFunctionType() (activate test for return_type): return_type = %p = %s \n&quot;,return_type,return_type-&gt;class_name().c_str());</a>
<a name="2882"><span class="lineNum">    2882 </span>            : #endif</a>
<a name="2883"><span class="lineNum">    2883 </span>            : #if 0</a>
<a name="2884"><span class="lineNum">    2884 </span>            :   // DQ (1/21/2014): Activate this test to see how we are building SgFunctionType with return type as SgFunctionType (see test2014_53.c).</a>
<a name="2885"><span class="lineNum">    2885 </span>            :      if (isSgFunctionType(return_type) != NULL)</a>
<a name="2886"><span class="lineNum">    2886 </span>            :         {</a>
<a name="2887"><span class="lineNum">    2887 </span>            :        // Liao 12/14/2012. This is not true for some functions (e.g. findFunctionUsingDlopen() on top of dlopen()) returning a function type</a>
<a name="2888"><span class="lineNum">    2888 </span>            :           printf (&quot;ERROR: Inside of SageBuilder::buildFunctionType(): function type can't be return type of function type (at least for debugging) \n&quot;);</a>
<a name="2889"><span class="lineNum">    2889 </span>            :           ROSE_ABORT();</a>
<a name="2890"><span class="lineNum">    2890 </span>            :         }</a>
<a name="2891"><span class="lineNum">    2891 </span>            : #endif</a>
<a name="2892"><span class="lineNum">    2892 </span>            : </a>
<a name="2893"><span class="lineNum">    2893 </span><span class="lineCov">    2284540 :      SgFunctionTypeTable * fTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="2894"><span class="lineNum">    2894 </span><span class="lineCov">    2284540 :      ROSE_ASSERT(fTable);</span></a>
<a name="2895"><span class="lineNum">    2895 </span>            : </a>
<a name="2896"><span class="lineNum">    2896 </span>            :   // This function make clever use of a static member function which can't be built</a>
<a name="2897"><span class="lineNum">    2897 </span>            :   // for the case of a SgMemberFunctionType (or at least not without more work).</a>
<a name="2898"><span class="lineNum">    2898 </span><span class="lineCov">    2284540 :      SgName typeName = SgFunctionType::get_mangled(return_type, typeList);</span></a>
<a name="2899"><span class="lineNum">    2899 </span>            : </a>
<a name="2900"><span class="lineNum">    2900 </span><span class="lineCov">    2284540 :      SgFunctionType* funcType = isSgFunctionType(fTable-&gt;lookup_function_type(typeName));</span></a>
<a name="2901"><span class="lineNum">    2901 </span>            : </a>
<a name="2902"><span class="lineNum">    2902 </span>            : #if 0</a>
<a name="2903"><span class="lineNum">    2903 </span>            :      printf (&quot;In SageBuilder::buildFunctionType(): typeName = %s funcType = %p \n&quot;,typeName.str(),funcType);</a>
<a name="2904"><span class="lineNum">    2904 </span>            :      if (funcType != NULL)</a>
<a name="2905"><span class="lineNum">    2905 </span>            :         {</a>
<a name="2906"><span class="lineNum">    2906 </span>            :           printf (&quot;In SageBuilder::buildFunctionType(): funcType-&gt;get_mangled_type() = %s \n&quot;,funcType-&gt;get_mangled_type().str());</a>
<a name="2907"><span class="lineNum">    2907 </span>            :         }</a>
<a name="2908"><span class="lineNum">    2908 </span>            : #endif</a>
<a name="2909"><span class="lineNum">    2909 </span>            : </a>
<a name="2910"><span class="lineNum">    2910 </span><span class="lineCov">    2284540 :      if (funcType == NULL)</span></a>
<a name="2911"><span class="lineNum">    2911 </span>            :         {</a>
<a name="2912"><span class="lineNum">    2912 </span>            :        // Only build the new type if it can't be found in the global type table.</a>
<a name="2913"><span class="lineNum">    2913 </span><span class="lineCov">     230808 :           funcType = new SgFunctionType(return_type, false);</span></a>
<a name="2914"><span class="lineNum">    2914 </span><span class="lineCov">     230808 :           ROSE_ASSERT(funcType);</span></a>
<a name="2915"><span class="lineNum">    2915 </span>            : </a>
<a name="2916"><span class="lineNum">    2916 </span><span class="lineCov">     230808 :           if (typeList != NULL)</span></a>
<a name="2917"><span class="lineNum">    2917 </span>            :              {</a>
<a name="2918"><span class="lineNum">    2918 </span>            :             // DQ (12/5/2012): We want to avoid overwriting an existing SgFunctionParameterTypeList. Could be related to failing tests for AST File I/O.</a>
<a name="2919"><span class="lineNum">    2919 </span><span class="lineCov">     230808 :                if (funcType-&gt;get_argument_list() != NULL)</span></a>
<a name="2920"><span class="lineNum">    2920 </span>            :                   {</a>
<a name="2921"><span class="lineNum">    2921 </span><span class="lineCov">     230808 :                     delete funcType-&gt;get_argument_list();</span></a>
<a name="2922"><span class="lineNum">    2922 </span><span class="lineCov">     230808 :                     funcType-&gt;set_argument_list(NULL);</span></a>
<a name="2923"><span class="lineNum">    2923 </span>            :                   }</a>
<a name="2924"><span class="lineNum">    2924 </span><span class="lineCov">     230808 :                ROSE_ASSERT(funcType-&gt;get_argument_list() == NULL);</span></a>
<a name="2925"><span class="lineNum">    2925 </span>            : </a>
<a name="2926"><span class="lineNum">    2926 </span><span class="lineCov">     230808 :                funcType-&gt;set_argument_list(typeList);</span></a>
<a name="2927"><span class="lineNum">    2927 </span><span class="lineCov">     230808 :                typeList-&gt;set_parent(funcType);</span></a>
<a name="2928"><span class="lineNum">    2928 </span>            :              }</a>
<a name="2929"><span class="lineNum">    2929 </span>            : </a>
<a name="2930"><span class="lineNum">    2930 </span>            : #if 0</a>
<a name="2931"><span class="lineNum">    2931 </span>            :           printf (&quot;Inserting function type = %s into function type table with type = %p \n&quot;,typeName.str(),funcType);</a>
<a name="2932"><span class="lineNum">    2932 </span>            : #endif</a>
<a name="2933"><span class="lineNum">    2933 </span>            : </a>
<a name="2934"><span class="lineNum">    2934 </span><span class="lineCov">     230808 :           fTable-&gt;insert_function_type(typeName,funcType);</span></a>
<a name="2935"><span class="lineNum">    2935 </span>            :         }</a>
<a name="2936"><span class="lineNum">    2936 </span>            :        else</a>
<a name="2937"><span class="lineNum">    2937 </span>            :         {</a>
<a name="2938"><span class="lineNum">    2938 </span>            :        // DQ (12/6/2012): Tracking down orphaned SgFunctionParameterTypeList objects.</a>
<a name="2939"><span class="lineNum">    2939 </span>            : #if 0</a>
<a name="2940"><span class="lineNum">    2940 </span>            :           printf (&quot;In SageBuilder::buildFunctionType(): Note that the SgFunctionParameterTypeList* typeList = %p was not used (so should be deleted by which ever calling function allocated it) \n&quot;,typeList);</a>
<a name="2941"><span class="lineNum">    2941 </span>            : #endif</a>
<a name="2942"><span class="lineNum">    2942 </span>            :         }</a>
<a name="2943"><span class="lineNum">    2943 </span>            : </a>
<a name="2944"><span class="lineNum">    2944 </span>            : #if 0</a>
<a name="2945"><span class="lineNum">    2945 </span>            :      printf (&quot;Leaving buildFunctionType(): Returning function type = %p \n&quot;,funcType);</a>
<a name="2946"><span class="lineNum">    2946 </span>            : #endif</a>
<a name="2947"><span class="lineNum">    2947 </span>            : </a>
<a name="2948"><span class="lineNum">    2948 </span><span class="lineCov">    2284540 :      return funcType;</span></a>
<a name="2949"><span class="lineNum">    2949 </span>            :    }</a>
<a name="2950"><span class="lineNum">    2950 </span>            : </a>
<a name="2951"><span class="lineNum">    2951 </span>            : </a>
<a name="2952"><span class="lineNum">    2952 </span>            : </a>
<a name="2953"><span class="lineNum">    2953 </span>            : SgMemberFunctionType*</a>
<a name="2954"><span class="lineNum">    2954 </span><span class="lineCov">      39463 : SageBuilder::buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList, SgType *classType, unsigned int mfunc_specifier, unsigned int ref_qualifiers)</span></a>
<a name="2955"><span class="lineNum">    2955 </span>            :    {</a>
<a name="2956"><span class="lineNum">    2956 </span>            :   // DQ (8/19/2012): This is a refactored version of the buildMemberFunctionType() below so that we can</a>
<a name="2957"><span class="lineNum">    2957 </span>            :   // isolate out the part that uses a SgClassType from the version that uses the SgClassDefinition.</a>
<a name="2958"><span class="lineNum">    2958 </span>            : </a>
<a name="2959"><span class="lineNum">    2959 </span>            :   // Maintain the global type table</a>
<a name="2960"><span class="lineNum">    2960 </span><span class="lineCov">      39463 :      SgFunctionTypeTable* fTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="2961"><span class="lineNum">    2961 </span><span class="lineCov">      39463 :      ROSE_ASSERT(fTable != NULL);</span></a>
<a name="2962"><span class="lineNum">    2962 </span>            : </a>
<a name="2963"><span class="lineNum">    2963 </span>            :   // DQ (12/6/2012): Added assertion.</a>
<a name="2964"><span class="lineNum">    2964 </span>            :   // ROSE_ASSERT(classType != NULL);</a>
<a name="2965"><span class="lineNum">    2965 </span>            : </a>
<a name="2966"><span class="lineNum">    2966 </span>            :   // DQ (12/13/2012): Added assertion.</a>
<a name="2967"><span class="lineNum">    2967 </span><span class="lineCov">      39463 :      ROSE_ASSERT(typeList != NULL);</span></a>
<a name="2968"><span class="lineNum">    2968 </span>            : </a>
<a name="2969"><span class="lineNum">    2969 </span>            :   // DQ (12/6/2012): Newer simpler code (using static function SgMemberFunctionType::get_mangled()).</a>
<a name="2970"><span class="lineNum">    2970 </span><span class="lineCov">      39463 :      SgName                typeName    = SgMemberFunctionType::get_mangled(return_type,typeList,classType,mfunc_specifier);</span></a>
<a name="2971"><span class="lineNum">    2971 </span><span class="lineCov">      39463 :      SgType*               typeInTable = fTable-&gt;lookup_function_type(typeName);</span></a>
<a name="2972"><span class="lineNum">    2972 </span>            : </a>
<a name="2973"><span class="lineNum">    2973 </span>            : #if 0</a>
<a name="2974"><span class="lineNum">    2974 </span>            :      printf (&quot;In buildMemberFunctionType(SgType*,SgFunctionParameterTypeList*,SgType*,int,int): fTable-&gt;lookup_function_type(typeName = %s) = %p \n&quot;,typeName.str(),typeInTable);</a>
<a name="2975"><span class="lineNum">    2975 </span>            :      printf (&quot; --- mfunc_specifier = %d ref_qualifiers = %d \n&quot;,mfunc_specifier,ref_qualifiers);</a>
<a name="2976"><span class="lineNum">    2976 </span>            : #endif</a>
<a name="2977"><span class="lineNum">    2977 </span>            : </a>
<a name="2978"><span class="lineNum">    2978 </span>            : #if 1</a>
<a name="2979"><span class="lineNum">    2979 </span>            :   // DQ (1/10/2020): I think that these qualifiers are contained in the mfunc_specifier.</a>
<a name="2980"><span class="lineNum">    2980 </span><span class="lineCov">      39463 :      if (ref_qualifiers &gt; 0)</span></a>
<a name="2981"><span class="lineNum">    2981 </span>            :         {</a>
<a name="2982"><span class="lineNum">    2982 </span><span class="lineNoCov">          0 :           printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="2983"><span class="lineNum">    2983 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="2984"><span class="lineNum">    2984 </span>            :         }</a>
<a name="2985"><span class="lineNum">    2985 </span>            : #endif</a>
<a name="2986"><span class="lineNum">    2986 </span>            : </a>
<a name="2987"><span class="lineNum">    2987 </span><span class="lineCov">      39463 :      SgMemberFunctionType* funcType = NULL;</span></a>
<a name="2988"><span class="lineNum">    2988 </span><span class="lineCov">      39463 :      if (typeInTable == NULL)</span></a>
<a name="2989"><span class="lineNum">    2989 </span>            :         {</a>
<a name="2990"><span class="lineNum">    2990 </span><span class="lineCov">      19092 :           bool has_ellipses = false;</span></a>
<a name="2991"><span class="lineNum">    2991 </span><span class="lineCov">      19092 :           SgPartialFunctionType* partialFunctionType = new SgPartialFunctionType(return_type, has_ellipses, classType, mfunc_specifier, ref_qualifiers);</span></a>
<a name="2992"><span class="lineNum">    2992 </span><span class="lineCov">      19092 :           ROSE_ASSERT(partialFunctionType != NULL);</span></a>
<a name="2993"><span class="lineNum">    2993 </span>            : #if 0</a>
<a name="2994"><span class="lineNum">    2994 </span>            :           printf (&quot;Building a SgPartialFunctionType: partialFunctionType = %p \n&quot;,partialFunctionType);</a>
<a name="2995"><span class="lineNum">    2995 </span>            :           printf (&quot; --- partialFunctionType-&gt;isLvalueReferenceFunc() = %s \n&quot;,partialFunctionType-&gt;isLvalueReferenceFunc() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2996"><span class="lineNum">    2996 </span>            :           printf (&quot; --- partialFunctionType-&gt;isRvalueReferenceFunc() = %s \n&quot;,partialFunctionType-&gt;isRvalueReferenceFunc() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2997"><span class="lineNum">    2997 </span>            : #endif</a>
<a name="2998"><span class="lineNum">    2998 </span>            :        // DQ (12/5/2012): We want to avoid overwriting an existing SgFunctionParameterTypeList. Could be related to failing tests for AST File I/O.</a>
<a name="2999"><span class="lineNum">    2999 </span><span class="lineCov">      19092 :           if (partialFunctionType-&gt;get_argument_list() != NULL)</span></a>
<a name="3000"><span class="lineNum">    3000 </span>            :              {</a>
<a name="3001"><span class="lineNum">    3001 </span><span class="lineCov">      19092 :                delete partialFunctionType-&gt;get_argument_list();</span></a>
<a name="3002"><span class="lineNum">    3002 </span><span class="lineCov">      19092 :                partialFunctionType-&gt;set_argument_list(NULL);</span></a>
<a name="3003"><span class="lineNum">    3003 </span>            :              }</a>
<a name="3004"><span class="lineNum">    3004 </span><span class="lineCov">      19092 :           ROSE_ASSERT(partialFunctionType-&gt;get_argument_list() == NULL);</span></a>
<a name="3005"><span class="lineNum">    3005 </span>            : </a>
<a name="3006"><span class="lineNum">    3006 </span><span class="lineCov">      19092 :           typeList-&gt;set_parent(partialFunctionType);</span></a>
<a name="3007"><span class="lineNum">    3007 </span>            : </a>
<a name="3008"><span class="lineNum">    3008 </span>            :        // DQ (12/6/2012): Set the SgFunctionParameterTypeList in the SgPartialFunctionType before trying</a>
<a name="3009"><span class="lineNum">    3009 </span>            :        // to build a SgMemberFunctionType (not critical that it be set before, but might be in the future,</a>
<a name="3010"><span class="lineNum">    3010 </span>            :        // but it is important that it be set).</a>
<a name="3011"><span class="lineNum">    3011 </span><span class="lineCov">      19092 :           partialFunctionType-&gt;set_argument_list(typeList);</span></a>
<a name="3012"><span class="lineNum">    3012 </span>            : </a>
<a name="3013"><span class="lineNum">    3013 </span><span class="lineCov">      19092 :           ROSE_ASSERT(partialFunctionType-&gt;get_argument_list() != NULL);</span></a>
<a name="3014"><span class="lineNum">    3014 </span>            : </a>
<a name="3015"><span class="lineNum">    3015 </span>            :        // The optional_fortran_type_kind is only required for Fortran support.</a>
<a name="3016"><span class="lineNum">    3016 </span><span class="lineCov">      19092 :           SgExpression* optional_fortran_type_kind = NULL;</span></a>
<a name="3017"><span class="lineNum">    3017 </span><span class="lineCov">      19092 :           funcType = SgMemberFunctionType::createType(partialFunctionType, optional_fortran_type_kind);</span></a>
<a name="3018"><span class="lineNum">    3018 </span>            : </a>
<a name="3019"><span class="lineNum">    3019 </span>            :        // DQ (12/13/2012): Remove the SgPartialFunctionType after it has been used to build the SgMemberFunctionType.</a>
<a name="3020"><span class="lineNum">    3020 </span>            :        // I would rather modify the SgMemberFunctionType::createType() API so that we didn't use the SgPartialFunctionType IR nodes.</a>
<a name="3021"><span class="lineNum">    3021 </span>            :        // First we have to reset the pointer to the type argument list to NULL since it is shared with the SgMemberFunctionType.</a>
<a name="3022"><span class="lineNum">    3022 </span><span class="lineCov">      19092 :           partialFunctionType-&gt;set_argument_list(NULL);</span></a>
<a name="3023"><span class="lineNum">    3023 </span>            : </a>
<a name="3024"><span class="lineNum">    3024 </span>            :        // Then we can delete the SgPartialFunctionType.</a>
<a name="3025"><span class="lineNum">    3025 </span><span class="lineCov">      19092 :           delete partialFunctionType;</span></a>
<a name="3026"><span class="lineNum">    3026 </span><span class="lineCov">      19092 :           partialFunctionType = NULL;</span></a>
<a name="3027"><span class="lineNum">    3027 </span>            : </a>
<a name="3028"><span class="lineNum">    3028 </span>            :        // This is perhaps redundant since it was set to a derived class (but might be an important distiction).</a>
<a name="3029"><span class="lineNum">    3029 </span><span class="lineCov">      19092 :           typeList-&gt;set_parent(funcType);</span></a>
<a name="3030"><span class="lineNum">    3030 </span>            : </a>
<a name="3031"><span class="lineNum">    3031 </span><span class="lineCov">      19092 :           ROSE_ASSERT(funcType-&gt;get_argument_list() != NULL);</span></a>
<a name="3032"><span class="lineNum">    3032 </span>            :         }</a>
<a name="3033"><span class="lineNum">    3033 </span>            : </a>
<a name="3034"><span class="lineNum">    3034 </span>            : #if 0</a>
<a name="3035"><span class="lineNum">    3035 </span>            :      printf (&quot;########### In buildMemberFunctionType(): Looking in global function type table for member function type = %p name = %s typeInTable = %p \n&quot;,funcType,typeName.str(),typeInTable);</a>
<a name="3036"><span class="lineNum">    3036 </span>            : #endif</a>
<a name="3037"><span class="lineNum">    3037 </span>            : </a>
<a name="3038"><span class="lineNum">    3038 </span><span class="lineCov">      39463 :      if (typeInTable == NULL)</span></a>
<a name="3039"><span class="lineNum">    3039 </span>            :         {</a>
<a name="3040"><span class="lineNum">    3040 </span>            : #if 0</a>
<a name="3041"><span class="lineNum">    3041 </span>            :           printf (&quot;########### In buildMemberFunctionType(): Adding funcType = %p = %s to global function type table \n&quot;,funcType,typeName.str());</a>
<a name="3042"><span class="lineNum">    3042 </span>            : #endif</a>
<a name="3043"><span class="lineNum">    3043 </span><span class="lineCov">      19092 :           ROSE_ASSERT(funcType != NULL);</span></a>
<a name="3044"><span class="lineNum">    3044 </span><span class="lineCov">      19092 :           fTable-&gt;insert_function_type(typeName,funcType);</span></a>
<a name="3045"><span class="lineNum">    3045 </span>            :         }</a>
<a name="3046"><span class="lineNum">    3046 </span>            :        else</a>
<a name="3047"><span class="lineNum">    3047 </span>            :         {</a>
<a name="3048"><span class="lineNum">    3048 </span>            :        // DQ (12/3/2011): Added this case to support reuse of function types (not handled by the createType functions).</a>
<a name="3049"><span class="lineNum">    3049 </span>            :        // Delete the one generated so that we could form the mangled name.</a>
<a name="3050"><span class="lineNum">    3050 </span>            : </a>
<a name="3051"><span class="lineNum">    3051 </span>            :        // printf (&quot;Deleting funcType = %p = %s \n&quot;,funcType,funcType-&gt;class_name().c_str());</a>
<a name="3052"><span class="lineNum">    3052 </span>            : </a>
<a name="3053"><span class="lineNum">    3053 </span>            :        // DQ (3/22/2012): Added assertion.</a>
<a name="3054"><span class="lineNum">    3054 </span><span class="lineCov">      20371 :           ROSE_ASSERT(typeInTable != funcType);</span></a>
<a name="3055"><span class="lineNum">    3055 </span>            : </a>
<a name="3056"><span class="lineNum">    3056 </span><span class="lineCov">      20371 :           delete funcType;</span></a>
<a name="3057"><span class="lineNum">    3057 </span><span class="lineCov">      20371 :           funcType = NULL;</span></a>
<a name="3058"><span class="lineNum">    3058 </span>            :        // Return the one from the global type table.</a>
<a name="3059"><span class="lineNum">    3059 </span><span class="lineCov">      20371 :           funcType = isSgMemberFunctionType(typeInTable);</span></a>
<a name="3060"><span class="lineNum">    3060 </span><span class="lineCov">      20371 :           ROSE_ASSERT(funcType != NULL);</span></a>
<a name="3061"><span class="lineNum">    3061 </span>            :         }</a>
<a name="3062"><span class="lineNum">    3062 </span>            : </a>
<a name="3063"><span class="lineNum">    3063 </span>            : #if 0</a>
<a name="3064"><span class="lineNum">    3064 </span>            :      fTable-&gt;get_function_type_table()-&gt;print(&quot;In buildMemberFunctionType(): globalFunctionTypeTable AFTER&quot;);</a>
<a name="3065"><span class="lineNum">    3065 </span>            : #endif</a>
<a name="3066"><span class="lineNum">    3066 </span>            : </a>
<a name="3067"><span class="lineNum">    3067 </span><span class="lineCov">      39463 :      return funcType;</span></a>
<a name="3068"><span class="lineNum">    3068 </span>            :    }</a>
<a name="3069"><span class="lineNum">    3069 </span>            : </a>
<a name="3070"><span class="lineNum">    3070 </span>            : </a>
<a name="3071"><span class="lineNum">    3071 </span>            : // DQ (1/4/2009): Need to finish this!!!</a>
<a name="3072"><span class="lineNum">    3072 </span>            : //-----------------------------------------------</a>
<a name="3073"><span class="lineNum">    3073 </span>            : // build member function type,</a>
<a name="3074"><span class="lineNum">    3074 </span>            : //</a>
<a name="3075"><span class="lineNum">    3075 </span>            : // insert into symbol table when not duplicated</a>
<a name="3076"><span class="lineNum">    3076 </span>            : SgMemberFunctionType*</a>
<a name="3077"><span class="lineNum">    3077 </span><span class="lineCov">      27054 : SageBuilder::buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList, SgScopeStatement * struct_name, unsigned int mfunc_specifier, unsigned int ref_qualifiers)</span></a>
<a name="3078"><span class="lineNum">    3078 </span>            :    {</a>
<a name="3079"><span class="lineNum">    3079 </span>            :   // This function has to first build a version of the SgMemberFunctionType so that it can generate a mangled name.</a>
<a name="3080"><span class="lineNum">    3080 </span>            :   // If the mangled name can be use to lookup a SgMemberFunctionType then the &quot;just built&quot; SgMemberFunctionType</a>
<a name="3081"><span class="lineNum">    3081 </span>            :   // is deleted and the one from the global function type table is returned.  This fixes a lot of subtle C++</a>
<a name="3082"><span class="lineNum">    3082 </span>            :   // specific issues with the build interface and it's use with the newer EDG 4.3 connection to ROSE.</a>
<a name="3083"><span class="lineNum">    3083 </span>            : </a>
<a name="3084"><span class="lineNum">    3084 </span><span class="lineCov">      27054 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="3085"><span class="lineNum">    3085 </span>            : </a>
<a name="3086"><span class="lineNum">    3086 </span>            :   // SgMemberFunctionType (SgType *return_type=NULL, bool has_ellipses=true, SgClassDefinition *struct_name=NULL, unsigned int mfunc_specifier=0)</a>
<a name="3087"><span class="lineNum">    3087 </span>            :   // SgMemberFunctionType * funcType = new SgMemberFunctionType(return_type, false);</a>
<a name="3088"><span class="lineNum">    3088 </span>            : </a>
<a name="3089"><span class="lineNum">    3089 </span><span class="lineCov">      27054 :      ROSE_ASSERT(struct_name != NULL);</span></a>
<a name="3090"><span class="lineNum">    3090 </span>            : </a>
<a name="3091"><span class="lineNum">    3091 </span>            : #if 0</a>
<a name="3092"><span class="lineNum">    3092 </span>            :      printf(&quot;In buildMemberFunctionType():\n&quot;);</a>
<a name="3093"><span class="lineNum">    3093 </span>            :      printf(&quot;  - struct_name = %p (%s)\n&quot;, struct_name, struct_name-&gt;class_name().c_str());</a>
<a name="3094"><span class="lineNum">    3094 </span>            : #endif</a>
<a name="3095"><span class="lineNum">    3095 </span>            : </a>
<a name="3096"><span class="lineNum">    3096 </span>            : #if 0</a>
<a name="3097"><span class="lineNum">    3097 </span>            :   // DQ (1/9/2020): Unclear why this function is not using the ref_qualifiers.</a>
<a name="3098"><span class="lineNum">    3098 </span>            :      printf (&quot;SageBuilder::buildMemberFunctionType(SgType*,SgFunctionParameterTypeList*,SgScopeStatement*,int,int): This function does not use the input ref_qualifiers = %x \n&quot;,ref_qualifiers);</a>
<a name="3099"><span class="lineNum">    3099 </span>            :      printf (&quot; --- mfunc_specifier = %d ref_qualifiers = %d \n&quot;,mfunc_specifier,ref_qualifiers);</a>
<a name="3100"><span class="lineNum">    3100 </span>            : #endif</a>
<a name="3101"><span class="lineNum">    3101 </span>            : </a>
<a name="3102"><span class="lineNum">    3102 </span>            : #if 1</a>
<a name="3103"><span class="lineNum">    3103 </span><span class="lineCov">      27054 :      if (ref_qualifiers &gt; 0)</span></a>
<a name="3104"><span class="lineNum">    3104 </span>            :        {</a>
<a name="3105"><span class="lineNum">    3105 </span><span class="lineNoCov">          0 :           printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="3106"><span class="lineNum">    3106 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="3107"><span class="lineNum">    3107 </span>            :        }</a>
<a name="3108"><span class="lineNum">    3108 </span>            : #endif</a>
<a name="3109"><span class="lineNum">    3109 </span>            : </a>
<a name="3110"><span class="lineNum">    3110 </span>            : #if 0</a>
<a name="3111"><span class="lineNum">    3111 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3112"><span class="lineNum">    3112 </span>            :      ROSE_ABORT();</a>
<a name="3113"><span class="lineNum">    3113 </span>            : #endif</a>
<a name="3114"><span class="lineNum">    3114 </span>            : </a>
<a name="3115"><span class="lineNum">    3115 </span><span class="lineCov">      27054 :      ROSE_ASSERT(struct_name-&gt;get_parent() != NULL);</span></a>
<a name="3116"><span class="lineNum">    3116 </span>            :   // ROSE_ASSERT(struct_name-&gt;get_declaration() != NULL);</a>
<a name="3117"><span class="lineNum">    3117 </span>            : </a>
<a name="3118"><span class="lineNum">    3118 </span>            : #if 0</a>
<a name="3119"><span class="lineNum">    3119 </span>            :      printf(&quot;struct_name = %p ( %s )\n&quot;, struct_name, struct_name-&gt;class_name().c_str());</a>
<a name="3120"><span class="lineNum">    3120 </span>            : #endif</a>
<a name="3121"><span class="lineNum">    3121 </span>            : </a>
<a name="3122"><span class="lineNum">    3122 </span>            :   // SgDeclarationStatement* declaration = struct_name-&gt;get_declaration();</a>
<a name="3123"><span class="lineNum">    3123 </span><span class="lineCov">      27054 :      SgClassDefinition*  classDefinition = isSgClassDefinition(struct_name);</span></a>
<a name="3124"><span class="lineNum">    3124 </span><span class="lineCov">      27054 :      SgDeclarationScope* decl_scope      = isSgDeclarationScope(struct_name);</span></a>
<a name="3125"><span class="lineNum">    3125 </span>            : </a>
<a name="3126"><span class="lineNum">    3126 </span><span class="lineCov">      27054 :      if (classDefinition == NULL &amp;&amp; decl_scope == NULL)</span></a>
<a name="3127"><span class="lineNum">    3127 </span>            :         {</a>
<a name="3128"><span class="lineNum">    3128 </span><span class="lineNoCov">          0 :           printf (&quot;Error: (classDefinition == NULL &amp;&amp; decl_scope == NULL): struct_name = %p = %s name = %s \n&quot;,</span></a>
<a name="3129"><span class="lineNum">    3129 </span><span class="lineNoCov">          0 :                   struct_name,struct_name-&gt;class_name().c_str(),SageInterface::get_name(struct_name).c_str());</span></a>
<a name="3130"><span class="lineNum">    3130 </span>            :         }</a>
<a name="3131"><span class="lineNum">    3131 </span><span class="lineCov">      27054 :      ROSE_ASSERT(classDefinition != NULL || decl_scope != NULL);</span></a>
<a name="3132"><span class="lineNum">    3132 </span>            : </a>
<a name="3133"><span class="lineNum">    3133 </span><span class="lineCov">      27054 :      SgDeclarationStatement* declaration = NULL;</span></a>
<a name="3134"><span class="lineNum">    3134 </span><span class="lineCov">      27054 :      if (classDefinition != NULL)</span></a>
<a name="3135"><span class="lineNum">    3135 </span>            :         {</a>
<a name="3136"><span class="lineNum">    3136 </span><span class="lineCov">      25861 :           declaration = classDefinition-&gt;get_declaration();</span></a>
<a name="3137"><span class="lineNum">    3137 </span>            :         }</a>
<a name="3138"><span class="lineNum">    3138 </span><span class="lineCov">       1193 :        else if (decl_scope != NULL)</span></a>
<a name="3139"><span class="lineNum">    3139 </span>            :         {</a>
<a name="3140"><span class="lineNum">    3140 </span><span class="lineCov">       1193 :           declaration = isSgDeclarationStatement(decl_scope-&gt;get_parent());</span></a>
<a name="3141"><span class="lineNum">    3141 </span>            :         }</a>
<a name="3142"><span class="lineNum">    3142 </span>            :        else</a>
<a name="3143"><span class="lineNum">    3143 </span>            :         {</a>
<a name="3144"><span class="lineNum">    3144 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="3145"><span class="lineNum">    3145 </span>            :         }</a>
<a name="3146"><span class="lineNum">    3146 </span>            : </a>
<a name="3147"><span class="lineNum">    3147 </span><span class="lineCov">      27054 :      ROSE_ASSERT(declaration != NULL);</span></a>
<a name="3148"><span class="lineNum">    3148 </span>            : </a>
<a name="3149"><span class="lineNum">    3149 </span><span class="lineCov">      27054 :      if (typeList != NULL)</span></a>
<a name="3150"><span class="lineNum">    3150 </span>            :         {</a>
<a name="3151"><span class="lineNum">    3151 </span>            : #if 0</a>
<a name="3152"><span class="lineNum">    3152 </span>            :           SgTypePtrList &amp; typeListArgs = typeList-&gt;get_arguments();</a>
<a name="3153"><span class="lineNum">    3153 </span>            :           for (SgTypePtrList::iterator i = typeListArgs.begin(); i != typeListArgs.end(); i++)</a>
<a name="3154"><span class="lineNum">    3154 </span>            :              {</a>
<a name="3155"><span class="lineNum">    3155 </span>            :                printf (&quot;   --- type argument = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="3156"><span class="lineNum">    3156 </span>            :              }</a>
<a name="3157"><span class="lineNum">    3157 </span>            : #endif</a>
<a name="3158"><span class="lineNum">    3158 </span>            :         }</a>
<a name="3159"><span class="lineNum">    3159 </span>            :        else</a>
<a name="3160"><span class="lineNum">    3160 </span>            :         {</a>
<a name="3161"><span class="lineNum">    3161 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: typeList == NULL \n&quot;);</span></a>
<a name="3162"><span class="lineNum">    3162 </span>            :         }</a>
<a name="3163"><span class="lineNum">    3163 </span>            : </a>
<a name="3164"><span class="lineNum">    3164 </span><span class="lineCov">      27054 :      SgClassDeclaration*         classDeclaration         = isSgClassDeclaration(declaration);</span></a>
<a name="3165"><span class="lineNum">    3165 </span>            :   // SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(declaration);</a>
<a name="3166"><span class="lineNum">    3166 </span><span class="lineCov">      27054 :      SgNonrealDecl *             nrdecl                   = isSgNonrealDecl(declaration);</span></a>
<a name="3167"><span class="lineNum">    3167 </span>            : </a>
<a name="3168"><span class="lineNum">    3168 </span><span class="lineCov">      27054 :      ROSE_ASSERT(classDeclaration != NULL || nrdecl != NULL);</span></a>
<a name="3169"><span class="lineNum">    3169 </span>            : </a>
<a name="3170"><span class="lineNum">    3170 </span><span class="lineCov">      27054 :      SgMemberFunctionType* funcType = NULL;</span></a>
<a name="3171"><span class="lineNum">    3171 </span>            : </a>
<a name="3172"><span class="lineNum">    3172 </span>            :   // DQ (12/4/2011): Modified SgClassType to support template declarations (SgTemplateClassDeclaration now contains a type set to SgClassType.</a>
<a name="3173"><span class="lineNum">    3173 </span>            :   // The SgClassType has been modified (browdened) to support a SgDeclarationStatement instead of a SgClassDeclaration.</a>
<a name="3174"><span class="lineNum">    3174 </span>            :   // SgClassType* classType = classDeclaration-&gt;get_type();</a>
<a name="3175"><span class="lineNum">    3175 </span><span class="lineCov">      27054 :      SgType* classType = NULL;</span></a>
<a name="3176"><span class="lineNum">    3176 </span><span class="lineCov">      27054 :      if (classDeclaration != NULL)</span></a>
<a name="3177"><span class="lineNum">    3177 </span>            :         {</a>
<a name="3178"><span class="lineNum">    3178 </span><span class="lineCov">      26949 :           classType = classDeclaration-&gt;get_type();</span></a>
<a name="3179"><span class="lineNum">    3179 </span>            :         }</a>
<a name="3180"><span class="lineNum">    3180 </span><span class="lineCov">        105 :        else if (decl_scope != NULL)</span></a>
<a name="3181"><span class="lineNum">    3181 </span>            :         {</a>
<a name="3182"><span class="lineNum">    3182 </span><span class="lineCov">        105 :           classType = nrdecl-&gt;get_type();</span></a>
<a name="3183"><span class="lineNum">    3183 </span>            :         }</a>
<a name="3184"><span class="lineNum">    3184 </span>            :        else</a>
<a name="3185"><span class="lineNum">    3185 </span>            :         {</a>
<a name="3186"><span class="lineNum">    3186 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="3187"><span class="lineNum">    3187 </span>            :         }</a>
<a name="3188"><span class="lineNum">    3188 </span>            : </a>
<a name="3189"><span class="lineNum">    3189 </span><span class="lineCov">      27054 :      ROSE_ASSERT(classType != NULL);</span></a>
<a name="3190"><span class="lineNum">    3190 </span>            : </a>
<a name="3191"><span class="lineNum">    3191 </span>            : #if 0</a>
<a name="3192"><span class="lineNum">    3192 </span>            :      printf (&quot;In buildMemberFunctionType(): Calling refactored function: buildMemberFunctionType(...,classType = %p,...) \n&quot;,classType);</a>
<a name="3193"><span class="lineNum">    3193 </span>            : #endif</a>
<a name="3194"><span class="lineNum">    3194 </span>            : </a>
<a name="3195"><span class="lineNum">    3195 </span>            :   // DQ (8/19/2012): This code has been refactored.</a>
<a name="3196"><span class="lineNum">    3196 </span><span class="lineCov">      27054 :      funcType = buildMemberFunctionType(return_type,typeList,classType,mfunc_specifier);</span></a>
<a name="3197"><span class="lineNum">    3197 </span>            : </a>
<a name="3198"><span class="lineNum">    3198 </span>            : #if 0</a>
<a name="3199"><span class="lineNum">    3199 </span>            :      printf (&quot;In buildMemberFunctionType(): DONE: Calling refactored function: buildMemberFunctionType(...,classType = %p,...) \n&quot;,classType);</a>
<a name="3200"><span class="lineNum">    3200 </span>            : #endif</a>
<a name="3201"><span class="lineNum">    3201 </span>            : </a>
<a name="3202"><span class="lineNum">    3202 </span><span class="lineCov">      27054 :      return funcType;</span></a>
<a name="3203"><span class="lineNum">    3203 </span>            :    }</a>
<a name="3204"><span class="lineNum">    3204 </span>            : </a>
<a name="3205"><span class="lineNum">    3205 </span>            : </a>
<a name="3206"><span class="lineNum">    3206 </span>            : //----------------------------------------------------</a>
<a name="3207"><span class="lineNum">    3207 </span>            : //! Build an opaque type with a name, useful when a type's details are unknown during transformation, especially for a runtime library's internal type.</a>
<a name="3208"><span class="lineNum">    3208 </span><span class="lineNoCov">          0 : SgType * SageBuilder::buildOpaqueType(std::string const name, SgScopeStatement * scope)</span></a>
<a name="3209"><span class="lineNum">    3209 </span>            : {</a>
<a name="3210"><span class="lineNum">    3210 </span>            :   // we require users to specify a target scope</a>
<a name="3211"><span class="lineNum">    3211 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(scope);</span></a>
<a name="3212"><span class="lineNum">    3212 </span><span class="lineNoCov">          0 :   SgTypedefDeclaration* type_decl = NULL;</span></a>
<a name="3213"><span class="lineNum">    3213 </span><span class="lineNoCov">          0 :   SgTypedefType* result = NULL;</span></a>
<a name="3214"><span class="lineNum">    3214 </span>            : </a>
<a name="3215"><span class="lineNum">    3215 </span>            :   // Liao and Greg Bronevetsky , 8/27/2009</a>
<a name="3216"><span class="lineNum">    3216 </span>            :   // patch up the symbol</a>
<a name="3217"><span class="lineNum">    3217 </span>            :   // and avoid duplicated creation</a>
<a name="3218"><span class="lineNum">    3218 </span>            :   // TODO  a function like fixTypeDeclaration() (similar to SageInterface::fixVariableDeclaration()) for this</a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineNoCov">          0 :   SgTypedefSymbol* type_symbol = scope-&gt;lookup_typedef_symbol(name);</span></a>
<a name="3220"><span class="lineNum">    3220 </span><span class="lineNoCov">          0 :   if (type_symbol == NULL)</span></a>
<a name="3221"><span class="lineNum">    3221 </span>            :   {</a>
<a name="3222"><span class="lineNum">    3222 </span><span class="lineNoCov">          0 :     type_decl =  new SgTypedefDeclaration(name,buildIntType(),NULL, NULL, NULL);</span></a>
<a name="3223"><span class="lineNum">    3223 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(type_decl);</span></a>
<a name="3224"><span class="lineNum">    3224 </span>            : </a>
<a name="3225"><span class="lineNum">    3225 </span>            : #if 0</a>
<a name="3226"><span class="lineNum">    3226 </span>            :      printf (&quot;In SageBuilder::buildOpaqueType(): calling SgTypedefType::createType() using this = %p = %s \n&quot;,type_decl,type_decl-&gt;class_name().c_str());</a>
<a name="3227"><span class="lineNum">    3227 </span>            : #endif</a>
<a name="3228"><span class="lineNum">    3228 </span>            : </a>
<a name="3229"><span class="lineNum">    3229 </span>            :   // DQ (2/27/2018): Add this call here to reflect change to the constructor semantics.</a>
<a name="3230"><span class="lineNum">    3230 </span><span class="lineNoCov">          0 :      type_decl-&gt;set_type(SgTypedefType::createType(type_decl));</span></a>
<a name="3231"><span class="lineNum">    3231 </span>            : </a>
<a name="3232"><span class="lineNum">    3232 </span>            : #if 0</a>
<a name="3233"><span class="lineNum">    3233 </span>            :      printf (&quot;In SageBuilder::buildOpaqueType(): DONE calling SgTypedefType::createType() using this = %p = %s \n&quot;,type_decl,type_decl-&gt;class_name().c_str());</a>
<a name="3234"><span class="lineNum">    3234 </span>            : #endif</a>
<a name="3235"><span class="lineNum">    3235 </span>            : </a>
<a name="3236"><span class="lineNum">    3236 </span>            : #if 0</a>
<a name="3237"><span class="lineNum">    3237 </span>            :  // DQ (3/28/2018): Commented out sinnce this fails for the documentation generation step in ROSE.</a>
<a name="3238"><span class="lineNum">    3238 </span>            :  // DQ (2/27/2018): The constructor semantics now require the type to be built after the IR node has been built.</a>
<a name="3239"><span class="lineNum">    3239 </span>            :  // Make this fail so that we can detect it an fix it properly later.</a>
<a name="3240"><span class="lineNum">    3240 </span>            :     printf (&quot;In SageBuilder::buildOpaqueType(): ERROR: The constructor semantics now require the type to be built after the IR node has been built \n&quot;);</a>
<a name="3241"><span class="lineNum">    3241 </span>            :     ROSE_ABORT();</a>
<a name="3242"><span class="lineNum">    3242 </span>            : #endif</a>
<a name="3243"><span class="lineNum">    3243 </span>            : </a>
<a name="3244"><span class="lineNum">    3244 </span><span class="lineNoCov">          0 :     type_symbol = new SgTypedefSymbol(type_decl);</span></a>
<a name="3245"><span class="lineNum">    3245 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(type_symbol);</span></a>
<a name="3246"><span class="lineNum">    3246 </span><span class="lineNoCov">          0 :     SgName n = name;</span></a>
<a name="3247"><span class="lineNum">    3247 </span>            : </a>
<a name="3248"><span class="lineNum">    3248 </span>            :  // DQ (5/21/2013): The symbol table should only be accessed through the SgScopeStatement interface.</a>
<a name="3249"><span class="lineNum">    3249 </span>            :  // scope-&gt;get_symbol_table()-&gt;insert(n, type_symbol);</a>
<a name="3250"><span class="lineNum">    3250 </span><span class="lineNoCov">          0 :     scope-&gt;insert_symbol(n,type_symbol);</span></a>
<a name="3251"><span class="lineNum">    3251 </span>            : </a>
<a name="3252"><span class="lineNum">    3252 </span><span class="lineNoCov">          0 :     type_decl-&gt;set_firstNondefiningDeclaration (type_decl);</span></a>
<a name="3253"><span class="lineNum">    3253 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(type_decl);</span></a>
<a name="3254"><span class="lineNum">    3254 </span><span class="lineNoCov">          0 :     prependStatement(type_decl,scope);</span></a>
<a name="3255"><span class="lineNum">    3255 </span>            :     // Hide it from unparser</a>
<a name="3256"><span class="lineNum">    3256 </span><span class="lineNoCov">          0 :     Sg_File_Info* file_info = type_decl-&gt;get_file_info();</span></a>
<a name="3257"><span class="lineNum">    3257 </span><span class="lineNoCov">          0 :     file_info-&gt;unsetOutputInCodeGeneration ();</span></a>
<a name="3258"><span class="lineNum">    3258 </span><span class="lineNoCov">          0 :     result = new SgTypedefType(type_decl);</span></a>
<a name="3259"><span class="lineNum">    3259 </span>            :   }</a>
<a name="3260"><span class="lineNum">    3260 </span>            :   else</a>
<a name="3261"><span class="lineNum">    3261 </span>            :   {</a>
<a name="3262"><span class="lineNum">    3262 </span><span class="lineNoCov">          0 :     type_decl = type_symbol-&gt;get_declaration();</span></a>
<a name="3263"><span class="lineNum">    3263 </span><span class="lineNoCov">          0 :     result = type_decl-&gt;get_type();</span></a>
<a name="3264"><span class="lineNum">    3264 </span>            :   }</a>
<a name="3265"><span class="lineNum">    3265 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="3266"><span class="lineNum">    3266 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="3267"><span class="lineNum">    3267 </span>            : }</a>
<a name="3268"><span class="lineNum">    3268 </span>            : </a>
<a name="3269"><span class="lineNum">    3269 </span>            : </a>
<a name="3270"><span class="lineNum">    3270 </span>            : //----------------- function type------------</a>
<a name="3271"><span class="lineNum">    3271 </span>            : // same function declarations (defining or nondefining) should share the same function type!</a>
<a name="3272"><span class="lineNum">    3272 </span>            : SgFunctionType*</a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineCov">    1134160 : SageBuilder::buildFunctionType(SgType* return_type, SgFunctionParameterList * argList)</span></a>
<a name="3274"><span class="lineNum">    3274 </span>            :    {</a>
<a name="3275"><span class="lineNum">    3275 </span>            : #if 0</a>
<a name="3276"><span class="lineNum">    3276 </span>            :      printf (&quot;Inside of SageBuilder::buildFunctionType(SgType,SgFunctionParameterList) \n&quot;);</a>
<a name="3277"><span class="lineNum">    3277 </span>            : #endif</a>
<a name="3278"><span class="lineNum">    3278 </span>            : </a>
<a name="3279"><span class="lineNum">    3279 </span>            :   // DQ (8/19/2012): Can we assert this?</a>
<a name="3280"><span class="lineNum">    3280 </span><span class="lineCov">    1134160 :      ROSE_ASSERT(argList != NULL);</span></a>
<a name="3281"><span class="lineNum">    3281 </span>            : </a>
<a name="3282"><span class="lineNum">    3282 </span><span class="lineCov">    1134160 :      SgFunctionParameterTypeList* typeList  = buildFunctionParameterTypeList(argList);</span></a>
<a name="3283"><span class="lineNum">    3283 </span>            : </a>
<a name="3284"><span class="lineNum">    3284 </span>            :   // DQ (8/19/2012): Can we assert this?</a>
<a name="3285"><span class="lineNum">    3285 </span><span class="lineCov">    1134160 :      ROSE_ASSERT(typeList != NULL);</span></a>
<a name="3286"><span class="lineNum">    3286 </span>            : </a>
<a name="3287"><span class="lineNum">    3287 </span><span class="lineCov">    1134160 :      SgFunctionType* func_type = buildFunctionType(return_type, typeList);</span></a>
<a name="3288"><span class="lineNum">    3288 </span>            : </a>
<a name="3289"><span class="lineNum">    3289 </span><span class="lineCov">    1134160 :      if (func_type-&gt;get_argument_list() != typeList)</span></a>
<a name="3290"><span class="lineNum">    3290 </span>            :         {</a>
<a name="3291"><span class="lineNum">    3291 </span>            : #if 0</a>
<a name="3292"><span class="lineNum">    3292 </span>            :           printf (&quot;WARNING: the generated SgFunctionParameterTypeList* typeList = %p was not used and should be deleted \n&quot;,typeList);</a>
<a name="3293"><span class="lineNum">    3293 </span>            : #endif</a>
<a name="3294"><span class="lineNum">    3294 </span><span class="lineCov">     916329 :           delete typeList;</span></a>
<a name="3295"><span class="lineNum">    3295 </span><span class="lineCov">     916329 :           typeList = NULL;</span></a>
<a name="3296"><span class="lineNum">    3296 </span>            :         }</a>
<a name="3297"><span class="lineNum">    3297 </span>            : </a>
<a name="3298"><span class="lineNum">    3298 </span><span class="lineCov">    1134160 :      return func_type;</span></a>
<a name="3299"><span class="lineNum">    3299 </span>            :    }</a>
<a name="3300"><span class="lineNum">    3300 </span>            : </a>
<a name="3301"><span class="lineNum">    3301 </span>            : void</a>
<a name="3302"><span class="lineNum">    3302 </span><span class="lineCov">    1180450 : checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope ( SgDeclarationStatement* func, SgScopeStatement* scope )</span></a>
<a name="3303"><span class="lineNum">    3303 </span>            :    {</a>
<a name="3304"><span class="lineNum">    3304 </span>            :   // DQ (12/14/2011): We need the parent to be set so that we can call some of the test functions</a>
<a name="3305"><span class="lineNum">    3305 </span>            :   // (e.g assert that get_class_scope() for member functions).  So we set the parent to the scope</a>
<a name="3306"><span class="lineNum">    3306 </span>            :   // by default and see if this will work, else we could disable to assertion that the parent is</a>
<a name="3307"><span class="lineNum">    3307 </span>            :   // non-null in the get_class_scope() member function.</a>
<a name="3308"><span class="lineNum">    3308 </span>            : </a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">    1180450 :      if (isSgMemberFunctionDeclaration(func) != NULL)</span></a>
<a name="3310"><span class="lineNum">    3310 </span>            :         {</a>
<a name="3311"><span class="lineNum">    3311 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="3312"><span class="lineNum">    3312 </span>            :           printf (&quot;WARNING: setting parent of function to match scope by default \n&quot;);</a>
<a name="3313"><span class="lineNum">    3313 </span>            : #endif</a>
<a name="3314"><span class="lineNum">    3314 </span><span class="lineCov">      39274 :           func-&gt;set_parent(scope);</span></a>
<a name="3315"><span class="lineNum">    3315 </span>            : </a>
<a name="3316"><span class="lineNum">    3316 </span><span class="lineCov">      39274 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="3317"><span class="lineNum">    3317 </span>            : </a>
<a name="3318"><span class="lineNum">    3318 </span><span class="lineCov">      39274 :           if (isSgTemplateInstantiationMemberFunctionDecl(func) != NULL)</span></a>
<a name="3319"><span class="lineNum">    3319 </span>            :              {</a>
<a name="3320"><span class="lineNum">    3320 </span>            :             // DQ (12/14/2011): We should not have a member function template instantiation in a template class definition.</a>
<a name="3321"><span class="lineNum">    3321 </span>            : #if 0</a>
<a name="3322"><span class="lineNum">    3322 </span>            :             // DQ (8/25/2014): Allow non-template functions in a template class declaration (see test2014_161.C).</a>
<a name="3323"><span class="lineNum">    3323 </span>            :                if (isSgTemplateClassDefinition(scope) != NULL)</a>
<a name="3324"><span class="lineNum">    3324 </span>            :                   {</a>
<a name="3325"><span class="lineNum">    3325 </span>            :                     printf (&quot;In checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(): p-&gt;source_corresp.is_class_member == true: Allow non-template functions in a template class declaration \n&quot;);</a>
<a name="3326"><span class="lineNum">    3326 </span>            :                   }</a>
<a name="3327"><span class="lineNum">    3327 </span>            : #endif</a>
<a name="3328"><span class="lineNum">    3328 </span>            : </a>
<a name="3329"><span class="lineNum">    3329 </span>            :             // DQ (8/25/2014): Un-Commented out to revert to previous working state.</a>
<a name="3330"><span class="lineNum">    3330 </span>            :             // DQ (8/25/2014): Commented out to test new logic at base of isTemplateDeclaration(a_routine_ptr).</a>
<a name="3331"><span class="lineNum">    3331 </span>            :             // DQ (8/25/2014): Un-Commented out to revert to previous working state.</a>
<a name="3332"><span class="lineNum">    3332 </span>            :             // DQ (8/25/2014): Allow non-template functions in a template class declaration (see test2014_161.C).</a>
<a name="3333"><span class="lineNum">    3333 </span>            : #if !ENFORCE_NO_FUNCTION_TEMPLATE_DECLARATIONS_IN_TEMPLATE_CLASS_INSTANTIATIONS</a>
<a name="3334"><span class="lineNum">    3334 </span>            :             // printf (&quot;In checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(): This is the wrong scope that is associated with this function (because EDG uses a single pointeer for a scope that maps to two different scopes in ROSE (and the scope_cache is not reset) \n&quot;);</a>
<a name="3335"><span class="lineNum">    3335 </span>            :             // ROSE_ASSERT(isSgTemplateClassDefinition(scope) == NULL);</a>
<a name="3336"><span class="lineNum">    3336 </span>            : #endif</a>
<a name="3337"><span class="lineNum">    3337 </span>            :              }</a>
<a name="3338"><span class="lineNum">    3338 </span>            :         }</a>
<a name="3339"><span class="lineNum">    3339 </span>            :        else</a>
<a name="3340"><span class="lineNum">    3340 </span>            :         {</a>
<a name="3341"><span class="lineNum">    3341 </span><span class="lineCov">    1141170 :           if (isSgTemplateFunctionDeclaration(func) != NULL)</span></a>
<a name="3342"><span class="lineNum">    3342 </span>            :              {</a>
<a name="3343"><span class="lineNum">    3343 </span><span class="lineCov">       6934 :                if (isSgTemplateInstantiationMemberFunctionDecl(func) != NULL)</span></a>
<a name="3344"><span class="lineNum">    3344 </span>            :                   {</a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(isSgTemplateClassDefinition(scope) != NULL);</span></a>
<a name="3346"><span class="lineNum">    3346 </span>            :                   }</a>
<a name="3347"><span class="lineNum">    3347 </span>            :              }</a>
<a name="3348"><span class="lineNum">    3348 </span>            :         }</a>
<a name="3349"><span class="lineNum">    3349 </span><span class="lineCov">    1180450 :    }</span></a>
<a name="3350"><span class="lineNum">    3350 </span>            : </a>
<a name="3351"><span class="lineNum">    3351 </span>            : //----------------- function declaration------------</a>
<a name="3352"><span class="lineNum">    3352 </span>            : // considering</a>
<a name="3353"><span class="lineNum">    3353 </span>            : // 1. fresh building</a>
<a name="3354"><span class="lineNum">    3354 </span>            : // 2. secondary building after another nondefining functiondeclaration</a>
<a name="3355"><span class="lineNum">    3355 </span>            : // 3. secondary building after another defining function declaration</a>
<a name="3356"><span class="lineNum">    3356 </span>            : // 4. fortran ?</a>
<a name="3357"><span class="lineNum">    3357 </span>            : template &lt;class actualFunction&gt;</a>
<a name="3358"><span class="lineNum">    3358 </span>            : actualFunction*</a>
<a name="3359"><span class="lineNum">    3359 </span><span class="lineCov">    1161200 : SageBuilder::buildNondefiningFunctionDeclaration_T (</span></a>
<a name="3360"><span class="lineNum">    3360 </span>            :    const SgName &amp; XXX_name, SgType* return_type, SgFunctionParameterList * paralist, bool isMemberFunction,</a>
<a name="3361"><span class="lineNum">    3361 </span>            :    SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags,</a>
<a name="3362"><span class="lineNum">    3362 </span>            :    SgTemplateArgumentPtrList* templateArgumentsList, SgTemplateParameterPtrList* templateParameterList,</a>
<a name="3363"><span class="lineNum">    3363 </span>            :    SgStorageModifier::storage_modifier_enum sm</a>
<a name="3364"><span class="lineNum">    3364 </span>            : ) {</a>
<a name="3365"><span class="lineNum">    3365 </span>            :   // DQ (11/25/2011): This function has been modified to work when used with a SgTemplateFunctionDeclaration as a template argument.</a>
<a name="3366"><span class="lineNum">    3366 </span>            :   // It was originally designed to work with only SgFunctionDeclaration and SgMemberFunctionDeclaration, it now works with these</a>
<a name="3367"><span class="lineNum">    3367 </span>            :   // plus SgTemplateFunctionDeclaration and SgTemplateMemberonDeclaration IR nodes. This is part of providing new support for template</a>
<a name="3368"><span class="lineNum">    3368 </span>            :   // declarations in the AST and a general update of this function to support this expanded use.</a>
<a name="3369"><span class="lineNum">    3369 </span>            : </a>
<a name="3370"><span class="lineNum">    3370 </span>            :   // DQ (11/27/2011) Note: it is not clear if we need the newly added input paramter: buildTemplateInstantiation; since this is represented in the template parameter.</a>
<a name="3371"><span class="lineNum">    3371 </span>            : </a>
<a name="3372"><span class="lineNum">    3372 </span>            : #if 0</a>
<a name="3373"><span class="lineNum">    3373 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): XXX_name = %s\n&quot;, XXX_name.str());</a>
<a name="3374"><span class="lineNum">    3374 </span>            : #endif</a>
<a name="3375"><span class="lineNum">    3375 </span>            : </a>
<a name="3376"><span class="lineNum">    3376 </span>            :   // argument verification</a>
<a name="3377"><span class="lineNum">    3377 </span><span class="lineCov">    1161200 :      if (scope == NULL)</span></a>
<a name="3378"><span class="lineNum">    3378 </span>            :         {</a>
<a name="3379"><span class="lineNum">    3379 </span><span class="lineCov">          8 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="3380"><span class="lineNum">    3380 </span>            : #if 0</a>
<a name="3381"><span class="lineNum">    3381 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): isMemberFunction = %s scope == NULL resetting the scope = %p = %s \n&quot;,isMemberFunction ? &quot;true&quot; : &quot;false&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3382"><span class="lineNum">    3382 </span>            : #endif</a>
<a name="3383"><span class="lineNum">    3383 </span>            :         }</a>
<a name="3384"><span class="lineNum">    3384 </span><span class="lineCov">    1161200 :      ROSE_ASSERT (scope !=NULL);</span></a>
<a name="3385"><span class="lineNum">    3385 </span>            : </a>
<a name="3386"><span class="lineNum">    3386 </span>            : #if 0</a>
<a name="3387"><span class="lineNum">    3387 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): scope = %p = %s templateArgumentsList = %p templateParameterList = %p \n&quot;,</a>
<a name="3388"><span class="lineNum">    3388 </span>            :           scope,scope != NULL ? scope-&gt;class_name().c_str() : &quot;NULL&quot;,templateArgumentsList,templateParameterList);</a>
<a name="3389"><span class="lineNum">    3389 </span>            : #endif</a>
<a name="3390"><span class="lineNum">    3390 </span>            : </a>
<a name="3391"><span class="lineNum">    3391 </span>            :   // ROSE_ASSERT(XXX_name.is_null() == false);</a>
<a name="3392"><span class="lineNum">    3392 </span><span class="lineCov">    1161200 :      if (XXX_name.is_null() == true)</span></a>
<a name="3393"><span class="lineNum">    3393 </span>            :         {</a>
<a name="3394"><span class="lineNum">    3394 </span>            :        // DQ (4/2/2013): This case is generated for test2013_86.C.</a>
<a name="3395"><span class="lineNum">    3395 </span><span class="lineNoCov">          0 :           mprintf (&quot;NOTE: In buildNondefiningFunctionDeclaration_T(): XXX_name.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n&quot;);</span></a>
<a name="3396"><span class="lineNum">    3396 </span>            :         }</a>
<a name="3397"><span class="lineNum">    3397 </span>            : </a>
<a name="3398"><span class="lineNum">    3398 </span><span class="lineCov">    2322410 :      SgName nameWithoutTemplateArguments = XXX_name;</span></a>
<a name="3399"><span class="lineNum">    3399 </span><span class="lineCov">    1161200 :      SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;</span></a>
<a name="3400"><span class="lineNum">    3400 </span>            : </a>
<a name="3401"><span class="lineNum">    3401 </span><span class="lineCov">    1161200 :      bool buildTemplateInstantiation = ((VariantT)actualFunction::static_variant == V_SgTemplateInstantiationFunctionDecl || (VariantT)actualFunction::static_variant == V_SgTemplateInstantiationMemberFunctionDecl);</span></a>
<a name="3402"><span class="lineNum">    3402 </span>            : </a>
<a name="3403"><span class="lineNum">    3403 </span>            :   // DQ (8/7/2013): Added support for template declarations.</a>
<a name="3404"><span class="lineNum">    3404 </span><span class="lineCov">    1161200 :      bool buildTemplateDeclaration   = ((VariantT)actualFunction::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration);</span></a>
<a name="3405"><span class="lineNum">    3405 </span>            : </a>
<a name="3406"><span class="lineNum">    3406 </span>            : #if 0</a>
<a name="3407"><span class="lineNum">    3407 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): buildTemplateInstantiation = %s \n&quot;,buildTemplateInstantiation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3408"><span class="lineNum">    3408 </span>            : #endif</a>
<a name="3409"><span class="lineNum">    3409 </span>            : </a>
<a name="3410"><span class="lineNum">    3410 </span>            :   // DQ (8/7/2013): Added support for template declarations (need to handle template names overloaded on template parameters).</a>
<a name="3411"><span class="lineNum">    3411 </span>            :   // We want to use the template arguments in the symbol table lookup, but not in the name generation.</a>
<a name="3412"><span class="lineNum">    3412 </span>            :   // if (buildTemplateInstantiation == true)</a>
<a name="3413"><span class="lineNum">    3413 </span>            :   // if (buildTemplateInstantiation == true || buildTemplateDeclaration == true)</a>
<a name="3414"><span class="lineNum">    3414 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="3415"><span class="lineNum">    3415 </span>            :         {</a>
<a name="3416"><span class="lineNum">    3416 </span><span class="lineCov">      14410 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="3417"><span class="lineNum">    3417 </span><span class="lineCov">      14410 :           nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);</span></a>
<a name="3418"><span class="lineNum">    3418 </span>            : #if 0</a>
<a name="3419"><span class="lineNum">    3419 </span>            :           printf (&quot;Building a non-defining function: buildNondefiningFunctionDeclaration_T() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n&quot;,nameWithTemplateArguments.str(),buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</a>
<a name="3420"><span class="lineNum">    3420 </span>            : #endif</a>
<a name="3421"><span class="lineNum">    3421 </span>            : #if 0</a>
<a name="3422"><span class="lineNum">    3422 </span>            :           if (nameWithTemplateArguments == &quot;insert &lt; __normal_iterator&lt; SgInitializedName ** , __type  &gt;  &gt; &quot;)</a>
<a name="3423"><span class="lineNum">    3423 </span>            :              {</a>
<a name="3424"><span class="lineNum">    3424 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): Found function nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="3425"><span class="lineNum">    3425 </span>            :              }</a>
<a name="3426"><span class="lineNum">    3426 </span>            : #endif</a>
<a name="3427"><span class="lineNum">    3427 </span>            :         }</a>
<a name="3428"><span class="lineNum">    3428 </span>            : </a>
<a name="3429"><span class="lineNum">    3429 </span>            : #if 0</a>
<a name="3430"><span class="lineNum">    3430 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): nameWithTemplateArguments = |%s| \n&quot;,nameWithTemplateArguments.str());</a>
<a name="3431"><span class="lineNum">    3431 </span>            : #endif</a>
<a name="3432"><span class="lineNum">    3432 </span>            : </a>
<a name="3433"><span class="lineNum">    3433 </span>            :   // printf (&quot;Building non-defining function for scope = %p in file = %s \n&quot;,scope,TransformationSupport::getSourceFile(scope)-&gt;getFileName().c_str());</a>
<a name="3434"><span class="lineNum">    3434 </span>            : </a>
<a name="3435"><span class="lineNum">    3435 </span>            :   // DQ (2/25/2009): I think I added this recently but it is overly restrictive.</a>
<a name="3436"><span class="lineNum">    3436 </span>            :   // ROSE_ASSERT(scope != NULL);</a>
<a name="3437"><span class="lineNum">    3437 </span>            : </a>
<a name="3438"><span class="lineNum">    3438 </span>            :   // ROSE_ASSERT(scope-&gt;containsOnlyDeclarations());</a>
<a name="3439"><span class="lineNum">    3439 </span>            :   // this function is also called when building a function reference before the function declaration exists.  So, skip the check</a>
<a name="3440"><span class="lineNum">    3440 </span>            :   // ROSE_ASSERT(nameWithTemplateArguments.is_null() == false);</a>
<a name="3441"><span class="lineNum">    3441 </span><span class="lineCov">    1161200 :      if (nameWithTemplateArguments.is_null() == true)</span></a>
<a name="3442"><span class="lineNum">    3442 </span>            :         {</a>
<a name="3443"><span class="lineNum">    3443 </span>            :        // DQ (3/25/2017): Modified to use message logging.</a>
<a name="3444"><span class="lineNum">    3444 </span>            :        // DQ (4/2/2013): This case is generated for test2013_86.C.</a>
<a name="3445"><span class="lineNum">    3445 </span><span class="lineNoCov">          0 :           mprintf (&quot;NOTE: In buildNondefiningFunctionDeclaration_T(): nameWithTemplateArguments.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n&quot;);</span></a>
<a name="3446"><span class="lineNum">    3446 </span>            :         }</a>
<a name="3447"><span class="lineNum">    3447 </span>            : </a>
<a name="3448"><span class="lineNum">    3448 </span>            :   // ROSE_ASSERT(nameWithoutTemplateArguments.is_null() == false);</a>
<a name="3449"><span class="lineNum">    3449 </span><span class="lineCov">    1161200 :      if (nameWithoutTemplateArguments.is_null() == true)</span></a>
<a name="3450"><span class="lineNum">    3450 </span>            :         {</a>
<a name="3451"><span class="lineNum">    3451 </span>            :        // DQ (3/25/2017): Modified to use message logging.</a>
<a name="3452"><span class="lineNum">    3452 </span>            :        // DQ (4/2/2013): This case is generated for test2013_86.C.</a>
<a name="3453"><span class="lineNum">    3453 </span><span class="lineNoCov">          0 :           mprintf (&quot;NOTE: In buildNondefiningFunctionDeclaration_T(): nameWithoutTemplateArguments.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n&quot;);</span></a>
<a name="3454"><span class="lineNum">    3454 </span>            :         }</a>
<a name="3455"><span class="lineNum">    3455 </span>            : </a>
<a name="3456"><span class="lineNum">    3456 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="3457"><span class="lineNum">    3457 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(paralist != NULL);</span></a>
<a name="3458"><span class="lineNum">    3458 </span>            : </a>
<a name="3459"><span class="lineNum">    3459 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="3460"><span class="lineNum">    3460 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="3461"><span class="lineNum">    3461 </span>            :   // ROSE_ASSERT(SageInterface::hasTemplateSyntax(XXX_name) == false);</a>
<a name="3462"><span class="lineNum">    3462 </span><span class="lineCov">    1161200 :      if (SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == true)</span></a>
<a name="3463"><span class="lineNum">    3463 </span>            :         {</a>
<a name="3464"><span class="lineNum">    3464 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="3465"><span class="lineNum">    3465 </span>            :           printf (&quot;Warning: In buildNondefiningFunctionDeclaration_T(): nameWithoutTemplateArguments = %s nameWithTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str(),nameWithTemplateArguments.str());</a>
<a name="3466"><span class="lineNum">    3466 </span>            : #endif</a>
<a name="3467"><span class="lineNum">    3467 </span>            :         }</a>
<a name="3468"><span class="lineNum">    3468 </span>            :   // DQ (7/27/2012): There are reasons why this can fail: e.g. for functions with names such as:</a>
<a name="3469"><span class="lineNum">    3469 </span>            :   // &quot;operator std::auto_ptr_ref&lt;_Tp1&gt;&quot; which is a user defined conversion operator to one class from another.</a>
<a name="3470"><span class="lineNum">    3470 </span>            :   // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);</a>
<a name="3471"><span class="lineNum">    3471 </span>            : </a>
<a name="3472"><span class="lineNum">    3472 </span>            :   // tentatively build a function type, since it is shared</a>
<a name="3473"><span class="lineNum">    3473 </span>            :   // by all prototypes and defining declarations of a same function!</a>
<a name="3474"><span class="lineNum">    3474 </span>            :   // SgFunctionType * func_type = buildFunctionType(return_type,paralist);</a>
<a name="3475"><span class="lineNum">    3475 </span>            : </a>
<a name="3476"><span class="lineNum">    3476 </span>            : #if 0</a>
<a name="3477"><span class="lineNum">    3477 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): isMemberFunction = %s scope = %p = %s \n&quot;,isMemberFunction ? &quot;true&quot; : &quot;false&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3478"><span class="lineNum">    3478 </span>            : #endif</a>
<a name="3479"><span class="lineNum">    3479 </span>            : </a>
<a name="3480"><span class="lineNum">    3480 </span><span class="lineCov">    1161200 :      SgFunctionType* func_type = NULL;</span></a>
<a name="3481"><span class="lineNum">    3481 </span><span class="lineCov">    1161200 :      if (isMemberFunction == true)</span></a>
<a name="3482"><span class="lineNum">    3482 </span>            :         {</a>
<a name="3483"><span class="lineNum">    3483 </span>            :        // func_type = buildMemberFunctionType(return_type,paralist,NULL,0);</a>
<a name="3484"><span class="lineNum">    3484 </span>            :        // func_type = buildFunctionType(return_type,paralist);</a>
<a name="3485"><span class="lineNum">    3485 </span>            : #if 0</a>
<a name="3486"><span class="lineNum">    3486 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): scope = %p = %s\n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3487"><span class="lineNum">    3487 </span>            : #endif</a>
<a name="3488"><span class="lineNum">    3488 </span><span class="lineCov">      27054 :           SgFunctionParameterTypeList * typeList = buildFunctionParameterTypeList(paralist);</span></a>
<a name="3489"><span class="lineNum">    3489 </span>            : </a>
<a name="3490"><span class="lineNum">    3490 </span>            :        // DQ (1/10/2020): This was a default argument that was initialized to zero, I would like to remove the</a>
<a name="3491"><span class="lineNum">    3491 </span>            :        // use of the default argument to better support debugging new regerence qualifiers for member functions.</a>
<a name="3492"><span class="lineNum">    3492 </span>            :        // func_type = buildMemberFunctionType(return_type,typeList,scope, functionConstVolatileFlags);</a>
<a name="3493"><span class="lineNum">    3493 </span><span class="lineCov">      27054 :           unsigned int reference_modifiers = 0;</span></a>
<a name="3494"><span class="lineNum">    3494 </span><span class="lineCov">      27054 :           func_type = buildMemberFunctionType(return_type,typeList,scope, functionConstVolatileFlags,reference_modifiers);</span></a>
<a name="3495"><span class="lineNum">    3495 </span>            : #if 0</a>
<a name="3496"><span class="lineNum">    3496 </span>            :           printf (&quot;Using zero as value for reference_modifiers for member function type = %p = %s \n&quot;,func_type,func_type-&gt;class_name().c_str());</a>
<a name="3497"><span class="lineNum">    3497 </span>            : #endif</a>
<a name="3498"><span class="lineNum">    3498 </span>            : #if 0</a>
<a name="3499"><span class="lineNum">    3499 </span>            :        // DQ (1/11/2020): Debugging Cxx11_tests/test2020_27.C.</a>
<a name="3500"><span class="lineNum">    3500 </span>            :           SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(func_type);</a>
<a name="3501"><span class="lineNum">    3501 </span>            :           if (memberFunctionType != NULL)</a>
<a name="3502"><span class="lineNum">    3502 </span>            :              {</a>
<a name="3503"><span class="lineNum">    3503 </span>            :                printf (&quot; --- memberFunctionType-&gt;isLvalueReferenceFunc() = %s \n&quot;,memberFunctionType-&gt;isLvalueReferenceFunc() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3504"><span class="lineNum">    3504 </span>            :                printf (&quot; --- memberFunctionType-&gt;isRvalueReferenceFunc() = %s \n&quot;,memberFunctionType-&gt;isRvalueReferenceFunc() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3505"><span class="lineNum">    3505 </span>            : #if 0</a>
<a name="3506"><span class="lineNum">    3506 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3507"><span class="lineNum">    3507 </span>            :                ROSE_ABORT();</a>
<a name="3508"><span class="lineNum">    3508 </span>            : #endif</a>
<a name="3509"><span class="lineNum">    3509 </span>            :              }</a>
<a name="3510"><span class="lineNum">    3510 </span>            : #endif</a>
<a name="3511"><span class="lineNum">    3511 </span>            : </a>
<a name="3512"><span class="lineNum">    3512 </span>            :        // printf (&quot;Error: SgFunctionType built instead of SgMemberFunctionType \n&quot;);</a>
<a name="3513"><span class="lineNum">    3513 </span>            :        // ROSE_ASSERT(false);</a>
<a name="3514"><span class="lineNum">    3514 </span>            :         }</a>
<a name="3515"><span class="lineNum">    3515 </span>            :        else</a>
<a name="3516"><span class="lineNum">    3516 </span>            :         {</a>
<a name="3517"><span class="lineNum">    3517 </span><span class="lineCov">    1134146 :           func_type = buildFunctionType(return_type,paralist);</span></a>
<a name="3518"><span class="lineNum">    3518 </span>            :         }</a>
<a name="3519"><span class="lineNum">    3519 </span>            : </a>
<a name="3520"><span class="lineNum">    3520 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func_type != NULL);</span></a>
<a name="3521"><span class="lineNum">    3521 </span>            : </a>
<a name="3522"><span class="lineNum">    3522 </span>            : #if 0</a>
<a name="3523"><span class="lineNum">    3523 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_type = %p = %s \n&quot;,func_type,func_type-&gt;class_name().c_str());</a>
<a name="3524"><span class="lineNum">    3524 </span>            : #endif</a>
<a name="3525"><span class="lineNum">    3525 </span>            : #if 0</a>
<a name="3526"><span class="lineNum">    3526 </span>            :   // printf (&quot;In buildNondefiningFunctionDeclaration_T(): paralist-&gt;get_args()[0]-&gt;unparseToString() = %s \n&quot;,paralist-&gt;get_args()[0]-&gt;unparseToString().c_str());</a>
<a name="3527"><span class="lineNum">    3527 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_type-&gt;unparseToString() = %s \n&quot;,func_type-&gt;unparseToString().c_str());</a>
<a name="3528"><span class="lineNum">    3528 </span>            : #endif</a>
<a name="3529"><span class="lineNum">    3529 </span>            : </a>
<a name="3530"><span class="lineNum">    3530 </span>            :   // function declaration</a>
<a name="3531"><span class="lineNum">    3531 </span><span class="lineCov">    1161200 :      actualFunction* func = NULL;</span></a>
<a name="3532"><span class="lineNum">    3532 </span>            : </a>
<a name="3533"><span class="lineNum">    3533 </span>            :   // search before using the function type to create the function declaration</a>
<a name="3534"><span class="lineNum">    3534 </span>            :   // TODO only search current scope or all ancestor scope?? (DQ: Only current scope!)</a>
<a name="3535"><span class="lineNum">    3535 </span>            :   // We don't have lookup_member_function_symbol  yet</a>
<a name="3536"><span class="lineNum">    3536 </span>            :   // SgFunctionSymbol *func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="3537"><span class="lineNum">    3537 </span>            : </a>
<a name="3538"><span class="lineNum">    3538 </span>            :   // DQ (12/27/2011): Under the new design we can make the symbol type SgFunctionSymbol instead of the less specific SgSymbol.</a>
<a name="3539"><span class="lineNum">    3539 </span>            :   // DQ (11/25/2011): We want to add the support for template function declarations,</a>
<a name="3540"><span class="lineNum">    3540 </span>            :   // so this should be a SgSymbol so that we can have it be either a SgFunctionSymbol</a>
<a name="3541"><span class="lineNum">    3541 </span>            :   // or a SgTemplateSymbol.</a>
<a name="3542"><span class="lineNum">    3542 </span>            :   // SgFunctionSymbol *func_symbol = NULL;</a>
<a name="3543"><span class="lineNum">    3543 </span>            :   // SgSymbol *func_symbol = NULL;</a>
<a name="3544"><span class="lineNum">    3544 </span><span class="lineCov">    1161200 :      SgFunctionSymbol* func_symbol = NULL;</span></a>
<a name="3545"><span class="lineNum">    3545 </span>            : </a>
<a name="3546"><span class="lineNum">    3546 </span>            :      if (scope != NULL)</a>
<a name="3547"><span class="lineNum">    3547 </span>            :         {</a>
<a name="3548"><span class="lineNum">    3548 </span>            :        // DQ (3/13/2012): Experiment with new function to support only associating the right type of symbol with the</a>
<a name="3549"><span class="lineNum">    3549 </span>            :        // function being built.  I don't think I like the design of this interface, but we might change that later.</a>
<a name="3550"><span class="lineNum">    3550 </span>            :        // func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="3551"><span class="lineNum">    3551 </span>            :        // SgSymbol* symbol = scope-&gt;get_symbol_table()-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(name,func_type);</a>
<a name="3552"><span class="lineNum">    3552 </span>            :        // func_symbol = symbol;</a>
<a name="3553"><span class="lineNum">    3553 </span>            : #if 0</a>
<a name="3554"><span class="lineNum">    3554 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): name = %s func_type = %p = %s templateParameterList-&gt;size() = %&quot; PRIuPTR &quot; templateArgumentsList-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="3555"><span class="lineNum">    3555 </span>            :                nameWithTemplateArguments.str(),func_type,func_type-&gt;get_mangled().str(),</a>
<a name="3556"><span class="lineNum">    3556 </span>            :                templateParameterList != NULL ? templateParameterList-&gt;size() : 999,</a>
<a name="3557"><span class="lineNum">    3557 </span>            :                templateArgumentsList != NULL ? templateArgumentsList-&gt;size() : 999);</a>
<a name="3558"><span class="lineNum">    3558 </span>            :           printf(&quot; --- scope = %p (%s)\n&quot;, scope, scope ? scope-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="3559"><span class="lineNum">    3559 </span>            : #endif</a>
<a name="3560"><span class="lineNum">    3560 </span>            : #if 0</a>
<a name="3561"><span class="lineNum">    3561 </span>            :        // Debugging output.</a>
<a name="3562"><span class="lineNum">    3562 </span>            :           if (templateArgumentsList != NULL)</a>
<a name="3563"><span class="lineNum">    3563 </span>            :              {</a>
<a name="3564"><span class="lineNum">    3564 </span>            :                printf (&quot;Output of type chains for template arguments: \n&quot;);</a>
<a name="3565"><span class="lineNum">    3565 </span>            :                for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="3566"><span class="lineNum">    3566 </span>            :                   {</a>
<a name="3567"><span class="lineNum">    3567 </span>            :                     string s = &quot;template argument: &quot; + StringUtility::numberToString(i) + &quot; &quot;;</a>
<a name="3568"><span class="lineNum">    3568 </span>            :                  // templateArgumentsList-&gt;get_args()[i]-&gt;display(s);</a>
<a name="3569"><span class="lineNum">    3569 </span>            :                  // templateArgumentsList-&gt;[i]-&gt;display(s);</a>
<a name="3570"><span class="lineNum">    3570 </span>            :                     templateArgumentsList-&gt;operator[](i)-&gt;display(s);</a>
<a name="3571"><span class="lineNum">    3571 </span>            :                   }</a>
<a name="3572"><span class="lineNum">    3572 </span>            :              }</a>
<a name="3573"><span class="lineNum">    3573 </span>            : #endif</a>
<a name="3574"><span class="lineNum">    3574 </span>            : </a>
<a name="3575"><span class="lineNum">    3575 </span>            :        // DQ (8/7/2013): We need to use the template arguments in the symbol table lookup for template functions to permit template function overloading on template perameters.</a>
<a name="3576"><span class="lineNum">    3576 </span><span class="lineCov">    1161200 :           func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);</span></a>
<a name="3577"><span class="lineNum">    3577 </span>            : </a>
<a name="3578"><span class="lineNum">    3578 </span>            : #if 0</a>
<a name="3579"><span class="lineNum">    3579 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_symbol from scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(name = %s) = %p \n&quot;,nameWithTemplateArguments.str(),func_symbol);</a>
<a name="3580"><span class="lineNum">    3580 </span>            :           if (func_symbol != NULL) {</a>
<a name="3581"><span class="lineNum">    3581 </span>            :             printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_symbol-&gt;get_declaration() = %p \n&quot;, func_symbol-&gt;get_declaration());</a>
<a name="3582"><span class="lineNum">    3582 </span>            :           }</a>
<a name="3583"><span class="lineNum">    3583 </span>            : #endif</a>
<a name="3584"><span class="lineNum">    3584 </span>            : #if 0</a>
<a name="3585"><span class="lineNum">    3585 </span>            :           if (nameWithoutTemplateArguments == &quot;getline&quot;)</a>
<a name="3586"><span class="lineNum">    3586 </span>            :              {</a>
<a name="3587"><span class="lineNum">    3587 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_symbol from scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(name = %s) = %p \n&quot;,nameWithTemplateArguments.str(),func_symbol);</a>
<a name="3588"><span class="lineNum">    3588 </span>            :              }</a>
<a name="3589"><span class="lineNum">    3589 </span>            : #endif</a>
<a name="3590"><span class="lineNum">    3590 </span>            : </a>
<a name="3591"><span class="lineNum">    3591 </span>            :        // If not a proper function (or instantiated template function), then check for a template function declaration.</a>
<a name="3592"><span class="lineNum">    3592 </span>            :           if (func_symbol == NULL)</a>
<a name="3593"><span class="lineNum">    3593 </span>            :              {</a>
<a name="3594"><span class="lineNum">    3594 </span>            :             // Note that a template function does not have a function type (just a name).</a>
<a name="3595"><span class="lineNum">    3595 </span>            : #if 0</a>
<a name="3596"><span class="lineNum">    3596 </span>            :                printf (&quot;NOTE: Maybe template symbols for template function declarations should use the function type \n&quot;);</a>
<a name="3597"><span class="lineNum">    3597 </span>            : #endif</a>
<a name="3598"><span class="lineNum">    3598 </span>            :                ROSE_ASSERT(func_type != NULL);</a>
<a name="3599"><span class="lineNum">    3599 </span>            :              }</a>
<a name="3600"><span class="lineNum">    3600 </span>            :             else</a>
<a name="3601"><span class="lineNum">    3601 </span>            :              {</a>
<a name="3602"><span class="lineNum">    3602 </span>            : #if 0</a>
<a name="3603"><span class="lineNum">    3603 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_symbol = %p was found using name = %s \n&quot;,func_symbol,nameWithTemplateArguments.str());</a>
<a name="3604"><span class="lineNum">    3604 </span>            : #endif</a>
<a name="3605"><span class="lineNum">    3605 </span>            :              }</a>
<a name="3606"><span class="lineNum">    3606 </span>            :         }</a>
<a name="3607"><span class="lineNum">    3607 </span>            : </a>
<a name="3608"><span class="lineNum">    3608 </span>            : #if 1</a>
<a name="3609"><span class="lineNum">    3609 </span>            :   // DQ (3/13/2012): I want to introduce error checking on the symbol matching the template parameter.</a>
<a name="3610"><span class="lineNum">    3610 </span><span class="lineCov">    1161200 :      if (func_symbol != NULL)</span></a>
<a name="3611"><span class="lineNum">    3611 </span>            :         {</a>
<a name="3612"><span class="lineNum">    3612 </span>            : #if 0</a>
<a name="3613"><span class="lineNum">    3613 </span>            :           printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p = %s \n&quot;,scope,func_symbol,func_symbol-&gt;class_name().c_str());</a>
<a name="3614"><span class="lineNum">    3614 </span>            : #endif</a>
<a name="3615"><span class="lineNum">    3615 </span>            : #if 0</a>
<a name="3616"><span class="lineNum">    3616 </span>            :           if ((VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration)</a>
<a name="3617"><span class="lineNum">    3617 </span>            :                printf (&quot;This is a SgTemplateMemberFunctionDeclaration function \n&quot;);</a>
<a name="3618"><span class="lineNum">    3618 </span>            :             else</a>
<a name="3619"><span class="lineNum">    3619 </span>            :                printf (&quot;variantT(actualFunction::static_variant) = %d \n&quot;,actualFunction::static_variant);</a>
<a name="3620"><span class="lineNum">    3620 </span>            : #endif</a>
<a name="3621"><span class="lineNum">    3621 </span>            :           switch((VariantT)actualFunction::static_variant)</a>
<a name="3622"><span class="lineNum">    3622 </span>            :              {</a>
<a name="3623"><span class="lineNum">    3623 </span><span class="lineCov">     309278 :                case V_SgFunctionDeclaration:</span></a>
<a name="3624"><span class="lineNum">    3624 </span>            :                case V_SgProcedureHeaderStatement:</a>
<a name="3625"><span class="lineNum">    3625 </span>            :                case V_SgTemplateInstantiationFunctionDecl:</a>
<a name="3626"><span class="lineNum">    3626 </span>            :                   {</a>
<a name="3627"><span class="lineNum">    3627 </span>            : #if 0</a>
<a name="3628"><span class="lineNum">    3628 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgFunctionDeclaration function \n&quot;);</a>
<a name="3629"><span class="lineNum">    3629 </span>            : #endif</a>
<a name="3630"><span class="lineNum">    3630 </span><span class="lineCov">     309278 :                     ROSE_ASSERT(isSgFunctionSymbol(func_symbol) != NULL);</span></a>
<a name="3631"><span class="lineNum">    3631 </span>            :                     break;</a>
<a name="3632"><span class="lineNum">    3632 </span>            :                   }</a>
<a name="3633"><span class="lineNum">    3633 </span><span class="lineCov">        567 :                case V_SgMemberFunctionDeclaration:</span></a>
<a name="3634"><span class="lineNum">    3634 </span>            :                case V_SgTemplateInstantiationMemberFunctionDecl:</a>
<a name="3635"><span class="lineNum">    3635 </span>            :                   {</a>
<a name="3636"><span class="lineNum">    3636 </span>            : #if 0</a>
<a name="3637"><span class="lineNum">    3637 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgMemberFunctionDeclaration function \n&quot;);</a>
<a name="3638"><span class="lineNum">    3638 </span>            : #endif</a>
<a name="3639"><span class="lineNum">    3639 </span><span class="lineCov">        567 :                     ROSE_ASSERT(isSgMemberFunctionSymbol(func_symbol) != NULL);</span></a>
<a name="3640"><span class="lineNum">    3640 </span>            :                     break;</a>
<a name="3641"><span class="lineNum">    3641 </span>            :                   }</a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineCov">        312 :                case V_SgTemplateFunctionDeclaration:</span></a>
<a name="3643"><span class="lineNum">    3643 </span>            :                   {</a>
<a name="3644"><span class="lineNum">    3644 </span>            : #if 0</a>
<a name="3645"><span class="lineNum">    3645 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgTemplateFunctionDeclaration function \n&quot;);</a>
<a name="3646"><span class="lineNum">    3646 </span>            : #endif</a>
<a name="3647"><span class="lineNum">    3647 </span><span class="lineCov">        312 :                     ROSE_ASSERT(isSgTemplateFunctionSymbol(func_symbol) != NULL);</span></a>
<a name="3648"><span class="lineNum">    3648 </span>            :                     break;</a>
<a name="3649"><span class="lineNum">    3649 </span>            :                   }</a>
<a name="3650"><span class="lineNum">    3650 </span><span class="lineCov">        229 :                case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="3651"><span class="lineNum">    3651 </span>            :                   {</a>
<a name="3652"><span class="lineNum">    3652 </span>            : #if 0</a>
<a name="3653"><span class="lineNum">    3653 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgTemplateMemberFunctionDeclaration function \n&quot;);</a>
<a name="3654"><span class="lineNum">    3654 </span>            : #endif</a>
<a name="3655"><span class="lineNum">    3655 </span><span class="lineCov">        229 :                     ROSE_ASSERT(isSgTemplateMemberFunctionSymbol(func_symbol) != NULL);</span></a>
<a name="3656"><span class="lineNum">    3656 </span>            :                     break;</a>
<a name="3657"><span class="lineNum">    3657 </span>            :                   }</a>
<a name="3658"><span class="lineNum">    3658 </span>            : </a>
<a name="3659"><span class="lineNum">    3659 </span>            :                default:</a>
<a name="3660"><span class="lineNum">    3660 </span>            :                   {</a>
<a name="3661"><span class="lineNum">    3661 </span>            :                     printf (&quot;default reach in buildNondefiningFunctionDeclaration_T(): variantT(actualFunction::static_variant) = %d \n&quot;,actualFunction::static_variant);</a>
<a name="3662"><span class="lineNum">    3662 </span>            :                     ROSE_ABORT();</a>
<a name="3663"><span class="lineNum">    3663 </span>            :                   }</a>
<a name="3664"><span class="lineNum">    3664 </span>            :              }</a>
<a name="3665"><span class="lineNum">    3665 </span>            : </a>
<a name="3666"><span class="lineNum">    3666 </span>            :           // TV (2/5/14): Found symbol might come from another file, in this case we need to insert it in the current scope.</a>
<a name="3667"><span class="lineNum">    3667 </span>            :           //              Can only happen when scope is a global scope</a>
<a name="3668"><span class="lineNum">    3668 </span><span class="lineCov">     310386 :              ROSE_ASSERT(scope != NULL);</span></a>
<a name="3669"><span class="lineNum">    3669 </span><span class="lineCov">     310386 :              if (  isSgGlobal(scope) != NULL</span></a>
<a name="3670"><span class="lineNum">    3670 </span><span class="lineCov">     308728 :                 &amp;&amp; scope != func_symbol-&gt;get_scope()</span></a>
<a name="3671"><span class="lineNum">    3671 </span><span class="lineCov">      10305 :                 &amp;&amp; !SageInterface::isAncestor(scope, func_symbol-&gt;get_scope())</span></a>
<a name="3672"><span class="lineNum">    3672 </span><span class="lineCov">     320691 :              &amp;&amp; !scope-&gt;symbol_exists(nameWithTemplateArguments, func_symbol) )</span></a>
<a name="3673"><span class="lineNum">    3673 </span>            :              {</a>
<a name="3674"><span class="lineNum">    3674 </span>            : #if 0</a>
<a name="3675"><span class="lineNum">    3675 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): Calling scope-&gt;insert_symbol(): for global scope: using nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="3676"><span class="lineNum">    3676 </span>            : #endif</a>
<a name="3677"><span class="lineNum">    3677 </span><span class="lineCov">       7411 :                scope-&gt;insert_symbol(nameWithTemplateArguments, func_symbol);</span></a>
<a name="3678"><span class="lineNum">    3678 </span>            :              }</a>
<a name="3679"><span class="lineNum">    3679 </span>            :         }</a>
<a name="3680"><span class="lineNum">    3680 </span>            : #endif</a>
<a name="3681"><span class="lineNum">    3681 </span>            : </a>
<a name="3682"><span class="lineNum">    3682 </span><span class="lineCov">    1161200 :      if (func_symbol == NULL)</span></a>
<a name="3683"><span class="lineNum">    3683 </span>            :         {</a>
<a name="3684"><span class="lineNum">    3684 </span><span class="lineCov">     850818 :           func = new actualFunction (nameWithTemplateArguments,func_type,NULL);</span></a>
<a name="3685"><span class="lineNum">    3685 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func != NULL);</span></a>
<a name="3686"><span class="lineNum">    3686 </span>            : </a>
<a name="3687"><span class="lineNum">    3687 </span>            :           // Storage modifier (esp. static) must be set before inserting symbol</a>
<a name="3688"><span class="lineNum">    3688 </span><span class="lineCov">     850818 :           func-&gt;get_declarationModifier().get_storageModifier().set_modifier(sm);</span></a>
<a name="3689"><span class="lineNum">    3689 </span>            : </a>
<a name="3690"><span class="lineNum">    3690 </span>            : #if 0</a>
<a name="3691"><span class="lineNum">    3691 </span>            :        // DQ (2/10/2016): Adding support for C99 function parameters used as variable references in the function parameter list.</a>
<a name="3692"><span class="lineNum">    3692 </span>            :           ROSE_ASSERT(func-&gt;get_functionParameterScope() == NULL);</a>
<a name="3693"><span class="lineNum">    3693 </span>            :           SgFunctionParameterScope* functionParameterScope = new SgFunctionParameterScope();</a>
<a name="3694"><span class="lineNum">    3694 </span>            :           ROSE_ASSERT(functionParameterScope != NULL);</a>
<a name="3695"><span class="lineNum">    3695 </span>            : #if 0</a>
<a name="3696"><span class="lineNum">    3696 </span>            :           printf (&quot;NOTE: In buildNondefiningFunctionDeclaration_T(): building new functionParameterScope for nondefining function declaration: name = %s functionParameterScope = %p = %s \n&quot;,</a>
<a name="3697"><span class="lineNum">    3697 </span>            :                nameWithTemplateArguments.str(),functionParameterScope,functionParameterScope-&gt;class_name().c_str());</a>
<a name="3698"><span class="lineNum">    3698 </span>            : #endif</a>
<a name="3699"><span class="lineNum">    3699 </span>            :           func-&gt;set_functionParameterScope(functionParameterScope);</a>
<a name="3700"><span class="lineNum">    3700 </span>            :           ROSE_ASSERT(func-&gt;get_functionParameterScope() != NULL);</a>
<a name="3701"><span class="lineNum">    3701 </span>            : #endif</a>
<a name="3702"><span class="lineNum">    3702 </span>            : </a>
<a name="3703"><span class="lineNum">    3703 </span>            :        // DQ (5/1/2012): This should always be true.</a>
<a name="3704"><span class="lineNum">    3704 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func-&gt;get_file_info() == NULL);</span></a>
<a name="3705"><span class="lineNum">    3705 </span>            : </a>
<a name="3706"><span class="lineNum">    3706 </span>            : #if 0</a>
<a name="3707"><span class="lineNum">    3707 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): case of func_symbol == NULL: constructor called to build func = %p = %s \n&quot;,func,func-&gt;class_name().c_str());</a>
<a name="3708"><span class="lineNum">    3708 </span>            : #endif</a>
<a name="3709"><span class="lineNum">    3709 </span>            : #if 0</a>
<a name="3710"><span class="lineNum">    3710 </span>            :           if (isSgMemberFunctionDeclaration(func) != NULL)</a>
<a name="3711"><span class="lineNum">    3711 </span>            :              {</a>
<a name="3712"><span class="lineNum">    3712 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): SgCtorInitializerList = %p \n&quot;,isSgMemberFunctionDeclaration(func)-&gt;get_CtorInitializerList());</a>
<a name="3713"><span class="lineNum">    3713 </span>            :              }</a>
<a name="3714"><span class="lineNum">    3714 </span>            : #endif</a>
<a name="3715"><span class="lineNum">    3715 </span>            : #if 0</a>
<a name="3716"><span class="lineNum">    3716 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3717"><span class="lineNum">    3717 </span>            : #endif</a>
<a name="3718"><span class="lineNum">    3718 </span>            :        // DQ (12/14/2011): Moved this from lower in this function.</a>
<a name="3719"><span class="lineNum">    3719 </span><span class="lineCov">     850818 :           func-&gt;set_scope(scope);</span></a>
<a name="3720"><span class="lineNum">    3720 </span>            : </a>
<a name="3721"><span class="lineNum">    3721 </span>            :        // DQ (12/15/2011): Added test.</a>
<a name="3722"><span class="lineNum">    3722 </span><span class="lineCov">     850818 :           checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(func,scope);</span></a>
<a name="3723"><span class="lineNum">    3723 </span>            : </a>
<a name="3724"><span class="lineNum">    3724 </span>            :        // This fails below for a SgTemplateFunctionDeclaration, so test it here.</a>
<a name="3725"><span class="lineNum">    3725 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func-&gt;get_parameterList() != NULL);</span></a>
<a name="3726"><span class="lineNum">    3726 </span>            : </a>
<a name="3727"><span class="lineNum">    3727 </span>            :        // NOTE: we want to allow the input scope to be NULL (and even the SageBuilder::topScopeStack() == NULL)</a>
<a name="3728"><span class="lineNum">    3728 </span>            :        // so that function can be built bottom up style.  However this means that the symbol tables in the</a>
<a name="3729"><span class="lineNum">    3729 </span>            :        // scope of the returned function declaration will have to be setup separately.</a>
<a name="3730"><span class="lineNum">    3730 </span>            :           if (scope != NULL)</a>
<a name="3731"><span class="lineNum">    3731 </span>            :              {</a>
<a name="3732"><span class="lineNum">    3732 </span>            :             // function symbol table</a>
<a name="3733"><span class="lineNum">    3733 </span><span class="lineCov">     850818 :                if (isSgMemberFunctionDeclaration(func))</span></a>
<a name="3734"><span class="lineNum">    3734 </span>            :                   {</a>
<a name="3735"><span class="lineNum">    3735 </span>            :                  // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used. I have</a>
<a name="3736"><span class="lineNum">    3736 </span>            :                  // not decided if template declarations should cause symbols to be generated for functions and member functions.</a>
<a name="3737"><span class="lineNum">    3737 </span>            :                  // func_symbol = new SgMemberFunctionSymbol(func);</a>
<a name="3738"><span class="lineNum">    3738 </span><span class="lineCov">      26258 :                     if (isSgTemplateMemberFunctionDeclaration(func) != NULL)</span></a>
<a name="3739"><span class="lineNum">    3739 </span><span class="lineCov">       9830 :                        func_symbol = new SgTemplateMemberFunctionSymbol(isSgTemplateMemberFunctionDeclaration(func));</span></a>
<a name="3740"><span class="lineNum">    3740 </span>            :                     else</a>
<a name="3741"><span class="lineNum">    3741 </span>            :                      {</a>
<a name="3742"><span class="lineNum">    3742 </span><span class="lineCov">      16428 :                        SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(func);</span></a>
<a name="3743"><span class="lineNum">    3743 </span><span class="lineCov">      16428 :                        ROSE_ASSERT(memberFunctionDeclaration != NULL);</span></a>
<a name="3744"><span class="lineNum">    3744 </span><span class="lineCov">      16428 :                        func_symbol = new SgMemberFunctionSymbol(memberFunctionDeclaration);</span></a>
<a name="3745"><span class="lineNum">    3745 </span>            :                      }</a>
<a name="3746"><span class="lineNum">    3746 </span>            : </a>
<a name="3747"><span class="lineNum">    3747 </span><span class="lineCov">      26258 :                     ROSE_ASSERT(func_symbol != NULL);</span></a>
<a name="3748"><span class="lineNum">    3748 </span><span class="lineCov">      26258 :                     ROSE_ASSERT(func_symbol-&gt;get_symbol_basis() != NULL);</span></a>
<a name="3749"><span class="lineNum">    3749 </span>            :                   }</a>
<a name="3750"><span class="lineNum">    3750 </span>            :                  else</a>
<a name="3751"><span class="lineNum">    3751 </span>            :                   {</a>
<a name="3752"><span class="lineNum">    3752 </span>            :                  // if (isSgFunctionDeclaration(func))</a>
<a name="3753"><span class="lineNum">    3753 </span><span class="lineCov">     824560 :                     if (isSgTemplateFunctionDeclaration(func))</span></a>
<a name="3754"><span class="lineNum">    3754 </span>            :                        {</a>
<a name="3755"><span class="lineNum">    3755 </span>            :                       // How should we handled template functions in the symbol table???</a>
<a name="3756"><span class="lineNum">    3756 </span>            :                       // DQ (11/24/2011): After some thought, I think that template declarations for function are more template declarations</a>
<a name="3757"><span class="lineNum">    3757 </span>            :                       // than functions.  So all template function declarations will be handled as SgTemplateSymbols and not SgFunctionSymbols.mplate function declarations.</a>
<a name="3758"><span class="lineNum">    3758 </span><span class="lineCov">       3423 :                          SgTemplateFunctionDeclaration* templatedeclaration = isSgTemplateFunctionDeclaration(func);</span></a>
<a name="3759"><span class="lineNum">    3759 </span><span class="lineCov">       3423 :                          ROSE_ASSERT(templatedeclaration != NULL);</span></a>
<a name="3760"><span class="lineNum">    3760 </span><span class="lineCov">       3423 :                          SgTemplateFunctionSymbol* template_symbol = new SgTemplateFunctionSymbol(templatedeclaration);</span></a>
<a name="3761"><span class="lineNum">    3761 </span><span class="lineCov">       3423 :                          ROSE_ASSERT(template_symbol != NULL);</span></a>
<a name="3762"><span class="lineNum">    3762 </span><span class="lineCov">       3423 :                          ROSE_ASSERT(template_symbol-&gt;get_symbol_basis() != NULL);</span></a>
<a name="3763"><span class="lineNum">    3763 </span><span class="lineCov">       3423 :                          func_symbol = template_symbol;</span></a>
<a name="3764"><span class="lineNum">    3764 </span>            :                        }</a>
<a name="3765"><span class="lineNum">    3765 </span>            :                       else</a>
<a name="3766"><span class="lineNum">    3766 </span>            :                        {</a>
<a name="3767"><span class="lineNum">    3767 </span><span class="lineCov">     821137 :                          func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(func));</span></a>
<a name="3768"><span class="lineNum">    3768 </span><span class="lineCov">     821137 :                          ROSE_ASSERT(func_symbol-&gt;get_symbol_basis() != NULL);</span></a>
<a name="3769"><span class="lineNum">    3769 </span>            :                        }</a>
<a name="3770"><span class="lineNum">    3770 </span>            :                   }</a>
<a name="3771"><span class="lineNum">    3771 </span>            : </a>
<a name="3772"><span class="lineNum">    3772 </span><span class="lineCov">     850818 :                ROSE_ASSERT(func_symbol != NULL);</span></a>
<a name="3773"><span class="lineNum">    3773 </span><span class="lineCov">     850818 :                ROSE_ASSERT(func_symbol-&gt;get_symbol_basis() != NULL);</span></a>
<a name="3774"><span class="lineNum">    3774 </span>            : #if 0</a>
<a name="3775"><span class="lineNum">    3775 </span>            :                printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p = %s nameWithTemplateArguments = %s func_symbol = %p = %s = %s \n&quot;,</a>
<a name="3776"><span class="lineNum">    3776 </span>            :                     scope,scope-&gt;class_name().c_str(),nameWithTemplateArguments.str(),func_symbol,func_symbol-&gt;class_name().c_str(),SageInterface::get_name(func_symbol).c_str());</a>
<a name="3777"><span class="lineNum">    3777 </span>            : #endif</a>
<a name="3778"><span class="lineNum">    3778 </span>            :             // scope-&gt;insert_symbol(name, func_symbol);</a>
<a name="3779"><span class="lineNum">    3779 </span><span class="lineCov">     850818 :                scope-&gt;insert_symbol(nameWithTemplateArguments, func_symbol);</span></a>
<a name="3780"><span class="lineNum">    3780 </span>            : </a>
<a name="3781"><span class="lineNum">    3781 </span>            :             // DQ (3/8/2012): Added assertion.</a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineCov">     850818 :                ROSE_ASSERT(func-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="3783"><span class="lineNum">    3783 </span>            : </a>
<a name="3784"><span class="lineNum">    3784 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type()) != NULL);</a>
<a name="3785"><span class="lineNum">    3785 </span>            : </a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineCov">     850818 :                if (isSgFunctionDeclaration(func) == NULL)</span></a>
<a name="3787"><span class="lineNum">    3787 </span>            :                   {</a>
<a name="3788"><span class="lineNum">    3788 </span>            :                  // DQ (12/18/2011): If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.</a>
<a name="3789"><span class="lineNum">    3789 </span>            : #if 0</a>
<a name="3790"><span class="lineNum">    3790 </span>            :                     printf (&quot;In buildNondefiningFunctionDeclaration_T(): Looking up nameWithTemplateArguments = %s in scope = %p = %s \n&quot;,nameWithTemplateArguments.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="3791"><span class="lineNum">    3791 </span>            : #endif</a>
<a name="3792"><span class="lineNum">    3792 </span>            :                  // DQ (8/12/2013): Added template parameter list.</a>
<a name="3793"><span class="lineNum">    3793 </span>            :                  // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="3794"><span class="lineNum">    3794 </span>            :                  // In this case these are unavailable from this point.</a>
<a name="3795"><span class="lineNum">    3795 </span>            :                  // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="3796"><span class="lineNum">    3796 </span>            :                  // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL);</a>
<a name="3797"><span class="lineNum">    3797 </span>            :                  // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);</a>
<a name="3798"><span class="lineNum">    3798 </span>            :                  // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);</a>
<a name="3799"><span class="lineNum">    3799 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</span></a>
<a name="3800"><span class="lineNum">    3800 </span>            :                   }</a>
<a name="3801"><span class="lineNum">    3801 </span>            : </a>
<a name="3802"><span class="lineNum">    3802 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(name,func_type) != NULL);</a>
<a name="3803"><span class="lineNum">    3803 </span>            : </a>
<a name="3804"><span class="lineNum">    3804 </span>            :             // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="3805"><span class="lineNum">    3805 </span>            :             // In this case these are unavailable from this point.</a>
<a name="3806"><span class="lineNum">    3806 </span>            :             // DQ (11/25/2011): Added support for template functions.</a>
<a name="3807"><span class="lineNum">    3807 </span>            :             // DQ (2/26/2009): uncommented assertion.</a>
<a name="3808"><span class="lineNum">    3808 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?</a>
<a name="3809"><span class="lineNum">    3809 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(name) != NULL || scope-&gt;lookup_template_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?</a>
<a name="3810"><span class="lineNum">    3810 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(nameWithTemplateArguments) != NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL); // Did not pass for member function? Should we have used the mangled name?</a>
<a name="3811"><span class="lineNum">    3811 </span>            :             // Did not pass for member function? Should we have used the mangled name?</a>
<a name="3812"><span class="lineNum">    3812 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(nameWithTemplateArguments) != NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);</a>
<a name="3813"><span class="lineNum">    3813 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(nameWithTemplateArguments) != NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);</a>
<a name="3814"><span class="lineNum">    3814 </span>            : #if 0</a>
<a name="3815"><span class="lineNum">    3815 </span>            :                printf (&quot;\n ############################### \n&quot;);</a>
<a name="3816"><span class="lineNum">    3816 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): lookup_symbol: templateParameterList = %p \n&quot;,templateParameterList);</a>
<a name="3817"><span class="lineNum">    3817 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): func = %p = %s \n&quot;,func,func-&gt;class_name().c_str());</a>
<a name="3818"><span class="lineNum">    3818 </span>            : #endif</a>
<a name="3819"><span class="lineNum">    3819 </span><span class="lineCov">     850818 :                ROSE_ASSERT(buildTemplateDeclaration == false || templateParameterList != NULL);</span></a>
<a name="3820"><span class="lineNum">    3820 </span>            : #if 0</a>
<a name="3821"><span class="lineNum">    3821 </span>            :                SgSymbol* s0 = scope-&gt;lookup_template_member_function_symbol(nameWithTemplateArguments,func_type,templateParameterList);</a>
<a name="3822"><span class="lineNum">    3822 </span>            : </a>
<a name="3823"><span class="lineNum">    3823 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): lookup_template_member_function_symbol: s0 = %p \n&quot;,s0);</a>
<a name="3824"><span class="lineNum">    3824 </span>            : </a>
<a name="3825"><span class="lineNum">    3825 </span>            :                SgSymbol* s1 = scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList);</a>
<a name="3826"><span class="lineNum">    3826 </span>            : </a>
<a name="3827"><span class="lineNum">    3827 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): lookup_template_function_symbol: s1 = %p \n&quot;,s1);</a>
<a name="3828"><span class="lineNum">    3828 </span>            : </a>
<a name="3829"><span class="lineNum">    3829 </span>            :                SgSymbol* s2 = scope-&gt;lookup_function_symbol(nameWithTemplateArguments);</a>
<a name="3830"><span class="lineNum">    3830 </span>            : </a>
<a name="3831"><span class="lineNum">    3831 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): lookup_template_function_symbol: s1 = %p lookup_function_symbol: s2 = %p \n&quot;,s1,s2);</a>
<a name="3832"><span class="lineNum">    3832 </span>            : #endif</a>
<a name="3833"><span class="lineNum">    3833 </span>            :             // DQ (8/13/2013): We need to test for function symbols (which will include member function symbols),</a>
<a name="3834"><span class="lineNum">    3834 </span>            :             // template functions and template member functions. Each must be tested for seperately because template</a>
<a name="3835"><span class="lineNum">    3835 </span>            :             // functions and template member functions are not connected to derivation which non-template functions</a>
<a name="3836"><span class="lineNum">    3836 </span>            :             // and non-template member functions are connected through derivation.</a>
<a name="3837"><span class="lineNum">    3837 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(nameWithTemplateArguments) != NULL || scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</a>
<a name="3838"><span class="lineNum">    3838 </span><span class="lineCov">     850818 :                ROSE_ASSERT(scope-&gt;lookup_function_symbol(nameWithTemplateArguments) != NULL ||</span></a>
<a name="3839"><span class="lineNum">    3839 </span>            :                            scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL ||</a>
<a name="3840"><span class="lineNum">    3840 </span>            :                            scope-&gt;lookup_template_member_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</a>
<a name="3841"><span class="lineNum">    3841 </span>            : </a>
<a name="3842"><span class="lineNum">    3842 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP</a>
<a name="3843"><span class="lineNum">    3843 </span>            :             // if (scope-&gt;lookup_function_symbol(name) == NULL || scope-&gt;lookup_template_symbol(name) != NULL)</a>
<a name="3844"><span class="lineNum">    3844 </span>            :             // if (scope-&gt;lookup_function_symbol(nameWithTemplateArguments) == NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL)</a>
<a name="3845"><span class="lineNum">    3845 </span>            :             // if (scope-&gt;lookup_function_symbol(nameWithTemplateArguments) == NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL)</a>
<a name="3846"><span class="lineNum">    3846 </span>            :                if (scope-&gt;lookup_function_symbol(nameWithTemplateArguments,templateArgumentList) == NULL || scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL)</a>
<a name="3847"><span class="lineNum">    3847 </span>            :                   {</a>
<a name="3848"><span class="lineNum">    3848 </span>            :                  // Make sure this is a template function declaration...</a>
<a name="3849"><span class="lineNum">    3849 </span>            :                     printf (&quot;Need to make sure this is a template function declaration... \n&quot;);</a>
<a name="3850"><span class="lineNum">    3850 </span>            :                   }</a>
<a name="3851"><span class="lineNum">    3851 </span>            : #endif</a>
<a name="3852"><span class="lineNum">    3852 </span>            :              }</a>
<a name="3853"><span class="lineNum">    3853 </span>            : </a>
<a name="3854"><span class="lineNum">    3854 </span>            :        // DQ (12/14/2011): Added test.</a>
<a name="3855"><span class="lineNum">    3855 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func-&gt;get_scope() != NULL);</span></a>
<a name="3856"><span class="lineNum">    3856 </span>            : </a>
<a name="3857"><span class="lineNum">    3857 </span><span class="lineCov">     850818 :           if (isSgFunctionDeclaration(func) == NULL)</span></a>
<a name="3858"><span class="lineNum">    3858 </span>            :              {</a>
<a name="3859"><span class="lineNum">    3859 </span>            :             // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.</a>
<a name="3860"><span class="lineNum">    3860 </span>            : #if 0</a>
<a name="3861"><span class="lineNum">    3861 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): Looking up nameWithTemplateArguments = %s in scope = %p = %s \n&quot;,nameWithTemplateArguments.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="3862"><span class="lineNum">    3862 </span>            : #endif</a>
<a name="3863"><span class="lineNum">    3863 </span>            :             // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="3864"><span class="lineNum">    3864 </span>            :             // In this case these are unavailable from this point.</a>
<a name="3865"><span class="lineNum">    3865 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="3866"><span class="lineNum">    3866 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL);</a>
<a name="3867"><span class="lineNum">    3867 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);</a>
<a name="3868"><span class="lineNum">    3868 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);</a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</span></a>
<a name="3870"><span class="lineNum">    3870 </span>            :              }</a>
<a name="3871"><span class="lineNum">    3871 </span>            : #if 0</a>
<a name="3872"><span class="lineNum">    3872 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_firstNondefiningDeclaration(func = %p) (to itself) \n&quot;,func,func);</a>
<a name="3873"><span class="lineNum">    3873 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(func == NULL)      (to NULL) \n&quot;,func);</a>
<a name="3874"><span class="lineNum">    3874 </span>            : #endif</a>
<a name="3875"><span class="lineNum">    3875 </span><span class="lineCov">     850818 :           func-&gt;set_firstNondefiningDeclaration(func);</span></a>
<a name="3876"><span class="lineNum">    3876 </span><span class="lineCov">     850818 :           func-&gt;set_definingDeclaration(NULL);</span></a>
<a name="3877"><span class="lineNum">    3877 </span>            : </a>
<a name="3878"><span class="lineNum">    3878 </span>            :        // DQ (5/8/2016): We need to test the first defining declaration that we used.</a>
<a name="3879"><span class="lineNum">    3879 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() == func);</span></a>
<a name="3880"><span class="lineNum">    3880 </span>            : </a>
<a name="3881"><span class="lineNum">    3881 </span><span class="lineCov">     850818 :           ROSE_ASSERT(func-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="3882"><span class="lineNum">    3882 </span>            : </a>
<a name="3883"><span class="lineNum">    3883 </span>            : #if 0</a>
<a name="3884"><span class="lineNum">    3884 </span>            :        // DQ (5/8/2016): We need to test the first defining declaration that we used.</a>
<a name="3885"><span class="lineNum">    3885 </span>            :           SgTemplateFunctionDeclaration* first_nondefiningTemplateFunctionDeclaration = isSgTemplateFunctionDeclaration(func-&gt;get_firstNondefiningDeclaration());</a>
<a name="3886"><span class="lineNum">    3886 </span>            :           ROSE_ASSERT(first_nondefiningTemplateFunctionDeclaration != NULL);</a>
<a name="3887"><span class="lineNum">    3887 </span>            : </a>
<a name="3888"><span class="lineNum">    3888 </span>            :        // DQ (9/24/2015): Adding test of template parameter lists.</a>
<a name="3889"><span class="lineNum">    3889 </span>            :           if (templateParameterList-&gt;size() != first_nondefiningTemplateFunctionDeclaration-&gt;get_templateParameters().size())</a>
<a name="3890"><span class="lineNum">    3890 </span>            :              {</a>
<a name="3891"><span class="lineNum">    3891 </span>            :                printf (&quot;Error: size mismatch: case first_nondefining_declaration == NULL: templateParameterList-&gt;size() = %zu \n&quot;,templateParameterList-&gt;size());</a>
<a name="3892"><span class="lineNum">    3892 </span>            :                printf (&quot;Error: size mismatch: case first_nondefining_declaration == NULL: first_nondefiningTemplateFunctionDeclaration-&gt;get_templateParameters().size() = %zu \n&quot;,</a>
<a name="3893"><span class="lineNum">    3893 </span>            :                     first_nondefiningTemplateFunctionDeclaration-&gt;get_templateParameters().size());</a>
<a name="3894"><span class="lineNum">    3894 </span>            :              }</a>
<a name="3895"><span class="lineNum">    3895 </span>            :        // This may be OK at this point in the construction.</a>
<a name="3896"><span class="lineNum">    3896 </span>            :        // ROSE_ASSERT(templateParameterList-&gt;size() == first_nondefiningTemplateFunctionDeclaration-&gt;get_templateParameters().size());</a>
<a name="3897"><span class="lineNum">    3897 </span>            : #endif</a>
<a name="3898"><span class="lineNum">    3898 </span>            : </a>
<a name="3899"><span class="lineNum">    3899 </span>            :        // DQ (12/14/2011): Error checking</a>
<a name="3900"><span class="lineNum">    3900 </span><span class="lineCov">     850818 :           SgTemplateInstantiationMemberFunctionDecl* testMemberDecl = isSgTemplateInstantiationMemberFunctionDecl(func);</span></a>
<a name="3901"><span class="lineNum">    3901 </span><span class="lineCov">     850818 :           if (testMemberDecl != NULL)</span></a>
<a name="3902"><span class="lineNum">    3902 </span>            :              {</a>
<a name="3903"><span class="lineNum">    3903 </span><span class="lineCov">      12206 :                ROSE_ASSERT(testMemberDecl-&gt;get_scope() != NULL);</span></a>
<a name="3904"><span class="lineNum">    3904 </span>            : #if 0</a>
<a name="3905"><span class="lineNum">    3905 </span>            :                printf (&quot;testMemberDecl-&gt;get_scope() = %s \n&quot;,testMemberDecl-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="3906"><span class="lineNum">    3906 </span>            : #endif</a>
<a name="3907"><span class="lineNum">    3907 </span><span class="lineCov">      12206 :                ROSE_ASSERT(testMemberDecl-&gt;get_class_scope() != NULL);</span></a>
<a name="3908"><span class="lineNum">    3908 </span>            : #if 0</a>
<a name="3909"><span class="lineNum">    3909 </span>            :                printf (&quot;testMemberDecl-&gt;get_class_scope() = %s \n&quot;,testMemberDecl-&gt;get_class_scope()-&gt;class_name().c_str());</a>
<a name="3910"><span class="lineNum">    3910 </span>            : #endif</a>
<a name="3911"><span class="lineNum">    3911 </span><span class="lineCov">      12206 :                ROSE_ASSERT(testMemberDecl-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="3912"><span class="lineNum">    3912 </span>            :              }</a>
<a name="3913"><span class="lineNum">    3913 </span>            : #if 0</a>
<a name="3914"><span class="lineNum">    3914 </span>            :             else</a>
<a name="3915"><span class="lineNum">    3915 </span>            :              {</a>
<a name="3916"><span class="lineNum">    3916 </span>            :                SgTemplateInstantiationFunctionDecl* testNonMemberDecl = isSgTemplateInstantiationFunctionDecl(func);</a>
<a name="3917"><span class="lineNum">    3917 </span>            :                if (testNonMemberDecl != NULL)</a>
<a name="3918"><span class="lineNum">    3918 </span>            :                   {</a>
<a name="3919"><span class="lineNum">    3919 </span>            :                     ROSE_ASSERT(testNonMemberDecl-&gt;get_associatedClassDeclaration() != NULL);</a>
<a name="3920"><span class="lineNum">    3920 </span>            :                   }</a>
<a name="3921"><span class="lineNum">    3921 </span>            :              }</a>
<a name="3922"><span class="lineNum">    3922 </span>            : #endif</a>
<a name="3923"><span class="lineNum">    3923 </span>            :         }</a>
<a name="3924"><span class="lineNum">    3924 </span>            :        else</a>
<a name="3925"><span class="lineNum">    3925 </span>            :         {</a>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func_symbol != NULL);</span></a>
<a name="3927"><span class="lineNum">    3927 </span>            : </a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineCov">     310386 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="3929"><span class="lineNum">    3929 </span>            : </a>
<a name="3930"><span class="lineNum">    3930 </span>            :        // 2nd, or 3rd... prototype declaration</a>
<a name="3931"><span class="lineNum">    3931 </span>            :        // reuse function type, function symbol of previous declaration</a>
<a name="3932"><span class="lineNum">    3932 </span>            : </a>
<a name="3933"><span class="lineNum">    3933 </span>            :        // std::cout&lt;&lt;&quot;debug:SageBuilder.C: 267: &quot;&lt;&lt;&quot;found func_symbol!&quot;&lt;&lt;std::endl;</a>
<a name="3934"><span class="lineNum">    3934 </span>            :        // delete (func_type-&gt; get_argument_list ());</a>
<a name="3935"><span class="lineNum">    3935 </span>            :        // delete func_type; // bug 189</a>
<a name="3936"><span class="lineNum">    3936 </span>            : #if 0</a>
<a name="3937"><span class="lineNum">    3937 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): func_symbol = %p = %s \n&quot;,func_symbol,func_symbol-&gt;class_name().c_str());</a>
<a name="3938"><span class="lineNum">    3938 </span>            : #endif</a>
<a name="3939"><span class="lineNum">    3939 </span>            :        // func_type = func_symbol-&gt;get_declaration()-&gt;get_type();</a>
<a name="3940"><span class="lineNum">    3940 </span><span class="lineCov">     310386 :           SgNode* associatedSymbolBasis = func_symbol-&gt;get_symbol_basis();</span></a>
<a name="3941"><span class="lineNum">    3941 </span><span class="lineCov">     310386 :           ROSE_ASSERT(associatedSymbolBasis != NULL);</span></a>
<a name="3942"><span class="lineNum">    3942 </span>            : </a>
<a name="3943"><span class="lineNum">    3943 </span><span class="lineCov">     310386 :           SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(associatedSymbolBasis);</span></a>
<a name="3944"><span class="lineNum">    3944 </span><span class="lineCov">     310386 :           ROSE_ASSERT(associatedDeclaration != NULL);</span></a>
<a name="3945"><span class="lineNum">    3945 </span><span class="lineCov">     310386 :           SgFunctionDeclaration*         functionDeclaration         = isSgFunctionDeclaration(associatedDeclaration);</span></a>
<a name="3946"><span class="lineNum">    3946 </span><span class="lineCov">     310386 :           SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(associatedDeclaration);</span></a>
<a name="3947"><span class="lineNum">    3947 </span>            : #if 0</a>
<a name="3948"><span class="lineNum">    3948 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): associatedDeclaration = %p functionDeclaration = %p templateFunctionDeclaration = %p \n&quot;,</a>
<a name="3949"><span class="lineNum">    3949 </span>            :                associatedDeclaration,functionDeclaration,templateFunctionDeclaration);</a>
<a name="3950"><span class="lineNum">    3950 </span>            : #endif</a>
<a name="3951"><span class="lineNum">    3951 </span><span class="lineCov">     310386 :           if (functionDeclaration != NULL)</span></a>
<a name="3952"><span class="lineNum">    3952 </span>            :              {</a>
<a name="3953"><span class="lineNum">    3953 </span><span class="lineCov">     310386 :                func_type = functionDeclaration-&gt;get_type();</span></a>
<a name="3954"><span class="lineNum">    3954 </span>            : #if 0</a>
<a name="3955"><span class="lineNum">    3955 </span>            :             // DQ (5/8/2016): Error checking!</a>
<a name="3956"><span class="lineNum">    3956 </span>            :                if (templateFunctionDeclaration != NULL)</a>
<a name="3957"><span class="lineNum">    3957 </span>            :                   {</a>
<a name="3958"><span class="lineNum">    3958 </span>            :                     printf (&quot;In buildNondefiningFunctionDeclaration_T(): templateFunctionDeclaration-&gt;get_templateParameters().size() = %zu \n&quot;,templateFunctionDeclaration-&gt;get_templateParameters().size());</a>
<a name="3959"><span class="lineNum">    3959 </span>            :                   }</a>
<a name="3960"><span class="lineNum">    3960 </span>            : #endif</a>
<a name="3961"><span class="lineNum">    3961 </span>            :              }</a>
<a name="3962"><span class="lineNum">    3962 </span>            :             else</a>
<a name="3963"><span class="lineNum">    3963 </span>            :              {</a>
<a name="3964"><span class="lineNum">    3964 </span><span class="lineNoCov">          0 :                if (templateFunctionDeclaration != NULL)</span></a>
<a name="3965"><span class="lineNum">    3965 </span>            :                   {</a>
<a name="3966"><span class="lineNum">    3966 </span>            :                  // DQ (5/8/2016): I think this code is never executed (because a templateFunctionDeclaration</a>
<a name="3967"><span class="lineNum">    3967 </span>            :                  // is derived from a SgFunctionDeclaration, in the newer design (a few years ago)).</a>
<a name="3968"><span class="lineNum">    3968 </span>            : </a>
<a name="3969"><span class="lineNum">    3969 </span><span class="lineNoCov">          0 :                     printf (&quot;This code should not be reachable! \n&quot;);</span></a>
<a name="3970"><span class="lineNum">    3970 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="3971"><span class="lineNum">    3971 </span>            : </a>
<a name="3972"><span class="lineNum">    3972 </span>            :                     func_type = templateFunctionDeclaration-&gt;get_type();</a>
<a name="3973"><span class="lineNum">    3973 </span>            : #if 0</a>
<a name="3974"><span class="lineNum">    3974 </span>            :                     printf (&quot;In buildNondefiningFunctionDeclaration_T(): templateFunctionDeclaration-&gt;get_templateParameters().size() = %zu \n&quot;,templateFunctionDeclaration-&gt;get_templateParameters().size());</a>
<a name="3975"><span class="lineNum">    3975 </span>            : #endif</a>
<a name="3976"><span class="lineNum">    3976 </span>            :                   }</a>
<a name="3977"><span class="lineNum">    3977 </span>            :                  else</a>
<a name="3978"><span class="lineNum">    3978 </span>            :                   {</a>
<a name="3979"><span class="lineNum">    3979 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: associatedDeclaration = %p = %s \n&quot;,associatedDeclaration,associatedDeclaration-&gt;class_name().c_str());</span></a>
<a name="3980"><span class="lineNum">    3980 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="3981"><span class="lineNum">    3981 </span>            :                   }</a>
<a name="3982"><span class="lineNum">    3982 </span>            :              }</a>
<a name="3983"><span class="lineNum">    3983 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func_type != NULL);</span></a>
<a name="3984"><span class="lineNum">    3984 </span>            : </a>
<a name="3985"><span class="lineNum">    3985 </span>            :        // func = new actualFunction(name,func_type,NULL);</a>
<a name="3986"><span class="lineNum">    3986 </span><span class="lineCov">     310386 :           func = new actualFunction(nameWithTemplateArguments,func_type,NULL);</span></a>
<a name="3987"><span class="lineNum">    3987 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func != NULL);</span></a>
<a name="3988"><span class="lineNum">    3988 </span>            : </a>
<a name="3989"><span class="lineNum">    3989 </span>            : #if 0</a>
<a name="3990"><span class="lineNum">    3990 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): func-&gt;get_name() = %s func = %p = %s \n&quot;,func-&gt;get_name().str(),func,func-&gt;class_name().c_str());</a>
<a name="3991"><span class="lineNum">    3991 </span>            : #endif</a>
<a name="3992"><span class="lineNum">    3992 </span>            : </a>
<a name="3993"><span class="lineNum">    3993 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="3994"><span class="lineNum">    3994 </span>            :        // DQ (5/1/2012): Make sure that we don't have IR nodes marked as translformations.</a>
<a name="3995"><span class="lineNum">    3995 </span>            :        // This is too early a point to test since the source position has not been set for func yet.</a>
<a name="3996"><span class="lineNum">    3996 </span>            :        // detectTransformations_local(func);</a>
<a name="3997"><span class="lineNum">    3997 </span>            : #endif</a>
<a name="3998"><span class="lineNum">    3998 </span>            : #if 0</a>
<a name="3999"><span class="lineNum">    3999 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T() (part 2): constructor called to build func = %p = %s \n&quot;,func,func-&gt;class_name().c_str());</a>
<a name="4000"><span class="lineNum">    4000 </span>            :           if (isSgMemberFunctionDeclaration(func) != NULL)</a>
<a name="4001"><span class="lineNum">    4001 </span>            :              {</a>
<a name="4002"><span class="lineNum">    4002 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T() (part 2): SgCtorInitializerList = %p \n&quot;,isSgMemberFunctionDeclaration(func)-&gt;get_CtorInitializerList());</a>
<a name="4003"><span class="lineNum">    4003 </span>            :              }</a>
<a name="4004"><span class="lineNum">    4004 </span>            : #endif</a>
<a name="4005"><span class="lineNum">    4005 </span>            : </a>
<a name="4006"><span class="lineNum">    4006 </span>            :        // DQ (12/14/2011): Moved this up from below.</a>
<a name="4007"><span class="lineNum">    4007 </span><span class="lineCov">     310386 :           func-&gt;set_scope(scope);</span></a>
<a name="4008"><span class="lineNum">    4008 </span>            : </a>
<a name="4009"><span class="lineNum">    4009 </span>            :        // DQ (3/8/2012): Added assertion.</a>
<a name="4010"><span class="lineNum">    4010 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func-&gt;get_symbol_from_symbol_table() == NULL);</span></a>
<a name="4011"><span class="lineNum">    4011 </span>            : </a>
<a name="4012"><span class="lineNum">    4012 </span>            : #if 1</a>
<a name="4013"><span class="lineNum">    4013 </span>            :        // DQ (12/15/2011): Added test.</a>
<a name="4014"><span class="lineNum">    4014 </span><span class="lineCov">     310386 :           checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(func,scope);</span></a>
<a name="4015"><span class="lineNum">    4015 </span>            : #else</a>
<a name="4016"><span class="lineNum">    4016 </span>            :        // DQ (12/14/2011): We need the parent to be set so that we can call some of the test functions</a>
<a name="4017"><span class="lineNum">    4017 </span>            :        // (e.g assert that get_class_scope() for member functions).  So we set the parent to the scope</a>
<a name="4018"><span class="lineNum">    4018 </span>            :        // by default and see if this will work, else we could disable to assertion that the parent is</a>
<a name="4019"><span class="lineNum">    4019 </span>            :        // non-null in the get_class_scope() member function.</a>
<a name="4020"><span class="lineNum">    4020 </span>            :           if (isSgMemberFunctionDeclaration(func) != NULL)</a>
<a name="4021"><span class="lineNum">    4021 </span>            :              {</a>
<a name="4022"><span class="lineNum">    4022 </span>            :                printf (&quot;WARNING: setting parent of function to match scope by default \n&quot;);</a>
<a name="4023"><span class="lineNum">    4023 </span>            :                func-&gt;set_parent(scope);</a>
<a name="4024"><span class="lineNum">    4024 </span>            : </a>
<a name="4025"><span class="lineNum">    4025 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="4026"><span class="lineNum">    4026 </span>            : </a>
<a name="4027"><span class="lineNum">    4027 </span>            :                ROSE_ASSERT(scope != NULL);</a>
<a name="4028"><span class="lineNum">    4028 </span>            :                ROSE_ASSERT(isSgTemplateClassDefinition(scope) == NULL);</a>
<a name="4029"><span class="lineNum">    4029 </span>            :              }</a>
<a name="4030"><span class="lineNum">    4030 </span>            :             else</a>
<a name="4031"><span class="lineNum">    4031 </span>            :              {</a>
<a name="4032"><span class="lineNum">    4032 </span>            :                if (isSgTemplateMemberFunctionDeclaration(func) != NULL)</a>
<a name="4033"><span class="lineNum">    4033 </span>            :                   {</a>
<a name="4034"><span class="lineNum">    4034 </span>            :                     ROSE_ASSERT(isSgTemplateClassDefinition(scope) != NULL);</a>
<a name="4035"><span class="lineNum">    4035 </span>            :                   }</a>
<a name="4036"><span class="lineNum">    4036 </span>            :              }</a>
<a name="4037"><span class="lineNum">    4037 </span>            : #endif</a>
<a name="4038"><span class="lineNum">    4038 </span>            :        // we don't care if it is member function or function here for a pointer</a>
<a name="4039"><span class="lineNum">    4039 </span>            :        // SgFunctionDeclaration* prevDecl = NULL;</a>
<a name="4040"><span class="lineNum">    4040 </span>            :           SgDeclarationStatement* prevDecl = NULL;</a>
<a name="4041"><span class="lineNum">    4041 </span>            : </a>
<a name="4042"><span class="lineNum">    4042 </span>            :        // This does not handle the case of a template function declaration.</a>
<a name="4043"><span class="lineNum">    4043 </span>            :        // prevDecl = func_symbol-&gt;get_declaration();</a>
<a name="4044"><span class="lineNum">    4044 </span>            :           if (functionDeclaration != NULL)</a>
<a name="4045"><span class="lineNum">    4045 </span>            :              {</a>
<a name="4046"><span class="lineNum">    4046 </span>            : #if 0</a>
<a name="4047"><span class="lineNum">    4047 </span>            :                printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): Set prevDecl = functionDeclaration \n&quot;);</a>
<a name="4048"><span class="lineNum">    4048 </span>            : #endif</a>
<a name="4049"><span class="lineNum">    4049 </span>            :                prevDecl = functionDeclaration;</a>
<a name="4050"><span class="lineNum">    4050 </span>            :              }</a>
<a name="4051"><span class="lineNum">    4051 </span>            :             else</a>
<a name="4052"><span class="lineNum">    4052 </span>            :              {</a>
<a name="4053"><span class="lineNum">    4053 </span>            :                ROSE_ASSERT(templateFunctionDeclaration != NULL);</a>
<a name="4054"><span class="lineNum">    4054 </span>            : #if 0</a>
<a name="4055"><span class="lineNum">    4055 </span>            :                printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): Set prevDecl = templateFunctionDeclaration \n&quot;);</a>
<a name="4056"><span class="lineNum">    4056 </span>            : #endif</a>
<a name="4057"><span class="lineNum">    4057 </span>            :                prevDecl = templateFunctionDeclaration;</a>
<a name="4058"><span class="lineNum">    4058 </span>            :              }</a>
<a name="4059"><span class="lineNum">    4059 </span>            : </a>
<a name="4060"><span class="lineNum">    4060 </span><span class="lineCov">     310386 :           ROSE_ASSERT(prevDecl != NULL);</span></a>
<a name="4061"><span class="lineNum">    4061 </span>            : #if 0</a>
<a name="4062"><span class="lineNum">    4062 </span>            :           printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): prevDecl = %p = %s \n&quot;,prevDecl,prevDecl-&gt;class_name().c_str());</a>
<a name="4063"><span class="lineNum">    4063 </span>            : #endif</a>
<a name="4064"><span class="lineNum">    4064 </span>            : #if 0</a>
<a name="4065"><span class="lineNum">    4065 </span>            :           if (prevDecl == prevDecl-&gt;get_definingDeclaration())</a>
<a name="4066"><span class="lineNum">    4066 </span>            :              {</a>
<a name="4067"><span class="lineNum">    4067 </span>            :             // The symbol points to a defining declaration and now that we have added a non-defining</a>
<a name="4068"><span class="lineNum">    4068 </span>            :             // declaration we should have the symbol point to the new non-defining declaration.</a>
<a name="4069"><span class="lineNum">    4069 </span>            :             // printf (&quot;Switching declaration in functionSymbol to point to the non-defining declaration \n&quot;);</a>
<a name="4070"><span class="lineNum">    4070 </span>            : </a>
<a name="4071"><span class="lineNum">    4071 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="4072"><span class="lineNum">    4072 </span>            : </a>
<a name="4073"><span class="lineNum">    4073 </span>            :             // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used.</a>
<a name="4074"><span class="lineNum">    4074 </span>            :             // func_symbol-&gt;set_declaration(func);</a>
<a name="4075"><span class="lineNum">    4075 </span>            :                func_symbol-&gt;set_declaration(isSgFunctionDeclaration(func));</a>
<a name="4076"><span class="lineNum">    4076 </span>            : </a>
<a name="4077"><span class="lineNum">    4077 </span>            :             // DQ (11/23/2011): Added this test to support debugging the case where SgTemplateFunctionDeclarations is used.</a>
<a name="4078"><span class="lineNum">    4078 </span>            :                ROSE_ASSERT(func_symbol-&gt;get_declaration() != NULL);</a>
<a name="4079"><span class="lineNum">    4079 </span>            :              }</a>
<a name="4080"><span class="lineNum">    4080 </span>            : #else</a>
<a name="4081"><span class="lineNum">    4081 </span><span class="lineCov">     310386 :           SgFunctionSymbol *function_symbol = isSgFunctionSymbol(func_symbol);</span></a>
<a name="4082"><span class="lineNum">    4082 </span><span class="lineCov">     310386 :           if (prevDecl == prevDecl-&gt;get_definingDeclaration())</span></a>
<a name="4083"><span class="lineNum">    4083 </span>            :              {</a>
<a name="4084"><span class="lineNum">    4084 </span>            :             // The symbol points to a defining declaration and now that we have added a non-defining</a>
<a name="4085"><span class="lineNum">    4085 </span>            :             // declaration we should have the symbol point to the new non-defining declaration.</a>
<a name="4086"><span class="lineNum">    4086 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: Switching declaration in functionSymbol to point to the non-defining declaration \n&quot;);</span></a>
<a name="4087"><span class="lineNum">    4087 </span><span class="lineNoCov">          0 :                function_symbol-&gt;set_declaration(isSgFunctionDeclaration(func));</span></a>
<a name="4088"><span class="lineNum">    4088 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(function_symbol-&gt;get_declaration() != NULL);</span></a>
<a name="4089"><span class="lineNum">    4089 </span>            :              }</a>
<a name="4090"><span class="lineNum">    4090 </span>            : #endif</a>
<a name="4091"><span class="lineNum">    4091 </span>            : </a>
<a name="4092"><span class="lineNum">    4092 </span>            :        // If this is the first non-defining declaration then set the associated data member.</a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineCov">     310386 :           SgDeclarationStatement* nondefiningDeclaration = prevDecl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="4094"><span class="lineNum">    4094 </span><span class="lineCov">     310386 :           if (nondefiningDeclaration == NULL)</span></a>
<a name="4095"><span class="lineNum">    4095 </span>            :              {</a>
<a name="4096"><span class="lineNum">    4096 </span><span class="lineNoCov">          0 :                nondefiningDeclaration = func;</span></a>
<a name="4097"><span class="lineNum">    4097 </span>            :              }</a>
<a name="4098"><span class="lineNum">    4098 </span>            : </a>
<a name="4099"><span class="lineNum">    4099 </span><span class="lineCov">     310386 :           ROSE_ASSERT(nondefiningDeclaration != NULL);</span></a>
<a name="4100"><span class="lineNum">    4100 </span>            : #if 0</a>
<a name="4101"><span class="lineNum">    4101 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_firstNondefiningDeclaration(nondefiningDeclaration = %p)      (to nondefiningDeclaration) \n&quot;,func,nondefiningDeclaration);</a>
<a name="4102"><span class="lineNum">    4102 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl-&gt;get_definingDeclaration() = %p) (to prevDecl-&gt;get_definingDeclaration()) \n&quot;,func,prevDecl-&gt;get_definingDeclaration());</a>
<a name="4103"><span class="lineNum">    4103 </span>            : #endif</a>
<a name="4104"><span class="lineNum">    4104 </span>            :        // DQ (8/27/2014): Added assertions.</a>
<a name="4105"><span class="lineNum">    4105 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func != NULL);</span></a>
<a name="4106"><span class="lineNum">    4106 </span><span class="lineCov">     310386 :           ROSE_ASSERT(prevDecl != NULL);</span></a>
<a name="4107"><span class="lineNum">    4107 </span>            : </a>
<a name="4108"><span class="lineNum">    4108 </span>            :        // func-&gt;set_firstNondefiningDeclaration(prevDecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="4109"><span class="lineNum">    4109 </span><span class="lineCov">     310386 :           func-&gt;set_firstNondefiningDeclaration(nondefiningDeclaration);</span></a>
<a name="4110"><span class="lineNum">    4110 </span><span class="lineCov">     310386 :           func-&gt;set_definingDeclaration(prevDecl-&gt;get_definingDeclaration());</span></a>
<a name="4111"><span class="lineNum">    4111 </span>            : </a>
<a name="4112"><span class="lineNum">    4112 </span>            : #if 0</a>
<a name="4113"><span class="lineNum">    4113 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Setting new function (func = %p) to have firstNondefiningDeclaration = %p definingDeclaration = %p \n&quot;,func,func-&gt;get_firstNondefiningDeclaration(),func-&gt;get_definingDeclaration());</a>
<a name="4114"><span class="lineNum">    4114 </span>            : #endif</a>
<a name="4115"><span class="lineNum">    4115 </span>            :        // DQ (3/8/2012): Added assertion.</a>
<a name="4116"><span class="lineNum">    4116 </span><span class="lineCov">     310386 :           ROSE_ASSERT(nondefiningDeclaration-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="4117"><span class="lineNum">    4117 </span><span class="lineCov">     310386 :           assert(func-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="4118"><span class="lineNum">    4118 </span>            : </a>
<a name="4119"><span class="lineNum">    4119 </span>            :        // DQ (3/8/2012): If this is the redundant function prototype then we have to look</a>
<a name="4120"><span class="lineNum">    4120 </span>            :        // at the first defining declaration since only it will have an associated symbol.</a>
<a name="4121"><span class="lineNum">    4121 </span>            :        // ROSE_ASSERT(func-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="4122"><span class="lineNum">    4122 </span><span class="lineCov">     310386 :           if (func-&gt;get_symbol_from_symbol_table() == NULL)</span></a>
<a name="4123"><span class="lineNum">    4123 </span>            :              {</a>
<a name="4124"><span class="lineNum">    4124 </span><span class="lineCov">     310386 :                ROSE_ASSERT(nondefiningDeclaration != NULL);</span></a>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineCov">     310386 :                ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() == nondefiningDeclaration);</span></a>
<a name="4126"><span class="lineNum">    4126 </span>            :              }</a>
<a name="4127"><span class="lineNum">    4127 </span>            : </a>
<a name="4128"><span class="lineNum">    4128 </span>            :        // DQ (12/14/2011): Added test.</a>
<a name="4129"><span class="lineNum">    4129 </span><span class="lineCov">     310386 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="4130"><span class="lineNum">    4130 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func-&gt;get_scope() != NULL);</span></a>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineCov">     310386 :           ROSE_ASSERT(func-&gt;get_scope() == scope);</span></a>
<a name="4132"><span class="lineNum">    4132 </span>            : </a>
<a name="4133"><span class="lineNum">    4133 </span>            :        // DQ (12/14/2011): Error checking</a>
<a name="4134"><span class="lineNum">    4134 </span><span class="lineCov">     310386 :           SgTemplateInstantiationMemberFunctionDecl* testMemberDecl = isSgTemplateInstantiationMemberFunctionDecl(func);</span></a>
<a name="4135"><span class="lineNum">    4135 </span><span class="lineCov">     310386 :           if (testMemberDecl != NULL)</span></a>
<a name="4136"><span class="lineNum">    4136 </span>            :              {</a>
<a name="4137"><span class="lineNum">    4137 </span><span class="lineCov">        509 :                ROSE_ASSERT(testMemberDecl-&gt;get_scope() != NULL);</span></a>
<a name="4138"><span class="lineNum">    4138 </span><span class="lineCov">        509 :                ROSE_ASSERT(testMemberDecl-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="4139"><span class="lineNum">    4139 </span>            :              }</a>
<a name="4140"><span class="lineNum">    4140 </span>            : </a>
<a name="4141"><span class="lineNum">    4141 </span>            :        // DQ (12/18/2011): Testing to debug generation of wrong kind of declaration (symbol not found in correct scope or ...).</a>
<a name="4142"><span class="lineNum">    4142 </span><span class="lineCov">     310386 :           if (isSgFunctionDeclaration(func) == NULL)</span></a>
<a name="4143"><span class="lineNum">    4143 </span>            :              {</a>
<a name="4144"><span class="lineNum">    4144 </span>            :             // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.</a>
<a name="4145"><span class="lineNum">    4145 </span>            : #if 0</a>
<a name="4146"><span class="lineNum">    4146 </span>            :                printf (&quot;In buildNondefiningFunctionDeclaration_T(): Looking up name = %s in scope = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="4147"><span class="lineNum">    4147 </span>            : #endif</a>
<a name="4148"><span class="lineNum">    4148 </span>            :             // DQ (8/12/2013): Added template parameter list.</a>
<a name="4149"><span class="lineNum">    4149 </span>            :             // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="4150"><span class="lineNum">    4150 </span>            :             // In this case these are unavailable from this point.</a>
<a name="4151"><span class="lineNum">    4151 </span>            :             // DQ (12/18/2011): This fails because the first use of the function causes a non-defining function declaration</a>
<a name="4152"><span class="lineNum">    4152 </span>            :             // to be built and it is built as a template instantiation instead of a template declaration.  So the symbol for</a>
<a name="4153"><span class="lineNum">    4153 </span>            :             // the non-defining declaration is put into the correct scope, but as a SgMemberFunctionSymbol instead of as a</a>
<a name="4154"><span class="lineNum">    4154 </span>            :             // SgTemplateSymbol (if it were built as a SgTemplateMemberFunctionDeclaration).  So of course we can't find it</a>
<a name="4155"><span class="lineNum">    4155 </span>            :             // using lookup_template_symbol().</a>
<a name="4156"><span class="lineNum">    4156 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="4157"><span class="lineNum">    4157 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL);</a>
<a name="4158"><span class="lineNum">    4158 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);</a>
<a name="4159"><span class="lineNum">    4159 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);</a>
<a name="4160"><span class="lineNum">    4160 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</span></a>
<a name="4161"><span class="lineNum">    4161 </span>            :              }</a>
<a name="4162"><span class="lineNum">    4162 </span>            :         }</a>
<a name="4163"><span class="lineNum">    4163 </span>            : </a>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func != NULL);</span></a>
<a name="4165"><span class="lineNum">    4165 </span>            : </a>
<a name="4166"><span class="lineNum">    4166 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_file_info() == NULL);</span></a>
<a name="4167"><span class="lineNum">    4167 </span>            : </a>
<a name="4168"><span class="lineNum">    4168 </span>            :   // DQ (3/8/2012): Added assertion.</a>
<a name="4169"><span class="lineNum">    4169 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4170"><span class="lineNum">    4170 </span><span class="lineCov">    1161200 :      assert(func_symbol != NULL);</span></a>
<a name="4171"><span class="lineNum">    4171 </span><span class="lineCov">    1161200 :      assert(func_symbol-&gt;get_symbol_basis() == func-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="4172"><span class="lineNum">    4172 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_symbol_from_symbol_table() != NULL || func-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="4173"><span class="lineNum">    4173 </span>            : </a>
<a name="4174"><span class="lineNum">    4174 </span>            :   // DQ (2/24/2009): Delete the old parameter list build by the actualFunction (template argument) constructor.</a>
<a name="4175"><span class="lineNum">    4175 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_parameterList() != NULL);</span></a>
<a name="4176"><span class="lineNum">    4176 </span><span class="lineCov">    1161200 :      delete func-&gt;get_parameterList();</span></a>
<a name="4177"><span class="lineNum">    4177 </span><span class="lineCov">    1161200 :      func-&gt;set_parameterList(NULL);</span></a>
<a name="4178"><span class="lineNum">    4178 </span>            : </a>
<a name="4179"><span class="lineNum">    4179 </span>            :   // DQ (9/16/2012): Setup up the template arguments and the parents of the template arguments.</a>
<a name="4180"><span class="lineNum">    4180 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="4181"><span class="lineNum">    4181 </span>            :         {</a>
<a name="4182"><span class="lineNum">    4182 </span><span class="lineCov">      14410 :           setTemplateArgumentsInDeclaration(func,templateArgumentsList);</span></a>
<a name="4183"><span class="lineNum">    4183 </span>            :         }</a>
<a name="4184"><span class="lineNum">    4184 </span>            : </a>
<a name="4185"><span class="lineNum">    4185 </span>            :   // DQ (8/10/2013): Setup the template parameters if this is a template declaration.</a>
<a name="4186"><span class="lineNum">    4186 </span>            :      if (buildTemplateDeclaration == true)</a>
<a name="4187"><span class="lineNum">    4187 </span>            :         {</a>
<a name="4188"><span class="lineNum">    4188 </span><span class="lineCov">      13794 :           setTemplateParametersInDeclaration(func,templateParameterList);</span></a>
<a name="4189"><span class="lineNum">    4189 </span>            : #if 0</a>
<a name="4190"><span class="lineNum">    4190 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="4191"><span class="lineNum">    4191 </span>            :           ROSE_ABORT();</a>
<a name="4192"><span class="lineNum">    4192 </span>            : #endif</a>
<a name="4193"><span class="lineNum">    4193 </span>            : </a>
<a name="4194"><span class="lineNum">    4194 </span>            :        // DQ (8/13/2013): Adding test of template parameter lists.</a>
<a name="4195"><span class="lineNum">    4195 </span><span class="lineCov">      13794 :           SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(func);</span></a>
<a name="4196"><span class="lineNum">    4196 </span>            : #if 0</a>
<a name="4197"><span class="lineNum">    4197 </span>            :           if (templateFunctionDeclaration != NULL)</a>
<a name="4198"><span class="lineNum">    4198 </span>            :              {</a>
<a name="4199"><span class="lineNum">    4199 </span>            :                printf (&quot;templateFunctionDeclaration-&gt;get_templateParameters().size() = %zu \n&quot;,templateFunctionDeclaration-&gt;get_templateParameters().size());</a>
<a name="4200"><span class="lineNum">    4200 </span>            :              }</a>
<a name="4201"><span class="lineNum">    4201 </span>            : #endif</a>
<a name="4202"><span class="lineNum">    4202 </span><span class="lineCov">      13794 :           ROSE_ASSERT(templateFunctionDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateFunctionDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="4203"><span class="lineNum">    4203 </span>            : </a>
<a name="4204"><span class="lineNum">    4204 </span><span class="lineCov">      13794 :           SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(func);</span></a>
<a name="4205"><span class="lineNum">    4205 </span><span class="lineCov">      13794 :           ROSE_ASSERT(templateMemberFunctionDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateMemberFunctionDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="4206"><span class="lineNum">    4206 </span>            :         }</a>
<a name="4207"><span class="lineNum">    4207 </span>            : </a>
<a name="4208"><span class="lineNum">    4208 </span>            :   // parameter list</a>
<a name="4209"><span class="lineNum">    4209 </span>            :   // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used.</a>
<a name="4210"><span class="lineNum">    4210 </span>            :   // setParameterList(func, paralist);</a>
<a name="4211"><span class="lineNum">    4211 </span>            :   // setParameterList(isSgFunctionDeclaration(func), paralist);</a>
<a name="4212"><span class="lineNum">    4212 </span><span class="lineCov">    1161200 :      setParameterList(func, paralist);</span></a>
<a name="4213"><span class="lineNum">    4213 </span>            : </a>
<a name="4214"><span class="lineNum">    4214 </span><span class="lineCov">    2322410 :      SgInitializedNamePtrList argList = paralist-&gt;get_args();</span></a>
<a name="4215"><span class="lineNum">    4215 </span><span class="lineCov">    1161200 :      Rose_STL_Container&lt;SgInitializedName*&gt;::iterator argi;</span></a>
<a name="4216"><span class="lineNum">    4216 </span><span class="lineCov">    4325666 :      for (argi=argList.begin(); argi!=argList.end(); argi++)</span></a>
<a name="4217"><span class="lineNum">    4217 </span>            :         {</a>
<a name="4218"><span class="lineNum">    4218 </span>            :        // std::cout&lt;&lt;&quot;patching argument's scope.... &quot;&lt;&lt;std::endl;</a>
<a name="4219"><span class="lineNum">    4219 </span><span class="lineCov">    3164456 :           (*argi)-&gt;set_scope(scope);</span></a>
<a name="4220"><span class="lineNum">    4220 </span>            : </a>
<a name="4221"><span class="lineNum">    4221 </span>            :        // DQ (2/23/2009): Also set the declptr (to NULL)</a>
<a name="4222"><span class="lineNum">    4222 </span>            :        // (*argi)-&gt;set_declptr(NULL);</a>
<a name="4223"><span class="lineNum">    4223 </span>            :         }</a>
<a name="4224"><span class="lineNum">    4224 </span>            : </a>
<a name="4225"><span class="lineNum">    4225 </span>            :   // DQ (5/2/2012): Test this to make sure we have SgInitializedNames set properly.</a>
<a name="4226"><span class="lineNum">    4226 </span><span class="lineCov">    1161200 :      SageInterface::setSourcePosition(paralist);</span></a>
<a name="4227"><span class="lineNum">    4227 </span>            : </a>
<a name="4228"><span class="lineNum">    4228 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="4229"><span class="lineNum">    4229 </span>            :   // Liao 11/21/2012: we should assert no transformation only when the current model is NOT transformation</a>
<a name="4230"><span class="lineNum">    4230 </span>            :      if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="4231"><span class="lineNum">    4231 </span>            :         {</a>
<a name="4232"><span class="lineNum">    4232 </span>            :           detectTransformations_local(paralist);</a>
<a name="4233"><span class="lineNum">    4233 </span>            :         }</a>
<a name="4234"><span class="lineNum">    4234 </span>            : #endif</a>
<a name="4235"><span class="lineNum">    4235 </span>            : </a>
<a name="4236"><span class="lineNum">    4236 </span>            :   // DQ (12/14/2011): Moved this closer to top of function.</a>
<a name="4237"><span class="lineNum">    4237 </span>            :   // TODO double check if there are exceptions</a>
<a name="4238"><span class="lineNum">    4238 </span>            :   // func-&gt;set_scope(scope);</a>
<a name="4239"><span class="lineNum">    4239 </span>            : </a>
<a name="4240"><span class="lineNum">    4240 </span>            :   // DQ (12/14/2011): Added test.</a>
<a name="4241"><span class="lineNum">    4241 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="4242"><span class="lineNum">    4242 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_scope() != NULL);</span></a>
<a name="4243"><span class="lineNum">    4243 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_scope() == scope);</span></a>
<a name="4244"><span class="lineNum">    4244 </span>            : </a>
<a name="4245"><span class="lineNum">    4245 </span>            :   // DQ (1/5/2009): This is not always true (should likely use SageBuilder::topScopeStack() instead)</a>
<a name="4246"><span class="lineNum">    4246 </span><span class="lineCov">    1161200 :      if (SageBuilder::topScopeStack() != NULL) // This comparison only makes sense when topScopeStack() returns non-NULL value</span></a>
<a name="4247"><span class="lineNum">    4247 </span>            :         {</a>
<a name="4248"><span class="lineNum">    4248 </span>            :        // since  stack scope is totally optional in SageBuilder.</a>
<a name="4249"><span class="lineNum">    4249 </span><span class="lineCov">    1161197 :           if (scope != SageBuilder::topScopeStack())</span></a>
<a name="4250"><span class="lineNum">    4250 </span>            :              {</a>
<a name="4251"><span class="lineNum">    4251 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="4252"><span class="lineNum">    4252 </span>            :                printf (&quot;Warning: SageBuilder::buildNondefiningFunctionDeclaration_T(): scope parameter may not be the same as the topScopeStack() (e.g. for member functions) \n&quot;);</a>
<a name="4253"><span class="lineNum">    4253 </span>            : #endif</a>
<a name="4254"><span class="lineNum">    4254 </span>            :              }</a>
<a name="4255"><span class="lineNum">    4255 </span>            :         }</a>
<a name="4256"><span class="lineNum">    4256 </span>            : </a>
<a name="4257"><span class="lineNum">    4257 </span><span class="lineCov">    1161200 :      func-&gt;set_parent(scope);</span></a>
<a name="4258"><span class="lineNum">    4258 </span>            : </a>
<a name="4259"><span class="lineNum">    4259 </span>            :   // DQ (2/21/2009): We can't assert that this is always NULL or non-NULL.</a>
<a name="4260"><span class="lineNum">    4260 </span>            :   // ROSE_ASSERT(func-&gt;get_definingDeclaration() == NULL);</a>
<a name="4261"><span class="lineNum">    4261 </span>            : </a>
<a name="4262"><span class="lineNum">    4262 </span>            :   // DQ (2/21/2009): Added assertion</a>
<a name="4263"><span class="lineNum">    4263 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4264"><span class="lineNum">    4264 </span>            : </a>
<a name="4265"><span class="lineNum">    4265 </span>            :   // mark as a forward declartion</a>
<a name="4266"><span class="lineNum">    4266 </span><span class="lineCov">    1161200 :      func-&gt;setForward();</span></a>
<a name="4267"><span class="lineNum">    4267 </span>            : </a>
<a name="4268"><span class="lineNum">    4268 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_file_info() == NULL);</span></a>
<a name="4269"><span class="lineNum">    4269 </span>            : </a>
<a name="4270"><span class="lineNum">    4270 </span>            :   // set File_Info as transformation generated or front end generated</a>
<a name="4271"><span class="lineNum">    4271 </span><span class="lineCov">    1161200 :      setSourcePositionAtRootAndAllChildren(func);</span></a>
<a name="4272"><span class="lineNum">    4272 </span>            : </a>
<a name="4273"><span class="lineNum">    4273 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_file_info() != NULL);</span></a>
<a name="4274"><span class="lineNum">    4274 </span>            : </a>
<a name="4275"><span class="lineNum">    4275 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="4276"><span class="lineNum">    4276 </span>            :   // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.</a>
<a name="4277"><span class="lineNum">    4277 </span>            :      if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="4278"><span class="lineNum">    4278 </span>            :         {</a>
<a name="4279"><span class="lineNum">    4279 </span>            :           detectTransformations_local(func);</a>
<a name="4280"><span class="lineNum">    4280 </span>            :         }</a>
<a name="4281"><span class="lineNum">    4281 </span>            : #endif</a>
<a name="4282"><span class="lineNum">    4282 </span>            : </a>
<a name="4283"><span class="lineNum">    4283 </span>            :   // printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): generated function func = %p \n&quot;,func);</a>
<a name="4284"><span class="lineNum">    4284 </span>            : </a>
<a name="4285"><span class="lineNum">    4285 </span>            :   // Liao 12/2/2010, special handling for Fortran functions and subroutines</a>
<a name="4286"><span class="lineNum">    4286 </span><span class="lineCov">    1161200 :      if ((SageInterface::is_Fortran_language() == true) &amp;&amp; (getEnclosingFileNode(scope)-&gt;get_outputLanguage() == SgFile::e_Fortran_language))</span></a>
<a name="4287"><span class="lineNum">    4287 </span>            :         {</a>
<a name="4288"><span class="lineNum">    4288 </span><span class="lineCov">          6 :           SgProcedureHeaderStatement * f_func = isSgProcedureHeaderStatement(func);</span></a>
<a name="4289"><span class="lineNum">    4289 </span><span class="lineCov">          6 :           ROSE_ASSERT (f_func != NULL);</span></a>
<a name="4290"><span class="lineNum">    4290 </span><span class="lineCov">          6 :           if (return_type == buildVoidType())</span></a>
<a name="4291"><span class="lineNum">    4291 </span><span class="lineCov">          5 :                f_func-&gt;set_subprogram_kind(SgProcedureHeaderStatement::e_subroutine_subprogram_kind);</span></a>
<a name="4292"><span class="lineNum">    4292 </span>            :             else</a>
<a name="4293"><span class="lineNum">    4293 </span><span class="lineCov">          1 :                f_func-&gt;set_subprogram_kind(SgProcedureHeaderStatement::e_function_subprogram_kind);</span></a>
<a name="4294"><span class="lineNum">    4294 </span>            : </a>
<a name="4295"><span class="lineNum">    4295 </span>            :        // hide it from the unparser since fortran prototype func declaration is internally used by ROSE AST</a>
<a name="4296"><span class="lineNum">    4296 </span><span class="lineCov">          6 :           f_func-&gt;get_startOfConstruct()-&gt;unsetOutputInCodeGeneration();</span></a>
<a name="4297"><span class="lineNum">    4297 </span><span class="lineCov">          6 :           f_func-&gt;get_endOfConstruct()-&gt;unsetOutputInCodeGeneration();</span></a>
<a name="4298"><span class="lineNum">    4298 </span><span class="lineCov">          6 :           ROSE_ASSERT(f_func-&gt;get_startOfConstruct()-&gt;isOutputInCodeGeneration() == false);</span></a>
<a name="4299"><span class="lineNum">    4299 </span><span class="lineCov">          6 :           ROSE_ASSERT(f_func-&gt;get_endOfConstruct()-&gt;isOutputInCodeGeneration() == false);</span></a>
<a name="4300"><span class="lineNum">    4300 </span>            :         }</a>
<a name="4301"><span class="lineNum">    4301 </span>            : </a>
<a name="4302"><span class="lineNum">    4302 </span>            :   // DQ (12/11/2011): Added new test.</a>
<a name="4303"><span class="lineNum">    4303 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4304"><span class="lineNum">    4304 </span><span class="lineCov">    1161200 :      SgSymbol* symbol_from_first_nondefining_function = func-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</span></a>
<a name="4305"><span class="lineNum">    4305 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(symbol_from_first_nondefining_function != NULL);</span></a>
<a name="4306"><span class="lineNum">    4306 </span>            : </a>
<a name="4307"><span class="lineNum">    4307 </span>            : #if 0</a>
<a name="4308"><span class="lineNum">    4308 </span>            :      if (nameWithoutTemplateArguments == &quot;getline&quot;)</a>
<a name="4309"><span class="lineNum">    4309 </span>            :         {</a>
<a name="4310"><span class="lineNum">    4310 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): symbol_from_first_nondefining_function = %p \n&quot;,symbol_from_first_nondefining_function);</a>
<a name="4311"><span class="lineNum">    4311 </span>            :         }</a>
<a name="4312"><span class="lineNum">    4312 </span>            : #endif</a>
<a name="4313"><span class="lineNum">    4313 </span>            : </a>
<a name="4314"><span class="lineNum">    4314 </span>            :   // DQ (12/11/2011): Note that this may be false when func is not the first nondefining declaration.</a>
<a name="4315"><span class="lineNum">    4315 </span><span class="lineCov">    1161200 :      if (func != func-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="4316"><span class="lineNum">    4316 </span>            :         {</a>
<a name="4317"><span class="lineNum">    4317 </span><span class="lineCov">     310386 :           SgSymbol* symbol_from_nondefining_function = func-&gt;get_symbol_from_symbol_table();</span></a>
<a name="4318"><span class="lineNum">    4318 </span><span class="lineCov">     310386 :           ROSE_ASSERT(symbol_from_nondefining_function == NULL);</span></a>
<a name="4319"><span class="lineNum">    4319 </span>            :         }</a>
<a name="4320"><span class="lineNum">    4320 </span>            : </a>
<a name="4321"><span class="lineNum">    4321 </span>            :   // DQ (12/18/2011): Testing to debug generation of wrong kind of declaration (symbol not found in correct scope or ...).</a>
<a name="4322"><span class="lineNum">    4322 </span><span class="lineCov">    1161200 :      if (isSgFunctionDeclaration(func) == NULL)</span></a>
<a name="4323"><span class="lineNum">    4323 </span>            :         {</a>
<a name="4324"><span class="lineNum">    4324 </span>            :        // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.</a>
<a name="4325"><span class="lineNum">    4325 </span>            : #if 0</a>
<a name="4326"><span class="lineNum">    4326 </span>            :           printf (&quot;In buildNondefiningFunctionDeclaration_T(): Looking up nameWithTemplateArguments = %s in scope = %p = %s \n&quot;,nameWithTemplateArguments.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="4327"><span class="lineNum">    4327 </span>            : #endif</a>
<a name="4328"><span class="lineNum">    4328 </span>            :        // DQ (8/12/2013): Make sure we use the template parameters and the template arguments that are available.</a>
<a name="4329"><span class="lineNum">    4329 </span>            :        // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="4330"><span class="lineNum">    4330 </span>            :        // In this case these are unavailable from this point.</a>
<a name="4331"><span class="lineNum">    4331 </span>            :        // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="4332"><span class="lineNum">    4332 </span>            :        // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments) != NULL);</a>
<a name="4333"><span class="lineNum">    4333 </span>            :        // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);</a>
<a name="4334"><span class="lineNum">    4334 </span>            :        // ROSE_ASSERT(scope-&gt;lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);</a>
<a name="4335"><span class="lineNum">    4335 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(scope-&gt;lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);</span></a>
<a name="4336"><span class="lineNum">    4336 </span>            :         }</a>
<a name="4337"><span class="lineNum">    4337 </span>            : </a>
<a name="4338"><span class="lineNum">    4338 </span>            :   // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).</a>
<a name="4339"><span class="lineNum">    4339 </span>            :   // setTemplateNameInTemplateInstantiations(func,name);</a>
<a name="4340"><span class="lineNum">    4340 </span><span class="lineCov">    1161200 :      setTemplateNameInTemplateInstantiations(func,nameWithoutTemplateArguments);</span></a>
<a name="4341"><span class="lineNum">    4341 </span>            : </a>
<a name="4342"><span class="lineNum">    4342 </span>            : #if 0</a>
<a name="4343"><span class="lineNum">    4343 </span>            :      printf (&quot;Leaving buildNondefiningFunctionDeclaration_T(): function nameWithTemplateArguments = %s in scope = %p = %s func = %p func-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,</a>
<a name="4344"><span class="lineNum">    4344 </span>            :           nameWithTemplateArguments.str(),scope,scope-&gt;class_name().c_str(),func,func-&gt;get_firstNondefiningDeclaration());</a>
<a name="4345"><span class="lineNum">    4345 </span>            : #endif</a>
<a name="4346"><span class="lineNum">    4346 </span>            : </a>
<a name="4347"><span class="lineNum">    4347 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="4348"><span class="lineNum">    4348 </span>            :   // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.</a>
<a name="4349"><span class="lineNum">    4349 </span>            :      if (SourcePositionClassificationMode !=e_sourcePositionTransformation)</a>
<a name="4350"><span class="lineNum">    4350 </span>            :         {</a>
<a name="4351"><span class="lineNum">    4351 </span>            :           detectTransformations_local(func);</a>
<a name="4352"><span class="lineNum">    4352 </span>            :         }</a>
<a name="4353"><span class="lineNum">    4353 </span>            : #endif</a>
<a name="4354"><span class="lineNum">    4354 </span>            : </a>
<a name="4355"><span class="lineNum">    4355 </span>            :   // DQ (12/11/2012): Force the two different ways that this can be set to match (we want consistancy).</a>
<a name="4356"><span class="lineNum">    4356 </span><span class="lineCov">    1161200 :      if (functionConstVolatileFlags &amp; SgMemberFunctionType::e_restrict)</span></a>
<a name="4357"><span class="lineNum">    4357 </span>            :         {</a>
<a name="4358"><span class="lineNum">    4358 </span><span class="lineNoCov">          0 :           func-&gt;get_declarationModifier().get_typeModifier().setRestrict();</span></a>
<a name="4359"><span class="lineNum">    4359 </span>            :         }</a>
<a name="4360"><span class="lineNum">    4360 </span>            : </a>
<a name="4361"><span class="lineNum">    4361 </span>            :   // DQ (8/19/2013): Added assertion that is tested and which fails for test_3 of the RoseExample_tests directory (in edgRose.C).</a>
<a name="4362"><span class="lineNum">    4362 </span>            :   // This fails for everything.... not sure why...</a>
<a name="4363"><span class="lineNum">    4363 </span>            :   // ROSE_ASSERT(func-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="4364"><span class="lineNum">    4364 </span>            : </a>
<a name="4365"><span class="lineNum">    4365 </span>            : #if 0</a>
<a name="4366"><span class="lineNum">    4366 </span>            :      printf (&quot;In buildNondefiningFunctionDeclaration_T(): XXX_name = %s (calling unsetNodesMarkedAsModified()) \n&quot;, XXX_name.str());</a>
<a name="4367"><span class="lineNum">    4367 </span>            : #endif</a>
<a name="4368"><span class="lineNum">    4368 </span>            : </a>
<a name="4369"><span class="lineNum">    4369 </span>            :   // DQ (4/16/2015): This is replaced with a better implementation.</a>
<a name="4370"><span class="lineNum">    4370 </span>            :   // Make sure the isModified boolean is clear for all newly-parsed nodes.</a>
<a name="4371"><span class="lineNum">    4371 </span><span class="lineCov">    1161200 :      unsetNodesMarkedAsModified(func);</span></a>
<a name="4372"><span class="lineNum">    4372 </span>            : </a>
<a name="4373"><span class="lineNum">    4373 </span>            : #if 0</a>
<a name="4374"><span class="lineNum">    4374 </span>            :   // DQ (4/2/2018): Debugging case of two symbols for the same function in the same namespace (but different namespace definitions).</a>
<a name="4375"><span class="lineNum">    4375 </span>            :      if (nameWithoutTemplateArguments == &quot;getline&quot;)</a>
<a name="4376"><span class="lineNum">    4376 </span>            :         {</a>
<a name="4377"><span class="lineNum">    4377 </span>            :           printf (&quot;&amp;&amp;&amp; Leaving buildNondefiningFunctionDeclaration_T(): getline: func: func = %p = %s unparseNameToString() = %s \n&quot;,func,func-&gt;class_name().c_str(),func-&gt;unparseNameToString().c_str());</a>
<a name="4378"><span class="lineNum">    4378 </span>            :           printf (&quot;   --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4379"><span class="lineNum">    4379 </span>            :           SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);</a>
<a name="4380"><span class="lineNum">    4380 </span>            :           if (namespaceDefinition != NULL)</a>
<a name="4381"><span class="lineNum">    4381 </span>            :              {</a>
<a name="4382"><span class="lineNum">    4382 </span>            :                printf (&quot;   --- namespaceDefinition: name = %s \n&quot;,namespaceDefinition-&gt;get_namespaceDeclaration()-&gt;get_name().str());</a>
<a name="4383"><span class="lineNum">    4383 </span>            :                printf (&quot;   --- global namespace          = %p \n&quot;,namespaceDefinition-&gt;get_global_definition());</a>
<a name="4384"><span class="lineNum">    4384 </span>            :              }</a>
<a name="4385"><span class="lineNum">    4385 </span>            :             else</a>
<a name="4386"><span class="lineNum">    4386 </span>            :              {</a>
<a name="4387"><span class="lineNum">    4387 </span>            :                SgTemplateInstantiationDefn* templateInstantiationDefn = isSgTemplateInstantiationDefn(scope);</a>
<a name="4388"><span class="lineNum">    4388 </span>            :                if (templateInstantiationDefn != NULL)</a>
<a name="4389"><span class="lineNum">    4389 </span>            :                   {</a>
<a name="4390"><span class="lineNum">    4390 </span>            :                     SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(templateInstantiationDefn-&gt;get_declaration());</a>
<a name="4391"><span class="lineNum">    4391 </span>            :                     printf (&quot;   --- templateInstantiationDecl: name = %s \n&quot;,templateInstantiationDecl-&gt;get_name().str());</a>
<a name="4392"><span class="lineNum">    4392 </span>            :                   }</a>
<a name="4393"><span class="lineNum">    4393 </span>            :                  else</a>
<a name="4394"><span class="lineNum">    4394 </span>            :                   {</a>
<a name="4395"><span class="lineNum">    4395 </span>            :                     SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(scope);</a>
<a name="4396"><span class="lineNum">    4396 </span>            :                     if (templateClassDefinition != NULL)</a>
<a name="4397"><span class="lineNum">    4397 </span>            :                        {</a>
<a name="4398"><span class="lineNum">    4398 </span>            :                          SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(templateClassDefinition-&gt;get_declaration());</a>
<a name="4399"><span class="lineNum">    4399 </span>            :                          printf (&quot;   --- templateClassDeclaration: name = %s \n&quot;,templateClassDeclaration-&gt;get_name().str());</a>
<a name="4400"><span class="lineNum">    4400 </span>            : </a>
<a name="4401"><span class="lineNum">    4401 </span>            :                       // See where this is (because it happens twice in the same class).</a>
<a name="4402"><span class="lineNum">    4402 </span>            :                          templateClassDeclaration-&gt;get_file_info()-&gt;display(&quot;getline found in SgTemplateClassDeclaration: debug&quot;);</a>
<a name="4403"><span class="lineNum">    4403 </span>            : #if 0</a>
<a name="4404"><span class="lineNum">    4404 </span>            :                          printf (&quot;Output the symbol tabel used for this template declaration/definition: \n&quot;);</a>
<a name="4405"><span class="lineNum">    4405 </span>            :                          templateClassDefinition-&gt;get_symbol_table()-&gt;print(&quot;getline found in SgTemplateClassDeclaration&quot;);</a>
<a name="4406"><span class="lineNum">    4406 </span>            : #endif</a>
<a name="4407"><span class="lineNum">    4407 </span>            :                        }</a>
<a name="4408"><span class="lineNum">    4408 </span>            :                   }</a>
<a name="4409"><span class="lineNum">    4409 </span>            :              }</a>
<a name="4410"><span class="lineNum">    4410 </span>            :           printf (&quot;   --- symbol_from_first_nondefining_function = %p = %s \n&quot;,symbol_from_first_nondefining_function,symbol_from_first_nondefining_function-&gt;class_name().c_str());</a>
<a name="4411"><span class="lineNum">    4411 </span>            :         }</a>
<a name="4412"><span class="lineNum">    4412 </span>            : #endif</a>
<a name="4413"><span class="lineNum">    4413 </span>            : </a>
<a name="4414"><span class="lineNum">    4414 </span>            : #if 0</a>
<a name="4415"><span class="lineNum">    4415 </span>            :      printf (&quot;Leaving buildNondefiningFunctionDeclaration_T(): func: unparseNameToString() = %s \n&quot;,func-&gt;unparseNameToString().c_str());</a>
<a name="4416"><span class="lineNum">    4416 </span>            : #endif</a>
<a name="4417"><span class="lineNum">    4417 </span>            : </a>
<a name="4418"><span class="lineNum">    4418 </span><span class="lineCov">    1161200 :      ROSE_ASSERT(paralist-&gt;get_parent() != NULL);</span></a>
<a name="4419"><span class="lineNum">    4419 </span><span class="lineCov">    2322410 :      return func;</span></a>
<a name="4420"><span class="lineNum">    4420 </span>            :    }</a>
<a name="4421"><span class="lineNum">    4421 </span>            : </a>
<a name="4422"><span class="lineNum">    4422 </span>            : </a>
<a name="4423"><span class="lineNum">    4423 </span>            : //! Build a prototype for an existing function declaration (defining or nondefining )</a>
<a name="4424"><span class="lineNum">    4424 </span>            : SgFunctionDeclaration *</a>
<a name="4425"><span class="lineNum">    4425 </span><span class="lineNoCov">          0 : SageBuilder::buildNondefiningFunctionDeclaration (const SgFunctionDeclaration* funcdecl, SgScopeStatement* scope/*=NULL*/, SgExprListExp* decoratorList)</span></a>
<a name="4426"><span class="lineNum">    4426 </span>            : {</a>
<a name="4427"><span class="lineNum">    4427 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(funcdecl!=NULL);</span></a>
<a name="4428"><span class="lineNum">    4428 </span><span class="lineNoCov">          0 :   SgName name=funcdecl-&gt;get_name();</span></a>
<a name="4429"><span class="lineNum">    4429 </span><span class="lineNoCov">          0 :   SgFunctionType * funcType = funcdecl-&gt;get_type();</span></a>
<a name="4430"><span class="lineNum">    4430 </span><span class="lineNoCov">          0 :   SgType* return_type = funcType-&gt;get_return_type();</span></a>
<a name="4431"><span class="lineNum">    4431 </span><span class="lineNoCov">          0 :   SgFunctionParameterList* paralist = deepCopy&lt;SgFunctionParameterList&gt;(funcdecl-&gt;get_parameterList());</span></a>
<a name="4432"><span class="lineNum">    4432 </span>            : </a>
<a name="4433"><span class="lineNum">    4433 </span>            :  // make sure the function has consistent function type based on its return type and parameter list</a>
<a name="4434"><span class="lineNum">    4434 </span><span class="lineNoCov">          0 :  SgFunctionType * ref_funcType= findFunctionType (return_type, funcType-&gt;get_argument_list());</span></a>
<a name="4435"><span class="lineNum">    4435 </span>            : // ROSE_ASSERT (funcType == buildFunctionType(funcdecl-&gt;get_type()-&gt;get_return_type(), buildFunctionParameterTypeList(funcdecl-&gt;get_parameterList())));</a>
<a name="4436"><span class="lineNum">    4436 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(funcType== ref_funcType);</span></a>
<a name="4437"><span class="lineNum">    4437 </span>            : #if 0</a>
<a name="4438"><span class="lineNum">    4438 </span>            :   // DQ (2/19/2009): Fixed to handle extern &quot;C&quot; state in input &quot;funcdecl&quot;</a>
<a name="4439"><span class="lineNum">    4439 </span>            :   // return buildNondefiningFunctionDeclaration(name,return_type,paralist,scope);</a>
<a name="4440"><span class="lineNum">    4440 </span>            :   SgFunctionDeclaration* returnFunction = buildNondefiningFunctionDeclaration(name,return_type,paralist,scope,decoratorList);</a>
<a name="4441"><span class="lineNum">    4441 </span>            : #endif</a>
<a name="4442"><span class="lineNum">    4442 </span>            :   // buildNondefiningFunctionDeclaration() will check if a same function is created before by looking up function symbols.</a>
<a name="4443"><span class="lineNum">    4443 </span><span class="lineNoCov">          0 :   SgFunctionDeclaration* returnFunction  = buildNondefiningFunctionDeclaration (name, return_type, paralist, scope, decoratorList, false, NULL);</span></a>
<a name="4444"><span class="lineNum">    4444 </span>            : </a>
<a name="4445"><span class="lineNum">    4445 </span><span class="lineNoCov">          0 :   returnFunction-&gt;set_linkage(funcdecl-&gt;get_linkage());</span></a>
<a name="4446"><span class="lineNum">    4446 </span><span class="lineNoCov">          0 :   if (funcdecl-&gt;get_declarationModifier().get_storageModifier().isExtern() == true)</span></a>
<a name="4447"><span class="lineNum">    4447 </span>            :   {</a>
<a name="4448"><span class="lineNum">    4448 </span><span class="lineNoCov">          0 :     returnFunction-&gt;get_declarationModifier().get_storageModifier().setExtern();</span></a>
<a name="4449"><span class="lineNum">    4449 </span>            :   }</a>
<a name="4450"><span class="lineNum">    4450 </span>            : </a>
<a name="4451"><span class="lineNum">    4451 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (returnFunction-&gt;get_linkage() == funcdecl-&gt;get_linkage());</span></a>
<a name="4452"><span class="lineNum">    4452 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (returnFunction-&gt;get_declarationModifier().get_storageModifier().isExtern() ==</span></a>
<a name="4453"><span class="lineNum">    4453 </span>            :                funcdecl-&gt;get_declarationModifier().get_storageModifier().isExtern());</a>
<a name="4454"><span class="lineNum">    4454 </span>            : </a>
<a name="4455"><span class="lineNum">    4455 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(returnFunction-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4456"><span class="lineNum">    4456 </span>            :   // Make sure that internal references are to the same file (else the symbol table information will not be consistent).</a>
<a name="4457"><span class="lineNum">    4457 </span><span class="lineNoCov">          0 :   if (scope != NULL)</span></a>
<a name="4458"><span class="lineNum">    4458 </span>            :   {</a>
<a name="4459"><span class="lineNum">    4459 </span>            :     // ROSE_ASSERT(returnFunction-&gt;get_parent() != NULL);</a>
<a name="4460"><span class="lineNum">    4460 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(returnFunction-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4461"><span class="lineNum">    4461 </span>            :   }</a>
<a name="4462"><span class="lineNum">    4462 </span>            : </a>
<a name="4463"><span class="lineNum">    4463 </span><span class="lineNoCov">          0 :   return returnFunction;</span></a>
<a name="4464"><span class="lineNum">    4464 </span>            : }</a>
<a name="4465"><span class="lineNum">    4465 </span>            : </a>
<a name="4466"><span class="lineNum">    4466 </span>            : SgFunctionDeclaration*</a>
<a name="4467"><span class="lineNum">    4467 </span><span class="lineCov">    1130410 : SageBuilder::buildNondefiningFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList, SgStorageModifier::storage_modifier_enum sm)</span></a>
<a name="4468"><span class="lineNum">    4468 </span>            :    {</a>
<a name="4469"><span class="lineNum">    4469 </span><span class="lineCov">    1130410 :      SgFunctionDeclaration * result = NULL;</span></a>
<a name="4470"><span class="lineNum">    4470 </span><span class="lineCov">    1130410 :      if ((SageInterface::is_Fortran_language() == true) &amp;&amp; (getEnclosingFileNode(scope)-&gt;get_outputLanguage() == SgFile::e_Fortran_language))</span></a>
<a name="4471"><span class="lineNum">    4471 </span>            :         {</a>
<a name="4472"><span class="lineNum">    4472 </span><span class="lineNoCov">          0 :           result = buildNondefiningFunctionDeclaration_T &lt;SgProcedureHeaderStatement&gt; (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, NULL, sm);</span></a>
<a name="4473"><span class="lineNum">    4473 </span>            :         }</a>
<a name="4474"><span class="lineNum">    4474 </span>            :        else</a>
<a name="4475"><span class="lineNum">    4475 </span>            :         {</a>
<a name="4476"><span class="lineNum">    4476 </span>            : #if 0</a>
<a name="4477"><span class="lineNum">    4477 </span>            :           printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration(): buildTemplateInstantiation = %s \n&quot;,buildTemplateInstantiation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4478"><span class="lineNum">    4478 </span>            : #endif</a>
<a name="4479"><span class="lineNum">    4479 </span>            :        // DQ (11/27/2011): Added support to generate template declarations in the AST (this is part of a common API to make the build functions support more uniform).</a>
<a name="4480"><span class="lineNum">    4480 </span><span class="lineCov">    1130410 :           if (buildTemplateInstantiation == true)</span></a>
<a name="4481"><span class="lineNum">    4481 </span>            :              {</a>
<a name="4482"><span class="lineNum">    4482 </span><span class="lineCov">       1695 :                result = buildNondefiningFunctionDeclaration_T &lt;SgTemplateInstantiationFunctionDecl&gt; (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, templateArgumentsList, NULL, sm);</span></a>
<a name="4483"><span class="lineNum">    4483 </span>            :              }</a>
<a name="4484"><span class="lineNum">    4484 </span>            :             else</a>
<a name="4485"><span class="lineNum">    4485 </span>            :              {</a>
<a name="4486"><span class="lineNum">    4486 </span><span class="lineCov">    1128710 :                result = buildNondefiningFunctionDeclaration_T &lt;SgFunctionDeclaration&gt; (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, NULL, sm);</span></a>
<a name="4487"><span class="lineNum">    4487 </span>            :              }</a>
<a name="4488"><span class="lineNum">    4488 </span>            :         }</a>
<a name="4489"><span class="lineNum">    4489 </span>            : </a>
<a name="4490"><span class="lineNum">    4490 </span><span class="lineCov">    1130410 :      return result;</span></a>
<a name="4491"><span class="lineNum">    4491 </span>            :    }</a>
<a name="4492"><span class="lineNum">    4492 </span>            : </a>
<a name="4493"><span class="lineNum">    4493 </span>            : </a>
<a name="4494"><span class="lineNum">    4494 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).</a>
<a name="4495"><span class="lineNum">    4495 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="4496"><span class="lineNum">    4496 </span>            : SgMemberFunctionDeclaration*</a>
<a name="4497"><span class="lineNum">    4497 </span><span class="lineCov">          1 : SageBuilder::buildNondefiningMemberFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)</span></a>
<a name="4498"><span class="lineNum">    4498 </span>            :    {</a>
<a name="4499"><span class="lineNum">    4499 </span><span class="lineCov">          1 :      unsigned int memberFunctionModifiers = 0;</span></a>
<a name="4500"><span class="lineNum">    4500 </span><span class="lineCov">          1 :      return buildNondefiningMemberFunctionDeclaration (name,return_type,paralist,scope,NULL,memberFunctionModifiers,false,NULL);</span></a>
<a name="4501"><span class="lineNum">    4501 </span>            :    }</a>
<a name="4502"><span class="lineNum">    4502 </span>            : </a>
<a name="4503"><span class="lineNum">    4503 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficient).</a>
<a name="4504"><span class="lineNum">    4504 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="4505"><span class="lineNum">    4505 </span>            : SgMemberFunctionDeclaration*</a>
<a name="4506"><span class="lineNum">    4506 </span><span class="lineCov">          1 : SageBuilder::buildDefiningMemberFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)</span></a>
<a name="4507"><span class="lineNum">    4507 </span>            :    {</a>
<a name="4508"><span class="lineNum">    4508 </span><span class="lineCov">          1 :      unsigned int memberFunctionModifiers = 0;</span></a>
<a name="4509"><span class="lineNum">    4509 </span>            :   // each defining member function decl must have a non-defining counter part now. 11/27/2012, Liao</a>
<a name="4510"><span class="lineNum">    4510 </span><span class="lineCov">          1 :      SgMemberFunctionDeclaration* nondefining_decl = buildNondefiningMemberFunctionDeclaration (name, return_type, paralist, scope,NULL, memberFunctionModifiers, false, NULL);</span></a>
<a name="4511"><span class="lineNum">    4511 </span><span class="lineCov">          1 :      return buildDefiningMemberFunctionDeclaration (name,return_type,paralist,scope,NULL,false,memberFunctionModifiers,nondefining_decl,NULL);</span></a>
<a name="4512"><span class="lineNum">    4512 </span>            :    }</a>
<a name="4513"><span class="lineNum">    4513 </span>            : </a>
<a name="4514"><span class="lineNum">    4514 </span>            : </a>
<a name="4515"><span class="lineNum">    4515 </span>            : // SgTemplateFunctionDeclaration* SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList)</a>
<a name="4516"><span class="lineNum">    4516 </span>            : // SgTemplateFunctionDeclaration* SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateArgumentPtrList* templateArgumentsList)</a>
<a name="4517"><span class="lineNum">    4517 </span>            : SgTemplateFunctionDeclaration*</a>
<a name="4518"><span class="lineNum">    4518 </span><span class="lineCov">       3735 : SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateParameterPtrList* templateParameterList)</span></a>
<a name="4519"><span class="lineNum">    4519 </span>            :    {</a>
<a name="4520"><span class="lineNum">    4520 </span>            : #if 0</a>
<a name="4521"><span class="lineNum">    4521 </span>            :   printf(&quot;In SageBuilder::buildNondefiningTemplateFunctionDeclaration(name = %s):\n&quot;, name.str());</a>
<a name="4522"><span class="lineNum">    4522 </span>            : #endif</a>
<a name="4523"><span class="lineNum">    4523 </span>            : </a>
<a name="4524"><span class="lineNum">    4524 </span>            :   // DQ (8/15/2013): Note that we don't need template arguments because teplate functions can't support partial specialization.</a>
<a name="4525"><span class="lineNum">    4525 </span>            : </a>
<a name="4526"><span class="lineNum">    4526 </span>            :   // DQ (11/25/2011): Adding support for template declarations in the AST.</a>
<a name="4527"><span class="lineNum">    4527 </span>            : </a>
<a name="4528"><span class="lineNum">    4528 </span>            :   // DQ (8/7/2013): Added support for template function overloading using template parameters.</a>
<a name="4529"><span class="lineNum">    4529 </span><span class="lineCov">       3735 :      SgTemplateFunctionDeclaration* result = buildNondefiningFunctionDeclaration_T &lt;SgTemplateFunctionDeclaration&gt; (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, templateParameterList, SgStorageModifier::e_default);</span></a>
<a name="4530"><span class="lineNum">    4530 </span>            : </a>
<a name="4531"><span class="lineNum">    4531 </span>            : #if 0</a>
<a name="4532"><span class="lineNum">    4532 </span>            :   // Optional debugging.</a>
<a name="4533"><span class="lineNum">    4533 </span>            :   // DQ (9/24/2015): Added more testing (for boost 1.54 and test2015_62.C).</a>
<a name="4534"><span class="lineNum">    4534 </span>            :      ROSE_ASSERT(result != NULL);</a>
<a name="4535"><span class="lineNum">    4535 </span>            :      ROSE_ASSERT(templateParameterList != NULL);</a>
<a name="4536"><span class="lineNum">    4536 </span>            :      ROSE_ASSERT(result-&gt;get_templateParameters().size() == templateParameterList-&gt;size());</a>
<a name="4537"><span class="lineNum">    4537 </span>            :      SgTemplateFunctionDeclaration* firstNondefining_result = isSgTemplateFunctionDeclaration(result-&gt;get_firstNondefiningDeclaration());</a>
<a name="4538"><span class="lineNum">    4538 </span>            :      ROSE_ASSERT(firstNondefining_result != NULL);</a>
<a name="4539"><span class="lineNum">    4539 </span>            :      if (firstNondefining_result-&gt;get_templateParameters().size() != templateParameterList-&gt;size())</a>
<a name="4540"><span class="lineNum">    4540 </span>            :         {</a>
<a name="4541"><span class="lineNum">    4541 </span>            :           printf (&quot;name   = %s \n&quot;,name.str());</a>
<a name="4542"><span class="lineNum">    4542 </span>            :           printf (&quot;result = %p \n&quot;,result);</a>
<a name="4543"><span class="lineNum">    4543 </span>            :           ROSE_ASSERT(scope != NULL);</a>
<a name="4544"><span class="lineNum">    4544 </span>            :           printf (&quot;scope  = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4545"><span class="lineNum">    4545 </span>            :           printf (&quot;firstNondefining_result = %p \n&quot;,firstNondefining_result);</a>
<a name="4546"><span class="lineNum">    4546 </span>            :           printf (&quot;templateParameterList-&gt;size()                            = %zu \n&quot;,templateParameterList-&gt;size());</a>
<a name="4547"><span class="lineNum">    4547 </span>            :           printf (&quot;firstNondefining_result-&gt;get_templateParameters().size() = %zu \n&quot;,firstNondefining_result-&gt;get_templateParameters().size());</a>
<a name="4548"><span class="lineNum">    4548 </span>            :           firstNondefining_result-&gt;get_startOfConstruct()-&gt;display(&quot;Error: firstNondefining_result-&gt;get_templateParameters().size() == templateParameterList-&gt;size()&quot;);</a>
<a name="4549"><span class="lineNum">    4549 </span>            :         }</a>
<a name="4550"><span class="lineNum">    4550 </span>            :      ROSE_ASSERT(firstNondefining_result-&gt;get_templateParameters().size() == templateParameterList-&gt;size());</a>
<a name="4551"><span class="lineNum">    4551 </span>            : #endif</a>
<a name="4552"><span class="lineNum">    4552 </span>            : </a>
<a name="4553"><span class="lineNum">    4553 </span>            :   // DQ (12/12/2011): Added test.</a>
<a name="4554"><span class="lineNum">    4554 </span><span class="lineCov">       3735 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="4555"><span class="lineNum">    4555 </span><span class="lineCov">       3735 :      if (result-&gt;get_symbol_from_symbol_table() == NULL)</span></a>
<a name="4556"><span class="lineNum">    4556 </span>            :         {</a>
<a name="4557"><span class="lineNum">    4557 </span>            : #if 0</a>
<a name="4558"><span class="lineNum">    4558 </span>            :           printf (&quot;In SageBuilder::buildNondefiningTemplateFunctionDeclaration(): result-&gt;get_symbol_from_symbol_table() == NULL \n&quot;);</a>
<a name="4559"><span class="lineNum">    4559 </span>            : #endif</a>
<a name="4560"><span class="lineNum">    4560 </span><span class="lineCov">        312 :           ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4561"><span class="lineNum">    4561 </span><span class="lineCov">        312 :           ROSE_ASSERT(result != result-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="4562"><span class="lineNum">    4562 </span><span class="lineCov">        312 :           ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="4563"><span class="lineNum">    4563 </span>            :         }</a>
<a name="4564"><span class="lineNum">    4564 </span>            :        else</a>
<a name="4565"><span class="lineNum">    4565 </span>            :         {</a>
<a name="4566"><span class="lineNum">    4566 </span>            : #if 0</a>
<a name="4567"><span class="lineNum">    4567 </span>            :        // DQ (2/12/2015): Added debugging code.</a>
<a name="4568"><span class="lineNum">    4568 </span>            :           printf (&quot;In SageBuilder::buildNondefiningTemplateFunctionDeclaration(): result-&gt;get_symbol_from_symbol_table() != NULL \n&quot;);</a>
<a name="4569"><span class="lineNum">    4569 </span>            :           SgSymbol* symbol = result-&gt;get_symbol_from_symbol_table();</a>
<a name="4570"><span class="lineNum">    4570 </span>            :           printf (&quot;symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="4571"><span class="lineNum">    4571 </span>            :           SgTemplateSymbol* templateSymbol = isSgTemplateSymbol(symbol);</a>
<a name="4572"><span class="lineNum">    4572 </span>            :           if (templateSymbol != NULL)</a>
<a name="4573"><span class="lineNum">    4573 </span>            :              {</a>
<a name="4574"><span class="lineNum">    4574 </span>            :                printf (&quot;Found SgTemplateSymbol \n&quot;);</a>
<a name="4575"><span class="lineNum">    4575 </span>            :              }</a>
<a name="4576"><span class="lineNum">    4576 </span>            : #endif</a>
<a name="4577"><span class="lineNum">    4577 </span>            :         }</a>
<a name="4578"><span class="lineNum">    4578 </span>            : </a>
<a name="4579"><span class="lineNum">    4579 </span>            :   // DQ (12/15/2011): We can't inforce this if it is not the first non-defining declaration (but we test for this above).</a>
<a name="4580"><span class="lineNum">    4580 </span>            :   // ROSE_ASSERT(result-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="4581"><span class="lineNum">    4581 </span>            : </a>
<a name="4582"><span class="lineNum">    4582 </span>            :   // DQ (2/12/2015): Added assertions earlier before calling buildDefiningFunctionDeclaration_T&lt;&gt;().</a>
<a name="4583"><span class="lineNum">    4583 </span><span class="lineCov">       3735 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4584"><span class="lineNum">    4584 </span>            : #if 0</a>
<a name="4585"><span class="lineNum">    4585 </span>            :      if (result-&gt;get_firstNondefiningDeclaration() != result)</a>
<a name="4586"><span class="lineNum">    4586 </span>            :         {</a>
<a name="4587"><span class="lineNum">    4587 </span>            :           printf (&quot;In SageBuilder::buildNondefiningTemplateFunctionDeclaration(): result-&gt;get_firstNondefiningDeclaration() = %p != result = %p: this is likely an additional prototype function \n&quot;,result-&gt;get_firstNondefiningDeclaration(),result);</a>
<a name="4588"><span class="lineNum">    4588 </span>            :           result-&gt;get_firstNondefiningDeclaration()-&gt;get_file_info()-&gt;display(&quot;In SageBuilder::buildNondefiningTemplateFunctionDeclaration(): result-&gt;get_firstNondefiningDeclaration() != result: debug&quot;);</a>
<a name="4589"><span class="lineNum">    4589 </span>            :         }</a>
<a name="4590"><span class="lineNum">    4590 </span>            : #endif</a>
<a name="4591"><span class="lineNum">    4591 </span>            :   // ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() == result);</a>
<a name="4592"><span class="lineNum">    4592 </span>            : </a>
<a name="4593"><span class="lineNum">    4593 </span><span class="lineCov">       3735 :      return result;</span></a>
<a name="4594"><span class="lineNum">    4594 </span>            :    }</a>
<a name="4595"><span class="lineNum">    4595 </span>            : </a>
<a name="4596"><span class="lineNum">    4596 </span>            : SgTemplateFunctionDeclaration*</a>
<a name="4597"><span class="lineNum">    4597 </span><span class="lineCov">       3199 : SageBuilder::buildDefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateFunctionDeclaration* first_nondefining_declaration)</span></a>
<a name="4598"><span class="lineNum">    4598 </span>            :    {</a>
<a name="4599"><span class="lineNum">    4599 </span>            :   // DQ (12/1/2011): Adding support for template declarations in the AST.</a>
<a name="4600"><span class="lineNum">    4600 </span>            : </a>
<a name="4601"><span class="lineNum">    4601 </span>            :   // DQ (7/31/2013): Added assertions earlier before calling buildDefiningFunctionDeclaration_T&lt;&gt;().</a>
<a name="4602"><span class="lineNum">    4602 </span><span class="lineCov">       3199 :      ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="4603"><span class="lineNum">    4603 </span><span class="lineCov">       3199 :      ROSE_ASSERT(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4604"><span class="lineNum">    4604 </span><span class="lineCov">       3199 :      ROSE_ASSERT(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() == first_nondefining_declaration);</span></a>
<a name="4605"><span class="lineNum">    4605 </span>            : </a>
<a name="4606"><span class="lineNum">    4606 </span>            :   // template &lt;class actualFunction&gt; actualFunction * buildDefiningFunctionDeclaration_T (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL);</a>
<a name="4607"><span class="lineNum">    4607 </span>            :   // SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T &lt;SgTemplateFunctionDeclaration&gt; (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList,functionConstVolatileFlags);</a>
<a name="4608"><span class="lineNum">    4608 </span>            :   // SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T &lt;SgTemplateFunctionDeclaration&gt; (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList, 0, first_nondefining_declaration);</a>
<a name="4609"><span class="lineNum">    4609 </span><span class="lineCov">       3199 :      SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T &lt;SgTemplateFunctionDeclaration&gt; (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList, 0, first_nondefining_declaration, NULL);</span></a>
<a name="4610"><span class="lineNum">    4610 </span>            : </a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineCov">       3199 :      return result;</span></a>
<a name="4612"><span class="lineNum">    4612 </span>            :    }</a>
<a name="4613"><span class="lineNum">    4613 </span>            : </a>
<a name="4614"><span class="lineNum">    4614 </span>            : SgTemplateMemberFunctionDeclaration*</a>
<a name="4615"><span class="lineNum">    4615 </span><span class="lineCov">       7877 : SageBuilder::buildDefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateMemberFunctionDeclaration* first_nondefining_declaration)</span></a>
<a name="4616"><span class="lineNum">    4616 </span>            :    {</a>
<a name="4617"><span class="lineNum">    4617 </span>            :   // DQ (12/1/2011): Adding support for template declarations in the AST.</a>
<a name="4618"><span class="lineNum">    4618 </span>            : </a>
<a name="4619"><span class="lineNum">    4619 </span><span class="lineCov">       7877 :      assert(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() == first_nondefining_declaration);</span></a>
<a name="4620"><span class="lineNum">    4620 </span>            : </a>
<a name="4621"><span class="lineNum">    4621 </span><span class="lineCov">       7877 :      SgTemplateMemberFunctionDeclaration* result = buildDefiningFunctionDeclaration_T &lt;SgTemplateMemberFunctionDeclaration&gt; (name,return_type,paralist, /* isMemberFunction = */ true, scope, decoratorList, functionConstVolatileFlags, first_nondefining_declaration, NULL);</span></a>
<a name="4622"><span class="lineNum">    4622 </span><span class="lineCov">       7877 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="4623"><span class="lineNum">    4623 </span>            : </a>
<a name="4624"><span class="lineNum">    4624 </span><span class="lineCov">       7877 :      ROSE_ASSERT(result-&gt;get_definition() != NULL);</span></a>
<a name="4625"><span class="lineNum">    4625 </span>            : </a>
<a name="4626"><span class="lineNum">    4626 </span>            : #if 0</a>
<a name="4627"><span class="lineNum">    4627 </span>            :      printf (&quot;This function is not yet finished being implemented in the build API! \n&quot;);</a>
<a name="4628"><span class="lineNum">    4628 </span>            :      ROSE_ABORT();</a>
<a name="4629"><span class="lineNum">    4629 </span>            : #endif</a>
<a name="4630"><span class="lineNum">    4630 </span>            : </a>
<a name="4631"><span class="lineNum">    4631 </span><span class="lineCov">       7877 :      return result;</span></a>
<a name="4632"><span class="lineNum">    4632 </span>            :    }</a>
<a name="4633"><span class="lineNum">    4633 </span>            : </a>
<a name="4634"><span class="lineNum">    4634 </span>            : </a>
<a name="4635"><span class="lineNum">    4635 </span>            : #if 0</a>
<a name="4636"><span class="lineNum">    4636 </span>            : // DQ (3/20/2017): This function is not used (so let's see if we can remove it).</a>
<a name="4637"><span class="lineNum">    4637 </span>            : //! Build a prototype for an existing member function declaration (defining or nondefining )</a>
<a name="4638"><span class="lineNum">    4638 </span>            : SgMemberFunctionDeclaration *</a>
<a name="4639"><span class="lineNum">    4639 </span>            : SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgMemberFunctionDeclaration* funcdecl, SgScopeStatement* scope/*=NULL*/, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags)</a>
<a name="4640"><span class="lineNum">    4640 </span>            :    {</a>
<a name="4641"><span class="lineNum">    4641 </span>            :      ROSE_ASSERT(funcdecl!=NULL);</a>
<a name="4642"><span class="lineNum">    4642 </span>            :      SgName name = funcdecl-&gt;get_name();</a>
<a name="4643"><span class="lineNum">    4643 </span>            : </a>
<a name="4644"><span class="lineNum">    4644 </span>            :   // DQ (2/19/2009): Fixed to handle extern &quot;C&quot; state in input &quot;funcdecl&quot;</a>
<a name="4645"><span class="lineNum">    4645 </span>            :   // return buildNondefiningFunctionDeclaration(name,return_type,paralist,scope);</a>
<a name="4646"><span class="lineNum">    4646 </span>            :   // SgMemberFunctionDeclaration* returnFunction = buildNondefiningMemberFunctionDeclaration(name,return_type,paralist,scope,decoratorList);</a>
<a name="4647"><span class="lineNum">    4647 </span>            : </a>
<a name="4648"><span class="lineNum">    4648 </span>            : #if 1</a>
<a name="4649"><span class="lineNum">    4649 </span>            : // DQ (7/26/2012): I am at least temporarily removing this function from the API.</a>
<a name="4650"><span class="lineNum">    4650 </span>            : // Later if we need it, we can update it to reflect that passing of the new</a>
<a name="4651"><span class="lineNum">    4651 </span>            : // SgTemplateArgumentPtrList function parameter (part of the new API design).</a>
<a name="4652"><span class="lineNum">    4652 </span>            : </a>
<a name="4653"><span class="lineNum">    4653 </span>            :    SgMemberFunctionDeclaration* returnFunction = NULL;</a>
<a name="4654"><span class="lineNum">    4654 </span>            :    printf (&quot;Error: buildNondefiningMemberFunctionDeclaration(): This function should not be used! \n&quot;);</a>
<a name="4655"><span class="lineNum">    4655 </span>            :    ROSE_ABORT();</a>
<a name="4656"><span class="lineNum">    4656 </span>            : #else</a>
<a name="4657"><span class="lineNum">    4657 </span>            :      SgFunctionType * funcType = funcdecl-&gt;get_type();</a>
<a name="4658"><span class="lineNum">    4658 </span>            :      SgType* return_type = funcType-&gt;get_return_type();</a>
<a name="4659"><span class="lineNum">    4659 </span>            :      SgFunctionParameterList* paralist = deepCopy&lt;SgFunctionParameterList&gt;(funcdecl-&gt;get_parameterList());</a>
<a name="4660"><span class="lineNum">    4660 </span>            :      SgMemberFunctionDeclaration* returnFunction = buildNondefiningMemberFunctionDeclaration(name,return_type,paralist,scope,decoratorList,functionConstVolatileFlags);</a>
<a name="4661"><span class="lineNum">    4661 </span>            : #endif</a>
<a name="4662"><span class="lineNum">    4662 </span>            : </a>
<a name="4663"><span class="lineNum">    4663 </span>            :      returnFunction-&gt;set_linkage(funcdecl-&gt;get_linkage());</a>
<a name="4664"><span class="lineNum">    4664 </span>            : </a>
<a name="4665"><span class="lineNum">    4665 </span>            :      if (funcdecl-&gt;get_declarationModifier().get_storageModifier().isExtern() == true)</a>
<a name="4666"><span class="lineNum">    4666 </span>            :         {</a>
<a name="4667"><span class="lineNum">    4667 </span>            :           returnFunction-&gt;get_declarationModifier().get_storageModifier().setExtern();</a>
<a name="4668"><span class="lineNum">    4668 </span>            :         }</a>
<a name="4669"><span class="lineNum">    4669 </span>            : </a>
<a name="4670"><span class="lineNum">    4670 </span>            :   // DQ (2/26/2009): Make this consistant with the non-member functions.</a>
<a name="4671"><span class="lineNum">    4671 </span>            :   // ROSE_ASSERT(returnFunction-&gt;get_definingDeclaration() == NULL);</a>
<a name="4672"><span class="lineNum">    4672 </span>            :      ROSE_ASSERT(returnFunction-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="4673"><span class="lineNum">    4673 </span>            : </a>
<a name="4674"><span class="lineNum">    4674 </span>            :      return returnFunction;</a>
<a name="4675"><span class="lineNum">    4675 </span>            :    }</a>
<a name="4676"><span class="lineNum">    4676 </span>            : #endif</a>
<a name="4677"><span class="lineNum">    4677 </span>            : </a>
<a name="4678"><span class="lineNum">    4678 </span>            : SgMemberFunctionDeclaration*</a>
<a name="4679"><span class="lineNum">    4679 </span><span class="lineCov">      16995 : SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope,</span></a>
<a name="4680"><span class="lineNum">    4680 </span>            :    SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList)</a>
<a name="4681"><span class="lineNum">    4681 </span>            :    {</a>
<a name="4682"><span class="lineNum">    4682 </span>            :   // This function builds either a SgMemberFunctionDeclaration (non-template; normal member function) or a SgTemplateInstantiationMemberFunctionDecl (template instantiation).</a>
<a name="4683"><span class="lineNum">    4683 </span>            : </a>
<a name="4684"><span class="lineNum">    4684 </span>            :   // DQ (11/27/2011): Added support for instations of template member functions.</a>
<a name="4685"><span class="lineNum">    4685 </span><span class="lineCov">      16995 :      SgMemberFunctionDeclaration * result = NULL;</span></a>
<a name="4686"><span class="lineNum">    4686 </span>            : </a>
<a name="4687"><span class="lineNum">    4687 </span>            : #if 0</a>
<a name="4688"><span class="lineNum">    4688 </span>            :      printf (&quot;In buildNondefiningMemberFunctionDeclaration(): buildTemplateInstantiation = %s \n&quot;,buildTemplateInstantiation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4689"><span class="lineNum">    4689 </span>            : #endif</a>
<a name="4690"><span class="lineNum">    4690 </span>            : </a>
<a name="4691"><span class="lineNum">    4691 </span><span class="lineCov">      16995 :      if (buildTemplateInstantiation == true)</span></a>
<a name="4692"><span class="lineNum">    4692 </span>            :         {</a>
<a name="4693"><span class="lineNum">    4693 </span>            :        // This is how we build an instantiation of a template (SgTemplateInstantiationMemberFunctionDecl).</a>
<a name="4694"><span class="lineNum">    4694 </span><span class="lineCov">      12715 :           result = buildNondefiningFunctionDeclaration_T &lt;SgTemplateInstantiationMemberFunctionDecl&gt; (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,templateArgumentsList,NULL, SgStorageModifier::e_default);</span></a>
<a name="4695"><span class="lineNum">    4695 </span>            :         }</a>
<a name="4696"><span class="lineNum">    4696 </span>            :        else</a>
<a name="4697"><span class="lineNum">    4697 </span>            :         {</a>
<a name="4698"><span class="lineNum">    4698 </span>            :        // This is a non-template instatiation (normal member function).</a>
<a name="4699"><span class="lineNum">    4699 </span><span class="lineCov">       4280 :           result = buildNondefiningFunctionDeclaration_T &lt;SgMemberFunctionDeclaration&gt; (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,NULL,NULL, SgStorageModifier::e_default);</span></a>
<a name="4700"><span class="lineNum">    4700 </span>            :         }</a>
<a name="4701"><span class="lineNum">    4701 </span><span class="lineCov">      16995 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="4702"><span class="lineNum">    4702 </span>            : </a>
<a name="4703"><span class="lineNum">    4703 </span>            :   // set definingdecl for SgCtorInitializerList</a>
<a name="4704"><span class="lineNum">    4704 </span><span class="lineCov">      16995 :      SgCtorInitializerList* ctor = result-&gt;get_CtorInitializerList();</span></a>
<a name="4705"><span class="lineNum">    4705 </span><span class="lineCov">      16995 :      ROSE_ASSERT(ctor != NULL);</span></a>
<a name="4706"><span class="lineNum">    4706 </span>            : </a>
<a name="4707"><span class="lineNum">    4707 </span>            :   // required in AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()</a>
<a name="4708"><span class="lineNum">    4708 </span><span class="lineCov">      16995 :      ctor-&gt;set_definingDeclaration(ctor);</span></a>
<a name="4709"><span class="lineNum">    4709 </span><span class="lineCov">      16995 :      ctor-&gt;set_firstNondefiningDeclaration(ctor);</span></a>
<a name="4710"><span class="lineNum">    4710 </span>            : </a>
<a name="4711"><span class="lineNum">    4711 </span>            :   // DQ (1/4/2009): Error checking</a>
<a name="4712"><span class="lineNum">    4712 </span><span class="lineCov">      16995 :      ROSE_ASSERT(result-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="4713"><span class="lineNum">    4713 </span>            : </a>
<a name="4714"><span class="lineNum">    4714 </span><span class="lineCov">      16995 :      if (result-&gt;get_associatedClassDeclaration() == NULL)</span></a>
<a name="4715"><span class="lineNum">    4715 </span>            :         {</a>
<a name="4716"><span class="lineNum">    4716 </span><span class="lineNoCov">          0 :           printf (&quot;Warning, must set the SgMemberFunctionDeclaration::associatedClassDeclaration \n&quot;);</span></a>
<a name="4717"><span class="lineNum">    4717 </span>            : </a>
<a name="4718"><span class="lineNum">    4718 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="4719"><span class="lineNum">    4719 </span><span class="lineNoCov">          0 :           SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="4720"><span class="lineNum">    4720 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="4721"><span class="lineNum">    4721 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* associatedDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="4722"><span class="lineNum">    4722 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(associatedDeclaration != NULL);</span></a>
<a name="4723"><span class="lineNum">    4723 </span><span class="lineNoCov">          0 :           SgClassDeclaration* associatedClassDeclaration = isSgClassDeclaration(associatedDeclaration);</span></a>
<a name="4724"><span class="lineNum">    4724 </span>            : </a>
<a name="4725"><span class="lineNum">    4725 </span>            :        // DQ (1/4/2009): This needs to be set, checked in AstConsistencyTests.C!</a>
<a name="4726"><span class="lineNum">    4726 </span><span class="lineNoCov">          0 :           result-&gt;set_associatedClassDeclaration(associatedClassDeclaration);</span></a>
<a name="4727"><span class="lineNum">    4727 </span>            :         }</a>
<a name="4728"><span class="lineNum">    4728 </span>            : </a>
<a name="4729"><span class="lineNum">    4729 </span>            : #if 0</a>
<a name="4730"><span class="lineNum">    4730 </span>            :      printf (&quot;In buildNondefiningMemberFunctionDeclaration(): result = %p result-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,result,result-&gt;get_firstNondefiningDeclaration());</a>
<a name="4731"><span class="lineNum">    4731 </span>            : #endif</a>
<a name="4732"><span class="lineNum">    4732 </span>            : </a>
<a name="4733"><span class="lineNum">    4733 </span><span class="lineCov">      16995 :      return result;</span></a>
<a name="4734"><span class="lineNum">    4734 </span>            :    }</a>
<a name="4735"><span class="lineNum">    4735 </span>            : </a>
<a name="4736"><span class="lineNum">    4736 </span>            : </a>
<a name="4737"><span class="lineNum">    4737 </span>            : // DQ (8/12/2013): This function needs to handle the SgTemplateParameterPtrList (since it is generating a template).</a>
<a name="4738"><span class="lineNum">    4738 </span>            : // It need not take a SgTemplateArgumentPtrList because template functions (including template member functions) can not support partial specialization.</a>
<a name="4739"><span class="lineNum">    4739 </span>            : // SgTemplateMemberFunctionDeclaration* SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags)</a>
<a name="4740"><span class="lineNum">    4740 </span>            : SgTemplateMemberFunctionDeclaration*</a>
<a name="4741"><span class="lineNum">    4741 </span><span class="lineCov">      10059 : SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateParameterPtrList* templateParameterList)</span></a>
<a name="4742"><span class="lineNum">    4742 </span>            :    {</a>
<a name="4743"><span class="lineNum">    4743 </span>            : #if 0</a>
<a name="4744"><span class="lineNum">    4744 </span>            :      printf(&quot;In SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration(name = %s):\n&quot;, name.str());</a>
<a name="4745"><span class="lineNum">    4745 </span>            : #endif</a>
<a name="4746"><span class="lineNum">    4746 </span>            : </a>
<a name="4747"><span class="lineNum">    4747 </span>            :   // This function only builds template member function declarations.</a>
<a name="4748"><span class="lineNum">    4748 </span>            : </a>
<a name="4749"><span class="lineNum">    4749 </span><span class="lineCov">      10059 :      SgTemplateMemberFunctionDeclaration * result = buildNondefiningFunctionDeclaration_T &lt;SgTemplateMemberFunctionDeclaration&gt; (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,NULL,templateParameterList, SgStorageModifier::e_default);</span></a>
<a name="4750"><span class="lineNum">    4750 </span>            : </a>
<a name="4751"><span class="lineNum">    4751 </span>            :   // set definingdecl for SgCtorInitializerList</a>
<a name="4752"><span class="lineNum">    4752 </span><span class="lineCov">      10059 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="4753"><span class="lineNum">    4753 </span>            : </a>
<a name="4754"><span class="lineNum">    4754 </span>            : #if 0</a>
<a name="4755"><span class="lineNum">    4755 </span>            :      printf(&quot; In SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration(...): result = %p (%s)\n&quot;, result, result-&gt;class_name().c_str());</a>
<a name="4756"><span class="lineNum">    4756 </span>            :      printf(&quot; In SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration(...): result-&gt;get_firstNondefiningDeclaration() = %p\n&quot;, result-&gt;get_firstNondefiningDeclaration());</a>
<a name="4757"><span class="lineNum">    4757 </span>            : #endif</a>
<a name="4758"><span class="lineNum">    4758 </span>            : </a>
<a name="4759"><span class="lineNum">    4759 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="4760"><span class="lineNum">    4760 </span>            :   // DQ (5/1/2012): Make sure that we don't have IR nodes marked as translformations.</a>
<a name="4761"><span class="lineNum">    4761 </span>            :      if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="4762"><span class="lineNum">    4762 </span>            :         {</a>
<a name="4763"><span class="lineNum">    4763 </span>            :           detectTransformations_local(result);</a>
<a name="4764"><span class="lineNum">    4764 </span>            :         }</a>
<a name="4765"><span class="lineNum">    4765 </span>            : #endif</a>
<a name="4766"><span class="lineNum">    4766 </span>            : </a>
<a name="4767"><span class="lineNum">    4767 </span>            : #if 0</a>
<a name="4768"><span class="lineNum">    4768 </span>            :      printf (&quot;After calling buildNondefiningFunctionDeclaration_T &lt;SgTemplateMemberFunctionDeclaration&gt;: result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="4769"><span class="lineNum">    4769 </span>            : #endif</a>
<a name="4770"><span class="lineNum">    4770 </span>            : </a>
<a name="4771"><span class="lineNum">    4771 </span>            :   // DQ (8/12/2013): Added template paremter list to call to get the function template symbol.</a>
<a name="4772"><span class="lineNum">    4772 </span>            :   // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="4773"><span class="lineNum">    4773 </span>            :   // In this case these are unavailable from this point.</a>
<a name="4774"><span class="lineNum">    4774 </span>            :   // SgSymbol* associatedSymbol = scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type());</a>
<a name="4775"><span class="lineNum">    4775 </span>            :   // SgSymbol* associatedSymbol = scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),NULL);</a>
<a name="4776"><span class="lineNum">    4776 </span><span class="lineCov">      10059 :      SgSymbol* associatedSymbol = scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),templateParameterList);</span></a>
<a name="4777"><span class="lineNum">    4777 </span><span class="lineCov">      10059 :      if (associatedSymbol == NULL)</span></a>
<a name="4778"><span class="lineNum">    4778 </span>            :         {</a>
<a name="4779"><span class="lineNum">    4779 </span><span class="lineNoCov">          0 :           printf (&quot;ERROR: associatedSymbol == NULL \n&quot;);</span></a>
<a name="4780"><span class="lineNum">    4780 </span><span class="lineNoCov">          0 :           printf (&quot;   --- result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</span></a>
<a name="4781"><span class="lineNum">    4781 </span><span class="lineNoCov">          0 :           printf (&quot;   --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="4782"><span class="lineNum">    4782 </span><span class="lineNoCov">          0 :           printf (&quot;   --- name = %s \n&quot;,name.str());</span></a>
<a name="4783"><span class="lineNum">    4783 </span><span class="lineNoCov">          0 :           printf (&quot;   --- result-&gt;get_type() = %p = %s \n&quot;,result-&gt;get_type(),result-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="4784"><span class="lineNum">    4784 </span><span class="lineNoCov">          0 :           printf (&quot;   --- result-&gt;get_type()-&gt;get_mangled() = %s \n&quot;,result-&gt;get_type()-&gt;get_mangled().str());</span></a>
<a name="4785"><span class="lineNum">    4785 </span>            :        }</a>
<a name="4786"><span class="lineNum">    4786 </span><span class="lineCov">      10059 :      ROSE_ASSERT(associatedSymbol != NULL);</span></a>
<a name="4787"><span class="lineNum">    4787 </span>            : </a>
<a name="4788"><span class="lineNum">    4788 </span>            : #if 1</a>
<a name="4789"><span class="lineNum">    4789 </span><span class="lineCov">      10059 :      SgCtorInitializerList * ctor = result-&gt;get_CtorInitializerList();</span></a>
<a name="4790"><span class="lineNum">    4790 </span><span class="lineCov">      10059 :      ROSE_ASSERT(ctor != NULL);</span></a>
<a name="4791"><span class="lineNum">    4791 </span>            :   // required ty AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()</a>
<a name="4792"><span class="lineNum">    4792 </span><span class="lineCov">      10059 :      ctor-&gt;set_definingDeclaration(ctor);</span></a>
<a name="4793"><span class="lineNum">    4793 </span><span class="lineCov">      10059 :      ctor-&gt;set_firstNondefiningDeclaration(ctor);</span></a>
<a name="4794"><span class="lineNum">    4794 </span>            : </a>
<a name="4795"><span class="lineNum">    4795 </span>            : #if 0</a>
<a name="4796"><span class="lineNum">    4796 </span>            :   // DQ (11/25/2011): I don't know if the SgTemplateMemberFunctionDeclaration needs this support!</a>
<a name="4797"><span class="lineNum">    4797 </span>            : </a>
<a name="4798"><span class="lineNum">    4798 </span>            :   // DQ (1/4/2009): Error checking</a>
<a name="4799"><span class="lineNum">    4799 </span>            :      ROSE_ASSERT(result-&gt;get_associatedClassDeclaration() != NULL);</a>
<a name="4800"><span class="lineNum">    4800 </span>            : </a>
<a name="4801"><span class="lineNum">    4801 </span>            :      if (result-&gt;get_associatedClassDeclaration() == NULL)</a>
<a name="4802"><span class="lineNum">    4802 </span>            :         {</a>
<a name="4803"><span class="lineNum">    4803 </span>            :           printf (&quot;Warning, must set the SgMemberFunctionDeclaration::associatedClassDeclaration \n&quot;);</a>
<a name="4804"><span class="lineNum">    4804 </span>            : </a>
<a name="4805"><span class="lineNum">    4805 </span>            :           ROSE_ASSERT(scope != NULL);</a>
<a name="4806"><span class="lineNum">    4806 </span>            :           SgClassDefinition* classDefinition = isSgClassDefinition(scope);</a>
<a name="4807"><span class="lineNum">    4807 </span>            :           ROSE_ASSERT(classDefinition != NULL);</a>
<a name="4808"><span class="lineNum">    4808 </span>            :           SgDeclarationStatement* associatedDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="4809"><span class="lineNum">    4809 </span>            :           ROSE_ASSERT(associatedDeclaration != NULL);</a>
<a name="4810"><span class="lineNum">    4810 </span>            :           SgClassDeclaration* associatedClassDeclaration = isSgClassDeclaration(associatedDeclaration);</a>
<a name="4811"><span class="lineNum">    4811 </span>            : </a>
<a name="4812"><span class="lineNum">    4812 </span>            :        // DQ (1/4/2009): This needs to be set, checked in AstConsistencyTests.C!</a>
<a name="4813"><span class="lineNum">    4813 </span>            :           result-&gt;set_associatedClassDeclaration(associatedClassDeclaration);</a>
<a name="4814"><span class="lineNum">    4814 </span>            :         }</a>
<a name="4815"><span class="lineNum">    4815 </span>            : #endif</a>
<a name="4816"><span class="lineNum">    4816 </span>            : </a>
<a name="4817"><span class="lineNum">    4817 </span>            : #else</a>
<a name="4818"><span class="lineNum">    4818 </span>            :      printf (&quot;Error: incomplete implementation of buildNondefiningTemplateMemberFunctionDeclaration() \n&quot;);</a>
<a name="4819"><span class="lineNum">    4819 </span>            :      ROSE_ABORT();</a>
<a name="4820"><span class="lineNum">    4820 </span>            : #endif</a>
<a name="4821"><span class="lineNum">    4821 </span>            : </a>
<a name="4822"><span class="lineNum">    4822 </span>            :   // DQ (12/11/2011): Added new test (also at the base of buildNondefiningFunctionDeclaration_T&lt;&gt;() function).</a>
<a name="4823"><span class="lineNum">    4823 </span><span class="lineCov">      10059 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="4824"><span class="lineNum">    4824 </span><span class="lineCov">      10059 :      SgSymbol* symbol_from_first_nondefining_function = result-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</span></a>
<a name="4825"><span class="lineNum">    4825 </span><span class="lineCov">      10059 :      ROSE_ASSERT(symbol_from_first_nondefining_function != NULL);</span></a>
<a name="4826"><span class="lineNum">    4826 </span>            : </a>
<a name="4827"><span class="lineNum">    4827 </span>            :   // DQ (12/11/2011): Note that this may be false when func is not the first nondefining declaration.</a>
<a name="4828"><span class="lineNum">    4828 </span><span class="lineCov">      10059 :      if (result != result-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="4829"><span class="lineNum">    4829 </span>            :         {</a>
<a name="4830"><span class="lineNum">    4830 </span><span class="lineCov">        229 :           SgSymbol* symbol_from_nondefining_function = result-&gt;get_symbol_from_symbol_table();</span></a>
<a name="4831"><span class="lineNum">    4831 </span><span class="lineCov">        229 :           ROSE_ASSERT(symbol_from_nondefining_function == NULL);</span></a>
<a name="4832"><span class="lineNum">    4832 </span>            :         }</a>
<a name="4833"><span class="lineNum">    4833 </span>            : </a>
<a name="4834"><span class="lineNum">    4834 </span>            : #if 0</a>
<a name="4835"><span class="lineNum">    4835 </span>            :      printf (&quot;In buildNondefiningTemplateMemberFunctionDeclaration(): Looking up name = %s in scope = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="4836"><span class="lineNum">    4836 </span>            : #endif</a>
<a name="4837"><span class="lineNum">    4837 </span>            : </a>
<a name="4838"><span class="lineNum">    4838 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP</a>
<a name="4839"><span class="lineNum">    4839 </span>            :   // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="4840"><span class="lineNum">    4840 </span>            :   // In this case these are unavailable from this point.</a>
<a name="4841"><span class="lineNum">    4841 </span>            :   // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="4842"><span class="lineNum">    4842 </span>            :   // if (scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type()) == NULL)</a>
<a name="4843"><span class="lineNum">    4843 </span>            :   // if (scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),NULL,NULL) == NULL)</a>
<a name="4844"><span class="lineNum">    4844 </span>            :      if (scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),templateParameterList) == NULL)</a>
<a name="4845"><span class="lineNum">    4845 </span>            :         {</a>
<a name="4846"><span class="lineNum">    4846 </span>            :           printf (&quot;Error: scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type()) == NULL (investigate this) \n&quot;);</a>
<a name="4847"><span class="lineNum">    4847 </span>            :           printf (&quot;--- function name = %s in scope = %p = %s result-&gt;get_type() = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str(),result-&gt;get_type(),result-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="4848"><span class="lineNum">    4848 </span>            :           scope-&gt;get_symbol_table()-&gt;print(&quot;Error: scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type()) == NULL (investigate this)&quot;);</a>
<a name="4849"><span class="lineNum">    4849 </span>            :         }</a>
<a name="4850"><span class="lineNum">    4850 </span>            : #endif</a>
<a name="4851"><span class="lineNum">    4851 </span>            :   // ROSE_ASSERT(scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type()) != NULL);</a>
<a name="4852"><span class="lineNum">    4852 </span>            :   // ROSE_ASSERT(scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),NULL) != NULL);</a>
<a name="4853"><span class="lineNum">    4853 </span><span class="lineCov">      10059 :      ROSE_ASSERT(scope-&gt;lookup_template_member_function_symbol(name,result-&gt;get_type(),templateParameterList) != NULL);</span></a>
<a name="4854"><span class="lineNum">    4854 </span>            : </a>
<a name="4855"><span class="lineNum">    4855 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="4856"><span class="lineNum">    4856 </span>            :   // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.</a>
<a name="4857"><span class="lineNum">    4857 </span>            :      if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="4858"><span class="lineNum">    4858 </span>            :         {</a>
<a name="4859"><span class="lineNum">    4859 </span>            :           detectTransformations_local(result);</a>
<a name="4860"><span class="lineNum">    4860 </span>            :         }</a>
<a name="4861"><span class="lineNum">    4861 </span>            : #endif</a>
<a name="4862"><span class="lineNum">    4862 </span>            : </a>
<a name="4863"><span class="lineNum">    4863 </span>            : #if 0</a>
<a name="4864"><span class="lineNum">    4864 </span>            :   // TV (04/12/2018): Add a scope for nonreal classes (and their member) on the first non-defining declaration of template member function</a>
<a name="4865"><span class="lineNum">    4865 </span>            :      if (result == result-&gt;get_firstNondefiningDeclaration()) {</a>
<a name="4866"><span class="lineNum">    4866 </span>            :        SgDeclarationScope * nonreal_decl_scope = new SgDeclarationScope();</a>
<a name="4867"><span class="lineNum">    4867 </span>            : </a>
<a name="4868"><span class="lineNum">    4868 </span>            :        nonreal_decl_scope-&gt;set_parent(result);</a>
<a name="4869"><span class="lineNum">    4869 </span>            :        result-&gt;set_nonreal_decl_scope(nonreal_decl_scope);</a>
<a name="4870"><span class="lineNum">    4870 </span>            : </a>
<a name="4871"><span class="lineNum">    4871 </span>            :        SageInterface::setSourcePosition(nonreal_decl_scope);</a>
<a name="4872"><span class="lineNum">    4872 </span>            :        nonreal_decl_scope-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</a>
<a name="4873"><span class="lineNum">    4873 </span>            :        nonreal_decl_scope-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</a>
<a name="4874"><span class="lineNum">    4874 </span>            : #if 0</a>
<a name="4875"><span class="lineNum">    4875 </span>            :        printf(&quot;Leaving SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration(name = %s): nrscope = %p (new)\n&quot;, name.str(), nonreal_decl_scope);</a>
<a name="4876"><span class="lineNum">    4876 </span>            : #endif</a>
<a name="4877"><span class="lineNum">    4877 </span>            :      }</a>
<a name="4878"><span class="lineNum">    4878 </span>            : #endif</a>
<a name="4879"><span class="lineNum">    4879 </span>            : </a>
<a name="4880"><span class="lineNum">    4880 </span><span class="lineCov">      10059 :      return result;</span></a>
<a name="4881"><span class="lineNum">    4881 </span>            :    }</a>
<a name="4882"><span class="lineNum">    4882 </span>            : </a>
<a name="4883"><span class="lineNum">    4883 </span>            : #if 0</a>
<a name="4884"><span class="lineNum">    4884 </span>            : SgMemberFunctionDeclaration*</a>
<a name="4885"><span class="lineNum">    4885 </span>            : SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgMemberFunctionType* func_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)</a>
<a name="4886"><span class="lineNum">    4886 </span>            :    {</a>
<a name="4887"><span class="lineNum">    4887 </span>            :      if (scope == NULL)</a>
<a name="4888"><span class="lineNum">    4888 </span>            :           scope = SageBuilder::topScopeStack();</a>
<a name="4889"><span class="lineNum">    4889 </span>            : </a>
<a name="4890"><span class="lineNum">    4890 </span>            :      ROSE_ASSERT(name.is_null() == false);</a>
<a name="4891"><span class="lineNum">    4891 </span>            :      ROSE_ASSERT(func_type != NULL);</a>
<a name="4892"><span class="lineNum">    4892 </span>            : </a>
<a name="4893"><span class="lineNum">    4893 </span>            :      SgClassDefinition *struct_name = isSgClassDefinition(scope);</a>
<a name="4894"><span class="lineNum">    4894 </span>            :      ROSE_ASSERT(struct_name != NULL);</a>
<a name="4895"><span class="lineNum">    4895 </span>            : </a>
<a name="4896"><span class="lineNum">    4896 </span>            : </a>
<a name="4897"><span class="lineNum">    4897 </span>            :   // function declaration</a>
<a name="4898"><span class="lineNum">    4898 </span>            :      SgMemberFunctionDeclaration* func = NULL;</a>
<a name="4899"><span class="lineNum">    4899 </span>            : </a>
<a name="4900"><span class="lineNum">    4900 </span>            :   // search before using the function type to create the function declaration</a>
<a name="4901"><span class="lineNum">    4901 </span>            :   // TODO only search current scope or all ancestor scope??</a>
<a name="4902"><span class="lineNum">    4902 </span>            :   // We don't have lookup_member_function_symbol  yet</a>
<a name="4903"><span class="lineNum">    4903 </span>            :   // SgFunctionSymbol *func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="4904"><span class="lineNum">    4904 </span>            :      SgFunctionSymbol *func_symbol = NULL;</a>
<a name="4905"><span class="lineNum">    4905 </span>            :      if (scope != NULL)</a>
<a name="4906"><span class="lineNum">    4906 </span>            :           func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="4907"><span class="lineNum">    4907 </span>            : </a>
<a name="4908"><span class="lineNum">    4908 </span>            :   // printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p \n&quot;,scope,func_symbol);</a>
<a name="4909"><span class="lineNum">    4909 </span>            :      if (func_symbol == NULL)</a>
<a name="4910"><span class="lineNum">    4910 </span>            :         {</a>
<a name="4911"><span class="lineNum">    4911 </span>            :        // first prototype declaration</a>
<a name="4912"><span class="lineNum">    4912 </span>            :           func = new SgMemberFunctionDeclaration (name,func_type,NULL);</a>
<a name="4913"><span class="lineNum">    4913 </span>            :           ROSE_ASSERT(func != NULL);</a>
<a name="4914"><span class="lineNum">    4914 </span>            : </a>
<a name="4915"><span class="lineNum">    4915 </span>            :        // NOTE: we want to allow the input scope to be NULL (and even the SageBuilder::topScopeStack() == NULL)</a>
<a name="4916"><span class="lineNum">    4916 </span>            :        // so that function can be built bottom up style.  However this means that the symbol tables in the</a>
<a name="4917"><span class="lineNum">    4917 </span>            :        // scope of the returned function declaration will have to be setup separately.</a>
<a name="4918"><span class="lineNum">    4918 </span>            :           if (scope != NULL)</a>
<a name="4919"><span class="lineNum">    4919 </span>            :              {</a>
<a name="4920"><span class="lineNum">    4920 </span>            :             // function symbol table</a>
<a name="4921"><span class="lineNum">    4921 </span>            :                func_symbol = new SgMemberFunctionSymbol(func);</a>
<a name="4922"><span class="lineNum">    4922 </span>            : </a>
<a name="4923"><span class="lineNum">    4923 </span>            :             // printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p = %s = %s \n&quot;,scope,func_symbol,func_symbol-&gt;class_name().c_str(),SageInterface::get_name(func_symbol).c_str());</a>
<a name="4924"><span class="lineNum">    4924 </span>            :                ROSE_ASSERT(func_symbol != NULL);</a>
<a name="4925"><span class="lineNum">    4925 </span>            : </a>
<a name="4926"><span class="lineNum">    4926 </span>            :                scope-&gt;insert_symbol(name, func_symbol);</a>
<a name="4927"><span class="lineNum">    4927 </span>            : </a>
<a name="4928"><span class="lineNum">    4928 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_function_symbol(name,func_type) != NULL);</a>
<a name="4929"><span class="lineNum">    4929 </span>            : </a>
<a name="4930"><span class="lineNum">    4930 </span>            :             // DQ (2/26/2009): uncommented assertion.</a>
<a name="4931"><span class="lineNum">    4931 </span>            :                ROSE_ASSERT(scope-&gt;lookup_function_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?</a>
<a name="4932"><span class="lineNum">    4932 </span>            :              }</a>
<a name="4933"><span class="lineNum">    4933 </span>            : </a>
<a name="4934"><span class="lineNum">    4934 </span>            :           func-&gt;set_firstNondefiningDeclaration(func);</a>
<a name="4935"><span class="lineNum">    4935 </span>            :           func-&gt;set_definingDeclaration(NULL);</a>
<a name="4936"><span class="lineNum">    4936 </span>            : </a>
<a name="4937"><span class="lineNum">    4937 </span>            :           ROSE_ASSERT(func-&gt;get_definingDeclaration() == NULL);</a>
<a name="4938"><span class="lineNum">    4938 </span>            :         }</a>
<a name="4939"><span class="lineNum">    4939 </span>            :        else</a>
<a name="4940"><span class="lineNum">    4940 </span>            :         {</a>
<a name="4941"><span class="lineNum">    4941 </span>            :           ROSE_ASSERT(scope != NULL);</a>
<a name="4942"><span class="lineNum">    4942 </span>            : </a>
<a name="4943"><span class="lineNum">    4943 </span>            :        // 2nd, or 3rd... prototype declaration</a>
<a name="4944"><span class="lineNum">    4944 </span>            :        // reuse function type, function symbol of previous declaration</a>
<a name="4945"><span class="lineNum">    4945 </span>            : </a>
<a name="4946"><span class="lineNum">    4946 </span>            :        // std::cout&lt;&lt;&quot;debug:SageBuilder.C: 267: &quot;&lt;&lt;&quot;found func_symbol!&quot;&lt;&lt;std::endl;</a>
<a name="4947"><span class="lineNum">    4947 </span>            :        // delete (func_type-&gt; get_argument_list ());</a>
<a name="4948"><span class="lineNum">    4948 </span>            :        // delete func_type; // bug 189</a>
<a name="4949"><span class="lineNum">    4949 </span>            : </a>
<a name="4950"><span class="lineNum">    4950 </span>            :           func_type = isSgMemberFunctionType(func_symbol-&gt;get_declaration()-&gt;get_type());</a>
<a name="4951"><span class="lineNum">    4951 </span>            :           func = new SgMemberFunctionDeclaration(name,func_type,NULL);</a>
<a name="4952"><span class="lineNum">    4952 </span>            :           ROSE_ASSERT(func);</a>
<a name="4953"><span class="lineNum">    4953 </span>            : </a>
<a name="4954"><span class="lineNum">    4954 </span>            :        // we don't care if it is member function or function here for a pointer</a>
<a name="4955"><span class="lineNum">    4955 </span>            :           SgFunctionDeclaration* prevDecl = NULL;</a>
<a name="4956"><span class="lineNum">    4956 </span>            :           prevDecl = func_symbol-&gt;get_declaration();</a>
<a name="4957"><span class="lineNum">    4957 </span>            :           ROSE_ASSERT(prevDecl != NULL);</a>
<a name="4958"><span class="lineNum">    4958 </span>            : </a>
<a name="4959"><span class="lineNum">    4959 </span>            :        // printf (&quot;In SageBuilder::buildNondefiningFunctionDeclaration_T(): prevDecl = %p \n&quot;,prevDecl);</a>
<a name="4960"><span class="lineNum">    4960 </span>            : </a>
<a name="4961"><span class="lineNum">    4961 </span>            :           if (prevDecl == prevDecl-&gt;get_definingDeclaration())</a>
<a name="4962"><span class="lineNum">    4962 </span>            :              {</a>
<a name="4963"><span class="lineNum">    4963 </span>            :             // The symbol points to a defining declaration and now that we have added a non-defining</a>
<a name="4964"><span class="lineNum">    4964 </span>            :             // declaration we should have the symbol point to the new non-defining declaration.</a>
<a name="4965"><span class="lineNum">    4965 </span>            :             // printf (&quot;Switching declaration in functionSymbol to point to the non-defining declaration \n&quot;);</a>
<a name="4966"><span class="lineNum">    4966 </span>            : </a>
<a name="4967"><span class="lineNum">    4967 </span>            :                func_symbol-&gt;set_declaration(func);</a>
<a name="4968"><span class="lineNum">    4968 </span>            :              }</a>
<a name="4969"><span class="lineNum">    4969 </span>            : </a>
<a name="4970"><span class="lineNum">    4970 </span>            :        // If this is the first non-defining declaration then set the associated data member.</a>
<a name="4971"><span class="lineNum">    4971 </span>            :           SgDeclarationStatement* nondefiningDeclaration = prevDecl-&gt;get_firstNondefiningDeclaration();</a>
<a name="4972"><span class="lineNum">    4972 </span>            :           if (nondefiningDeclaration == NULL)</a>
<a name="4973"><span class="lineNum">    4973 </span>            :              {</a>
<a name="4974"><span class="lineNum">    4974 </span>            :                nondefiningDeclaration = func;</a>
<a name="4975"><span class="lineNum">    4975 </span>            :              }</a>
<a name="4976"><span class="lineNum">    4976 </span>            : </a>
<a name="4977"><span class="lineNum">    4977 </span>            :           ROSE_ASSERT(nondefiningDeclaration != NULL);</a>
<a name="4978"><span class="lineNum">    4978 </span>            : </a>
<a name="4979"><span class="lineNum">    4979 </span>            :        // func-&gt;set_firstNondefiningDeclaration(prevDecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="4980"><span class="lineNum">    4980 </span>            :           func-&gt;set_firstNondefiningDeclaration(nondefiningDeclaration);</a>
<a name="4981"><span class="lineNum">    4981 </span>            :           func-&gt;set_definingDeclaration(prevDecl-&gt;get_definingDeclaration());</a>
<a name="4982"><span class="lineNum">    4982 </span>            :         }</a>
<a name="4983"><span class="lineNum">    4983 </span>            : </a>
<a name="4984"><span class="lineNum">    4984 </span>            :   // parameter list</a>
<a name="4985"><span class="lineNum">    4985 </span>            :      //SgFunctionParameterList* paralist = buildFunctionParameterList(func_type-&gt;get_argument_list());</a>
<a name="4986"><span class="lineNum">    4986 </span>            :      setParameterList(func, paralist);</a>
<a name="4987"><span class="lineNum">    4987 </span>            : </a>
<a name="4988"><span class="lineNum">    4988 </span>            :      SgInitializedNamePtrList argList = paralist-&gt;get_args();</a>
<a name="4989"><span class="lineNum">    4989 </span>            :      Rose_STL_Container&lt;SgInitializedName*&gt;::iterator argi;</a>
<a name="4990"><span class="lineNum">    4990 </span>            :      for(argi=argList.begin(); argi!=argList.end(); argi++)</a>
<a name="4991"><span class="lineNum">    4991 </span>            :         {</a>
<a name="4992"><span class="lineNum">    4992 </span>            :        // std::cout&lt;&lt;&quot;patching argument's scope.... &quot;&lt;&lt;std::endl;</a>
<a name="4993"><span class="lineNum">    4993 </span>            :           (*argi)-&gt;set_scope(scope);</a>
<a name="4994"><span class="lineNum">    4994 </span>            : </a>
<a name="4995"><span class="lineNum">    4995 </span>            :        // DQ (2/23/2009): Also set the declptr (to NULL)</a>
<a name="4996"><span class="lineNum">    4996 </span>            :        // (*argi)-&gt;set_declptr(NULL);</a>
<a name="4997"><span class="lineNum">    4997 </span>            :         }</a>
<a name="4998"><span class="lineNum">    4998 </span>            :   // TODO double check if there are exceptions</a>
<a name="4999"><span class="lineNum">    4999 </span>            :      func-&gt;set_scope(scope);</a>
<a name="5000"><span class="lineNum">    5000 </span>            : </a>
<a name="5001"><span class="lineNum">    5001 </span>            :      // DQ (1/5/2009): This is not always true (should likely use SageBuilder::topScopeStack() instead)</a>
<a name="5002"><span class="lineNum">    5002 </span>            :      if (SageBuilder::topScopeStack()!= NULL) // This comparison only makes sense when topScopeStack() returns non-NULL value</a>
<a name="5003"><span class="lineNum">    5003 </span>            :         {</a>
<a name="5004"><span class="lineNum">    5004 </span>            :        // Since stack scope is totally optional in SageBuilder.</a>
<a name="5005"><span class="lineNum">    5005 </span>            :           if (scope != SageBuilder::topScopeStack())</a>
<a name="5006"><span class="lineNum">    5006 </span>            :              {</a>
<a name="5007"><span class="lineNum">    5007 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="5008"><span class="lineNum">    5008 </span>            :                printf (&quot;Warning: SageBuilder::buildNondefiningFunctionDeclaration_T(): scope parameter may not be the same as the topScopeStack() (e.g. for member functions) \n&quot;);</a>
<a name="5009"><span class="lineNum">    5009 </span>            : #endif</a>
<a name="5010"><span class="lineNum">    5010 </span>            :              }</a>
<a name="5011"><span class="lineNum">    5011 </span>            :         }</a>
<a name="5012"><span class="lineNum">    5012 </span>            : </a>
<a name="5013"><span class="lineNum">    5013 </span>            :      func-&gt;set_parent(scope);</a>
<a name="5014"><span class="lineNum">    5014 </span>            : </a>
<a name="5015"><span class="lineNum">    5015 </span>            :   // DQ (2/21/2009): We can't assert that this is always NULL or non-NULL.</a>
<a name="5016"><span class="lineNum">    5016 </span>            :   // ROSE_ASSERT(func-&gt;get_definingDeclaration() == NULL);</a>
<a name="5017"><span class="lineNum">    5017 </span>            : </a>
<a name="5018"><span class="lineNum">    5018 </span>            :   // DQ (2/21/2009): Added assertion</a>
<a name="5019"><span class="lineNum">    5019 </span>            :      ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="5020"><span class="lineNum">    5020 </span>            : </a>
<a name="5021"><span class="lineNum">    5021 </span>            :   // mark as a forward declartion</a>
<a name="5022"><span class="lineNum">    5022 </span>            :      func-&gt;setForward();</a>
<a name="5023"><span class="lineNum">    5023 </span>            : </a>
<a name="5024"><span class="lineNum">    5024 </span>            :   // set File_Info as transformation generated</a>
<a name="5025"><span class="lineNum">    5025 </span>            :      setSourcePositionAtRootAndAllChildren(func);</a>
<a name="5026"><span class="lineNum">    5026 </span>            : </a>
<a name="5027"><span class="lineNum">    5027 </span>            :      return func;</a>
<a name="5028"><span class="lineNum">    5028 </span>            :    }</a>
<a name="5029"><span class="lineNum">    5029 </span>            : #endif</a>
<a name="5030"><span class="lineNum">    5030 </span>            : </a>
<a name="5031"><span class="lineNum">    5031 </span>            : #if 0</a>
<a name="5032"><span class="lineNum">    5032 </span>            : // DQ (3/20/2017): This function is not used (so let's see if we can remove it).</a>
<a name="5033"><span class="lineNum">    5033 </span>            : // DQ (8/29/2012): This is re-enabled because the backstroke project is using it.</a>
<a name="5034"><span class="lineNum">    5034 </span>            : // DQ (7/26/2012): I would like to remove this from the API (at least for now while debugging the newer API required for template argument handling).</a>
<a name="5035"><span class="lineNum">    5035 </span>            : SgMemberFunctionDeclaration*</a>
<a name="5036"><span class="lineNum">    5036 </span>            : SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgMemberFunctionType* func_type, SgScopeStatement* scope, SgExprListExp* decoratorList, SgMemberFunctionDeclaration* first_nondefining_declaration)</a>
<a name="5037"><span class="lineNum">    5037 </span>            :    {</a>
<a name="5038"><span class="lineNum">    5038 </span>            :      SgType* return_type = func_type-&gt;get_return_type();</a>
<a name="5039"><span class="lineNum">    5039 </span>            :      SgFunctionParameterList* paralist = buildFunctionParameterList(func_type-&gt;get_argument_list());</a>
<a name="5040"><span class="lineNum">    5040 </span>            : </a>
<a name="5041"><span class="lineNum">    5041 </span>            :      bool buildTemplateInstantiation         = false;</a>
<a name="5042"><span class="lineNum">    5042 </span>            :      unsigned int functionConstVolatileFlags = 0;</a>
<a name="5043"><span class="lineNum">    5043 </span>            :      SgTemplateArgumentPtrList* templateArgumentsList = NULL;</a>
<a name="5044"><span class="lineNum">    5044 </span>            : </a>
<a name="5045"><span class="lineNum">    5045 </span>            :      return SageBuilder::buildDefiningMemberFunctionDeclaration(name, return_type, paralist, scope, decoratorList, buildTemplateInstantiation, functionConstVolatileFlags, first_nondefining_declaration, templateArgumentsList);</a>
<a name="5046"><span class="lineNum">    5046 </span>            :    }</a>
<a name="5047"><span class="lineNum">    5047 </span>            : #endif</a>
<a name="5048"><span class="lineNum">    5048 </span>            : </a>
<a name="5049"><span class="lineNum">    5049 </span>            : #if 0</a>
<a name="5050"><span class="lineNum">    5050 </span>            : // DQ (7/26/2012): I would like to remove this from the API (at least for now while debugging the newer API required for template argument handling).</a>
<a name="5051"><span class="lineNum">    5051 </span>            : </a>
<a name="5052"><span class="lineNum">    5052 </span>            : // DQ (5/12/2012): This interferes with the other function:</a>
<a name="5053"><span class="lineNum">    5053 </span>            : // SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration)</a>
<a name="5054"><span class="lineNum">    5054 </span>            : // Once the default arguments are removed.</a>
<a name="5055"><span class="lineNum">    5055 </span>            : // Comment this out for now.  this might be one too many API functions anyway.</a>
<a name="5056"><span class="lineNum">    5056 </span>            : </a>
<a name="5057"><span class="lineNum">    5057 </span>            : SgMemberFunctionDeclaration*</a>
<a name="5058"><span class="lineNum">    5058 </span>            : SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgMemberFunctionType* func_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgMemberFunctionDeclaration* first_nondefining_declaration)</a>
<a name="5059"><span class="lineNum">    5059 </span>            : {</a>
<a name="5060"><span class="lineNum">    5060 </span>            :   if (scope == NULL)</a>
<a name="5061"><span class="lineNum">    5061 </span>            :     scope = SageBuilder::topScopeStack();</a>
<a name="5062"><span class="lineNum">    5062 </span>            :   ROSE_ASSERT(scope != NULL);</a>
<a name="5063"><span class="lineNum">    5063 </span>            :   ROSE_ASSERT(name.is_null() == false);</a>
<a name="5064"><span class="lineNum">    5064 </span>            :   ROSE_ASSERT(func_type != NULL);</a>
<a name="5065"><span class="lineNum">    5065 </span>            : </a>
<a name="5066"><span class="lineNum">    5066 </span>            :   SgMemberFunctionDeclaration * func;</a>
<a name="5067"><span class="lineNum">    5067 </span>            : </a>
<a name="5068"><span class="lineNum">    5068 </span>            :  //  symbol table and non-defining</a>
<a name="5069"><span class="lineNum">    5069 </span>            :   SgMemberFunctionSymbol *func_symbol = isSgMemberFunctionSymbol(scope-&gt;lookup_function_symbol(name,func_type));</a>
<a name="5070"><span class="lineNum">    5070 </span>            :   if (func_symbol == NULL)</a>
<a name="5071"><span class="lineNum">    5071 </span>            :   {</a>
<a name="5072"><span class="lineNum">    5072 </span>            :     // new defining declaration</a>
<a name="5073"><span class="lineNum">    5073 </span>            : //    func = new SgFunctionDeclaration(name,func_type,NULL);</a>
<a name="5074"><span class="lineNum">    5074 </span>            :     func = new SgMemberFunctionDeclaration(name,func_type,NULL);</a>
<a name="5075"><span class="lineNum">    5075 </span>            :     ROSE_ASSERT(func);</a>
<a name="5076"><span class="lineNum">    5076 </span>            :     SgMemberFunctionSymbol *func_symbol = new SgMemberFunctionSymbol(func);</a>
<a name="5077"><span class="lineNum">    5077 </span>            :     scope-&gt;insert_symbol(name, func_symbol);</a>
<a name="5078"><span class="lineNum">    5078 </span>            :     func-&gt;set_firstNondefiningDeclaration(NULL);</a>
<a name="5079"><span class="lineNum">    5079 </span>            :   } else</a>
<a name="5080"><span class="lineNum">    5080 </span>            :   {</a>
<a name="5081"><span class="lineNum">    5081 </span>            :     // defining declaration after nondefining declaration</a>
<a name="5082"><span class="lineNum">    5082 </span>            :     //reuse function type, function symbol</a>
<a name="5083"><span class="lineNum">    5083 </span>            : </a>
<a name="5084"><span class="lineNum">    5084 </span>            : //    delete func_type;// bug 189</a>
<a name="5085"><span class="lineNum">    5085 </span>            : </a>
<a name="5086"><span class="lineNum">    5086 </span>            :     // Cong (10/25/2010): Make sure in this situation there is no defining declaration for this symbol.</a>
<a name="5087"><span class="lineNum">    5087 </span>            :     //ROSE_ASSERT(func_symbol-&gt;get_declaration()-&gt;get_definingDeclaration() == NULL);</a>
<a name="5088"><span class="lineNum">    5088 </span>            : </a>
<a name="5089"><span class="lineNum">    5089 </span>            :     func_type = isSgMemberFunctionType(func_symbol-&gt;get_declaration()-&gt;get_type());</a>
<a name="5090"><span class="lineNum">    5090 </span>            :     //func = new SgFunctionDeclaration(name,func_type,NULL);</a>
<a name="5091"><span class="lineNum">    5091 </span>            :     func = new SgMemberFunctionDeclaration(name,func_type,NULL);</a>
<a name="5092"><span class="lineNum">    5092 </span>            :     ROSE_ASSERT(func);</a>
<a name="5093"><span class="lineNum">    5093 </span>            : </a>
<a name="5094"><span class="lineNum">    5094 </span>            :     func-&gt;set_firstNondefiningDeclaration(func_symbol-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5095"><span class="lineNum">    5095 </span>            : </a>
<a name="5096"><span class="lineNum">    5096 </span>            :     // fix up defining declarations before current statement</a>
<a name="5097"><span class="lineNum">    5097 </span>            :     func_symbol-&gt;get_declaration()-&gt;set_definingDeclaration(func);</a>
<a name="5098"><span class="lineNum">    5098 </span>            :     //for the rare case that two or more prototype declaration exist</a>
<a name="5099"><span class="lineNum">    5099 </span>            :     // cannot do anything until append/prepend_statment() is invoked</a>
<a name="5100"><span class="lineNum">    5100 </span>            :   }</a>
<a name="5101"><span class="lineNum">    5101 </span>            : </a>
<a name="5102"><span class="lineNum">    5102 </span>            :   // handle decorators</a>
<a name="5103"><span class="lineNum">    5103 </span>            :   if (decoratorList != NULL)</a>
<a name="5104"><span class="lineNum">    5104 </span>            :   {</a>
<a name="5105"><span class="lineNum">    5105 </span>            :       func-&gt;set_decoratorList(decoratorList);</a>
<a name="5106"><span class="lineNum">    5106 </span>            :       decoratorList-&gt;set_parent(func);</a>
<a name="5107"><span class="lineNum">    5107 </span>            :   }</a>
<a name="5108"><span class="lineNum">    5108 </span>            : </a>
<a name="5109"><span class="lineNum">    5109 </span>            :   // definingDeclaration</a>
<a name="5110"><span class="lineNum">    5110 </span>            :   func-&gt;set_definingDeclaration(func);</a>
<a name="5111"><span class="lineNum">    5111 </span>            : </a>
<a name="5112"><span class="lineNum">    5112 </span>            :   // function body and definition are created before setting argument list</a>
<a name="5113"><span class="lineNum">    5113 </span>            :   SgBasicBlock * func_body = new SgBasicBlock();</a>
<a name="5114"><span class="lineNum">    5114 </span>            :   ROSE_ASSERT(func_body);</a>
<a name="5115"><span class="lineNum">    5115 </span>            :   SgFunctionDefinition * func_def = new SgFunctionDefinition(func,func_body);</a>
<a name="5116"><span class="lineNum">    5116 </span>            :   ROSE_ASSERT(func_def);</a>
<a name="5117"><span class="lineNum">    5117 </span>            : </a>
<a name="5118"><span class="lineNum">    5118 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="5119"><span class="lineNum">    5119 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="5120"><span class="lineNum">    5120 </span>            :   if (SageInterface::is_language_case_insensitive())</a>
<a name="5121"><span class="lineNum">    5121 </span>            :      {</a>
<a name="5122"><span class="lineNum">    5122 </span>            :        func_def-&gt;setCaseInsensitive(true);</a>
<a name="5123"><span class="lineNum">    5123 </span>            :        func_body-&gt;setCaseInsensitive(true);</a>
<a name="5124"><span class="lineNum">    5124 </span>            :      }</a>
<a name="5125"><span class="lineNum">    5125 </span>            : </a>
<a name="5126"><span class="lineNum">    5126 </span>            :   func_def-&gt;set_parent(func);</a>
<a name="5127"><span class="lineNum">    5127 </span>            :   func_def-&gt;set_body(func_body);</a>
<a name="5128"><span class="lineNum">    5128 </span>            :   func_body-&gt;set_parent(func_def);</a>
<a name="5129"><span class="lineNum">    5129 </span>            : </a>
<a name="5130"><span class="lineNum">    5130 </span>            :    // parameter list,</a>
<a name="5131"><span class="lineNum">    5131 </span>            :    //TODO consider the difference between C++ and Fortran</a>
<a name="5132"><span class="lineNum">    5132 </span>            :   //SgFunctionParameterList* paralist = buildFunctionParameterList(func_type-&gt;get_argument_list());</a>
<a name="5133"><span class="lineNum">    5133 </span>            :   setParameterList(func,paralist);</a>
<a name="5134"><span class="lineNum">    5134 </span>            :          // fixup the scope and symbol of arguments,</a>
<a name="5135"><span class="lineNum">    5135 </span>            :   SgInitializedNamePtrList&amp; argList = paralist-&gt;get_args();</a>
<a name="5136"><span class="lineNum">    5136 </span>            :   Rose_STL_Container&lt;SgInitializedName*&gt;::iterator argi;</a>
<a name="5137"><span class="lineNum">    5137 </span>            :   for(argi=argList.begin(); argi!=argList.end(); argi++)</a>
<a name="5138"><span class="lineNum">    5138 </span>            :   {</a>
<a name="5139"><span class="lineNum">    5139 </span>            : //    std::cout&lt;&lt;&quot;patching defining function argument's scope and symbol.... &quot;&lt;&lt;std::endl;</a>
<a name="5140"><span class="lineNum">    5140 </span>            :     (*argi)-&gt;set_scope(func_def);</a>
<a name="5141"><span class="lineNum">    5141 </span>            :     func_def-&gt;insert_symbol((*argi)-&gt;get_name(), new SgVariableSymbol(*argi) );</a>
<a name="5142"><span class="lineNum">    5142 </span>            :   }</a>
<a name="5143"><span class="lineNum">    5143 </span>            : </a>
<a name="5144"><span class="lineNum">    5144 </span>            :   func-&gt;set_parent(scope);</a>
<a name="5145"><span class="lineNum">    5145 </span>            :   func-&gt;set_scope(scope);</a>
<a name="5146"><span class="lineNum">    5146 </span>            : </a>
<a name="5147"><span class="lineNum">    5147 </span>            :   // set File_Info as transformation generated</a>
<a name="5148"><span class="lineNum">    5148 </span>            :   setSourcePositionAtRootAndAllChildren(func);</a>
<a name="5149"><span class="lineNum">    5149 </span>            :   return func;</a>
<a name="5150"><span class="lineNum">    5150 </span>            : }</a>
<a name="5151"><span class="lineNum">    5151 </span>            : #endif</a>
<a name="5152"><span class="lineNum">    5152 </span>            : </a>
<a name="5153"><span class="lineNum">    5153 </span>            : </a>
<a name="5154"><span class="lineNum">    5154 </span>            : // SgMemberFunctionDeclaration* SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration)</a>
<a name="5155"><span class="lineNum">    5155 </span>            : SgMemberFunctionDeclaration*</a>
<a name="5156"><span class="lineNum">    5156 </span><span class="lineCov">       4343 : SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)</span></a>
<a name="5157"><span class="lineNum">    5157 </span>            :    {</a>
<a name="5158"><span class="lineNum">    5158 </span>            : </a>
<a name="5159"><span class="lineNum">    5159 </span>            : #if 0</a>
<a name="5160"><span class="lineNum">    5160 </span>            :      SgMemberFunctionDeclaration * result = buildDefiningFunctionDeclaration_T &lt;SgMemberFunctionDeclaration&gt; (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList);</a>
<a name="5161"><span class="lineNum">    5161 </span>            : </a>
<a name="5162"><span class="lineNum">    5162 </span>            :   // DQ (12/1/2011): This API is not yet supported for member function template instantiations.</a>
<a name="5163"><span class="lineNum">    5163 </span>            :   // ROSE_ASSERT(buildTemplateInstantiation == false);</a>
<a name="5164"><span class="lineNum">    5164 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="5165"><span class="lineNum">    5165 </span>            :         {</a>
<a name="5166"><span class="lineNum">    5166 </span>            :        // DQ (12/18/2011): I can't think of what more might be required here, but there may be something missing.</a>
<a name="5167"><span class="lineNum">    5167 </span>            :           printf (&quot;WARNING: In buildDefiningMemberFunctionDeclaration(): Case of buildTemplateInstantiation == true may be incomplete \n&quot;);</a>
<a name="5168"><span class="lineNum">    5168 </span>            : </a>
<a name="5169"><span class="lineNum">    5169 </span>            :           ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result) != NULL);</a>
<a name="5170"><span class="lineNum">    5170 </span>            :         }</a>
<a name="5171"><span class="lineNum">    5171 </span>            : #else</a>
<a name="5172"><span class="lineNum">    5172 </span>            :   // DQ (12/18/2011): Need to build a SgTemplateInstantiationMemberFunctionDecl when buildTemplateInstantiation == true</a>
<a name="5173"><span class="lineNum">    5173 </span><span class="lineCov">       4343 :      SgMemberFunctionDeclaration * result = NULL;</span></a>
<a name="5174"><span class="lineNum">    5174 </span><span class="lineCov">       4343 :      if (buildTemplateInstantiation == true)</span></a>
<a name="5175"><span class="lineNum">    5175 </span>            :         {</a>
<a name="5176"><span class="lineNum">    5176 </span>            :        // SgTemplateArgumentPtrList emptyList;</a>
<a name="5177"><span class="lineNum">    5177 </span>            :        // nondefdecl = new SgTemplateInstantiationMemberFunctionDecl(name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList);</a>
<a name="5178"><span class="lineNum">    5178 </span><span class="lineCov">       1672 :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(first_nondefining_declaration);</span></a>
<a name="5179"><span class="lineNum">    5179 </span><span class="lineCov">       1672 :           ROSE_ASSERT(templateInstantiationMemberFunctionDecl != NULL);</span></a>
<a name="5180"><span class="lineNum">    5180 </span>            : </a>
<a name="5181"><span class="lineNum">    5181 </span>            : #if 1</a>
<a name="5182"><span class="lineNum">    5182 </span>            :        // DQ (1/26/2013): Added test failing in buildDefiningFunctionDeclaration_T().</a>
<a name="5183"><span class="lineNum">    5183 </span><span class="lineCov">       1672 :              {</span></a>
<a name="5184"><span class="lineNum">    5184 </span><span class="lineCov">       1672 :                ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="5185"><span class="lineNum">    5185 </span><span class="lineCov">       1672 :                string nameWithoutTemplateArguments = name;</span></a>
<a name="5186"><span class="lineNum">    5186 </span><span class="lineCov">       5016 :                string nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);</span></a>
<a name="5187"><span class="lineNum">    5187 </span><span class="lineCov">       1672 :                SgMemberFunctionType* func_type = isSgMemberFunctionType(first_nondefining_declaration-&gt;get_type());</span></a>
<a name="5188"><span class="lineNum">    5188 </span><span class="lineCov">       1672 :                ROSE_ASSERT(func_type != NULL);</span></a>
<a name="5189"><span class="lineNum">    5189 </span>            : </a>
<a name="5190"><span class="lineNum">    5190 </span>            :             // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.</a>
<a name="5191"><span class="lineNum">    5191 </span>            :             // SgSymbol* func_symbol = scope-&gt;get_symbol_table()-&gt;find_symbol_by_type_of_function&lt;SgTemplateInstantiationMemberFunctionDecl&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5192"><span class="lineNum">    5192 </span>            :             // SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;SgTemplateInstantiationMemberFunctionDecl&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5193"><span class="lineNum">    5193 </span>            :             // SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;SgTemplateInstantiationMemberFunctionDecl&gt;(nameWithTemplateArguments,func_type,NULL);</a>
<a name="5194"><span class="lineNum">    5194 </span><span class="lineCov">       1672 :                SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;SgTemplateInstantiationMemberFunctionDecl&gt;(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);</span></a>
<a name="5195"><span class="lineNum">    5195 </span><span class="lineCov">       1672 :                if (func_symbol == NULL)</span></a>
<a name="5196"><span class="lineNum">    5196 </span>            :                   {</a>
<a name="5197"><span class="lineNum">    5197 </span><span class="lineNoCov">          0 :                     printf (&quot;ERROR caught in SageBuilder::buildDefiningMemberFunctionDeclaration(): nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n&quot;,nameWithTemplateArguments.c_str(),buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</span></a>
<a name="5198"><span class="lineNum">    5198 </span><span class="lineNoCov">          0 :                     printf (&quot;ERROR caught in SageBuilder::buildDefiningMemberFunctionDeclaration(): func_symbol == NULL for first_nondefining_declaration = %p = %s and func_type = %p = %s \n&quot;,</span></a>
<a name="5199"><span class="lineNum">    5199 </span><span class="lineNoCov">          0 :                          templateInstantiationMemberFunctionDecl,templateInstantiationMemberFunctionDecl-&gt;class_name().c_str(),func_type,func_type-&gt;class_name().c_str());</span></a>
<a name="5200"><span class="lineNum">    5200 </span>            :                   }</a>
<a name="5201"><span class="lineNum">    5201 </span>            :             // ROSE_ASSERT(func_symbol != NULL);</a>
<a name="5202"><span class="lineNum">    5202 </span>            :              }</a>
<a name="5203"><span class="lineNum">    5203 </span>            : #endif</a>
<a name="5204"><span class="lineNum">    5204 </span>            : </a>
<a name="5205"><span class="lineNum">    5205 </span>            :        // result = buildDefiningFunctionDeclaration_T &lt;SgTemplateInstantiationMemberFunctionDecl&gt; (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,templateInstantiationMemberFunctionDecl);</a>
<a name="5206"><span class="lineNum">    5206 </span><span class="lineCov">       1672 :           result = buildDefiningFunctionDeclaration_T &lt;SgTemplateInstantiationMemberFunctionDecl&gt; (name, return_type, paralist, /* isMemberFunction = */ true, scope, decoratorList, functionConstVolatileFlags, templateInstantiationMemberFunctionDecl, templateArgumentsList);</span></a>
<a name="5207"><span class="lineNum">    5207 </span>            : #if 0</a>
<a name="5208"><span class="lineNum">    5208 </span>            :           printf (&quot;In SageBuilder::buildDefiningMemberFunctionDeclaration(): isSgTemplateInstantiationMemberFunctionDecl(result)-&gt;get_templateName() = %s \n&quot;,isSgTemplateInstantiationMemberFunctionDecl(result)-&gt;get_templateName().str());</a>
<a name="5209"><span class="lineNum">    5209 </span>            : #endif</a>
<a name="5210"><span class="lineNum">    5210 </span><span class="lineCov">       1672 :           ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result) != NULL);</span></a>
<a name="5211"><span class="lineNum">    5211 </span><span class="lineCov">       1672 :           ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result)-&gt;get_templateName().is_null() == false);</span></a>
<a name="5212"><span class="lineNum">    5212 </span>            :         }</a>
<a name="5213"><span class="lineNum">    5213 </span>            :        else</a>
<a name="5214"><span class="lineNum">    5214 </span>            :         {</a>
<a name="5215"><span class="lineNum">    5215 </span><span class="lineCov">       2671 :           ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="5216"><span class="lineNum">    5216 </span>            : </a>
<a name="5217"><span class="lineNum">    5217 </span>            :        // DQ (12/27/20134): Added these to permit testing earlier than in the buildDefiningFunctionDeclaration_T() function.</a>
<a name="5218"><span class="lineNum">    5218 </span><span class="lineCov">       2671 :           ROSE_ASSERT(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="5219"><span class="lineNum">    5219 </span><span class="lineCov">       2671 :           ROSE_ASSERT(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() == first_nondefining_declaration);</span></a>
<a name="5220"><span class="lineNum">    5220 </span>            : </a>
<a name="5221"><span class="lineNum">    5221 </span><span class="lineCov">       2671 :           result = buildDefiningFunctionDeclaration_T &lt;SgMemberFunctionDeclaration&gt; (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,first_nondefining_declaration, NULL);</span></a>
<a name="5222"><span class="lineNum">    5222 </span>            :         }</a>
<a name="5223"><span class="lineNum">    5223 </span>            : #endif</a>
<a name="5224"><span class="lineNum">    5224 </span>            : </a>
<a name="5225"><span class="lineNum">    5225 </span><span class="lineCov">       4343 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="5226"><span class="lineNum">    5226 </span>            : </a>
<a name="5227"><span class="lineNum">    5227 </span>            :   // set definingdecl for SgCtorInitializerList</a>
<a name="5228"><span class="lineNum">    5228 </span><span class="lineCov">       4343 :      SgCtorInitializerList* ctor = result-&gt;get_CtorInitializerList();</span></a>
<a name="5229"><span class="lineNum">    5229 </span><span class="lineCov">       4343 :      ROSE_ASSERT(ctor != NULL);</span></a>
<a name="5230"><span class="lineNum">    5230 </span>            : </a>
<a name="5231"><span class="lineNum">    5231 </span>            :   // required ty AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()</a>
<a name="5232"><span class="lineNum">    5232 </span><span class="lineCov">       4343 :      ctor-&gt;set_definingDeclaration(ctor);</span></a>
<a name="5233"><span class="lineNum">    5233 </span><span class="lineCov">       4343 :      ctor-&gt;set_firstNondefiningDeclaration(ctor);</span></a>
<a name="5234"><span class="lineNum">    5234 </span>            : </a>
<a name="5235"><span class="lineNum">    5235 </span>            : //     if (result-&gt;get_associatedClassDeclaration() == NULL &amp;&amp; first_nondefining_declaration != NULL &amp;&amp; first_nondefining_declaration-&gt;get_associatedClassDeclaration() != NULL)</a>
<a name="5236"><span class="lineNum">    5236 </span>            : //       result-&gt;set_associatedClassDeclaration(first_nondefining_declaration-&gt;get_associatedClassDeclaration());</a>
<a name="5237"><span class="lineNum">    5237 </span>            : </a>
<a name="5238"><span class="lineNum">    5238 </span>            :   // DQ (1/4/2009): Error checking</a>
<a name="5239"><span class="lineNum">    5239 </span><span class="lineCov">       4343 :      ROSE_ASSERT(result-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="5240"><span class="lineNum">    5240 </span>            : #if 0</a>
<a name="5241"><span class="lineNum">    5241 </span>            :      printf (&quot;Looking up name = %s in scope = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="5242"><span class="lineNum">    5242 </span>            :   // ROSE_ASSERT(scope-&gt;lookup_template_symbol(name) != NULL);</a>
<a name="5243"><span class="lineNum">    5243 </span>            :      ROSE_ASSERT(scope-&gt;lookup_template_symbol(name,templateParameterList) != NULL);</a>
<a name="5244"><span class="lineNum">    5244 </span>            : #endif</a>
<a name="5245"><span class="lineNum">    5245 </span>            : </a>
<a name="5246"><span class="lineNum">    5246 </span><span class="lineCov">       4343 :      return result;</span></a>
<a name="5247"><span class="lineNum">    5247 </span>            :    }</a>
<a name="5248"><span class="lineNum">    5248 </span>            : </a>
<a name="5249"><span class="lineNum">    5249 </span>            : </a>
<a name="5250"><span class="lineNum">    5250 </span>            : //----------------- defining function declaration------------</a>
<a name="5251"><span class="lineNum">    5251 </span>            : // a template builder for all kinds of defining SgFunctionDeclaration</a>
<a name="5252"><span class="lineNum">    5252 </span>            : // handle common chores for function type, symbol, paramter etc.</a>
<a name="5253"><span class="lineNum">    5253 </span>            : </a>
<a name="5254"><span class="lineNum">    5254 </span>            : template &lt;class actualFunction&gt;</a>
<a name="5255"><span class="lineNum">    5255 </span>            : actualFunction*</a>
<a name="5256"><span class="lineNum">    5256 </span><span class="lineCov">      19243 : SageBuilder::buildDefiningFunctionDeclaration_T(const SgName &amp; XXX_name, SgType* return_type, SgFunctionParameterList* paralist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, actualFunction* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)</span></a>
<a name="5257"><span class="lineNum">    5257 </span>            :    {</a>
<a name="5258"><span class="lineNum">    5258 </span>            : #if 0</a>
<a name="5259"><span class="lineNum">    5259 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T():\n&quot;);</a>
<a name="5260"><span class="lineNum">    5260 </span>            :      printf (&quot;  --- XXX_name = %s \n&quot;, XXX_name.str());</a>
<a name="5261"><span class="lineNum">    5261 </span>            :      printf (&quot;  --- return_type = %p (%s) \n&quot;, return_type, return_type ? return_type-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="5262"><span class="lineNum">    5262 </span>            :      printf (&quot;  --- first_nondefining_declaration = %p (%s) \n&quot;, first_nondefining_declaration, first_nondefining_declaration ? first_nondefining_declaration-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="5263"><span class="lineNum">    5263 </span>            : #endif</a>
<a name="5264"><span class="lineNum">    5264 </span>            :   // Note that the semantics of this function now differs from that of the buildDefiningClassDeclaration().</a>
<a name="5265"><span class="lineNum">    5265 </span>            :   // We want to have the non-defining declaration already exist before calling this function.</a>
<a name="5266"><span class="lineNum">    5266 </span>            :   // We could still build a higher level function that built both together.  Or we could provide two versions</a>
<a name="5267"><span class="lineNum">    5267 </span>            :   // named differently (from this one) and depricate this function...which I like much better.</a>
<a name="5268"><span class="lineNum">    5268 </span>            : </a>
<a name="5269"><span class="lineNum">    5269 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="5270"><span class="lineNum">    5270 </span>            :      printf (&quot;WARNING: This function for building defining function declarations has different semantics from that of the function to build defining class declarations. \n&quot;);</a>
<a name="5271"><span class="lineNum">    5271 </span>            : #endif</a>
<a name="5272"><span class="lineNum">    5272 </span>            : </a>
<a name="5273"><span class="lineNum">    5273 </span><span class="lineCov">      19243 :      assert(first_nondefining_declaration != NULL);</span></a>
<a name="5274"><span class="lineNum">    5274 </span><span class="lineCov">      19243 :      assert(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="5275"><span class="lineNum">    5275 </span><span class="lineCov">      19243 :      assert(first_nondefining_declaration-&gt;get_firstNondefiningDeclaration() == first_nondefining_declaration);</span></a>
<a name="5276"><span class="lineNum">    5276 </span>            : </a>
<a name="5277"><span class="lineNum">    5277 </span><span class="lineCov">      19243 :      if (scope == NULL)</span></a>
<a name="5278"><span class="lineNum">    5278 </span>            :         {</a>
<a name="5279"><span class="lineNum">    5279 </span><span class="lineCov">          1 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="5280"><span class="lineNum">    5280 </span>            :         }</a>
<a name="5281"><span class="lineNum">    5281 </span>            : </a>
<a name="5282"><span class="lineNum">    5282 </span><span class="lineCov">      19243 :      ROSE_ASSERT(XXX_name.is_null() == false);</span></a>
<a name="5283"><span class="lineNum">    5283 </span><span class="lineCov">      19243 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="5284"><span class="lineNum">    5284 </span><span class="lineCov">      19243 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="5285"><span class="lineNum">    5285 </span>            : </a>
<a name="5286"><span class="lineNum">    5286 </span><span class="lineCov">      38486 :      SgName nameWithoutTemplateArguments = XXX_name;</span></a>
<a name="5287"><span class="lineNum">    5287 </span><span class="lineCov">      38486 :      SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;</span></a>
<a name="5288"><span class="lineNum">    5288 </span>            : </a>
<a name="5289"><span class="lineNum">    5289 </span><span class="lineCov">      19243 :      bool buildTemplateInstantiation = ((VariantT)actualFunction::static_variant == V_SgTemplateInstantiationFunctionDecl || (VariantT)actualFunction::static_variant == V_SgTemplateInstantiationMemberFunctionDecl);</span></a>
<a name="5290"><span class="lineNum">    5290 </span>            : </a>
<a name="5291"><span class="lineNum">    5291 </span>            :   // DQ (8/7/2013): Added support for template declarations.</a>
<a name="5292"><span class="lineNum">    5292 </span><span class="lineCov">      19243 :      bool buildTemplateDeclaration   = ((VariantT)actualFunction::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration);</span></a>
<a name="5293"><span class="lineNum">    5293 </span>            : </a>
<a name="5294"><span class="lineNum">    5294 </span>            : #if 0</a>
<a name="5295"><span class="lineNum">    5295 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): buildTemplateInstantiation = %s \n&quot;,buildTemplateInstantiation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5296"><span class="lineNum">    5296 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): buildTemplateDeclaration   = %s \n&quot;,buildTemplateDeclaration ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5297"><span class="lineNum">    5297 </span>            : #endif</a>
<a name="5298"><span class="lineNum">    5298 </span>            : </a>
<a name="5299"><span class="lineNum">    5299 </span>            :   // DQ (8/11/2013): Check that the template argument lists are consistant.  The templateArgumentsList can then be considered redundant if this works.</a>
<a name="5300"><span class="lineNum">    5300 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="5301"><span class="lineNum">    5301 </span>            :         {</a>
<a name="5302"><span class="lineNum">    5302 </span><span class="lineCov">       2249 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="5303"><span class="lineNum">    5303 </span>            : </a>
<a name="5304"><span class="lineNum">    5304 </span><span class="lineCov">       2249 :           SgTemplateArgumentPtrList &amp; templateArgumentsList_from_first_nondefining_declaration = (isMemberFunction == false) ?</span></a>
<a name="5305"><span class="lineNum">    5305 </span>            :                isSgTemplateInstantiationFunctionDecl(first_nondefining_declaration)-&gt;get_templateArguments() :</a>
<a name="5306"><span class="lineNum">    5306 </span>            :                isSgTemplateInstantiationMemberFunctionDecl(first_nondefining_declaration)-&gt;get_templateArguments();</a>
<a name="5307"><span class="lineNum">    5307 </span>            : </a>
<a name="5308"><span class="lineNum">    5308 </span><span class="lineCov">       2249 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="5309"><span class="lineNum">    5309 </span>            : #if 0</a>
<a name="5310"><span class="lineNum">    5310 </span>            :        // printf (&quot;templateArgumentsList                                           = %p \n&quot;,templateArgumentsList);</a>
<a name="5311"><span class="lineNum">    5311 </span>            :           printf (&quot;templateArgumentsList = %p templateArgumentsList-&gt;size() = %zu \n&quot;,templateArgumentsList,templateArgumentsList-&gt;size());</a>
<a name="5312"><span class="lineNum">    5312 </span>            :           printf (&quot;templateArgumentsList_from_first_nondefining_declaration.size()      = %zu \n&quot;,templateArgumentsList_from_first_nondefining_declaration.size());</a>
<a name="5313"><span class="lineNum">    5313 </span>            : #endif</a>
<a name="5314"><span class="lineNum">    5314 </span>            : #if 1</a>
<a name="5315"><span class="lineNum">    5315 </span><span class="lineCov">       2249 :           bool templateArgumentListsAreEquivalent = SageInterface::templateArgumentListEquivalence(*templateArgumentsList, templateArgumentsList_from_first_nondefining_declaration);</span></a>
<a name="5316"><span class="lineNum">    5316 </span>            : #if 0</a>
<a name="5317"><span class="lineNum">    5317 </span>            :        // DQ (3/21/2017): Removing debugging code (leaving assertion).</a>
<a name="5318"><span class="lineNum">    5318 </span>            :           if (templateArgumentListsAreEquivalent == false)</a>
<a name="5319"><span class="lineNum">    5319 </span>            :              {</a>
<a name="5320"><span class="lineNum">    5320 </span>            :                printf (&quot;after test: nameWithoutTemplateArguments  = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="5321"><span class="lineNum">    5321 </span>            :                printf (&quot;after test: nameWithTemplateArguments     = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="5322"><span class="lineNum">    5322 </span>            :                printf (&quot;after test: templateArgumentsList         = %p \n&quot;,templateArgumentsList);</a>
<a name="5323"><span class="lineNum">    5323 </span>            :                printf (&quot;after test: templateArgumentsList-&gt;size() = %zu \n&quot;,templateArgumentsList != NULL ? templateArgumentsList-&gt;size() : (size_t)0L);</a>
<a name="5324"><span class="lineNum">    5324 </span>            :                printf (&quot;after test: templateArgumentsList_from_first_nondefining_declaration.size() = %zu \n&quot;,templateArgumentsList_from_first_nondefining_declaration.size());</a>
<a name="5325"><span class="lineNum">    5325 </span>            :                if (first_nondefining_declaration != NULL)</a>
<a name="5326"><span class="lineNum">    5326 </span>            :                   {</a>
<a name="5327"><span class="lineNum">    5327 </span>            :                     printf (&quot;first_nondefining_declaration = %p = %s = %s \n&quot;,first_nondefining_declaration,</a>
<a name="5328"><span class="lineNum">    5328 </span>            :                          first_nondefining_declaration-&gt;class_name().c_str(),first_nondefining_declaration-&gt;get_name().str());</a>
<a name="5329"><span class="lineNum">    5329 </span>            :                     ROSE_ASSERT(first_nondefining_declaration-&gt;get_file_info() != NULL);</a>
<a name="5330"><span class="lineNum">    5330 </span>            :                     first_nondefining_declaration-&gt;get_file_info()-&gt;display(&quot;first_nondefining_declaration: debug&quot;);</a>
<a name="5331"><span class="lineNum">    5331 </span>            :                   }</a>
<a name="5332"><span class="lineNum">    5332 </span>            :              }</a>
<a name="5333"><span class="lineNum">    5333 </span>            : #endif</a>
<a name="5334"><span class="lineNum">    5334 </span><span class="lineCov">       2249 :           ROSE_ASSERT(templateArgumentListsAreEquivalent == true);</span></a>
<a name="5335"><span class="lineNum">    5335 </span>            : #else</a>
<a name="5336"><span class="lineNum">    5336 </span>            :           ROSE_ASSERT(SageInterface::templateArgumentListEquivalence(*templateArgumentsList, templateArgumentsList_from_first_nondefining_declaration));</a>
<a name="5337"><span class="lineNum">    5337 </span>            : #endif</a>
<a name="5338"><span class="lineNum">    5338 </span>            :         }</a>
<a name="5339"><span class="lineNum">    5339 </span>            : </a>
<a name="5340"><span class="lineNum">    5340 </span><span class="lineCov">      11076 :      SgTemplateParameterPtrList* templateParameterList = NULL;</span></a>
<a name="5341"><span class="lineNum">    5341 </span>            :      if (buildTemplateDeclaration == true)</a>
<a name="5342"><span class="lineNum">    5342 </span>            :         {</a>
<a name="5343"><span class="lineNum">    5343 </span>            :        // DQ (8/11/2013): Since this is not passed in so we can access it but not assert its equivalence with a redundant input parameter.</a>
<a name="5344"><span class="lineNum">    5344 </span><span class="lineCov">      11076 :           templateParameterList = (isMemberFunction == false) ?</span></a>
<a name="5345"><span class="lineNum">    5345 </span><span class="lineCov">       3199 :                &amp;(isSgTemplateFunctionDeclaration(first_nondefining_declaration)-&gt;get_templateParameters()) :</span></a>
<a name="5346"><span class="lineNum">    5346 </span><span class="lineCov">       7877 :                &amp;(isSgTemplateMemberFunctionDeclaration(first_nondefining_declaration)-&gt;get_templateParameters());</span></a>
<a name="5347"><span class="lineNum">    5347 </span>            : </a>
<a name="5348"><span class="lineNum">    5348 </span><span class="lineCov">      11076 :           ROSE_ASSERT(templateArgumentsList == NULL);</span></a>
<a name="5349"><span class="lineNum">    5349 </span><span class="lineCov">      11076 :           ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="5350"><span class="lineNum">    5350 </span>            : #if 0</a>
<a name="5351"><span class="lineNum">    5351 </span>            :           if (templateParameterList != NULL)</a>
<a name="5352"><span class="lineNum">    5352 </span>            :              {</a>
<a name="5353"><span class="lineNum">    5353 </span>            :                 ROSE_ASSERT(templateArgumentsList == NULL);</a>
<a name="5354"><span class="lineNum">    5354 </span>            :              }</a>
<a name="5355"><span class="lineNum">    5355 </span>            :           ROSE_ASSERT(templateParameterList == NULL || templateParameterList-&gt;size() == templateArgumentsList-&gt;size());</a>
<a name="5356"><span class="lineNum">    5356 </span>            : #endif</a>
<a name="5357"><span class="lineNum">    5357 </span>            :         }</a>
<a name="5358"><span class="lineNum">    5358 </span>            : </a>
<a name="5359"><span class="lineNum">    5359 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="5360"><span class="lineNum">    5360 </span>            :         {</a>
<a name="5361"><span class="lineNum">    5361 </span><span class="lineCov">       2249 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="5362"><span class="lineNum">    5362 </span><span class="lineCov">       2249 :           nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);</span></a>
<a name="5363"><span class="lineNum">    5363 </span>            : #if 0</a>
<a name="5364"><span class="lineNum">    5364 </span>            :           printf (&quot;Building a defining function: buildDefiningFunctionDeclaration_nfi() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n&quot;,nameWithTemplateArguments.str(),buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</a>
<a name="5365"><span class="lineNum">    5365 </span>            : #endif</a>
<a name="5366"><span class="lineNum">    5366 </span>            : </a>
<a name="5367"><span class="lineNum">    5367 </span><span class="lineCov">       2249 :           if (nameWithTemplateArguments == &quot;insert &lt; __normal_iterator&lt; SgInitializedName ** , __type  &gt;  &gt; &quot;)</span></a>
<a name="5368"><span class="lineNum">    5368 </span>            :              {</a>
<a name="5369"><span class="lineNum">    5369 </span><span class="lineCov">      16994 :                printf (&quot;In buildDefiningFunctionDeclaration_T(): Found function nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</span></a>
<a name="5370"><span class="lineNum">    5370 </span>            :              }</a>
<a name="5371"><span class="lineNum">    5371 </span>            :         }</a>
<a name="5372"><span class="lineNum">    5372 </span>            : </a>
<a name="5373"><span class="lineNum">    5373 </span>            : #if 0</a>
<a name="5374"><span class="lineNum">    5374 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="5375"><span class="lineNum">    5375 </span>            : #endif</a>
<a name="5376"><span class="lineNum">    5376 </span>            : </a>
<a name="5377"><span class="lineNum">    5377 </span><span class="lineCov">      19243 :      ROSE_ASSERT(nameWithoutTemplateArguments.is_null() == false);</span></a>
<a name="5378"><span class="lineNum">    5378 </span><span class="lineCov">      19243 :      ROSE_ASSERT(nameWithTemplateArguments.is_null() == false);</span></a>
<a name="5379"><span class="lineNum">    5379 </span>            : </a>
<a name="5380"><span class="lineNum">    5380 </span>            :   // DQ (12/3/2011): Added more checking.</a>
<a name="5381"><span class="lineNum">    5381 </span><span class="lineCov">      19243 :      ROSE_ASSERT(paralist != NULL);</span></a>
<a name="5382"><span class="lineNum">    5382 </span>            : </a>
<a name="5383"><span class="lineNum">    5383 </span>            : // CR (3/28/2020): Changed to call a function to support multiple languages</a>
<a name="5384"><span class="lineNum">    5384 </span><span class="lineCov">      19243 :      if (SageInterface::language_may_contain_nondeclarations_in_scope() == false)</span></a>
<a name="5385"><span class="lineNum">    5385 </span>            :         {</a>
<a name="5386"><span class="lineNum">    5386 </span><span class="lineCov">      19238 :            ROSE_ASSERT(scope-&gt;containsOnlyDeclarations());</span></a>
<a name="5387"><span class="lineNum">    5387 </span>            :         }</a>
<a name="5388"><span class="lineNum">    5388 </span>            : </a>
<a name="5389"><span class="lineNum">    5389 </span>            :   // actualFunction* firstNondefiningFunctionDeclaration = NULL;</a>
<a name="5390"><span class="lineNum">    5390 </span><span class="lineCov">      19243 :      actualFunction* defining_func = NULL;</span></a>
<a name="5391"><span class="lineNum">    5391 </span>            : </a>
<a name="5392"><span class="lineNum">    5392 </span>            :   // build function type, manage function type symbol internally</a>
<a name="5393"><span class="lineNum">    5393 </span>            :   // SgFunctionType* func_type = buildFunctionType(return_type,paralist);</a>
<a name="5394"><span class="lineNum">    5394 </span><span class="lineCov">      19243 :      SgFunctionType* func_type = NULL;</span></a>
<a name="5395"><span class="lineNum">    5395 </span>            : </a>
<a name="5396"><span class="lineNum">    5396 </span>            :   // DQ (5/11/2012): Enforce this so that we can avoid building the function type (be reusing the function type of the first non-defining declaration).</a>
<a name="5397"><span class="lineNum">    5397 </span>            :   // This is a special problem for templates because the function parameters will evaluate different for different builds of the same template.</a>
<a name="5398"><span class="lineNum">    5398 </span>            :   // This is a problem for test2012_74.C (and a dozen other test codes that make use of STL).</a>
<a name="5399"><span class="lineNum">    5399 </span><span class="lineCov">      19243 :      ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="5400"><span class="lineNum">    5400 </span>            : </a>
<a name="5401"><span class="lineNum">    5401 </span>            : #if 0</a>
<a name="5402"><span class="lineNum">    5402 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): isMemberFunction = %s \n&quot;,isMemberFunction ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5403"><span class="lineNum">    5403 </span>            : #endif</a>
<a name="5404"><span class="lineNum">    5404 </span>            : </a>
<a name="5405"><span class="lineNum">    5405 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="5406"><span class="lineNum">    5406 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="5407"><span class="lineNum">    5407 </span>            :   // DQ (7/27/2012): There are reasons why this can fail: e.g. for functions with names such as:</a>
<a name="5408"><span class="lineNum">    5408 </span>            :   // &quot;operator std::auto_ptr_ref&lt;_Tp1&gt;&quot; which is a user defined conversion operator to one class from another.</a>
<a name="5409"><span class="lineNum">    5409 </span>            :   // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);</a>
<a name="5410"><span class="lineNum">    5410 </span>            : </a>
<a name="5411"><span class="lineNum">    5411 </span>            : #if 1</a>
<a name="5412"><span class="lineNum">    5412 </span>            :   // DQ (5/12/2012): Use the newly added parameter to get the exact SgFunctionType used to build the symbol.</a>
<a name="5413"><span class="lineNum">    5413 </span>            :   // This should make the template handling more robust since we were sometimes using types that had different</a>
<a name="5414"><span class="lineNum">    5414 </span>            :   // levels of template instantiation between the non-definng and defining function declarations and this</a>
<a name="5415"><span class="lineNum">    5415 </span>            :   // caused symbols build to support the non-defining declaration to not be found when we searched for them</a>
<a name="5416"><span class="lineNum">    5416 </span>            :   // using the function type built for the defining declaration.  We want the function types for all defining</a>
<a name="5417"><span class="lineNum">    5417 </span>            :   // and non-defining declarations to be identical.  This define also means that we don't have to build a</a>
<a name="5418"><span class="lineNum">    5418 </span>            :   // SgFunctionType just to look up a symbol in the symbol table (which was always silly).  However, only</a>
<a name="5419"><span class="lineNum">    5419 </span>            :   // the defining function declaration can use the existing function type because it is required that a</a>
<a name="5420"><span class="lineNum">    5420 </span>            :   // non-defining declaration exist prior to the construction of the defining declaration (built by this</a>
<a name="5421"><span class="lineNum">    5421 </span>            :   // function).</a>
<a name="5422"><span class="lineNum">    5422 </span><span class="lineCov">      19243 :      func_type = first_nondefining_declaration-&gt;get_type();</span></a>
<a name="5423"><span class="lineNum">    5423 </span>            : #else</a>
<a name="5424"><span class="lineNum">    5424 </span>            :      if (isMemberFunction == true)</a>
<a name="5425"><span class="lineNum">    5425 </span>            :         {</a>
<a name="5426"><span class="lineNum">    5426 </span>            : #if 0</a>
<a name="5427"><span class="lineNum">    5427 </span>            :           printf (&quot;return_type = %p = %s \n&quot;,return_type,return_type-&gt;class_name().c_str());</a>
<a name="5428"><span class="lineNum">    5428 </span>            : #endif</a>
<a name="5429"><span class="lineNum">    5429 </span>            :           ROSE_ASSERT(isSgClassDefinition(scope) != NULL);</a>
<a name="5430"><span class="lineNum">    5430 </span>            :        // func_type = buildMemberFunctionType(return_type,paralist,isSgClassDefinition(scope),0);</a>
<a name="5431"><span class="lineNum">    5431 </span>            :           func_type = buildMemberFunctionType(return_type,paralist,isSgClassDefinition(scope),functionConstVolatileFlags);</a>
<a name="5432"><span class="lineNum">    5432 </span>            :         }</a>
<a name="5433"><span class="lineNum">    5433 </span>            :        else</a>
<a name="5434"><span class="lineNum">    5434 </span>            :         {</a>
<a name="5435"><span class="lineNum">    5435 </span>            :           func_type = buildFunctionType(return_type,paralist);</a>
<a name="5436"><span class="lineNum">    5436 </span>            :         }</a>
<a name="5437"><span class="lineNum">    5437 </span>            : #endif</a>
<a name="5438"><span class="lineNum">    5438 </span><span class="lineCov">      19243 :      ROSE_ASSERT(func_type != NULL);</span></a>
<a name="5439"><span class="lineNum">    5439 </span>            : </a>
<a name="5440"><span class="lineNum">    5440 </span>            :   // Make sure these are the same (this will fail until we generate the func_type directly from first_nondefining_declaration).</a>
<a name="5441"><span class="lineNum">    5441 </span><span class="lineCov">      19243 :      ROSE_ASSERT(func_type == first_nondefining_declaration-&gt;get_type());</span></a>
<a name="5442"><span class="lineNum">    5442 </span>            : </a>
<a name="5443"><span class="lineNum">    5443 </span><span class="lineCov">      19243 :      SgDeclarationStatement* firstNondefiningFunctionDeclaration = NULL;</span></a>
<a name="5444"><span class="lineNum">    5444 </span>            : </a>
<a name="5445"><span class="lineNum">    5445 </span>            : #if 0</a>
<a name="5446"><span class="lineNum">    5446 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): scope     = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="5447"><span class="lineNum">    5447 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): func_type = %p = %s \n&quot;,func_type,func_type-&gt;class_name().c_str());</a>
<a name="5448"><span class="lineNum">    5448 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): Looking for function in symbol table with nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="5449"><span class="lineNum">    5449 </span>            : #endif</a>
<a name="5450"><span class="lineNum">    5450 </span>            : </a>
<a name="5451"><span class="lineNum">    5451 </span>            :   // symbol table and non-defining</a>
<a name="5452"><span class="lineNum">    5452 </span>            :   // SgFunctionSymbol *func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="5453"><span class="lineNum">    5453 </span>            :   // SgSymbol* func_symbol = scope-&gt;lookup_function_symbol(name,func_type);</a>
<a name="5454"><span class="lineNum">    5454 </span>            : </a>
<a name="5455"><span class="lineNum">    5455 </span><span class="lineCov">      19243 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="5456"><span class="lineNum">    5456 </span>            :   // ROSE_ASSERT(scope-&gt;get_symbol_table() != NULL);</a>
<a name="5457"><span class="lineNum">    5457 </span>            : </a>
<a name="5458"><span class="lineNum">    5458 </span>            :   // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.</a>
<a name="5459"><span class="lineNum">    5459 </span>            :   // SgSymbol* func_symbol = scope-&gt;get_symbol_table()-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(name,func_type);</a>
<a name="5460"><span class="lineNum">    5460 </span>            :   // SgSymbol* func_symbol = scope-&gt;get_symbol_table()-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5461"><span class="lineNum">    5461 </span>            :   // SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5462"><span class="lineNum">    5462 </span>            :   // SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);</a>
<a name="5463"><span class="lineNum">    5463 </span><span class="lineCov">      19243 :      SgSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);</span></a>
<a name="5464"><span class="lineNum">    5464 </span>            : </a>
<a name="5465"><span class="lineNum">    5465 </span>            : #if 0</a>
<a name="5466"><span class="lineNum">    5466 </span>            :      if (func_symbol == NULL)</a>
<a name="5467"><span class="lineNum">    5467 </span>            :         {</a>
<a name="5468"><span class="lineNum">    5468 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): could not find function symbol for name = %s \n&quot;,name.str());</a>
<a name="5469"><span class="lineNum">    5469 </span>            : </a>
<a name="5470"><span class="lineNum">    5470 </span>            :        // Look for the template function</a>
<a name="5471"><span class="lineNum">    5471 </span>            :        // func_symbol = scope-&gt;lookup_template_symbol(name,func_type);</a>
<a name="5472"><span class="lineNum">    5472 </span>            :        // func_symbol = scope-&gt;lookup_template_symbol(name);</a>
<a name="5473"><span class="lineNum">    5473 </span>            : </a>
<a name="5474"><span class="lineNum">    5474 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="5475"><span class="lineNum">    5475 </span>            : </a>
<a name="5476"><span class="lineNum">    5476 </span>            :        // DQ (3/10/2012): Fix this to call lookup_template_function_symbol() instead.</a>
<a name="5477"><span class="lineNum">    5477 </span>            :        // func_symbol = scope-&gt;lookup_template_symbol(name);</a>
<a name="5478"><span class="lineNum">    5478 </span>            :           func_symbol = scope-&gt;lookup_template_function_symbol(name,func_type);</a>
<a name="5479"><span class="lineNum">    5479 </span>            : </a>
<a name="5480"><span class="lineNum">    5480 </span>            :           if (func_symbol == NULL)</a>
<a name="5481"><span class="lineNum">    5481 </span>            :              {</a>
<a name="5482"><span class="lineNum">    5482 </span>            :                printf (&quot;In buildDefiningFunctionDeclaration_T(): could not find template symbol for name = %s \n&quot;,name.str());</a>
<a name="5483"><span class="lineNum">    5483 </span>            :              }</a>
<a name="5484"><span class="lineNum">    5484 </span>            :           ROSE_ASSERT(func_symbol != NULL);</a>
<a name="5485"><span class="lineNum">    5485 </span>            :         }</a>
<a name="5486"><span class="lineNum">    5486 </span>            : #else</a>
<a name="5487"><span class="lineNum">    5487 </span>            : #if 0</a>
<a name="5488"><span class="lineNum">    5488 </span>            :   // DQ (3/21/2017): Removing debugging code (leaving assertion).</a>
<a name="5489"><span class="lineNum">    5489 </span>            :   // DQ (5/10/2012): This is a failing assertion, I'm not sure that we can enforce this in general (see test2004_149.C).</a>
<a name="5490"><span class="lineNum">    5490 </span>            :   // DQ (3/13/2012): Note that this function building a defining declaration can enforce that the non-defining declaration has already build a proper symbol.</a>
<a name="5491"><span class="lineNum">    5491 </span>            :      if (func_symbol == NULL)</a>
<a name="5492"><span class="lineNum">    5492 </span>            :         {</a>
<a name="5493"><span class="lineNum">    5493 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_symbol == NULL We can't assume that the symbol already exists. \n&quot;);</a>
<a name="5494"><span class="lineNum">    5494 </span>            : </a>
<a name="5495"><span class="lineNum">    5495 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="5496"><span class="lineNum">    5496 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration = %p = %s \n&quot;,</a>
<a name="5497"><span class="lineNum">    5497 </span>            :                first_nondefining_declaration,first_nondefining_declaration-&gt;class_name().c_str());</a>
<a name="5498"><span class="lineNum">    5498 </span>            : </a>
<a name="5499"><span class="lineNum">    5499 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): scope                    = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="5500"><span class="lineNum">    5500 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration-&gt;get_scope() = %p = %s \n&quot;,</a>
<a name="5501"><span class="lineNum">    5501 </span>            :                first_nondefining_declaration-&gt;get_scope(),first_nondefining_declaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="5502"><span class="lineNum">    5502 </span>            : </a>
<a name="5503"><span class="lineNum">    5503 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_type                = %p = %s \n&quot;,func_type,func_type-&gt;class_name().c_str());</a>
<a name="5504"><span class="lineNum">    5504 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="5505"><span class="lineNum">    5505 </span>            :                first_nondefining_declaration-&gt;get_type(),first_nondefining_declaration-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="5506"><span class="lineNum">    5506 </span>            : </a>
<a name="5507"><span class="lineNum">    5507 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_type-&gt;get_mangled() = %s \n&quot;,func_type-&gt;get_mangled().str());</a>
<a name="5508"><span class="lineNum">    5508 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): Looking for function in symbol table with name = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="5509"><span class="lineNum">    5509 </span>            : </a>
<a name="5510"><span class="lineNum">    5510 </span>            : #if 0</a>
<a name="5511"><span class="lineNum">    5511 </span>            :           scope-&gt;get_symbol_table()-&gt;print(&quot;In SageBuilder::buildDefiningFunctionDeclaration_T()&quot;);</a>
<a name="5512"><span class="lineNum">    5512 </span>            : #endif</a>
<a name="5513"><span class="lineNum">    5513 </span>            : </a>
<a name="5514"><span class="lineNum">    5514 </span>            :        // DQ (1/29/2013): Retry using the name from the non-definging function declaration.</a>
<a name="5515"><span class="lineNum">    5515 </span>            :           SgFunctionDeclaration* nondefiningFunctionDeclaration = isSgFunctionDeclaration(first_nondefining_declaration);</a>
<a name="5516"><span class="lineNum">    5516 </span>            :           ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="5517"><span class="lineNum">    5517 </span>            : </a>
<a name="5518"><span class="lineNum">    5518 </span>            :           nameWithTemplateArguments = nondefiningFunctionDeclaration-&gt;get_name();</a>
<a name="5519"><span class="lineNum">    5519 </span>            : </a>
<a name="5520"><span class="lineNum">    5520 </span>            :        // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.</a>
<a name="5521"><span class="lineNum">    5521 </span>            :        // func_symbol = scope-&gt;get_symbol_table()-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5522"><span class="lineNum">    5522 </span>            :        // func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type);</a>
<a name="5523"><span class="lineNum">    5523 </span>            :        // func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,templateArgumentsList);</a>
<a name="5524"><span class="lineNum">    5524 </span>            :        // func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);</a>
<a name="5525"><span class="lineNum">    5525 </span>            :           func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;actualFunction&gt;(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);</a>
<a name="5526"><span class="lineNum">    5526 </span>            : </a>
<a name="5527"><span class="lineNum">    5527 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_symbol = %p reset using lookup with reset nameWithTemplateArguments = %s \n&quot;,func_symbol,nameWithTemplateArguments.str());</a>
<a name="5528"><span class="lineNum">    5528 </span>            : </a>
<a name="5529"><span class="lineNum">    5529 </span>            :           ROSE_ASSERT(func_symbol != NULL);</a>
<a name="5530"><span class="lineNum">    5530 </span>            : </a>
<a name="5531"><span class="lineNum">    5531 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_symbol = %p = %s reset using lookup with reset nameWithTemplateArguments = %s \n&quot;,func_symbol,func_symbol-&gt;class_name().c_str(),nameWithTemplateArguments.str());</a>
<a name="5532"><span class="lineNum">    5532 </span>            : #if 0</a>
<a name="5533"><span class="lineNum">    5533 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="5534"><span class="lineNum">    5534 </span>            :           ROSE_ABORT();</a>
<a name="5535"><span class="lineNum">    5535 </span>            : #endif</a>
<a name="5536"><span class="lineNum">    5536 </span>            :         }</a>
<a name="5537"><span class="lineNum">    5537 </span>            : #endif</a>
<a name="5538"><span class="lineNum">    5538 </span>            : </a>
<a name="5539"><span class="lineNum">    5539 </span>            :   // DQ (1/26/2013): This fails for ROSE compiling ROSE.</a>
<a name="5540"><span class="lineNum">    5540 </span><span class="lineCov">      19243 :      ROSE_ASSERT(func_symbol != NULL);</span></a>
<a name="5541"><span class="lineNum">    5541 </span>            : #endif</a>
<a name="5542"><span class="lineNum">    5542 </span>            : </a>
<a name="5543"><span class="lineNum">    5543 </span>            : #if 0</a>
<a name="5544"><span class="lineNum">    5544 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): func_symbol = %p \n&quot;,func_symbol);</a>
<a name="5545"><span class="lineNum">    5545 </span>            : #endif</a>
<a name="5546"><span class="lineNum">    5546 </span>            : </a>
<a name="5547"><span class="lineNum">    5547 </span>            : #if 0</a>
<a name="5548"><span class="lineNum">    5548 </span>            :   // Not ready for member functions yet, need to generate SgMemberFucntionType instead of SgFunctionType.</a>
<a name="5549"><span class="lineNum">    5549 </span>            :      printf (&quot;Not ready for member functions yet, need to generate SgMemberFucntionType instead of SgFunctionType. \n&quot;);</a>
<a name="5550"><span class="lineNum">    5550 </span>            :      ROSE_ASSERT(isMemberFunction == false);</a>
<a name="5551"><span class="lineNum">    5551 </span>            : #endif</a>
<a name="5552"><span class="lineNum">    5552 </span>            : </a>
<a name="5553"><span class="lineNum">    5553 </span>            :      if (func_symbol == NULL)</a>
<a name="5554"><span class="lineNum">    5554 </span>            :         {</a>
<a name="5555"><span class="lineNum">    5555 </span>            :           printf (&quot;Could not find an existing symbol for this function! \n&quot;);</a>
<a name="5556"><span class="lineNum">    5556 </span>            :        // scope-&gt;get_symbol_table()-&gt;print(&quot;Could not find an existing symbol for this function!&quot;);</a>
<a name="5557"><span class="lineNum">    5557 </span>            : </a>
<a name="5558"><span class="lineNum">    5558 </span>            :        // DQ (12/2/2011): After discussion with Liao, we think this should be an error.</a>
<a name="5559"><span class="lineNum">    5559 </span>            :        // The defining declaration requires that the associated non-defining declaration should already exist.</a>
<a name="5560"><span class="lineNum">    5560 </span>            :        // If required, a higher level build function could build both of these and connect them as required.</a>
<a name="5561"><span class="lineNum">    5561 </span>            :           printf (&quot;Error: building a defining declaration requires that the associated non-defining declaration already exists and it's symbol found the the same scope's symbol table! \n&quot;);</a>
<a name="5562"><span class="lineNum">    5562 </span>            :           ROSE_ABORT();</a>
<a name="5563"><span class="lineNum">    5563 </span>            : #if 0</a>
<a name="5564"><span class="lineNum">    5564 </span>            :        // new defining declaration</a>
<a name="5565"><span class="lineNum">    5565 </span>            :        // func = new SgFunctionDeclaration(name,func_type,NULL);</a>
<a name="5566"><span class="lineNum">    5566 </span>            :           defining_func = new actualFunction(name,func_type,NULL);</a>
<a name="5567"><span class="lineNum">    5567 </span>            :           ROSE_ASSERT(defining_func != NULL);</a>
<a name="5568"><span class="lineNum">    5568 </span>            : </a>
<a name="5569"><span class="lineNum">    5569 </span>            :           firstNondefiningFunctionDeclaration = defining_func;</a>
<a name="5570"><span class="lineNum">    5570 </span>            :           ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</a>
<a name="5571"><span class="lineNum">    5571 </span>            : #if 0</a>
<a name="5572"><span class="lineNum">    5572 </span>            :           SgFunctionSymbol *func_symbol = new SgFunctionSymbol(defining_func);</a>
<a name="5573"><span class="lineNum">    5573 </span>            :           scope-&gt;insert_symbol(name, func_symbol);</a>
<a name="5574"><span class="lineNum">    5574 </span>            :           defining_func-&gt;set_firstNondefiningDeclaration(NULL);</a>
<a name="5575"><span class="lineNum">    5575 </span>            : #else</a>
<a name="5576"><span class="lineNum">    5576 </span>            :           printf (&quot;This code may still have to be debugged! \n&quot;);</a>
<a name="5577"><span class="lineNum">    5577 </span>            : </a>
<a name="5578"><span class="lineNum">    5578 </span>            :           if (isSgFunctionDeclaration(defining_func) != NULL)</a>
<a name="5579"><span class="lineNum">    5579 </span>            :              {</a>
<a name="5580"><span class="lineNum">    5580 </span>            :                func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(defining_func));</a>
<a name="5581"><span class="lineNum">    5581 </span>            :                if (isMemberFunction == true)</a>
<a name="5582"><span class="lineNum">    5582 </span>            :                   {</a>
<a name="5583"><span class="lineNum">    5583 </span>            :                     ROSE_ASSERT(isSgMemberFunctionDeclaration(defining_func) != NULL);</a>
<a name="5584"><span class="lineNum">    5584 </span>            :                     func_symbol = new SgMemberFunctionSymbol(isSgMemberFunctionDeclaration(defining_func));</a>
<a name="5585"><span class="lineNum">    5585 </span>            :                   }</a>
<a name="5586"><span class="lineNum">    5586 </span>            :                  else</a>
<a name="5587"><span class="lineNum">    5587 </span>            :                   {</a>
<a name="5588"><span class="lineNum">    5588 </span>            :                     ROSE_ASSERT(isSgFunctionDeclaration(defining_func) != NULL);</a>
<a name="5589"><span class="lineNum">    5589 </span>            :                     func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(defining_func));</a>
<a name="5590"><span class="lineNum">    5590 </span>            :                   }</a>
<a name="5591"><span class="lineNum">    5591 </span>            : </a>
<a name="5592"><span class="lineNum">    5592 </span>            :                ROSE_ASSERT(func_symbol != NULL);</a>
<a name="5593"><span class="lineNum">    5593 </span>            :                ROSE_ASSERT(func_symbol-&gt;get_symbol_basis() != NULL);</a>
<a name="5594"><span class="lineNum">    5594 </span>            :              }</a>
<a name="5595"><span class="lineNum">    5595 </span>            :             else</a>
<a name="5596"><span class="lineNum">    5596 </span>            :              {</a>
<a name="5597"><span class="lineNum">    5597 </span>            :             // How should we handled template functions in the symbol table???</a>
<a name="5598"><span class="lineNum">    5598 </span>            :             // DQ (11/24/2011): After some thought, I think that template declarations for function are more template declarations</a>
<a name="5599"><span class="lineNum">    5599 </span>            :             // than functions.  So all template function declarations will be handled as SgTemplateSymbols and not SgFunctionSymbols.</a>
<a name="5600"><span class="lineNum">    5600 </span>            :                SgTemplateDeclaration* templatedeclaration = isSgTemplateDeclaration(defining_func);</a>
<a name="5601"><span class="lineNum">    5601 </span>            :                ROSE_ASSERT(templatedeclaration != NULL);</a>
<a name="5602"><span class="lineNum">    5602 </span>            :                SgTemplateSymbol* template_symbol = new SgTemplateSymbol(templatedeclaration);</a>
<a name="5603"><span class="lineNum">    5603 </span>            :                ROSE_ASSERT(template_symbol != NULL);</a>
<a name="5604"><span class="lineNum">    5604 </span>            :                ROSE_ASSERT(template_symbol-&gt;get_symbol_basis() != NULL);</a>
<a name="5605"><span class="lineNum">    5605 </span>            : </a>
<a name="5606"><span class="lineNum">    5606 </span>            :                func_symbol = template_symbol;</a>
<a name="5607"><span class="lineNum">    5607 </span>            :              }</a>
<a name="5608"><span class="lineNum">    5608 </span>            : </a>
<a name="5609"><span class="lineNum">    5609 </span>            :           ROSE_ASSERT(func_symbol != NULL);</a>
<a name="5610"><span class="lineNum">    5610 </span>            :           scope-&gt;insert_symbol(name, func_symbol);</a>
<a name="5611"><span class="lineNum">    5611 </span>            : #if 0</a>
<a name="5612"><span class="lineNum">    5612 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): Setting the defining_func = %p set_firstNondefiningDeclaration(NULL) (to NULL) \n&quot;,defining_func);</a>
<a name="5613"><span class="lineNum">    5613 </span>            :        // printf (&quot;In buildDefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl-&gt;get_definingDeclaration() = %p) (to prevDecl-&gt;get_definingDeclaration()) \n&quot;,func,prevDecl-&gt;get_definingDeclaration());</a>
<a name="5614"><span class="lineNum">    5614 </span>            : #endif</a>
<a name="5615"><span class="lineNum">    5615 </span>            :           defining_func-&gt;set_firstNondefiningDeclaration(NULL);</a>
<a name="5616"><span class="lineNum">    5616 </span>            : </a>
<a name="5617"><span class="lineNum">    5617 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): func_symbol = %p = %s \n&quot;,func_symbol,func_symbol-&gt;class_name().c_str());</a>
<a name="5618"><span class="lineNum">    5618 </span>            : #endif</a>
<a name="5619"><span class="lineNum">    5619 </span>            : #endif</a>
<a name="5620"><span class="lineNum">    5620 </span>            :         }</a>
<a name="5621"><span class="lineNum">    5621 </span>            :        else</a>
<a name="5622"><span class="lineNum">    5622 </span>            :         {</a>
<a name="5623"><span class="lineNum">    5623 </span>            :        // We will now build a reference to the non-defining declaration found in the symbol.</a>
<a name="5624"><span class="lineNum">    5624 </span>            : </a>
<a name="5625"><span class="lineNum">    5625 </span>            :        // defining declaration after nondefining declaration</a>
<a name="5626"><span class="lineNum">    5626 </span>            :        // reuse function type, function symbol</a>
<a name="5627"><span class="lineNum">    5627 </span>            : </a>
<a name="5628"><span class="lineNum">    5628 </span>            :        // delete func_type;// bug 189</a>
<a name="5629"><span class="lineNum">    5629 </span>            : </a>
<a name="5630"><span class="lineNum">    5630 </span>            :        // Cong (10/25/2010): Make sure in this situation there is no defining declaration for this symbol.</a>
<a name="5631"><span class="lineNum">    5631 </span>            :        // ROSE_ASSERT(func_symbol-&gt;get_declaration()-&gt;get_definingDeclaration() == NULL);</a>
<a name="5632"><span class="lineNum">    5632 </span>            : #if 0</a>
<a name="5633"><span class="lineNum">    5633 </span>            :           func_type = func_symbol-&gt;get_declaration()-&gt;get_type();</a>
<a name="5634"><span class="lineNum">    5634 </span>            : #else</a>
<a name="5635"><span class="lineNum">    5635 </span><span class="lineCov">      19243 :           SgFunctionSymbol* temp_function_sym = isSgFunctionSymbol(func_symbol);</span></a>
<a name="5636"><span class="lineNum">    5636 </span><span class="lineCov">      19243 :           SgTemplateSymbol* temp_template_sym = isSgTemplateSymbol(func_symbol);</span></a>
<a name="5637"><span class="lineNum">    5637 </span><span class="lineCov">      19243 :           if (temp_function_sym != NULL)</span></a>
<a name="5638"><span class="lineNum">    5638 </span>            :              {</a>
<a name="5639"><span class="lineNum">    5639 </span><span class="lineCov">      19243 :                func_type = temp_function_sym-&gt;get_declaration()-&gt;get_type();</span></a>
<a name="5640"><span class="lineNum">    5640 </span>            : </a>
<a name="5641"><span class="lineNum">    5641 </span>            :             // firstNondefiningFunctionDeclaration = temp_function_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration();</a>
<a name="5642"><span class="lineNum">    5642 </span>            :             // firstNondefiningFunctionDeclaration = isSgFunctionDeclaration(temp_function_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5643"><span class="lineNum">    5643 </span>            :             // firstNondefiningFunctionDeclaration = dynamic_cast&lt;SgFunctionDeclaration*&gt;(temp_function_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5644"><span class="lineNum">    5644 </span><span class="lineCov">      19243 :                firstNondefiningFunctionDeclaration = temp_function_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="5645"><span class="lineNum">    5645 </span><span class="lineCov">      19243 :                ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</span></a>
<a name="5646"><span class="lineNum">    5646 </span>            :              }</a>
<a name="5647"><span class="lineNum">    5647 </span>            :             else</a>
<a name="5648"><span class="lineNum">    5648 </span>            :              {</a>
<a name="5649"><span class="lineNum">    5649 </span>            :             // There is no type for a template function declaration.</a>
<a name="5650"><span class="lineNum">    5650 </span>            :             // func_type = temp_template_sym-&gt;get_declaration()-&gt;get_type();</a>
<a name="5651"><span class="lineNum">    5651 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(temp_template_sym != NULL);</span></a>
<a name="5652"><span class="lineNum">    5652 </span>            :             // firstNondefiningFunctionDeclaration = temp_template_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration();</a>
<a name="5653"><span class="lineNum">    5653 </span>            :             // firstNondefiningFunctionDeclaration = isSgTemplateFunctionDeclaration(temp_template_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5654"><span class="lineNum">    5654 </span>            :             // firstNondefiningFunctionDeclaration = dynamic_cast&lt;SgTemplateFunctionDeclaration*&gt;(temp_template_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5655"><span class="lineNum">    5655 </span><span class="lineNoCov">          0 :                firstNondefiningFunctionDeclaration = temp_template_sym-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="5656"><span class="lineNum">    5656 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</span></a>
<a name="5657"><span class="lineNum">    5657 </span>            :              }</a>
<a name="5658"><span class="lineNum">    5658 </span>            : #endif</a>
<a name="5659"><span class="lineNum">    5659 </span>            : #if 0</a>
<a name="5660"><span class="lineNum">    5660 </span>            :        // func = new SgFunctionDeclaration(name,func_type,NULL);</a>
<a name="5661"><span class="lineNum">    5661 </span>            :           defining_func = new actualFunction(name,func_type,NULL);</a>
<a name="5662"><span class="lineNum">    5662 </span>            :           ROSE_ASSERT(defining_func);</a>
<a name="5663"><span class="lineNum">    5663 </span>            : </a>
<a name="5664"><span class="lineNum">    5664 </span>            :        // func-&gt;set_firstNondefiningDeclaration(func_symbol-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5665"><span class="lineNum">    5665 </span>            :           ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</a>
<a name="5666"><span class="lineNum">    5666 </span>            :           defining_func-&gt;set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration);</a>
<a name="5667"><span class="lineNum">    5667 </span>            : </a>
<a name="5668"><span class="lineNum">    5668 </span>            :        // fix up defining declarations before current statement</a>
<a name="5669"><span class="lineNum">    5669 </span>            :        // func_symbol-&gt;get_declaration()-&gt;set_definingDeclaration(func);</a>
<a name="5670"><span class="lineNum">    5670 </span>            :           firstNondefiningFunctionDeclaration-&gt;set_definingDeclaration(defining_func);</a>
<a name="5671"><span class="lineNum">    5671 </span>            : </a>
<a name="5672"><span class="lineNum">    5672 </span>            :        // for the rare case that two or more prototype declaration exist</a>
<a name="5673"><span class="lineNum">    5673 </span>            :        // cannot do anything until append/prepend_statment() is invoked</a>
<a name="5674"><span class="lineNum">    5674 </span>            : #else</a>
<a name="5675"><span class="lineNum">    5675 </span><span class="lineCov">      19243 :           ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</span></a>
<a name="5676"><span class="lineNum">    5676 </span>            : #endif</a>
<a name="5677"><span class="lineNum">    5677 </span>            :         }</a>
<a name="5678"><span class="lineNum">    5678 </span>            : </a>
<a name="5679"><span class="lineNum">    5679 </span>            :   // defining_func = new actualFunction(name,func_type,NULL);</a>
<a name="5680"><span class="lineNum">    5680 </span><span class="lineCov">      19243 :      defining_func = new actualFunction(nameWithTemplateArguments,func_type,NULL);</span></a>
<a name="5681"><span class="lineNum">    5681 </span>            : </a>
<a name="5682"><span class="lineNum">    5682 </span><span class="lineCov">      19243 :      ROSE_ASSERT(defining_func != NULL);</span></a>
<a name="5683"><span class="lineNum">    5683 </span>            : </a>
<a name="5684"><span class="lineNum">    5684 </span>            : #if 0</a>
<a name="5685"><span class="lineNum">    5685 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): constructor called to build func = %p = %s \n&quot;,defining_func,defining_func-&gt;class_name().c_str());</a>
<a name="5686"><span class="lineNum">    5686 </span>            :      if (isSgMemberFunctionDeclaration(defining_func) != NULL)</a>
<a name="5687"><span class="lineNum">    5687 </span>            :         {</a>
<a name="5688"><span class="lineNum">    5688 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration_T(): SgCtorInitializerList = %p \n&quot;,isSgMemberFunctionDeclaration(defining_func)-&gt;get_CtorInitializerList());</a>
<a name="5689"><span class="lineNum">    5689 </span>            :         }</a>
<a name="5690"><span class="lineNum">    5690 </span>            : #endif</a>
<a name="5691"><span class="lineNum">    5691 </span>            : </a>
<a name="5692"><span class="lineNum">    5692 </span>            : #if 0</a>
<a name="5693"><span class="lineNum">    5693 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): Setting the defining_func = %p set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration = %p) (to valid pointer) \n&quot;,defining_func,firstNondefiningFunctionDeclaration);</a>
<a name="5694"><span class="lineNum">    5694 </span>            :   // printf (&quot;In buildDefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl-&gt;get_definingDeclaration() = %p) (to prevDecl-&gt;get_definingDeclaration()) \n&quot;,func,prevDecl-&gt;get_definingDeclaration());</a>
<a name="5695"><span class="lineNum">    5695 </span>            : #endif</a>
<a name="5696"><span class="lineNum">    5696 </span>            : </a>
<a name="5697"><span class="lineNum">    5697 </span>            :   // func-&gt;set_firstNondefiningDeclaration(func_symbol-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration());</a>
<a name="5698"><span class="lineNum">    5698 </span><span class="lineCov">      19243 :      ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);</span></a>
<a name="5699"><span class="lineNum">    5699 </span><span class="lineCov">      19243 :      defining_func-&gt;set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration);</span></a>
<a name="5700"><span class="lineNum">    5700 </span>            : </a>
<a name="5701"><span class="lineNum">    5701 </span>            :   // fix up defining declarations before current statement</a>
<a name="5702"><span class="lineNum">    5702 </span><span class="lineCov">      19243 :      firstNondefiningFunctionDeclaration-&gt;set_definingDeclaration(defining_func);</span></a>
<a name="5703"><span class="lineNum">    5703 </span>            : </a>
<a name="5704"><span class="lineNum">    5704 </span>            :   // Handle decorators (Python specific)</a>
<a name="5705"><span class="lineNum">    5705 </span><span class="lineCov">      19243 :      if (decoratorList != NULL)</span></a>
<a name="5706"><span class="lineNum">    5706 </span>            :         {</a>
<a name="5707"><span class="lineNum">    5707 </span><span class="lineNoCov">          0 :           defining_func-&gt;set_decoratorList(decoratorList);</span></a>
<a name="5708"><span class="lineNum">    5708 </span><span class="lineNoCov">          0 :           decoratorList-&gt;set_parent(defining_func);</span></a>
<a name="5709"><span class="lineNum">    5709 </span>            :         }</a>
<a name="5710"><span class="lineNum">    5710 </span>            : </a>
<a name="5711"><span class="lineNum">    5711 </span>            :   // definingDeclaration</a>
<a name="5712"><span class="lineNum">    5712 </span><span class="lineCov">      19243 :      defining_func-&gt;set_definingDeclaration(defining_func);</span></a>
<a name="5713"><span class="lineNum">    5713 </span>            : </a>
<a name="5714"><span class="lineNum">    5714 </span>            :   // function body and definition are created before setting argument list</a>
<a name="5715"><span class="lineNum">    5715 </span><span class="lineCov">      19243 :      SgBasicBlock * func_body = new SgBasicBlock();</span></a>
<a name="5716"><span class="lineNum">    5716 </span><span class="lineCov">      19243 :      ROSE_ASSERT(func_body != NULL);</span></a>
<a name="5717"><span class="lineNum">    5717 </span>            : </a>
<a name="5718"><span class="lineNum">    5718 </span>            : #if 0</a>
<a name="5719"><span class="lineNum">    5719 </span>            :      SgFunctionDefinition* func_def = new SgFunctionDefinition(defining_func,func_body);</a>
<a name="5720"><span class="lineNum">    5720 </span>            : #else</a>
<a name="5721"><span class="lineNum">    5721 </span><span class="lineCov">      19243 :      SgFunctionDefinition*          func_def                    = NULL;</span></a>
<a name="5722"><span class="lineNum">    5722 </span><span class="lineCov">      19243 :      SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(defining_func);</span></a>
<a name="5723"><span class="lineNum">    5723 </span>            : </a>
<a name="5724"><span class="lineNum">    5724 </span>            :   // Build either a definition for a template or non-template function definition.</a>
<a name="5725"><span class="lineNum">    5725 </span>            :   // DQ (2/11/2012): Swapped the order to test templateFunctionDeclaration, since functionDeclaration is always a valid pointer.</a>
<a name="5726"><span class="lineNum">    5726 </span>            :   // if (functionDeclaration != NULL)</a>
<a name="5727"><span class="lineNum">    5727 </span><span class="lineCov">      19243 :      if (templateFunctionDeclaration == NULL)</span></a>
<a name="5728"><span class="lineNum">    5728 </span>            :         {</a>
<a name="5729"><span class="lineNum">    5729 </span>            :        // DQ (2/11/2012): If we can't assert this then I fear we may have the test in the wrong</a>
<a name="5730"><span class="lineNum">    5730 </span>            :        // order (for if test above should be on templateFunctionDeclaration instead).  The new</a>
<a name="5731"><span class="lineNum">    5731 </span>            :        // design for templates makes the SgFunctionDeclaration a base class of SgTemplateFunctionDeclaration.</a>
<a name="5732"><span class="lineNum">    5732 </span>            :        // Might not make a difference if it is OK to use SgFunctionDefinition interchangibly with</a>
<a name="5733"><span class="lineNum">    5733 </span>            :        // SgTemplateFunctionDefinition, but we would never want that.</a>
<a name="5734"><span class="lineNum">    5734 </span><span class="lineCov">      16044 :           ROSE_ASSERT(templateFunctionDeclaration == NULL);</span></a>
<a name="5735"><span class="lineNum">    5735 </span>            : </a>
<a name="5736"><span class="lineNum">    5736 </span><span class="lineCov">      16044 :           SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(defining_func);</span></a>
<a name="5737"><span class="lineNum">    5737 </span><span class="lineCov">      16044 :           ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="5738"><span class="lineNum">    5738 </span><span class="lineCov">      16044 :           func_def = new SgFunctionDefinition(functionDeclaration,func_body);</span></a>
<a name="5739"><span class="lineNum">    5739 </span>            :         }</a>
<a name="5740"><span class="lineNum">    5740 </span>            :        else</a>
<a name="5741"><span class="lineNum">    5741 </span>            :         {</a>
<a name="5742"><span class="lineNum">    5742 </span><span class="lineCov">       3199 :           ROSE_ASSERT(templateFunctionDeclaration != NULL);</span></a>
<a name="5743"><span class="lineNum">    5743 </span><span class="lineCov">       3199 :           func_def = new SgTemplateFunctionDefinition(templateFunctionDeclaration,func_body);</span></a>
<a name="5744"><span class="lineNum">    5744 </span>            :         }</a>
<a name="5745"><span class="lineNum">    5745 </span>            : #endif</a>
<a name="5746"><span class="lineNum">    5746 </span><span class="lineCov">      19243 :      ROSE_ASSERT(func_def);</span></a>
<a name="5747"><span class="lineNum">    5747 </span>            : </a>
<a name="5748"><span class="lineNum">    5748 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="5749"><span class="lineNum">    5749 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="5750"><span class="lineNum">    5750 </span><span class="lineCov">      19243 :    if (SageInterface::is_language_case_insensitive())</span></a>
<a name="5751"><span class="lineNum">    5751 </span>            :         {</a>
<a name="5752"><span class="lineNum">    5752 </span><span class="lineCov">          5 :           func_def-&gt;setCaseInsensitive(true);</span></a>
<a name="5753"><span class="lineNum">    5753 </span><span class="lineCov">          5 :           func_body-&gt;setCaseInsensitive(true);</span></a>
<a name="5754"><span class="lineNum">    5754 </span>            :         }</a>
<a name="5755"><span class="lineNum">    5755 </span>            : </a>
<a name="5756"><span class="lineNum">    5756 </span><span class="lineCov">      19243 :      func_def-&gt;set_parent(defining_func);</span></a>
<a name="5757"><span class="lineNum">    5757 </span><span class="lineCov">      19243 :      func_def-&gt;set_body(func_body);</span></a>
<a name="5758"><span class="lineNum">    5758 </span><span class="lineCov">      19243 :      func_body-&gt;set_parent(func_def);</span></a>
<a name="5759"><span class="lineNum">    5759 </span>            : </a>
<a name="5760"><span class="lineNum">    5760 </span>            :   // parameter list,</a>
<a name="5761"><span class="lineNum">    5761 </span>            :   // TODO consider the difference between C++ and Fortran</a>
<a name="5762"><span class="lineNum">    5762 </span><span class="lineCov">      19243 :      setParameterList(defining_func,paralist);</span></a>
<a name="5763"><span class="lineNum">    5763 </span>            :   // fixup the scope and symbol of arguments,</a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineCov">      19243 :      SgInitializedNamePtrList&amp; argList = paralist-&gt;get_args();</span></a>
<a name="5765"><span class="lineNum">    5765 </span><span class="lineCov">      19243 :      Rose_STL_Container&lt;SgInitializedName*&gt;::iterator argi;</span></a>
<a name="5766"><span class="lineNum">    5766 </span><span class="lineCov">      47782 :      for (argi = argList.begin(); argi!=argList.end(); argi++)</span></a>
<a name="5767"><span class="lineNum">    5767 </span>            :         {</a>
<a name="5768"><span class="lineNum">    5768 </span>            :         // std::cout&lt;&lt;&quot;patching defining function argument's scope and symbol.... &quot;&lt;&lt;std::endl;</a>
<a name="5769"><span class="lineNum">    5769 </span><span class="lineCov">      28539 :           (*argi)-&gt;set_scope(func_def);</span></a>
<a name="5770"><span class="lineNum">    5770 </span>            : </a>
<a name="5771"><span class="lineNum">    5771 </span>            :        // func_def-&gt;insert_symbol((*argi)-&gt;get_name(), new SgVariableSymbol(*argi) );</a>
<a name="5772"><span class="lineNum">    5772 </span><span class="lineCov">      28539 :           SgVariableSymbol* variableSymbol = new SgVariableSymbol(*argi);</span></a>
<a name="5773"><span class="lineNum">    5773 </span><span class="lineCov">      28539 :           ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="5774"><span class="lineNum">    5774 </span><span class="lineCov">      28539 :           func_def-&gt;insert_symbol((*argi)-&gt;get_name(), variableSymbol );</span></a>
<a name="5775"><span class="lineNum">    5775 </span>            : </a>
<a name="5776"><span class="lineNum">    5776 </span>            :        // DQ (2/13/2016): Adding support for variable length array types in the function parameter list.</a>
<a name="5777"><span class="lineNum">    5777 </span><span class="lineCov">      28539 :           SgArrayType* arrayType = isSgArrayType((*argi)-&gt;get_type());</span></a>
<a name="5778"><span class="lineNum">    5778 </span><span class="lineCov">      28539 :           if (arrayType != NULL)</span></a>
<a name="5779"><span class="lineNum">    5779 </span>            :              {</a>
<a name="5780"><span class="lineNum">    5780 </span>            :             // Check if this is a VLA array type, if so look for the index expressions and check</a>
<a name="5781"><span class="lineNum">    5781 </span>            :             // if we need to add asociated symbols to the current function definition scope.</a>
<a name="5782"><span class="lineNum">    5782 </span><span class="lineCov">         60 :                SgExpression* indexExpression = arrayType-&gt;get_index();</span></a>
<a name="5783"><span class="lineNum">    5783 </span>            : </a>
<a name="5784"><span class="lineNum">    5784 </span>            :             // DQ (2/15/2016): This fails for X10 support.</a>
<a name="5785"><span class="lineNum">    5785 </span>            :             // ROSE_ASSERT(indexExpression != NULL);</a>
<a name="5786"><span class="lineNum">    5786 </span><span class="lineCov">         60 :                if (indexExpression != NULL)</span></a>
<a name="5787"><span class="lineNum">    5787 </span>            :                   {</a>
<a name="5788"><span class="lineNum">    5788 </span>            :                  // DQ (2/14/2016): Handle the case of an expression tree with any number of variable references.</a>
<a name="5789"><span class="lineNum">    5789 </span>            :                  // Get the list of SgVarRef IR nodes and process each one as above.</a>
<a name="5790"><span class="lineNum">    5790 </span>            :                  // void collectVarRefs(SgLocatedNode* root, std::vector&lt;SgVarRefExp* &gt;&amp; result);</a>
<a name="5791"><span class="lineNum">    5791 </span><span class="lineCov">         60 :                     vector&lt;SgVarRefExp* &gt; varRefList;</span></a>
<a name="5792"><span class="lineNum">    5792 </span><span class="lineCov">         60 :                     collectVarRefs(indexExpression,varRefList);</span></a>
<a name="5793"><span class="lineNum">    5793 </span>            : #if 0</a>
<a name="5794"><span class="lineNum">    5794 </span>            :                     printf (&quot;For array variable: name = %s \n&quot;,(*argi)-&gt;get_name().str());</a>
<a name="5795"><span class="lineNum">    5795 </span>            :                     printf (&quot;varRefList.size() = %zu \n&quot;,varRefList.size());</a>
<a name="5796"><span class="lineNum">    5796 </span>            : #endif</a>
<a name="5797"><span class="lineNum">    5797 </span><span class="lineCov">         63 :                     for (size_t i = 0; i &lt; varRefList.size(); i++)</span></a>
<a name="5798"><span class="lineNum">    5798 </span>            :                        {</a>
<a name="5799"><span class="lineNum">    5799 </span>            :                       // Process each index subtree's SgVarRefExp.</a>
<a name="5800"><span class="lineNum">    5800 </span>            : #if 0</a>
<a name="5801"><span class="lineNum">    5801 </span>            :                          printf (&quot;   --- index expression SgVarRefExp: name = %s \n&quot;,varRefList[i]-&gt;get_symbol()-&gt;get_name().str());</a>
<a name="5802"><span class="lineNum">    5802 </span>            : #endif</a>
<a name="5803"><span class="lineNum">    5803 </span><span class="lineCov">          3 :                          SgVariableSymbol* dimension_variableSymbol = varRefList[i]-&gt;get_symbol();</span></a>
<a name="5804"><span class="lineNum">    5804 </span><span class="lineCov">          3 :                          ROSE_ASSERT(dimension_variableSymbol != NULL);</span></a>
<a name="5805"><span class="lineNum">    5805 </span>            : #if 0</a>
<a name="5806"><span class="lineNum">    5806 </span>            :                          printf (&quot;dimension_variableSymbol = %p \n&quot;,dimension_variableSymbol);</a>
<a name="5807"><span class="lineNum">    5807 </span>            : #endif</a>
<a name="5808"><span class="lineNum">    5808 </span><span class="lineCov">          3 :                          ROSE_ASSERT(dimension_variableSymbol != variableSymbol);</span></a>
<a name="5809"><span class="lineNum">    5809 </span>            : </a>
<a name="5810"><span class="lineNum">    5810 </span>            :                       // The symbol from the referenced variable for the array dimension expression shuld already by in the function definition's symbol table.</a>
<a name="5811"><span class="lineNum">    5811 </span><span class="lineCov">          3 :                          SgSymbol* symbolFromLookup = func_def-&gt;lookup_symbol(dimension_variableSymbol-&gt;get_name());</span></a>
<a name="5812"><span class="lineNum">    5812 </span><span class="lineCov">          3 :                          if (symbolFromLookup != NULL)</span></a>
<a name="5813"><span class="lineNum">    5813 </span>            :                             {</a>
<a name="5814"><span class="lineNum">    5814 </span><span class="lineCov">          3 :                               SgVariableSymbol* variableSymbolFromLookup = isSgVariableSymbol(symbolFromLookup);</span></a>
<a name="5815"><span class="lineNum">    5815 </span><span class="lineCov">          3 :                               ROSE_ASSERT(variableSymbolFromLookup != NULL);</span></a>
<a name="5816"><span class="lineNum">    5816 </span>            : </a>
<a name="5817"><span class="lineNum">    5817 </span>            :                            // varRefExp-&gt;set_symbol(symbolFromLookup);</a>
<a name="5818"><span class="lineNum">    5818 </span><span class="lineCov">          3 :                               varRefList[i]-&gt;set_symbol(variableSymbolFromLookup);</span></a>
<a name="5819"><span class="lineNum">    5819 </span>            : #if 0</a>
<a name="5820"><span class="lineNum">    5820 </span>            :                               printf (&quot;Ignoring previously built dimension_variableSymbol: dimension_variableSymbol-&gt;get_name() = %s \n&quot;,dimension_variableSymbol-&gt;get_name().str());</a>
<a name="5821"><span class="lineNum">    5821 </span>            : #endif</a>
<a name="5822"><span class="lineNum">    5822 </span>            :                            // I think we have a problem if this is not true.</a>
<a name="5823"><span class="lineNum">    5823 </span><span class="lineCov">          3 :                               ROSE_ASSERT(dimension_variableSymbol != variableSymbol);</span></a>
<a name="5824"><span class="lineNum">    5824 </span>            :                             }</a>
<a name="5825"><span class="lineNum">    5825 </span>            :                            else</a>
<a name="5826"><span class="lineNum">    5826 </span>            :                             {</a>
<a name="5827"><span class="lineNum">    5827 </span>            :                            // This is not a reference to a variable from the current function's paramter lists, so we can ignore processing it within the VLA handling.</a>
<a name="5828"><span class="lineNum">    5828 </span>            :                             }</a>
<a name="5829"><span class="lineNum">    5829 </span>            : #if 0</a>
<a name="5830"><span class="lineNum">    5830 </span>            :                          printf (&quot;Detected an array type in the function parameter list with nontrivial index expression tree \n&quot;);</a>
<a name="5831"><span class="lineNum">    5831 </span>            :                          ROSE_ABORT();</a>
<a name="5832"><span class="lineNum">    5832 </span>            : #endif</a>
<a name="5833"><span class="lineNum">    5833 </span>            :                        }</a>
<a name="5834"><span class="lineNum">    5834 </span>            :                   }</a>
<a name="5835"><span class="lineNum">    5835 </span>            :                  else</a>
<a name="5836"><span class="lineNum">    5836 </span>            :                   {</a>
<a name="5837"><span class="lineNum">    5837 </span>            :                  // In X10 the array index can be more general (fixed to avoid failing X10 tests).</a>
<a name="5838"><span class="lineNum">    5838 </span>            :                   }</a>
<a name="5839"><span class="lineNum">    5839 </span>            : #if 0</a>
<a name="5840"><span class="lineNum">    5840 </span>            :                printf (&quot;Detected an array type in the function parameter list \n&quot;);</a>
<a name="5841"><span class="lineNum">    5841 </span>            :                ROSE_ABORT();</a>
<a name="5842"><span class="lineNum">    5842 </span>            : #endif</a>
<a name="5843"><span class="lineNum">    5843 </span>            :              }</a>
<a name="5844"><span class="lineNum">    5844 </span>            :         }</a>
<a name="5845"><span class="lineNum">    5845 </span>            : </a>
<a name="5846"><span class="lineNum">    5846 </span><span class="lineCov">      19243 :      defining_func-&gt;set_parent(scope);</span></a>
<a name="5847"><span class="lineNum">    5847 </span><span class="lineCov">      19243 :      defining_func-&gt;set_scope(scope);</span></a>
<a name="5848"><span class="lineNum">    5848 </span>            : </a>
<a name="5849"><span class="lineNum">    5849 </span>            :   // DQ (12/14/2011): Added test.</a>
<a name="5850"><span class="lineNum">    5850 </span><span class="lineCov">      19243 :      ROSE_ASSERT(defining_func-&gt;get_scope() != NULL);</span></a>
<a name="5851"><span class="lineNum">    5851 </span>            : </a>
<a name="5852"><span class="lineNum">    5852 </span>            :   // DQ (12/15/2011): Added test.</a>
<a name="5853"><span class="lineNum">    5853 </span><span class="lineCov">      19243 :      checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(defining_func,scope);</span></a>
<a name="5854"><span class="lineNum">    5854 </span>            : </a>
<a name="5855"><span class="lineNum">    5855 </span>            :   // set File_Info as transformation generated</a>
<a name="5856"><span class="lineNum">    5856 </span><span class="lineCov">      19243 :      setSourcePositionAtRootAndAllChildren(defining_func);</span></a>
<a name="5857"><span class="lineNum">    5857 </span>            : </a>
<a name="5858"><span class="lineNum">    5858 </span>            :   // DQ (2/11/2012): Enforce that the return type matches the specification to build a member function.</a>
<a name="5859"><span class="lineNum">    5859 </span><span class="lineCov">      19243 :      if (isMemberFunction == true)</span></a>
<a name="5860"><span class="lineNum">    5860 </span>            :         {</a>
<a name="5861"><span class="lineNum">    5861 </span><span class="lineCov">      12220 :           ROSE_ASSERT(isSgMemberFunctionDeclaration(defining_func) != NULL);</span></a>
<a name="5862"><span class="lineNum">    5862 </span>            :         }</a>
<a name="5863"><span class="lineNum">    5863 </span>            : </a>
<a name="5864"><span class="lineNum">    5864 </span>            :   // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).</a>
<a name="5865"><span class="lineNum">    5865 </span>            :   // setTemplateNameInTemplateInstantiations(defining_func,name);</a>
<a name="5866"><span class="lineNum">    5866 </span><span class="lineCov">      19243 :      setTemplateNameInTemplateInstantiations(defining_func,nameWithoutTemplateArguments);</span></a>
<a name="5867"><span class="lineNum">    5867 </span>            : </a>
<a name="5868"><span class="lineNum">    5868 </span>            :   // DQ (9/16/2012): Setup up the template arguments and the parents of the template arguments.</a>
<a name="5869"><span class="lineNum">    5869 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="5870"><span class="lineNum">    5870 </span>            :         {</a>
<a name="5871"><span class="lineNum">    5871 </span><span class="lineCov">       2249 :           setTemplateArgumentsInDeclaration(defining_func,templateArgumentsList);</span></a>
<a name="5872"><span class="lineNum">    5872 </span>            :         }</a>
<a name="5873"><span class="lineNum">    5873 </span>            : </a>
<a name="5874"><span class="lineNum">    5874 </span>            :   // DQ (8/13/2013): Added code to set the template parameters in the defining declaration (if it is a template declaration).</a>
<a name="5875"><span class="lineNum">    5875 </span>            :      if (buildTemplateDeclaration == true)</a>
<a name="5876"><span class="lineNum">    5876 </span>            :         {</a>
<a name="5877"><span class="lineNum">    5877 </span><span class="lineCov">      11076 :           setTemplateParametersInDeclaration(defining_func,templateParameterList);</span></a>
<a name="5878"><span class="lineNum">    5878 </span>            : </a>
<a name="5879"><span class="lineNum">    5879 </span>            :        // DQ (8/13/2013): Adding test of template parameter lists.</a>
<a name="5880"><span class="lineNum">    5880 </span><span class="lineCov">      11076 :           SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(defining_func);</span></a>
<a name="5881"><span class="lineNum">    5881 </span><span class="lineCov">      11076 :           ROSE_ASSERT(templateFunctionDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateFunctionDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="5882"><span class="lineNum">    5882 </span><span class="lineCov">      11076 :           SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(defining_func);</span></a>
<a name="5883"><span class="lineNum">    5883 </span><span class="lineCov">      11076 :           ROSE_ASSERT(templateMemberFunctionDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateMemberFunctionDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="5884"><span class="lineNum">    5884 </span>            :         }</a>
<a name="5885"><span class="lineNum">    5885 </span>            : </a>
<a name="5886"><span class="lineNum">    5886 </span>            :   // DQ (12/12/2012): Force the two different ways that this can be set to match (we want consistancy).</a>
<a name="5887"><span class="lineNum">    5887 </span><span class="lineCov">      19243 :      if (functionConstVolatileFlags &amp; SgMemberFunctionType::e_restrict)</span></a>
<a name="5888"><span class="lineNum">    5888 </span>            :         {</a>
<a name="5889"><span class="lineNum">    5889 </span><span class="lineNoCov">          0 :           defining_func-&gt;get_declarationModifier().get_typeModifier().setRestrict();</span></a>
<a name="5890"><span class="lineNum">    5890 </span>            :         }</a>
<a name="5891"><span class="lineNum">    5891 </span>            : </a>
<a name="5892"><span class="lineNum">    5892 </span>            : #if 0</a>
<a name="5893"><span class="lineNum">    5893 </span>            :      printf (&quot;In buildDefiningFunctionDeclaration_T(): XXX_name = %s (calling unsetNodesMarkedAsModified()) \n&quot;, XXX_name.str());</a>
<a name="5894"><span class="lineNum">    5894 </span>            : #endif</a>
<a name="5895"><span class="lineNum">    5895 </span>            : </a>
<a name="5896"><span class="lineNum">    5896 </span>            :   // DQ (4/16/2015): This is replaced with a better implementation.</a>
<a name="5897"><span class="lineNum">    5897 </span>            :   // DQ (4/15/2015): We should reset the isModified flags as part of the transforamtion</a>
<a name="5898"><span class="lineNum">    5898 </span>            :   // because we have added statements explicitly marked as transformations.</a>
<a name="5899"><span class="lineNum">    5899 </span>            :   // checkIsModifiedFlag(defining_func);</a>
<a name="5900"><span class="lineNum">    5900 </span><span class="lineCov">      19243 :      unsetNodesMarkedAsModified(defining_func);</span></a>
<a name="5901"><span class="lineNum">    5901 </span>            : </a>
<a name="5902"><span class="lineNum">    5902 </span>            : #if 0</a>
<a name="5903"><span class="lineNum">    5903 </span>            :   // DQ (4/2/2018): Debugging case of two symbols for the same function in the same namespace (but different namespace definitions).</a>
<a name="5904"><span class="lineNum">    5904 </span>            :      if (nameWithoutTemplateArguments == &quot;getline&quot;)</a>
<a name="5905"><span class="lineNum">    5905 </span>            :         {</a>
<a name="5906"><span class="lineNum">    5906 </span>            :           printf (&quot;### Leaving buildDefiningFunctionDeclaration_T(): getline: func: defining_func = %p = %s unparseNameToString() = %s \n&quot;,</a>
<a name="5907"><span class="lineNum">    5907 </span>            :                defining_func,defining_func-&gt;class_name().c_str(),defining_func-&gt;unparseNameToString().c_str());</a>
<a name="5908"><span class="lineNum">    5908 </span>            :           printf (&quot;   --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="5909"><span class="lineNum">    5909 </span>            :           SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);</a>
<a name="5910"><span class="lineNum">    5910 </span>            :           if (namespaceDefinition != NULL)</a>
<a name="5911"><span class="lineNum">    5911 </span>            :              {</a>
<a name="5912"><span class="lineNum">    5912 </span>            :                printf (&quot;   --- namespaceDefinition: name = %s \n&quot;,namespaceDefinition-&gt;get_namespaceDeclaration()-&gt;get_name().str());</a>
<a name="5913"><span class="lineNum">    5913 </span>            :                printf (&quot;   --- global namespace          = %p \n&quot;,namespaceDefinition-&gt;get_global_definition());</a>
<a name="5914"><span class="lineNum">    5914 </span>            :              }</a>
<a name="5915"><span class="lineNum">    5915 </span>            :             else</a>
<a name="5916"><span class="lineNum">    5916 </span>            :              {</a>
<a name="5917"><span class="lineNum">    5917 </span>            :                SgTemplateInstantiationDefn* templateInstantiationDefn = isSgTemplateInstantiationDefn(scope);</a>
<a name="5918"><span class="lineNum">    5918 </span>            :                if (templateInstantiationDefn != NULL)</a>
<a name="5919"><span class="lineNum">    5919 </span>            :                   {</a>
<a name="5920"><span class="lineNum">    5920 </span>            :                     SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(templateInstantiationDefn-&gt;get_declaration());</a>
<a name="5921"><span class="lineNum">    5921 </span>            :                     printf (&quot;   --- templateInstantiationDecl: name = %s \n&quot;,templateInstantiationDecl-&gt;get_name().str());</a>
<a name="5922"><span class="lineNum">    5922 </span>            :                   }</a>
<a name="5923"><span class="lineNum">    5923 </span>            :                  else</a>
<a name="5924"><span class="lineNum">    5924 </span>            :                   {</a>
<a name="5925"><span class="lineNum">    5925 </span>            :                     SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(scope);</a>
<a name="5926"><span class="lineNum">    5926 </span>            :                     if (templateClassDefinition != NULL)</a>
<a name="5927"><span class="lineNum">    5927 </span>            :                        {</a>
<a name="5928"><span class="lineNum">    5928 </span>            :                          SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(templateClassDefinition-&gt;get_declaration());</a>
<a name="5929"><span class="lineNum">    5929 </span>            :                          printf (&quot;   --- templateClassDeclaration: name = %s \n&quot;,templateClassDeclaration-&gt;get_name().str());</a>
<a name="5930"><span class="lineNum">    5930 </span>            : </a>
<a name="5931"><span class="lineNum">    5931 </span>            :                       // See where this is (because it happens twice in the same class).</a>
<a name="5932"><span class="lineNum">    5932 </span>            :                          templateClassDeclaration-&gt;get_file_info()-&gt;display(&quot;getline found in SgTemplateClassDeclaration: debug&quot;);</a>
<a name="5933"><span class="lineNum">    5933 </span>            : #if 0</a>
<a name="5934"><span class="lineNum">    5934 </span>            :                          printf (&quot;Output the symbol tabel used for this template declaration/definition: \n&quot;);</a>
<a name="5935"><span class="lineNum">    5935 </span>            :                          templateClassDefinition-&gt;get_symbol_table()-&gt;print(&quot;getline found in SgTemplateClassDeclaration&quot;);</a>
<a name="5936"><span class="lineNum">    5936 </span>            : #endif</a>
<a name="5937"><span class="lineNum">    5937 </span>            :                        }</a>
<a name="5938"><span class="lineNum">    5938 </span>            :                   }</a>
<a name="5939"><span class="lineNum">    5939 </span>            :              }</a>
<a name="5940"><span class="lineNum">    5940 </span>            :           printf (&quot;   --- func_symbol = %p = %s \n&quot;,func_symbol,func_symbol-&gt;class_name().c_str());</a>
<a name="5941"><span class="lineNum">    5941 </span>            :         }</a>
<a name="5942"><span class="lineNum">    5942 </span>            : #endif</a>
<a name="5943"><span class="lineNum">    5943 </span>            : </a>
<a name="5944"><span class="lineNum">    5944 </span><span class="lineCov">      19243 :      return defining_func;</span></a>
<a name="5945"><span class="lineNum">    5945 </span>            :    }</a>
<a name="5946"><span class="lineNum">    5946 </span>            : </a>
<a name="5947"><span class="lineNum">    5947 </span>            : </a>
<a name="5948"><span class="lineNum">    5948 </span>            : void</a>
<a name="5949"><span class="lineNum">    5949 </span><span class="lineCov">    1180450 : SageBuilder::setTemplateNameInTemplateInstantiations( SgFunctionDeclaration* func, const SgName &amp; name )</span></a>
<a name="5950"><span class="lineNum">    5950 </span>            :    {</a>
<a name="5951"><span class="lineNum">    5951 </span>            :   // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).</a>
<a name="5952"><span class="lineNum">    5952 </span>            : </a>
<a name="5953"><span class="lineNum">    5953 </span>            : #if 0</a>
<a name="5954"><span class="lineNum">    5954 </span>            :      printf (&quot;In setTemplateNameInTemplateInstantiations(): name = %s func-&gt;get_name() = %s \n&quot;,name.str(),func-&gt;get_name().str());</a>
<a name="5955"><span class="lineNum">    5955 </span>            : #endif</a>
<a name="5956"><span class="lineNum">    5956 </span>            : </a>
<a name="5957"><span class="lineNum">    5957 </span><span class="lineCov">    1180450 :      SgTemplateInstantiationFunctionDecl*       templateInstantiationFunctionDecl       = isSgTemplateInstantiationFunctionDecl(func);</span></a>
<a name="5958"><span class="lineNum">    5958 </span><span class="lineCov">    1180450 :      SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(func);</span></a>
<a name="5959"><span class="lineNum">    5959 </span><span class="lineCov">    1180450 :      bool isTemplateInstantition = (templateInstantiationFunctionDecl != NULL) || (templateInstantiationMemberFunctionDecl != NULL);</span></a>
<a name="5960"><span class="lineNum">    5960 </span><span class="lineCov">    1180450 :      if (isTemplateInstantition == true)</span></a>
<a name="5961"><span class="lineNum">    5961 </span>            :         {</a>
<a name="5962"><span class="lineNum">    5962 </span>            :        // If this is a template instantiation then we need to take care of a few more issues.</a>
<a name="5963"><span class="lineNum">    5963 </span>            : </a>
<a name="5964"><span class="lineNum">    5964 </span><span class="lineCov">      33318 :           SgName templateNameWithoutArguments = name;</span></a>
<a name="5965"><span class="lineNum">    5965 </span>            : </a>
<a name="5966"><span class="lineNum">    5966 </span>            : #if 1</a>
<a name="5967"><span class="lineNum">    5967 </span>            :        // DQ (7/27/2012): New semantics is that we want to have the input name be without template arguments and</a>
<a name="5968"><span class="lineNum">    5968 </span>            :        // we will add the template arguments instead of trying to remove then (which was problematic for examples</a>
<a name="5969"><span class="lineNum">    5969 </span>            :        // such as &quot;X&lt;Y&lt;Z&gt;&gt; operator X&amp;()&quot; and &quot;X&lt;Y&lt;Z&gt;&gt; operator&gt;()&quot;.</a>
<a name="5970"><span class="lineNum">    5970 </span>            : #if 0</a>
<a name="5971"><span class="lineNum">    5971 </span>            :           if (hasTemplateSyntax(templateNameWithoutArguments) == true)</a>
<a name="5972"><span class="lineNum">    5972 </span>            :              {</a>
<a name="5973"><span class="lineNum">    5973 </span>            :                printf (&quot;WARNING: new semantics is that the input name has no template syntax. templateNameWithoutArguments = %s \n&quot;,templateNameWithoutArguments.str());</a>
<a name="5974"><span class="lineNum">    5974 </span>            :             // ROSE_ABORT();</a>
<a name="5975"><span class="lineNum">    5975 </span>            :              }</a>
<a name="5976"><span class="lineNum">    5976 </span>            : #endif</a>
<a name="5977"><span class="lineNum">    5977 </span>            : #else</a>
<a name="5978"><span class="lineNum">    5978 </span>            :           XXX SageBuilder::appendTemplateArgumentsToName( const SgName &amp; name, const SgTemplateArgumentPtrList &amp; templateArgumentsList)</a>
<a name="5979"><span class="lineNum">    5979 </span>            : </a>
<a name="5980"><span class="lineNum">    5980 </span>            :        // if (templateNameWithoutArguments.getString().find('&lt;') != string::npos)</a>
<a name="5981"><span class="lineNum">    5981 </span>            :           if (hasTemplateSyntax(templateNameWithoutArguments) == true)</a>
<a name="5982"><span class="lineNum">    5982 </span>            :              {</a>
<a name="5983"><span class="lineNum">    5983 </span>            :                templateNameWithoutArguments = generateTemplateNameFromTemplateNameWithTemplateArguments(name);</a>
<a name="5984"><span class="lineNum">    5984 </span>            :              }</a>
<a name="5985"><span class="lineNum">    5985 </span>            :             else</a>
<a name="5986"><span class="lineNum">    5986 </span>            :              {</a>
<a name="5987"><span class="lineNum">    5987 </span>            :                printf (&quot;WARNING: In setTemplateNameInTemplateInstantiations(): name = %s (does not have any template argument syntax) \n&quot;,name.str());</a>
<a name="5988"><span class="lineNum">    5988 </span>            : </a>
<a name="5989"><span class="lineNum">    5989 </span>            :             // DQ (7/22/2012): Test exiting where we don't detect template syntax.</a>
<a name="5990"><span class="lineNum">    5990 </span>            :                printf (&quot;Exiting as a test \n&quot;);</a>
<a name="5991"><span class="lineNum">    5991 </span>            :                ROSE_ABORT();</a>
<a name="5992"><span class="lineNum">    5992 </span>            :              }</a>
<a name="5993"><span class="lineNum">    5993 </span>            : #endif</a>
<a name="5994"><span class="lineNum">    5994 </span>            : #if 0</a>
<a name="5995"><span class="lineNum">    5995 </span>            :           printf (&quot;In setTemplateNameInTemplateInstantiations(): detected construction of template instantiation func-&gt;get_name() = %s \n&quot;,func-&gt;get_name().str());</a>
<a name="5996"><span class="lineNum">    5996 </span>            :           printf (&quot;In setTemplateNameInTemplateInstantiations(): templateNameWithoutArguments            = %s \n&quot;,templateNameWithoutArguments.str());</a>
<a name="5997"><span class="lineNum">    5997 </span>            :           printf (&quot;In setTemplateNameInTemplateInstantiations(): templateInstantiationFunctionDecl       = %p \n&quot;,templateInstantiationFunctionDecl);</a>
<a name="5998"><span class="lineNum">    5998 </span>            :           printf (&quot;In setTemplateNameInTemplateInstantiations(): templateInstantiationMemberFunctionDecl = %p \n&quot;,templateInstantiationMemberFunctionDecl);</a>
<a name="5999"><span class="lineNum">    5999 </span>            : #endif</a>
<a name="6000"><span class="lineNum">    6000 </span>            : </a>
<a name="6001"><span class="lineNum">    6001 </span><span class="lineCov">      16659 :           bool isMemberFunction = (templateInstantiationMemberFunctionDecl != NULL);</span></a>
<a name="6002"><span class="lineNum">    6002 </span><span class="lineCov">      16659 :           if (isMemberFunction == true)</span></a>
<a name="6003"><span class="lineNum">    6003 </span>            :              {</a>
<a name="6004"><span class="lineNum">    6004 </span><span class="lineCov">      14387 :                ROSE_ASSERT(templateInstantiationMemberFunctionDecl != NULL);</span></a>
<a name="6005"><span class="lineNum">    6005 </span><span class="lineCov">      14387 :                ROSE_ASSERT(templateInstantiationFunctionDecl == NULL);</span></a>
<a name="6006"><span class="lineNum">    6006 </span>            : </a>
<a name="6007"><span class="lineNum">    6007 </span><span class="lineCov">      14387 :                if (templateInstantiationMemberFunctionDecl-&gt;get_templateName().is_null() == true)</span></a>
<a name="6008"><span class="lineNum">    6008 </span>            :                   {</a>
<a name="6009"><span class="lineNum">    6009 </span>            :                  // Set the template name for the member function template instantiation.</a>
<a name="6010"><span class="lineNum">    6010 </span>            :                  // templateInstantiationMemberFunctionDecl-&gt;set_templateName(name);</a>
<a name="6011"><span class="lineNum">    6011 </span><span class="lineCov">      14387 :                     templateInstantiationMemberFunctionDecl-&gt;set_templateName(templateNameWithoutArguments);</span></a>
<a name="6012"><span class="lineNum">    6012 </span>            : </a>
<a name="6013"><span class="lineNum">    6013 </span>            :                  // DQ (5/31/2012): Find locations where this is set and include template syntax.</a>
<a name="6014"><span class="lineNum">    6014 </span>            :                  // ROSE_ASSERT(name.getString().find('&lt;') == string::npos);</a>
<a name="6015"><span class="lineNum">    6015 </span>            :                  // ROSE_ASSERT(templateNameWithoutArguments.getString().find('&lt;') == string::npos);</a>
<a name="6016"><span class="lineNum">    6016 </span>            :                  // ROSE_ASSERT(hasTemplateSyntax(templateNameWithoutArguments) == false);</a>
<a name="6017"><span class="lineNum">    6017 </span>            :                   }</a>
<a name="6018"><span class="lineNum">    6018 </span>            : #if 0</a>
<a name="6019"><span class="lineNum">    6019 </span>            :                printf (&quot;templateInstantiationMemberFunctionDecl-&gt;get_templateName() = %s \n&quot;,templateInstantiationMemberFunctionDecl-&gt;get_templateName().str());</a>
<a name="6020"><span class="lineNum">    6020 </span>            : #endif</a>
<a name="6021"><span class="lineNum">    6021 </span><span class="lineCov">      14387 :                ROSE_ASSERT(templateInstantiationMemberFunctionDecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="6022"><span class="lineNum">    6022 </span>            :              }</a>
<a name="6023"><span class="lineNum">    6023 </span>            :             else</a>
<a name="6024"><span class="lineNum">    6024 </span>            :              {</a>
<a name="6025"><span class="lineNum">    6025 </span><span class="lineCov">       2272 :                ROSE_ASSERT(templateInstantiationFunctionDecl != NULL);</span></a>
<a name="6026"><span class="lineNum">    6026 </span><span class="lineCov">       2272 :                ROSE_ASSERT(templateInstantiationMemberFunctionDecl == NULL);</span></a>
<a name="6027"><span class="lineNum">    6027 </span>            : </a>
<a name="6028"><span class="lineNum">    6028 </span><span class="lineCov">       2272 :                if (templateInstantiationFunctionDecl-&gt;get_templateName().is_null() == true)</span></a>
<a name="6029"><span class="lineNum">    6029 </span>            :                   {</a>
<a name="6030"><span class="lineNum">    6030 </span>            :                  // Set the template name for the function template instantiation.</a>
<a name="6031"><span class="lineNum">    6031 </span>            :                  // templateInstantiationFunctionDecl-&gt;set_templateName(name);</a>
<a name="6032"><span class="lineNum">    6032 </span><span class="lineCov">       2272 :                     templateInstantiationFunctionDecl-&gt;set_templateName(templateNameWithoutArguments);</span></a>
<a name="6033"><span class="lineNum">    6033 </span>            : </a>
<a name="6034"><span class="lineNum">    6034 </span>            :                  // DQ (5/31/2012): Find locations where this is set and include template syntax.</a>
<a name="6035"><span class="lineNum">    6035 </span>            :                  // ROSE_ASSERT(name.getString().find('&lt;') == string::npos);</a>
<a name="6036"><span class="lineNum">    6036 </span>            :                  // ROSE_ASSERT(templateNameWithoutArguments.getString().find('&lt;') == string::npos);</a>
<a name="6037"><span class="lineNum">    6037 </span><span class="lineCov">       2272 :                     ROSE_ASSERT(hasTemplateSyntax(templateNameWithoutArguments) == false);</span></a>
<a name="6038"><span class="lineNum">    6038 </span>            :                   }</a>
<a name="6039"><span class="lineNum">    6039 </span>            : #if 0</a>
<a name="6040"><span class="lineNum">    6040 </span>            :                printf (&quot;templateInstantiationFunctionDecl-&gt;get_templateName() = %s \n&quot;,templateInstantiationFunctionDecl-&gt;get_templateName().str());</a>
<a name="6041"><span class="lineNum">    6041 </span>            : #endif</a>
<a name="6042"><span class="lineNum">    6042 </span><span class="lineCov">       2272 :                ROSE_ASSERT(templateInstantiationFunctionDecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="6043"><span class="lineNum">    6043 </span>            :              }</a>
<a name="6044"><span class="lineNum">    6044 </span>            : #if 0</a>
<a name="6045"><span class="lineNum">    6045 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="6046"><span class="lineNum">    6046 </span>            :           ROSE_ABORT();</a>
<a name="6047"><span class="lineNum">    6047 </span>            : #endif</a>
<a name="6048"><span class="lineNum">    6048 </span>            :         }</a>
<a name="6049"><span class="lineNum">    6049 </span><span class="lineCov">    1180450 :    }</span></a>
<a name="6050"><span class="lineNum">    6050 </span>            : </a>
<a name="6051"><span class="lineNum">    6051 </span>            : </a>
<a name="6052"><span class="lineNum">    6052 </span>            : // SgFunctionDeclaration* SageBuilder::buildDefiningFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgFunctionDeclaration* first_nondefining_declaration)</a>
<a name="6053"><span class="lineNum">    6053 </span>            : SgFunctionDeclaration*</a>
<a name="6054"><span class="lineNum">    6054 </span><span class="lineCov">       3819 : SageBuilder::buildDefiningFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgFunctionDeclaration* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)</span></a>
<a name="6055"><span class="lineNum">    6055 </span>            :    {</a>
<a name="6056"><span class="lineNum">    6056 </span>            :   // DQ (2/10/2012): This is not correct, we have to build template instantiations depending on the value of buildTemplateInstantiation.</a>
<a name="6057"><span class="lineNum">    6057 </span>            :   // SgFunctionDeclaration* func = buildDefiningFunctionDeclaration_T&lt;SgFunctionDeclaration&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList);</a>
<a name="6058"><span class="lineNum">    6058 </span>            : </a>
<a name="6059"><span class="lineNum">    6059 </span>            :   // DQ (2/10/2012): Fixed to build either SgTemplateInstantiationFunctionDecl or SgFunctionDeclaration.</a>
<a name="6060"><span class="lineNum">    6060 </span><span class="lineCov">       3819 :      SgFunctionDeclaration* func = NULL;</span></a>
<a name="6061"><span class="lineNum">    6061 </span><span class="lineCov">       3819 :      if (buildTemplateInstantiation == true)</span></a>
<a name="6062"><span class="lineNum">    6062 </span>            :         {</a>
<a name="6063"><span class="lineNum">    6063 </span><span class="lineCov">        577 :           SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(first_nondefining_declaration);</span></a>
<a name="6064"><span class="lineNum">    6064 </span>            : </a>
<a name="6065"><span class="lineNum">    6065 </span><span class="lineCov">        577 :           ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="6066"><span class="lineNum">    6066 </span>            : #if 0</a>
<a name="6067"><span class="lineNum">    6067 </span>            :           printf (&quot;In buildDefiningFunctionDeclaration(): first_nondefining_declaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,first_nondefining_declaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6068"><span class="lineNum">    6068 </span>            : #endif</a>
<a name="6069"><span class="lineNum">    6069 </span>            :        // func = buildDefiningFunctionDeclaration_T&lt;SgTemplateInstantiationFunctionDecl&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl);</a>
<a name="6070"><span class="lineNum">    6070 </span>            :        // func = buildDefiningFunctionDeclaration_T&lt;SgTemplateInstantiationFunctionDecl&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl, templateArgumentsList);</a>
<a name="6071"><span class="lineNum">    6071 </span><span class="lineCov">        577 :           func = buildDefiningFunctionDeclaration_T&lt;SgTemplateInstantiationFunctionDecl&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl, templateArgumentsList);</span></a>
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<a name="6073"><span class="lineNum">    6073 </span><span class="lineCov">        577 :           ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func) != NULL);</span></a>
<a name="6074"><span class="lineNum">    6074 </span>            : #if 0</a>
<a name="6075"><span class="lineNum">    6075 </span>            :           printf (&quot;In SageBuilder::buildDefiningFunctionDeclaration(): isSgTemplateInstantiationFunctionDecl(func)-&gt;get_templateName() = %s \n&quot;,isSgTemplateInstantiationFunctionDecl(func)-&gt;get_templateName().str());</a>
<a name="6076"><span class="lineNum">    6076 </span>            : #endif</a>
<a name="6077"><span class="lineNum">    6077 </span><span class="lineCov">        577 :           ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func) != NULL);</span></a>
<a name="6078"><span class="lineNum">    6078 </span><span class="lineCov">        577 :           ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func)-&gt;get_templateName().is_null() == false);</span></a>
<a name="6079"><span class="lineNum">    6079 </span>            :         }</a>
<a name="6080"><span class="lineNum">    6080 </span>            :        else</a>
<a name="6081"><span class="lineNum">    6081 </span>            :         {</a>
<a name="6082"><span class="lineNum">    6082 </span><span class="lineCov">       3242 :           ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="6083"><span class="lineNum">    6083 </span>            : </a>
<a name="6084"><span class="lineNum">    6084 </span>            :        // func = buildDefiningFunctionDeclaration_T&lt;SgFunctionDeclaration&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,first_nondefining_declaration);</a>
<a name="6085"><span class="lineNum">    6085 </span><span class="lineCov">       3242 :           func = buildDefiningFunctionDeclaration_T&lt;SgFunctionDeclaration&gt;(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,first_nondefining_declaration, NULL);</span></a>
<a name="6086"><span class="lineNum">    6086 </span>            : </a>
<a name="6087"><span class="lineNum">    6087 </span><span class="lineCov">       3242 :           ROSE_ASSERT(isSgFunctionDeclaration(func) != NULL);</span></a>
<a name="6088"><span class="lineNum">    6088 </span>            :         }</a>
<a name="6089"><span class="lineNum">    6089 </span>            : </a>
<a name="6090"><span class="lineNum">    6090 </span><span class="lineCov">       3819 :      return func;</span></a>
<a name="6091"><span class="lineNum">    6091 </span>            :    }</a>
<a name="6092"><span class="lineNum">    6092 </span>            : </a>
<a name="6093"><span class="lineNum">    6093 </span>            : </a>
<a name="6094"><span class="lineNum">    6094 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).</a>
<a name="6095"><span class="lineNum">    6095 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="6096"><span class="lineNum">    6096 </span>            : SgFunctionDeclaration*</a>
<a name="6097"><span class="lineNum">    6097 </span><span class="lineCov">          4 : SageBuilder::buildDefiningFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list, SgScopeStatement* scope)</span></a>
<a name="6098"><span class="lineNum">    6098 </span>            :    {</a>
<a name="6099"><span class="lineNum">    6099 </span>            :   // DQ (11/12/2012): Note that this function is not used in the AST construction in the EDG/ROSE interface.</a>
<a name="6100"><span class="lineNum">    6100 </span>            : </a>
<a name="6101"><span class="lineNum">    6101 </span>            :   // DQ (8/23/2013): Added assertions.</a>
<a name="6102"><span class="lineNum">    6102 </span><span class="lineCov">          4 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="6103"><span class="lineNum">    6103 </span><span class="lineCov">          4 :      ROSE_ASSERT(parameter_list != NULL);</span></a>
<a name="6104"><span class="lineNum">    6104 </span>            : </a>
<a name="6105"><span class="lineNum">    6105 </span>            :   // DQ (8/23/2013): We need to provide the buildDefiningFunctionDeclaration() function with a pointer to the first non-defining declaration.</a>
<a name="6106"><span class="lineNum">    6106 </span>            :   // So we need to find it, and if it does not exist we need to build one so that we have a simple API for building defining declarations.</a>
<a name="6107"><span class="lineNum">    6107 </span>            :   // DQ (11/12/2012): Building a defining declaration from scratch now requires a non-defining declaration to exist.</a>
<a name="6108"><span class="lineNum">    6108 </span>            :   // SgFunctionDeclaration* nondefininfDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);</a>
<a name="6109"><span class="lineNum">    6109 </span>            : </a>
<a name="6110"><span class="lineNum">    6110 </span><span class="lineCov">          4 :      if (scope == NULL)</span></a>
<a name="6111"><span class="lineNum">    6111 </span>            :         {</a>
<a name="6112"><span class="lineNum">    6112 </span><span class="lineCov">          4 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="6113"><span class="lineNum">    6113 </span>            :         }</a>
<a name="6114"><span class="lineNum">    6114 </span>            : </a>
<a name="6115"><span class="lineNum">    6115 </span><span class="lineCov">          4 :      SgFunctionDeclaration* nondefiningDeclaration = NULL;</span></a>
<a name="6116"><span class="lineNum">    6116 </span>            : </a>
<a name="6117"><span class="lineNum">    6117 </span><span class="lineCov">          4 :      SgFunctionType* func_type = buildFunctionType(return_type,parameter_list);</span></a>
<a name="6118"><span class="lineNum">    6118 </span><span class="lineCov">          4 :      SgFunctionSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;SgFunctionDeclaration&gt;(name,func_type,NULL,NULL);</span></a>
<a name="6119"><span class="lineNum">    6119 </span><span class="lineCov">          4 :      if (func_symbol != NULL)</span></a>
<a name="6120"><span class="lineNum">    6120 </span>            :         {</a>
<a name="6121"><span class="lineNum">    6121 </span><span class="lineCov">          1 :           nondefiningDeclaration = func_symbol-&gt;get_declaration();</span></a>
<a name="6122"><span class="lineNum">    6122 </span>            :         }</a>
<a name="6123"><span class="lineNum">    6123 </span>            :        else</a>
<a name="6124"><span class="lineNum">    6124 </span>            :         {</a>
<a name="6125"><span class="lineNum">    6125 </span><span class="lineCov">          3 :           nondefiningDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);</span></a>
<a name="6126"><span class="lineNum">    6126 </span>            : #if 0</a>
<a name="6127"><span class="lineNum">    6127 </span>            :        // DQ (11/20/2013): We should not be appending the nondefiningDeclaration to the scope.  This was added a few months ago.</a>
<a name="6128"><span class="lineNum">    6128 </span>            :        // This was a mistake/misunderstanding with Laio about the semantics of the buildDefiningFunctionDeclaration()</a>
<a name="6129"><span class="lineNum">    6129 </span>            :        // function.  Building a function should not have a side-effect on the AST (though clearly it can build new</a>
<a name="6130"><span class="lineNum">    6130 </span>            :        // subtrees, the AST is not modified until the result of the buildDefiningFunctionDeclaration() is explicitly</a>
<a name="6131"><span class="lineNum">    6131 </span>            :        // added (it should also not add the nondefiningDeclaration).  Additionally this code was not consistant with</a>
<a name="6132"><span class="lineNum">    6132 </span>            :        // the associated fortran function to build defining function declaration.</a>
<a name="6133"><span class="lineNum">    6133 </span>            :           if (scope != NULL)</a>
<a name="6134"><span class="lineNum">    6134 </span>            :                appendStatement(nondefiningDeclaration, scope);</a>
<a name="6135"><span class="lineNum">    6135 </span>            : #endif</a>
<a name="6136"><span class="lineNum">    6136 </span>            :         }</a>
<a name="6137"><span class="lineNum">    6137 </span>            : </a>
<a name="6138"><span class="lineNum">    6138 </span>            :   // DQ (8/23/2013): Added assertions.</a>
<a name="6139"><span class="lineNum">    6139 </span><span class="lineCov">          4 :      assert(nondefiningDeclaration != NULL);</span></a>
<a name="6140"><span class="lineNum">    6140 </span><span class="lineCov">          4 :      assert(nondefiningDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="6141"><span class="lineNum">    6141 </span><span class="lineCov">          4 :      assert(nondefiningDeclaration-&gt;get_firstNondefiningDeclaration() == nondefiningDeclaration);</span></a>
<a name="6142"><span class="lineNum">    6142 </span>            : </a>
<a name="6143"><span class="lineNum">    6143 </span><span class="lineCov">          4 :      return buildDefiningFunctionDeclaration (name,return_type,parameter_list,scope,NULL,false,nondefiningDeclaration,NULL);</span></a>
<a name="6144"><span class="lineNum">    6144 </span>            :    }</a>
<a name="6145"><span class="lineNum">    6145 </span>            : </a>
<a name="6146"><span class="lineNum">    6146 </span>            : // Build a nondefining SgProcedureHeaderStatement, handle function type, symbol etc transparently [CR 9/24/2020]</a>
<a name="6147"><span class="lineNum">    6147 </span><span class="lineNoCov">          0 : SgProcedureHeaderStatement* SageBuilder::</span></a>
<a name="6148"><span class="lineNum">    6148 </span>            : buildNondefiningProcedureHeaderStatement(const SgName &amp; name, SgType* return_type, SgFunctionParameterList* param_list,</a>
<a name="6149"><span class="lineNum">    6149 </span>            :                                          SgProcedureHeaderStatement::subprogram_kind_enum kind, SgScopeStatement* scope)</a>
<a name="6150"><span class="lineNum">    6150 </span>            :   {</a>
<a name="6151"><span class="lineNum">    6151 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(return_type);</span></a>
<a name="6152"><span class="lineNum">    6152 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(param_list);</span></a>
<a name="6153"><span class="lineNum">    6153 </span>            : </a>
<a name="6154"><span class="lineNum">    6154 </span><span class="lineNoCov">          0 :     SgProcedureHeaderStatement* nondef_decl = NULL;</span></a>
<a name="6155"><span class="lineNum">    6155 </span>            : </a>
<a name="6156"><span class="lineNum">    6156 </span><span class="lineNoCov">          0 :     if (scope == NULL)</span></a>
<a name="6157"><span class="lineNum">    6157 </span>            :       {</a>
<a name="6158"><span class="lineNum">    6158 </span><span class="lineNoCov">          0 :         scope = SageBuilder::topScopeStack();</span></a>
<a name="6159"><span class="lineNum">    6159 </span>            :       }</a>
<a name="6160"><span class="lineNum">    6160 </span>            : </a>
<a name="6161"><span class="lineNum">    6161 </span>            :   // A new nondefing declaration is needed even if the function symbol already exists. The function symbol</a>
<a name="6162"><span class="lineNum">    6162 </span>            :   // should always contain the _first_ nondefining declaration (even though this may not be the first one).</a>
<a name="6163"><span class="lineNum">    6163 </span><span class="lineNoCov">          0 :     nondef_decl = buildNondefiningFunctionDeclaration_T &lt;SgProcedureHeaderStatement&gt;</span></a>
<a name="6164"><span class="lineNum">    6164 </span><span class="lineNoCov">          0 :                        ( name, return_type, param_list, /*isMemberFunction*/false, scope, /*decoratorList*/NULL,</span></a>
<a name="6165"><span class="lineNum">    6165 </span>            :                         /*functionConstVolatileFlags*/0, NULL, NULL, SgStorageModifier::e_default );</a>
<a name="6166"><span class="lineNum">    6166 </span>            : </a>
<a name="6167"><span class="lineNum">    6167 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(isSgProcedureHeaderStatement(nondef_decl));</span></a>
<a name="6168"><span class="lineNum">    6168 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(nondef_decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="6169"><span class="lineNum">    6169 </span>            : </a>
<a name="6170"><span class="lineNum">    6170 </span><span class="lineNoCov">          0 :     nondef_decl-&gt;set_subprogram_kind(kind);</span></a>
<a name="6171"><span class="lineNum">    6171 </span>            : </a>
<a name="6172"><span class="lineNum">    6172 </span><span class="lineNoCov">          0 :     return nondef_decl;</span></a>
<a name="6173"><span class="lineNum">    6173 </span>            :   }</a>
<a name="6174"><span class="lineNum">    6174 </span>            : </a>
<a name="6175"><span class="lineNum">    6175 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).</a>
<a name="6176"><span class="lineNum">    6176 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="6177"><span class="lineNum">    6177 </span>            : // CR (10/7/2020): May not be appropriate for C++ but improves capability for Fortran and Jovial.</a>
<a name="6178"><span class="lineNum">    6178 </span><span class="lineCov">          5 : SgProcedureHeaderStatement* SageBuilder::</span></a>
<a name="6179"><span class="lineNum">    6179 </span>            : buildProcedureHeaderStatement(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list,</a>
<a name="6180"><span class="lineNum">    6180 </span>            :                               SgProcedureHeaderStatement::subprogram_kind_enum kind, SgScopeStatement* scope)</a>
<a name="6181"><span class="lineNum">    6181 </span>            :    {</a>
<a name="6182"><span class="lineNum">    6182 </span><span class="lineCov">          5 :      ROSE_ASSERT(return_type != NULL);</span></a>
<a name="6183"><span class="lineNum">    6183 </span><span class="lineCov">          5 :      ROSE_ASSERT(parameter_list != NULL);</span></a>
<a name="6184"><span class="lineNum">    6184 </span>            : </a>
<a name="6185"><span class="lineNum">    6185 </span><span class="lineCov">          5 :      SgFunctionDeclaration* nondef_decl = NULL;</span></a>
<a name="6186"><span class="lineNum">    6186 </span>            : </a>
<a name="6187"><span class="lineNum">    6187 </span><span class="lineCov">          5 :      if (scope == NULL)</span></a>
<a name="6188"><span class="lineNum">    6188 </span>            :         {</a>
<a name="6189"><span class="lineNum">    6189 </span><span class="lineCov">          4 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="6190"><span class="lineNum">    6190 </span>            :         }</a>
<a name="6191"><span class="lineNum">    6191 </span>            : </a>
<a name="6192"><span class="lineNum">    6192 </span><span class="lineCov">          5 :      SgFunctionType* func_type = buildFunctionType(return_type,parameter_list);</span></a>
<a name="6193"><span class="lineNum">    6193 </span><span class="lineCov">          5 :      SgFunctionSymbol* func_symbol = scope-&gt;find_symbol_by_type_of_function&lt;SgProcedureHeaderStatement&gt;(name,func_type,NULL,NULL);</span></a>
<a name="6194"><span class="lineNum">    6194 </span><span class="lineCov">          5 :      if (func_symbol == NULL)</span></a>
<a name="6195"><span class="lineNum">    6195 </span>            :         {</a>
<a name="6196"><span class="lineNum">    6196 </span>            :        // CR (3/25/2020): Replaced call to builder function with templated version.</a>
<a name="6197"><span class="lineNum">    6197 </span><span class="lineCov">          4 :           nondef_decl = buildNondefiningFunctionDeclaration_T &lt;SgProcedureHeaderStatement&gt;</span></a>
<a name="6198"><span class="lineNum">    6198 </span><span class="lineCov">          4 :                            ( name, return_type, parameter_list, /*isMemberFunction*/false, scope,</span></a>
<a name="6199"><span class="lineNum">    6199 </span>            :                             /*decoratorList*/NULL, /*functionConstVolatileFlags*/0, NULL, NULL, SgStorageModifier::e_default);</a>
<a name="6200"><span class="lineNum">    6200 </span>            :         }</a>
<a name="6201"><span class="lineNum">    6201 </span>            :        else</a>
<a name="6202"><span class="lineNum">    6202 </span>            :         {</a>
<a name="6203"><span class="lineNum">    6203 </span><span class="lineCov">          1 :           nondef_decl = func_symbol-&gt;get_declaration();</span></a>
<a name="6204"><span class="lineNum">    6204 </span>            :         }</a>
<a name="6205"><span class="lineNum">    6205 </span>            : </a>
<a name="6206"><span class="lineNum">    6206 </span><span class="lineCov">          5 :      assert(nondef_decl != NULL);</span></a>
<a name="6207"><span class="lineNum">    6207 </span><span class="lineCov">          5 :      assert(nondef_decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="6208"><span class="lineNum">    6208 </span><span class="lineCov">          5 :      assert(nondef_decl-&gt;get_firstNondefiningDeclaration() == nondef_decl);</span></a>
<a name="6209"><span class="lineNum">    6209 </span>            : </a>
<a name="6210"><span class="lineNum">    6210 </span><span class="lineCov">          5 :      SgProcedureHeaderStatement* proc_header_stmt = isSgProcedureHeaderStatement(nondef_decl);</span></a>
<a name="6211"><span class="lineNum">    6211 </span><span class="lineCov">          5 :      ROSE_ASSERT(proc_header_stmt);</span></a>
<a name="6212"><span class="lineNum">    6212 </span>            : </a>
<a name="6213"><span class="lineNum">    6213 </span><span class="lineCov">          5 :      return buildProcedureHeaderStatement(name.str(), return_type, parameter_list, kind, scope, proc_header_stmt);</span></a>
<a name="6214"><span class="lineNum">    6214 </span>            :    }</a>
<a name="6215"><span class="lineNum">    6215 </span>            : </a>
<a name="6216"><span class="lineNum">    6216 </span>            : </a>
<a name="6217"><span class="lineNum">    6217 </span>            : //! Build a Fortran subroutine or procedure</a>
<a name="6218"><span class="lineNum">    6218 </span>            : SgProcedureHeaderStatement*</a>
<a name="6219"><span class="lineNum">    6219 </span><span class="lineCov">          5 : SageBuilder::buildProcedureHeaderStatement( const char* name, SgType* return_type, SgFunctionParameterList * paralist,</span></a>
<a name="6220"><span class="lineNum">    6220 </span>            :                                             SgProcedureHeaderStatement::subprogram_kind_enum kind, SgScopeStatement* scope/*=NULL*/,</a>
<a name="6221"><span class="lineNum">    6221 </span>            :                                             SgProcedureHeaderStatement* first_nondefining_declaration)</a>
<a name="6222"><span class="lineNum">    6222 </span>            :    {</a>
<a name="6223"><span class="lineNum">    6223 </span>            :   // CR (10/7/2020): Cleaned up code</a>
<a name="6224"><span class="lineNum">    6224 </span><span class="lineCov">          5 :      ROSE_ASSERT(first_nondefining_declaration != NULL);</span></a>
<a name="6225"><span class="lineNum">    6225 </span>            : </a>
<a name="6226"><span class="lineNum">    6226 </span><span class="lineCov">          5 :      if (kind == SgProcedureHeaderStatement::e_subroutine_subprogram_kind)</span></a>
<a name="6227"><span class="lineNum">    6227 </span>            :         {</a>
<a name="6228"><span class="lineNum">    6228 </span><span class="lineCov">          4 :           ROSE_ASSERT(return_type == buildVoidType());</span></a>
<a name="6229"><span class="lineNum">    6229 </span>            :         }</a>
<a name="6230"><span class="lineNum">    6230 </span>            :        else</a>
<a name="6231"><span class="lineNum">    6231 </span>            :         {</a>
<a name="6232"><span class="lineNum">    6232 </span><span class="lineCov">          1 :           if (kind != SgProcedureHeaderStatement::e_function_subprogram_kind)</span></a>
<a name="6233"><span class="lineNum">    6233 </span>            :              {</a>
<a name="6234"><span class="lineNum">    6234 </span><span class="lineNoCov">          0 :                mlog[ERROR] &lt;&lt; &quot;unhandled subprogram kind for Fortran (or Jovial) function declaration:&quot;</span></a>
<a name="6235"><span class="lineNum">    6235 </span><span class="lineNoCov">          0 :                            &lt;&lt; kind &lt;&lt; endl;</span></a>
<a name="6236"><span class="lineNum">    6236 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="6237"><span class="lineNum">    6237 </span>            :              }</a>
<a name="6238"><span class="lineNum">    6238 </span>            :         }</a>
<a name="6239"><span class="lineNum">    6239 </span>            : </a>
<a name="6240"><span class="lineNum">    6240 </span><span class="lineCov">          5 :      SgProcedureHeaderStatement* func = buildDefiningFunctionDeclaration_T&lt;SgProcedureHeaderStatement&gt; (SgName(name),return_type,paralist,/* isMemberFunction = */ false,scope,NULL,0U,first_nondefining_declaration, NULL);</span></a>
<a name="6241"><span class="lineNum">    6241 </span><span class="lineCov">          5 :      ROSE_ASSERT(func != NULL);</span></a>
<a name="6242"><span class="lineNum">    6242 </span>            : </a>
<a name="6243"><span class="lineNum">    6243 </span><span class="lineCov">          5 :      func-&gt;set_subprogram_kind(kind);</span></a>
<a name="6244"><span class="lineNum">    6244 </span>            : </a>
<a name="6245"><span class="lineNum">    6245 </span><span class="lineCov">          5 :      return func;</span></a>
<a name="6246"><span class="lineNum">    6246 </span>            :    }</a>
<a name="6247"><span class="lineNum">    6247 </span>            : </a>
<a name="6248"><span class="lineNum">    6248 </span>            : #if 0</a>
<a name="6249"><span class="lineNum">    6249 </span>            : // DQ (7/26/2012): I would like to remove these from the API (if possible).</a>
<a name="6250"><span class="lineNum">    6250 </span>            : SgFunctionDeclaration*</a>
<a name="6251"><span class="lineNum">    6251 </span>            : SageBuilder::buildDefiningFunctionDeclaration(const std::string &amp; name, SgType* return_type, SgFunctionParameterList * paralist,SgScopeStatement* scope, SgExprListExp* decoratorList, SgFunctionDeclaration* first_nondefining_declaration)</a>
<a name="6252"><span class="lineNum">    6252 </span>            :    {</a>
<a name="6253"><span class="lineNum">    6253 </span>            :      SgName sg_name(name);</a>
<a name="6254"><span class="lineNum">    6254 </span>            : </a>
<a name="6255"><span class="lineNum">    6255 </span>            :      bool buildTemplateInstantiation = false;</a>
<a name="6256"><span class="lineNum">    6256 </span>            : </a>
<a name="6257"><span class="lineNum">    6257 </span>            :   // DQ (5/11/2012): This is a compile time error (use if SgFunctionDeclaration* first_nondefining_declaration results in ambigous function type for g++).</a>
<a name="6258"><span class="lineNum">    6258 </span>            :   // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,first_nondefining_declaration);</a>
<a name="6259"><span class="lineNum">    6259 </span>            :   // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList);</a>
<a name="6260"><span class="lineNum">    6260 </span>            :      return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,buildTemplateInstantiation,first_nondefining_declaration);</a>
<a name="6261"><span class="lineNum">    6261 </span>            :    }</a>
<a name="6262"><span class="lineNum">    6262 </span>            : #endif</a>
<a name="6263"><span class="lineNum">    6263 </span>            : </a>
<a name="6264"><span class="lineNum">    6264 </span>            : #if 0</a>
<a name="6265"><span class="lineNum">    6265 </span>            : // DQ (7/26/2012): I would like to remove these from the API (if possible).</a>
<a name="6266"><span class="lineNum">    6266 </span>            : SgFunctionDeclaration *</a>
<a name="6267"><span class="lineNum">    6267 </span>            : SageBuilder::buildDefiningFunctionDeclaration(const char* name, SgType* return_type, SgFunctionParameterList * paralist,SgScopeStatement* scope, SgExprListExp* decoratorList, SgFunctionDeclaration* first_nondefining_declaration)</a>
<a name="6268"><span class="lineNum">    6268 </span>            :    {</a>
<a name="6269"><span class="lineNum">    6269 </span>            :      SgName sg_name(name);</a>
<a name="6270"><span class="lineNum">    6270 </span>            : </a>
<a name="6271"><span class="lineNum">    6271 </span>            :      bool buildTemplateInstantiation = false;</a>
<a name="6272"><span class="lineNum">    6272 </span>            : </a>
<a name="6273"><span class="lineNum">    6273 </span>            :   // DQ (5/11/2012): This is a compile time error (use if SgFunctionDeclaration* first_nondefining_declaration results in ambigous function type for g++).</a>
<a name="6274"><span class="lineNum">    6274 </span>            :   // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,first_nondefining_declaration);</a>
<a name="6275"><span class="lineNum">    6275 </span>            :      return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,buildTemplateInstantiation,first_nondefining_declaration);</a>
<a name="6276"><span class="lineNum">    6276 </span>            :    }</a>
<a name="6277"><span class="lineNum">    6277 </span>            : #endif</a>
<a name="6278"><span class="lineNum">    6278 </span>            : </a>
<a name="6279"><span class="lineNum">    6279 </span>            : </a>
<a name="6280"><span class="lineNum">    6280 </span>            : //------------------build value expressions -------------------</a>
<a name="6281"><span class="lineNum">    6281 </span>            : //-------------------------------------------------------------</a>
<a name="6282"><span class="lineNum">    6282 </span><span class="lineCov">          1 : SgBoolValExp* SageBuilder::buildBoolValExp(int value /*=0*/)</span></a>
<a name="6283"><span class="lineNum">    6283 </span>            : {</a>
<a name="6284"><span class="lineNum">    6284 </span>            :   //TODO does valueString matter here?</a>
<a name="6285"><span class="lineNum">    6285 </span><span class="lineCov">          1 :   SgBoolValExp* boolValue= new SgBoolValExp(value);</span></a>
<a name="6286"><span class="lineNum">    6286 </span><span class="lineCov">          1 :   ROSE_ASSERT(boolValue);</span></a>
<a name="6287"><span class="lineNum">    6287 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(boolValue);</span></a>
<a name="6288"><span class="lineNum">    6288 </span><span class="lineCov">          1 :   return boolValue;</span></a>
<a name="6289"><span class="lineNum">    6289 </span>            : }</a>
<a name="6290"><span class="lineNum">    6290 </span><span class="lineCov">          1 : SgBoolValExp* SageBuilder::buildBoolValExp(bool value /*=0*/)</span></a>
<a name="6291"><span class="lineNum">    6291 </span>            : {</a>
<a name="6292"><span class="lineNum">    6292 </span><span class="lineCov">          1 :   return buildBoolValExp(int(value));</span></a>
<a name="6293"><span class="lineNum">    6293 </span>            : }</a>
<a name="6294"><span class="lineNum">    6294 </span><span class="lineCov">       4969 : SgBoolValExp* SageBuilder::buildBoolValExp_nfi(int value)</span></a>
<a name="6295"><span class="lineNum">    6295 </span>            : {</a>
<a name="6296"><span class="lineNum">    6296 </span><span class="lineCov">       4969 :   SgBoolValExp* boolValue= new SgBoolValExp(value);</span></a>
<a name="6297"><span class="lineNum">    6297 </span><span class="lineCov">       4969 :   ROSE_ASSERT(boolValue);</span></a>
<a name="6298"><span class="lineNum">    6298 </span><span class="lineCov">       4969 :   setOneSourcePositionNull(boolValue);</span></a>
<a name="6299"><span class="lineNum">    6299 </span><span class="lineCov">       4969 :   return boolValue;</span></a>
<a name="6300"><span class="lineNum">    6300 </span>            : }</a>
<a name="6301"><span class="lineNum">    6301 </span>            : </a>
<a name="6302"><span class="lineNum">    6302 </span><span class="lineNoCov">          0 : SgNullptrValExp* SageBuilder::buildNullptrValExp()</span></a>
<a name="6303"><span class="lineNum">    6303 </span>            :    {</a>
<a name="6304"><span class="lineNum">    6304 </span><span class="lineNoCov">          0 :      SgNullptrValExp* nullptrValue = new SgNullptrValExp();</span></a>
<a name="6305"><span class="lineNum">    6305 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nullptrValue);</span></a>
<a name="6306"><span class="lineNum">    6306 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(nullptrValue);</span></a>
<a name="6307"><span class="lineNum">    6307 </span><span class="lineNoCov">          0 :      return nullptrValue;</span></a>
<a name="6308"><span class="lineNum">    6308 </span>            :    }</a>
<a name="6309"><span class="lineNum">    6309 </span>            : </a>
<a name="6310"><span class="lineNum">    6310 </span><span class="lineCov">        125 : SgNullptrValExp* SageBuilder::buildNullptrValExp_nfi()</span></a>
<a name="6311"><span class="lineNum">    6311 </span>            :    {</a>
<a name="6312"><span class="lineNum">    6312 </span><span class="lineCov">        125 :      SgNullptrValExp* nullptrValue = new SgNullptrValExp();</span></a>
<a name="6313"><span class="lineNum">    6313 </span><span class="lineCov">        125 :      ROSE_ASSERT(nullptrValue);</span></a>
<a name="6314"><span class="lineNum">    6314 </span><span class="lineCov">        125 :      setOneSourcePositionNull(nullptrValue);</span></a>
<a name="6315"><span class="lineNum">    6315 </span><span class="lineCov">        125 :      return nullptrValue;</span></a>
<a name="6316"><span class="lineNum">    6316 </span>            :    }</a>
<a name="6317"><span class="lineNum">    6317 </span>            : </a>
<a name="6318"><span class="lineNum">    6318 </span><span class="lineNoCov">          0 : SgVoidVal* SageBuilder::buildVoidVal()</span></a>
<a name="6319"><span class="lineNum">    6319 </span>            :    {</a>
<a name="6320"><span class="lineNum">    6320 </span><span class="lineNoCov">          0 :      SgVoidVal* voidValue = new SgVoidVal();</span></a>
<a name="6321"><span class="lineNum">    6321 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(voidValue);</span></a>
<a name="6322"><span class="lineNum">    6322 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(voidValue);</span></a>
<a name="6323"><span class="lineNum">    6323 </span><span class="lineNoCov">          0 :      return voidValue;</span></a>
<a name="6324"><span class="lineNum">    6324 </span>            :    }</a>
<a name="6325"><span class="lineNum">    6325 </span>            : </a>
<a name="6326"><span class="lineNum">    6326 </span><span class="lineNoCov">          0 : SgVoidVal* SageBuilder::buildVoidVal_nfi()</span></a>
<a name="6327"><span class="lineNum">    6327 </span>            :    {</a>
<a name="6328"><span class="lineNum">    6328 </span><span class="lineNoCov">          0 :      SgVoidVal* voidValue = new SgVoidVal();</span></a>
<a name="6329"><span class="lineNum">    6329 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(voidValue);</span></a>
<a name="6330"><span class="lineNum">    6330 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(voidValue);</span></a>
<a name="6331"><span class="lineNum">    6331 </span><span class="lineNoCov">          0 :      return voidValue;</span></a>
<a name="6332"><span class="lineNum">    6332 </span>            :    }</a>
<a name="6333"><span class="lineNum">    6333 </span>            : </a>
<a name="6334"><span class="lineNum">    6334 </span><span class="lineNoCov">          0 : SgCharVal* SageBuilder::buildCharVal(char value /*= 0*/)</span></a>
<a name="6335"><span class="lineNum">    6335 </span>            : {</a>
<a name="6336"><span class="lineNum">    6336 </span><span class="lineNoCov">          0 :   SgCharVal* result = new SgCharVal(value, &quot;&quot;);</span></a>
<a name="6337"><span class="lineNum">    6337 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6338"><span class="lineNum">    6338 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6339"><span class="lineNum">    6339 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6340"><span class="lineNum">    6340 </span>            : }</a>
<a name="6341"><span class="lineNum">    6341 </span>            : </a>
<a name="6342"><span class="lineNum">    6342 </span><span class="lineCov">        406 : SgCharVal* SageBuilder::buildCharVal_nfi(char value, const string&amp; str)</span></a>
<a name="6343"><span class="lineNum">    6343 </span>            : {</a>
<a name="6344"><span class="lineNum">    6344 </span><span class="lineCov">        406 :   SgCharVal* result = new SgCharVal(value, str);</span></a>
<a name="6345"><span class="lineNum">    6345 </span><span class="lineCov">        406 :   ROSE_ASSERT(result);</span></a>
<a name="6346"><span class="lineNum">    6346 </span><span class="lineCov">        406 :   setOneSourcePositionNull(result);</span></a>
<a name="6347"><span class="lineNum">    6347 </span><span class="lineCov">        406 :   return result;</span></a>
<a name="6348"><span class="lineNum">    6348 </span>            : }</a>
<a name="6349"><span class="lineNum">    6349 </span>            : </a>
<a name="6350"><span class="lineNum">    6350 </span><span class="lineCov">          1 : SgWcharVal* SageBuilder::buildWcharVal(wchar_t value /*= 0*/)</span></a>
<a name="6351"><span class="lineNum">    6351 </span>            : {</a>
<a name="6352"><span class="lineNum">    6352 </span><span class="lineCov">          1 :   SgWcharVal* result = new SgWcharVal(value, &quot;&quot;);</span></a>
<a name="6353"><span class="lineNum">    6353 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6354"><span class="lineNum">    6354 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6355"><span class="lineNum">    6355 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6356"><span class="lineNum">    6356 </span>            : }</a>
<a name="6357"><span class="lineNum">    6357 </span>            : </a>
<a name="6358"><span class="lineNum">    6358 </span><span class="lineCov">          8 : SgWcharVal* SageBuilder::buildWcharVal_nfi(wchar_t value, const string&amp; str)</span></a>
<a name="6359"><span class="lineNum">    6359 </span>            : {</a>
<a name="6360"><span class="lineNum">    6360 </span><span class="lineCov">          8 :   SgWcharVal* result = new SgWcharVal(value, str);</span></a>
<a name="6361"><span class="lineNum">    6361 </span><span class="lineCov">          8 :   ROSE_ASSERT(result);</span></a>
<a name="6362"><span class="lineNum">    6362 </span><span class="lineCov">          8 :   setOneSourcePositionNull(result);</span></a>
<a name="6363"><span class="lineNum">    6363 </span><span class="lineCov">          8 :   return result;</span></a>
<a name="6364"><span class="lineNum">    6364 </span>            : }</a>
<a name="6365"><span class="lineNum">    6365 </span>            : </a>
<a name="6366"><span class="lineNum">    6366 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="6367"><span class="lineNum">    6367 </span><span class="lineNoCov">          0 : SgChar16Val* SageBuilder::buildChar16Val(unsigned short value /*= 0*/)</span></a>
<a name="6368"><span class="lineNum">    6368 </span>            : {</a>
<a name="6369"><span class="lineNum">    6369 </span><span class="lineNoCov">          0 :   SgChar16Val* result = new SgChar16Val(value, &quot;&quot;);</span></a>
<a name="6370"><span class="lineNum">    6370 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6371"><span class="lineNum">    6371 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6372"><span class="lineNum">    6372 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6373"><span class="lineNum">    6373 </span>            : }</a>
<a name="6374"><span class="lineNum">    6374 </span>            : </a>
<a name="6375"><span class="lineNum">    6375 </span><span class="lineNoCov">          0 : SgChar16Val* SageBuilder::buildChar16Val_nfi(unsigned short value, const string&amp; str)</span></a>
<a name="6376"><span class="lineNum">    6376 </span>            : {</a>
<a name="6377"><span class="lineNum">    6377 </span><span class="lineNoCov">          0 :   SgChar16Val* result = new SgChar16Val(value, str);</span></a>
<a name="6378"><span class="lineNum">    6378 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6379"><span class="lineNum">    6379 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6380"><span class="lineNum">    6380 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6381"><span class="lineNum">    6381 </span>            : }</a>
<a name="6382"><span class="lineNum">    6382 </span>            : </a>
<a name="6383"><span class="lineNum">    6383 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="6384"><span class="lineNum">    6384 </span><span class="lineNoCov">          0 : SgChar32Val* SageBuilder::buildChar32Val(unsigned int value /*= 0*/)</span></a>
<a name="6385"><span class="lineNum">    6385 </span>            : {</a>
<a name="6386"><span class="lineNum">    6386 </span><span class="lineNoCov">          0 :   SgChar32Val* result = new SgChar32Val(value, &quot;&quot;);</span></a>
<a name="6387"><span class="lineNum">    6387 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6388"><span class="lineNum">    6388 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6389"><span class="lineNum">    6389 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6390"><span class="lineNum">    6390 </span>            : }</a>
<a name="6391"><span class="lineNum">    6391 </span>            : </a>
<a name="6392"><span class="lineNum">    6392 </span><span class="lineNoCov">          0 : SgChar32Val* SageBuilder::buildChar32Val_nfi(unsigned int value, const string&amp; str)</span></a>
<a name="6393"><span class="lineNum">    6393 </span>            : {</a>
<a name="6394"><span class="lineNum">    6394 </span><span class="lineNoCov">          0 :   SgChar32Val* result = new SgChar32Val(value, str);</span></a>
<a name="6395"><span class="lineNum">    6395 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6396"><span class="lineNum">    6396 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6397"><span class="lineNum">    6397 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6398"><span class="lineNum">    6398 </span>            : }</a>
<a name="6399"><span class="lineNum">    6399 </span>            : </a>
<a name="6400"><span class="lineNum">    6400 </span>            : </a>
<a name="6401"><span class="lineNum">    6401 </span><span class="lineCov">          1 : SgComplexVal* SageBuilder::buildComplexVal(SgValueExp* real_value, SgValueExp* imaginary_value)</span></a>
<a name="6402"><span class="lineNum">    6402 </span>            : {</a>
<a name="6403"><span class="lineNum">    6403 </span><span class="lineCov">          1 :   SgComplexVal* result = new SgComplexVal(real_value,imaginary_value,imaginary_value-&gt;get_type(),&quot;&quot;);</span></a>
<a name="6404"><span class="lineNum">    6404 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6405"><span class="lineNum">    6405 </span>            : </a>
<a name="6406"><span class="lineNum">    6406 </span>            : // DQ (12/31/2008): set and test the parents</a>
<a name="6407"><span class="lineNum">    6407 </span><span class="lineCov">          1 :   if (real_value != NULL)</span></a>
<a name="6408"><span class="lineNum">    6408 </span><span class="lineCov">          1 :        real_value-&gt;set_parent(result);</span></a>
<a name="6409"><span class="lineNum">    6409 </span>            : </a>
<a name="6410"><span class="lineNum">    6410 </span><span class="lineCov">          1 :   if (imaginary_value != NULL)</span></a>
<a name="6411"><span class="lineNum">    6411 </span><span class="lineCov">          1 :        imaginary_value-&gt;set_parent(result);</span></a>
<a name="6412"><span class="lineNum">    6412 </span>            : </a>
<a name="6413"><span class="lineNum">    6413 </span><span class="lineCov">          1 :   ROSE_ASSERT(real_value == NULL || real_value-&gt;get_parent() != NULL);</span></a>
<a name="6414"><span class="lineNum">    6414 </span><span class="lineCov">          1 :   ROSE_ASSERT(imaginary_value == NULL || imaginary_value-&gt;get_parent() != NULL);</span></a>
<a name="6415"><span class="lineNum">    6415 </span>            : </a>
<a name="6416"><span class="lineNum">    6416 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6417"><span class="lineNum">    6417 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6418"><span class="lineNum">    6418 </span>            : }</a>
<a name="6419"><span class="lineNum">    6419 </span>            : </a>
<a name="6420"><span class="lineNum">    6420 </span><span class="lineNoCov">          0 : SgComplexVal* SageBuilder::buildComplexVal_nfi(SgValueExp* real_value, SgValueExp* imaginary_value, const std::string&amp; str)</span></a>
<a name="6421"><span class="lineNum">    6421 </span>            : {</a>
<a name="6422"><span class="lineNum">    6422 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(imaginary_value != NULL);</span></a>
<a name="6423"><span class="lineNum">    6423 </span><span class="lineNoCov">          0 :   SgComplexVal* result = new SgComplexVal(real_value,imaginary_value,imaginary_value-&gt;get_type(),str);</span></a>
<a name="6424"><span class="lineNum">    6424 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="6425"><span class="lineNum">    6425 </span>            : </a>
<a name="6426"><span class="lineNum">    6426 </span>            : // DQ (12/31/2008): set and test the parents</a>
<a name="6427"><span class="lineNum">    6427 </span><span class="lineNoCov">          0 :   if (real_value != NULL)</span></a>
<a name="6428"><span class="lineNum">    6428 </span><span class="lineNoCov">          0 :        real_value-&gt;set_parent(result);</span></a>
<a name="6429"><span class="lineNum">    6429 </span>            : </a>
<a name="6430"><span class="lineNum">    6430 </span><span class="lineNoCov">          0 :   if (imaginary_value != NULL)</span></a>
<a name="6431"><span class="lineNum">    6431 </span><span class="lineNoCov">          0 :        imaginary_value-&gt;set_parent(result);</span></a>
<a name="6432"><span class="lineNum">    6432 </span>            : </a>
<a name="6433"><span class="lineNum">    6433 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(real_value == NULL || real_value-&gt;get_parent() != NULL);</span></a>
<a name="6434"><span class="lineNum">    6434 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(imaginary_value == NULL || imaginary_value-&gt;get_parent() != NULL);</span></a>
<a name="6435"><span class="lineNum">    6435 </span>            : </a>
<a name="6436"><span class="lineNum">    6436 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6437"><span class="lineNum">    6437 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6438"><span class="lineNum">    6438 </span>            : }</a>
<a name="6439"><span class="lineNum">    6439 </span>            : </a>
<a name="6440"><span class="lineNum">    6440 </span><span class="lineCov">          1 : SgComplexVal* SageBuilder::buildImaginaryVal(long double imaginary_value /*= 0.0*/ )</span></a>
<a name="6441"><span class="lineNum">    6441 </span>            : {</a>
<a name="6442"><span class="lineNum">    6442 </span><span class="lineCov">          1 :   SgComplexVal* result = new SgComplexVal(NULL,buildLongDoubleVal(imaginary_value),SgTypeLongDouble::createType(),&quot;&quot;);</span></a>
<a name="6443"><span class="lineNum">    6443 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6444"><span class="lineNum">    6444 </span>            : </a>
<a name="6445"><span class="lineNum">    6445 </span>            : // DQ (12/31/2008): set and test the parents</a>
<a name="6446"><span class="lineNum">    6446 </span><span class="lineCov">          1 :   result-&gt;get_imaginary_value()-&gt;set_parent(result);</span></a>
<a name="6447"><span class="lineNum">    6447 </span><span class="lineCov">          1 :   ROSE_ASSERT(result-&gt;get_imaginary_value()-&gt;get_parent() != NULL);</span></a>
<a name="6448"><span class="lineNum">    6448 </span>            : </a>
<a name="6449"><span class="lineNum">    6449 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6450"><span class="lineNum">    6450 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6451"><span class="lineNum">    6451 </span>            : }</a>
<a name="6452"><span class="lineNum">    6452 </span>            : </a>
<a name="6453"><span class="lineNum">    6453 </span><span class="lineCov">          1 : SgComplexVal* SageBuilder::buildImaginaryVal(SgValueExp* imaginary_value)</span></a>
<a name="6454"><span class="lineNum">    6454 </span>            : {</a>
<a name="6455"><span class="lineNum">    6455 </span><span class="lineCov">          1 :   ROSE_ASSERT(imaginary_value != NULL);</span></a>
<a name="6456"><span class="lineNum">    6456 </span>            : </a>
<a name="6457"><span class="lineNum">    6457 </span><span class="lineCov">          1 :   SgComplexVal* result = new SgComplexVal(NULL,imaginary_value,imaginary_value-&gt;get_type(),&quot;&quot;);</span></a>
<a name="6458"><span class="lineNum">    6458 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6459"><span class="lineNum">    6459 </span>            : </a>
<a name="6460"><span class="lineNum">    6460 </span>            : // DQ (12/31/2008): set and test the parents</a>
<a name="6461"><span class="lineNum">    6461 </span><span class="lineCov">          1 :   imaginary_value-&gt;set_parent(result);</span></a>
<a name="6462"><span class="lineNum">    6462 </span><span class="lineCov">          1 :   ROSE_ASSERT(imaginary_value-&gt;get_parent() != NULL);</span></a>
<a name="6463"><span class="lineNum">    6463 </span>            : </a>
<a name="6464"><span class="lineNum">    6464 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6465"><span class="lineNum">    6465 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6466"><span class="lineNum">    6466 </span>            : }</a>
<a name="6467"><span class="lineNum">    6467 </span>            : </a>
<a name="6468"><span class="lineNum">    6468 </span><span class="lineCov">          1 : SgComplexVal* SageBuilder::buildImaginaryVal_nfi(SgValueExp* imaginary_value, const std::string&amp; str)</span></a>
<a name="6469"><span class="lineNum">    6469 </span>            : {</a>
<a name="6470"><span class="lineNum">    6470 </span><span class="lineCov">          1 :   ROSE_ASSERT(imaginary_value != NULL);</span></a>
<a name="6471"><span class="lineNum">    6471 </span>            : </a>
<a name="6472"><span class="lineNum">    6472 </span><span class="lineCov">          1 :   SgComplexVal* result = new SgComplexVal(NULL,imaginary_value,imaginary_value-&gt;get_type(),str);</span></a>
<a name="6473"><span class="lineNum">    6473 </span><span class="lineCov">          1 :   imaginary_value-&gt;set_parent(result);</span></a>
<a name="6474"><span class="lineNum">    6474 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6475"><span class="lineNum">    6475 </span>            : </a>
<a name="6476"><span class="lineNum">    6476 </span>            : // DQ (12/31/2008): set and test the parents</a>
<a name="6477"><span class="lineNum">    6477 </span><span class="lineCov">          1 :   ROSE_ASSERT(imaginary_value-&gt;get_parent() != NULL);</span></a>
<a name="6478"><span class="lineNum">    6478 </span>            : </a>
<a name="6479"><span class="lineNum">    6479 </span><span class="lineCov">          1 :   setOneSourcePositionNull(result);</span></a>
<a name="6480"><span class="lineNum">    6480 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6481"><span class="lineNum">    6481 </span>            : }</a>
<a name="6482"><span class="lineNum">    6482 </span>            : </a>
<a name="6483"><span class="lineNum">    6483 </span><span class="lineCov">          7 : SgDoubleVal* SageBuilder::buildDoubleVal(double t)</span></a>
<a name="6484"><span class="lineNum">    6484 </span>            : {</a>
<a name="6485"><span class="lineNum">    6485 </span><span class="lineCov">          7 :   SgDoubleVal* value = new SgDoubleVal(t,&quot;&quot;);</span></a>
<a name="6486"><span class="lineNum">    6486 </span><span class="lineCov">          7 :   ROSE_ASSERT(value);</span></a>
<a name="6487"><span class="lineNum">    6487 </span><span class="lineCov">          7 :   setOneSourcePositionForTransformation(value);</span></a>
<a name="6488"><span class="lineNum">    6488 </span><span class="lineCov">          7 :   return value;</span></a>
<a name="6489"><span class="lineNum">    6489 </span>            : }</a>
<a name="6490"><span class="lineNum">    6490 </span>            : </a>
<a name="6491"><span class="lineNum">    6491 </span><span class="lineCov">        578 : SgDoubleVal* SageBuilder::buildDoubleVal_nfi(double t, const string&amp; str)</span></a>
<a name="6492"><span class="lineNum">    6492 </span>            : {</a>
<a name="6493"><span class="lineNum">    6493 </span><span class="lineCov">        578 :   SgDoubleVal* value = new SgDoubleVal(t,str);</span></a>
<a name="6494"><span class="lineNum">    6494 </span><span class="lineCov">        578 :   ROSE_ASSERT(value);</span></a>
<a name="6495"><span class="lineNum">    6495 </span><span class="lineCov">        578 :   setOneSourcePositionNull(value);</span></a>
<a name="6496"><span class="lineNum">    6496 </span><span class="lineCov">        578 :   return value;</span></a>
<a name="6497"><span class="lineNum">    6497 </span>            : }</a>
<a name="6498"><span class="lineNum">    6498 </span>            : </a>
<a name="6499"><span class="lineNum">    6499 </span><span class="lineCov">          1 : SgFloatVal* SageBuilder::buildFloatVal(float value /*= 0.0*/)</span></a>
<a name="6500"><span class="lineNum">    6500 </span>            : {</a>
<a name="6501"><span class="lineNum">    6501 </span><span class="lineCov">          1 :   SgFloatVal* result = new SgFloatVal(value,&quot;&quot;);</span></a>
<a name="6502"><span class="lineNum">    6502 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6503"><span class="lineNum">    6503 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6504"><span class="lineNum">    6504 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6505"><span class="lineNum">    6505 </span>            : }</a>
<a name="6506"><span class="lineNum">    6506 </span>            : </a>
<a name="6507"><span class="lineNum">    6507 </span><span class="lineNoCov">          0 : SgFloatVal* SageBuilder::buildFloatVal_nfi(float value)</span></a>
<a name="6508"><span class="lineNum">    6508 </span>            : {</a>
<a name="6509"><span class="lineNum">    6509 </span><span class="lineNoCov">          0 :   SgFloatVal* result = new SgFloatVal(value,&quot;&quot;);</span></a>
<a name="6510"><span class="lineNum">    6510 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6511"><span class="lineNum">    6511 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6512"><span class="lineNum">    6512 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6513"><span class="lineNum">    6513 </span>            : }</a>
<a name="6514"><span class="lineNum">    6514 </span>            : </a>
<a name="6515"><span class="lineNum">    6515 </span><span class="lineCov">        115 : SgFloatVal* SageBuilder::buildFloatVal_nfi(float value, const string&amp; str)</span></a>
<a name="6516"><span class="lineNum">    6516 </span>            : {</a>
<a name="6517"><span class="lineNum">    6517 </span><span class="lineCov">        115 :   SgFloatVal* result = new SgFloatVal(value,str);</span></a>
<a name="6518"><span class="lineNum">    6518 </span><span class="lineCov">        115 :   ROSE_ASSERT(result);</span></a>
<a name="6519"><span class="lineNum">    6519 </span><span class="lineCov">        115 :   setOneSourcePositionNull(result);</span></a>
<a name="6520"><span class="lineNum">    6520 </span><span class="lineCov">        115 :   return result;</span></a>
<a name="6521"><span class="lineNum">    6521 </span>            : }</a>
<a name="6522"><span class="lineNum">    6522 </span>            : </a>
<a name="6523"><span class="lineNum">    6523 </span><span class="lineNoCov">          0 : SgFloatVal* SageBuilder::buildFloatVal_nfi(const string&amp; str)</span></a>
<a name="6524"><span class="lineNum">    6524 </span>            : {</a>
<a name="6525"><span class="lineNum">    6525 </span>            :   // C++11 please [CR 2020.02.25]</a>
<a name="6526"><span class="lineNum">    6526 </span>            :   // return buildFloatVal_nfi(std::stof(str), str);</a>
<a name="6527"><span class="lineNum">    6527 </span><span class="lineNoCov">          0 :      return buildFloatVal_nfi(atof(str.c_str()), str);</span></a>
<a name="6528"><span class="lineNum">    6528 </span>            : }</a>
<a name="6529"><span class="lineNum">    6529 </span>            : </a>
<a name="6530"><span class="lineNum">    6530 </span><span class="lineCov">       1098 : SgIntVal* SageBuilder::buildIntVal(int value)</span></a>
<a name="6531"><span class="lineNum">    6531 </span>            :    {</a>
<a name="6532"><span class="lineNum">    6532 </span><span class="lineCov">       1098 :      SgIntVal* intValue= new SgIntVal(value,&quot;&quot;);</span></a>
<a name="6533"><span class="lineNum">    6533 </span><span class="lineCov">       1098 :      ROSE_ASSERT(intValue);</span></a>
<a name="6534"><span class="lineNum">    6534 </span><span class="lineCov">       1098 :      setOneSourcePositionForTransformation(intValue);</span></a>
<a name="6535"><span class="lineNum">    6535 </span><span class="lineCov">       1098 :      return intValue;</span></a>
<a name="6536"><span class="lineNum">    6536 </span>            :    }</a>
<a name="6537"><span class="lineNum">    6537 </span>            : </a>
<a name="6538"><span class="lineNum">    6538 </span><span class="lineCov">          1 : SgIntVal* SageBuilder::buildIntValHex(int value)</span></a>
<a name="6539"><span class="lineNum">    6539 </span>            :    {</a>
<a name="6540"><span class="lineNum">    6540 </span><span class="lineCov">          1 :      SgIntVal* intValue= new SgIntVal(value, (value &gt;= 0 ? StringUtility::intToHex((unsigned int)value) : &quot;-&quot; + StringUtility::intToHex((unsigned int)(-value))));</span></a>
<a name="6541"><span class="lineNum">    6541 </span><span class="lineCov">          1 :      ROSE_ASSERT(intValue);</span></a>
<a name="6542"><span class="lineNum">    6542 </span><span class="lineCov">          1 :      setOneSourcePositionForTransformation(intValue);</span></a>
<a name="6543"><span class="lineNum">    6543 </span><span class="lineCov">          1 :      return intValue;</span></a>
<a name="6544"><span class="lineNum">    6544 </span>            :    }</a>
<a name="6545"><span class="lineNum">    6545 </span>            : </a>
<a name="6546"><span class="lineNum">    6546 </span><span class="lineNoCov">          0 : SgIntVal* SageBuilder::buildIntVal_nfi(int value)</span></a>
<a name="6547"><span class="lineNum">    6547 </span>            :    {</a>
<a name="6548"><span class="lineNum">    6548 </span><span class="lineNoCov">          0 :      SgIntVal* intValue = new SgIntVal(value,&quot;&quot;);</span></a>
<a name="6549"><span class="lineNum">    6549 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(intValue);</span></a>
<a name="6550"><span class="lineNum">    6550 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(intValue);</span></a>
<a name="6551"><span class="lineNum">    6551 </span><span class="lineNoCov">          0 :      return intValue;</span></a>
<a name="6552"><span class="lineNum">    6552 </span>            :    }</a>
<a name="6553"><span class="lineNum">    6553 </span>            : </a>
<a name="6554"><span class="lineNum">    6554 </span><span class="lineCov">      27645 : SgIntVal* SageBuilder::buildIntVal_nfi(int value, const string&amp; str)</span></a>
<a name="6555"><span class="lineNum">    6555 </span>            :    {</a>
<a name="6556"><span class="lineNum">    6556 </span><span class="lineCov">      27645 :      SgIntVal* intValue = new SgIntVal(value,str);</span></a>
<a name="6557"><span class="lineNum">    6557 </span><span class="lineCov">      27645 :      ROSE_ASSERT(intValue);</span></a>
<a name="6558"><span class="lineNum">    6558 </span><span class="lineCov">      27645 :      setOneSourcePositionNull(intValue);</span></a>
<a name="6559"><span class="lineNum">    6559 </span><span class="lineCov">      27645 :      return intValue;</span></a>
<a name="6560"><span class="lineNum">    6560 </span>            :    }</a>
<a name="6561"><span class="lineNum">    6561 </span>            : </a>
<a name="6562"><span class="lineNum">    6562 </span><span class="lineNoCov">          0 : SgIntVal* SageBuilder::buildIntVal_nfi(const string&amp; str)</span></a>
<a name="6563"><span class="lineNum">    6563 </span>            :    {</a>
<a name="6564"><span class="lineNum">    6564 </span>            :   // C++11 please [CR 2020.02.25]</a>
<a name="6565"><span class="lineNum">    6565 </span>            :   // return buildIntVal_nfi(std::stoi(str), str);</a>
<a name="6566"><span class="lineNum">    6566 </span><span class="lineNoCov">          0 :      return buildIntVal_nfi(atoi(str.c_str()), str);</span></a>
<a name="6567"><span class="lineNum">    6567 </span>            :    }</a>
<a name="6568"><span class="lineNum">    6568 </span>            : </a>
<a name="6569"><span class="lineNum">    6569 </span><span class="lineNoCov">          0 : SgLongIntVal* SageBuilder::buildLongIntVal(long value)</span></a>
<a name="6570"><span class="lineNum">    6570 </span>            : {</a>
<a name="6571"><span class="lineNum">    6571 </span><span class="lineNoCov">          0 :   SgLongIntVal* intValue= new SgLongIntVal(value,&quot;&quot;);</span></a>
<a name="6572"><span class="lineNum">    6572 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(intValue);</span></a>
<a name="6573"><span class="lineNum">    6573 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(intValue);</span></a>
<a name="6574"><span class="lineNum">    6574 </span><span class="lineNoCov">          0 :   return intValue;</span></a>
<a name="6575"><span class="lineNum">    6575 </span>            : }</a>
<a name="6576"><span class="lineNum">    6576 </span>            : </a>
<a name="6577"><span class="lineNum">    6577 </span><span class="lineCov">       1927 : SgLongIntVal* SageBuilder::buildLongIntVal_nfi(long value, const string&amp; str)</span></a>
<a name="6578"><span class="lineNum">    6578 </span>            : {</a>
<a name="6579"><span class="lineNum">    6579 </span><span class="lineCov">       1927 :   SgLongIntVal* intValue= new SgLongIntVal(value,str);</span></a>
<a name="6580"><span class="lineNum">    6580 </span><span class="lineCov">       1927 :   ROSE_ASSERT(intValue);</span></a>
<a name="6581"><span class="lineNum">    6581 </span><span class="lineCov">       1927 :   setOneSourcePositionNull(intValue);</span></a>
<a name="6582"><span class="lineNum">    6582 </span><span class="lineCov">       1927 :   return intValue;</span></a>
<a name="6583"><span class="lineNum">    6583 </span>            : }</a>
<a name="6584"><span class="lineNum">    6584 </span>            : </a>
<a name="6585"><span class="lineNum">    6585 </span><span class="lineCov">          1 : SgLongLongIntVal* SageBuilder::buildLongLongIntVal(long long value)</span></a>
<a name="6586"><span class="lineNum">    6586 </span>            : {</a>
<a name="6587"><span class="lineNum">    6587 </span><span class="lineCov">          1 :   SgLongLongIntVal* intValue= new SgLongLongIntVal(value,&quot;&quot;);</span></a>
<a name="6588"><span class="lineNum">    6588 </span><span class="lineCov">          1 :   ROSE_ASSERT(intValue);</span></a>
<a name="6589"><span class="lineNum">    6589 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(intValue);</span></a>
<a name="6590"><span class="lineNum">    6590 </span><span class="lineCov">          1 :   return intValue;</span></a>
<a name="6591"><span class="lineNum">    6591 </span>            : }</a>
<a name="6592"><span class="lineNum">    6592 </span>            : </a>
<a name="6593"><span class="lineNum">    6593 </span><span class="lineCov">         46 : SgLongLongIntVal* SageBuilder::buildLongLongIntVal_nfi(long long value, const string&amp; str)</span></a>
<a name="6594"><span class="lineNum">    6594 </span>            : {</a>
<a name="6595"><span class="lineNum">    6595 </span><span class="lineCov">         46 :   SgLongLongIntVal* intValue= new SgLongLongIntVal(value,str);</span></a>
<a name="6596"><span class="lineNum">    6596 </span><span class="lineCov">         46 :   ROSE_ASSERT(intValue);</span></a>
<a name="6597"><span class="lineNum">    6597 </span><span class="lineCov">         46 :   setOneSourcePositionNull(intValue);</span></a>
<a name="6598"><span class="lineNum">    6598 </span><span class="lineCov">         46 :   return intValue;</span></a>
<a name="6599"><span class="lineNum">    6599 </span>            : }</a>
<a name="6600"><span class="lineNum">    6600 </span>            : </a>
<a name="6601"><span class="lineNum">    6601 </span><span class="lineNoCov">          0 : SgEnumVal* SageBuilder::buildEnumVal(long long int value, SgEnumDeclaration* decl, SgName name)</span></a>
<a name="6602"><span class="lineNum">    6602 </span>            :    {</a>
<a name="6603"><span class="lineNum">    6603 </span><span class="lineNoCov">          0 :      SgEnumVal* enumVal= new SgEnumVal(value,decl,name);</span></a>
<a name="6604"><span class="lineNum">    6604 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(enumVal != NULL);</span></a>
<a name="6605"><span class="lineNum">    6605 </span>            : </a>
<a name="6606"><span class="lineNum">    6606 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(enumVal);</span></a>
<a name="6607"><span class="lineNum">    6607 </span><span class="lineNoCov">          0 :      return enumVal;</span></a>
<a name="6608"><span class="lineNum">    6608 </span>            :    }</a>
<a name="6609"><span class="lineNum">    6609 </span>            : </a>
<a name="6610"><span class="lineNum">    6610 </span>            : </a>
<a name="6611"><span class="lineNum">    6611 </span><span class="lineCov">      12124 : SgEnumVal* SageBuilder::buildEnumVal_nfi(long long int value, SgEnumDeclaration* decl, SgName name)</span></a>
<a name="6612"><span class="lineNum">    6612 </span>            :    {</a>
<a name="6613"><span class="lineNum">    6613 </span><span class="lineCov">      12124 :      SgEnumVal* enumVal= new SgEnumVal(value,decl,name);</span></a>
<a name="6614"><span class="lineNum">    6614 </span><span class="lineCov">      12124 :      ROSE_ASSERT(enumVal != NULL);</span></a>
<a name="6615"><span class="lineNum">    6615 </span>            : </a>
<a name="6616"><span class="lineNum">    6616 </span><span class="lineCov">      12124 :      setOneSourcePositionNull(enumVal);</span></a>
<a name="6617"><span class="lineNum">    6617 </span>            : </a>
<a name="6618"><span class="lineNum">    6618 </span>            : #if 0</a>
<a name="6619"><span class="lineNum">    6619 </span>            :   // DQ (6/10/2012): This is moved, but perhaps it really should be here!</a>
<a name="6620"><span class="lineNum">    6620 </span>            :      printf (&quot;In buildEnumVal_nfi(): We need to add the enum value to the symbol table in the scope of the SgEnumDeclaration (name = %s) \n&quot;,name.str());</a>
<a name="6621"><span class="lineNum">    6621 </span>            : </a>
<a name="6622"><span class="lineNum">    6622 </span>            :   // DQ (6/10/2012): We need to add the enum field value to the correct symbol table.</a>
<a name="6623"><span class="lineNum">    6623 </span>            :      SgScopeStatement* scope = decl-&gt;get_scope();</a>
<a name="6624"><span class="lineNum">    6624 </span>            :      ROSE_ASSERT(scope != NULL);</a>
<a name="6625"><span class="lineNum">    6625 </span>            : </a>
<a name="6626"><span class="lineNum">    6626 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="6627"><span class="lineNum">    6627 </span>            : </a>
<a name="6628"><span class="lineNum">    6628 </span>            :      SgEnumFieldSymbol* enumFieldSymbol = scope-&gt;lookup_enum_field_symbol(name);</a>
<a name="6629"><span class="lineNum">    6629 </span>            :      ROSE_ASSERT(enumFieldSymbol == NULL);</a>
<a name="6630"><span class="lineNum">    6630 </span>            :      if (enumFieldSymbol == NULL)</a>
<a name="6631"><span class="lineNum">    6631 </span>            :         {</a>
<a name="6632"><span class="lineNum">    6632 </span>            :           SgEnumType* enumType = new SgEnumType(decl);</a>
<a name="6633"><span class="lineNum">    6633 </span>            :           ROSE_ASSERT(enumType != NULL);</a>
<a name="6634"><span class="lineNum">    6634 </span>            : </a>
<a name="6635"><span class="lineNum">    6635 </span>            :           printf (&quot;In buildEnumVal_nfi(): Building a SgInitializedName for enum field \n&quot;);</a>
<a name="6636"><span class="lineNum">    6636 </span>            : </a>
<a name="6637"><span class="lineNum">    6637 </span>            :           SgInitializedName* initializedName = buildInitializedName(name,enumType);</a>
<a name="6638"><span class="lineNum">    6638 </span>            :           ROSE_ASSERT(initializedName != NULL);</a>
<a name="6639"><span class="lineNum">    6639 </span>            : </a>
<a name="6640"><span class="lineNum">    6640 </span>            :           initializedName-&gt;set_declptr(decl);</a>
<a name="6641"><span class="lineNum">    6641 </span>            :           initializedName-&gt;set_scope(scope);</a>
<a name="6642"><span class="lineNum">    6642 </span>            : </a>
<a name="6643"><span class="lineNum">    6643 </span>            :           enumFieldSymbol = new SgEnumFieldSymbol(initializedName);</a>
<a name="6644"><span class="lineNum">    6644 </span>            :         }</a>
<a name="6645"><span class="lineNum">    6645 </span>            : </a>
<a name="6646"><span class="lineNum">    6646 </span>            :      ROSE_ASSERT(enumFieldSymbol != NULL);</a>
<a name="6647"><span class="lineNum">    6647 </span>            : </a>
<a name="6648"><span class="lineNum">    6648 </span>            :      scope-&gt;insert_symbol(name,enumFieldSymbol);</a>
<a name="6649"><span class="lineNum">    6649 </span>            : #endif</a>
<a name="6650"><span class="lineNum">    6650 </span>            : </a>
<a name="6651"><span class="lineNum">    6651 </span><span class="lineCov">      12124 :      return enumVal;</span></a>
<a name="6652"><span class="lineNum">    6652 </span>            :    }</a>
<a name="6653"><span class="lineNum">    6653 </span>            : </a>
<a name="6654"><span class="lineNum">    6654 </span><span class="lineNoCov">          0 : SgEnumVal* SageBuilder::buildEnumVal(SgEnumFieldSymbol * sym) {</span></a>
<a name="6655"><span class="lineNum">    6655 </span><span class="lineNoCov">          0 :   SgInitializedName * init_name = sym-&gt;get_declaration();</span></a>
<a name="6656"><span class="lineNum">    6656 </span><span class="lineNoCov">          0 :   assert(init_name != NULL);</span></a>
<a name="6657"><span class="lineNum">    6657 </span><span class="lineNoCov">          0 :   SgAssignInitializer * assign_init = isSgAssignInitializer(init_name-&gt;get_initptr());</span></a>
<a name="6658"><span class="lineNum">    6658 </span><span class="lineNoCov">          0 :   assert(assign_init != NULL);</span></a>
<a name="6659"><span class="lineNum">    6659 </span><span class="lineNoCov">          0 :   SgEnumVal * enum_val = isSgEnumVal(assign_init-&gt;get_operand_i());</span></a>
<a name="6660"><span class="lineNum">    6660 </span><span class="lineNoCov">          0 :   assert(enum_val != NULL);</span></a>
<a name="6661"><span class="lineNum">    6661 </span><span class="lineNoCov">          0 :   enum_val = isSgEnumVal(SageInterface::copyExpression(enum_val));</span></a>
<a name="6662"><span class="lineNum">    6662 </span><span class="lineNoCov">          0 :   return enum_val;</span></a>
<a name="6663"><span class="lineNum">    6663 </span>            : }</a>
<a name="6664"><span class="lineNum">    6664 </span>            : </a>
<a name="6665"><span class="lineNum">    6665 </span><span class="lineCov">          1 : SgLongDoubleVal* SageBuilder::buildLongDoubleVal(long double value /*= 0.0*/)</span></a>
<a name="6666"><span class="lineNum">    6666 </span>            : {</a>
<a name="6667"><span class="lineNum">    6667 </span><span class="lineCov">          1 :   SgLongDoubleVal* result = new SgLongDoubleVal(value,&quot;&quot;);</span></a>
<a name="6668"><span class="lineNum">    6668 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6669"><span class="lineNum">    6669 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6670"><span class="lineNum">    6670 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6671"><span class="lineNum">    6671 </span>            : }</a>
<a name="6672"><span class="lineNum">    6672 </span>            : </a>
<a name="6673"><span class="lineNum">    6673 </span><span class="lineCov">         32 : SgLongDoubleVal* SageBuilder::buildLongDoubleVal_nfi(long double value, const string&amp; str)</span></a>
<a name="6674"><span class="lineNum">    6674 </span>            : {</a>
<a name="6675"><span class="lineNum">    6675 </span><span class="lineCov">         32 :   SgLongDoubleVal* result = new SgLongDoubleVal(value,str);</span></a>
<a name="6676"><span class="lineNum">    6676 </span><span class="lineCov">         32 :   ROSE_ASSERT(result);</span></a>
<a name="6677"><span class="lineNum">    6677 </span><span class="lineCov">         32 :   setOneSourcePositionNull(result);</span></a>
<a name="6678"><span class="lineNum">    6678 </span><span class="lineCov">         32 :   return result;</span></a>
<a name="6679"><span class="lineNum">    6679 </span>            : }</a>
<a name="6680"><span class="lineNum">    6680 </span>            : </a>
<a name="6681"><span class="lineNum">    6681 </span><span class="lineNoCov">          0 : SgFloat80Val* SageBuilder::buildFloat80Val(long double value /*= 0.0*/)</span></a>
<a name="6682"><span class="lineNum">    6682 </span>            : {</a>
<a name="6683"><span class="lineNum">    6683 </span><span class="lineNoCov">          0 :   SgFloat80Val* result = new SgFloat80Val(value,&quot;&quot;);</span></a>
<a name="6684"><span class="lineNum">    6684 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6685"><span class="lineNum">    6685 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6686"><span class="lineNum">    6686 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6687"><span class="lineNum">    6687 </span>            : }</a>
<a name="6688"><span class="lineNum">    6688 </span>            : </a>
<a name="6689"><span class="lineNum">    6689 </span><span class="lineNoCov">          0 : SgFloat80Val* SageBuilder::buildFloat80Val_nfi(long double value, const string&amp; str)</span></a>
<a name="6690"><span class="lineNum">    6690 </span>            : {</a>
<a name="6691"><span class="lineNum">    6691 </span><span class="lineNoCov">          0 :   SgFloat80Val* result = new SgFloat80Val(value,str);</span></a>
<a name="6692"><span class="lineNum">    6692 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6693"><span class="lineNum">    6693 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6694"><span class="lineNum">    6694 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6695"><span class="lineNum">    6695 </span>            : }</a>
<a name="6696"><span class="lineNum">    6696 </span>            : </a>
<a name="6697"><span class="lineNum">    6697 </span><span class="lineNoCov">          0 : SgFloat128Val* SageBuilder::buildFloat128Val(long double value /*= 0.0*/)</span></a>
<a name="6698"><span class="lineNum">    6698 </span>            : {</a>
<a name="6699"><span class="lineNum">    6699 </span><span class="lineNoCov">          0 :   SgFloat128Val* result = new SgFloat128Val(value,&quot;&quot;);</span></a>
<a name="6700"><span class="lineNum">    6700 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6701"><span class="lineNum">    6701 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6702"><span class="lineNum">    6702 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6703"><span class="lineNum">    6703 </span>            : }</a>
<a name="6704"><span class="lineNum">    6704 </span>            : </a>
<a name="6705"><span class="lineNum">    6705 </span><span class="lineNoCov">          0 : SgFloat128Val* SageBuilder::buildFloat128Val_nfi(long double value, const string&amp; str)</span></a>
<a name="6706"><span class="lineNum">    6706 </span>            : {</a>
<a name="6707"><span class="lineNum">    6707 </span><span class="lineNoCov">          0 :   SgFloat128Val* result = new SgFloat128Val(value,str);</span></a>
<a name="6708"><span class="lineNum">    6708 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6709"><span class="lineNum">    6709 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6710"><span class="lineNum">    6710 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6711"><span class="lineNum">    6711 </span>            : }</a>
<a name="6712"><span class="lineNum">    6712 </span>            : </a>
<a name="6713"><span class="lineNum">    6713 </span><span class="lineNoCov">          0 : SgStringVal* SageBuilder::buildStringVal(std::string value /*=&quot;&quot;*/)</span></a>
<a name="6714"><span class="lineNum">    6714 </span>            : {</a>
<a name="6715"><span class="lineNum">    6715 </span><span class="lineNoCov">          0 :   SgStringVal* result = new SgStringVal(value);</span></a>
<a name="6716"><span class="lineNum">    6716 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6717"><span class="lineNum">    6717 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6718"><span class="lineNum">    6718 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6719"><span class="lineNum">    6719 </span>            : }</a>
<a name="6720"><span class="lineNum">    6720 </span>            : </a>
<a name="6721"><span class="lineNum">    6721 </span><span class="lineCov">       1518 : SgStringVal* SageBuilder::buildStringVal_nfi(std::string value)</span></a>
<a name="6722"><span class="lineNum">    6722 </span>            : {</a>
<a name="6723"><span class="lineNum">    6723 </span><span class="lineCov">       1518 :   SgStringVal* result = new SgStringVal(value);</span></a>
<a name="6724"><span class="lineNum">    6724 </span><span class="lineCov">       1518 :   ROSE_ASSERT(result);</span></a>
<a name="6725"><span class="lineNum">    6725 </span><span class="lineCov">       1518 :   setOneSourcePositionNull(result);</span></a>
<a name="6726"><span class="lineNum">    6726 </span><span class="lineCov">       1518 :   return result;</span></a>
<a name="6727"><span class="lineNum">    6727 </span>            : }</a>
<a name="6728"><span class="lineNum">    6728 </span>            : </a>
<a name="6729"><span class="lineNum">    6729 </span><span class="lineCov">          1 : SgUnsignedCharVal* SageBuilder::buildUnsignedCharVal(unsigned char v)</span></a>
<a name="6730"><span class="lineNum">    6730 </span>            : {</a>
<a name="6731"><span class="lineNum">    6731 </span><span class="lineCov">          1 :   SgUnsignedCharVal* result = new SgUnsignedCharVal(v,&quot;&quot;);</span></a>
<a name="6732"><span class="lineNum">    6732 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6733"><span class="lineNum">    6733 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6734"><span class="lineNum">    6734 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6735"><span class="lineNum">    6735 </span>            : }</a>
<a name="6736"><span class="lineNum">    6736 </span>            : </a>
<a name="6737"><span class="lineNum">    6737 </span><span class="lineCov">          1 : SgUnsignedCharVal* SageBuilder::buildUnsignedCharValHex(unsigned char v)</span></a>
<a name="6738"><span class="lineNum">    6738 </span>            : {</a>
<a name="6739"><span class="lineNum">    6739 </span><span class="lineCov">          1 :   SgUnsignedCharVal* result = new SgUnsignedCharVal(v,StringUtility::intToHex(v));</span></a>
<a name="6740"><span class="lineNum">    6740 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6741"><span class="lineNum">    6741 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6742"><span class="lineNum">    6742 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6743"><span class="lineNum">    6743 </span>            : }</a>
<a name="6744"><span class="lineNum">    6744 </span>            : </a>
<a name="6745"><span class="lineNum">    6745 </span><span class="lineNoCov">          0 : SgUnsignedCharVal* SageBuilder::buildUnsignedCharVal_nfi(unsigned char v, const string&amp; str)</span></a>
<a name="6746"><span class="lineNum">    6746 </span>            : {</a>
<a name="6747"><span class="lineNum">    6747 </span><span class="lineNoCov">          0 :   SgUnsignedCharVal* result = new SgUnsignedCharVal(v,str);</span></a>
<a name="6748"><span class="lineNum">    6748 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6749"><span class="lineNum">    6749 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6750"><span class="lineNum">    6750 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6751"><span class="lineNum">    6751 </span>            : }</a>
<a name="6752"><span class="lineNum">    6752 </span>            : </a>
<a name="6753"><span class="lineNum">    6753 </span><span class="lineCov">          1 : SgShortVal* SageBuilder::buildShortVal(short v)</span></a>
<a name="6754"><span class="lineNum">    6754 </span>            : {</a>
<a name="6755"><span class="lineNum">    6755 </span><span class="lineCov">          1 :   SgShortVal* result = new SgShortVal(v,&quot;&quot;);</span></a>
<a name="6756"><span class="lineNum">    6756 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6757"><span class="lineNum">    6757 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6758"><span class="lineNum">    6758 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6759"><span class="lineNum">    6759 </span>            : }</a>
<a name="6760"><span class="lineNum">    6760 </span>            : </a>
<a name="6761"><span class="lineNum">    6761 </span><span class="lineCov">          1 : SgShortVal* SageBuilder::buildShortValHex(short v)</span></a>
<a name="6762"><span class="lineNum">    6762 </span>            : {</a>
<a name="6763"><span class="lineNum">    6763 </span><span class="lineCov">          1 :   SgShortVal* result = new SgShortVal(v, (v &gt;= 0 ? StringUtility::intToHex((unsigned int)v) : &quot;-&quot; + StringUtility::intToHex((unsigned int)(-v))));</span></a>
<a name="6764"><span class="lineNum">    6764 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6765"><span class="lineNum">    6765 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6766"><span class="lineNum">    6766 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6767"><span class="lineNum">    6767 </span>            : }</a>
<a name="6768"><span class="lineNum">    6768 </span>            : </a>
<a name="6769"><span class="lineNum">    6769 </span><span class="lineCov">         33 : SgShortVal* SageBuilder::buildShortVal_nfi(short v, const string&amp; str)</span></a>
<a name="6770"><span class="lineNum">    6770 </span>            : {</a>
<a name="6771"><span class="lineNum">    6771 </span><span class="lineCov">         33 :   SgShortVal* result = new SgShortVal(v,str);</span></a>
<a name="6772"><span class="lineNum">    6772 </span><span class="lineCov">         33 :   ROSE_ASSERT(result);</span></a>
<a name="6773"><span class="lineNum">    6773 </span><span class="lineCov">         33 :   setOneSourcePositionNull(result);</span></a>
<a name="6774"><span class="lineNum">    6774 </span><span class="lineCov">         33 :   return result;</span></a>
<a name="6775"><span class="lineNum">    6775 </span>            : }</a>
<a name="6776"><span class="lineNum">    6776 </span>            : </a>
<a name="6777"><span class="lineNum">    6777 </span><span class="lineCov">          1 : SgUnsignedShortVal* SageBuilder::buildUnsignedShortVal(unsigned short v)</span></a>
<a name="6778"><span class="lineNum">    6778 </span>            : {</a>
<a name="6779"><span class="lineNum">    6779 </span><span class="lineCov">          1 :   SgUnsignedShortVal* result = new SgUnsignedShortVal(v,&quot;&quot;);</span></a>
<a name="6780"><span class="lineNum">    6780 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6781"><span class="lineNum">    6781 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6782"><span class="lineNum">    6782 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6783"><span class="lineNum">    6783 </span>            : }</a>
<a name="6784"><span class="lineNum">    6784 </span>            : </a>
<a name="6785"><span class="lineNum">    6785 </span><span class="lineCov">          1 : SgUnsignedShortVal* SageBuilder::buildUnsignedShortValHex(unsigned short v)</span></a>
<a name="6786"><span class="lineNum">    6786 </span>            : {</a>
<a name="6787"><span class="lineNum">    6787 </span><span class="lineCov">          1 :   SgUnsignedShortVal* result = new SgUnsignedShortVal(v,StringUtility::intToHex(v));</span></a>
<a name="6788"><span class="lineNum">    6788 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6789"><span class="lineNum">    6789 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6790"><span class="lineNum">    6790 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6791"><span class="lineNum">    6791 </span>            : }</a>
<a name="6792"><span class="lineNum">    6792 </span>            : </a>
<a name="6793"><span class="lineNum">    6793 </span><span class="lineCov">        217 : SgUnsignedShortVal* SageBuilder::buildUnsignedShortVal_nfi(unsigned short v, const string&amp; str)</span></a>
<a name="6794"><span class="lineNum">    6794 </span>            : {</a>
<a name="6795"><span class="lineNum">    6795 </span><span class="lineCov">        217 :   SgUnsignedShortVal* result = new SgUnsignedShortVal(v,str);</span></a>
<a name="6796"><span class="lineNum">    6796 </span><span class="lineCov">        217 :   ROSE_ASSERT(result);</span></a>
<a name="6797"><span class="lineNum">    6797 </span><span class="lineCov">        217 :   setOneSourcePositionNull(result);</span></a>
<a name="6798"><span class="lineNum">    6798 </span><span class="lineCov">        217 :   return result;</span></a>
<a name="6799"><span class="lineNum">    6799 </span>            : }</a>
<a name="6800"><span class="lineNum">    6800 </span>            : </a>
<a name="6801"><span class="lineNum">    6801 </span><span class="lineCov">          1 : SgUnsignedIntVal* SageBuilder::buildUnsignedIntVal(unsigned int v)</span></a>
<a name="6802"><span class="lineNum">    6802 </span>            : {</a>
<a name="6803"><span class="lineNum">    6803 </span><span class="lineCov">          1 :   SgUnsignedIntVal* result = new SgUnsignedIntVal(v,&quot;&quot;);</span></a>
<a name="6804"><span class="lineNum">    6804 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6805"><span class="lineNum">    6805 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6806"><span class="lineNum">    6806 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6807"><span class="lineNum">    6807 </span>            : }</a>
<a name="6808"><span class="lineNum">    6808 </span>            : </a>
<a name="6809"><span class="lineNum">    6809 </span><span class="lineCov">          1 : SgUnsignedIntVal* SageBuilder::buildUnsignedIntValHex(unsigned int v)</span></a>
<a name="6810"><span class="lineNum">    6810 </span>            : {</a>
<a name="6811"><span class="lineNum">    6811 </span><span class="lineCov">          1 :   SgUnsignedIntVal* result = new SgUnsignedIntVal(v,StringUtility::intToHex(v) + &quot;U&quot;);</span></a>
<a name="6812"><span class="lineNum">    6812 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6813"><span class="lineNum">    6813 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6814"><span class="lineNum">    6814 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6815"><span class="lineNum">    6815 </span>            : }</a>
<a name="6816"><span class="lineNum">    6816 </span>            : </a>
<a name="6817"><span class="lineNum">    6817 </span><span class="lineCov">        249 : SgUnsignedIntVal* SageBuilder::buildUnsignedIntVal_nfi(unsigned int v, const string&amp; str)</span></a>
<a name="6818"><span class="lineNum">    6818 </span>            : {</a>
<a name="6819"><span class="lineNum">    6819 </span><span class="lineCov">        249 :   SgUnsignedIntVal* result = new SgUnsignedIntVal(v,str);</span></a>
<a name="6820"><span class="lineNum">    6820 </span><span class="lineCov">        249 :   ROSE_ASSERT(result);</span></a>
<a name="6821"><span class="lineNum">    6821 </span><span class="lineCov">        249 :   setOneSourcePositionNull(result);</span></a>
<a name="6822"><span class="lineNum">    6822 </span><span class="lineCov">        249 :   return result;</span></a>
<a name="6823"><span class="lineNum">    6823 </span>            : }</a>
<a name="6824"><span class="lineNum">    6824 </span>            : </a>
<a name="6825"><span class="lineNum">    6825 </span><span class="lineNoCov">          0 : SgUnsignedLongVal* SageBuilder::buildUnsignedLongVal(unsigned long v)</span></a>
<a name="6826"><span class="lineNum">    6826 </span>            : {</a>
<a name="6827"><span class="lineNum">    6827 </span><span class="lineNoCov">          0 :   SgUnsignedLongVal* result = new SgUnsignedLongVal(v,&quot;&quot;);</span></a>
<a name="6828"><span class="lineNum">    6828 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6829"><span class="lineNum">    6829 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6830"><span class="lineNum">    6830 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6831"><span class="lineNum">    6831 </span>            : }</a>
<a name="6832"><span class="lineNum">    6832 </span>            : </a>
<a name="6833"><span class="lineNum">    6833 </span><span class="lineCov">          1 : SgUnsignedLongVal* SageBuilder::buildUnsignedLongValHex(unsigned long v)</span></a>
<a name="6834"><span class="lineNum">    6834 </span>            : {</a>
<a name="6835"><span class="lineNum">    6835 </span><span class="lineCov">          1 :   SgUnsignedLongVal* result = new SgUnsignedLongVal(v,StringUtility::intToHex(v) + &quot;UL&quot;);</span></a>
<a name="6836"><span class="lineNum">    6836 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6837"><span class="lineNum">    6837 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6838"><span class="lineNum">    6838 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6839"><span class="lineNum">    6839 </span>            : }</a>
<a name="6840"><span class="lineNum">    6840 </span>            : </a>
<a name="6841"><span class="lineNum">    6841 </span><span class="lineCov">       7863 : SgUnsignedLongVal* SageBuilder::buildUnsignedLongVal_nfi(unsigned long v, const string&amp; str)</span></a>
<a name="6842"><span class="lineNum">    6842 </span>            : {</a>
<a name="6843"><span class="lineNum">    6843 </span><span class="lineCov">       7863 :   SgUnsignedLongVal* result = new SgUnsignedLongVal(v,str);</span></a>
<a name="6844"><span class="lineNum">    6844 </span><span class="lineCov">       7863 :   ROSE_ASSERT(result);</span></a>
<a name="6845"><span class="lineNum">    6845 </span><span class="lineCov">       7863 :   setOneSourcePositionNull(result);</span></a>
<a name="6846"><span class="lineNum">    6846 </span><span class="lineCov">       7863 :   return result;</span></a>
<a name="6847"><span class="lineNum">    6847 </span>            : }</a>
<a name="6848"><span class="lineNum">    6848 </span>            : </a>
<a name="6849"><span class="lineNum">    6849 </span><span class="lineCov">          1 : SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntVal(unsigned long long v)</span></a>
<a name="6850"><span class="lineNum">    6850 </span>            : {</a>
<a name="6851"><span class="lineNum">    6851 </span><span class="lineCov">          1 :   SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,&quot;&quot;);</span></a>
<a name="6852"><span class="lineNum">    6852 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6853"><span class="lineNum">    6853 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6854"><span class="lineNum">    6854 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6855"><span class="lineNum">    6855 </span>            : }</a>
<a name="6856"><span class="lineNum">    6856 </span>            : </a>
<a name="6857"><span class="lineNum">    6857 </span><span class="lineCov">          1 : SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntValHex(unsigned long long v)</span></a>
<a name="6858"><span class="lineNum">    6858 </span>            : {</a>
<a name="6859"><span class="lineNum">    6859 </span><span class="lineCov">          1 :   SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,StringUtility::intToHex(v) + &quot;ULL&quot;);</span></a>
<a name="6860"><span class="lineNum">    6860 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="6861"><span class="lineNum">    6861 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6862"><span class="lineNum">    6862 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6863"><span class="lineNum">    6863 </span>            : }</a>
<a name="6864"><span class="lineNum">    6864 </span>            : </a>
<a name="6865"><span class="lineNum">    6865 </span><span class="lineCov">         33 : SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntVal_nfi(unsigned long long v, const string&amp; str)</span></a>
<a name="6866"><span class="lineNum">    6866 </span>            : {</a>
<a name="6867"><span class="lineNum">    6867 </span><span class="lineCov">         33 :   SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,str);</span></a>
<a name="6868"><span class="lineNum">    6868 </span><span class="lineCov">         33 :   ROSE_ASSERT(result);</span></a>
<a name="6869"><span class="lineNum">    6869 </span><span class="lineCov">         33 :   setOneSourcePositionNull(result);</span></a>
<a name="6870"><span class="lineNum">    6870 </span><span class="lineCov">         33 :   return result;</span></a>
<a name="6871"><span class="lineNum">    6871 </span>            : }</a>
<a name="6872"><span class="lineNum">    6872 </span>            : </a>
<a name="6873"><span class="lineNum">    6873 </span><span class="lineNoCov">          0 : SgTemplateType* SageBuilder::buildTemplateType(SgName name/* =&quot;&quot; */)</span></a>
<a name="6874"><span class="lineNum">    6874 </span>            : {</a>
<a name="6875"><span class="lineNum">    6875 </span><span class="lineNoCov">          0 :   SgTemplateType* result = new SgTemplateType (name);</span></a>
<a name="6876"><span class="lineNum">    6876 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (result);</span></a>
<a name="6877"><span class="lineNum">    6877 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6878"><span class="lineNum">    6878 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6879"><span class="lineNum">    6879 </span>            : }</a>
<a name="6880"><span class="lineNum">    6880 </span>            : </a>
<a name="6881"><span class="lineNum">    6881 </span><span class="lineCov">          1 : SgTemplateParameter * SageBuilder::buildTemplateParameter (SgTemplateParameter::template_parameter_enum parameterType, SgType* t)</span></a>
<a name="6882"><span class="lineNum">    6882 </span>            : {</a>
<a name="6883"><span class="lineNum">    6883 </span><span class="lineCov">          1 :   ROSE_ASSERT (t);</span></a>
<a name="6884"><span class="lineNum">    6884 </span><span class="lineCov">          1 :   SgTemplateParameter* result = new SgTemplateParameter(parameterType, t);</span></a>
<a name="6885"><span class="lineNum">    6885 </span><span class="lineCov">          1 :   ROSE_ASSERT (result);</span></a>
<a name="6886"><span class="lineNum">    6886 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6887"><span class="lineNum">    6887 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="6888"><span class="lineNum">    6888 </span>            : }</a>
<a name="6889"><span class="lineNum">    6889 </span>            : </a>
<a name="6890"><span class="lineNum">    6890 </span><span class="lineNoCov">          0 : SgTemplateParameterVal* SageBuilder::buildTemplateParameterVal(int template_parameter_position)</span></a>
<a name="6891"><span class="lineNum">    6891 </span>            : {</a>
<a name="6892"><span class="lineNum">    6892 </span><span class="lineNoCov">          0 :   SgTemplateParameterVal* templateParameterValue = new SgTemplateParameterVal(template_parameter_position,&quot;&quot;);</span></a>
<a name="6893"><span class="lineNum">    6893 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(templateParameterValue);</span></a>
<a name="6894"><span class="lineNum">    6894 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(templateParameterValue);</span></a>
<a name="6895"><span class="lineNum">    6895 </span>            : </a>
<a name="6896"><span class="lineNum">    6896 </span>            : // DQ (7/25/2012): Assert this (it will be set later).</a>
<a name="6897"><span class="lineNum">    6897 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(templateParameterValue-&gt;get_parent() == NULL);</span></a>
<a name="6898"><span class="lineNum">    6898 </span>            : </a>
<a name="6899"><span class="lineNum">    6899 </span><span class="lineNoCov">          0 :   return templateParameterValue;</span></a>
<a name="6900"><span class="lineNum">    6900 </span>            : }</a>
<a name="6901"><span class="lineNum">    6901 </span>            : </a>
<a name="6902"><span class="lineNum">    6902 </span><span class="lineNoCov">          0 : SgTemplateParameterVal* SageBuilder::buildTemplateParameterVal_nfi(int template_parameter_position, const string&amp; str)</span></a>
<a name="6903"><span class="lineNum">    6903 </span>            : {</a>
<a name="6904"><span class="lineNum">    6904 </span><span class="lineNoCov">          0 :   SgTemplateParameterVal* templateParameterValue= new SgTemplateParameterVal(template_parameter_position,str);</span></a>
<a name="6905"><span class="lineNum">    6905 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(templateParameterValue);</span></a>
<a name="6906"><span class="lineNum">    6906 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(templateParameterValue);</span></a>
<a name="6907"><span class="lineNum">    6907 </span>            : </a>
<a name="6908"><span class="lineNum">    6908 </span>            : // DQ (7/25/2012): Assert this (it will be set later).</a>
<a name="6909"><span class="lineNum">    6909 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(templateParameterValue-&gt;get_parent() == NULL);</span></a>
<a name="6910"><span class="lineNum">    6910 </span>            : </a>
<a name="6911"><span class="lineNum">    6911 </span><span class="lineNoCov">          0 :   return templateParameterValue;</span></a>
<a name="6912"><span class="lineNum">    6912 </span>            : }</a>
<a name="6913"><span class="lineNum">    6913 </span>            : </a>
<a name="6914"><span class="lineNum">    6914 </span>            : #define DEBUG_BUILD_NONREAL_DECL 0</a>
<a name="6915"><span class="lineNum">    6915 </span>            : </a>
<a name="6916"><span class="lineNum">    6916 </span><span class="lineCov">      49325 : SgNonrealDecl * SageBuilder::buildNonrealDecl(const SgName &amp; name, SgDeclarationScope * scope, SgDeclarationScope * child_scope) {</span></a>
<a name="6917"><span class="lineNum">    6917 </span><span class="lineCov">      49325 :   ROSE_ASSERT(scope != NULL);</span></a>
<a name="6918"><span class="lineNum">    6918 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6919"><span class="lineNum">    6919 </span>            :   printf(&quot;ENTER SageBuilder::buildNonrealDecl\n&quot;);</a>
<a name="6920"><span class="lineNum">    6920 </span>            :   printf(&quot;  --- name = %s\n&quot;, name.str());</a>
<a name="6921"><span class="lineNum">    6921 </span>            :   printf(&quot;  --- scope = %p (%s)\n&quot;, scope, scope-&gt;class_name().c_str());</a>
<a name="6922"><span class="lineNum">    6922 </span>            : #endif</a>
<a name="6923"><span class="lineNum">    6923 </span>            : </a>
<a name="6924"><span class="lineNum">    6924 </span><span class="lineCov">      49325 :   SgNonrealDecl * nrdecl = NULL;</span></a>
<a name="6925"><span class="lineNum">    6925 </span>            : </a>
<a name="6926"><span class="lineNum">    6926 </span><span class="lineCov">      49325 :   nrdecl = new SgNonrealDecl(name);</span></a>
<a name="6927"><span class="lineNum">    6927 </span><span class="lineCov">      49325 :   SageInterface::setSourcePosition(nrdecl);</span></a>
<a name="6928"><span class="lineNum">    6928 </span><span class="lineCov">      49325 :   nrdecl-&gt;set_firstNondefiningDeclaration(nrdecl);</span></a>
<a name="6929"><span class="lineNum">    6929 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6930"><span class="lineNum">    6930 </span>            :   printf(&quot;  --- nrdecl = %p (%s)\n&quot;, nrdecl, nrdecl-&gt;class_name().c_str());</a>
<a name="6931"><span class="lineNum">    6931 </span>            : #endif</a>
<a name="6932"><span class="lineNum">    6932 </span>            : </a>
<a name="6933"><span class="lineNum">    6933 </span><span class="lineCov">      49325 :   SgNonrealSymbol * symbol = new SgNonrealSymbol(nrdecl);</span></a>
<a name="6934"><span class="lineNum">    6934 </span><span class="lineCov">      49325 :   scope-&gt;insert_symbol(name, symbol);</span></a>
<a name="6935"><span class="lineNum">    6935 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6936"><span class="lineNum">    6936 </span>            :   printf(&quot;  --- symbol = %p (%s)\n&quot;, symbol, symbol-&gt;class_name().c_str());</a>
<a name="6937"><span class="lineNum">    6937 </span>            : #endif</a>
<a name="6938"><span class="lineNum">    6938 </span>            : </a>
<a name="6939"><span class="lineNum">    6939 </span><span class="lineCov">      49325 :   SgNonrealType * type = new SgNonrealType();</span></a>
<a name="6940"><span class="lineNum">    6940 </span><span class="lineCov">      49325 :   type-&gt;set_declaration(nrdecl);</span></a>
<a name="6941"><span class="lineNum">    6941 </span><span class="lineCov">      49325 :   type-&gt;set_parent(scope);</span></a>
<a name="6942"><span class="lineNum">    6942 </span><span class="lineCov">      49325 :   nrdecl-&gt;set_type(type);</span></a>
<a name="6943"><span class="lineNum">    6943 </span>            :   // FIXME (???) insert `type` in `scope`</a>
<a name="6944"><span class="lineNum">    6944 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6945"><span class="lineNum">    6945 </span>            :   printf(&quot;  --- type = %p (%s)\n&quot;, type, type-&gt;class_name().c_str());</a>
<a name="6946"><span class="lineNum">    6946 </span>            : #endif</a>
<a name="6947"><span class="lineNum">    6947 </span>            : </a>
<a name="6948"><span class="lineNum">    6948 </span><span class="lineCov">      49325 :   if (child_scope == NULL) {</span></a>
<a name="6949"><span class="lineNum">    6949 </span><span class="lineCov">      49245 :     child_scope = new SgDeclarationScope();</span></a>
<a name="6950"><span class="lineNum">    6950 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6951"><span class="lineNum">    6951 </span>            :   printf(&quot;  --- child_scope = %p (new)\n&quot;, name.str(), child_scope);</a>
<a name="6952"><span class="lineNum">    6952 </span>            : #endif</a>
<a name="6953"><span class="lineNum">    6953 </span><span class="lineCov">      49245 :     SageInterface::setSourcePosition(child_scope);</span></a>
<a name="6954"><span class="lineNum">    6954 </span><span class="lineCov">      49245 :     child_scope-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="6955"><span class="lineNum">    6955 </span><span class="lineCov">      49245 :     child_scope-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="6956"><span class="lineNum">    6956 </span>            :   } else {</a>
<a name="6957"><span class="lineNum">    6957 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6958"><span class="lineNum">    6958 </span>            :   printf(&quot;  --- child_scope = %p (provided)\n&quot;, name.str(), child_scope);</a>
<a name="6959"><span class="lineNum">    6959 </span>            : #endif</a>
<a name="6960"><span class="lineNum">    6960 </span>            : </a>
<a name="6961"><span class="lineNum">    6961 </span>            :   }</a>
<a name="6962"><span class="lineNum">    6962 </span><span class="lineCov">      49325 :   child_scope-&gt;set_parent(nrdecl);</span></a>
<a name="6963"><span class="lineNum">    6963 </span><span class="lineCov">      49325 :   nrdecl-&gt;set_nonreal_decl_scope(child_scope);</span></a>
<a name="6964"><span class="lineNum">    6964 </span>            : </a>
<a name="6965"><span class="lineNum">    6965 </span>            : #if DEBUG_BUILD_NONREAL_DECL</a>
<a name="6966"><span class="lineNum">    6966 </span>            :   printf(&quot;LEAVE SageBuilder::buildNonrealDecl\n&quot;);</a>
<a name="6967"><span class="lineNum">    6967 </span>            : #endif</a>
<a name="6968"><span class="lineNum">    6968 </span>            : </a>
<a name="6969"><span class="lineNum">    6969 </span><span class="lineCov">      49325 :   return nrdecl;</span></a>
<a name="6970"><span class="lineNum">    6970 </span>            : }</a>
<a name="6971"><span class="lineNum">    6971 </span>            : </a>
<a name="6972"><span class="lineNum">    6972 </span>            : //! Build UPC THREADS (integer expression)</a>
<a name="6973"><span class="lineNum">    6973 </span><span class="lineNoCov">          0 : SgUpcThreads* SageBuilder::buildUpcThreads()</span></a>
<a name="6974"><span class="lineNum">    6974 </span>            : {</a>
<a name="6975"><span class="lineNum">    6975 </span><span class="lineNoCov">          0 :   SgUpcThreads* result = new SgUpcThreads(0,&quot;&quot;);</span></a>
<a name="6976"><span class="lineNum">    6976 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6977"><span class="lineNum">    6977 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6978"><span class="lineNum">    6978 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6979"><span class="lineNum">    6979 </span>            : }</a>
<a name="6980"><span class="lineNum">    6980 </span>            : </a>
<a name="6981"><span class="lineNum">    6981 </span>            : //! Build UPC THREADS (integer expression)</a>
<a name="6982"><span class="lineNum">    6982 </span><span class="lineNoCov">          0 : SgUpcThreads* SageBuilder::buildUpcThreads_nfi()</span></a>
<a name="6983"><span class="lineNum">    6983 </span>            : {</a>
<a name="6984"><span class="lineNum">    6984 </span><span class="lineNoCov">          0 :   SgUpcThreads* result = new SgUpcThreads(0,&quot;&quot;);</span></a>
<a name="6985"><span class="lineNum">    6985 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6986"><span class="lineNum">    6986 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="6987"><span class="lineNum">    6987 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6988"><span class="lineNum">    6988 </span>            : }</a>
<a name="6989"><span class="lineNum">    6989 </span>            : </a>
<a name="6990"><span class="lineNum">    6990 </span>            : //! Build UPC  MYTHREAD (integer expression)</a>
<a name="6991"><span class="lineNum">    6991 </span><span class="lineNoCov">          0 : SgUpcMythread* SageBuilder::buildUpcMythread()</span></a>
<a name="6992"><span class="lineNum">    6992 </span>            : {</a>
<a name="6993"><span class="lineNum">    6993 </span><span class="lineNoCov">          0 :   SgUpcMythread* result = new SgUpcMythread(0,&quot;&quot;);</span></a>
<a name="6994"><span class="lineNum">    6994 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="6995"><span class="lineNum">    6995 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="6996"><span class="lineNum">    6996 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="6997"><span class="lineNum">    6997 </span>            : }</a>
<a name="6998"><span class="lineNum">    6998 </span>            : </a>
<a name="6999"><span class="lineNum">    6999 </span>            : //! Build UPC  MYTHREAD (integer expression)</a>
<a name="7000"><span class="lineNum">    7000 </span><span class="lineNoCov">          0 : SgUpcMythread* SageBuilder::buildUpcMythread_nfi()</span></a>
<a name="7001"><span class="lineNum">    7001 </span>            : {</a>
<a name="7002"><span class="lineNum">    7002 </span><span class="lineNoCov">          0 :   SgUpcMythread* result = new SgUpcMythread(0,&quot;&quot;);</span></a>
<a name="7003"><span class="lineNum">    7003 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7004"><span class="lineNum">    7004 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="7005"><span class="lineNum">    7005 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7006"><span class="lineNum">    7006 </span>            : }</a>
<a name="7007"><span class="lineNum">    7007 </span>            : </a>
<a name="7008"><span class="lineNum">    7008 </span><span class="lineNoCov">          0 : SgThisExp* SageBuilder::buildThisExp(SgSymbol* sym)</span></a>
<a name="7009"><span class="lineNum">    7009 </span>            : {</a>
<a name="7010"><span class="lineNum">    7010 </span><span class="lineNoCov">          0 :   SgThisExp* result = new SgThisExp(isSgClassSymbol(sym), isSgNonrealSymbol(sym), 0);</span></a>
<a name="7011"><span class="lineNum">    7011 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7012"><span class="lineNum">    7012 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7013"><span class="lineNum">    7013 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7014"><span class="lineNum">    7014 </span>            : }</a>
<a name="7015"><span class="lineNum">    7015 </span>            : </a>
<a name="7016"><span class="lineNum">    7016 </span><span class="lineCov">      11795 : SgThisExp* SageBuilder::buildThisExp_nfi(SgSymbol* sym)</span></a>
<a name="7017"><span class="lineNum">    7017 </span>            : {</a>
<a name="7018"><span class="lineNum">    7018 </span><span class="lineCov">      11795 :   SgThisExp* result = new SgThisExp(isSgClassSymbol(sym), isSgNonrealSymbol(sym), 0);</span></a>
<a name="7019"><span class="lineNum">    7019 </span><span class="lineCov">      11795 :   ROSE_ASSERT(result);</span></a>
<a name="7020"><span class="lineNum">    7020 </span><span class="lineCov">      11795 :   setOneSourcePositionNull(result);</span></a>
<a name="7021"><span class="lineNum">    7021 </span><span class="lineCov">      11795 :   return result;</span></a>
<a name="7022"><span class="lineNum">    7022 </span>            : }</a>
<a name="7023"><span class="lineNum">    7023 </span>            : </a>
<a name="7024"><span class="lineNum">    7024 </span><span class="lineNoCov">          0 : SgSuperExp* SageBuilder::buildSuperExp(SgClassSymbol* sym)</span></a>
<a name="7025"><span class="lineNum">    7025 </span>            : {</a>
<a name="7026"><span class="lineNum">    7026 </span><span class="lineNoCov">          0 :   SgSuperExp* result = new SgSuperExp(sym, 0);</span></a>
<a name="7027"><span class="lineNum">    7027 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7028"><span class="lineNum">    7028 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7029"><span class="lineNum">    7029 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7030"><span class="lineNum">    7030 </span>            : }</a>
<a name="7031"><span class="lineNum">    7031 </span>            : </a>
<a name="7032"><span class="lineNum">    7032 </span><span class="lineNoCov">          0 : SgSuperExp* SageBuilder::buildSuperExp_nfi(SgClassSymbol* sym)</span></a>
<a name="7033"><span class="lineNum">    7033 </span>            : {</a>
<a name="7034"><span class="lineNum">    7034 </span><span class="lineNoCov">          0 :   SgSuperExp* result = new SgSuperExp(sym, 0);</span></a>
<a name="7035"><span class="lineNum">    7035 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7036"><span class="lineNum">    7036 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="7037"><span class="lineNum">    7037 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7038"><span class="lineNum">    7038 </span>            : }</a>
<a name="7039"><span class="lineNum">    7039 </span>            : </a>
<a name="7040"><span class="lineNum">    7040 </span><span class="lineNoCov">          0 : SgClassExp* SageBuilder::buildClassExp(SgClassSymbol* sym)</span></a>
<a name="7041"><span class="lineNum">    7041 </span>            : {</a>
<a name="7042"><span class="lineNum">    7042 </span><span class="lineNoCov">          0 :   SgClassExp* result = new SgClassExp(sym, 0);</span></a>
<a name="7043"><span class="lineNum">    7043 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7044"><span class="lineNum">    7044 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7045"><span class="lineNum">    7045 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7046"><span class="lineNum">    7046 </span>            : }</a>
<a name="7047"><span class="lineNum">    7047 </span>            : </a>
<a name="7048"><span class="lineNum">    7048 </span><span class="lineNoCov">          0 : SgClassExp* SageBuilder::buildClassExp_nfi(SgClassSymbol* sym)</span></a>
<a name="7049"><span class="lineNum">    7049 </span>            : {</a>
<a name="7050"><span class="lineNum">    7050 </span><span class="lineNoCov">          0 :   SgClassExp* result = new SgClassExp(sym, 0);</span></a>
<a name="7051"><span class="lineNum">    7051 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7052"><span class="lineNum">    7052 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="7053"><span class="lineNum">    7053 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7054"><span class="lineNum">    7054 </span>            : }</a>
<a name="7055"><span class="lineNum">    7055 </span>            : </a>
<a name="7056"><span class="lineNum">    7056 </span>            : SgTupleExp*</a>
<a name="7057"><span class="lineNum">    7057 </span><span class="lineNoCov">          0 : SageBuilder::buildTupleExp(SgExpression * elt1, SgExpression* elt2, SgExpression* elt3, SgExpression* elt4, SgExpression* elt5, SgExpression* elt6, SgExpression* elt7, SgExpression* elt8, SgExpression* elt9, SgExpression* elt10)</span></a>
<a name="7058"><span class="lineNum">    7058 </span>            : {</a>
<a name="7059"><span class="lineNum">    7059 </span><span class="lineNoCov">          0 :   SgTupleExp* tuple = new SgTupleExp();</span></a>
<a name="7060"><span class="lineNum">    7060 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tuple);</span></a>
<a name="7061"><span class="lineNum">    7061 </span><span class="lineNoCov">          0 :   if (elt1) appendExpression(tuple, elt1);</span></a>
<a name="7062"><span class="lineNum">    7062 </span><span class="lineNoCov">          0 :   if (elt2) appendExpression(tuple, elt2);</span></a>
<a name="7063"><span class="lineNum">    7063 </span><span class="lineNoCov">          0 :   if (elt3) appendExpression(tuple, elt3);</span></a>
<a name="7064"><span class="lineNum">    7064 </span><span class="lineNoCov">          0 :   if (elt4) appendExpression(tuple, elt4);</span></a>
<a name="7065"><span class="lineNum">    7065 </span><span class="lineNoCov">          0 :   if (elt5) appendExpression(tuple, elt5);</span></a>
<a name="7066"><span class="lineNum">    7066 </span><span class="lineNoCov">          0 :   if (elt6) appendExpression(tuple, elt6);</span></a>
<a name="7067"><span class="lineNum">    7067 </span><span class="lineNoCov">          0 :   if (elt7) appendExpression(tuple, elt7);</span></a>
<a name="7068"><span class="lineNum">    7068 </span><span class="lineNoCov">          0 :   if (elt8) appendExpression(tuple, elt8);</span></a>
<a name="7069"><span class="lineNum">    7069 </span><span class="lineNoCov">          0 :   if (elt9) appendExpression(tuple, elt9);</span></a>
<a name="7070"><span class="lineNum">    7070 </span><span class="lineNoCov">          0 :   if (elt10) appendExpression(tuple, elt10);</span></a>
<a name="7071"><span class="lineNum">    7071 </span>            : </a>
<a name="7072"><span class="lineNum">    7072 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(tuple);</span></a>
<a name="7073"><span class="lineNum">    7073 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7074"><span class="lineNum">    7074 </span>            : }</a>
<a name="7075"><span class="lineNum">    7075 </span>            : </a>
<a name="7076"><span class="lineNum">    7076 </span>            : SgTupleExp*</a>
<a name="7077"><span class="lineNum">    7077 </span><span class="lineNoCov">          0 : SageBuilder::buildTupleExp(const std::vector&lt;SgExpression*&gt;&amp; elts)</span></a>
<a name="7078"><span class="lineNum">    7078 </span>            : {</a>
<a name="7079"><span class="lineNum">    7079 </span><span class="lineNoCov">          0 :   SgTupleExp* expList = SageBuilder::buildTupleExp();</span></a>
<a name="7080"><span class="lineNum">    7080 </span><span class="lineNoCov">          0 :   appendExpressionList(expList, elts);</span></a>
<a name="7081"><span class="lineNum">    7081 </span><span class="lineNoCov">          0 :   return expList;</span></a>
<a name="7082"><span class="lineNum">    7082 </span>            : }</a>
<a name="7083"><span class="lineNum">    7083 </span>            : </a>
<a name="7084"><span class="lineNum">    7084 </span>            : SgTupleExp*</a>
<a name="7085"><span class="lineNum">    7085 </span><span class="lineNoCov">          0 : SageBuilder::buildTupleExp_nfi()</span></a>
<a name="7086"><span class="lineNum">    7086 </span>            : {</a>
<a name="7087"><span class="lineNum">    7087 </span><span class="lineNoCov">          0 :   SgTupleExp* tuple = new SgTupleExp();</span></a>
<a name="7088"><span class="lineNum">    7088 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tuple);</span></a>
<a name="7089"><span class="lineNum">    7089 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(tuple);</span></a>
<a name="7090"><span class="lineNum">    7090 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7091"><span class="lineNum">    7091 </span>            : }</a>
<a name="7092"><span class="lineNum">    7092 </span>            : </a>
<a name="7093"><span class="lineNum">    7093 </span>            : SgTupleExp*</a>
<a name="7094"><span class="lineNum">    7094 </span><span class="lineNoCov">          0 : SageBuilder::buildTupleExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; elts)</span></a>
<a name="7095"><span class="lineNum">    7095 </span>            : {</a>
<a name="7096"><span class="lineNum">    7096 </span><span class="lineNoCov">          0 :   SgTupleExp* tuple = SageBuilder::buildTupleExp_nfi();</span></a>
<a name="7097"><span class="lineNum">    7097 </span><span class="lineNoCov">          0 :   appendExpressionList(tuple, elts);</span></a>
<a name="7098"><span class="lineNum">    7098 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7099"><span class="lineNum">    7099 </span>            : }</a>
<a name="7100"><span class="lineNum">    7100 </span>            : </a>
<a name="7101"><span class="lineNum">    7101 </span>            : SgListExp*</a>
<a name="7102"><span class="lineNum">    7102 </span><span class="lineNoCov">          0 : SageBuilder::buildListExp(SgExpression * elt1, SgExpression* elt2, SgExpression* elt3, SgExpression* elt4, SgExpression* elt5, SgExpression* elt6, SgExpression* elt7, SgExpression* elt8, SgExpression* elt9, SgExpression* elt10)</span></a>
<a name="7103"><span class="lineNum">    7103 </span>            : {</a>
<a name="7104"><span class="lineNum">    7104 </span><span class="lineNoCov">          0 :   SgListExp* tuple = new SgListExp();</span></a>
<a name="7105"><span class="lineNum">    7105 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tuple);</span></a>
<a name="7106"><span class="lineNum">    7106 </span><span class="lineNoCov">          0 :   if (elt1) appendExpression(tuple, elt1);</span></a>
<a name="7107"><span class="lineNum">    7107 </span><span class="lineNoCov">          0 :   if (elt2) appendExpression(tuple, elt2);</span></a>
<a name="7108"><span class="lineNum">    7108 </span><span class="lineNoCov">          0 :   if (elt3) appendExpression(tuple, elt3);</span></a>
<a name="7109"><span class="lineNum">    7109 </span><span class="lineNoCov">          0 :   if (elt4) appendExpression(tuple, elt4);</span></a>
<a name="7110"><span class="lineNum">    7110 </span><span class="lineNoCov">          0 :   if (elt5) appendExpression(tuple, elt5);</span></a>
<a name="7111"><span class="lineNum">    7111 </span><span class="lineNoCov">          0 :   if (elt6) appendExpression(tuple, elt6);</span></a>
<a name="7112"><span class="lineNum">    7112 </span><span class="lineNoCov">          0 :   if (elt7) appendExpression(tuple, elt7);</span></a>
<a name="7113"><span class="lineNum">    7113 </span><span class="lineNoCov">          0 :   if (elt8) appendExpression(tuple, elt8);</span></a>
<a name="7114"><span class="lineNum">    7114 </span><span class="lineNoCov">          0 :   if (elt9) appendExpression(tuple, elt9);</span></a>
<a name="7115"><span class="lineNum">    7115 </span><span class="lineNoCov">          0 :   if (elt10) appendExpression(tuple, elt10);</span></a>
<a name="7116"><span class="lineNum">    7116 </span>            : </a>
<a name="7117"><span class="lineNum">    7117 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(tuple);</span></a>
<a name="7118"><span class="lineNum">    7118 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7119"><span class="lineNum">    7119 </span>            : }</a>
<a name="7120"><span class="lineNum">    7120 </span>            : </a>
<a name="7121"><span class="lineNum">    7121 </span>            : SgListExp*</a>
<a name="7122"><span class="lineNum">    7122 </span><span class="lineNoCov">          0 : SageBuilder::buildListExp(const std::vector&lt;SgExpression*&gt;&amp; elts)</span></a>
<a name="7123"><span class="lineNum">    7123 </span>            : {</a>
<a name="7124"><span class="lineNum">    7124 </span><span class="lineNoCov">          0 :   SgListExp* expList = SageBuilder::buildListExp();</span></a>
<a name="7125"><span class="lineNum">    7125 </span><span class="lineNoCov">          0 :   appendExpressionList(expList, elts);</span></a>
<a name="7126"><span class="lineNum">    7126 </span><span class="lineNoCov">          0 :   return expList;</span></a>
<a name="7127"><span class="lineNum">    7127 </span>            : }</a>
<a name="7128"><span class="lineNum">    7128 </span>            : </a>
<a name="7129"><span class="lineNum">    7129 </span>            : SgListExp*</a>
<a name="7130"><span class="lineNum">    7130 </span><span class="lineNoCov">          0 : SageBuilder::buildListExp_nfi()</span></a>
<a name="7131"><span class="lineNum">    7131 </span>            : {</a>
<a name="7132"><span class="lineNum">    7132 </span><span class="lineNoCov">          0 :   SgListExp* tuple = new SgListExp();</span></a>
<a name="7133"><span class="lineNum">    7133 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tuple);</span></a>
<a name="7134"><span class="lineNum">    7134 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(tuple);</span></a>
<a name="7135"><span class="lineNum">    7135 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7136"><span class="lineNum">    7136 </span>            : }</a>
<a name="7137"><span class="lineNum">    7137 </span>            : </a>
<a name="7138"><span class="lineNum">    7138 </span>            : SgListExp*</a>
<a name="7139"><span class="lineNum">    7139 </span><span class="lineNoCov">          0 : SageBuilder::buildListExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; elts)</span></a>
<a name="7140"><span class="lineNum">    7140 </span>            : {</a>
<a name="7141"><span class="lineNum">    7141 </span><span class="lineNoCov">          0 :   SgListExp* tuple = SageBuilder::buildListExp_nfi();</span></a>
<a name="7142"><span class="lineNum">    7142 </span><span class="lineNoCov">          0 :   appendExpressionList(tuple, elts);</span></a>
<a name="7143"><span class="lineNum">    7143 </span><span class="lineNoCov">          0 :   return tuple;</span></a>
<a name="7144"><span class="lineNum">    7144 </span>            : }</a>
<a name="7145"><span class="lineNum">    7145 </span>            : </a>
<a name="7146"><span class="lineNum">    7146 </span>            : </a>
<a name="7147"><span class="lineNum">    7147 </span>            : #define BUILD_UNARY_DEF(suffix) \</a>
<a name="7148"><span class="lineNum">    7148 </span>            :   ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix##_nfi(SgExpression* op) \</a>
<a name="7149"><span class="lineNum">    7149 </span>            :   { \</a>
<a name="7150"><span class="lineNum">    7150 </span>            :      return SageBuilder::buildUnaryExpression_nfi&lt;Sg##suffix&gt;(op); \</a>
<a name="7151"><span class="lineNum">    7151 </span>            :   } \</a>
<a name="7152"><span class="lineNum">    7152 </span>            :   ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix(SgExpression* op) \</a>
<a name="7153"><span class="lineNum">    7153 </span>            :   { \</a>
<a name="7154"><span class="lineNum">    7154 </span>            :      return SageBuilder::buildUnaryExpression&lt;Sg##suffix&gt;(op); \</a>
<a name="7155"><span class="lineNum">    7155 </span>            :   }</a>
<a name="7156"><span class="lineNum">    7156 </span>            : </a>
<a name="7157"><span class="lineNum">    7157 </span><span class="lineCov">        780 : BUILD_UNARY_DEF(AddressOfOp)</span></a>
<a name="7158"><span class="lineNum">    7158 </span><span class="lineCov">        167 : BUILD_UNARY_DEF(BitComplementOp)</span></a>
<a name="7159"><span class="lineNum">    7159 </span><span class="lineCov">        570 : BUILD_UNARY_DEF(MinusOp)</span></a>
<a name="7160"><span class="lineNum">    7160 </span><span class="lineCov">       2231 : BUILD_UNARY_DEF(NotOp)</span></a>
<a name="7161"><span class="lineNum">    7161 </span><span class="lineCov">       3636 : BUILD_UNARY_DEF(PointerDerefExp)</span></a>
<a name="7162"><span class="lineNum">    7162 </span><span class="lineCov">          1 : BUILD_UNARY_DEF(UnaryAddOp)</span></a>
<a name="7163"><span class="lineNum">    7163 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(MinusMinusOp)</span></a>
<a name="7164"><span class="lineNum">    7164 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(PlusPlusOp)</span></a>
<a name="7165"><span class="lineNum">    7165 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(RealPartOp)</span></a>
<a name="7166"><span class="lineNum">    7166 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(ImagPartOp)</span></a>
<a name="7167"><span class="lineNum">    7167 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(ConjugateOp)</span></a>
<a name="7168"><span class="lineNum">    7168 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(VarArgStartOneOperandOp)</span></a>
<a name="7169"><span class="lineNum">    7169 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(VarArgEndOp)</span></a>
<a name="7170"><span class="lineNum">    7170 </span>            : </a>
<a name="7171"><span class="lineNum">    7171 </span><span class="lineNoCov">          0 : BUILD_UNARY_DEF(MatrixTransposeOp) //SK(08/20/2015): Matlab matrix transpose operators</span></a>
<a name="7172"><span class="lineNum">    7172 </span>            : </a>
<a name="7173"><span class="lineNum">    7173 </span>            : #undef BUILD_UNARY_DEF</a>
<a name="7174"><span class="lineNum">    7174 </span>            : </a>
<a name="7175"><span class="lineNum">    7175 </span><span class="lineCov">        447 : SgCastExp * SageBuilder::buildCastExp(SgExpression *  operand_i,</span></a>
<a name="7176"><span class="lineNum">    7176 </span>            :                 SgType * expression_type,</a>
<a name="7177"><span class="lineNum">    7177 </span>            :                 SgCastExp::cast_type_enum cast_type)</a>
<a name="7178"><span class="lineNum">    7178 </span>            : {</a>
<a name="7179"><span class="lineNum">    7179 </span><span class="lineCov">        447 :   SgCastExp* result = new SgCastExp(operand_i, expression_type, cast_type);</span></a>
<a name="7180"><span class="lineNum">    7180 </span><span class="lineCov">        447 :   ROSE_ASSERT(result);</span></a>
<a name="7181"><span class="lineNum">    7181 </span><span class="lineCov">        447 :   if (operand_i) {operand_i-&gt;set_parent(result); markLhsValues(result);}</span></a>
<a name="7182"><span class="lineNum">    7182 </span><span class="lineCov">        447 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7183"><span class="lineNum">    7183 </span><span class="lineCov">        447 :   return result;</span></a>
<a name="7184"><span class="lineNum">    7184 </span>            : }</a>
<a name="7185"><span class="lineNum">    7185 </span>            : </a>
<a name="7186"><span class="lineNum">    7186 </span>            : SgNewExp*</a>
<a name="7187"><span class="lineNum">    7187 </span><span class="lineCov">        129 : SageBuilder::buildNewExp ( SgType* specified_type,</span></a>
<a name="7188"><span class="lineNum">    7188 </span>            :                            SgExprListExp* placement_args,</a>
<a name="7189"><span class="lineNum">    7189 </span>            :                            SgConstructorInitializer* constructor_args,</a>
<a name="7190"><span class="lineNum">    7190 </span>            :                            SgExpression* builtin_args,</a>
<a name="7191"><span class="lineNum">    7191 </span>            :                         // FIXME: Change this from &quot;short int&quot; to &quot;bool&quot;.</a>
<a name="7192"><span class="lineNum">    7192 </span>            :                            short int need_global_specifier,</a>
<a name="7193"><span class="lineNum">    7193 </span>            :                            SgFunctionDeclaration* newOperatorDeclaration)</a>
<a name="7194"><span class="lineNum">    7194 </span>            :    {</a>
<a name="7195"><span class="lineNum">    7195 </span>            :   // DQ (11/18/2012): Modified parameter names to make this function more clear.</a>
<a name="7196"><span class="lineNum">    7196 </span><span class="lineCov">        129 :      SgNewExp* result = new SgNewExp(specified_type, placement_args, constructor_args, builtin_args, need_global_specifier, newOperatorDeclaration);</span></a>
<a name="7197"><span class="lineNum">    7197 </span><span class="lineCov">        129 :      ROSE_ASSERT(result);</span></a>
<a name="7198"><span class="lineNum">    7198 </span>            : </a>
<a name="7199"><span class="lineNum">    7199 </span><span class="lineCov">        129 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7200"><span class="lineNum">    7200 </span><span class="lineCov">        129 :      return result;</span></a>
<a name="7201"><span class="lineNum">    7201 </span>            :    }</a>
<a name="7202"><span class="lineNum">    7202 </span>            : </a>
<a name="7203"><span class="lineNum">    7203 </span><span class="lineNoCov">          0 : SgDeleteExp* SageBuilder::buildDeleteExp(SgExpression* variable,</span></a>
<a name="7204"><span class="lineNum">    7204 </span>            :                                          short is_array,</a>
<a name="7205"><span class="lineNum">    7205 </span>            :                                          short need_global_specifier,</a>
<a name="7206"><span class="lineNum">    7206 </span>            :                                          SgFunctionDeclaration* deleteOperatorDeclaration)</a>
<a name="7207"><span class="lineNum">    7207 </span>            : {</a>
<a name="7208"><span class="lineNum">    7208 </span><span class="lineNoCov">          0 :   SgDeleteExp* result = new SgDeleteExp(variable, is_array,</span></a>
<a name="7209"><span class="lineNum">    7209 </span><span class="lineNoCov">          0 :           need_global_specifier, deleteOperatorDeclaration);</span></a>
<a name="7210"><span class="lineNum">    7210 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7211"><span class="lineNum">    7211 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7212"><span class="lineNum">    7212 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7213"><span class="lineNum">    7213 </span>            : }</a>
<a name="7214"><span class="lineNum">    7214 </span>            : </a>
<a name="7215"><span class="lineNum">    7215 </span>            : SgTypeIdOp*</a>
<a name="7216"><span class="lineNum">    7216 </span><span class="lineCov">         10 : SageBuilder::buildTypeIdOp(SgExpression *operand_expr, SgType *operand_type)</span></a>
<a name="7217"><span class="lineNum">    7217 </span>            :    {</a>
<a name="7218"><span class="lineNum">    7218 </span>            :   // DQ (1/25/2013): Added support for typeId operators.</a>
<a name="7219"><span class="lineNum">    7219 </span><span class="lineCov">         10 :      SgTypeIdOp* result = new SgTypeIdOp(operand_expr,operand_type);</span></a>
<a name="7220"><span class="lineNum">    7220 </span><span class="lineCov">         10 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="7221"><span class="lineNum">    7221 </span><span class="lineCov">         10 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7222"><span class="lineNum">    7222 </span><span class="lineCov">         10 :      return result;</span></a>
<a name="7223"><span class="lineNum">    7223 </span>            :    }</a>
<a name="7224"><span class="lineNum">    7224 </span>            : </a>
<a name="7225"><span class="lineNum">    7225 </span><span class="lineCov">      26223 : SgCastExp * SageBuilder::buildCastExp_nfi(SgExpression *  operand_i, SgType * expression_type, SgCastExp::cast_type_enum cast_type)</span></a>
<a name="7226"><span class="lineNum">    7226 </span>            : {</a>
<a name="7227"><span class="lineNum">    7227 </span><span class="lineCov">      26223 :   SgCastExp* result = new SgCastExp(operand_i, expression_type, cast_type);</span></a>
<a name="7228"><span class="lineNum">    7228 </span><span class="lineCov">      26223 :   ROSE_ASSERT(result);</span></a>
<a name="7229"><span class="lineNum">    7229 </span><span class="lineCov">      26223 :   if (operand_i) {operand_i-&gt;set_parent(result); markLhsValues(result);}</span></a>
<a name="7230"><span class="lineNum">    7230 </span><span class="lineCov">      26223 :   setOneSourcePositionNull(result);</span></a>
<a name="7231"><span class="lineNum">    7231 </span><span class="lineCov">      26223 :   return result;</span></a>
<a name="7232"><span class="lineNum">    7232 </span>            : }</a>
<a name="7233"><span class="lineNum">    7233 </span>            : </a>
<a name="7234"><span class="lineNum">    7234 </span><span class="lineNoCov">          0 : SgVarArgOp * SageBuilder::buildVarArgOp_nfi(SgExpression *  operand_i, SgType * expression_type) {</span></a>
<a name="7235"><span class="lineNum">    7235 </span><span class="lineNoCov">          0 :   SgVarArgOp* result = new SgVarArgOp(operand_i, expression_type);</span></a>
<a name="7236"><span class="lineNum">    7236 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7237"><span class="lineNum">    7237 </span><span class="lineNoCov">          0 :   if (operand_i) {operand_i-&gt;set_parent(result); markLhsValues(result);}</span></a>
<a name="7238"><span class="lineNum">    7238 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="7239"><span class="lineNum">    7239 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7240"><span class="lineNum">    7240 </span>            : }</a>
<a name="7241"><span class="lineNum">    7241 </span>            : </a>
<a name="7242"><span class="lineNum">    7242 </span><span class="lineCov">          4 : SgMinusMinusOp *SageBuilder::buildMinusMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7243"><span class="lineNum">    7243 </span>            : {</a>
<a name="7244"><span class="lineNum">    7244 </span><span class="lineCov">          4 :   SgMinusMinusOp* result = buildUnaryExpression&lt;SgMinusMinusOp&gt;(operand_i);</span></a>
<a name="7245"><span class="lineNum">    7245 </span><span class="lineCov">          4 :   ROSE_ASSERT(result);</span></a>
<a name="7246"><span class="lineNum">    7246 </span><span class="lineCov">          4 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7247"><span class="lineNum">    7247 </span><span class="lineCov">          4 :   return result;</span></a>
<a name="7248"><span class="lineNum">    7248 </span>            : }</a>
<a name="7249"><span class="lineNum">    7249 </span>            : </a>
<a name="7250"><span class="lineNum">    7250 </span><span class="lineCov">        550 : SgMinusMinusOp *SageBuilder::buildMinusMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7251"><span class="lineNum">    7251 </span>            : {</a>
<a name="7252"><span class="lineNum">    7252 </span><span class="lineCov">        550 :   SgMinusMinusOp* result = buildUnaryExpression_nfi&lt;SgMinusMinusOp&gt;(operand_i);</span></a>
<a name="7253"><span class="lineNum">    7253 </span><span class="lineCov">        550 :   ROSE_ASSERT(result);</span></a>
<a name="7254"><span class="lineNum">    7254 </span><span class="lineCov">        550 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7255"><span class="lineNum">    7255 </span><span class="lineCov">        550 :   return result;</span></a>
<a name="7256"><span class="lineNum">    7256 </span>            : }</a>
<a name="7257"><span class="lineNum">    7257 </span>            : </a>
<a name="7258"><span class="lineNum">    7258 </span><span class="lineNoCov">          0 : SgMinusOp *SageBuilder::buildMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7259"><span class="lineNum">    7259 </span>            : {</a>
<a name="7260"><span class="lineNum">    7260 </span><span class="lineNoCov">          0 :   SgMinusOp* result = buildUnaryExpression&lt;SgMinusOp&gt;(operand_i);</span></a>
<a name="7261"><span class="lineNum">    7261 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7262"><span class="lineNum">    7262 </span><span class="lineNoCov">          0 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7263"><span class="lineNum">    7263 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7264"><span class="lineNum">    7264 </span>            : }</a>
<a name="7265"><span class="lineNum">    7265 </span>            : </a>
<a name="7266"><span class="lineNum">    7266 </span><span class="lineNoCov">          0 : SgMinusOp *SageBuilder::buildMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7267"><span class="lineNum">    7267 </span>            : {</a>
<a name="7268"><span class="lineNum">    7268 </span><span class="lineNoCov">          0 :   SgMinusOp* result = buildUnaryExpression_nfi&lt;SgMinusOp&gt;(operand_i);</span></a>
<a name="7269"><span class="lineNum">    7269 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7270"><span class="lineNum">    7270 </span><span class="lineNoCov">          0 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7271"><span class="lineNum">    7271 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7272"><span class="lineNum">    7272 </span>            : }</a>
<a name="7273"><span class="lineNum">    7273 </span>            : </a>
<a name="7274"><span class="lineNum">    7274 </span><span class="lineCov">          8 : SgPlusPlusOp *SageBuilder::buildPlusPlusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7275"><span class="lineNum">    7275 </span>            : {</a>
<a name="7276"><span class="lineNum">    7276 </span><span class="lineCov">          8 :   SgPlusPlusOp* result = buildUnaryExpression&lt;SgPlusPlusOp&gt;(operand_i);</span></a>
<a name="7277"><span class="lineNum">    7277 </span><span class="lineCov">          8 :   ROSE_ASSERT(result);</span></a>
<a name="7278"><span class="lineNum">    7278 </span><span class="lineCov">          8 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7279"><span class="lineNum">    7279 </span><span class="lineCov">          8 :   return result;</span></a>
<a name="7280"><span class="lineNum">    7280 </span>            : }</a>
<a name="7281"><span class="lineNum">    7281 </span>            : </a>
<a name="7282"><span class="lineNum">    7282 </span>            : </a>
<a name="7283"><span class="lineNum">    7283 </span><span class="lineCov">       1899 : SgPlusPlusOp *SageBuilder::buildPlusPlusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)</span></a>
<a name="7284"><span class="lineNum">    7284 </span>            : {</a>
<a name="7285"><span class="lineNum">    7285 </span><span class="lineCov">       1899 :   SgPlusPlusOp* result = buildUnaryExpression_nfi&lt;SgPlusPlusOp&gt;(operand_i);</span></a>
<a name="7286"><span class="lineNum">    7286 </span><span class="lineCov">       1899 :   ROSE_ASSERT(result);</span></a>
<a name="7287"><span class="lineNum">    7287 </span><span class="lineCov">       1899 :   result-&gt;set_mode(a_mode);</span></a>
<a name="7288"><span class="lineNum">    7288 </span><span class="lineCov">       1899 :   return result;</span></a>
<a name="7289"><span class="lineNum">    7289 </span>            : }</a>
<a name="7290"><span class="lineNum">    7290 </span>            : </a>
<a name="7291"><span class="lineNum">    7291 </span><span class="lineCov">        495 : SgThrowOp *SageBuilder::buildThrowOp(SgExpression *operand_i, SgThrowOp::e_throw_kind throwKind)</span></a>
<a name="7292"><span class="lineNum">    7292 </span>            :    {</a>
<a name="7293"><span class="lineNum">    7293 </span>            :   // DQ (11/8/2011): operand_i is allowed to be NULL.</a>
<a name="7294"><span class="lineNum">    7294 </span>            : </a>
<a name="7295"><span class="lineNum">    7295 </span>            :   // SgThrowOp* result = new SgThrowOp(operand_i, operand_i -&gt; get_type(), throwKind);</a>
<a name="7296"><span class="lineNum">    7296 </span><span class="lineCov">        495 :      SgThrowOp* result = new SgThrowOp(operand_i, (operand_i != NULL) ? operand_i-&gt;get_type() : NULL, throwKind);</span></a>
<a name="7297"><span class="lineNum">    7297 </span>            : </a>
<a name="7298"><span class="lineNum">    7298 </span><span class="lineCov">        495 :      if (operand_i != NULL)</span></a>
<a name="7299"><span class="lineNum">    7299 </span>            :         {</a>
<a name="7300"><span class="lineNum">    7300 </span><span class="lineCov">         20 :           markLhsValues(result);</span></a>
<a name="7301"><span class="lineNum">    7301 </span>            :         }</a>
<a name="7302"><span class="lineNum">    7302 </span>            : </a>
<a name="7303"><span class="lineNum">    7303 </span><span class="lineCov">        495 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7304"><span class="lineNum">    7304 </span>            : </a>
<a name="7305"><span class="lineNum">    7305 </span><span class="lineCov">        495 :      if (operand_i != NULL)</span></a>
<a name="7306"><span class="lineNum">    7306 </span><span class="lineCov">         20 :           operand_i -&gt; set_parent(result);</span></a>
<a name="7307"><span class="lineNum">    7307 </span>            : </a>
<a name="7308"><span class="lineNum">    7308 </span><span class="lineCov">        495 :      ROSE_ASSERT(result);</span></a>
<a name="7309"><span class="lineNum">    7309 </span>            : </a>
<a name="7310"><span class="lineNum">    7310 </span><span class="lineCov">        495 :      return result;</span></a>
<a name="7311"><span class="lineNum">    7311 </span>            :    }</a>
<a name="7312"><span class="lineNum">    7312 </span>            : </a>
<a name="7313"><span class="lineNum">    7313 </span>            : </a>
<a name="7314"><span class="lineNum">    7314 </span>            : </a>
<a name="7315"><span class="lineNum">    7315 </span>            : #define BUILD_BINARY_DEF(suffix) \</a>
<a name="7316"><span class="lineNum">    7316 </span>            :   ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix##_nfi(SgExpression* lhs, SgExpression* rhs) \</a>
<a name="7317"><span class="lineNum">    7317 </span>            :   { \</a>
<a name="7318"><span class="lineNum">    7318 </span>            :      return buildBinaryExpression_nfi&lt;Sg##suffix&gt;(lhs, rhs); \</a>
<a name="7319"><span class="lineNum">    7319 </span>            :   } \</a>
<a name="7320"><span class="lineNum">    7320 </span>            :   ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix(SgExpression* lhs, SgExpression* rhs) \</a>
<a name="7321"><span class="lineNum">    7321 </span>            :   { \</a>
<a name="7322"><span class="lineNum">    7322 </span>            :      return buildBinaryExpression&lt;Sg##suffix&gt;(lhs, rhs); \</a>
<a name="7323"><span class="lineNum">    7323 </span>            :   }</a>
<a name="7324"><span class="lineNum">    7324 </span>            : </a>
<a name="7325"><span class="lineNum">    7325 </span><span class="lineCov">       2638 : BUILD_BINARY_DEF(AddOp)</span></a>
<a name="7326"><span class="lineNum">    7326 </span><span class="lineCov">          9 : BUILD_BINARY_DEF(AndAssignOp)</span></a>
<a name="7327"><span class="lineNum">    7327 </span><span class="lineCov">       1591 : BUILD_BINARY_DEF(AndOp)</span></a>
<a name="7328"><span class="lineNum">    7328 </span><span class="lineCov">      11798 : BUILD_BINARY_DEF(ArrowExp)</span></a>
<a name="7329"><span class="lineNum">    7329 </span><span class="lineCov">         32 : BUILD_BINARY_DEF(ArrowStarOp)</span></a>
<a name="7330"><span class="lineNum">    7330 </span><span class="lineCov">       5608 : BUILD_BINARY_DEF(AssignOp)</span></a>
<a name="7331"><span class="lineNum">    7331 </span><span class="lineCov">        174 : BUILD_BINARY_DEF(BitAndOp)</span></a>
<a name="7332"><span class="lineNum">    7332 </span><span class="lineCov">        252 : BUILD_BINARY_DEF(BitOrOp)</span></a>
<a name="7333"><span class="lineNum">    7333 </span><span class="lineCov">         52 : BUILD_BINARY_DEF(BitXorOp)</span></a>
<a name="7334"><span class="lineNum">    7334 </span>            : </a>
<a name="7335"><span class="lineNum">    7335 </span><span class="lineCov">        274 : BUILD_BINARY_DEF(CommaOpExp)</span></a>
<a name="7336"><span class="lineNum">    7336 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ConcatenationOp)</span></a>
<a name="7337"><span class="lineNum">    7337 </span><span class="lineCov">          9 : BUILD_BINARY_DEF(DivAssignOp)</span></a>
<a name="7338"><span class="lineNum">    7338 </span><span class="lineCov">       1109 : BUILD_BINARY_DEF(DivideOp)</span></a>
<a name="7339"><span class="lineNum">    7339 </span><span class="lineCov">       8558 : BUILD_BINARY_DEF(DotExp)</span></a>
<a name="7340"><span class="lineNum">    7340 </span><span class="lineCov">        112 : BUILD_BINARY_DEF(DotStarOp)</span></a>
<a name="7341"><span class="lineNum">    7341 </span><span class="lineCov">       2347 : BUILD_BINARY_DEF(EqualityOp)</span></a>
<a name="7342"><span class="lineNum">    7342 </span>            : </a>
<a name="7343"><span class="lineNum">    7343 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ExponentiationOp)</span></a>
<a name="7344"><span class="lineNum">    7344 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ExponentiationAssignOp)</span></a>
<a name="7345"><span class="lineNum">    7345 </span><span class="lineCov">        282 : BUILD_BINARY_DEF(GreaterOrEqualOp)</span></a>
<a name="7346"><span class="lineNum">    7346 </span><span class="lineCov">       1035 : BUILD_BINARY_DEF(GreaterThanOp)</span></a>
<a name="7347"><span class="lineNum">    7347 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(IntegerDivideOp)</span></a>
<a name="7348"><span class="lineNum">    7348 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(IntegerDivideAssignOp)</span></a>
<a name="7349"><span class="lineNum">    7349 </span><span class="lineCov">         62 : BUILD_BINARY_DEF(IorAssignOp)</span></a>
<a name="7350"><span class="lineNum">    7350 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(IsOp)</span></a>
<a name="7351"><span class="lineNum">    7351 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(IsNotOp)</span></a>
<a name="7352"><span class="lineNum">    7352 </span>            : </a>
<a name="7353"><span class="lineNum">    7353 </span><span class="lineCov">        337 : BUILD_BINARY_DEF(LessOrEqualOp)</span></a>
<a name="7354"><span class="lineNum">    7354 </span><span class="lineCov">       2652 : BUILD_BINARY_DEF(LessThanOp)</span></a>
<a name="7355"><span class="lineNum">    7355 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(LshiftAssignOp)</span></a>
<a name="7356"><span class="lineNum">    7356 </span><span class="lineCov">       3158 : BUILD_BINARY_DEF(LshiftOp)</span></a>
<a name="7357"><span class="lineNum">    7357 </span>            : </a>
<a name="7358"><span class="lineNum">    7358 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(MembershipOp)</span></a>
<a name="7359"><span class="lineNum">    7359 </span><span class="lineCov">         96 : BUILD_BINARY_DEF(MinusAssignOp)</span></a>
<a name="7360"><span class="lineNum">    7360 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ModAssignOp)</span></a>
<a name="7361"><span class="lineNum">    7361 </span><span class="lineCov">        108 : BUILD_BINARY_DEF(ModOp)</span></a>
<a name="7362"><span class="lineNum">    7362 </span><span class="lineCov">         30 : BUILD_BINARY_DEF(MultAssignOp)</span></a>
<a name="7363"><span class="lineNum">    7363 </span><span class="lineCov">       1987 : BUILD_BINARY_DEF(MultiplyOp)</span></a>
<a name="7364"><span class="lineNum">    7364 </span>            : </a>
<a name="7365"><span class="lineNum">    7365 </span><span class="lineCov">       1721 : BUILD_BINARY_DEF(NotEqualOp)</span></a>
<a name="7366"><span class="lineNum">    7366 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(NonMembershipOp)</span></a>
<a name="7367"><span class="lineNum">    7367 </span><span class="lineCov">        716 : BUILD_BINARY_DEF(OrOp)</span></a>
<a name="7368"><span class="lineNum">    7368 </span><span class="lineCov">        377 : BUILD_BINARY_DEF(PlusAssignOp)</span></a>
<a name="7369"><span class="lineNum">    7369 </span><span class="lineCov">       2025 : BUILD_BINARY_DEF(PntrArrRefExp)</span></a>
<a name="7370"><span class="lineNum">    7370 </span><span class="lineCov">         16 : BUILD_BINARY_DEF(RshiftAssignOp)</span></a>
<a name="7371"><span class="lineNum">    7371 </span>            : </a>
<a name="7372"><span class="lineNum">    7372 </span><span class="lineCov">        765 : BUILD_BINARY_DEF(RshiftOp)</span></a>
<a name="7373"><span class="lineNum">    7373 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ScopeOp)</span></a>
<a name="7374"><span class="lineNum">    7374 </span><span class="lineCov">       2692 : BUILD_BINARY_DEF(SubtractOp)</span></a>
<a name="7375"><span class="lineNum">    7375 </span><span class="lineCov">          3 : BUILD_BINARY_DEF(XorAssignOp)</span></a>
<a name="7376"><span class="lineNum">    7376 </span>            : </a>
<a name="7377"><span class="lineNum">    7377 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(VarArgCopyOp)</span></a>
<a name="7378"><span class="lineNum">    7378 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(VarArgStartOp)</span></a>
<a name="7379"><span class="lineNum">    7379 </span>            : </a>
<a name="7380"><span class="lineNum">    7380 </span>            : //SK(08/20/2015): Matlab operators</a>
<a name="7381"><span class="lineNum">    7381 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(PowerOp);</span></a>
<a name="7382"><span class="lineNum">    7382 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwisePowerOp);</span></a>
<a name="7383"><span class="lineNum">    7383 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwiseMultiplyOp);</span></a>
<a name="7384"><span class="lineNum">    7384 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwiseDivideOp);</span></a>
<a name="7385"><span class="lineNum">    7385 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(LeftDivideOp);</span></a>
<a name="7386"><span class="lineNum">    7386 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwiseLeftDivideOp);</span></a>
<a name="7387"><span class="lineNum">    7387 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwiseAddOp);</span></a>
<a name="7388"><span class="lineNum">    7388 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(ElementwiseSubtractOp);</span></a>
<a name="7389"><span class="lineNum">    7389 </span>            : </a>
<a name="7390"><span class="lineNum">    7390 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="7391"><span class="lineNum">    7391 </span><span class="lineNoCov">          0 : BUILD_BINARY_DEF(SpaceshipOp)</span></a>
<a name="7392"><span class="lineNum">    7392 </span>            : </a>
<a name="7393"><span class="lineNum">    7393 </span>            : #undef BUILD_BINARY_DEF</a>
<a name="7394"><span class="lineNum">    7394 </span>            : </a>
<a name="7395"><span class="lineNum">    7395 </span>            : </a>
<a name="7396"><span class="lineNum">    7396 </span>            : </a>
<a name="7397"><span class="lineNum">    7397 </span>            : // CR ( 1/25/2018):</a>
<a name="7398"><span class="lineNum">    7398 </span>            : //    (10/30/2018): Fixed case when this function is called with NULL dim_info object.</a>
<a name="7399"><span class="lineNum">    7399 </span><span class="lineNoCov">          0 : SgArrayType* SageBuilder::buildArrayType(SgType* base_type, SgExprListExp* dim_info)</span></a>
<a name="7400"><span class="lineNum">    7400 </span>            :    {</a>
<a name="7401"><span class="lineNum">    7401 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="7402"><span class="lineNum">    7402 </span>            : </a>
<a name="7403"><span class="lineNum">    7403 </span>            :   // There must always be a dim_info object for this function.  If not, the</a>
<a name="7404"><span class="lineNum">    7404 </span>            :   // overloaded function must be used to handle it.</a>
<a name="7405"><span class="lineNum">    7405 </span><span class="lineNoCov">          0 :      if (dim_info == NULL)</span></a>
<a name="7406"><span class="lineNum">    7406 </span>            :         {</a>
<a name="7407"><span class="lineNum">    7407 </span><span class="lineNoCov">          0 :            SgExpression* index = NULL;</span></a>
<a name="7408"><span class="lineNum">    7408 </span><span class="lineNoCov">          0 :            return buildArrayType(base_type, index);</span></a>
<a name="7409"><span class="lineNum">    7409 </span>            :         }</a>
<a name="7410"><span class="lineNum">    7410 </span>            : </a>
<a name="7411"><span class="lineNum">    7411 </span><span class="lineNoCov">          0 :      SgExpression* index = new SgNullExpression();</span></a>
<a name="7412"><span class="lineNum">    7412 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(index);</span></a>
<a name="7413"><span class="lineNum">    7413 </span><span class="lineNoCov">          0 :      setSourcePosition(index);</span></a>
<a name="7414"><span class="lineNum">    7414 </span>            : </a>
<a name="7415"><span class="lineNum">    7415 </span><span class="lineNoCov">          0 :      SgArrayType* array_type = new SgArrayType(base_type, index);</span></a>
<a name="7416"><span class="lineNum">    7416 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(array_type);</span></a>
<a name="7417"><span class="lineNum">    7417 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(array_type-&gt;get_dim_info() == NULL);</span></a>
<a name="7418"><span class="lineNum">    7418 </span>            : </a>
<a name="7419"><span class="lineNum">    7419 </span><span class="lineNoCov">          0 :      index   -&gt;set_parent(array_type);</span></a>
<a name="7420"><span class="lineNum">    7420 </span><span class="lineNoCov">          0 :      dim_info-&gt;set_parent(array_type);</span></a>
<a name="7421"><span class="lineNum">    7421 </span>            : </a>
<a name="7422"><span class="lineNum">    7422 </span><span class="lineNoCov">          0 :      array_type-&gt;set_dim_info(dim_info);</span></a>
<a name="7423"><span class="lineNum">    7423 </span><span class="lineNoCov">          0 :      array_type-&gt;set_rank(dim_info-&gt;get_expressions().size());</span></a>
<a name="7424"><span class="lineNum">    7424 </span>            : </a>
<a name="7425"><span class="lineNum">    7425 </span><span class="lineNoCov">          0 :      return array_type;</span></a>
<a name="7426"><span class="lineNum">    7426 </span>            :    }</a>
<a name="7427"><span class="lineNum">    7427 </span>            : </a>
<a name="7428"><span class="lineNum">    7428 </span><span class="lineCov">       6606 : SgArrayType* SageBuilder::buildArrayType(SgType* base_type/*=NULL*/, SgExpression* index/*=NULL*/)</span></a>
<a name="7429"><span class="lineNum">    7429 </span>            :    {</a>
<a name="7430"><span class="lineNum">    7430 </span><span class="lineCov">       6606 :      SgArrayType* result = new SgArrayType(base_type,index);</span></a>
<a name="7431"><span class="lineNum">    7431 </span><span class="lineCov">       6606 :      ROSE_ASSERT(result);</span></a>
<a name="7432"><span class="lineNum">    7432 </span>            : </a>
<a name="7433"><span class="lineNum">    7433 </span><span class="lineCov">       6606 :      if (index != NULL)</span></a>
<a name="7434"><span class="lineNum">    7434 </span><span class="lineCov">       6606 :           index-&gt;set_parent(result); // important!</span></a>
<a name="7435"><span class="lineNum">    7435 </span>            : </a>
<a name="7436"><span class="lineNum">    7436 </span>            : #if 0</a>
<a name="7437"><span class="lineNum">    7437 </span>            :      printf (&quot;In SageBuilder::buildArrayType(): result = %p base_type = %p = %s index = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str(),index,index-&gt;class_name().c_str());</a>
<a name="7438"><span class="lineNum">    7438 </span>            : #endif</a>
<a name="7439"><span class="lineNum">    7439 </span>            : </a>
<a name="7440"><span class="lineNum">    7440 </span><span class="lineCov">       6606 :      return result;</span></a>
<a name="7441"><span class="lineNum">    7441 </span>            :    }</a>
<a name="7442"><span class="lineNum">    7442 </span>            : </a>
<a name="7443"><span class="lineNum">    7443 </span><span class="lineCov">         21 : SgConditionalExp* SageBuilder::buildConditionalExp(SgExpression* test, SgExpression* a, SgExpression* b)</span></a>
<a name="7444"><span class="lineNum">    7444 </span>            : {</a>
<a name="7445"><span class="lineNum">    7445 </span><span class="lineCov">         21 :   SgConditionalExp* result = new SgConditionalExp(test, a, b, NULL);</span></a>
<a name="7446"><span class="lineNum">    7446 </span><span class="lineCov">         21 :   if (test) test-&gt;set_parent(result);</span></a>
<a name="7447"><span class="lineNum">    7447 </span><span class="lineCov">         21 :   if (a) a-&gt;set_parent(result);</span></a>
<a name="7448"><span class="lineNum">    7448 </span><span class="lineCov">         21 :   if (b) b-&gt;set_parent(result);</span></a>
<a name="7449"><span class="lineNum">    7449 </span><span class="lineCov">         21 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7450"><span class="lineNum">    7450 </span><span class="lineCov">         21 :   return result;</span></a>
<a name="7451"><span class="lineNum">    7451 </span>            : }</a>
<a name="7452"><span class="lineNum">    7452 </span>            : </a>
<a name="7453"><span class="lineNum">    7453 </span><span class="lineCov">       1794 : SgConditionalExp* SageBuilder::buildConditionalExp_nfi(SgExpression* test, SgExpression* a, SgExpression* b, SgType* t)</span></a>
<a name="7454"><span class="lineNum">    7454 </span>            : {</a>
<a name="7455"><span class="lineNum">    7455 </span><span class="lineCov">       1794 :   SgConditionalExp* result = new SgConditionalExp(test, a, b, t);</span></a>
<a name="7456"><span class="lineNum">    7456 </span><span class="lineCov">       1794 :   if (test) test-&gt;set_parent(result);</span></a>
<a name="7457"><span class="lineNum">    7457 </span><span class="lineCov">       1794 :   if (a) {a-&gt;set_parent(result); markLhsValues(a);}</span></a>
<a name="7458"><span class="lineNum">    7458 </span><span class="lineCov">       1794 :   if (b) {b-&gt;set_parent(result); markLhsValues(b);}</span></a>
<a name="7459"><span class="lineNum">    7459 </span><span class="lineCov">       1794 :   setOneSourcePositionNull(result);</span></a>
<a name="7460"><span class="lineNum">    7460 </span><span class="lineCov">       1794 :   return result;</span></a>
<a name="7461"><span class="lineNum">    7461 </span>            : }</a>
<a name="7462"><span class="lineNum">    7462 </span><span class="lineCov">          1 : SgVariantExpression * SageBuilder::buildVariantExpression()</span></a>
<a name="7463"><span class="lineNum">    7463 </span>            : {</a>
<a name="7464"><span class="lineNum">    7464 </span><span class="lineCov">          1 :   SgVariantExpression * result =  new SgVariantExpression();</span></a>
<a name="7465"><span class="lineNum">    7465 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="7466"><span class="lineNum">    7466 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7467"><span class="lineNum">    7467 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="7468"><span class="lineNum">    7468 </span>            : }</a>
<a name="7469"><span class="lineNum">    7469 </span>            : </a>
<a name="7470"><span class="lineNum">    7470 </span><span class="lineCov">       1666 : SgNullExpression* SageBuilder::buildNullExpression_nfi()</span></a>
<a name="7471"><span class="lineNum">    7471 </span>            : {</a>
<a name="7472"><span class="lineNum">    7472 </span><span class="lineCov">       1666 :   SgNullExpression* ne = new SgNullExpression();</span></a>
<a name="7473"><span class="lineNum">    7473 </span><span class="lineCov">       1666 :   ROSE_ASSERT(ne);</span></a>
<a name="7474"><span class="lineNum">    7474 </span><span class="lineCov">       1666 :   setOneSourcePositionNull(ne);</span></a>
<a name="7475"><span class="lineNum">    7475 </span><span class="lineCov">       1666 :   return ne;</span></a>
<a name="7476"><span class="lineNum">    7476 </span>            : }</a>
<a name="7477"><span class="lineNum">    7477 </span>            : </a>
<a name="7478"><span class="lineNum">    7478 </span><span class="lineCov">          1 : SgNullExpression* SageBuilder::buildNullExpression() {</span></a>
<a name="7479"><span class="lineNum">    7479 </span><span class="lineCov">          1 :   SgNullExpression* e = buildNullExpression_nfi();</span></a>
<a name="7480"><span class="lineNum">    7480 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(e);</span></a>
<a name="7481"><span class="lineNum">    7481 </span><span class="lineCov">          1 :   return e;</span></a>
<a name="7482"><span class="lineNum">    7482 </span>            : }</a>
<a name="7483"><span class="lineNum">    7483 </span>            : </a>
<a name="7484"><span class="lineNum">    7484 </span><span class="lineCov">       1299 : SgAssignInitializer * SageBuilder::buildAssignInitializer(SgExpression * operand_i /*= NULL*/, SgType * expression_type /* = NULL */)</span></a>
<a name="7485"><span class="lineNum">    7485 </span>            :    {</a>
<a name="7486"><span class="lineNum">    7486 </span><span class="lineCov">       1299 :      SgAssignInitializer* result = new SgAssignInitializer(operand_i, expression_type);</span></a>
<a name="7487"><span class="lineNum">    7487 </span><span class="lineCov">       1299 :      ROSE_ASSERT(result);</span></a>
<a name="7488"><span class="lineNum">    7488 </span><span class="lineCov">       1299 :      if (operand_i!=NULL)</span></a>
<a name="7489"><span class="lineNum">    7489 </span>            :         {</a>
<a name="7490"><span class="lineNum">    7490 </span><span class="lineCov">       1299 :           operand_i-&gt;set_parent(result);</span></a>
<a name="7491"><span class="lineNum">    7491 </span>            :        // set lvalue, it asserts operand!=NULL</a>
<a name="7492"><span class="lineNum">    7492 </span><span class="lineCov">       1299 :           markLhsValues(result);</span></a>
<a name="7493"><span class="lineNum">    7493 </span>            :         }</a>
<a name="7494"><span class="lineNum">    7494 </span><span class="lineCov">       1299 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7495"><span class="lineNum">    7495 </span><span class="lineCov">       1299 :      return result;</span></a>
<a name="7496"><span class="lineNum">    7496 </span>            :    }</a>
<a name="7497"><span class="lineNum">    7497 </span>            : </a>
<a name="7498"><span class="lineNum">    7498 </span><span class="lineCov">      15627 : SgAssignInitializer * SageBuilder::buildAssignInitializer_nfi(SgExpression * operand_i /*= NULL*/, SgType * expression_type /* = NULL */)</span></a>
<a name="7499"><span class="lineNum">    7499 </span>            :    {</a>
<a name="7500"><span class="lineNum">    7500 </span><span class="lineCov">      15627 :      SgAssignInitializer* result = new SgAssignInitializer(operand_i, expression_type);</span></a>
<a name="7501"><span class="lineNum">    7501 </span><span class="lineCov">      15627 :      ROSE_ASSERT(result);</span></a>
<a name="7502"><span class="lineNum">    7502 </span><span class="lineCov">      15627 :      if (operand_i!=NULL)</span></a>
<a name="7503"><span class="lineNum">    7503 </span>            :         {</a>
<a name="7504"><span class="lineNum">    7504 </span><span class="lineCov">      15627 :           operand_i-&gt;set_parent(result);</span></a>
<a name="7505"><span class="lineNum">    7505 </span>            :        // set lvalue, it asserts operand!=NULL</a>
<a name="7506"><span class="lineNum">    7506 </span><span class="lineCov">      15627 :           markLhsValues(result);</span></a>
<a name="7507"><span class="lineNum">    7507 </span>            :         }</a>
<a name="7508"><span class="lineNum">    7508 </span>            : </a>
<a name="7509"><span class="lineNum">    7509 </span>            :   // DQ (11/2/2012): Set the source positon using our standard approach.</a>
<a name="7510"><span class="lineNum">    7510 </span>            :   // result-&gt;set_startOfConstruct(NULL);</a>
<a name="7511"><span class="lineNum">    7511 </span>            :   // result-&gt;set_endOfConstruct(NULL);</a>
<a name="7512"><span class="lineNum">    7512 </span>            :   // result-&gt;set_operatorPosition(NULL);</a>
<a name="7513"><span class="lineNum">    7513 </span><span class="lineCov">      15627 :      setSourcePosition(result);</span></a>
<a name="7514"><span class="lineNum">    7514 </span>            : </a>
<a name="7515"><span class="lineNum">    7515 </span><span class="lineCov">      15627 :      result-&gt;set_need_paren(false);</span></a>
<a name="7516"><span class="lineNum">    7516 </span>            : </a>
<a name="7517"><span class="lineNum">    7517 </span><span class="lineCov">      15627 :      return result;</span></a>
<a name="7518"><span class="lineNum">    7518 </span>            :    }</a>
<a name="7519"><span class="lineNum">    7519 </span>            : </a>
<a name="7520"><span class="lineNum">    7520 </span>            : //! Build an aggregate initializer</a>
<a name="7521"><span class="lineNum">    7521 </span><span class="lineNoCov">          0 : SgAggregateInitializer * SageBuilder::buildAggregateInitializer(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)</span></a>
<a name="7522"><span class="lineNum">    7522 </span>            : {</a>
<a name="7523"><span class="lineNum">    7523 </span><span class="lineNoCov">          0 :   SgAggregateInitializer* result = new SgAggregateInitializer(initializers, type);</span></a>
<a name="7524"><span class="lineNum">    7524 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7525"><span class="lineNum">    7525 </span><span class="lineNoCov">          0 :   if (initializers!=NULL)</span></a>
<a name="7526"><span class="lineNum">    7526 </span>            :   {</a>
<a name="7527"><span class="lineNum">    7527 </span><span class="lineNoCov">          0 :     initializers-&gt;set_parent(result);</span></a>
<a name="7528"><span class="lineNum">    7528 </span>            :   }</a>
<a name="7529"><span class="lineNum">    7529 </span><span class="lineNoCov">          0 :   result-&gt;set_need_explicit_braces(true);</span></a>
<a name="7530"><span class="lineNum">    7530 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7531"><span class="lineNum">    7531 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7532"><span class="lineNum">    7532 </span>            : }</a>
<a name="7533"><span class="lineNum">    7533 </span>            : </a>
<a name="7534"><span class="lineNum">    7534 </span>            : //! Build an aggregate initializer</a>
<a name="7535"><span class="lineNum">    7535 </span><span class="lineCov">        272 : SgAggregateInitializer * SageBuilder::buildAggregateInitializer_nfi(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)</span></a>
<a name="7536"><span class="lineNum">    7536 </span>            : {</a>
<a name="7537"><span class="lineNum">    7537 </span><span class="lineCov">        272 :   SgAggregateInitializer* result = new SgAggregateInitializer(initializers, type);</span></a>
<a name="7538"><span class="lineNum">    7538 </span><span class="lineCov">        272 :   ROSE_ASSERT(result);</span></a>
<a name="7539"><span class="lineNum">    7539 </span><span class="lineCov">        272 :   if (initializers!=NULL)</span></a>
<a name="7540"><span class="lineNum">    7540 </span>            :   {</a>
<a name="7541"><span class="lineNum">    7541 </span><span class="lineCov">        272 :     initializers-&gt;set_parent(result);</span></a>
<a name="7542"><span class="lineNum">    7542 </span>            :   }</a>
<a name="7543"><span class="lineNum">    7543 </span><span class="lineCov">        272 :   result-&gt;set_need_explicit_braces(true);</span></a>
<a name="7544"><span class="lineNum">    7544 </span><span class="lineCov">        272 :   setOneSourcePositionNull(result);</span></a>
<a name="7545"><span class="lineNum">    7545 </span><span class="lineCov">        272 :   return result;</span></a>
<a name="7546"><span class="lineNum">    7546 </span>            : }</a>
<a name="7547"><span class="lineNum">    7547 </span>            : </a>
<a name="7548"><span class="lineNum">    7548 </span>            : //! Build a compound initializer, for vector type initialization</a>
<a name="7549"><span class="lineNum">    7549 </span><span class="lineNoCov">          0 : SgCompoundInitializer * SageBuilder::buildCompoundInitializer(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)</span></a>
<a name="7550"><span class="lineNum">    7550 </span>            : {</a>
<a name="7551"><span class="lineNum">    7551 </span><span class="lineNoCov">          0 :   SgCompoundInitializer* result = new SgCompoundInitializer(initializers, type);</span></a>
<a name="7552"><span class="lineNum">    7552 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7553"><span class="lineNum">    7553 </span><span class="lineNoCov">          0 :   if (initializers!=NULL)</span></a>
<a name="7554"><span class="lineNum">    7554 </span>            :   {</a>
<a name="7555"><span class="lineNum">    7555 </span><span class="lineNoCov">          0 :     initializers-&gt;set_parent(result);</span></a>
<a name="7556"><span class="lineNum">    7556 </span>            :   }</a>
<a name="7557"><span class="lineNum">    7557 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="7558"><span class="lineNum">    7558 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7559"><span class="lineNum">    7559 </span>            : }</a>
<a name="7560"><span class="lineNum">    7560 </span>            : </a>
<a name="7561"><span class="lineNum">    7561 </span>            : //! Build a compound initializer, for vector type initialization</a>
<a name="7562"><span class="lineNum">    7562 </span><span class="lineNoCov">          0 : SgCompoundInitializer * SageBuilder::buildCompoundInitializer_nfi(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)</span></a>
<a name="7563"><span class="lineNum">    7563 </span>            : {</a>
<a name="7564"><span class="lineNum">    7564 </span><span class="lineNoCov">          0 :   SgCompoundInitializer* result = new SgCompoundInitializer(initializers, type);</span></a>
<a name="7565"><span class="lineNum">    7565 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="7566"><span class="lineNum">    7566 </span><span class="lineNoCov">          0 :   if (initializers!=NULL)</span></a>
<a name="7567"><span class="lineNum">    7567 </span>            :   {</a>
<a name="7568"><span class="lineNum">    7568 </span><span class="lineNoCov">          0 :     initializers-&gt;set_parent(result);</span></a>
<a name="7569"><span class="lineNum">    7569 </span>            :   }</a>
<a name="7570"><span class="lineNum">    7570 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="7571"><span class="lineNum">    7571 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="7572"><span class="lineNum">    7572 </span>            : }</a>
<a name="7573"><span class="lineNum">    7573 </span>            : </a>
<a name="7574"><span class="lineNum">    7574 </span>            : // DQ (1/4/2009): Added support for SgConstructorInitializer</a>
<a name="7575"><span class="lineNum">    7575 </span>            : SgConstructorInitializer *</a>
<a name="7576"><span class="lineNum">    7576 </span><span class="lineCov">       3480 : SageBuilder::buildConstructorInitializer(</span></a>
<a name="7577"><span class="lineNum">    7577 </span>            :    SgMemberFunctionDeclaration *declaration/* = NULL*/,</a>
<a name="7578"><span class="lineNum">    7578 </span>            :    SgExprListExp *args/* = NULL*/,</a>
<a name="7579"><span class="lineNum">    7579 </span>            :    SgType *expression_type/* = NULL*/,</a>
<a name="7580"><span class="lineNum">    7580 </span>            :    bool need_name /*= false*/,</a>
<a name="7581"><span class="lineNum">    7581 </span>            :    bool need_qualifier /*= false*/,</a>
<a name="7582"><span class="lineNum">    7582 </span>            :    bool need_parenthesis_after_name /*= false*/,</a>
<a name="7583"><span class="lineNum">    7583 </span>            :    bool associated_class_unknown /*= false*/)</a>
<a name="7584"><span class="lineNum">    7584 </span>            :    {</a>
<a name="7585"><span class="lineNum">    7585 </span>            :   // Prototype:</a>
<a name="7586"><span class="lineNum">    7586 </span>            :   // SgConstructorInitializer (SgMemberFunctionDeclaration *declaration, SgExprListExp *args, SgType *expression_type,</a>
<a name="7587"><span class="lineNum">    7587 </span>            :   //    bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown);</a>
<a name="7588"><span class="lineNum">    7588 </span>            : </a>
<a name="7589"><span class="lineNum">    7589 </span>            :      //George Vulov (05/24/2011) Modified this assertion to allow for a NULL declaration (in case of implicit constructors)</a>
<a name="7590"><span class="lineNum">    7590 </span><span class="lineCov">       3480 :      ROSE_ASSERT(declaration == NULL || declaration-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="7591"><span class="lineNum">    7591 </span>            : </a>
<a name="7592"><span class="lineNum">    7592 </span><span class="lineCov">       3480 :      SgConstructorInitializer* result = new SgConstructorInitializer( declaration, args, expression_type, need_name,</span></a>
<a name="7593"><span class="lineNum">    7593 </span><span class="lineCov">       3480 :                                         need_qualifier, need_parenthesis_after_name, associated_class_unknown );</span></a>
<a name="7594"><span class="lineNum">    7594 </span><span class="lineCov">       3480 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="7595"><span class="lineNum">    7595 </span><span class="lineCov">       3480 :      if (args != NULL)</span></a>
<a name="7596"><span class="lineNum">    7596 </span>            :         {</a>
<a name="7597"><span class="lineNum">    7597 </span><span class="lineCov">       3480 :           args-&gt;set_parent(result);</span></a>
<a name="7598"><span class="lineNum">    7598 </span><span class="lineCov">       3480 :           setOneSourcePositionForTransformation(args);</span></a>
<a name="7599"><span class="lineNum">    7599 </span>            :         }</a>
<a name="7600"><span class="lineNum">    7600 </span>            : </a>
<a name="7601"><span class="lineNum">    7601 </span><span class="lineCov">       3480 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7602"><span class="lineNum">    7602 </span>            : </a>
<a name="7603"><span class="lineNum">    7603 </span><span class="lineCov">       3480 :      return result;</span></a>
<a name="7604"><span class="lineNum">    7604 </span>            :    }</a>
<a name="7605"><span class="lineNum">    7605 </span>            : </a>
<a name="7606"><span class="lineNum">    7606 </span>            : // DQ (1/4/2009): Added support for SgConstructorInitializer</a>
<a name="7607"><span class="lineNum">    7607 </span>            : SgConstructorInitializer *</a>
<a name="7608"><span class="lineNum">    7608 </span><span class="lineCov">       1068 : SageBuilder::buildConstructorInitializer_nfi(</span></a>
<a name="7609"><span class="lineNum">    7609 </span>            :    SgMemberFunctionDeclaration *declaration/* = NULL*/,</a>
<a name="7610"><span class="lineNum">    7610 </span>            :    SgExprListExp *args/* = NULL*/,</a>
<a name="7611"><span class="lineNum">    7611 </span>            :    SgType *expression_type/* = NULL*/,</a>
<a name="7612"><span class="lineNum">    7612 </span>            :    bool need_name /*= false*/,</a>
<a name="7613"><span class="lineNum">    7613 </span>            :    bool need_qualifier /*= false*/,</a>
<a name="7614"><span class="lineNum">    7614 </span>            :    bool need_parenthesis_after_name /*= false*/,</a>
<a name="7615"><span class="lineNum">    7615 </span>            :    bool associated_class_unknown /*= false*/)</a>
<a name="7616"><span class="lineNum">    7616 </span>            :    {</a>
<a name="7617"><span class="lineNum">    7617 </span>            :   // Prototype:</a>
<a name="7618"><span class="lineNum">    7618 </span>            :   // SgConstructorInitializer (SgMemberFunctionDeclaration *declaration, SgExprListExp *args, SgType *expression_type, bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown);</a>
<a name="7619"><span class="lineNum">    7619 </span>            : </a>
<a name="7620"><span class="lineNum">    7620 </span>            :   // DQ (11/7/2011): Added additional error checking.</a>
<a name="7621"><span class="lineNum">    7621 </span>            :   // ROSE_ASSERT(declaration != NULL);</a>
<a name="7622"><span class="lineNum">    7622 </span>            :   // DQ (1/4/2009): Error checking</a>
<a name="7623"><span class="lineNum">    7623 </span>            :   // ROSE_ASSERT(declaration-&gt;get_associatedClassDeclaration() != NULL);</a>
<a name="7624"><span class="lineNum">    7624 </span>            : </a>
<a name="7625"><span class="lineNum">    7625 </span>            :   // DQ (11/7/2011): Fix symetric to the way George did it above.</a>
<a name="7626"><span class="lineNum">    7626 </span><span class="lineCov">       1068 :      ROSE_ASSERT(declaration == NULL || declaration-&gt;get_associatedClassDeclaration() != NULL);</span></a>
<a name="7627"><span class="lineNum">    7627 </span>            : </a>
<a name="7628"><span class="lineNum">    7628 </span><span class="lineCov">       1068 :      SgConstructorInitializer* result = new SgConstructorInitializer( declaration, args, expression_type, need_name, need_qualifier, need_parenthesis_after_name, associated_class_unknown );</span></a>
<a name="7629"><span class="lineNum">    7629 </span><span class="lineCov">       1068 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="7630"><span class="lineNum">    7630 </span>            : </a>
<a name="7631"><span class="lineNum">    7631 </span><span class="lineCov">       1068 :      setOneSourcePositionNull(result);</span></a>
<a name="7632"><span class="lineNum">    7632 </span>            : </a>
<a name="7633"><span class="lineNum">    7633 </span><span class="lineCov">       1068 :      if (args != NULL)</span></a>
<a name="7634"><span class="lineNum">    7634 </span>            :         {</a>
<a name="7635"><span class="lineNum">    7635 </span><span class="lineNoCov">          0 :           args-&gt;set_parent(result);</span></a>
<a name="7636"><span class="lineNum">    7636 </span>            :         }</a>
<a name="7637"><span class="lineNum">    7637 </span>            : </a>
<a name="7638"><span class="lineNum">    7638 </span>            :   // DQ (11/4/2012): This is required and appears to work fine now.</a>
<a name="7639"><span class="lineNum">    7639 </span>            :   // DQ (11/23/2011): Fixup the expression list (but this does not appear to work...)</a>
<a name="7640"><span class="lineNum">    7640 </span><span class="lineCov">       1068 :      if (result-&gt;get_args()-&gt;get_startOfConstruct() == NULL)</span></a>
<a name="7641"><span class="lineNum">    7641 </span>            :        {</a>
<a name="7642"><span class="lineNum">    7642 </span>            : #if 0</a>
<a name="7643"><span class="lineNum">    7643 </span>            :          printf (&quot;In buildConstructorInitializer_nfi(): Fixup the source position of result-&gt;get_args() \n&quot;);</a>
<a name="7644"><span class="lineNum">    7644 </span>            : #endif</a>
<a name="7645"><span class="lineNum">    7645 </span><span class="lineCov">       1068 :          setOneSourcePositionNull(result-&gt;get_args());</span></a>
<a name="7646"><span class="lineNum">    7646 </span>            :        }</a>
<a name="7647"><span class="lineNum">    7647 </span>            : </a>
<a name="7648"><span class="lineNum">    7648 </span><span class="lineCov">       1068 :      return result;</span></a>
<a name="7649"><span class="lineNum">    7649 </span>            :    }</a>
<a name="7650"><span class="lineNum">    7650 </span>            : </a>
<a name="7651"><span class="lineNum">    7651 </span>            : // DQ (11/15/2016):Adding support for braced initializer (required for template support).</a>
<a name="7652"><span class="lineNum">    7652 </span>            : //! Build an braced initializer</a>
<a name="7653"><span class="lineNum">    7653 </span>            : SgBracedInitializer*</a>
<a name="7654"><span class="lineNum">    7654 </span><span class="lineCov">         10 : SageBuilder::buildBracedInitializer(SgExprListExp * initializers, SgType * expression_type )</span></a>
<a name="7655"><span class="lineNum">    7655 </span>            :    {</a>
<a name="7656"><span class="lineNum">    7656 </span><span class="lineCov">         10 :      SgBracedInitializer* result = new SgBracedInitializer(initializers, expression_type);</span></a>
<a name="7657"><span class="lineNum">    7657 </span><span class="lineCov">         10 :      ROSE_ASSERT(result);</span></a>
<a name="7658"><span class="lineNum">    7658 </span><span class="lineCov">         10 :      if (initializers!=NULL)</span></a>
<a name="7659"><span class="lineNum">    7659 </span>            :         {</a>
<a name="7660"><span class="lineNum">    7660 </span><span class="lineCov">         10 :           initializers-&gt;set_parent(result);</span></a>
<a name="7661"><span class="lineNum">    7661 </span>            :         }</a>
<a name="7662"><span class="lineNum">    7662 </span><span class="lineCov">         10 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7663"><span class="lineNum">    7663 </span><span class="lineCov">         10 :      return result;</span></a>
<a name="7664"><span class="lineNum">    7664 </span>            :    }</a>
<a name="7665"><span class="lineNum">    7665 </span>            : </a>
<a name="7666"><span class="lineNum">    7666 </span><span class="lineNoCov">          0 : SgBracedInitializer* SageBuilder::buildBracedInitializer_nfi(SgExprListExp * initializers, SgType * expression_type )</span></a>
<a name="7667"><span class="lineNum">    7667 </span>            :    {</a>
<a name="7668"><span class="lineNum">    7668 </span><span class="lineNoCov">          0 :      SgBracedInitializer* result = new SgBracedInitializer(initializers, expression_type);</span></a>
<a name="7669"><span class="lineNum">    7669 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="7670"><span class="lineNum">    7670 </span><span class="lineNoCov">          0 :      if (initializers!=NULL)</span></a>
<a name="7671"><span class="lineNum">    7671 </span>            :         {</a>
<a name="7672"><span class="lineNum">    7672 </span><span class="lineNoCov">          0 :           initializers-&gt;set_parent(result);</span></a>
<a name="7673"><span class="lineNum">    7673 </span>            :         }</a>
<a name="7674"><span class="lineNum">    7674 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="7675"><span class="lineNum">    7675 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="7676"><span class="lineNum">    7676 </span>            :    }</a>
<a name="7677"><span class="lineNum">    7677 </span>            : </a>
<a name="7678"><span class="lineNum">    7678 </span>            : </a>
<a name="7679"><span class="lineNum">    7679 </span>            : //! Build sizeof() expression with an expression parameter</a>
<a name="7680"><span class="lineNum">    7680 </span><span class="lineCov">          1 : SgSizeOfOp* SageBuilder::buildSizeOfOp(SgExpression* exp/*= NULL*/)</span></a>
<a name="7681"><span class="lineNum">    7681 </span>            :    {</a>
<a name="7682"><span class="lineNum">    7682 </span>            :   // SgType* exp_type = NULL;</a>
<a name="7683"><span class="lineNum">    7683 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7684"><span class="lineNum">    7684 </span>            : </a>
<a name="7685"><span class="lineNum">    7685 </span><span class="lineCov">          1 :      SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, NULL);</span></a>
<a name="7686"><span class="lineNum">    7686 </span>            :   // SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, exp_type);</a>
<a name="7687"><span class="lineNum">    7687 </span><span class="lineCov">          1 :      ROSE_ASSERT(result);</span></a>
<a name="7688"><span class="lineNum">    7688 </span><span class="lineCov">          1 :      if (exp)</span></a>
<a name="7689"><span class="lineNum">    7689 </span>            :         {</a>
<a name="7690"><span class="lineNum">    7690 </span><span class="lineCov">          1 :           exp-&gt;set_parent(result);</span></a>
<a name="7691"><span class="lineNum">    7691 </span><span class="lineCov">          1 :           markLhsValues(result);</span></a>
<a name="7692"><span class="lineNum">    7692 </span>            :         }</a>
<a name="7693"><span class="lineNum">    7693 </span><span class="lineCov">          1 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7694"><span class="lineNum">    7694 </span><span class="lineCov">          1 :      return result;</span></a>
<a name="7695"><span class="lineNum">    7695 </span>            :    }</a>
<a name="7696"><span class="lineNum">    7696 </span>            : </a>
<a name="7697"><span class="lineNum">    7697 </span>            : //! Build sizeof() expression with an expression parameter</a>
<a name="7698"><span class="lineNum">    7698 </span><span class="lineCov">         96 : SgSizeOfOp* SageBuilder::buildSizeOfOp_nfi(SgExpression* exp/*= NULL*/)</span></a>
<a name="7699"><span class="lineNum">    7699 </span>            :    {</a>
<a name="7700"><span class="lineNum">    7700 </span>            :   // SgType* exp_type =NULL;</a>
<a name="7701"><span class="lineNum">    7701 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7702"><span class="lineNum">    7702 </span>            : </a>
<a name="7703"><span class="lineNum">    7703 </span><span class="lineCov">         96 :      SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, NULL);</span></a>
<a name="7704"><span class="lineNum">    7704 </span>            :   // SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, exp_type);</a>
<a name="7705"><span class="lineNum">    7705 </span><span class="lineCov">         96 :      ROSE_ASSERT(result);</span></a>
<a name="7706"><span class="lineNum">    7706 </span><span class="lineCov">         96 :      if (exp)</span></a>
<a name="7707"><span class="lineNum">    7707 </span>            :         {</a>
<a name="7708"><span class="lineNum">    7708 </span><span class="lineCov">         96 :           exp-&gt;set_parent(result);</span></a>
<a name="7709"><span class="lineNum">    7709 </span><span class="lineCov">         96 :           markLhsValues(result);</span></a>
<a name="7710"><span class="lineNum">    7710 </span>            :         }</a>
<a name="7711"><span class="lineNum">    7711 </span><span class="lineCov">         96 :      setOneSourcePositionNull(result);</span></a>
<a name="7712"><span class="lineNum">    7712 </span><span class="lineCov">         96 :      return result;</span></a>
<a name="7713"><span class="lineNum">    7713 </span>            :    }</a>
<a name="7714"><span class="lineNum">    7714 </span>            : </a>
<a name="7715"><span class="lineNum">    7715 </span>            : //! Build sizeof() expression with a type parameter</a>
<a name="7716"><span class="lineNum">    7716 </span><span class="lineCov">          2 : SgSizeOfOp* SageBuilder::buildSizeOfOp(SgType* type /* = NULL*/)</span></a>
<a name="7717"><span class="lineNum">    7717 </span>            :    {</a>
<a name="7718"><span class="lineNum">    7718 </span><span class="lineCov">          2 :      SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,NULL);</span></a>
<a name="7719"><span class="lineNum">    7719 </span>            :   // SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,type);</a>
<a name="7720"><span class="lineNum">    7720 </span><span class="lineCov">          2 :      ROSE_ASSERT(result);</span></a>
<a name="7721"><span class="lineNum">    7721 </span><span class="lineCov">          2 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7722"><span class="lineNum">    7722 </span><span class="lineCov">          2 :      return result;</span></a>
<a name="7723"><span class="lineNum">    7723 </span>            :    }</a>
<a name="7724"><span class="lineNum">    7724 </span>            : </a>
<a name="7725"><span class="lineNum">    7725 </span>            : //! Build sizeof() expression with a type parameter</a>
<a name="7726"><span class="lineNum">    7726 </span><span class="lineCov">       2049 : SgSizeOfOp* SageBuilder::buildSizeOfOp_nfi(SgType* type /* = NULL*/)</span></a>
<a name="7727"><span class="lineNum">    7727 </span>            :    {</a>
<a name="7728"><span class="lineNum">    7728 </span><span class="lineCov">       2049 :      SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,NULL);</span></a>
<a name="7729"><span class="lineNum">    7729 </span>            :   // SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,type);</a>
<a name="7730"><span class="lineNum">    7730 </span><span class="lineCov">       2049 :      ROSE_ASSERT(result);</span></a>
<a name="7731"><span class="lineNum">    7731 </span><span class="lineCov">       2049 :      setOneSourcePositionNull(result);</span></a>
<a name="7732"><span class="lineNum">    7732 </span><span class="lineCov">       2049 :      return result;</span></a>
<a name="7733"><span class="lineNum">    7733 </span>            :    }</a>
<a name="7734"><span class="lineNum">    7734 </span>            : </a>
<a name="7735"><span class="lineNum">    7735 </span>            : //! Build __alignof__() expression with an expression parameter</a>
<a name="7736"><span class="lineNum">    7736 </span><span class="lineNoCov">          0 : SgAlignOfOp* SageBuilder::buildAlignOfOp(SgExpression* exp/*= NULL*/)</span></a>
<a name="7737"><span class="lineNum">    7737 </span>            :    {</a>
<a name="7738"><span class="lineNum">    7738 </span>            :   // SgType* exp_type =NULL;</a>
<a name="7739"><span class="lineNum">    7739 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7740"><span class="lineNum">    7740 </span>            : </a>
<a name="7741"><span class="lineNum">    7741 </span><span class="lineNoCov">          0 :      SgAlignOfOp* result = new SgAlignOfOp(exp,NULL, NULL);</span></a>
<a name="7742"><span class="lineNum">    7742 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="7743"><span class="lineNum">    7743 </span><span class="lineNoCov">          0 :      if (exp)</span></a>
<a name="7744"><span class="lineNum">    7744 </span>            :         {</a>
<a name="7745"><span class="lineNum">    7745 </span><span class="lineNoCov">          0 :           exp-&gt;set_parent(result);</span></a>
<a name="7746"><span class="lineNum">    7746 </span><span class="lineNoCov">          0 :           markLhsValues(result);</span></a>
<a name="7747"><span class="lineNum">    7747 </span>            :         }</a>
<a name="7748"><span class="lineNum">    7748 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7749"><span class="lineNum">    7749 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="7750"><span class="lineNum">    7750 </span>            :    }</a>
<a name="7751"><span class="lineNum">    7751 </span>            : </a>
<a name="7752"><span class="lineNum">    7752 </span>            : //! Build __alignof__() expression with an expression parameter</a>
<a name="7753"><span class="lineNum">    7753 </span><span class="lineNoCov">          0 : SgAlignOfOp* SageBuilder::buildAlignOfOp_nfi(SgExpression* exp/*= NULL*/)</span></a>
<a name="7754"><span class="lineNum">    7754 </span>            :    {</a>
<a name="7755"><span class="lineNum">    7755 </span>            :   // SgType* exp_type =NULL;</a>
<a name="7756"><span class="lineNum">    7756 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7757"><span class="lineNum">    7757 </span>            : </a>
<a name="7758"><span class="lineNum">    7758 </span><span class="lineNoCov">          0 :      SgAlignOfOp* result = new SgAlignOfOp(exp,NULL, NULL);</span></a>
<a name="7759"><span class="lineNum">    7759 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="7760"><span class="lineNum">    7760 </span><span class="lineNoCov">          0 :      if (exp)</span></a>
<a name="7761"><span class="lineNum">    7761 </span>            :         {</a>
<a name="7762"><span class="lineNum">    7762 </span><span class="lineNoCov">          0 :           exp-&gt;set_parent(result);</span></a>
<a name="7763"><span class="lineNum">    7763 </span><span class="lineNoCov">          0 :           markLhsValues(result);</span></a>
<a name="7764"><span class="lineNum">    7764 </span>            :         }</a>
<a name="7765"><span class="lineNum">    7765 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="7766"><span class="lineNum">    7766 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="7767"><span class="lineNum">    7767 </span>            :    }</a>
<a name="7768"><span class="lineNum">    7768 </span>            : </a>
<a name="7769"><span class="lineNum">    7769 </span>            : //! Build noexcept operator expression with an expression parameter</a>
<a name="7770"><span class="lineNum">    7770 </span><span class="lineNoCov">          0 : SgNoexceptOp* SageBuilder::buildNoexceptOp(SgExpression* exp/*= NULL*/)</span></a>
<a name="7771"><span class="lineNum">    7771 </span>            :    {</a>
<a name="7772"><span class="lineNum">    7772 </span>            :   // SgType* exp_type =NULL;</a>
<a name="7773"><span class="lineNum">    7773 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7774"><span class="lineNum">    7774 </span>            : </a>
<a name="7775"><span class="lineNum">    7775 </span><span class="lineNoCov">          0 :      SgNoexceptOp* result = new SgNoexceptOp(exp);</span></a>
<a name="7776"><span class="lineNum">    7776 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="7777"><span class="lineNum">    7777 </span><span class="lineNoCov">          0 :      if (exp)</span></a>
<a name="7778"><span class="lineNum">    7778 </span>            :         {</a>
<a name="7779"><span class="lineNum">    7779 </span><span class="lineNoCov">          0 :           exp-&gt;set_parent(result);</span></a>
<a name="7780"><span class="lineNum">    7780 </span><span class="lineNoCov">          0 :           markLhsValues(result);</span></a>
<a name="7781"><span class="lineNum">    7781 </span>            :         }</a>
<a name="7782"><span class="lineNum">    7782 </span>            : </a>
<a name="7783"><span class="lineNum">    7783 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7784"><span class="lineNum">    7784 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="7785"><span class="lineNum">    7785 </span>            :    }</a>
<a name="7786"><span class="lineNum">    7786 </span>            : </a>
<a name="7787"><span class="lineNum">    7787 </span>            : //! Build noexcept operator expression with an expression parameter</a>
<a name="7788"><span class="lineNum">    7788 </span><span class="lineCov">        183 : SgNoexceptOp* SageBuilder::buildNoexceptOp_nfi(SgExpression* exp/*= NULL*/)</span></a>
<a name="7789"><span class="lineNum">    7789 </span>            :    {</a>
<a name="7790"><span class="lineNum">    7790 </span>            :   // SgType* exp_type =NULL;</a>
<a name="7791"><span class="lineNum">    7791 </span>            :   // if (exp) exp_type = exp-&gt;get_type();</a>
<a name="7792"><span class="lineNum">    7792 </span>            : </a>
<a name="7793"><span class="lineNum">    7793 </span><span class="lineCov">        183 :      SgNoexceptOp* result = new SgNoexceptOp(exp);</span></a>
<a name="7794"><span class="lineNum">    7794 </span><span class="lineCov">        183 :      ROSE_ASSERT(result);</span></a>
<a name="7795"><span class="lineNum">    7795 </span><span class="lineCov">        183 :      if (exp)</span></a>
<a name="7796"><span class="lineNum">    7796 </span>            :         {</a>
<a name="7797"><span class="lineNum">    7797 </span><span class="lineCov">        183 :           exp-&gt;set_parent(result);</span></a>
<a name="7798"><span class="lineNum">    7798 </span><span class="lineCov">        183 :           markLhsValues(result);</span></a>
<a name="7799"><span class="lineNum">    7799 </span>            :         }</a>
<a name="7800"><span class="lineNum">    7800 </span>            : </a>
<a name="7801"><span class="lineNum">    7801 </span><span class="lineCov">        183 :      setOneSourcePositionNull(result);</span></a>
<a name="7802"><span class="lineNum">    7802 </span><span class="lineCov">        183 :      return result;</span></a>
<a name="7803"><span class="lineNum">    7803 </span>            :    }</a>
<a name="7804"><span class="lineNum">    7804 </span>            : </a>
<a name="7805"><span class="lineNum">    7805 </span>            : //! Build __alignof__() expression with a type parameter</a>
<a name="7806"><span class="lineNum">    7806 </span><span class="lineNoCov">          0 : SgAlignOfOp* SageBuilder::buildAlignOfOp(SgType* type /* = NULL*/)</span></a>
<a name="7807"><span class="lineNum">    7807 </span>            :    {</a>
<a name="7808"><span class="lineNum">    7808 </span><span class="lineNoCov">          0 :      SgAlignOfOp* result = new SgAlignOfOp((SgExpression*)NULL,type,NULL);</span></a>
<a name="7809"><span class="lineNum">    7809 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="7810"><span class="lineNum">    7810 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="7811"><span class="lineNum">    7811 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="7812"><span class="lineNum">    7812 </span>            :    }</a>
<a name="7813"><span class="lineNum">    7813 </span>            : </a>
<a name="7814"><span class="lineNum">    7814 </span>            : //! Build __alignof__() expression with a type parameter</a>
<a name="7815"><span class="lineNum">    7815 </span><span class="lineCov">         53 : SgAlignOfOp* SageBuilder::buildAlignOfOp_nfi(SgType* type /* = NULL*/)</span></a>
<a name="7816"><span class="lineNum">    7816 </span>            :    {</a>
<a name="7817"><span class="lineNum">    7817 </span><span class="lineCov">         53 :      SgAlignOfOp* result = new SgAlignOfOp((SgExpression*)NULL,type,NULL);</span></a>
<a name="7818"><span class="lineNum">    7818 </span><span class="lineCov">         53 :      ROSE_ASSERT(result);</span></a>
<a name="7819"><span class="lineNum">    7819 </span><span class="lineCov">         53 :      setOneSourcePositionNull(result);</span></a>
<a name="7820"><span class="lineNum">    7820 </span><span class="lineCov">         53 :      return result;</span></a>
<a name="7821"><span class="lineNum">    7821 </span>            :    }</a>
<a name="7822"><span class="lineNum">    7822 </span>            : </a>
<a name="7823"><span class="lineNum">    7823 </span>            : </a>
<a name="7824"><span class="lineNum">    7824 </span><span class="lineCov">        435 : SgExprListExp * SageBuilder::buildExprListExp(SgExpression * expr1, SgExpression* expr2, SgExpression* expr3, SgExpression* expr4, SgExpression* expr5, SgExpression* expr6, SgExpression* expr7, SgExpression* expr8, SgExpression* expr9, SgExpression* expr10)</span></a>
<a name="7825"><span class="lineNum">    7825 </span>            : {</a>
<a name="7826"><span class="lineNum">    7826 </span><span class="lineCov">        435 :   SgExprListExp* expList = new SgExprListExp();</span></a>
<a name="7827"><span class="lineNum">    7827 </span><span class="lineCov">        435 :   ROSE_ASSERT(expList);</span></a>
<a name="7828"><span class="lineNum">    7828 </span>            : </a>
<a name="7829"><span class="lineNum">    7829 </span>            : //  printf (&quot;In SageBuilder::buildExprListExp(SgExpression * expr1, SgExpression* expr2, ...): SgExprListExp* expList = %p \n&quot;,expList);</a>
<a name="7830"><span class="lineNum">    7830 </span>            : </a>
<a name="7831"><span class="lineNum">    7831 </span><span class="lineCov">        435 :   setOneSourcePositionForTransformation(expList);</span></a>
<a name="7832"><span class="lineNum">    7832 </span><span class="lineCov">        435 :   if (expr1) appendExpression(expList, expr1);</span></a>
<a name="7833"><span class="lineNum">    7833 </span><span class="lineCov">        435 :   if (expr2) appendExpression(expList, expr2);</span></a>
<a name="7834"><span class="lineNum">    7834 </span><span class="lineCov">        435 :   if (expr3) appendExpression(expList, expr3);</span></a>
<a name="7835"><span class="lineNum">    7835 </span><span class="lineCov">        435 :   if (expr4) appendExpression(expList, expr4);</span></a>
<a name="7836"><span class="lineNum">    7836 </span><span class="lineCov">        435 :   if (expr5) appendExpression(expList, expr5);</span></a>
<a name="7837"><span class="lineNum">    7837 </span><span class="lineCov">        435 :   if (expr6) appendExpression(expList, expr6);</span></a>
<a name="7838"><span class="lineNum">    7838 </span><span class="lineCov">        435 :   if (expr7) appendExpression(expList, expr7);</span></a>
<a name="7839"><span class="lineNum">    7839 </span><span class="lineCov">        435 :   if (expr8) appendExpression(expList, expr8);</span></a>
<a name="7840"><span class="lineNum">    7840 </span><span class="lineCov">        435 :   if (expr9) appendExpression(expList, expr9);</span></a>
<a name="7841"><span class="lineNum">    7841 </span><span class="lineCov">        435 :   if (expr10) appendExpression(expList, expr10);</span></a>
<a name="7842"><span class="lineNum">    7842 </span><span class="lineCov">        435 :   return expList;</span></a>
<a name="7843"><span class="lineNum">    7843 </span>            : }</a>
<a name="7844"><span class="lineNum">    7844 </span>            : </a>
<a name="7845"><span class="lineNum">    7845 </span>            : // CH (5/11/2010): Seems that this function is useful.</a>
<a name="7846"><span class="lineNum">    7846 </span><span class="lineNoCov">          0 : SgExprListExp * SageBuilder::buildExprListExp(const std::vector&lt;SgExpression*&gt;&amp; exprs)</span></a>
<a name="7847"><span class="lineNum">    7847 </span>            : {</a>
<a name="7848"><span class="lineNum">    7848 </span><span class="lineNoCov">          0 :   SgExprListExp* expList = new SgExprListExp();</span></a>
<a name="7849"><span class="lineNum">    7849 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(expList);</span></a>
<a name="7850"><span class="lineNum">    7850 </span>            : </a>
<a name="7851"><span class="lineNum">    7851 </span>            : #if 0</a>
<a name="7852"><span class="lineNum">    7852 </span>            :   printf (&quot;In SageBuilder::buildExprListExp(const std::vector&lt;SgExpression*&gt;&amp; exprs): SgExprListExp* expList = %p \n&quot;,expList);</a>
<a name="7853"><span class="lineNum">    7853 </span>            : #endif</a>
<a name="7854"><span class="lineNum">    7854 </span>            : </a>
<a name="7855"><span class="lineNum">    7855 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(expList);</span></a>
<a name="7856"><span class="lineNum">    7856 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; exprs.size(); ++i) {</span></a>
<a name="7857"><span class="lineNum">    7857 </span><span class="lineNoCov">          0 :     appendExpression(expList, exprs[i]);</span></a>
<a name="7858"><span class="lineNum">    7858 </span>            :   }</a>
<a name="7859"><span class="lineNum">    7859 </span><span class="lineNoCov">          0 :   return expList;</span></a>
<a name="7860"><span class="lineNum">    7860 </span>            : }</a>
<a name="7861"><span class="lineNum">    7861 </span>            : </a>
<a name="7862"><span class="lineNum">    7862 </span><span class="lineCov">       3808 : SgExprListExp * SageBuilder::buildExprListExp_nfi()</span></a>
<a name="7863"><span class="lineNum">    7863 </span>            :    {</a>
<a name="7864"><span class="lineNum">    7864 </span><span class="lineCov">       3808 :      SgExprListExp* expList = new SgExprListExp();</span></a>
<a name="7865"><span class="lineNum">    7865 </span><span class="lineCov">       3808 :      ROSE_ASSERT(expList);</span></a>
<a name="7866"><span class="lineNum">    7866 </span>            : </a>
<a name="7867"><span class="lineNum">    7867 </span>            : #if 0</a>
<a name="7868"><span class="lineNum">    7868 </span>            :      printf (&quot;In SageBuilder::buildExprListExp_nfi(): SgExprListExp* expList = %p \n&quot;,expList);</a>
<a name="7869"><span class="lineNum">    7869 </span>            : #endif</a>
<a name="7870"><span class="lineNum">    7870 </span>            : </a>
<a name="7871"><span class="lineNum">    7871 </span><span class="lineCov">       3808 :      setOneSourcePositionNull(expList);</span></a>
<a name="7872"><span class="lineNum">    7872 </span><span class="lineCov">       3808 :      return expList;</span></a>
<a name="7873"><span class="lineNum">    7873 </span>            :    }</a>
<a name="7874"><span class="lineNum">    7874 </span>            : </a>
<a name="7875"><span class="lineNum">    7875 </span><span class="lineCov">      32107 : SgExprListExp * SageBuilder::buildExprListExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; exprs)</span></a>
<a name="7876"><span class="lineNum">    7876 </span>            :    {</a>
<a name="7877"><span class="lineNum">    7877 </span><span class="lineCov">      32107 :      SgExprListExp* expList = new SgExprListExp();</span></a>
<a name="7878"><span class="lineNum">    7878 </span><span class="lineCov">      32107 :      ROSE_ASSERT(expList != NULL);</span></a>
<a name="7879"><span class="lineNum">    7879 </span>            : </a>
<a name="7880"><span class="lineNum">    7880 </span>            : #if 0</a>
<a name="7881"><span class="lineNum">    7881 </span>            :      printf (&quot;In SageBuilder::buildExprListExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; exprs): SgExprListExp* expList = %p expList-&gt;get_expressions().size() = %&quot; PRIuPTR &quot; \n&quot;,expList,expList-&gt;get_expressions().size());</a>
<a name="7882"><span class="lineNum">    7882 </span>            : #endif</a>
<a name="7883"><span class="lineNum">    7883 </span>            : </a>
<a name="7884"><span class="lineNum">    7884 </span><span class="lineCov">      32107 :      setOneSourcePositionNull(expList);</span></a>
<a name="7885"><span class="lineNum">    7885 </span><span class="lineCov">      69005 :      for (size_t i = 0; i &lt; exprs.size(); ++i)</span></a>
<a name="7886"><span class="lineNum">    7886 </span>            :         {</a>
<a name="7887"><span class="lineNum">    7887 </span>            : #if 0</a>
<a name="7888"><span class="lineNum">    7888 </span>            :           printf (&quot;In SageBuilder::buildExprListExp_nfi(): exprs[i=%&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,exprs[i],exprs[i]-&gt;class_name().c_str());</a>
<a name="7889"><span class="lineNum">    7889 </span>            : #endif</a>
<a name="7890"><span class="lineNum">    7890 </span><span class="lineCov">      36898 :           appendExpression(expList, exprs[i]);</span></a>
<a name="7891"><span class="lineNum">    7891 </span>            :         }</a>
<a name="7892"><span class="lineNum">    7892 </span>            : </a>
<a name="7893"><span class="lineNum">    7893 </span>            :   // DQ (4/3/2012): Added test to make sure that the pointers are unique.</a>
<a name="7894"><span class="lineNum">    7894 </span><span class="lineCov">      32107 :      testAstForUniqueNodes(expList);</span></a>
<a name="7895"><span class="lineNum">    7895 </span>            : </a>
<a name="7896"><span class="lineNum">    7896 </span><span class="lineCov">      32107 :      return expList;</span></a>
<a name="7897"><span class="lineNum">    7897 </span>            :    }</a>
<a name="7898"><span class="lineNum">    7898 </span>            : </a>
<a name="7899"><span class="lineNum">    7899 </span>            : SgSubscriptExpression*</a>
<a name="7900"><span class="lineNum">    7900 </span><span class="lineNoCov">          0 : SageBuilder::buildSubscriptExpression_nfi(SgExpression* lower_bound, SgExpression* upper_bound, SgExpression* stride)</span></a>
<a name="7901"><span class="lineNum">    7901 </span>            :    {</a>
<a name="7902"><span class="lineNum">    7902 </span><span class="lineNoCov">          0 :       if (lower_bound == NULL)</span></a>
<a name="7903"><span class="lineNum">    7903 </span>            :          {</a>
<a name="7904"><span class="lineNum">    7904 </span><span class="lineNoCov">          0 :             lower_bound = SageBuilder::buildNullExpression_nfi();</span></a>
<a name="7905"><span class="lineNum">    7905 </span>            :          }</a>
<a name="7906"><span class="lineNum">    7906 </span><span class="lineNoCov">          0 :       if (stride == NULL)</span></a>
<a name="7907"><span class="lineNum">    7907 </span>            :          {</a>
<a name="7908"><span class="lineNum">    7908 </span><span class="lineNoCov">          0 :             stride = SageBuilder::buildNullExpression_nfi();</span></a>
<a name="7909"><span class="lineNum">    7909 </span>            :          }</a>
<a name="7910"><span class="lineNum">    7910 </span>            : </a>
<a name="7911"><span class="lineNum">    7911 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(lower_bound);</span></a>
<a name="7912"><span class="lineNum">    7912 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(upper_bound);</span></a>
<a name="7913"><span class="lineNum">    7913 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(stride);</span></a>
<a name="7914"><span class="lineNum">    7914 </span>            : </a>
<a name="7915"><span class="lineNum">    7915 </span><span class="lineNoCov">          0 :       SgSubscriptExpression* subscript = new SgSubscriptExpression(lower_bound, upper_bound, stride);</span></a>
<a name="7916"><span class="lineNum">    7916 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(subscript);</span></a>
<a name="7917"><span class="lineNum">    7917 </span><span class="lineNoCov">          0 :       SageInterface::setSourcePosition(subscript);</span></a>
<a name="7918"><span class="lineNum">    7918 </span>            : </a>
<a name="7919"><span class="lineNum">    7919 </span>            :       // Set the parents of all the parts of the SgSubscriptExpression</a>
<a name="7920"><span class="lineNum">    7920 </span><span class="lineNoCov">          0 :       lower_bound-&gt;set_parent(subscript);</span></a>
<a name="7921"><span class="lineNum">    7921 </span><span class="lineNoCov">          0 :       upper_bound-&gt;set_parent(subscript);</span></a>
<a name="7922"><span class="lineNum">    7922 </span><span class="lineNoCov">          0 :       stride     -&gt;set_parent(subscript);</span></a>
<a name="7923"><span class="lineNum">    7923 </span>            : </a>
<a name="7924"><span class="lineNum">    7924 </span><span class="lineNoCov">          0 :       return subscript;</span></a>
<a name="7925"><span class="lineNum">    7925 </span>            :    }</a>
<a name="7926"><span class="lineNum">    7926 </span>            : </a>
<a name="7927"><span class="lineNum">    7927 </span>            : SgVarRefExp*</a>
<a name="7928"><span class="lineNum">    7928 </span><span class="lineCov">        767 : SageBuilder::buildVarRefExp(SgInitializedName* initname, SgScopeStatement* scope)</span></a>
<a name="7929"><span class="lineNum">    7929 </span>            :    {</a>
<a name="7930"><span class="lineNum">    7930 </span><span class="lineCov">        767 :      ROSE_ASSERT(initname);</span></a>
<a name="7931"><span class="lineNum">    7931 </span><span class="lineCov">        767 :      if (scope == NULL)</span></a>
<a name="7932"><span class="lineNum">    7932 </span><span class="lineCov">        739 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="7933"><span class="lineNum">    7933 </span>            :   // ROSE_ASSERT(scope != NULL); // we allow to build a dangling ref without symbol</a>
<a name="7934"><span class="lineNum">    7934 </span>            : </a>
<a name="7935"><span class="lineNum">    7935 </span><span class="lineCov">        767 :      SgVarRefExp *varRef = NULL;</span></a>
<a name="7936"><span class="lineNum">    7936 </span>            :   // there is assertion for get_scope() != NULL in get_symbol_from_symbol_table()</a>
<a name="7937"><span class="lineNum">    7937 </span><span class="lineCov">        767 :      SgSymbol* symbol = NULL;</span></a>
<a name="7938"><span class="lineNum">    7938 </span><span class="lineCov">        767 :      if (initname-&gt;get_scope()!=NULL)</span></a>
<a name="7939"><span class="lineNum">    7939 </span><span class="lineCov">        767 :           symbol = initname-&gt;get_symbol_from_symbol_table ();</span></a>
<a name="7940"><span class="lineNum">    7940 </span>            : </a>
<a name="7941"><span class="lineNum">    7941 </span><span class="lineCov">        767 :      if (symbol != NULL)</span></a>
<a name="7942"><span class="lineNum">    7942 </span>            :         {</a>
<a name="7943"><span class="lineNum">    7943 </span><span class="lineCov">        767 :           varRef = new SgVarRefExp(isSgVariableSymbol(symbol));</span></a>
<a name="7944"><span class="lineNum">    7944 </span><span class="lineCov">        767 :           setOneSourcePositionForTransformation(varRef);</span></a>
<a name="7945"><span class="lineNum">    7945 </span><span class="lineCov">        767 :           ROSE_ASSERT(varRef);</span></a>
<a name="7946"><span class="lineNum">    7946 </span>            :         }</a>
<a name="7947"><span class="lineNum">    7947 </span>            :        else</a>
<a name="7948"><span class="lineNum">    7948 </span>            :         {</a>
<a name="7949"><span class="lineNum">    7949 </span>            : #if 0</a>
<a name="7950"><span class="lineNum">    7950 </span>            :           printf (&quot;In SageBuilder::buildVarRefExp(): we might be reusing an existing SgVarRefExp \n&quot;);</a>
<a name="7951"><span class="lineNum">    7951 </span>            : #endif</a>
<a name="7952"><span class="lineNum">    7952 </span><span class="lineNoCov">          0 :           varRef = buildVarRefExp(initname-&gt;get_name(), scope);</span></a>
<a name="7953"><span class="lineNum">    7953 </span>            :         }</a>
<a name="7954"><span class="lineNum">    7954 </span>            : </a>
<a name="7955"><span class="lineNum">    7955 </span>            : #if 0</a>
<a name="7956"><span class="lineNum">    7956 </span>            :      printf (&quot;In SageBuilder::buildVarRefExp(): Returning SgVarRefExp = %p \n&quot;,varRef);</a>
<a name="7957"><span class="lineNum">    7957 </span>            : #endif</a>
<a name="7958"><span class="lineNum">    7958 </span>            : </a>
<a name="7959"><span class="lineNum">    7959 </span><span class="lineCov">        767 :      return varRef;</span></a>
<a name="7960"><span class="lineNum">    7960 </span>            :    }</a>
<a name="7961"><span class="lineNum">    7961 </span>            : </a>
<a name="7962"><span class="lineNum">    7962 </span>            : SgVarRefExp *</a>
<a name="7963"><span class="lineNum">    7963 </span><span class="lineCov">        189 : SageBuilder::buildVarRefExp(const char* varName, SgScopeStatement* scope)</span></a>
<a name="7964"><span class="lineNum">    7964 </span>            : {</a>
<a name="7965"><span class="lineNum">    7965 </span><span class="lineCov">        378 :    SgName name(varName);</span></a>
<a name="7966"><span class="lineNum">    7966 </span><span class="lineCov">        378 :    return buildVarRefExp(name,scope);</span></a>
<a name="7967"><span class="lineNum">    7967 </span>            : }</a>
<a name="7968"><span class="lineNum">    7968 </span>            : </a>
<a name="7969"><span class="lineNum">    7969 </span>            : SgVarRefExp *</a>
<a name="7970"><span class="lineNum">    7970 </span><span class="lineCov">         64 : SageBuilder::buildVarRefExp(const std::string&amp; varName, SgScopeStatement* scope)</span></a>
<a name="7971"><span class="lineNum">    7971 </span>            : //SageBuilder::buildVarRefExp(std::string&amp; varName, SgScopeStatement* scope=NULL)</a>
<a name="7972"><span class="lineNum">    7972 </span>            : {</a>
<a name="7973"><span class="lineNum">    7973 </span><span class="lineCov">        128 :   SgName name(varName);</span></a>
<a name="7974"><span class="lineNum">    7974 </span><span class="lineCov">        128 :   return buildVarRefExp(name,scope);</span></a>
<a name="7975"><span class="lineNum">    7975 </span>            : }</a>
<a name="7976"><span class="lineNum">    7976 </span>            : </a>
<a name="7977"><span class="lineNum">    7977 </span>            : SgVarRefExp *</a>
<a name="7978"><span class="lineNum">    7978 </span><span class="lineCov">        254 : SageBuilder::buildVarRefExp(const SgName&amp; name, SgScopeStatement* scope/*=NULL*/)</span></a>
<a name="7979"><span class="lineNum">    7979 </span>            :    {</a>
<a name="7980"><span class="lineNum">    7980 </span>            : #if 0</a>
<a name="7981"><span class="lineNum">    7981 </span>            :      printf (&quot;In SageBuilder::buildVarRefExp(): scope = %p = %s = %s \n&quot;,scope,scope-&gt;class_name().c_str(),get_name(scope).c_str());</a>
<a name="7982"><span class="lineNum">    7982 </span>            : #endif</a>
<a name="7983"><span class="lineNum">    7983 </span>            : </a>
<a name="7984"><span class="lineNum">    7984 </span><span class="lineCov">        254 :      if (scope == NULL)</span></a>
<a name="7985"><span class="lineNum">    7985 </span><span class="lineCov">         20 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="7986"><span class="lineNum">    7986 </span>            : </a>
<a name="7987"><span class="lineNum">    7987 </span>            :   // ROSE_ASSERT(scope != NULL); // we allow to build a dangling ref without symbol</a>
<a name="7988"><span class="lineNum">    7988 </span><span class="lineCov">        254 :      SgSymbol*         symbol    = NULL;</span></a>
<a name="7989"><span class="lineNum">    7989 </span><span class="lineCov">        254 :      SgVariableSymbol* varSymbol = NULL;</span></a>
<a name="7990"><span class="lineNum">    7990 </span>            : </a>
<a name="7991"><span class="lineNum">    7991 </span><span class="lineCov">        254 :      if (scope != NULL)</span></a>
<a name="7992"><span class="lineNum">    7992 </span>            :         {</a>
<a name="7993"><span class="lineNum">    7993 </span>            :        // DQ (12/30/2011): This is a bad idea for C++ since qualified names might indicate different scopes.</a>
<a name="7994"><span class="lineNum">    7994 </span>            :        // If the scope has been provided then is should be the correct scope.</a>
<a name="7995"><span class="lineNum">    7995 </span>            : #if 1</a>
<a name="7996"><span class="lineNum">    7996 </span>            :        // DQ (8/16/2013): Modified to use the new API supporting template parameters and template arguments, however</a>
<a name="7997"><span class="lineNum">    7997 </span>            :        // this should more likely be using lookupVariableSymbolInParentScopes() instead of lookupSymbolInParentScopes().</a>
<a name="7998"><span class="lineNum">    7998 </span>            :        // printf (&quot;In SageBuilder::buildVarRefExp(): switch from lookupSymbolInParentScopes() and lookupVariableSymbolInParentScopes() \n&quot;);</a>
<a name="7999"><span class="lineNum">    7999 </span>            :        // symbol = lookupSymbolInParentScopes(name,scope);</a>
<a name="8000"><span class="lineNum">    8000 </span><span class="lineCov">        248 :           symbol = lookupVariableSymbolInParentScopes(name,scope);</span></a>
<a name="8001"><span class="lineNum">    8001 </span>            : #else</a>
<a name="8002"><span class="lineNum">    8002 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="8003"><span class="lineNum">    8003 </span>            :           symbol = scope-&gt;lookup_variable_symbol(name);</a>
<a name="8004"><span class="lineNum">    8004 </span>            : #endif</a>
<a name="8005"><span class="lineNum">    8005 </span>            : #if 0</a>
<a name="8006"><span class="lineNum">    8006 </span>            :           printf (&quot;In SageBuilder::buildVarRefExp(): scope = %p = %s name = %s symbol = %p \n&quot;,scope,scope-&gt;class_name().c_str(),name.str(),symbol);</a>
<a name="8007"><span class="lineNum">    8007 </span>            : #endif</a>
<a name="8008"><span class="lineNum">    8008 </span>            : //        ROSE_ASSERT(symbol != NULL);</a>
<a name="8009"><span class="lineNum">    8009 </span>            :         }</a>
<a name="8010"><span class="lineNum">    8010 </span>            : </a>
<a name="8011"><span class="lineNum">    8011 </span><span class="lineCov">        248 :      if (symbol != NULL)</span></a>
<a name="8012"><span class="lineNum">    8012 </span>            :         {</a>
<a name="8013"><span class="lineNum">    8013 </span>            : #if 0</a>
<a name="8014"><span class="lineNum">    8014 </span>            :           printf (&quot;What type of symbol is this: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="8015"><span class="lineNum">    8015 </span>            : #endif</a>
<a name="8016"><span class="lineNum">    8016 </span><span class="lineCov">        222 :           varSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="8017"><span class="lineNum">    8017 </span>            :         }</a>
<a name="8018"><span class="lineNum">    8018 </span>            :        else</a>
<a name="8019"><span class="lineNum">    8019 </span>            :         {</a>
<a name="8020"><span class="lineNum">    8020 </span>            :        // if not found: put fake init name and symbol here and</a>
<a name="8021"><span class="lineNum">    8021 </span>            :        // waiting for a postProcessing phase to clean it up</a>
<a name="8022"><span class="lineNum">    8022 </span>            :        // two features: no scope and unknown type for initializedName</a>
<a name="8023"><span class="lineNum">    8023 </span><span class="lineCov">         32 :           SgInitializedName * name1 = buildInitializedName(name,SgTypeUnknown::createType());</span></a>
<a name="8024"><span class="lineNum">    8024 </span><span class="lineCov">         32 :           name1-&gt;set_scope(scope);  // buildInitializedName() does not set scope for various reasons</span></a>
<a name="8025"><span class="lineNum">    8025 </span><span class="lineCov">         32 :           name1-&gt;set_parent(scope);</span></a>
<a name="8026"><span class="lineNum">    8026 </span><span class="lineCov">         32 :           varSymbol = new SgVariableSymbol(name1);</span></a>
<a name="8027"><span class="lineNum">    8027 </span><span class="lineCov">         32 :           varSymbol-&gt;set_parent(scope);</span></a>
<a name="8028"><span class="lineNum">    8028 </span>            : </a>
<a name="8029"><span class="lineNum">    8029 </span>            :        // DQ (4/2/2012): Output a warning:</a>
<a name="8030"><span class="lineNum">    8030 </span>            : #if 0</a>
<a name="8031"><span class="lineNum">    8031 </span>            :           printf (&quot;WARNING: In SageBuilder::buildVarRefExp(): symbol not found so we built a SgVariableSymbol = %p (but not put into symbol table) \n&quot;,varSymbol);</a>
<a name="8032"><span class="lineNum">    8032 </span>            : #endif</a>
<a name="8033"><span class="lineNum">    8033 </span>            :         }</a>
<a name="8034"><span class="lineNum">    8034 </span>            : </a>
<a name="8035"><span class="lineNum">    8035 </span><span class="lineCov">        254 :      if (varSymbol == NULL)</span></a>
<a name="8036"><span class="lineNum">    8036 </span>            :         {</a>
<a name="8037"><span class="lineNum">    8037 </span><span class="lineNoCov">          0 :           printf (&quot;Error: varSymbol == NULL for name = %s \n&quot;,name.str());</span></a>
<a name="8038"><span class="lineNum">    8038 </span>            :         }</a>
<a name="8039"><span class="lineNum">    8039 </span><span class="lineCov">        254 :      ROSE_ASSERT(varSymbol != NULL);</span></a>
<a name="8040"><span class="lineNum">    8040 </span>            : </a>
<a name="8041"><span class="lineNum">    8041 </span><span class="lineCov">        254 :      SgVarRefExp *varRef = new SgVarRefExp(varSymbol);</span></a>
<a name="8042"><span class="lineNum">    8042 </span><span class="lineCov">        254 :      setOneSourcePositionForTransformation(varRef);</span></a>
<a name="8043"><span class="lineNum">    8043 </span><span class="lineCov">        254 :      ROSE_ASSERT(varRef != NULL);</span></a>
<a name="8044"><span class="lineNum">    8044 </span>            : </a>
<a name="8045"><span class="lineNum">    8045 </span><span class="lineCov">        254 :      ROSE_ASSERT (isSgVariableSymbol(varRef-&gt;get_symbol())-&gt;get_declaration()!=NULL);</span></a>
<a name="8046"><span class="lineNum">    8046 </span>            : #if 0</a>
<a name="8047"><span class="lineNum">    8047 </span>            :      printf (&quot;In SageBuilder::buildVarRefExp(const SgName&amp; name, SgScopeStatement* scope = %p): varRef = %p \n&quot;,scope,varRef);</a>
<a name="8048"><span class="lineNum">    8048 </span>            : #endif</a>
<a name="8049"><span class="lineNum">    8049 </span>            : </a>
<a name="8050"><span class="lineNum">    8050 </span><span class="lineCov">        254 :      return varRef;</span></a>
<a name="8051"><span class="lineNum">    8051 </span>            :    }</a>
<a name="8052"><span class="lineNum">    8052 </span>            : </a>
<a name="8053"><span class="lineNum">    8053 </span>            : //! Build a variable reference from an existing variable declaration. The assumption is a SgVariableDeclartion only declares one variable in the ROSE AST.</a>
<a name="8054"><span class="lineNum">    8054 </span>            : SgVarRefExp *</a>
<a name="8055"><span class="lineNum">    8055 </span><span class="lineCov">       1374 : SageBuilder::buildVarRefExp(SgVariableDeclaration* vardecl)</span></a>
<a name="8056"><span class="lineNum">    8056 </span>            :    {</a>
<a name="8057"><span class="lineNum">    8057 </span><span class="lineCov">       1374 :      SgVariableSymbol* symbol = getFirstVarSym(vardecl);</span></a>
<a name="8058"><span class="lineNum">    8058 </span><span class="lineCov">       1374 :      ROSE_ASSERT(symbol);</span></a>
<a name="8059"><span class="lineNum">    8059 </span>            : </a>
<a name="8060"><span class="lineNum">    8060 </span><span class="lineCov">       1374 :      return buildVarRefExp(symbol);</span></a>
<a name="8061"><span class="lineNum">    8061 </span>            :    }</a>
<a name="8062"><span class="lineNum">    8062 </span>            : </a>
<a name="8063"><span class="lineNum">    8063 </span>            : </a>
<a name="8064"><span class="lineNum">    8064 </span>            : SgVarRefExp *</a>
<a name="8065"><span class="lineNum">    8065 </span><span class="lineCov">       1430 : SageBuilder::buildVarRefExp(SgVariableSymbol* sym)</span></a>
<a name="8066"><span class="lineNum">    8066 </span>            :    {</a>
<a name="8067"><span class="lineNum">    8067 </span><span class="lineCov">       1430 :      SgVarRefExp *varRef = new SgVarRefExp(sym);</span></a>
<a name="8068"><span class="lineNum">    8068 </span><span class="lineCov">       1430 :      ROSE_ASSERT(varRef);</span></a>
<a name="8069"><span class="lineNum">    8069 </span>            : </a>
<a name="8070"><span class="lineNum">    8070 </span><span class="lineCov">       1430 :      setOneSourcePositionForTransformation(varRef);</span></a>
<a name="8071"><span class="lineNum">    8071 </span>            : </a>
<a name="8072"><span class="lineNum">    8072 </span>            : #if 0</a>
<a name="8073"><span class="lineNum">    8073 </span>            :      printf (&quot;In SageBuilder::buildVarRefExp(SgVariableSymbol* sym): Returning SgVarRefExp = %p \n&quot;,varRef);</a>
<a name="8074"><span class="lineNum">    8074 </span>            : #endif</a>
<a name="8075"><span class="lineNum">    8075 </span>            : </a>
<a name="8076"><span class="lineNum">    8076 </span><span class="lineCov">       1430 :      return varRef;</span></a>
<a name="8077"><span class="lineNum">    8077 </span>            :    }</a>
<a name="8078"><span class="lineNum">    8078 </span>            : </a>
<a name="8079"><span class="lineNum">    8079 </span>            : SgVarRefExp *</a>
<a name="8080"><span class="lineNum">    8080 </span><span class="lineCov">      70831 : SageBuilder::buildVarRefExp_nfi(SgVariableSymbol* sym)</span></a>
<a name="8081"><span class="lineNum">    8081 </span>            :    {</a>
<a name="8082"><span class="lineNum">    8082 </span><span class="lineCov">      70831 :      SgVarRefExp *varRef = new SgVarRefExp(sym);</span></a>
<a name="8083"><span class="lineNum">    8083 </span><span class="lineCov">      70831 :      ROSE_ASSERT(varRef);</span></a>
<a name="8084"><span class="lineNum">    8084 </span>            : </a>
<a name="8085"><span class="lineNum">    8085 </span><span class="lineCov">      70831 :      setOneSourcePositionNull(varRef);</span></a>
<a name="8086"><span class="lineNum">    8086 </span>            : </a>
<a name="8087"><span class="lineNum">    8087 </span>            : #if 0</a>
<a name="8088"><span class="lineNum">    8088 </span>            :      printf (&quot;In SageBuilder::buildVarRefExp_nfi(SgVariableSymbol* sym): Returning SgVarRefExp = %p \n&quot;,varRef);</a>
<a name="8089"><span class="lineNum">    8089 </span>            : #endif</a>
<a name="8090"><span class="lineNum">    8090 </span>            : </a>
<a name="8091"><span class="lineNum">    8091 </span><span class="lineCov">      70831 :      return varRef;</span></a>
<a name="8092"><span class="lineNum">    8092 </span>            :    }</a>
<a name="8093"><span class="lineNum">    8093 </span>            : </a>
<a name="8094"><span class="lineNum">    8094 </span>            : SgNonrealRefExp *</a>
<a name="8095"><span class="lineNum">    8095 </span><span class="lineCov">      16185 : SageBuilder::buildNonrealRefExp_nfi(SgNonrealSymbol * sym)</span></a>
<a name="8096"><span class="lineNum">    8096 </span>            :    {</a>
<a name="8097"><span class="lineNum">    8097 </span><span class="lineCov">      16185 :      SgNonrealRefExp * refexp = new SgNonrealRefExp(sym);</span></a>
<a name="8098"><span class="lineNum">    8098 </span><span class="lineCov">      16185 :      ROSE_ASSERT(refexp != NULL);</span></a>
<a name="8099"><span class="lineNum">    8099 </span><span class="lineCov">      16185 :      setOneSourcePositionNull(refexp);</span></a>
<a name="8100"><span class="lineNum">    8100 </span><span class="lineCov">      16185 :      return refexp;</span></a>
<a name="8101"><span class="lineNum">    8101 </span>            :    }</a>
<a name="8102"><span class="lineNum">    8102 </span>            : </a>
<a name="8103"><span class="lineNum">    8103 </span>            : //!Build a variable reference expression at scope to an opaque variable which has unknown information except for its name.  Used when referring to an internal variable defined in some headers of runtime libraries.(The headers are not yet inserted into the file during translation). Similar to buildOpaqueType();</a>
<a name="8104"><span class="lineNum">    8104 </span>            : /*! It will declare a hidden int varName  at the specified scope to cheat the AST consistence tests.</a>
<a name="8105"><span class="lineNum">    8105 </span>            :  */</a>
<a name="8106"><span class="lineNum">    8106 </span>            : SgVarRefExp*</a>
<a name="8107"><span class="lineNum">    8107 </span><span class="lineNoCov">          0 : SageBuilder::buildOpaqueVarRefExp(const std::string&amp; name,SgScopeStatement* scope/* =NULL */)</span></a>
<a name="8108"><span class="lineNum">    8108 </span>            :    {</a>
<a name="8109"><span class="lineNum">    8109 </span><span class="lineNoCov">          0 :      SgVarRefExp *result = NULL;</span></a>
<a name="8110"><span class="lineNum">    8110 </span>            : </a>
<a name="8111"><span class="lineNum">    8111 </span><span class="lineNoCov">          0 :      if (scope == NULL)</span></a>
<a name="8112"><span class="lineNum">    8112 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="8113"><span class="lineNum">    8113 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="8114"><span class="lineNum">    8114 </span>            : </a>
<a name="8115"><span class="lineNum">    8115 </span>            :   // DQ (8/16/2013): Modified to use the new API supporting template parameters and template arguments, however</a>
<a name="8116"><span class="lineNum">    8116 </span>            :   // this should more likely be using lookupVariableSymbolInParentScopes() instead of lookupSymbolInParentScopes().</a>
<a name="8117"><span class="lineNum">    8117 </span>            :   // SgSymbol * symbol = lookupSymbolInParentScopes(name,scope);</a>
<a name="8118"><span class="lineNum">    8118 </span><span class="lineNoCov">          0 :      SgSymbol * symbol = lookupVariableSymbolInParentScopes(name,scope);</span></a>
<a name="8119"><span class="lineNum">    8119 </span>            : </a>
<a name="8120"><span class="lineNum">    8120 </span><span class="lineNoCov">          0 :      if (symbol)</span></a>
<a name="8121"><span class="lineNum">    8121 </span>            :         {</a>
<a name="8122"><span class="lineNum">    8122 </span>            :        // Can be the same opaque var ref built before</a>
<a name="8123"><span class="lineNum">    8123 </span>            :        // cerr&lt;&lt;&quot;Error: trying to build an opaque var ref when the variable is actual explicit!&quot;&lt;&lt;endl;</a>
<a name="8124"><span class="lineNum">    8124 </span>            :        // ROSE_ASSERT(false);</a>
<a name="8125"><span class="lineNum">    8125 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(isSgVariableSymbol(symbol));</span></a>
<a name="8126"><span class="lineNum">    8126 </span><span class="lineNoCov">          0 :           result = buildVarRefExp(isSgVariableSymbol(symbol));</span></a>
<a name="8127"><span class="lineNum">    8127 </span>            : </a>
<a name="8128"><span class="lineNum">    8128 </span>            :        // DQ (4/2/2012): Output a warning:</a>
<a name="8129"><span class="lineNum">    8129 </span>            :        //   printf (&quot;WARNING: In SageBuilder::buildOpaqueVarRefExp(): proper symbol used to build SgVarRefExp = %p \n&quot;,result);</a>
<a name="8130"><span class="lineNum">    8130 </span>            :         }</a>
<a name="8131"><span class="lineNum">    8131 </span>            :        else</a>
<a name="8132"><span class="lineNum">    8132 </span>            :         {</a>
<a name="8133"><span class="lineNum">    8133 </span><span class="lineNoCov">          0 :          SgVariableDeclaration* fakeVar = buildVariableDeclaration(name, buildIntType(),NULL, scope);</span></a>
<a name="8134"><span class="lineNum">    8134 </span><span class="lineNoCov">          0 :          Sg_File_Info* file_info = fakeVar-&gt;get_file_info();</span></a>
<a name="8135"><span class="lineNum">    8135 </span>            : </a>
<a name="8136"><span class="lineNum">    8136 </span>            :       // TGWE (7/16/2014): on the advice of DQ who doesn't like the function at all</a>
<a name="8137"><span class="lineNum">    8137 </span><span class="lineNoCov">          0 :          fakeVar-&gt;set_parent(scope);</span></a>
<a name="8138"><span class="lineNum">    8138 </span>            : </a>
<a name="8139"><span class="lineNum">    8139 </span><span class="lineNoCov">          0 :          file_info-&gt;unsetOutputInCodeGeneration ();</span></a>
<a name="8140"><span class="lineNum">    8140 </span><span class="lineNoCov">          0 :          SgVariableSymbol* fakeSymbol = getFirstVarSym (fakeVar);</span></a>
<a name="8141"><span class="lineNum">    8141 </span><span class="lineNoCov">          0 :          result = buildVarRefExp(fakeSymbol);</span></a>
<a name="8142"><span class="lineNum">    8142 </span>            : </a>
<a name="8143"><span class="lineNum">    8143 </span>            :        // DQ (4/2/2012): Output a warning:</a>
<a name="8144"><span class="lineNum">    8144 </span>            :        //   printf (&quot;WARNING: In SageBuilder::buildOpaqueVarRefExp(): fake symbol generated to build SgVarRefExp = %p (but not put into symbol table) \n&quot;,result);</a>
<a name="8145"><span class="lineNum">    8145 </span>            :         }</a>
<a name="8146"><span class="lineNum">    8146 </span>            : </a>
<a name="8147"><span class="lineNum">    8147 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="8148"><span class="lineNum">    8148 </span>            :    } // buildOpaqueVarRefExp()</a>
<a name="8149"><span class="lineNum">    8149 </span>            : </a>
<a name="8150"><span class="lineNum">    8150 </span>            : </a>
<a name="8151"><span class="lineNum">    8151 </span>            : // DQ (9/4/2013): Added support for building compound literals (similar to a SgVarRefExp).</a>
<a name="8152"><span class="lineNum">    8152 </span>            : //! Build function for compound literals (uses a SgVariableSymbol and is similar to buildVarRefExp_nfi()).</a>
<a name="8153"><span class="lineNum">    8153 </span>            : SgCompoundLiteralExp*</a>
<a name="8154"><span class="lineNum">    8154 </span><span class="lineNoCov">          0 : SageBuilder::buildCompoundLiteralExp_nfi(SgVariableSymbol* varSymbol)</span></a>
<a name="8155"><span class="lineNum">    8155 </span>            :    {</a>
<a name="8156"><span class="lineNum">    8156 </span><span class="lineNoCov">          0 :      SgCompoundLiteralExp *compoundLiteral = new SgCompoundLiteralExp(varSymbol);</span></a>
<a name="8157"><span class="lineNum">    8157 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(compoundLiteral != NULL);</span></a>
<a name="8158"><span class="lineNum">    8158 </span>            : </a>
<a name="8159"><span class="lineNum">    8159 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(compoundLiteral);</span></a>
<a name="8160"><span class="lineNum">    8160 </span>            : </a>
<a name="8161"><span class="lineNum">    8161 </span>            : #if 0</a>
<a name="8162"><span class="lineNum">    8162 </span>            :      printf (&quot;In SageBuilder::buildCompoundLiteralExp_nfi(SgVariableSymbol* sym): Returning SgCompoundLiteralExp = %p \n&quot;,compoundLiteral);</a>
<a name="8163"><span class="lineNum">    8163 </span>            : #endif</a>
<a name="8164"><span class="lineNum">    8164 </span>            : </a>
<a name="8165"><span class="lineNum">    8165 </span><span class="lineNoCov">          0 :      return compoundLiteral;</span></a>
<a name="8166"><span class="lineNum">    8166 </span>            :    }</a>
<a name="8167"><span class="lineNum">    8167 </span>            : </a>
<a name="8168"><span class="lineNum">    8168 </span>            : // DQ (9/4/2013): Added support for building compound literals (similar to a SgVarRefExp).</a>
<a name="8169"><span class="lineNum">    8169 </span>            : //! Build function for compound literals (uses a SgVariableSymbol and is similar to buildVarRefExp()).</a>
<a name="8170"><span class="lineNum">    8170 </span>            : SgCompoundLiteralExp*</a>
<a name="8171"><span class="lineNum">    8171 </span><span class="lineNoCov">          0 : SageBuilder::buildCompoundLiteralExp(SgVariableSymbol* varSymbol)</span></a>
<a name="8172"><span class="lineNum">    8172 </span>            :    {</a>
<a name="8173"><span class="lineNum">    8173 </span><span class="lineNoCov">          0 :      SgCompoundLiteralExp *compoundLiteral = new SgCompoundLiteralExp(varSymbol);</span></a>
<a name="8174"><span class="lineNum">    8174 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(compoundLiteral != NULL);</span></a>
<a name="8175"><span class="lineNum">    8175 </span>            : </a>
<a name="8176"><span class="lineNum">    8176 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(compoundLiteral);</span></a>
<a name="8177"><span class="lineNum">    8177 </span>            : </a>
<a name="8178"><span class="lineNum">    8178 </span>            : #if 0</a>
<a name="8179"><span class="lineNum">    8179 </span>            :      printf (&quot;In SageBuilder::buildCompoundLiteralExp(SgVariableSymbol* sym): Returning SgCompoundLiteralExp = %p \n&quot;,compoundLiteral);</a>
<a name="8180"><span class="lineNum">    8180 </span>            : #endif</a>
<a name="8181"><span class="lineNum">    8181 </span>            : </a>
<a name="8182"><span class="lineNum">    8182 </span><span class="lineNoCov">          0 :      return compoundLiteral;</span></a>
<a name="8183"><span class="lineNum">    8183 </span>            :    }</a>
<a name="8184"><span class="lineNum">    8184 </span>            : </a>
<a name="8185"><span class="lineNum">    8185 </span>            : </a>
<a name="8186"><span class="lineNum">    8186 </span>            : //! Build a Fortran numeric label ref exp</a>
<a name="8187"><span class="lineNum">    8187 </span><span class="lineCov">          3 : SgLabelRefExp * SageBuilder::buildLabelRefExp(SgLabelSymbol * s)</span></a>
<a name="8188"><span class="lineNum">    8188 </span>            : {</a>
<a name="8189"><span class="lineNum">    8189 </span><span class="lineCov">          3 :    SgLabelRefExp * result= NULL;</span></a>
<a name="8190"><span class="lineNum">    8190 </span><span class="lineCov">          3 :    ROSE_ASSERT (s!= NULL);</span></a>
<a name="8191"><span class="lineNum">    8191 </span><span class="lineCov">          3 :    result = new SgLabelRefExp(s);</span></a>
<a name="8192"><span class="lineNum">    8192 </span><span class="lineCov">          3 :    ROSE_ASSERT (result != NULL);</span></a>
<a name="8193"><span class="lineNum">    8193 </span><span class="lineCov">          3 :    setOneSourcePositionForTransformation(result);</span></a>
<a name="8194"><span class="lineNum">    8194 </span><span class="lineCov">          3 :    return result;</span></a>
<a name="8195"><span class="lineNum">    8195 </span>            : }</a>
<a name="8196"><span class="lineNum">    8196 </span>            : </a>
<a name="8197"><span class="lineNum">    8197 </span>            : SgFunctionParameterList*</a>
<a name="8198"><span class="lineNum">    8198 </span><span class="lineCov">          4 : SageBuilder::buildFunctionParameterList(SgFunctionParameterTypeList * paraTypeList)</span></a>
<a name="8199"><span class="lineNum">    8199 </span>            : {</a>
<a name="8200"><span class="lineNum">    8200 </span><span class="lineCov">          4 :   SgFunctionParameterList* paraList = buildFunctionParameterList();</span></a>
<a name="8201"><span class="lineNum">    8201 </span><span class="lineCov">          4 :   if (paraTypeList==NULL) return paraList;</span></a>
<a name="8202"><span class="lineNum">    8202 </span>            : </a>
<a name="8203"><span class="lineNum">    8203 </span><span class="lineCov">          8 :   SgTypePtrList typeList = paraTypeList-&gt;get_arguments();</span></a>
<a name="8204"><span class="lineNum">    8204 </span><span class="lineCov">          4 :   SgTypePtrList::iterator i;</span></a>
<a name="8205"><span class="lineNum">    8205 </span><span class="lineCov">          6 :   for (i=typeList.begin();i!=typeList.end();i++)</span></a>
<a name="8206"><span class="lineNum">    8206 </span>            :   {</a>
<a name="8207"><span class="lineNum">    8207 </span><span class="lineCov">          2 :     SgInitializedName* arg = buildInitializedName(SgName(&quot;&quot;),(*i));</span></a>
<a name="8208"><span class="lineNum">    8208 </span><span class="lineCov">          2 :     appendArg(paraList,arg);</span></a>
<a name="8209"><span class="lineNum">    8209 </span>            :   }</a>
<a name="8210"><span class="lineNum">    8210 </span>            : </a>
<a name="8211"><span class="lineNum">    8211 </span><span class="lineCov">          4 :   return paraList;</span></a>
<a name="8212"><span class="lineNum">    8212 </span>            : }</a>
<a name="8213"><span class="lineNum">    8213 </span>            : </a>
<a name="8214"><span class="lineNum">    8214 </span>            : SgFunctionParameterList*</a>
<a name="8215"><span class="lineNum">    8215 </span><span class="lineNoCov">          0 : SageBuilder::buildFunctionParameterList_nfi(SgFunctionParameterTypeList * paraTypeList)</span></a>
<a name="8216"><span class="lineNum">    8216 </span>            : {</a>
<a name="8217"><span class="lineNum">    8217 </span><span class="lineNoCov">          0 :   SgFunctionParameterList* paraList = buildFunctionParameterList();</span></a>
<a name="8218"><span class="lineNum">    8218 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (paraList);</span></a>
<a name="8219"><span class="lineNum">    8219 </span><span class="lineNoCov">          0 :   SgTypePtrList typeList = paraTypeList-&gt;get_arguments();</span></a>
<a name="8220"><span class="lineNum">    8220 </span><span class="lineNoCov">          0 :   SgTypePtrList::iterator i;</span></a>
<a name="8221"><span class="lineNum">    8221 </span><span class="lineNoCov">          0 :   for (i=typeList.begin();i!=typeList.end();i++)</span></a>
<a name="8222"><span class="lineNum">    8222 </span>            :   {</a>
<a name="8223"><span class="lineNum">    8223 </span><span class="lineNoCov">          0 :     SgInitializedName* arg = buildInitializedName_nfi(SgName(&quot;&quot;),(*i),NULL);</span></a>
<a name="8224"><span class="lineNum">    8224 </span><span class="lineNoCov">          0 :     appendArg(paraList,arg);</span></a>
<a name="8225"><span class="lineNum">    8225 </span>            :   }</a>
<a name="8226"><span class="lineNum">    8226 </span><span class="lineNoCov">          0 :   return paraList;</span></a>
<a name="8227"><span class="lineNum">    8227 </span>            : }</a>
<a name="8228"><span class="lineNum">    8228 </span>            : </a>
<a name="8229"><span class="lineNum">    8229 </span>            : // lookup function symbol to create a reference to it</a>
<a name="8230"><span class="lineNum">    8230 </span>            : SgFunctionRefExp *</a>
<a name="8231"><span class="lineNum">    8231 </span><span class="lineCov">          6 : SageBuilder::buildFunctionRefExp(const SgName&amp; name,const SgType* funcType, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8232"><span class="lineNum">    8232 </span>            : {</a>
<a name="8233"><span class="lineNum">    8233 </span><span class="lineCov">          6 :   ROSE_ASSERT(funcType); // function type cannot be NULL</span></a>
<a name="8234"><span class="lineNum">    8234 </span><span class="lineCov">          6 :   SgFunctionType* func_type = isSgFunctionType(const_cast&lt;SgType*&gt;(funcType));</span></a>
<a name="8235"><span class="lineNum">    8235 </span><span class="lineCov">          6 :   ROSE_ASSERT(func_type);</span></a>
<a name="8236"><span class="lineNum">    8236 </span>            : </a>
<a name="8237"><span class="lineNum">    8237 </span><span class="lineCov">          6 :   bool isMemberFunc = isSgMemberFunctionType(func_type);</span></a>
<a name="8238"><span class="lineNum">    8238 </span>            : </a>
<a name="8239"><span class="lineNum">    8239 </span><span class="lineCov">          6 :   if (scope == NULL)</span></a>
<a name="8240"><span class="lineNum">    8240 </span><span class="lineNoCov">          0 :     scope = SageBuilder::topScopeStack();</span></a>
<a name="8241"><span class="lineNum">    8241 </span><span class="lineCov">          6 :   ROSE_ASSERT(scope != NULL);</span></a>
<a name="8242"><span class="lineNum">    8242 </span><span class="lineCov">          6 :   SgFunctionSymbol* symbol = lookupFunctionSymbolInParentScopes(name,func_type,scope);</span></a>
<a name="8243"><span class="lineNum">    8243 </span><span class="lineCov">          6 :   if (symbol == NULL)</span></a>
<a name="8244"><span class="lineNum">    8244 </span>            :     // in rare cases when function calls are inserted before any prototypes exist</a>
<a name="8245"><span class="lineNum">    8245 </span>            :   {</a>
<a name="8246"><span class="lineNum">    8246 </span><span class="lineCov">          4 :     SgType* return_type = func_type-&gt;get_return_type();</span></a>
<a name="8247"><span class="lineNum">    8247 </span><span class="lineCov">          4 :     SgFunctionParameterTypeList * paraTypeList = func_type-&gt;get_argument_list();</span></a>
<a name="8248"><span class="lineNum">    8248 </span><span class="lineCov">          4 :     SgFunctionParameterList *parList = buildFunctionParameterList(paraTypeList);</span></a>
<a name="8249"><span class="lineNum">    8249 </span>            : </a>
<a name="8250"><span class="lineNum">    8250 </span><span class="lineCov">          4 :     SgGlobal* globalscope = getGlobalScope(scope);</span></a>
<a name="8251"><span class="lineNum">    8251 </span>            : </a>
<a name="8252"><span class="lineNum">    8252 </span><span class="lineCov">          4 :     ROSE_ASSERT (isMemberFunc == false);  // Liao, 11/21/2012. We assume only regular functions can go into this if-body so we can insert them into global scope by default</span></a>
<a name="8253"><span class="lineNum">    8253 </span>            :  // TODO: consider C++ template functions and Fortran functions</a>
<a name="8254"><span class="lineNum">    8254 </span>            :  // SgFunctionDeclaration * funcDecl= buildNondefiningFunctionDeclaration(name,return_type,parList,globalscope);</a>
<a name="8255"><span class="lineNum">    8255 </span>            :  // SgFunctionDeclaration * funcDecl = buildNondefiningFunctionDeclaration_T &lt;SgFunctionDeclaration&gt;(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL);</a>
<a name="8256"><span class="lineNum">    8256 </span>            : </a>
<a name="8257"><span class="lineNum">    8257 </span>            :  // TODO: consider C++ template functions</a>
<a name="8258"><span class="lineNum">    8258 </span><span class="lineCov">          4 :     SgFunctionDeclaration * funcDecl = NULL;</span></a>
<a name="8259"><span class="lineNum">    8259 </span><span class="lineCov">          4 :     if (SageInterface::is_Fortran_language())</span></a>
<a name="8260"><span class="lineNum">    8260 </span>            :        {</a>
<a name="8261"><span class="lineNum">    8261 </span>            :       // DQ (8/21/2013): Fixed number of parameters in buildNondefiningFunctionDeclaration_T() function call.</a>
<a name="8262"><span class="lineNum">    8262 </span><span class="lineCov">          2 :          funcDecl = buildNondefiningFunctionDeclaration_T &lt;SgProcedureHeaderStatement&gt;(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL, SgStorageModifier::e_default);</span></a>
<a name="8263"><span class="lineNum">    8263 </span>            :        }</a>
<a name="8264"><span class="lineNum">    8264 </span>            :       else</a>
<a name="8265"><span class="lineNum">    8265 </span>            :        {</a>
<a name="8266"><span class="lineNum">    8266 </span>            :       // DQ (8/21/2013): Fixed number of parameters in buildNondefiningFunctionDeclaration_T() function call.</a>
<a name="8267"><span class="lineNum">    8267 </span><span class="lineCov">          2 :           funcDecl = buildNondefiningFunctionDeclaration_T &lt;SgFunctionDeclaration&gt;(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL, SgStorageModifier::e_default);</span></a>
<a name="8268"><span class="lineNum">    8268 </span>            :        }</a>
<a name="8269"><span class="lineNum">    8269 </span>            : </a>
<a name="8270"><span class="lineNum">    8270 </span><span class="lineCov">          4 :     funcDecl-&gt;get_declarationModifier().get_storageModifier().setExtern();</span></a>
<a name="8271"><span class="lineNum">    8271 </span>            : </a>
<a name="8272"><span class="lineNum">    8272 </span>            :     // This will conflict with prototype in a header</a>
<a name="8273"><span class="lineNum">    8273 </span>            :     // prepend_statement(globalscope,funcDecl);</a>
<a name="8274"><span class="lineNum">    8274 </span>            :     // Prepend a function prototype declaration in current scope, hide it from the unparser</a>
<a name="8275"><span class="lineNum">    8275 </span>            :     // prependStatement(funcDecl,scope);</a>
<a name="8276"><span class="lineNum">    8276 </span>            :     // Sg_File_Info* file_info = funcDecl-&gt;get_file_info();</a>
<a name="8277"><span class="lineNum">    8277 </span>            :     // file_info-&gt;unsetOutputInCodeGeneration ();</a>
<a name="8278"><span class="lineNum">    8278 </span>            : </a>
<a name="8279"><span class="lineNum">    8279 </span><span class="lineCov">          4 :     symbol = lookupFunctionSymbolInParentScopes(name,func_type,scope);</span></a>
<a name="8280"><span class="lineNum">    8280 </span><span class="lineCov">          4 :     ROSE_ASSERT(symbol);</span></a>
<a name="8281"><span class="lineNum">    8281 </span>            :   }</a>
<a name="8282"><span class="lineNum">    8282 </span><span class="lineCov">          6 :   SgFunctionRefExp* func_ref = new SgFunctionRefExp(symbol,func_type);</span></a>
<a name="8283"><span class="lineNum">    8283 </span><span class="lineCov">          6 :   setOneSourcePositionForTransformation(func_ref);</span></a>
<a name="8284"><span class="lineNum">    8284 </span>            : </a>
<a name="8285"><span class="lineNum">    8285 </span><span class="lineCov">          6 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8286"><span class="lineNum">    8286 </span><span class="lineCov">          6 :   return func_ref;</span></a>
<a name="8287"><span class="lineNum">    8287 </span>            : }</a>
<a name="8288"><span class="lineNum">    8288 </span>            : </a>
<a name="8289"><span class="lineNum">    8289 </span>            : SgFunctionRefExp *</a>
<a name="8290"><span class="lineNum">    8290 </span><span class="lineCov">          2 : SageBuilder::buildFunctionRefExp(const char* name,const SgType* funcType, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8291"><span class="lineNum">    8291 </span>            : {</a>
<a name="8292"><span class="lineNum">    8292 </span><span class="lineCov">          4 :   SgName name2(name);</span></a>
<a name="8293"><span class="lineNum">    8293 </span><span class="lineCov">          4 :   return buildFunctionRefExp(name2,funcType,scope);</span></a>
<a name="8294"><span class="lineNum">    8294 </span>            : }</a>
<a name="8295"><span class="lineNum">    8295 </span>            : </a>
<a name="8296"><span class="lineNum">    8296 </span>            : // lookup function symbol to create a reference to it</a>
<a name="8297"><span class="lineNum">    8297 </span>            : SgFunctionRefExp *</a>
<a name="8298"><span class="lineNum">    8298 </span><span class="lineNoCov">          0 : SageBuilder::buildFunctionRefExp(const SgFunctionDeclaration* func_decl)</span></a>
<a name="8299"><span class="lineNum">    8299 </span>            : {</a>
<a name="8300"><span class="lineNum">    8300 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(func_decl != NULL);</span></a>
<a name="8301"><span class="lineNum">    8301 </span><span class="lineNoCov">          0 :   SgDeclarationStatement* nondef_func = func_decl-&gt;get_firstNondefiningDeclaration ();</span></a>
<a name="8302"><span class="lineNum">    8302 </span><span class="lineNoCov">          0 :   SgDeclarationStatement* def_func = func_decl-&gt;get_definingDeclaration ();</span></a>
<a name="8303"><span class="lineNum">    8303 </span><span class="lineNoCov">          0 :   SgSymbol* symbol = NULL;</span></a>
<a name="8304"><span class="lineNum">    8304 </span><span class="lineNoCov">          0 :   if (nondef_func != NULL)</span></a>
<a name="8305"><span class="lineNum">    8305 </span>            :   {</a>
<a name="8306"><span class="lineNum">    8306 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(nondef_func!= NULL);</span></a>
<a name="8307"><span class="lineNum">    8307 </span><span class="lineNoCov">          0 :     symbol = nondef_func-&gt;get_symbol_from_symbol_table();</span></a>
<a name="8308"><span class="lineNum">    8308 </span><span class="lineNoCov">          0 :     ROSE_ASSERT( symbol != NULL);</span></a>
<a name="8309"><span class="lineNum">    8309 </span>            :   }</a>
<a name="8310"><span class="lineNum">    8310 </span>            :   // Liao 12/1/2010. It is possible that there is no prototype declarations at all</a>
<a name="8311"><span class="lineNum">    8311 </span><span class="lineNoCov">          0 :   else if (def_func != NULL)</span></a>
<a name="8312"><span class="lineNum">    8312 </span>            :   {</a>
<a name="8313"><span class="lineNum">    8313 </span><span class="lineNoCov">          0 :     symbol = def_func-&gt;get_symbol_from_symbol_table();</span></a>
<a name="8314"><span class="lineNum">    8314 </span>            :   }</a>
<a name="8315"><span class="lineNum">    8315 </span>            :   else</a>
<a name="8316"><span class="lineNum">    8316 </span>            :   {</a>
<a name="8317"><span class="lineNum">    8317 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Fatal error: SageBuilder::buildFunctionRefExp():defining and nondefining declarations for a function cannot be both NULL&quot;&lt;&lt;endl;</span></a>
<a name="8318"><span class="lineNum">    8318 </span><span class="lineNoCov">          0 :     ROSE_ABORT ();</span></a>
<a name="8319"><span class="lineNum">    8319 </span>            :   }</a>
<a name="8320"><span class="lineNum">    8320 </span><span class="lineNoCov">          0 :   ROSE_ASSERT( symbol != NULL);</span></a>
<a name="8321"><span class="lineNum">    8321 </span><span class="lineNoCov">          0 :   return buildFunctionRefExp( isSgFunctionSymbol (symbol));</span></a>
<a name="8322"><span class="lineNum">    8322 </span>            : }</a>
<a name="8323"><span class="lineNum">    8323 </span>            : </a>
<a name="8324"><span class="lineNum">    8324 </span>            : </a>
<a name="8325"><span class="lineNum">    8325 </span>            : // lookup function symbol to create a reference to it</a>
<a name="8326"><span class="lineNum">    8326 </span>            : SgFunctionRefExp *</a>
<a name="8327"><span class="lineNum">    8327 </span><span class="lineCov">          8 : SageBuilder::buildFunctionRefExp(SgFunctionSymbol* sym)</span></a>
<a name="8328"><span class="lineNum">    8328 </span>            : {</a>
<a name="8329"><span class="lineNum">    8329 </span><span class="lineCov">          8 :   SgFunctionRefExp* func_ref = new SgFunctionRefExp(sym, NULL);</span></a>
<a name="8330"><span class="lineNum">    8330 </span><span class="lineCov">          8 :   setOneSourcePositionForTransformation(func_ref);</span></a>
<a name="8331"><span class="lineNum">    8331 </span><span class="lineCov">          8 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8332"><span class="lineNum">    8332 </span><span class="lineCov">          8 :   return func_ref;</span></a>
<a name="8333"><span class="lineNum">    8333 </span>            : }</a>
<a name="8334"><span class="lineNum">    8334 </span>            : </a>
<a name="8335"><span class="lineNum">    8335 </span>            : // lookup function symbol to create a reference to it</a>
<a name="8336"><span class="lineNum">    8336 </span>            : SgFunctionRefExp *</a>
<a name="8337"><span class="lineNum">    8337 </span><span class="lineCov">       7300 : SageBuilder::buildFunctionRefExp_nfi(SgFunctionSymbol* sym)</span></a>
<a name="8338"><span class="lineNum">    8338 </span>            : {</a>
<a name="8339"><span class="lineNum">    8339 </span><span class="lineCov">       7300 :   SgFunctionRefExp* func_ref = new SgFunctionRefExp(sym, NULL);</span></a>
<a name="8340"><span class="lineNum">    8340 </span><span class="lineCov">       7300 :   setOneSourcePositionNull(func_ref);</span></a>
<a name="8341"><span class="lineNum">    8341 </span><span class="lineCov">       7300 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8342"><span class="lineNum">    8342 </span><span class="lineCov">       7300 :   return func_ref;</span></a>
<a name="8343"><span class="lineNum">    8343 </span>            : }</a>
<a name="8344"><span class="lineNum">    8344 </span>            : </a>
<a name="8345"><span class="lineNum">    8345 </span>            : // DQ (12/15/2011): Adding template declaration support to the AST.</a>
<a name="8346"><span class="lineNum">    8346 </span>            : SgTemplateFunctionRefExp *</a>
<a name="8347"><span class="lineNum">    8347 </span><span class="lineCov">       2786 : SageBuilder::buildTemplateFunctionRefExp_nfi(SgTemplateFunctionSymbol* sym)</span></a>
<a name="8348"><span class="lineNum">    8348 </span>            :    {</a>
<a name="8349"><span class="lineNum">    8349 </span>            :   // DQ (2/23/2013): Added assertion.</a>
<a name="8350"><span class="lineNum">    8350 </span><span class="lineCov">       2786 :      ROSE_ASSERT(sym != NULL);</span></a>
<a name="8351"><span class="lineNum">    8351 </span>            : </a>
<a name="8352"><span class="lineNum">    8352 </span><span class="lineCov">       2786 :      SgTemplateFunctionRefExp* func_ref = new SgTemplateFunctionRefExp(sym);</span></a>
<a name="8353"><span class="lineNum">    8353 </span><span class="lineCov">       2786 :      ROSE_ASSERT(func_ref != NULL);</span></a>
<a name="8354"><span class="lineNum">    8354 </span>            : </a>
<a name="8355"><span class="lineNum">    8355 </span><span class="lineCov">       2786 :      setOneSourcePositionNull(func_ref);</span></a>
<a name="8356"><span class="lineNum">    8356 </span>            : </a>
<a name="8357"><span class="lineNum">    8357 </span>            :   // DQ (2/23/2013): Added assertion.</a>
<a name="8358"><span class="lineNum">    8358 </span><span class="lineCov">       2786 :      ROSE_ASSERT(func_ref-&gt;get_symbol() != NULL);</span></a>
<a name="8359"><span class="lineNum">    8359 </span>            : </a>
<a name="8360"><span class="lineNum">    8360 </span><span class="lineCov">       2786 :      return func_ref;</span></a>
<a name="8361"><span class="lineNum">    8361 </span>            :    }</a>
<a name="8362"><span class="lineNum">    8362 </span>            : </a>
<a name="8363"><span class="lineNum">    8363 </span>            : // DQ (12/29/2011): Adding template declaration support to the AST.</a>
<a name="8364"><span class="lineNum">    8364 </span>            : SgTemplateMemberFunctionRefExp *</a>
<a name="8365"><span class="lineNum">    8365 </span><span class="lineCov">       7078 : SageBuilder::buildTemplateMemberFunctionRefExp_nfi(SgTemplateMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)</span></a>
<a name="8366"><span class="lineNum">    8366 </span>            :    {</a>
<a name="8367"><span class="lineNum">    8367 </span><span class="lineCov">       7078 :      SgTemplateMemberFunctionRefExp* func_ref = new SgTemplateMemberFunctionRefExp(sym, virtual_call, need_qualifier);</span></a>
<a name="8368"><span class="lineNum">    8368 </span><span class="lineCov">       7078 :      setOneSourcePositionNull(func_ref);</span></a>
<a name="8369"><span class="lineNum">    8369 </span><span class="lineCov">       7078 :      ROSE_ASSERT(func_ref);</span></a>
<a name="8370"><span class="lineNum">    8370 </span><span class="lineCov">       7078 :      return func_ref;</span></a>
<a name="8371"><span class="lineNum">    8371 </span>            :    }</a>
<a name="8372"><span class="lineNum">    8372 </span>            : </a>
<a name="8373"><span class="lineNum">    8373 </span>            : // lookup member function symbol to create a reference to it</a>
<a name="8374"><span class="lineNum">    8374 </span>            : SgMemberFunctionRefExp *</a>
<a name="8375"><span class="lineNum">    8375 </span><span class="lineCov">       4659 : SageBuilder::buildMemberFunctionRefExp_nfi(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)</span></a>
<a name="8376"><span class="lineNum">    8376 </span>            : {</a>
<a name="8377"><span class="lineNum">    8377 </span><span class="lineCov">       4659 :   SgMemberFunctionRefExp* func_ref = new SgMemberFunctionRefExp(sym, virtual_call, NULL, need_qualifier);</span></a>
<a name="8378"><span class="lineNum">    8378 </span><span class="lineCov">       4659 :   setOneSourcePositionNull(func_ref);</span></a>
<a name="8379"><span class="lineNum">    8379 </span><span class="lineCov">       4659 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8380"><span class="lineNum">    8380 </span><span class="lineCov">       4659 :   return func_ref;</span></a>
<a name="8381"><span class="lineNum">    8381 </span>            : }</a>
<a name="8382"><span class="lineNum">    8382 </span>            : </a>
<a name="8383"><span class="lineNum">    8383 </span>            : // lookup member function symbol to create a reference to it</a>
<a name="8384"><span class="lineNum">    8384 </span>            : SgMemberFunctionRefExp *</a>
<a name="8385"><span class="lineNum">    8385 </span><span class="lineNoCov">          0 : SageBuilder::buildMemberFunctionRefExp(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)</span></a>
<a name="8386"><span class="lineNum">    8386 </span>            : {</a>
<a name="8387"><span class="lineNum">    8387 </span><span class="lineNoCov">          0 :   SgMemberFunctionRefExp* func_ref = new SgMemberFunctionRefExp(sym, virtual_call, NULL, need_qualifier);</span></a>
<a name="8388"><span class="lineNum">    8388 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(func_ref);</span></a>
<a name="8389"><span class="lineNum">    8389 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8390"><span class="lineNum">    8390 </span><span class="lineNoCov">          0 :   return func_ref;</span></a>
<a name="8391"><span class="lineNum">    8391 </span>            : }</a>
<a name="8392"><span class="lineNum">    8392 </span>            : </a>
<a name="8393"><span class="lineNum">    8393 </span>            : // lookup class symbol to create a reference to it</a>
<a name="8394"><span class="lineNum">    8394 </span>            : SgClassNameRefExp *</a>
<a name="8395"><span class="lineNum">    8395 </span><span class="lineNoCov">          0 : SageBuilder::buildClassNameRefExp_nfi(SgClassSymbol* sym)</span></a>
<a name="8396"><span class="lineNum">    8396 </span>            : {</a>
<a name="8397"><span class="lineNum">    8397 </span><span class="lineNoCov">          0 :   SgClassNameRefExp* class_ref = new SgClassNameRefExp(sym);</span></a>
<a name="8398"><span class="lineNum">    8398 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(class_ref);</span></a>
<a name="8399"><span class="lineNum">    8399 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(class_ref);</span></a>
<a name="8400"><span class="lineNum">    8400 </span><span class="lineNoCov">          0 :   return class_ref;</span></a>
<a name="8401"><span class="lineNum">    8401 </span>            : }</a>
<a name="8402"><span class="lineNum">    8402 </span>            : </a>
<a name="8403"><span class="lineNum">    8403 </span>            : SgClassNameRefExp *</a>
<a name="8404"><span class="lineNum">    8404 </span><span class="lineNoCov">          0 : SageBuilder::buildClassNameRefExp(SgClassSymbol* sym)</span></a>
<a name="8405"><span class="lineNum">    8405 </span>            : {</a>
<a name="8406"><span class="lineNum">    8406 </span><span class="lineNoCov">          0 :   SgClassNameRefExp* class_ref = new SgClassNameRefExp(sym);</span></a>
<a name="8407"><span class="lineNum">    8407 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(class_ref);</span></a>
<a name="8408"><span class="lineNum">    8408 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(class_ref);</span></a>
<a name="8409"><span class="lineNum">    8409 </span><span class="lineNoCov">          0 :   return class_ref;</span></a>
<a name="8410"><span class="lineNum">    8410 </span>            : }</a>
<a name="8411"><span class="lineNum">    8411 </span>            : </a>
<a name="8412"><span class="lineNum">    8412 </span>            : //! Lookup a C style function symbol to create a function reference expression to it</a>
<a name="8413"><span class="lineNum">    8413 </span>            : SgFunctionRefExp *</a>
<a name="8414"><span class="lineNum">    8414 </span><span class="lineCov">          1 : SageBuilder::buildFunctionRefExp(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8415"><span class="lineNum">    8415 </span>            : {</a>
<a name="8416"><span class="lineNum">    8416 </span><span class="lineCov">          1 :   if (scope == NULL)</span></a>
<a name="8417"><span class="lineNum">    8417 </span><span class="lineNoCov">          0 :      scope = SageBuilder::topScopeStack();</span></a>
<a name="8418"><span class="lineNum">    8418 </span><span class="lineCov">          1 :   ROSE_ASSERT(scope != NULL);</span></a>
<a name="8419"><span class="lineNum">    8419 </span><span class="lineCov">          1 :   SgFunctionSymbol* symbol = lookupFunctionSymbolInParentScopes(name,scope);</span></a>
<a name="8420"><span class="lineNum">    8420 </span>            : </a>
<a name="8421"><span class="lineNum">    8421 </span><span class="lineCov">          1 :   if (symbol==NULL)</span></a>
<a name="8422"><span class="lineNum">    8422 </span>            : // in rare cases when function calls are inserted before any prototypes exist</a>
<a name="8423"><span class="lineNum">    8423 </span>            :   {</a>
<a name="8424"><span class="lineNum">    8424 </span>            : // assume int return type, and empty parameter list</a>
<a name="8425"><span class="lineNum">    8425 </span>            : </a>
<a name="8426"><span class="lineNum">    8426 </span>            : #if 1</a>
<a name="8427"><span class="lineNum">    8427 </span>            : // DQ (7/26/2012): I am at least temporarily removing this function from the API.</a>
<a name="8428"><span class="lineNum">    8428 </span>            : // Later if we need it, we can update it to reflect that passing of the new</a>
<a name="8429"><span class="lineNum">    8429 </span>            : // SgTemplateArgumentPtrList function parameter (part of the new API design).</a>
<a name="8430"><span class="lineNum">    8430 </span>            : </a>
<a name="8431"><span class="lineNum">    8431 </span><span class="lineNoCov">          0 :    SgFunctionDeclaration* funcDecl = NULL;</span></a>
<a name="8432"><span class="lineNum">    8432 </span><span class="lineNoCov">          0 :    printf (&quot;Error: buildFunctionRefExp(): This function should not be used! \n&quot;);</span></a>
<a name="8433"><span class="lineNum">    8433 </span><span class="lineNoCov">          0 :    ROSE_ABORT();</span></a>
<a name="8434"><span class="lineNum">    8434 </span>            : #else</a>
<a name="8435"><span class="lineNum">    8435 </span>            :     SgType* return_type = buildIntType();</a>
<a name="8436"><span class="lineNum">    8436 </span>            :     SgFunctionParameterList *parList = buildFunctionParameterList();</a>
<a name="8437"><span class="lineNum">    8437 </span>            : </a>
<a name="8438"><span class="lineNum">    8438 </span>            :     SgGlobal* globalscope = getGlobalScope(scope);</a>
<a name="8439"><span class="lineNum">    8439 </span>            : </a>
<a name="8440"><span class="lineNum">    8440 </span>            :     SgFunctionDeclaration * funcDecl = buildNondefiningFunctionDeclaration(name,return_type,parList,globalscope);</a>
<a name="8441"><span class="lineNum">    8441 </span>            : #endif</a>
<a name="8442"><span class="lineNum">    8442 </span>            : </a>
<a name="8443"><span class="lineNum">    8443 </span>            :     funcDecl-&gt;get_declarationModifier().get_storageModifier().setExtern();</a>
<a name="8444"><span class="lineNum">    8444 </span>            : </a>
<a name="8445"><span class="lineNum">    8445 </span>            :     symbol = lookupFunctionSymbolInParentScopes(name,scope);</a>
<a name="8446"><span class="lineNum">    8446 </span>            :     ROSE_ASSERT(symbol);</a>
<a name="8447"><span class="lineNum">    8447 </span>            :   }</a>
<a name="8448"><span class="lineNum">    8448 </span>            : </a>
<a name="8449"><span class="lineNum">    8449 </span><span class="lineCov">          1 :   SgFunctionRefExp* func_ref = buildFunctionRefExp(symbol);</span></a>
<a name="8450"><span class="lineNum">    8450 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(func_ref);</span></a>
<a name="8451"><span class="lineNum">    8451 </span>            : </a>
<a name="8452"><span class="lineNum">    8452 </span><span class="lineCov">          1 :   ROSE_ASSERT(func_ref);</span></a>
<a name="8453"><span class="lineNum">    8453 </span><span class="lineCov">          1 :   return func_ref;</span></a>
<a name="8454"><span class="lineNum">    8454 </span>            : }</a>
<a name="8455"><span class="lineNum">    8455 </span>            : </a>
<a name="8456"><span class="lineNum">    8456 </span>            : SgFunctionRefExp *</a>
<a name="8457"><span class="lineNum">    8457 </span><span class="lineCov">          1 : SageBuilder::buildFunctionRefExp(const char* name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8458"><span class="lineNum">    8458 </span>            : {</a>
<a name="8459"><span class="lineNum">    8459 </span><span class="lineCov">          2 :   SgName name2(name);</span></a>
<a name="8460"><span class="lineNum">    8460 </span><span class="lineCov">          2 :   return buildFunctionRefExp(name2,scope);</span></a>
<a name="8461"><span class="lineNum">    8461 </span>            : }</a>
<a name="8462"><span class="lineNum">    8462 </span>            : </a>
<a name="8463"><span class="lineNum">    8463 </span>            : </a>
<a name="8464"><span class="lineNum">    8464 </span>            : SgExprStatement*</a>
<a name="8465"><span class="lineNum">    8465 </span><span class="lineCov">        737 : SageBuilder::buildExprStatement(SgExpression*  exp)</span></a>
<a name="8466"><span class="lineNum">    8466 </span>            : {</a>
<a name="8467"><span class="lineNum">    8467 </span><span class="lineCov">        737 :   SgExprStatement* expStmt = new SgExprStatement(exp);</span></a>
<a name="8468"><span class="lineNum">    8468 </span><span class="lineCov">        737 :   ROSE_ASSERT(expStmt);</span></a>
<a name="8469"><span class="lineNum">    8469 </span><span class="lineCov">        737 :   if (exp) exp-&gt;set_parent(expStmt);</span></a>
<a name="8470"><span class="lineNum">    8470 </span><span class="lineCov">        737 :   setOneSourcePositionForTransformation(expStmt);</span></a>
<a name="8471"><span class="lineNum">    8471 </span><span class="lineCov">        737 :   return expStmt;</span></a>
<a name="8472"><span class="lineNum">    8472 </span>            : }</a>
<a name="8473"><span class="lineNum">    8473 </span>            : </a>
<a name="8474"><span class="lineNum">    8474 </span>            : SgExprStatement*</a>
<a name="8475"><span class="lineNum">    8475 </span><span class="lineCov">      23377 : SageBuilder::buildExprStatement_nfi(SgExpression*  exp)</span></a>
<a name="8476"><span class="lineNum">    8476 </span>            : {</a>
<a name="8477"><span class="lineNum">    8477 </span><span class="lineCov">      23377 :   SgExprStatement* expStmt = new SgExprStatement(exp);</span></a>
<a name="8478"><span class="lineNum">    8478 </span><span class="lineCov">      23377 :   ROSE_ASSERT(expStmt);</span></a>
<a name="8479"><span class="lineNum">    8479 </span><span class="lineCov">      23377 :   if (exp) exp-&gt;set_parent(expStmt);</span></a>
<a name="8480"><span class="lineNum">    8480 </span><span class="lineCov">      23377 :   setOneSourcePositionNull(expStmt);</span></a>
<a name="8481"><span class="lineNum">    8481 </span><span class="lineCov">      23377 :   return expStmt;</span></a>
<a name="8482"><span class="lineNum">    8482 </span>            : }</a>
<a name="8483"><span class="lineNum">    8483 </span>            : </a>
<a name="8484"><span class="lineNum">    8484 </span>            : // DQ (3/27/2015): Added support for SgStatementExpression.</a>
<a name="8485"><span class="lineNum">    8485 </span>            : SgStatementExpression*</a>
<a name="8486"><span class="lineNum">    8486 </span><span class="lineNoCov">          0 : SageBuilder::buildStatementExpression(SgStatement*  exp)</span></a>
<a name="8487"><span class="lineNum">    8487 </span>            : {</a>
<a name="8488"><span class="lineNum">    8488 </span><span class="lineNoCov">          0 :   SgStatementExpression* expStmt = new SgStatementExpression(exp);</span></a>
<a name="8489"><span class="lineNum">    8489 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(expStmt);</span></a>
<a name="8490"><span class="lineNum">    8490 </span><span class="lineNoCov">          0 :   if (exp) exp-&gt;set_parent(expStmt);</span></a>
<a name="8491"><span class="lineNum">    8491 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(expStmt);</span></a>
<a name="8492"><span class="lineNum">    8492 </span>            : </a>
<a name="8493"><span class="lineNum">    8493 </span><span class="lineNoCov">          0 :   return expStmt;</span></a>
<a name="8494"><span class="lineNum">    8494 </span>            : }</a>
<a name="8495"><span class="lineNum">    8495 </span>            : </a>
<a name="8496"><span class="lineNum">    8496 </span>            : // DQ (3/27/2015): Added support for SgStatementExpression.</a>
<a name="8497"><span class="lineNum">    8497 </span>            : SgStatementExpression*</a>
<a name="8498"><span class="lineNum">    8498 </span><span class="lineNoCov">          0 : SageBuilder::buildStatementExpression_nfi(SgStatement*  exp)</span></a>
<a name="8499"><span class="lineNum">    8499 </span>            : {</a>
<a name="8500"><span class="lineNum">    8500 </span><span class="lineNoCov">          0 :   SgStatementExpression* expStmt = new SgStatementExpression(exp);</span></a>
<a name="8501"><span class="lineNum">    8501 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(expStmt);</span></a>
<a name="8502"><span class="lineNum">    8502 </span><span class="lineNoCov">          0 :   if (exp) exp-&gt;set_parent(expStmt);</span></a>
<a name="8503"><span class="lineNum">    8503 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(expStmt);</span></a>
<a name="8504"><span class="lineNum">    8504 </span>            : </a>
<a name="8505"><span class="lineNum">    8505 </span><span class="lineNoCov">          0 :   return expStmt;</span></a>
<a name="8506"><span class="lineNum">    8506 </span>            : }</a>
<a name="8507"><span class="lineNum">    8507 </span>            : </a>
<a name="8508"><span class="lineNum">    8508 </span>            : SgFunctionCallExp*</a>
<a name="8509"><span class="lineNum">    8509 </span><span class="lineCov">          4 : SageBuilder::buildFunctionCallExp(const SgName&amp; name, SgType* return_type, SgExprListExp* parameters/*=NULL*/, SgScopeStatement* scope/*=NULL*/)</span></a>
<a name="8510"><span class="lineNum">    8510 </span>            :    {</a>
<a name="8511"><span class="lineNum">    8511 </span><span class="lineCov">          4 :      if (scope == NULL)</span></a>
<a name="8512"><span class="lineNum">    8512 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="8513"><span class="lineNum">    8513 </span><span class="lineCov">          4 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="8514"><span class="lineNum">    8514 </span>            : </a>
<a name="8515"><span class="lineNum">    8515 </span><span class="lineCov">          4 :      if (parameters == NULL)</span></a>
<a name="8516"><span class="lineNum">    8516 </span><span class="lineNoCov">          0 :           parameters = buildExprListExp();</span></a>
<a name="8517"><span class="lineNum">    8517 </span>            : </a>
<a name="8518"><span class="lineNum">    8518 </span>            : #if 0</a>
<a name="8519"><span class="lineNum">    8519 </span>            :      printf (&quot;In SageBuilder::buildFunctionCallExp(): calling buildFunctionParameterTypeList() \n&quot;);</a>
<a name="8520"><span class="lineNum">    8520 </span>            : #endif</a>
<a name="8521"><span class="lineNum">    8521 </span>            : </a>
<a name="8522"><span class="lineNum">    8522 </span><span class="lineCov">          4 :      SgFunctionParameterTypeList * typeList = buildFunctionParameterTypeList(parameters);</span></a>
<a name="8523"><span class="lineNum">    8523 </span><span class="lineCov">          4 :      SgFunctionType * func_type = buildFunctionType(return_type,typeList);</span></a>
<a name="8524"><span class="lineNum">    8524 </span><span class="lineCov">          4 :      SgFunctionRefExp* func_ref = buildFunctionRefExp(name,func_type,scope);</span></a>
<a name="8525"><span class="lineNum">    8525 </span><span class="lineCov">          4 :      SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref-&gt;get_type());</span></a>
<a name="8526"><span class="lineNum">    8526 </span><span class="lineCov">          4 :      parameters-&gt;set_parent(func_call_expr);</span></a>
<a name="8527"><span class="lineNum">    8527 </span><span class="lineCov">          4 :      setOneSourcePositionForTransformation(func_call_expr);</span></a>
<a name="8528"><span class="lineNum">    8528 </span><span class="lineCov">          4 :      ROSE_ASSERT(func_call_expr);</span></a>
<a name="8529"><span class="lineNum">    8529 </span>            : </a>
<a name="8530"><span class="lineNum">    8530 </span><span class="lineCov">          4 :      return func_call_expr;</span></a>
<a name="8531"><span class="lineNum">    8531 </span>            :    }</a>
<a name="8532"><span class="lineNum">    8532 </span>            : </a>
<a name="8533"><span class="lineNum">    8533 </span>            : </a>
<a name="8534"><span class="lineNum">    8534 </span>            : SgFunctionCallExp*</a>
<a name="8535"><span class="lineNum">    8535 </span><span class="lineCov">          1 : SageBuilder::buildFunctionCallExp(SgFunctionSymbol* sym,</span></a>
<a name="8536"><span class="lineNum">    8536 </span>            :                                   SgExprListExp* parameters/*=NULL*/)</a>
<a name="8537"><span class="lineNum">    8537 </span>            :    {</a>
<a name="8538"><span class="lineNum">    8538 </span><span class="lineCov">          1 :      ROSE_ASSERT (sym != NULL);</span></a>
<a name="8539"><span class="lineNum">    8539 </span><span class="lineCov">          1 :      if (parameters == NULL)</span></a>
<a name="8540"><span class="lineNum">    8540 </span><span class="lineCov">          1 :           parameters = buildExprListExp();</span></a>
<a name="8541"><span class="lineNum">    8541 </span><span class="lineCov">          1 :      ROSE_ASSERT (parameters != NULL);</span></a>
<a name="8542"><span class="lineNum">    8542 </span>            : </a>
<a name="8543"><span class="lineNum">    8543 </span>            :   // DQ (8/21/2011): We want to preserve the support for member functions to be built as SgMemberFunctionRefExp.</a>
<a name="8544"><span class="lineNum">    8544 </span>            :   // This is important for the Java support and the C++ support else we will be lowering all mmember function calls</a>
<a name="8545"><span class="lineNum">    8545 </span>            :   // to function calls which will be a proble for eht analysis of object oriented languages.</a>
<a name="8546"><span class="lineNum">    8546 </span>            :   // SgFunctionRefExp* func_ref = buildFunctionRefExp(sym);</a>
<a name="8547"><span class="lineNum">    8547 </span>            :   // SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref-&gt;get_type());</a>
<a name="8548"><span class="lineNum">    8548 </span>            :   // func_ref-&gt;set_parent(func_call_expr);</a>
<a name="8549"><span class="lineNum">    8549 </span><span class="lineCov">          1 :      SgFunctionCallExp * func_call_expr = NULL;</span></a>
<a name="8550"><span class="lineNum">    8550 </span><span class="lineCov">          1 :      SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(sym);</span></a>
<a name="8551"><span class="lineNum">    8551 </span><span class="lineCov">          1 :      if (memberFunctionSymbol != NULL)</span></a>
<a name="8552"><span class="lineNum">    8552 </span>            :         {</a>
<a name="8553"><span class="lineNum">    8553 </span>            :        // Note that we can't at this point be sure this is not a virtual function.</a>
<a name="8554"><span class="lineNum">    8554 </span><span class="lineNoCov">          0 :           bool virtual_call = false;</span></a>
<a name="8555"><span class="lineNum">    8555 </span>            : </a>
<a name="8556"><span class="lineNum">    8556 </span>            :        // Name qualificaiton is handled separately from the setting of this variable (old API).</a>
<a name="8557"><span class="lineNum">    8557 </span><span class="lineNoCov">          0 :           bool need_qualifier = false;</span></a>
<a name="8558"><span class="lineNum">    8558 </span>            : </a>
<a name="8559"><span class="lineNum">    8559 </span><span class="lineNoCov">          0 :           SgMemberFunctionRefExp* member_func_ref = buildMemberFunctionRefExp(memberFunctionSymbol,virtual_call,need_qualifier);</span></a>
<a name="8560"><span class="lineNum">    8560 </span><span class="lineNoCov">          0 :           func_call_expr = new SgFunctionCallExp(member_func_ref,parameters,member_func_ref-&gt;get_type());</span></a>
<a name="8561"><span class="lineNum">    8561 </span><span class="lineNoCov">          0 :           member_func_ref-&gt;set_parent(func_call_expr);</span></a>
<a name="8562"><span class="lineNum">    8562 </span>            :         }</a>
<a name="8563"><span class="lineNum">    8563 </span>            :        else</a>
<a name="8564"><span class="lineNum">    8564 </span>            :         {</a>
<a name="8565"><span class="lineNum">    8565 </span><span class="lineCov">          1 :           SgFunctionRefExp * func_ref = buildFunctionRefExp(sym);</span></a>
<a name="8566"><span class="lineNum">    8566 </span><span class="lineCov">          1 :           func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref-&gt;get_type());</span></a>
<a name="8567"><span class="lineNum">    8567 </span><span class="lineCov">          1 :           func_ref-&gt;set_parent(func_call_expr);</span></a>
<a name="8568"><span class="lineNum">    8568 </span>            :         }</a>
<a name="8569"><span class="lineNum">    8569 </span>            : </a>
<a name="8570"><span class="lineNum">    8570 </span>            : </a>
<a name="8571"><span class="lineNum">    8571 </span><span class="lineCov">          1 :      parameters-&gt;set_parent(func_call_expr);</span></a>
<a name="8572"><span class="lineNum">    8572 </span>            : </a>
<a name="8573"><span class="lineNum">    8573 </span><span class="lineCov">          1 :      setOneSourcePositionForTransformation(func_call_expr);</span></a>
<a name="8574"><span class="lineNum">    8574 </span>            : </a>
<a name="8575"><span class="lineNum">    8575 </span><span class="lineCov">          1 :      ROSE_ASSERT(func_call_expr);</span></a>
<a name="8576"><span class="lineNum">    8576 </span><span class="lineCov">          1 :      return func_call_expr;</span></a>
<a name="8577"><span class="lineNum">    8577 </span>            :    }</a>
<a name="8578"><span class="lineNum">    8578 </span>            : </a>
<a name="8579"><span class="lineNum">    8579 </span>            : SgFunctionCallExp*</a>
<a name="8580"><span class="lineNum">    8580 </span><span class="lineCov">      32107 : SageBuilder::buildFunctionCallExp_nfi(SgExpression* f, SgExprListExp* parameters /*=NULL*/)</span></a>
<a name="8581"><span class="lineNum">    8581 </span>            :    {</a>
<a name="8582"><span class="lineNum">    8582 </span><span class="lineCov">      32107 :      ROSE_ASSERT(f != NULL);</span></a>
<a name="8583"><span class="lineNum">    8583 </span><span class="lineCov">      32107 :      SgFunctionCallExp* func_call_expr = new SgFunctionCallExp(f,parameters,f-&gt;get_type());</span></a>
<a name="8584"><span class="lineNum">    8584 </span><span class="lineCov">      32107 :      ROSE_ASSERT(func_call_expr != NULL);</span></a>
<a name="8585"><span class="lineNum">    8585 </span>            : </a>
<a name="8586"><span class="lineNum">    8586 </span><span class="lineCov">      32107 :      if (f != NULL) {</span></a>
<a name="8587"><span class="lineNum">    8587 </span><span class="lineCov">      32107 :         f-&gt;set_parent(func_call_expr);</span></a>
<a name="8588"><span class="lineNum">    8588 </span>            :      }</a>
<a name="8589"><span class="lineNum">    8589 </span><span class="lineCov">      32107 :      if (parameters != NULL) {</span></a>
<a name="8590"><span class="lineNum">    8590 </span><span class="lineCov">      32107 :         parameters-&gt;set_parent(func_call_expr);</span></a>
<a name="8591"><span class="lineNum">    8591 </span>            :      }</a>
<a name="8592"><span class="lineNum">    8592 </span><span class="lineCov">      32107 :      setOneSourcePositionNull(func_call_expr);</span></a>
<a name="8593"><span class="lineNum">    8593 </span>            : </a>
<a name="8594"><span class="lineNum">    8594 </span><span class="lineCov">      32107 :      return func_call_expr;</span></a>
<a name="8595"><span class="lineNum">    8595 </span>            :    }</a>
<a name="8596"><span class="lineNum">    8596 </span>            : </a>
<a name="8597"><span class="lineNum">    8597 </span>            : SgFunctionCallExp*</a>
<a name="8598"><span class="lineNum">    8598 </span><span class="lineCov">          4 : SageBuilder::buildFunctionCallExp(SgExpression* f, SgExprListExp* parameters/*=NULL*/)</span></a>
<a name="8599"><span class="lineNum">    8599 </span>            :    {</a>
<a name="8600"><span class="lineNum">    8600 </span><span class="lineCov">          4 :      ROSE_ASSERT(f != NULL);</span></a>
<a name="8601"><span class="lineNum">    8601 </span><span class="lineCov">          4 :      SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(f,parameters,f-&gt;get_type());</span></a>
<a name="8602"><span class="lineNum">    8602 </span><span class="lineCov">          4 :      ROSE_ASSERT(func_call_expr != NULL);</span></a>
<a name="8603"><span class="lineNum">    8603 </span>            : </a>
<a name="8604"><span class="lineNum">    8604 </span><span class="lineCov">          4 :      if (f) f-&gt;set_parent(func_call_expr);</span></a>
<a name="8605"><span class="lineNum">    8605 </span><span class="lineCov">          4 :      if (parameters) parameters-&gt;set_parent(func_call_expr);</span></a>
<a name="8606"><span class="lineNum">    8606 </span><span class="lineCov">          4 :      setOneSourcePositionForTransformation(func_call_expr);</span></a>
<a name="8607"><span class="lineNum">    8607 </span>            : </a>
<a name="8608"><span class="lineNum">    8608 </span><span class="lineCov">          4 :      return func_call_expr;</span></a>
<a name="8609"><span class="lineNum">    8609 </span>            :    }</a>
<a name="8610"><span class="lineNum">    8610 </span>            : </a>
<a name="8611"><span class="lineNum">    8611 </span>            : SgExprStatement*</a>
<a name="8612"><span class="lineNum">    8612 </span><span class="lineCov">          3 : SageBuilder::buildFunctionCallStmt(const SgName&amp; name,</span></a>
<a name="8613"><span class="lineNum">    8613 </span>            :                       SgType* return_type,</a>
<a name="8614"><span class="lineNum">    8614 </span>            :                       SgExprListExp* parameters /*= NULL*/,</a>
<a name="8615"><span class="lineNum">    8615 </span>            :                       SgScopeStatement* scope /*=NULL*/)</a>
<a name="8616"><span class="lineNum">    8616 </span>            : {</a>
<a name="8617"><span class="lineNum">    8617 </span><span class="lineCov">          3 :   if (scope == NULL)</span></a>
<a name="8618"><span class="lineNum">    8618 </span><span class="lineCov">          2 :     scope = SageBuilder::topScopeStack();</span></a>
<a name="8619"><span class="lineNum">    8619 </span><span class="lineCov">          3 :   ROSE_ASSERT(scope != NULL);</span></a>
<a name="8620"><span class="lineNum">    8620 </span><span class="lineCov">          3 :   SgFunctionCallExp* func_call_expr = buildFunctionCallExp(name,return_type,parameters,scope);</span></a>
<a name="8621"><span class="lineNum">    8621 </span><span class="lineCov">          3 :   SgExprStatement * expStmt = buildExprStatement(func_call_expr);</span></a>
<a name="8622"><span class="lineNum">    8622 </span><span class="lineCov">          3 :   return expStmt;</span></a>
<a name="8623"><span class="lineNum">    8623 </span>            : }</a>
<a name="8624"><span class="lineNum">    8624 </span>            : </a>
<a name="8625"><span class="lineNum">    8625 </span>            : //! Build a function call statement using function expression and argument list only, like (*funcPtr)(args);</a>
<a name="8626"><span class="lineNum">    8626 </span>            : SgExprStatement*</a>
<a name="8627"><span class="lineNum">    8627 </span><span class="lineNoCov">          0 : SageBuilder::buildFunctionCallStmt(SgExpression* function_exp, SgExprListExp* parameters/*=NULL*/)</span></a>
<a name="8628"><span class="lineNum">    8628 </span>            : {</a>
<a name="8629"><span class="lineNum">    8629 </span><span class="lineNoCov">          0 :   SgFunctionCallExp* func_call_expr = buildFunctionCallExp(function_exp, parameters);</span></a>
<a name="8630"><span class="lineNum">    8630 </span><span class="lineNoCov">          0 :   SgExprStatement * expStmt = buildExprStatement(func_call_expr);</span></a>
<a name="8631"><span class="lineNum">    8631 </span><span class="lineNoCov">          0 :   return expStmt;</span></a>
<a name="8632"><span class="lineNum">    8632 </span>            : }</a>
<a name="8633"><span class="lineNum">    8633 </span>            : </a>
<a name="8634"><span class="lineNum">    8634 </span>            : </a>
<a name="8635"><span class="lineNum">    8635 </span>            : //! AST builder functions for template instantiation etc.</a>
<a name="8636"><span class="lineNum">    8636 </span>            : /**</a>
<a name="8637"><span class="lineNum">    8637 </span>            :  * Create a member function call</a>
<a name="8638"><span class="lineNum">    8638 </span>            :  * This function looks for the function symbol in the given className</a>
<a name="8639"><span class="lineNum">    8639 </span>            :  * The function should exist in the class</a>
<a name="8640"><span class="lineNum">    8640 </span>            :  * The class should be #included or present in the source file parsed by frontend</a>
<a name="8641"><span class="lineNum">    8641 </span>            :  */</a>
<a name="8642"><span class="lineNum">    8642 </span>            :   SgFunctionCallExp*</a>
<a name="8643"><span class="lineNum">    8643 </span><span class="lineNoCov">          0 : SageBuilder::buildMemberFunctionCall( std::string       className,</span></a>
<a name="8644"><span class="lineNum">    8644 </span>            :     SgExpression*     objectExpression,</a>
<a name="8645"><span class="lineNum">    8645 </span>            :     std::string       functionName,</a>
<a name="8646"><span class="lineNum">    8646 </span>            :     SgExprListExp*    params,</a>
<a name="8647"><span class="lineNum">    8647 </span>            :     SgScopeStatement* scope</a>
<a name="8648"><span class="lineNum">    8648 </span>            :     )</a>
<a name="8649"><span class="lineNum">    8649 </span>            : {</a>
<a name="8650"><span class="lineNum">    8650 </span><span class="lineNoCov">          0 :   SgClassSymbol* classSymbol = SageInterface::lookupClassSymbolInParentScopes(className, scope);</span></a>
<a name="8651"><span class="lineNum">    8651 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(classSymbol);</span></a>
<a name="8652"><span class="lineNum">    8652 </span>            : </a>
<a name="8653"><span class="lineNum">    8653 </span><span class="lineNoCov">          0 :   SgDeclarationStatement* classDecl = classSymbol-&gt;get_declaration()-&gt;get_definingDeclaration();</span></a>
<a name="8654"><span class="lineNum">    8654 </span><span class="lineNoCov">          0 :   SgClassDeclaration*     classDeclaration = isSgClassDeclaration(classDecl);</span></a>
<a name="8655"><span class="lineNum">    8655 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="8656"><span class="lineNum">    8656 </span>            : </a>
<a name="8657"><span class="lineNum">    8657 </span><span class="lineNoCov">          0 :   SgClassDefinition*      classDefinition = classDeclaration-&gt;get_definition();</span></a>
<a name="8658"><span class="lineNum">    8658 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(classDefinition);</span></a>
<a name="8659"><span class="lineNum">    8659 </span>            : </a>
<a name="8660"><span class="lineNum">    8660 </span><span class="lineNoCov">          0 :   SgSymbol*               funsy = lookupFunctionSymbolInParentScopes(functionName, classDefinition);</span></a>
<a name="8661"><span class="lineNum">    8661 </span><span class="lineNoCov">          0 :   SgMemberFunctionSymbol* functionSymbol = isSgMemberFunctionSymbol(funsy);</span></a>
<a name="8662"><span class="lineNum">    8662 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(functionSymbol);</span></a>
<a name="8663"><span class="lineNum">    8663 </span>            : </a>
<a name="8664"><span class="lineNum">    8664 </span><span class="lineNoCov">          0 :   SgMemberFunctionRefExp* memref = buildMemberFunctionRefExp(functionSymbol, false, false);</span></a>
<a name="8665"><span class="lineNum">    8665 </span>            : </a>
<a name="8666"><span class="lineNum">    8666 </span><span class="lineNoCov">          0 :   return buildFunctionCallExp(buildDotExp(objectExpression, memref), params);</span></a>
<a name="8667"><span class="lineNum">    8667 </span>            : }</a>
<a name="8668"><span class="lineNum">    8668 </span>            : </a>
<a name="8669"><span class="lineNum">    8669 </span>            : // with known varRef and mem function symbol :  a.size()</a>
<a name="8670"><span class="lineNum">    8670 </span><span class="lineNoCov">          0 : SgFunctionCallExp* SageBuilder::buildMemberFunctionCall (SgExpression*     objectExpression, SgMemberFunctionSymbol* functionSymbol,</span></a>
<a name="8671"><span class="lineNum">    8671 </span>            :     SgExprListExp*    params)</a>
<a name="8672"><span class="lineNum">    8672 </span>            : {</a>
<a name="8673"><span class="lineNum">    8673 </span><span class="lineNoCov">          0 :   SgMemberFunctionRefExp* memref = SageBuilder::buildMemberFunctionRefExp(functionSymbol, false, false);</span></a>
<a name="8674"><span class="lineNum">    8674 </span><span class="lineNoCov">          0 :   return SageBuilder::buildFunctionCallExp(SageBuilder::buildDotExp(objectExpression, memref), params);</span></a>
<a name="8675"><span class="lineNum">    8675 </span>            : }</a>
<a name="8676"><span class="lineNum">    8676 </span>            : </a>
<a name="8677"><span class="lineNum">    8677 </span>            : SgTypeTraitBuiltinOperator*</a>
<a name="8678"><span class="lineNum">    8678 </span><span class="lineCov">        428 : SageBuilder::buildTypeTraitBuiltinOperator(SgName functionName, SgNodePtrList parameters)</span></a>
<a name="8679"><span class="lineNum">    8679 </span>            :    {</a>
<a name="8680"><span class="lineNum">    8680 </span>            :   // DQ (7/14/2013): This is supporting compiler extensions that are required to support type traits in C++.</a>
<a name="8681"><span class="lineNum">    8681 </span>            :   // These operators are used increasingly in newer versions of GNU and other compilers.  They are builtin</a>
<a name="8682"><span class="lineNum">    8682 </span>            :   // compiler extensions that typically take types as arguments.</a>
<a name="8683"><span class="lineNum">    8683 </span>            : </a>
<a name="8684"><span class="lineNum">    8684 </span><span class="lineCov">        428 :      SgTypeTraitBuiltinOperator * builtin_func_call_expr = new SgTypeTraitBuiltinOperator(functionName);</span></a>
<a name="8685"><span class="lineNum">    8685 </span><span class="lineCov">        428 :      ROSE_ASSERT(builtin_func_call_expr != NULL);</span></a>
<a name="8686"><span class="lineNum">    8686 </span>            : </a>
<a name="8687"><span class="lineNum">    8687 </span><span class="lineCov">        428 :      SgNodePtrList &amp; args = builtin_func_call_expr-&gt;get_args();</span></a>
<a name="8688"><span class="lineNum">    8688 </span><span class="lineCov">        966 :      for (SgNodePtrList::iterator it = parameters.begin(); it != parameters.end(); ++it) {</span></a>
<a name="8689"><span class="lineNum">    8689 </span><span class="lineCov">        538 :        args.push_back(*it);</span></a>
<a name="8690"><span class="lineNum">    8690 </span><span class="lineCov">        538 :        (*it)-&gt;set_parent(builtin_func_call_expr);</span></a>
<a name="8691"><span class="lineNum">    8691 </span>            :      }</a>
<a name="8692"><span class="lineNum">    8692 </span>            : </a>
<a name="8693"><span class="lineNum">    8693 </span><span class="lineCov">        428 :      return builtin_func_call_expr;</span></a>
<a name="8694"><span class="lineNum">    8694 </span>            :    }</a>
<a name="8695"><span class="lineNum">    8695 </span>            : </a>
<a name="8696"><span class="lineNum">    8696 </span>            : </a>
<a name="8697"><span class="lineNum">    8697 </span>            : //! Build a CUDA kernel call expression (kernel&lt;&lt;&lt;config&gt;&gt;&gt;(parameters))</a>
<a name="8698"><span class="lineNum">    8698 </span><span class="lineNoCov">          0 : SgCudaKernelCallExp * SageBuilder::buildCudaKernelCallExp_nfi(SgExpression * kernel, SgExprListExp* parameters, SgCudaKernelExecConfig * config)</span></a>
<a name="8699"><span class="lineNum">    8699 </span>            :    {</a>
<a name="8700"><span class="lineNum">    8700 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(kernel);</span></a>
<a name="8701"><span class="lineNum">    8701 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(parameters);</span></a>
<a name="8702"><span class="lineNum">    8702 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(config);</span></a>
<a name="8703"><span class="lineNum">    8703 </span>            : </a>
<a name="8704"><span class="lineNum">    8704 </span>            :   // DQ (1/19/2016): Adding template function ref support.</a>
<a name="8705"><span class="lineNum">    8705 </span><span class="lineNoCov">          0 :      SgFunctionRefExp * func_ref_exp = isSgFunctionRefExp(kernel);</span></a>
<a name="8706"><span class="lineNum">    8706 </span><span class="lineNoCov">          0 :      SgTemplateFunctionRefExp * template_func_ref_exp = isSgTemplateFunctionRefExp(kernel);</span></a>
<a name="8707"><span class="lineNum">    8707 </span>            :   // if (func_ref_exp == NULL)</a>
<a name="8708"><span class="lineNum">    8708 </span><span class="lineNoCov">          0 :      if (func_ref_exp == NULL &amp;&amp; template_func_ref_exp == NULL)</span></a>
<a name="8709"><span class="lineNum">    8709 </span>            :         {</a>
<a name="8710"><span class="lineNum">    8710 </span>            : #if 0</a>
<a name="8711"><span class="lineNum">    8711 </span>            :           printf (&quot;Error: SageBuilder::buildCudaKernelCallExp_nfi(): kernel = %p = %s \n&quot;,kernel,kernel-&gt;class_name().c_str());</a>
<a name="8712"><span class="lineNum">    8712 </span>            : #endif</a>
<a name="8713"><span class="lineNum">    8713 </span><span class="lineNoCov">          0 :           std::cerr &lt;&lt; &quot;SgCudaKernelCallExp accept only direct reference to a function. Got, &quot; &lt;&lt; typeid(*kernel).name()</span></a>
<a name="8714"><span class="lineNum">    8714 </span><span class="lineNoCov">          0 :                     &lt;&lt; &quot; with, &quot; &lt;&lt; kernel-&gt;unparseToString() &lt;&lt; std::endl;</span></a>
<a name="8715"><span class="lineNum">    8715 </span>            : </a>
<a name="8716"><span class="lineNum">    8716 </span>            :           // PP (7/1/19): experimental support for RAJA/CUDA Lulesh codes (producing SgNonrealRefExp) **1</a>
<a name="8717"><span class="lineNum">    8717 </span>            :           // was: ROSE_ASSERT(false);</a>
<a name="8718"><span class="lineNum">    8718 </span>            :         }</a>
<a name="8719"><span class="lineNum">    8719 </span>            : </a>
<a name="8720"><span class="lineNum">    8720 </span>            :     else // was not here (**1)</a>
<a name="8721"><span class="lineNum">    8721 </span>            : </a>
<a name="8722"><span class="lineNum">    8722 </span>            :   // DQ (1/19/2016): Adding template function ref support.</a>
<a name="8723"><span class="lineNum">    8723 </span>            :   // if (!(func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel()))</a>
<a name="8724"><span class="lineNum">    8724 </span><span class="lineNoCov">          0 :      if ( (func_ref_exp          != NULL &amp;&amp; func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() == false) &amp;&amp;</span></a>
<a name="8725"><span class="lineNum">    8725 </span><span class="lineNoCov">          0 :           (template_func_ref_exp != NULL &amp;&amp; template_func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() == false) )</span></a>
<a name="8726"><span class="lineNum">    8726 </span>            :         {</a>
<a name="8727"><span class="lineNum">    8727 </span>            : #if 0</a>
<a name="8728"><span class="lineNum">    8728 </span>            :           printf (&quot;Error: SageBuilder::buildCudaKernelCallExp_nfi(): kernel = %p = %s \n&quot;,kernel,kernel-&gt;class_name().c_str());</a>
<a name="8729"><span class="lineNum">    8729 </span>            :           if (func_ref_exp != NULL)</a>
<a name="8730"><span class="lineNum">    8730 </span>            :                printf (&quot;func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() = %s \n&quot;,</a>
<a name="8731"><span class="lineNum">    8731 </span>            :                     func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8732"><span class="lineNum">    8732 </span>            :           if (template_func_ref_exp != NULL)</a>
<a name="8733"><span class="lineNum">    8733 </span>            :                printf (&quot;template_func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() = %s \n&quot;,</a>
<a name="8734"><span class="lineNum">    8734 </span>            :                     template_func_ref_exp-&gt;get_symbol_i()-&gt;get_declaration()-&gt;get_functionModifier().isCudaKernel() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8735"><span class="lineNum">    8735 </span>            : #endif</a>
<a name="8736"><span class="lineNum">    8736 </span><span class="lineNoCov">          0 :           std::cerr &lt;&lt; &quot;To build a SgCudaKernelCallExp the callee needs to be a kernel (having \&quot;__global__\&quot; attribute).&quot; &lt;&lt; std::endl;</span></a>
<a name="8737"><span class="lineNum">    8737 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="8738"><span class="lineNum">    8738 </span>            :         }</a>
<a name="8739"><span class="lineNum">    8739 </span>            : </a>
<a name="8740"><span class="lineNum">    8740 </span><span class="lineNoCov">          0 :      SgCudaKernelCallExp * kernel_call_expr = new SgCudaKernelCallExp(kernel, parameters, kernel-&gt;get_type(), config);</span></a>
<a name="8741"><span class="lineNum">    8741 </span>            : </a>
<a name="8742"><span class="lineNum">    8742 </span><span class="lineNoCov">          0 :      kernel-&gt;set_parent(kernel_call_expr);</span></a>
<a name="8743"><span class="lineNum">    8743 </span><span class="lineNoCov">          0 :      parameters-&gt;set_parent(kernel_call_expr);</span></a>
<a name="8744"><span class="lineNum">    8744 </span><span class="lineNoCov">          0 :      config-&gt;set_parent(kernel_call_expr);</span></a>
<a name="8745"><span class="lineNum">    8745 </span>            : </a>
<a name="8746"><span class="lineNum">    8746 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(kernel_call_expr);</span></a>
<a name="8747"><span class="lineNum">    8747 </span>            : </a>
<a name="8748"><span class="lineNum">    8748 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(kernel_call_expr);</span></a>
<a name="8749"><span class="lineNum">    8749 </span>            : </a>
<a name="8750"><span class="lineNum">    8750 </span><span class="lineNoCov">          0 :      return kernel_call_expr;</span></a>
<a name="8751"><span class="lineNum">    8751 </span>            :    }</a>
<a name="8752"><span class="lineNum">    8752 </span>            : </a>
<a name="8753"><span class="lineNum">    8753 </span>            : //! Build a CUDA kernel execution configuration (&lt;&lt;&lt;grid, blocks, shared, stream&gt;&gt;&gt;)</a>
<a name="8754"><span class="lineNum">    8754 </span><span class="lineNoCov">          0 : SgCudaKernelExecConfig * SageBuilder::buildCudaKernelExecConfig_nfi(SgExpression *grid, SgExpression *blocks, SgExpression *shared, SgExpression *stream) {</span></a>
<a name="8755"><span class="lineNum">    8755 </span><span class="lineNoCov">          0 :   if (!grid || !blocks) {</span></a>
<a name="8756"><span class="lineNum">    8756 </span><span class="lineNoCov">          0 :      std::cerr &lt;&lt; &quot;SgCudaKernelExecConfig need fields 'grid' and 'blocks' to be set.&quot; &lt;&lt; std::endl;</span></a>
<a name="8757"><span class="lineNum">    8757 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="8758"><span class="lineNum">    8758 </span>            :   }</a>
<a name="8759"><span class="lineNum">    8759 </span>            : </a>
<a name="8760"><span class="lineNum">    8760 </span>            :   // TODO-CUDA check types</a>
<a name="8761"><span class="lineNum">    8761 </span>            : </a>
<a name="8762"><span class="lineNum">    8762 </span><span class="lineNoCov">          0 :   SgCudaKernelExecConfig * config = new SgCudaKernelExecConfig (grid, blocks, shared, stream);</span></a>
<a name="8763"><span class="lineNum">    8763 </span>            : </a>
<a name="8764"><span class="lineNum">    8764 </span><span class="lineNoCov">          0 :   grid-&gt;set_parent(config);</span></a>
<a name="8765"><span class="lineNum">    8765 </span><span class="lineNoCov">          0 :   blocks-&gt;set_parent(config);</span></a>
<a name="8766"><span class="lineNum">    8766 </span><span class="lineNoCov">          0 :   if (shared)</span></a>
<a name="8767"><span class="lineNum">    8767 </span><span class="lineNoCov">          0 :     shared-&gt;set_parent(config);</span></a>
<a name="8768"><span class="lineNum">    8768 </span><span class="lineNoCov">          0 :   if (stream)</span></a>
<a name="8769"><span class="lineNum">    8769 </span><span class="lineNoCov">          0 :     stream-&gt;set_parent(config);</span></a>
<a name="8770"><span class="lineNum">    8770 </span>            : </a>
<a name="8771"><span class="lineNum">    8771 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(config);</span></a>
<a name="8772"><span class="lineNum">    8772 </span>            : </a>
<a name="8773"><span class="lineNum">    8773 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(config);</span></a>
<a name="8774"><span class="lineNum">    8774 </span>            : </a>
<a name="8775"><span class="lineNum">    8775 </span><span class="lineNoCov">          0 :   return config;</span></a>
<a name="8776"><span class="lineNum">    8776 </span>            : }</a>
<a name="8777"><span class="lineNum">    8777 </span>            : </a>
<a name="8778"><span class="lineNum">    8778 </span>            : SgExprStatement*</a>
<a name="8779"><span class="lineNum">    8779 </span><span class="lineCov">         42 : SageBuilder::buildAssignStatement(SgExpression* lhs,SgExpression* rhs)</span></a>
<a name="8780"><span class="lineNum">    8780 </span>            : //SageBuilder::buildAssignStatement(SgExpression* lhs,SgExpression* rhs, SgScopeStatement* scope=NULL)</a>
<a name="8781"><span class="lineNum">    8781 </span>            : {</a>
<a name="8782"><span class="lineNum">    8782 </span><span class="lineCov">         42 :   ROSE_ASSERT(lhs != NULL);</span></a>
<a name="8783"><span class="lineNum">    8783 </span><span class="lineCov">         42 :   ROSE_ASSERT(rhs != NULL);</span></a>
<a name="8784"><span class="lineNum">    8784 </span>            : </a>
<a name="8785"><span class="lineNum">    8785 </span>            :   //SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,lhs-&gt;get_type());</a>
<a name="8786"><span class="lineNum">    8786 </span>            : // SgBinaryOp::get_type() assume p_expression_type is not set</a>
<a name="8787"><span class="lineNum">    8787 </span><span class="lineCov">         42 :   SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,NULL);</span></a>
<a name="8788"><span class="lineNum">    8788 </span><span class="lineCov">         42 :   ROSE_ASSERT(assignOp);</span></a>
<a name="8789"><span class="lineNum">    8789 </span><span class="lineCov">         42 :   setOneSourcePositionForTransformation(assignOp);</span></a>
<a name="8790"><span class="lineNum">    8790 </span><span class="lineCov">         42 :   lhs-&gt;set_parent(assignOp);</span></a>
<a name="8791"><span class="lineNum">    8791 </span><span class="lineCov">         42 :   rhs-&gt;set_parent(assignOp);</span></a>
<a name="8792"><span class="lineNum">    8792 </span>            : </a>
<a name="8793"><span class="lineNum">    8793 </span><span class="lineCov">         42 :   lhs-&gt;set_lvalue (true);</span></a>
<a name="8794"><span class="lineNum">    8794 </span><span class="lineCov">         42 :   SgExprStatement* exp = new SgExprStatement(assignOp);</span></a>
<a name="8795"><span class="lineNum">    8795 </span><span class="lineCov">         42 :   ROSE_ASSERT(exp);</span></a>
<a name="8796"><span class="lineNum">    8796 </span>            :    // some child nodes are transparently generated, using recursive setting is safer</a>
<a name="8797"><span class="lineNum">    8797 </span><span class="lineCov">         42 :   setSourcePositionAtRootAndAllChildren(exp);</span></a>
<a name="8798"><span class="lineNum">    8798 </span>            :   //setOneSourcePositionForTransformation(exp);</a>
<a name="8799"><span class="lineNum">    8799 </span><span class="lineCov">         42 :   assignOp-&gt;set_parent(exp);</span></a>
<a name="8800"><span class="lineNum">    8800 </span><span class="lineCov">         42 :   return exp;</span></a>
<a name="8801"><span class="lineNum">    8801 </span>            : }</a>
<a name="8802"><span class="lineNum">    8802 </span>            : </a>
<a name="8803"><span class="lineNum">    8803 </span>            : // DQ (8/16/2011): This is an AST translate specific version (see note below).</a>
<a name="8804"><span class="lineNum">    8804 </span>            : // We would like to phase out the version above if possible (but we want to</a>
<a name="8805"><span class="lineNum">    8805 </span>            : // test this later).</a>
<a name="8806"><span class="lineNum">    8806 </span>            : SgExprStatement*</a>
<a name="8807"><span class="lineNum">    8807 </span><span class="lineNoCov">          0 : SageBuilder::buildAssignStatement_ast_translate(SgExpression* lhs,SgExpression* rhs)</span></a>
<a name="8808"><span class="lineNum">    8808 </span>            : {</a>
<a name="8809"><span class="lineNum">    8809 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(lhs != NULL);</span></a>
<a name="8810"><span class="lineNum">    8810 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(rhs != NULL);</span></a>
<a name="8811"><span class="lineNum">    8811 </span>            : </a>
<a name="8812"><span class="lineNum">    8812 </span>            :   //SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,lhs-&gt;get_type());</a>
<a name="8813"><span class="lineNum">    8813 </span>            : // SgBinaryOp::get_type() assume p_expression_type is not set</a>
<a name="8814"><span class="lineNum">    8814 </span><span class="lineNoCov">          0 :   SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,NULL);</span></a>
<a name="8815"><span class="lineNum">    8815 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(assignOp);</span></a>
<a name="8816"><span class="lineNum">    8816 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(assignOp);</span></a>
<a name="8817"><span class="lineNum">    8817 </span><span class="lineNoCov">          0 :   lhs-&gt;set_parent(assignOp);</span></a>
<a name="8818"><span class="lineNum">    8818 </span><span class="lineNoCov">          0 :   rhs-&gt;set_parent(assignOp);</span></a>
<a name="8819"><span class="lineNum">    8819 </span>            : </a>
<a name="8820"><span class="lineNum">    8820 </span><span class="lineNoCov">          0 :   lhs-&gt;set_lvalue (true);</span></a>
<a name="8821"><span class="lineNum">    8821 </span><span class="lineNoCov">          0 :   SgExprStatement* exp = new SgExprStatement(assignOp);</span></a>
<a name="8822"><span class="lineNum">    8822 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(exp);</span></a>
<a name="8823"><span class="lineNum">    8823 </span>            : </a>
<a name="8824"><span class="lineNum">    8824 </span>            : // DQ (8/16/2011): Modified to avoid recursive call to reset source position information</a>
<a name="8825"><span class="lineNum">    8825 </span>            : // (this version is required for the Java support where we have set source code position</a>
<a name="8826"><span class="lineNum">    8826 </span>            : // information on the lhs and rhs and we don't want it to be reset as a transformation.</a>
<a name="8827"><span class="lineNum">    8827 </span>            : // some child nodes are transparently generated, using recursive setting is safer</a>
<a name="8828"><span class="lineNum">    8828 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(exp);</span></a>
<a name="8829"><span class="lineNum">    8829 </span><span class="lineNoCov">          0 :   assignOp-&gt;set_parent(exp);</span></a>
<a name="8830"><span class="lineNum">    8830 </span><span class="lineNoCov">          0 :   return exp;</span></a>
<a name="8831"><span class="lineNum">    8831 </span>            : }</a>
<a name="8832"><span class="lineNum">    8832 </span>            : </a>
<a name="8833"><span class="lineNum">    8833 </span>            : </a>
<a name="8834"><span class="lineNum">    8834 </span><span class="lineCov">          6 : SgLabelStatement * SageBuilder::buildLabelStatement(const SgName&amp; name,  SgStatement * stmt/*=NULL*/, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8835"><span class="lineNum">    8835 </span>            : {</a>
<a name="8836"><span class="lineNum">    8836 </span><span class="lineCov">          6 :   if (scope == NULL)</span></a>
<a name="8837"><span class="lineNum">    8837 </span><span class="lineCov">          4 :     scope = SageBuilder::topScopeStack();</span></a>
<a name="8838"><span class="lineNum">    8838 </span>            :  //  ROSE_ASSERT(scope != NULL); // We support bottom up building of label statements now</a>
<a name="8839"><span class="lineNum">    8839 </span>            : </a>
<a name="8840"><span class="lineNum">    8840 </span>            :    // should including current scope when searching for the function definition</a>
<a name="8841"><span class="lineNum">    8841 </span>            :    // since users can only pass FunctionDefinition when the function body is not yet attached</a>
<a name="8842"><span class="lineNum">    8842 </span><span class="lineCov">          6 :   SgLabelStatement * labelstmt = new SgLabelStatement(name,stmt);</span></a>
<a name="8843"><span class="lineNum">    8843 </span><span class="lineCov">          6 :   ROSE_ASSERT(labelstmt);</span></a>
<a name="8844"><span class="lineNum">    8844 </span><span class="lineCov">          6 :   setOneSourcePositionForTransformation(labelstmt);</span></a>
<a name="8845"><span class="lineNum">    8845 </span>            : </a>
<a name="8846"><span class="lineNum">    8846 </span><span class="lineCov">          6 :  if(stmt!=NULL)</span></a>
<a name="8847"><span class="lineNum">    8847 </span><span class="lineCov">          1 :    stmt-&gt;set_parent(labelstmt);</span></a>
<a name="8848"><span class="lineNum">    8848 </span>            :  #if 0  // moved to fixLabelStatement()</a>
<a name="8849"><span class="lineNum">    8849 </span>            :   SgFunctionDefinition * label_scope = getEnclosingFunctionDefinition(scope,true);</a>
<a name="8850"><span class="lineNum">    8850 </span>            :   ROSE_ASSERT (label_scope);</a>
<a name="8851"><span class="lineNum">    8851 </span>            :   labelstmt-&gt;set_scope(label_scope);</a>
<a name="8852"><span class="lineNum">    8852 </span>            :   SgLabelSymbol* lsymbol= new SgLabelSymbol(labelstmt);</a>
<a name="8853"><span class="lineNum">    8853 </span>            :   ROSE_ASSERT(lsymbol);</a>
<a name="8854"><span class="lineNum">    8854 </span>            :   // TODO should we prevent duplicated insertion ?</a>
<a name="8855"><span class="lineNum">    8855 </span>            :   label_scope-&gt;insert_symbol(lsymbol-&gt;get_name(), lsymbol);</a>
<a name="8856"><span class="lineNum">    8856 </span>            :  #endif</a>
<a name="8857"><span class="lineNum">    8857 </span>            : </a>
<a name="8858"><span class="lineNum">    8858 </span>            :   // Liao 1/7/2010</a>
<a name="8859"><span class="lineNum">    8859 </span>            :   // SgLabelStatement is used for CONTINUE statement in Fortran</a>
<a name="8860"><span class="lineNum">    8860 </span>            :   // In this case , it has no inherent association with a Label symbol.</a>
<a name="8861"><span class="lineNum">    8861 </span>            :   // It is up to the SageInterface::setNumericalLabel(SgStatement*) to handle label symbol</a>
<a name="8862"><span class="lineNum">    8862 </span><span class="lineCov">          6 :   if (!SageInterface::is_Fortran_language() &amp;&amp;scope)</span></a>
<a name="8863"><span class="lineNum">    8863 </span><span class="lineCov">          3 :     fixLabelStatement(labelstmt,scope);</span></a>
<a name="8864"><span class="lineNum">    8864 </span>            :   // we don't want to set parent here yet</a>
<a name="8865"><span class="lineNum">    8865 </span>            :   // delay it until append_statement() or alike</a>
<a name="8866"><span class="lineNum">    8866 </span><span class="lineCov">          6 :   return labelstmt;</span></a>
<a name="8867"><span class="lineNum">    8867 </span>            : }</a>
<a name="8868"><span class="lineNum">    8868 </span>            : </a>
<a name="8869"><span class="lineNum">    8869 </span><span class="lineCov">          2 : SgLabelStatement * SageBuilder::buildLabelStatement_nfi(const SgName&amp; name,  SgStatement * stmt/*=NULL*/, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="8870"><span class="lineNum">    8870 </span>            : {</a>
<a name="8871"><span class="lineNum">    8871 </span><span class="lineCov">          2 :   SgLabelStatement * labelstmt = new SgLabelStatement(name,stmt);</span></a>
<a name="8872"><span class="lineNum">    8872 </span><span class="lineCov">          2 :   ROSE_ASSERT(labelstmt);</span></a>
<a name="8873"><span class="lineNum">    8873 </span><span class="lineCov">          2 :   setOneSourcePositionForTransformation(labelstmt);</span></a>
<a name="8874"><span class="lineNum">    8874 </span>            : </a>
<a name="8875"><span class="lineNum">    8875 </span><span class="lineCov">          2 :  if(stmt!=NULL)</span></a>
<a name="8876"><span class="lineNum">    8876 </span><span class="lineCov">          2 :    stmt-&gt;set_parent(labelstmt);</span></a>
<a name="8877"><span class="lineNum">    8877 </span><span class="lineCov">          2 :   if (scope)</span></a>
<a name="8878"><span class="lineNum">    8878 </span><span class="lineCov">          2 :     fixLabelStatement(labelstmt,scope);</span></a>
<a name="8879"><span class="lineNum">    8879 </span>            :   // we don't want to set parent here yet</a>
<a name="8880"><span class="lineNum">    8880 </span>            :   // delay it until append_statement() or alike</a>
<a name="8881"><span class="lineNum">    8881 </span><span class="lineCov">          2 :   return labelstmt;</span></a>
<a name="8882"><span class="lineNum">    8882 </span>            : }</a>
<a name="8883"><span class="lineNum">    8883 </span>            : </a>
<a name="8884"><span class="lineNum">    8884 </span><span class="lineCov">          3 : SgIfStmt * SageBuilder::buildIfStmt(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body)</span></a>
<a name="8885"><span class="lineNum">    8885 </span>            : {</a>
<a name="8886"><span class="lineNum">    8886 </span><span class="lineCov">          3 :   ROSE_ASSERT(conditional);</span></a>
<a name="8887"><span class="lineNum">    8887 </span><span class="lineCov">          3 :   ROSE_ASSERT(true_body);</span></a>
<a name="8888"><span class="lineNum">    8888 </span>            :   // ROSE_ASSERT(false_body); -- this is not required anymore</a>
<a name="8889"><span class="lineNum">    8889 </span><span class="lineCov">          3 :   SgIfStmt *ifstmt = new SgIfStmt(conditional, true_body, false_body);</span></a>
<a name="8890"><span class="lineNum">    8890 </span><span class="lineCov">          3 :   ROSE_ASSERT(ifstmt);</span></a>
<a name="8891"><span class="lineNum">    8891 </span>            : </a>
<a name="8892"><span class="lineNum">    8892 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="8893"><span class="lineNum">    8893 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="8894"><span class="lineNum">    8894 </span><span class="lineCov">          3 :   if (SageInterface::is_language_case_insensitive())</span></a>
<a name="8895"><span class="lineNum">    8895 </span><span class="lineCov">          1 :        ifstmt-&gt;setCaseInsensitive(true);</span></a>
<a name="8896"><span class="lineNum">    8896 </span>            : </a>
<a name="8897"><span class="lineNum">    8897 </span><span class="lineCov">          3 :   setOneSourcePositionForTransformation(ifstmt);</span></a>
<a name="8898"><span class="lineNum">    8898 </span><span class="lineCov">          3 :   conditional-&gt;set_parent(ifstmt);</span></a>
<a name="8899"><span class="lineNum">    8899 </span><span class="lineCov">          3 :   true_body-&gt;set_parent(ifstmt);</span></a>
<a name="8900"><span class="lineNum">    8900 </span><span class="lineCov">          3 :   if (false_body != NULL) false_body-&gt;set_parent(ifstmt);</span></a>
<a name="8901"><span class="lineNum">    8901 </span>            : </a>
<a name="8902"><span class="lineNum">    8902 </span><span class="lineCov">          3 :   if (SageInterface::is_Fortran_language() )</span></a>
<a name="8903"><span class="lineNum">    8903 </span>            :   {</a>
<a name="8904"><span class="lineNum">    8904 </span>            :     // Liao 1/20/2010</a>
<a name="8905"><span class="lineNum">    8905 </span>            :     // According to Fortran 77 standard Chapter 11.5 to 11.9,</a>
<a name="8906"><span class="lineNum">    8906 </span>            :     // this is a Fortran Block IF statement, if the true body is:</a>
<a name="8907"><span class="lineNum">    8907 </span>            :     // 1. A block of statement under SgBasicBlock</a>
<a name="8908"><span class="lineNum">    8908 </span>            :     // 2. DO, block if, or another logical if</a>
<a name="8909"><span class="lineNum">    8909 </span>            :     // Otherwise it is a logical if statement</a>
<a name="8910"><span class="lineNum">    8910 </span><span class="lineCov">          1 :     if (isSgBasicBlock(true_body)|| isSgFortranDo(true_body)|| isSgIfStmt(true_body))</span></a>
<a name="8911"><span class="lineNum">    8911 </span>            :     {</a>
<a name="8912"><span class="lineNum">    8912 </span><span class="lineCov">          1 :       ifstmt-&gt;set_use_then_keyword(true);</span></a>
<a name="8913"><span class="lineNum">    8913 </span><span class="lineCov">          1 :       ifstmt-&gt;set_has_end_statement(true);</span></a>
<a name="8914"><span class="lineNum">    8914 </span>            :     }</a>
<a name="8915"><span class="lineNum">    8915 </span>            :   }</a>
<a name="8916"><span class="lineNum">    8916 </span>            : </a>
<a name="8917"><span class="lineNum">    8917 </span><span class="lineCov">          3 :   return ifstmt;</span></a>
<a name="8918"><span class="lineNum">    8918 </span>            : }</a>
<a name="8919"><span class="lineNum">    8919 </span>            : </a>
<a name="8920"><span class="lineNum">    8920 </span><span class="lineNoCov">          0 : SgIfStmt * SageBuilder::buildIfStmt_nfi(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body)</span></a>
<a name="8921"><span class="lineNum">    8921 </span>            :    {</a>
<a name="8922"><span class="lineNum">    8922 </span><span class="lineNoCov">          0 :      SgIfStmt *ifstmt = new SgIfStmt(conditional, true_body, false_body);</span></a>
<a name="8923"><span class="lineNum">    8923 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(ifstmt);</span></a>
<a name="8924"><span class="lineNum">    8924 </span>            : #if 0</a>
<a name="8925"><span class="lineNum">    8925 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="8926"><span class="lineNum">    8926 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="8927"><span class="lineNum">    8927 </span>            :      if (SageInterface::is_language_case_insensitive())</a>
<a name="8928"><span class="lineNum">    8928 </span>            :           ifstmt-&gt;setCaseInsensitive(true);</a>
<a name="8929"><span class="lineNum">    8929 </span>            : </a>
<a name="8930"><span class="lineNum">    8930 </span>            :      setOneSourcePositionNull(ifstmt);</a>
<a name="8931"><span class="lineNum">    8931 </span>            :      if (conditional) conditional-&gt;set_parent(ifstmt);</a>
<a name="8932"><span class="lineNum">    8932 </span>            :      if (true_body) true_body-&gt;set_parent(ifstmt);</a>
<a name="8933"><span class="lineNum">    8933 </span>            :      if (false_body) false_body-&gt;set_parent(ifstmt);</a>
<a name="8934"><span class="lineNum">    8934 </span>            :      return ifstmt;</a>
<a name="8935"><span class="lineNum">    8935 </span>            : #else</a>
<a name="8936"><span class="lineNum">    8936 </span>            :   // DQ (2/13/2012): This allows us to separate the construction from the initialization (see note below).</a>
<a name="8937"><span class="lineNum">    8937 </span><span class="lineNoCov">          0 :      initializeIfStmt(ifstmt,conditional,true_body,false_body);</span></a>
<a name="8938"><span class="lineNum">    8938 </span><span class="lineNoCov">          0 :      return ifstmt;</span></a>
<a name="8939"><span class="lineNum">    8939 </span>            : #endif</a>
<a name="8940"><span class="lineNum">    8940 </span>            :    }</a>
<a name="8941"><span class="lineNum">    8941 </span>            : </a>
<a name="8942"><span class="lineNum">    8942 </span>            : // CR (9/3/2018): Added build function for a Fortran do construct</a>
<a name="8943"><span class="lineNum">    8943 </span><span class="lineNoCov">          0 : SgFortranDo * SageBuilder::buildFortranDo(SgExpression* initialization, SgExpression* bound, SgExpression* increment, SgBasicBlock* loop_body)</span></a>
<a name="8944"><span class="lineNum">    8944 </span>            :   {</a>
<a name="8945"><span class="lineNum">    8945 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(initialization);</span></a>
<a name="8946"><span class="lineNum">    8946 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(bound);</span></a>
<a name="8947"><span class="lineNum">    8947 </span>            : </a>
<a name="8948"><span class="lineNum">    8948 </span><span class="lineNoCov">          0 :      if (increment == NULL)</span></a>
<a name="8949"><span class="lineNum">    8949 </span>            :        {</a>
<a name="8950"><span class="lineNum">    8950 </span><span class="lineNoCov">          0 :           increment = buildNullExpression();</span></a>
<a name="8951"><span class="lineNum">    8951 </span>            :        }</a>
<a name="8952"><span class="lineNum">    8952 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(increment);</span></a>
<a name="8953"><span class="lineNum">    8953 </span>            : </a>
<a name="8954"><span class="lineNum">    8954 </span><span class="lineNoCov">          0 :      if (loop_body == NULL)</span></a>
<a name="8955"><span class="lineNum">    8955 </span>            :        {</a>
<a name="8956"><span class="lineNum">    8956 </span><span class="lineNoCov">          0 :           loop_body = buildBasicBlock();</span></a>
<a name="8957"><span class="lineNum">    8957 </span>            :        }</a>
<a name="8958"><span class="lineNum">    8958 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(loop_body);</span></a>
<a name="8959"><span class="lineNum">    8959 </span>            : </a>
<a name="8960"><span class="lineNum">    8960 </span><span class="lineNoCov">          0 :      SgFortranDo * result = new SgFortranDo(initialization, bound, increment, loop_body);</span></a>
<a name="8961"><span class="lineNum">    8961 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="8962"><span class="lineNum">    8962 </span>            : </a>
<a name="8963"><span class="lineNum">    8963 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="8964"><span class="lineNum">    8964 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="8965"><span class="lineNum">    8965 </span><span class="lineNoCov">          0 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="8966"><span class="lineNum">    8966 </span><span class="lineNoCov">          0 :         result-&gt;setCaseInsensitive(true);</span></a>
<a name="8967"><span class="lineNum">    8967 </span>            : </a>
<a name="8968"><span class="lineNum">    8968 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="8969"><span class="lineNum">    8969 </span>            : </a>
<a name="8970"><span class="lineNum">    8970 </span><span class="lineNoCov">          0 :      initialization-&gt;set_parent(result);</span></a>
<a name="8971"><span class="lineNum">    8971 </span><span class="lineNoCov">          0 :      bound-&gt;set_parent(result);</span></a>
<a name="8972"><span class="lineNum">    8972 </span><span class="lineNoCov">          0 :      increment-&gt;set_parent(result);</span></a>
<a name="8973"><span class="lineNum">    8973 </span><span class="lineNoCov">          0 :      loop_body-&gt;set_parent(result);</span></a>
<a name="8974"><span class="lineNum">    8974 </span>            : </a>
<a name="8975"><span class="lineNum">    8975 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="8976"><span class="lineNum">    8976 </span>            :    }</a>
<a name="8977"><span class="lineNum">    8977 </span>            : </a>
<a name="8978"><span class="lineNum">    8978 </span>            : // charles4 10/14/2011:  Vanilla allocation. Use prepend_init_stmt and append_init_stmt to populate afterward.</a>
<a name="8979"><span class="lineNum">    8979 </span><span class="lineNoCov">          0 : SgForInitStatement * SageBuilder::buildForInitStatement()</span></a>
<a name="8980"><span class="lineNum">    8980 </span>            :    {</a>
<a name="8981"><span class="lineNum">    8981 </span>            :   // return new SgForInitStatement();</a>
<a name="8982"><span class="lineNum">    8982 </span><span class="lineNoCov">          0 :      SgForInitStatement* result = new SgForInitStatement();</span></a>
<a name="8983"><span class="lineNum">    8983 </span>            : </a>
<a name="8984"><span class="lineNum">    8984 </span>            :   // DQ (11/3/2012): Added call to set file info to default settings.</a>
<a name="8985"><span class="lineNum">    8985 </span><span class="lineNoCov">          0 :      setSourcePosition(result);</span></a>
<a name="8986"><span class="lineNum">    8986 </span>            : </a>
<a name="8987"><span class="lineNum">    8987 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="8988"><span class="lineNum">    8988 </span>            :    }</a>
<a name="8989"><span class="lineNum">    8989 </span>            : </a>
<a name="8990"><span class="lineNum">    8990 </span>            : // DQ (10/12/2012): Added specific API to handle simple (single) statement.</a>
<a name="8991"><span class="lineNum">    8991 </span>            : SgForInitStatement*</a>
<a name="8992"><span class="lineNum">    8992 </span><span class="lineCov">        236 : SageBuilder::buildForInitStatement( SgStatement* statement )</span></a>
<a name="8993"><span class="lineNum">    8993 </span>            :    {</a>
<a name="8994"><span class="lineNum">    8994 </span><span class="lineCov">        236 :      SgForInitStatement* forInit = new SgForInitStatement();</span></a>
<a name="8995"><span class="lineNum">    8995 </span><span class="lineCov">        236 :      ROSE_ASSERT(forInit != NULL);</span></a>
<a name="8996"><span class="lineNum">    8996 </span>            : </a>
<a name="8997"><span class="lineNum">    8997 </span><span class="lineCov">        236 :      ROSE_ASSERT(statement != NULL);</span></a>
<a name="8998"><span class="lineNum">    8998 </span><span class="lineCov">        236 :      forInit-&gt;append_init_stmt(statement);</span></a>
<a name="8999"><span class="lineNum">    8999 </span>            : </a>
<a name="9000"><span class="lineNum">    9000 </span>            :   // DQ (11/3/2012): Added call to set file info to default settings.</a>
<a name="9001"><span class="lineNum">    9001 </span><span class="lineCov">        236 :      setSourcePosition(forInit);</span></a>
<a name="9002"><span class="lineNum">    9002 </span>            : </a>
<a name="9003"><span class="lineNum">    9003 </span><span class="lineCov">        236 :      return forInit;</span></a>
<a name="9004"><span class="lineNum">    9004 </span>            :    }</a>
<a name="9005"><span class="lineNum">    9005 </span>            : </a>
<a name="9006"><span class="lineNum">    9006 </span><span class="lineNoCov">          0 : SgForInitStatement * SageBuilder::buildForInitStatement(const SgStatementPtrList &amp; statements)</span></a>
<a name="9007"><span class="lineNum">    9007 </span>            : {</a>
<a name="9008"><span class="lineNum">    9008 </span><span class="lineNoCov">          0 :   SgForInitStatement * result = new SgForInitStatement();</span></a>
<a name="9009"><span class="lineNum">    9009 </span><span class="lineNoCov">          0 :   result-&gt;get_init_stmt() = statements;</span></a>
<a name="9010"><span class="lineNum">    9010 </span>            : </a>
<a name="9011"><span class="lineNum">    9011 </span><span class="lineNoCov">          0 :   for (SgStatementPtrList::iterator it = result-&gt;get_init_stmt().begin(); it != result-&gt;get_init_stmt().end(); it++)</span></a>
<a name="9012"><span class="lineNum">    9012 </span><span class="lineNoCov">          0 :     (*it)-&gt;set_parent(result);</span></a>
<a name="9013"><span class="lineNum">    9013 </span>            : </a>
<a name="9014"><span class="lineNum">    9014 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9015"><span class="lineNum">    9015 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9016"><span class="lineNum">    9016 </span>            : }</a>
<a name="9017"><span class="lineNum">    9017 </span>            : </a>
<a name="9018"><span class="lineNum">    9018 </span>            : SgForInitStatement*</a>
<a name="9019"><span class="lineNum">    9019 </span><span class="lineCov">        722 : SageBuilder::buildForInitStatement_nfi(SgStatementPtrList &amp; statements)</span></a>
<a name="9020"><span class="lineNum">    9020 </span>            :    {</a>
<a name="9021"><span class="lineNum">    9021 </span><span class="lineCov">        722 :      SgForInitStatement * result = new SgForInitStatement();</span></a>
<a name="9022"><span class="lineNum">    9022 </span>            : </a>
<a name="9023"><span class="lineNum">    9023 </span><span class="lineCov">        722 :      result-&gt;get_init_stmt() = statements;</span></a>
<a name="9024"><span class="lineNum">    9024 </span>            : </a>
<a name="9025"><span class="lineNum">    9025 </span><span class="lineCov">       1444 :      for (SgStatementPtrList::iterator it = result-&gt;get_init_stmt().begin(); it != result-&gt;get_init_stmt().end(); it++)</span></a>
<a name="9026"><span class="lineNum">    9026 </span>            :         {</a>
<a name="9027"><span class="lineNum">    9027 </span>            : #if 0</a>
<a name="9028"><span class="lineNum">    9028 </span>            :           printf (&quot;In buildForInitStatement_nfi(): set the parent for it = %p = %s \n&quot;,*it,(*it)-&gt;class_name().c_str());</a>
<a name="9029"><span class="lineNum">    9029 </span>            : #endif</a>
<a name="9030"><span class="lineNum">    9030 </span><span class="lineCov">        722 :           (*it)-&gt;set_parent(result);</span></a>
<a name="9031"><span class="lineNum">    9031 </span>            :         }</a>
<a name="9032"><span class="lineNum">    9032 </span>            : </a>
<a name="9033"><span class="lineNum">    9033 </span>            :   // DQ (11/3/2012): Added call to set file info to default settings.</a>
<a name="9034"><span class="lineNum">    9034 </span><span class="lineCov">        722 :      setSourcePosition(result);</span></a>
<a name="9035"><span class="lineNum">    9035 </span>            : </a>
<a name="9036"><span class="lineNum">    9036 </span><span class="lineCov">        722 :      return result;</span></a>
<a name="9037"><span class="lineNum">    9037 </span>            :    }</a>
<a name="9038"><span class="lineNum">    9038 </span>            : </a>
<a name="9039"><span class="lineNum">    9039 </span>            : //! Based on the contribution from Pradeep Srinivasa@ LANL</a>
<a name="9040"><span class="lineNum">    9040 </span>            : //Liao, 8/27/2008</a>
<a name="9041"><span class="lineNum">    9041 </span><span class="lineCov">          9 : SgForStatement * SageBuilder::buildForStatement(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)</span></a>
<a name="9042"><span class="lineNum">    9042 </span>            : {</a>
<a name="9043"><span class="lineNum">    9043 </span><span class="lineCov">          9 :      SgForStatement * result = new SgForStatement(test,increment, loop_body);</span></a>
<a name="9044"><span class="lineNum">    9044 </span><span class="lineCov">          9 :      ROSE_ASSERT(result);</span></a>
<a name="9045"><span class="lineNum">    9045 </span>            : </a>
<a name="9046"><span class="lineNum">    9046 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9047"><span class="lineNum">    9047 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9048"><span class="lineNum">    9048 </span><span class="lineCov">          9 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9049"><span class="lineNum">    9049 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="9050"><span class="lineNum">    9050 </span>            : </a>
<a name="9051"><span class="lineNum">    9051 </span><span class="lineCov">          9 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="9052"><span class="lineNum">    9052 </span><span class="lineCov">          9 :      if (test)</span></a>
<a name="9053"><span class="lineNum">    9053 </span><span class="lineCov">          9 :           test-&gt;set_parent(result);</span></a>
<a name="9054"><span class="lineNum">    9054 </span><span class="lineCov">          9 :      if (loop_body)</span></a>
<a name="9055"><span class="lineNum">    9055 </span><span class="lineCov">          9 :           loop_body-&gt;set_parent(result);</span></a>
<a name="9056"><span class="lineNum">    9056 </span><span class="lineCov">          9 :      if (increment)</span></a>
<a name="9057"><span class="lineNum">    9057 </span><span class="lineCov">          9 :           increment-&gt;set_parent(result);</span></a>
<a name="9058"><span class="lineNum">    9058 </span>            : </a>
<a name="9059"><span class="lineNum">    9059 </span><span class="lineCov">          9 :   if (else_body)</span></a>
<a name="9060"><span class="lineNum">    9060 </span><span class="lineNoCov">          0 :     else_body-&gt;set_parent(result);</span></a>
<a name="9061"><span class="lineNum">    9061 </span><span class="lineCov">          9 :   result-&gt;set_else_body(else_body);</span></a>
<a name="9062"><span class="lineNum">    9062 </span>            : </a>
<a name="9063"><span class="lineNum">    9063 </span>            :   // CH (5/13/2010): If the initialize_stmt is an object of SgForInitStatement, we can directly put it</a>
<a name="9064"><span class="lineNum">    9064 </span>            :   // into for statement. Or else, there will be two semicolons after unparsing.</a>
<a name="9065"><span class="lineNum">    9065 </span><span class="lineCov">          9 :      if (SgForInitStatement* for_init_stmt = isSgForInitStatement(initialize_stmt))</span></a>
<a name="9066"><span class="lineNum">    9066 </span>            :         {</a>
<a name="9067"><span class="lineNum">    9067 </span>            : #if 0</a>
<a name="9068"><span class="lineNum">    9068 </span>            :           printf (&quot;Handled a proper SgForInitStatement as input! \n&quot;);</a>
<a name="9069"><span class="lineNum">    9069 </span>            : #endif</a>
<a name="9070"><span class="lineNum">    9070 </span>            :        // DQ (7/30/2011): We have to delete the the SgForInitStatement build within the SgForStatement::post_constructor_initialization()</a>
<a name="9071"><span class="lineNum">    9071 </span>            :        // to avoid causing errors in the AST consistancy checking later.</a>
<a name="9072"><span class="lineNum">    9072 </span><span class="lineNoCov">          0 :           if (result-&gt;get_for_init_stmt() != NULL)</span></a>
<a name="9073"><span class="lineNum">    9073 </span>            :              {</a>
<a name="9074"><span class="lineNum">    9074 </span>            : #if 0</a>
<a name="9075"><span class="lineNum">    9075 </span>            :                printf (&quot;Deleting the old one build in SgForStatement::post_constructor_initialization() \n&quot;);</a>
<a name="9076"><span class="lineNum">    9076 </span>            : #endif</a>
<a name="9077"><span class="lineNum">    9077 </span><span class="lineNoCov">          0 :                delete result-&gt;get_for_init_stmt();</span></a>
<a name="9078"><span class="lineNum">    9078 </span><span class="lineNoCov">          0 :                result-&gt;set_for_init_stmt(NULL);</span></a>
<a name="9079"><span class="lineNum">    9079 </span>            :              }</a>
<a name="9080"><span class="lineNum">    9080 </span>            : </a>
<a name="9081"><span class="lineNum">    9081 </span><span class="lineNoCov">          0 :           result-&gt;set_for_init_stmt(for_init_stmt);</span></a>
<a name="9082"><span class="lineNum">    9082 </span><span class="lineNoCov">          0 :           for_init_stmt-&gt;set_parent(result);</span></a>
<a name="9083"><span class="lineNum">    9083 </span><span class="lineNoCov">          0 :           return result;</span></a>
<a name="9084"><span class="lineNum">    9084 </span>            :         }</a>
<a name="9085"><span class="lineNum">    9085 </span>            : </a>
<a name="9086"><span class="lineNum">    9086 </span><span class="lineCov">          9 :      SgForInitStatement* init_stmt = new SgForInitStatement();</span></a>
<a name="9087"><span class="lineNum">    9087 </span><span class="lineCov">          9 :      ROSE_ASSERT(init_stmt);</span></a>
<a name="9088"><span class="lineNum">    9088 </span><span class="lineCov">          9 :      setOneSourcePositionForTransformation(init_stmt);</span></a>
<a name="9089"><span class="lineNum">    9089 </span>            : </a>
<a name="9090"><span class="lineNum">    9090 </span>            :   // DQ (7/30/2011): We have to delete the the SgForInitStatement build within the SgForStatement::post_constructor_initialization().</a>
<a name="9091"><span class="lineNum">    9091 </span>            :   // to avoid causeing errors in the AST consistancy checking later.</a>
<a name="9092"><span class="lineNum">    9092 </span><span class="lineCov">          9 :      if (result-&gt;get_for_init_stmt() != NULL)</span></a>
<a name="9093"><span class="lineNum">    9093 </span>            :         {</a>
<a name="9094"><span class="lineNum">    9094 </span><span class="lineCov">          9 :           delete result-&gt;get_for_init_stmt();</span></a>
<a name="9095"><span class="lineNum">    9095 </span><span class="lineCov">          9 :           result-&gt;set_for_init_stmt(NULL);</span></a>
<a name="9096"><span class="lineNum">    9096 </span>            :         }</a>
<a name="9097"><span class="lineNum">    9097 </span>            : </a>
<a name="9098"><span class="lineNum">    9098 </span><span class="lineCov">          9 :      result-&gt;set_for_init_stmt(init_stmt);</span></a>
<a name="9099"><span class="lineNum">    9099 </span><span class="lineCov">          9 :      init_stmt-&gt;set_parent(result);</span></a>
<a name="9100"><span class="lineNum">    9100 </span>            : </a>
<a name="9101"><span class="lineNum">    9101 </span><span class="lineCov">          9 :      if (initialize_stmt)</span></a>
<a name="9102"><span class="lineNum">    9102 </span>            :         {</a>
<a name="9103"><span class="lineNum">    9103 </span><span class="lineCov">          9 :           init_stmt-&gt;append_init_stmt(initialize_stmt);</span></a>
<a name="9104"><span class="lineNum">    9104 </span>            :        // Support for &quot;for (int i=0; )&quot;, Liao, 3/11/2009</a>
<a name="9105"><span class="lineNum">    9105 </span>            :        // The symbols are inserted into the symbol table attached to SgForStatement</a>
<a name="9106"><span class="lineNum">    9106 </span><span class="lineCov">          9 :           if (isSgVariableDeclaration(initialize_stmt))</span></a>
<a name="9107"><span class="lineNum">    9107 </span>            :              {</a>
<a name="9108"><span class="lineNum">    9108 </span><span class="lineCov">          1 :                fixVariableDeclaration(isSgVariableDeclaration(initialize_stmt),result);</span></a>
<a name="9109"><span class="lineNum">    9109 </span>            :             // fix varRefExp to the index variable used in increment, conditional expressions</a>
<a name="9110"><span class="lineNum">    9110 </span><span class="lineCov">          1 :                fixVariableReferences(result);</span></a>
<a name="9111"><span class="lineNum">    9111 </span>            :              }</a>
<a name="9112"><span class="lineNum">    9112 </span>            :         }</a>
<a name="9113"><span class="lineNum">    9113 </span>            : </a>
<a name="9114"><span class="lineNum">    9114 </span>            :      return result;</a>
<a name="9115"><span class="lineNum">    9115 </span>            :    }</a>
<a name="9116"><span class="lineNum">    9116 </span>            : </a>
<a name="9117"><span class="lineNum">    9117 </span>            : </a>
<a name="9118"><span class="lineNum">    9118 </span>            : //! Based on the contribution from Pradeep Srinivasa@ LANL</a>
<a name="9119"><span class="lineNum">    9119 </span>            : //Liao, 8/27/2008</a>
<a name="9120"><span class="lineNum">    9120 </span>            : SgForStatement*</a>
<a name="9121"><span class="lineNum">    9121 </span><span class="lineNoCov">          0 : SageBuilder::buildForStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)</span></a>
<a name="9122"><span class="lineNum">    9122 </span>            :    {</a>
<a name="9123"><span class="lineNum">    9123 </span><span class="lineNoCov">          0 :      SgForStatement * result = new SgForStatement(test, increment, loop_body);</span></a>
<a name="9124"><span class="lineNum">    9124 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="9125"><span class="lineNum">    9125 </span>            : </a>
<a name="9126"><span class="lineNum">    9126 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9127"><span class="lineNum">    9127 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9128"><span class="lineNum">    9128 </span><span class="lineNoCov">          0 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9129"><span class="lineNum">    9129 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="9130"><span class="lineNum">    9130 </span>            : </a>
<a name="9131"><span class="lineNum">    9131 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9132"><span class="lineNum">    9132 </span><span class="lineNoCov">          0 :      if (test)      test-&gt;set_parent(result);</span></a>
<a name="9133"><span class="lineNum">    9133 </span><span class="lineNoCov">          0 :      if (loop_body) loop_body-&gt;set_parent(result);</span></a>
<a name="9134"><span class="lineNum">    9134 </span><span class="lineNoCov">          0 :      if (increment) increment-&gt;set_parent(result);</span></a>
<a name="9135"><span class="lineNum">    9135 </span><span class="lineNoCov">          0 :      if (else_body) else_body-&gt;set_parent(result);</span></a>
<a name="9136"><span class="lineNum">    9136 </span>            : </a>
<a name="9137"><span class="lineNum">    9137 </span><span class="lineNoCov">          0 :      result-&gt;set_else_body(else_body);</span></a>
<a name="9138"><span class="lineNum">    9138 </span>            : </a>
<a name="9139"><span class="lineNum">    9139 </span><span class="lineNoCov">          0 :      if (initialize_stmt != NULL)</span></a>
<a name="9140"><span class="lineNum">    9140 </span>            :         {</a>
<a name="9141"><span class="lineNum">    9141 </span><span class="lineNoCov">          0 :           SgForInitStatement* init_stmt = result-&gt;get_for_init_stmt();</span></a>
<a name="9142"><span class="lineNum">    9142 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(init_stmt);</span></a>
<a name="9143"><span class="lineNum">    9143 </span><span class="lineNoCov">          0 :           setOneSourcePositionNull(init_stmt);</span></a>
<a name="9144"><span class="lineNum">    9144 </span><span class="lineNoCov">          0 :           init_stmt-&gt;append_init_stmt(initialize_stmt);</span></a>
<a name="9145"><span class="lineNum">    9145 </span><span class="lineNoCov">          0 :           initialize_stmt-&gt;set_parent(init_stmt);</span></a>
<a name="9146"><span class="lineNum">    9146 </span>            :         }</a>
<a name="9147"><span class="lineNum">    9147 </span>            : </a>
<a name="9148"><span class="lineNum">    9148 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9149"><span class="lineNum">    9149 </span>            :    }</a>
<a name="9150"><span class="lineNum">    9150 </span>            : </a>
<a name="9151"><span class="lineNum">    9151 </span>            : </a>
<a name="9152"><span class="lineNum">    9152 </span>            : SgForStatement*</a>
<a name="9153"><span class="lineNum">    9153 </span><span class="lineNoCov">          0 : SageBuilder::buildForStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)</span></a>
<a name="9154"><span class="lineNum">    9154 </span>            :    {</a>
<a name="9155"><span class="lineNum">    9155 </span><span class="lineNoCov">          0 :      SgForStatement * result = new SgForStatement(init_stmt, test, increment, loop_body);</span></a>
<a name="9156"><span class="lineNum">    9156 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="9157"><span class="lineNum">    9157 </span>            : </a>
<a name="9158"><span class="lineNum">    9158 </span>            : #if 1</a>
<a name="9159"><span class="lineNum">    9159 </span>            :   // DQ (9/26/2012): Refactored this function to allow for where the SgForStatement had to be</a>
<a name="9160"><span class="lineNum">    9160 </span>            :   // constructed early to define the scope for types that can be defined in the SgForInitStatement.</a>
<a name="9161"><span class="lineNum">    9161 </span><span class="lineNoCov">          0 :      buildForStatement_nfi(result,init_stmt,test,increment,loop_body,else_body);</span></a>
<a name="9162"><span class="lineNum">    9162 </span>            : #else</a>
<a name="9163"><span class="lineNum">    9163 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="9164"><span class="lineNum">    9164 </span>            :      if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9165"><span class="lineNum">    9165 </span>            :           result-&gt;setCaseInsensitive(true);</a>
<a name="9166"><span class="lineNum">    9166 </span>            : </a>
<a name="9167"><span class="lineNum">    9167 </span>            :      setOneSourcePositionNull(result);</a>
<a name="9168"><span class="lineNum">    9168 </span>            :      if (test)           test-&gt;set_parent(result);</a>
<a name="9169"><span class="lineNum">    9169 </span>            :      if (loop_body) loop_body-&gt;set_parent(result);</a>
<a name="9170"><span class="lineNum">    9170 </span>            :      if (increment) increment-&gt;set_parent(result);</a>
<a name="9171"><span class="lineNum">    9171 </span>            :      if (init_stmt) init_stmt-&gt;set_parent(result);</a>
<a name="9172"><span class="lineNum">    9172 </span>            : </a>
<a name="9173"><span class="lineNum">    9173 </span>            :      if (else_body) init_stmt-&gt;set_parent(result);</a>
<a name="9174"><span class="lineNum">    9174 </span>            :      result-&gt;set_else_body(else_body);</a>
<a name="9175"><span class="lineNum">    9175 </span>            : #endif</a>
<a name="9176"><span class="lineNum">    9176 </span>            : </a>
<a name="9177"><span class="lineNum">    9177 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9178"><span class="lineNum">    9178 </span>            :    }</a>
<a name="9179"><span class="lineNum">    9179 </span>            : </a>
<a name="9180"><span class="lineNum">    9180 </span>            : </a>
<a name="9181"><span class="lineNum">    9181 </span>            : void</a>
<a name="9182"><span class="lineNum">    9182 </span><span class="lineCov">        958 : SageBuilder::buildForStatement_nfi(SgForStatement* result, SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)</span></a>
<a name="9183"><span class="lineNum">    9183 </span>            :    {</a>
<a name="9184"><span class="lineNum">    9184 </span>            :   // DQ (9/26/2012): Refactored this function to allow for where the SgForStatement had to be</a>
<a name="9185"><span class="lineNum">    9185 </span>            :   // constructed early to define the scope for types that can be defined in the SgForInitStatement.</a>
<a name="9186"><span class="lineNum">    9186 </span>            : </a>
<a name="9187"><span class="lineNum">    9187 </span><span class="lineCov">        958 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="9188"><span class="lineNum">    9188 </span>            : </a>
<a name="9189"><span class="lineNum">    9189 </span>            :   // DQ  (9/26/2012): I think we can assert this (fails test2004_77.C).</a>
<a name="9190"><span class="lineNum">    9190 </span>            :   // ROSE_ASSERT(init_stmt != NULL);</a>
<a name="9191"><span class="lineNum">    9191 </span>            :   // ROSE_ASSERT(test      != NULL);</a>
<a name="9192"><span class="lineNum">    9192 </span>            :   // ROSE_ASSERT(increment != NULL);</a>
<a name="9193"><span class="lineNum">    9193 </span>            :   // ROSE_ASSERT(loop_body != NULL);</a>
<a name="9194"><span class="lineNum">    9194 </span>            : </a>
<a name="9195"><span class="lineNum">    9195 </span>            : #if 0</a>
<a name="9196"><span class="lineNum">    9196 </span>            :   // DQ (9/26/2012): It might be that these should always be set.</a>
<a name="9197"><span class="lineNum">    9197 </span>            : #if 0</a>
<a name="9198"><span class="lineNum">    9198 </span>            :      if (result-&gt;get_for_init_stmt() == NULL)</a>
<a name="9199"><span class="lineNum">    9199 </span>            :           result-&gt;set_for_init_stmt(init_stmt);</a>
<a name="9200"><span class="lineNum">    9200 </span>            :      if (result-&gt;get_test() == NULL)</a>
<a name="9201"><span class="lineNum">    9201 </span>            :           result-&gt;set_test(test);</a>
<a name="9202"><span class="lineNum">    9202 </span>            :      if (result-&gt;get_increment() == NULL)</a>
<a name="9203"><span class="lineNum">    9203 </span>            :           result-&gt;set_increment(increment);</a>
<a name="9204"><span class="lineNum">    9204 </span>            :      if (result-&gt;get_loop_body() == NULL)</a>
<a name="9205"><span class="lineNum">    9205 </span>            :           result-&gt;set_loop_body(loop_body);</a>
<a name="9206"><span class="lineNum">    9206 </span>            : #else</a>
<a name="9207"><span class="lineNum">    9207 </span>            :   // This test might make it impossible for us to use this function in SgForStatement* SageBuilder::buildForStatement_nfi()</a>
<a name="9208"><span class="lineNum">    9208 </span>            :      if (result-&gt;get_for_init_stmt() != NULL)</a>
<a name="9209"><span class="lineNum">    9209 </span>            :         {</a>
<a name="9210"><span class="lineNum">    9210 </span>            :           if (init_stmt != result-&gt;get_for_init_stmt())</a>
<a name="9211"><span class="lineNum">    9211 </span>            :              {</a>
<a name="9212"><span class="lineNum">    9212 </span>            :                delete result-&gt;get_for_init_stmt();</a>
<a name="9213"><span class="lineNum">    9213 </span>            :                result-&gt;set_for_init_stmt(NULL);</a>
<a name="9214"><span class="lineNum">    9214 </span>            :              }</a>
<a name="9215"><span class="lineNum">    9215 </span>            :        // delete result-&gt;get_for_init_stmt();</a>
<a name="9216"><span class="lineNum">    9216 </span>            :        // result-&gt;set_for_init_stmt(NULL);</a>
<a name="9217"><span class="lineNum">    9217 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="9218"><span class="lineNum">    9218 </span>            :           printf (&quot;Error: In SgForStatement, SgForInitStatement is already set result-&gt;get_for_init_stmt() = %p = %s \n&quot;,result-&gt;get_for_init_stmt(),result-&gt;get_for_init_stmt()-&gt;class_name().c_str());</a>
<a name="9219"><span class="lineNum">    9219 </span>            : #endif</a>
<a name="9220"><span class="lineNum">    9220 </span>            :        // ROSE_ASSERT(false);</a>
<a name="9221"><span class="lineNum">    9221 </span>            :         }</a>
<a name="9222"><span class="lineNum">    9222 </span>            : #endif</a>
<a name="9223"><span class="lineNum">    9223 </span>            : #endif</a>
<a name="9224"><span class="lineNum">    9224 </span>            : </a>
<a name="9225"><span class="lineNum">    9225 </span>            :   // DQ (11/4/2012): I have added support for remove existing subtrees if they are different from what is provided as input.</a>
<a name="9226"><span class="lineNum">    9226 </span><span class="lineCov">        958 :      if (result-&gt;get_for_init_stmt() != NULL &amp;&amp; init_stmt != result-&gt;get_for_init_stmt())</span></a>
<a name="9227"><span class="lineNum">    9227 </span>            :         {</a>
<a name="9228"><span class="lineNum">    9228 </span><span class="lineCov">        958 :           delete result-&gt;get_for_init_stmt();</span></a>
<a name="9229"><span class="lineNum">    9229 </span><span class="lineCov">        958 :           result-&gt;set_for_init_stmt(NULL);</span></a>
<a name="9230"><span class="lineNum">    9230 </span>            :         }</a>
<a name="9231"><span class="lineNum">    9231 </span>            : </a>
<a name="9232"><span class="lineNum">    9232 </span><span class="lineCov">        958 :      if (result-&gt;get_test() != NULL &amp;&amp; test != result-&gt;get_test())</span></a>
<a name="9233"><span class="lineNum">    9233 </span>            :         {</a>
<a name="9234"><span class="lineNum">    9234 </span><span class="lineNoCov">          0 :           delete result-&gt;get_test();</span></a>
<a name="9235"><span class="lineNum">    9235 </span><span class="lineNoCov">          0 :           result-&gt;set_test(NULL);</span></a>
<a name="9236"><span class="lineNum">    9236 </span>            :         }</a>
<a name="9237"><span class="lineNum">    9237 </span>            : </a>
<a name="9238"><span class="lineNum">    9238 </span><span class="lineCov">        958 :      if (result-&gt;get_increment() != NULL &amp;&amp; increment != result-&gt;get_increment())</span></a>
<a name="9239"><span class="lineNum">    9239 </span>            :         {</a>
<a name="9240"><span class="lineNum">    9240 </span><span class="lineNoCov">          0 :           delete result-&gt;get_increment();</span></a>
<a name="9241"><span class="lineNum">    9241 </span><span class="lineNoCov">          0 :           result-&gt;set_increment(NULL);</span></a>
<a name="9242"><span class="lineNum">    9242 </span>            :         }</a>
<a name="9243"><span class="lineNum">    9243 </span>            : </a>
<a name="9244"><span class="lineNum">    9244 </span><span class="lineCov">        958 :      if (result-&gt;get_loop_body() != NULL &amp;&amp; loop_body != result-&gt;get_loop_body())</span></a>
<a name="9245"><span class="lineNum">    9245 </span>            :         {</a>
<a name="9246"><span class="lineNum">    9246 </span><span class="lineNoCov">          0 :           delete result-&gt;get_loop_body();</span></a>
<a name="9247"><span class="lineNum">    9247 </span><span class="lineNoCov">          0 :           result-&gt;set_loop_body(NULL);</span></a>
<a name="9248"><span class="lineNum">    9248 </span>            :         }</a>
<a name="9249"><span class="lineNum">    9249 </span>            : </a>
<a name="9250"><span class="lineNum">    9250 </span><span class="lineCov">        958 :      if (result-&gt;get_else_body() != NULL &amp;&amp; else_body != result-&gt;get_else_body())</span></a>
<a name="9251"><span class="lineNum">    9251 </span>            :         {</a>
<a name="9252"><span class="lineNum">    9252 </span><span class="lineNoCov">          0 :           delete result-&gt;get_else_body();</span></a>
<a name="9253"><span class="lineNum">    9253 </span><span class="lineNoCov">          0 :           result-&gt;set_else_body(NULL);</span></a>
<a name="9254"><span class="lineNum">    9254 </span>            :         }</a>
<a name="9255"><span class="lineNum">    9255 </span>            : </a>
<a name="9256"><span class="lineNum">    9256 </span><span class="lineCov">        958 :      result-&gt;set_for_init_stmt(init_stmt);</span></a>
<a name="9257"><span class="lineNum">    9257 </span><span class="lineCov">        958 :      result-&gt;set_test(test);</span></a>
<a name="9258"><span class="lineNum">    9258 </span><span class="lineCov">        958 :      result-&gt;set_increment(increment);</span></a>
<a name="9259"><span class="lineNum">    9259 </span><span class="lineCov">        958 :      result-&gt;set_loop_body(loop_body);</span></a>
<a name="9260"><span class="lineNum">    9260 </span>            : </a>
<a name="9261"><span class="lineNum">    9261 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9262"><span class="lineNum">    9262 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9263"><span class="lineNum">    9263 </span><span class="lineCov">        958 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9264"><span class="lineNum">    9264 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="9265"><span class="lineNum">    9265 </span>            : </a>
<a name="9266"><span class="lineNum">    9266 </span><span class="lineCov">        958 :      setOneSourcePositionNull(result);</span></a>
<a name="9267"><span class="lineNum">    9267 </span><span class="lineCov">        958 :      if (test)           test-&gt;set_parent(result);</span></a>
<a name="9268"><span class="lineNum">    9268 </span><span class="lineCov">        958 :      if (loop_body) loop_body-&gt;set_parent(result);</span></a>
<a name="9269"><span class="lineNum">    9269 </span><span class="lineCov">        958 :      if (increment) increment-&gt;set_parent(result);</span></a>
<a name="9270"><span class="lineNum">    9270 </span><span class="lineCov">        958 :      if (init_stmt) init_stmt-&gt;set_parent(result);</span></a>
<a name="9271"><span class="lineNum">    9271 </span>            : </a>
<a name="9272"><span class="lineNum">    9272 </span><span class="lineCov">        958 :      if (else_body) init_stmt-&gt;set_parent(result);</span></a>
<a name="9273"><span class="lineNum">    9273 </span><span class="lineCov">        958 :      result-&gt;set_else_body(else_body);</span></a>
<a name="9274"><span class="lineNum">    9274 </span>            : </a>
<a name="9275"><span class="lineNum">    9275 </span><span class="lineCov">        958 :      ROSE_ASSERT(result-&gt;get_for_init_stmt() != NULL);</span></a>
<a name="9276"><span class="lineNum">    9276 </span><span class="lineCov">        958 :      ROSE_ASSERT(result-&gt;get_test()          != NULL);</span></a>
<a name="9277"><span class="lineNum">    9277 </span><span class="lineCov">        958 :      ROSE_ASSERT(result-&gt;get_increment()     != NULL);</span></a>
<a name="9278"><span class="lineNum">    9278 </span><span class="lineCov">        958 :      ROSE_ASSERT(result-&gt;get_loop_body()     != NULL);</span></a>
<a name="9279"><span class="lineNum">    9279 </span><span class="lineCov">        958 :    }</span></a>
<a name="9280"><span class="lineNum">    9280 </span>            : </a>
<a name="9281"><span class="lineNum">    9281 </span>            : </a>
<a name="9282"><span class="lineNum">    9282 </span>            : // DQ (3/26/2018): Adding support for range based for statement.</a>
<a name="9283"><span class="lineNum">    9283 </span>            : // SgRangeBasedForStatement* SageBuilder::buildRangeBasedForStatement_nfi(SgVariableDeclaration* initializer, SgExpression* range, SgStatement* body)</a>
<a name="9284"><span class="lineNum">    9284 </span>            : SgRangeBasedForStatement*</a>
<a name="9285"><span class="lineNum">    9285 </span><span class="lineNoCov">          0 : SageBuilder::buildRangeBasedForStatement_nfi(</span></a>
<a name="9286"><span class="lineNum">    9286 </span>            :      SgVariableDeclaration* initializer,          SgVariableDeclaration* range,</a>
<a name="9287"><span class="lineNum">    9287 </span>            :      SgVariableDeclaration* begin_declaration,    SgVariableDeclaration* end_declaration,</a>
<a name="9288"><span class="lineNum">    9288 </span>            :      SgExpression*          not_equal_expression, SgExpression*          increment_expression,</a>
<a name="9289"><span class="lineNum">    9289 </span>            :      SgStatement*           body)</a>
<a name="9290"><span class="lineNum">    9290 </span>            :    {</a>
<a name="9291"><span class="lineNum">    9291 </span>            :   // DQ (6/26/2019): Commented these out so that we could build the SgRangeBasedForStatement before</a>
<a name="9292"><span class="lineNum">    9292 </span>            :   // building the children, since the scope of the chldren will be the SgRangeBasedForStatement and</a>
<a name="9293"><span class="lineNum">    9293 </span>            :   // it must exist before the children are constructed.</a>
<a name="9294"><span class="lineNum">    9294 </span>            :   // ROSE_ASSERT(initializer != NULL);</a>
<a name="9295"><span class="lineNum">    9295 </span>            :   // ROSE_ASSERT(range       != NULL);</a>
<a name="9296"><span class="lineNum">    9296 </span>            : </a>
<a name="9297"><span class="lineNum">    9297 </span>            :   // DQ (6/26/2019): This was already commented out.</a>
<a name="9298"><span class="lineNum">    9298 </span>            :   // ROSE_ASSERT(body        != NULL);</a>
<a name="9299"><span class="lineNum">    9299 </span>            : </a>
<a name="9300"><span class="lineNum">    9300 </span><span class="lineNoCov">          0 :      SgRangeBasedForStatement* result = new SgRangeBasedForStatement(initializer, range, begin_declaration, end_declaration, not_equal_expression, increment_expression, body);</span></a>
<a name="9301"><span class="lineNum">    9301 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="9302"><span class="lineNum">    9302 </span>            : </a>
<a name="9303"><span class="lineNum">    9303 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9304"><span class="lineNum">    9304 </span>            : </a>
<a name="9305"><span class="lineNum">    9305 </span><span class="lineNoCov">          0 :      if (initializer != NULL) initializer-&gt;set_parent(result);</span></a>
<a name="9306"><span class="lineNum">    9306 </span><span class="lineNoCov">          0 :      if (range       != NULL) range-&gt;set_parent(result);</span></a>
<a name="9307"><span class="lineNum">    9307 </span>            : </a>
<a name="9308"><span class="lineNum">    9308 </span><span class="lineNoCov">          0 :      if (begin_declaration != NULL) begin_declaration-&gt;set_parent(result);</span></a>
<a name="9309"><span class="lineNum">    9309 </span><span class="lineNoCov">          0 :      if (end_declaration   != NULL) end_declaration-&gt;set_parent(result);</span></a>
<a name="9310"><span class="lineNum">    9310 </span>            : </a>
<a name="9311"><span class="lineNum">    9311 </span><span class="lineNoCov">          0 :      if (not_equal_expression != NULL) not_equal_expression-&gt;set_parent(result);</span></a>
<a name="9312"><span class="lineNum">    9312 </span><span class="lineNoCov">          0 :      if (increment_expression != NULL) increment_expression-&gt;set_parent(result);</span></a>
<a name="9313"><span class="lineNum">    9313 </span>            : </a>
<a name="9314"><span class="lineNum">    9314 </span><span class="lineNoCov">          0 :      if (body        != NULL) body-&gt;set_parent(result);</span></a>
<a name="9315"><span class="lineNum">    9315 </span>            : </a>
<a name="9316"><span class="lineNum">    9316 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9317"><span class="lineNum">    9317 </span>            :    }</a>
<a name="9318"><span class="lineNum">    9318 </span>            : </a>
<a name="9319"><span class="lineNum">    9319 </span>            : </a>
<a name="9320"><span class="lineNum">    9320 </span>            : void</a>
<a name="9321"><span class="lineNum">    9321 </span><span class="lineCov">         57 : SageBuilder::buildDoWhileStatement_nfi(SgDoWhileStmt* result, SgStatement * body, SgStatement * condition)</span></a>
<a name="9322"><span class="lineNum">    9322 </span>            :    {</a>
<a name="9323"><span class="lineNum">    9323 </span>            :   // DQ (3/22/2014): This function has been built to support reusing an existing SgDoWhileStatement</a>
<a name="9324"><span class="lineNum">    9324 </span>            :   // that may have been built and pushed onto the stack as part of a top-down construction of the AST.</a>
<a name="9325"><span class="lineNum">    9325 </span>            :   // It is required in the EDG 4.8 useage because of a change from EDG 4.7 to 4.8 in how blocks are</a>
<a name="9326"><span class="lineNum">    9326 </span>            :   // handled (end-of-construct entries).</a>
<a name="9327"><span class="lineNum">    9327 </span>            : </a>
<a name="9328"><span class="lineNum">    9328 </span><span class="lineCov">         57 :      ROSE_ASSERT(result    != NULL);</span></a>
<a name="9329"><span class="lineNum">    9329 </span><span class="lineCov">         57 :      ROSE_ASSERT(body      != NULL);</span></a>
<a name="9330"><span class="lineNum">    9330 </span><span class="lineCov">         57 :      ROSE_ASSERT(condition != NULL);</span></a>
<a name="9331"><span class="lineNum">    9331 </span>            : </a>
<a name="9332"><span class="lineNum">    9332 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_body()      == NULL);</span></a>
<a name="9333"><span class="lineNum">    9333 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_condition() == NULL);</span></a>
<a name="9334"><span class="lineNum">    9334 </span>            : </a>
<a name="9335"><span class="lineNum">    9335 </span><span class="lineCov">         57 :      result-&gt;set_body(body);</span></a>
<a name="9336"><span class="lineNum">    9336 </span><span class="lineCov">         57 :      result-&gt;set_condition(condition);</span></a>
<a name="9337"><span class="lineNum">    9337 </span>            : </a>
<a name="9338"><span class="lineNum">    9338 </span><span class="lineCov">         57 :      body-&gt;set_parent(result);</span></a>
<a name="9339"><span class="lineNum">    9339 </span><span class="lineCov">         57 :      condition-&gt;set_parent(result);</span></a>
<a name="9340"><span class="lineNum">    9340 </span>            : </a>
<a name="9341"><span class="lineNum">    9341 </span><span class="lineCov">         57 :      setOneSourcePositionNull(result);</span></a>
<a name="9342"><span class="lineNum">    9342 </span>            : </a>
<a name="9343"><span class="lineNum">    9343 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_body()      != NULL);</span></a>
<a name="9344"><span class="lineNum">    9344 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_condition() != NULL);</span></a>
<a name="9345"><span class="lineNum">    9345 </span>            : </a>
<a name="9346"><span class="lineNum">    9346 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_body()-&gt;get_parent()      == result);</span></a>
<a name="9347"><span class="lineNum">    9347 </span><span class="lineCov">         57 :      ROSE_ASSERT(result-&gt;get_condition()-&gt;get_parent() == result);</span></a>
<a name="9348"><span class="lineNum">    9348 </span>            : </a>
<a name="9349"><span class="lineNum">    9349 </span>            : #if 0</a>
<a name="9350"><span class="lineNum">    9350 </span>            :      printf (&quot;Exiting at the base of SageBuilder::buildDoWhileStatement_nfi() \n&quot;);</a>
<a name="9351"><span class="lineNum">    9351 </span>            :      ROSE_ABORT();</a>
<a name="9352"><span class="lineNum">    9352 </span>            : #endif</a>
<a name="9353"><span class="lineNum">    9353 </span><span class="lineCov">         57 :    }</span></a>
<a name="9354"><span class="lineNum">    9354 </span>            : </a>
<a name="9355"><span class="lineNum">    9355 </span>            : </a>
<a name="9356"><span class="lineNum">    9356 </span>            : </a>
<a name="9357"><span class="lineNum">    9357 </span>            : //! Based on the contribution from Pradeep Srinivasa@ LANL</a>
<a name="9358"><span class="lineNum">    9358 </span>            : //Liao, 8/27/2008</a>
<a name="9359"><span class="lineNum">    9359 </span><span class="lineNoCov">          0 : SgUpcForAllStatement * SageBuilder::buildUpcForAllStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body)</span></a>
<a name="9360"><span class="lineNum">    9360 </span>            : {</a>
<a name="9361"><span class="lineNum">    9361 </span><span class="lineNoCov">          0 :   SgUpcForAllStatement * result = new SgUpcForAllStatement(test,increment, affinity, loop_body);</span></a>
<a name="9362"><span class="lineNum">    9362 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9363"><span class="lineNum">    9363 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9364"><span class="lineNum">    9364 </span><span class="lineNoCov">          0 :   if (test) test-&gt;set_parent(result);</span></a>
<a name="9365"><span class="lineNum">    9365 </span><span class="lineNoCov">          0 :   if (loop_body) loop_body-&gt;set_parent(result);</span></a>
<a name="9366"><span class="lineNum">    9366 </span><span class="lineNoCov">          0 :   if (increment) increment-&gt;set_parent(result);</span></a>
<a name="9367"><span class="lineNum">    9367 </span><span class="lineNoCov">          0 :   if (affinity) affinity-&gt;set_parent(result);</span></a>
<a name="9368"><span class="lineNum">    9368 </span>            : </a>
<a name="9369"><span class="lineNum">    9369 </span><span class="lineNoCov">          0 :   if (initialize_stmt != NULL) {</span></a>
<a name="9370"><span class="lineNum">    9370 </span><span class="lineNoCov">          0 :     SgForInitStatement* init_stmt = result-&gt;get_for_init_stmt();</span></a>
<a name="9371"><span class="lineNum">    9371 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(init_stmt);</span></a>
<a name="9372"><span class="lineNum">    9372 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(init_stmt);</span></a>
<a name="9373"><span class="lineNum">    9373 </span><span class="lineNoCov">          0 :     init_stmt-&gt;append_init_stmt(initialize_stmt);</span></a>
<a name="9374"><span class="lineNum">    9374 </span><span class="lineNoCov">          0 :     initialize_stmt-&gt;set_parent(init_stmt);</span></a>
<a name="9375"><span class="lineNum">    9375 </span>            :   }</a>
<a name="9376"><span class="lineNum">    9376 </span>            : </a>
<a name="9377"><span class="lineNum">    9377 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9378"><span class="lineNum">    9378 </span>            : }</a>
<a name="9379"><span class="lineNum">    9379 </span>            : </a>
<a name="9380"><span class="lineNum">    9380 </span>            : </a>
<a name="9381"><span class="lineNum">    9381 </span><span class="lineNoCov">          0 : SgUpcForAllStatement * SageBuilder::buildUpcForAllStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body)</span></a>
<a name="9382"><span class="lineNum">    9382 </span>            : {</a>
<a name="9383"><span class="lineNum">    9383 </span><span class="lineNoCov">          0 :   SgUpcForAllStatement * result = new SgUpcForAllStatement(init_stmt, test, increment, affinity, loop_body);</span></a>
<a name="9384"><span class="lineNum">    9384 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9385"><span class="lineNum">    9385 </span>            : </a>
<a name="9386"><span class="lineNum">    9386 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9387"><span class="lineNum">    9387 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9388"><span class="lineNum">    9388 </span><span class="lineNoCov">          0 :   if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9389"><span class="lineNum">    9389 </span><span class="lineNoCov">          0 :        result-&gt;setCaseInsensitive(true);</span></a>
<a name="9390"><span class="lineNum">    9390 </span>            : </a>
<a name="9391"><span class="lineNum">    9391 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9392"><span class="lineNum">    9392 </span><span class="lineNoCov">          0 :   if (test)           test-&gt;set_parent(result);</span></a>
<a name="9393"><span class="lineNum">    9393 </span><span class="lineNoCov">          0 :   if (loop_body) loop_body-&gt;set_parent(result);</span></a>
<a name="9394"><span class="lineNum">    9394 </span><span class="lineNoCov">          0 :   if (increment) increment-&gt;set_parent(result);</span></a>
<a name="9395"><span class="lineNum">    9395 </span><span class="lineNoCov">          0 :   if (affinity)   affinity-&gt;set_parent(result);</span></a>
<a name="9396"><span class="lineNum">    9396 </span><span class="lineNoCov">          0 :   if (init_stmt) init_stmt-&gt;set_parent(result);</span></a>
<a name="9397"><span class="lineNum">    9397 </span>            : </a>
<a name="9398"><span class="lineNum">    9398 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9399"><span class="lineNum">    9399 </span>            : }</a>
<a name="9400"><span class="lineNum">    9400 </span>            : </a>
<a name="9401"><span class="lineNum">    9401 </span>            : // DQ (3/3/2013): Added UPC specific build functions.</a>
<a name="9402"><span class="lineNum">    9402 </span>            : SgUpcNotifyStatement*</a>
<a name="9403"><span class="lineNum">    9403 </span><span class="lineNoCov">          0 : SageBuilder::buildUpcNotifyStatement_nfi(SgExpression* exp)</span></a>
<a name="9404"><span class="lineNum">    9404 </span>            :    {</a>
<a name="9405"><span class="lineNum">    9405 </span><span class="lineNoCov">          0 :      SgUpcNotifyStatement* result = new SgUpcNotifyStatement(exp);</span></a>
<a name="9406"><span class="lineNum">    9406 </span>            : </a>
<a name="9407"><span class="lineNum">    9407 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9408"><span class="lineNum">    9408 </span>            : </a>
<a name="9409"><span class="lineNum">    9409 </span><span class="lineNoCov">          0 :      exp-&gt;set_parent(result);</span></a>
<a name="9410"><span class="lineNum">    9410 </span>            : </a>
<a name="9411"><span class="lineNum">    9411 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(exp-&gt;get_parent() != NULL);</span></a>
<a name="9412"><span class="lineNum">    9412 </span>            : </a>
<a name="9413"><span class="lineNum">    9413 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9414"><span class="lineNum">    9414 </span>            :    }</a>
<a name="9415"><span class="lineNum">    9415 </span>            : </a>
<a name="9416"><span class="lineNum">    9416 </span>            : SgUpcWaitStatement*</a>
<a name="9417"><span class="lineNum">    9417 </span><span class="lineNoCov">          0 : SageBuilder::buildUpcWaitStatement_nfi(SgExpression* exp)</span></a>
<a name="9418"><span class="lineNum">    9418 </span>            :    {</a>
<a name="9419"><span class="lineNum">    9419 </span><span class="lineNoCov">          0 :      SgUpcWaitStatement* result = new SgUpcWaitStatement(exp);</span></a>
<a name="9420"><span class="lineNum">    9420 </span>            : </a>
<a name="9421"><span class="lineNum">    9421 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9422"><span class="lineNum">    9422 </span>            : </a>
<a name="9423"><span class="lineNum">    9423 </span><span class="lineNoCov">          0 :      exp-&gt;set_parent(result);</span></a>
<a name="9424"><span class="lineNum">    9424 </span>            : </a>
<a name="9425"><span class="lineNum">    9425 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(exp-&gt;get_parent() != NULL);</span></a>
<a name="9426"><span class="lineNum">    9426 </span>            : </a>
<a name="9427"><span class="lineNum">    9427 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9428"><span class="lineNum">    9428 </span>            :    }</a>
<a name="9429"><span class="lineNum">    9429 </span>            : </a>
<a name="9430"><span class="lineNum">    9430 </span>            : SgUpcBarrierStatement*</a>
<a name="9431"><span class="lineNum">    9431 </span><span class="lineNoCov">          0 : SageBuilder::buildUpcBarrierStatement_nfi(SgExpression* exp)</span></a>
<a name="9432"><span class="lineNum">    9432 </span>            :    {</a>
<a name="9433"><span class="lineNum">    9433 </span><span class="lineNoCov">          0 :      SgUpcBarrierStatement* result = new SgUpcBarrierStatement(exp);</span></a>
<a name="9434"><span class="lineNum">    9434 </span>            : </a>
<a name="9435"><span class="lineNum">    9435 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9436"><span class="lineNum">    9436 </span>            : </a>
<a name="9437"><span class="lineNum">    9437 </span><span class="lineNoCov">          0 :      exp-&gt;set_parent(result);</span></a>
<a name="9438"><span class="lineNum">    9438 </span>            : </a>
<a name="9439"><span class="lineNum">    9439 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(exp-&gt;get_parent() != NULL);</span></a>
<a name="9440"><span class="lineNum">    9440 </span>            : </a>
<a name="9441"><span class="lineNum">    9441 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9442"><span class="lineNum">    9442 </span>            :    }</a>
<a name="9443"><span class="lineNum">    9443 </span>            : </a>
<a name="9444"><span class="lineNum">    9444 </span>            : SgUpcFenceStatement*</a>
<a name="9445"><span class="lineNum">    9445 </span><span class="lineNoCov">          0 : SageBuilder::buildUpcFenceStatement_nfi()</span></a>
<a name="9446"><span class="lineNum">    9446 </span>            :    {</a>
<a name="9447"><span class="lineNum">    9447 </span><span class="lineNoCov">          0 :      SgUpcFenceStatement* result = new SgUpcFenceStatement();</span></a>
<a name="9448"><span class="lineNum">    9448 </span>            : </a>
<a name="9449"><span class="lineNum">    9449 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="9450"><span class="lineNum">    9450 </span>            : </a>
<a name="9451"><span class="lineNum">    9451 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9452"><span class="lineNum">    9452 </span>            :    }</a>
<a name="9453"><span class="lineNum">    9453 </span>            : </a>
<a name="9454"><span class="lineNum">    9454 </span>            : </a>
<a name="9455"><span class="lineNum">    9455 </span>            : </a>
<a name="9456"><span class="lineNum">    9456 </span>            : </a>
<a name="9457"><span class="lineNum">    9457 </span><span class="lineCov">          1 : SgWhileStmt * SageBuilder::buildWhileStmt(SgStatement *  condition, SgStatement *body, SgStatement* else_body)</span></a>
<a name="9458"><span class="lineNum">    9458 </span>            : {</a>
<a name="9459"><span class="lineNum">    9459 </span><span class="lineCov">          1 :   ROSE_ASSERT(condition);</span></a>
<a name="9460"><span class="lineNum">    9460 </span><span class="lineCov">          1 :   ROSE_ASSERT(body);</span></a>
<a name="9461"><span class="lineNum">    9461 </span><span class="lineCov">          1 :   SgWhileStmt * result = new SgWhileStmt(condition,body);</span></a>
<a name="9462"><span class="lineNum">    9462 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="9463"><span class="lineNum">    9463 </span>            : </a>
<a name="9464"><span class="lineNum">    9464 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9465"><span class="lineNum">    9465 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9466"><span class="lineNum">    9466 </span><span class="lineCov">          1 :   if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9467"><span class="lineNum">    9467 </span><span class="lineNoCov">          0 :        result-&gt;setCaseInsensitive(true);</span></a>
<a name="9468"><span class="lineNum">    9468 </span>            : </a>
<a name="9469"><span class="lineNum">    9469 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9470"><span class="lineNum">    9470 </span><span class="lineCov">          1 :   condition-&gt;set_parent(result);</span></a>
<a name="9471"><span class="lineNum">    9471 </span><span class="lineCov">          1 :   body-&gt;set_parent(result);</span></a>
<a name="9472"><span class="lineNum">    9472 </span>            : </a>
<a name="9473"><span class="lineNum">    9473 </span>            : // DQ (8/10/2011): This is added by Michael to support a Python specific feature.</a>
<a name="9474"><span class="lineNum">    9474 </span><span class="lineCov">          1 :   if (else_body != NULL) {</span></a>
<a name="9475"><span class="lineNum">    9475 </span><span class="lineNoCov">          0 :       result-&gt;set_else_body(else_body);</span></a>
<a name="9476"><span class="lineNum">    9476 </span><span class="lineNoCov">          0 :       else_body-&gt;set_parent(result);</span></a>
<a name="9477"><span class="lineNum">    9477 </span>            :   }</a>
<a name="9478"><span class="lineNum">    9478 </span>            : </a>
<a name="9479"><span class="lineNum">    9479 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="9480"><span class="lineNum">    9480 </span>            : }</a>
<a name="9481"><span class="lineNum">    9481 </span>            : </a>
<a name="9482"><span class="lineNum">    9482 </span>            : </a>
<a name="9483"><span class="lineNum">    9483 </span>            : SgWhileStmt*</a>
<a name="9484"><span class="lineNum">    9484 </span><span class="lineNoCov">          0 : SageBuilder::buildWhileStmt_nfi(SgStatement *  condition, SgStatement *body, SgStatement *else_body)</span></a>
<a name="9485"><span class="lineNum">    9485 </span>            :    {</a>
<a name="9486"><span class="lineNum">    9486 </span><span class="lineNoCov">          0 :      SgWhileStmt * result = new SgWhileStmt(condition,body);</span></a>
<a name="9487"><span class="lineNum">    9487 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="9488"><span class="lineNum">    9488 </span>            : </a>
<a name="9489"><span class="lineNum">    9489 </span>            : #if 0</a>
<a name="9490"><span class="lineNum">    9490 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="9491"><span class="lineNum">    9491 </span>            :      if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9492"><span class="lineNum">    9492 </span>            :           result-&gt;setCaseInsensitive(true);</a>
<a name="9493"><span class="lineNum">    9493 </span>            : </a>
<a name="9494"><span class="lineNum">    9494 </span>            :      setOneSourcePositionNull(result);</a>
<a name="9495"><span class="lineNum">    9495 </span>            :      if (condition) condition-&gt;set_parent(result);</a>
<a name="9496"><span class="lineNum">    9496 </span>            :      if (body) body-&gt;set_parent(result);</a>
<a name="9497"><span class="lineNum">    9497 </span>            : </a>
<a name="9498"><span class="lineNum">    9498 </span>            :   // DQ (8/10/2011): This is added by Michael to support a Python specific feature.</a>
<a name="9499"><span class="lineNum">    9499 </span>            :      if (else_body != NULL)</a>
<a name="9500"><span class="lineNum">    9500 </span>            :         {</a>
<a name="9501"><span class="lineNum">    9501 </span>            :           result-&gt;set_else_body(else_body);</a>
<a name="9502"><span class="lineNum">    9502 </span>            :           else_body-&gt;set_parent(result);</a>
<a name="9503"><span class="lineNum">    9503 </span>            :         }</a>
<a name="9504"><span class="lineNum">    9504 </span>            : #else</a>
<a name="9505"><span class="lineNum">    9505 </span>            :   // DQ (2/15/2012): This function supports the case where in C++ the condition can include a variable declaration.</a>
<a name="9506"><span class="lineNum">    9506 </span><span class="lineNoCov">          0 :      initializeWhileStatement(result,condition,body,else_body);</span></a>
<a name="9507"><span class="lineNum">    9507 </span>            : #endif</a>
<a name="9508"><span class="lineNum">    9508 </span>            : </a>
<a name="9509"><span class="lineNum">    9509 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="9510"><span class="lineNum">    9510 </span>            :    }</a>
<a name="9511"><span class="lineNum">    9511 </span>            : </a>
<a name="9512"><span class="lineNum">    9512 </span>            : </a>
<a name="9513"><span class="lineNum">    9513 </span><span class="lineNoCov">          0 : SgWithStatement* SageBuilder::buildWithStatement(SgExpression* expr, SgStatement *body)</span></a>
<a name="9514"><span class="lineNum">    9514 </span>            : {</a>
<a name="9515"><span class="lineNum">    9515 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(expr != NULL &amp;&amp; body != NULL);</span></a>
<a name="9516"><span class="lineNum">    9516 </span><span class="lineNoCov">          0 :   SgWithStatement* result = new SgWithStatement(expr, body);</span></a>
<a name="9517"><span class="lineNum">    9517 </span><span class="lineNoCov">          0 :   expr-&gt;set_parent(result);</span></a>
<a name="9518"><span class="lineNum">    9518 </span><span class="lineNoCov">          0 :   body-&gt;set_parent(result);</span></a>
<a name="9519"><span class="lineNum">    9519 </span>            : </a>
<a name="9520"><span class="lineNum">    9520 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9521"><span class="lineNum">    9521 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9522"><span class="lineNum">    9522 </span>            : }</a>
<a name="9523"><span class="lineNum">    9523 </span>            : </a>
<a name="9524"><span class="lineNum">    9524 </span><span class="lineNoCov">          0 : SgWithStatement* SageBuilder::buildWithStatement_nfi(SgExpression* expr, SgStatement *body)</span></a>
<a name="9525"><span class="lineNum">    9525 </span>            : {</a>
<a name="9526"><span class="lineNum">    9526 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(expr != NULL &amp;&amp; body != NULL);</span></a>
<a name="9527"><span class="lineNum">    9527 </span><span class="lineNoCov">          0 :   SgWithStatement* result = new SgWithStatement(expr, body);</span></a>
<a name="9528"><span class="lineNum">    9528 </span><span class="lineNoCov">          0 :   expr-&gt;set_parent(result);</span></a>
<a name="9529"><span class="lineNum">    9529 </span><span class="lineNoCov">          0 :   body-&gt;set_parent(result);</span></a>
<a name="9530"><span class="lineNum">    9530 </span>            : </a>
<a name="9531"><span class="lineNum">    9531 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9532"><span class="lineNum">    9532 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9533"><span class="lineNum">    9533 </span>            : }</a>
<a name="9534"><span class="lineNum">    9534 </span>            : </a>
<a name="9535"><span class="lineNum">    9535 </span><span class="lineCov">          1 : SgDoWhileStmt * SageBuilder::buildDoWhileStmt(SgStatement *  body, SgStatement *condition)</span></a>
<a name="9536"><span class="lineNum">    9536 </span>            : {</a>
<a name="9537"><span class="lineNum">    9537 </span><span class="lineCov">          1 :   ROSE_ASSERT(condition);</span></a>
<a name="9538"><span class="lineNum">    9538 </span><span class="lineCov">          1 :   ROSE_ASSERT(body);</span></a>
<a name="9539"><span class="lineNum">    9539 </span><span class="lineCov">          1 :   SgDoWhileStmt * result = new SgDoWhileStmt(body, condition);</span></a>
<a name="9540"><span class="lineNum">    9540 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="9541"><span class="lineNum">    9541 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9542"><span class="lineNum">    9542 </span><span class="lineCov">          1 :   condition-&gt;set_parent(result);</span></a>
<a name="9543"><span class="lineNum">    9543 </span><span class="lineCov">          1 :   body-&gt;set_parent(result);</span></a>
<a name="9544"><span class="lineNum">    9544 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="9545"><span class="lineNum">    9545 </span>            : }</a>
<a name="9546"><span class="lineNum">    9546 </span>            : </a>
<a name="9547"><span class="lineNum">    9547 </span><span class="lineNoCov">          0 : SgDoWhileStmt * SageBuilder::buildDoWhileStmt_nfi(SgStatement *  body, SgStatement *condition)</span></a>
<a name="9548"><span class="lineNum">    9548 </span>            : {</a>
<a name="9549"><span class="lineNum">    9549 </span><span class="lineNoCov">          0 :   SgDoWhileStmt * result = new SgDoWhileStmt(body, condition);</span></a>
<a name="9550"><span class="lineNum">    9550 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9551"><span class="lineNum">    9551 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9552"><span class="lineNum">    9552 </span><span class="lineNoCov">          0 :   if (condition) condition-&gt;set_parent(result);</span></a>
<a name="9553"><span class="lineNum">    9553 </span><span class="lineNoCov">          0 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="9554"><span class="lineNum">    9554 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9555"><span class="lineNum">    9555 </span>            : }</a>
<a name="9556"><span class="lineNum">    9556 </span>            : </a>
<a name="9557"><span class="lineNum">    9557 </span><span class="lineNoCov">          0 : SgBreakStmt * SageBuilder::buildBreakStmt()</span></a>
<a name="9558"><span class="lineNum">    9558 </span>            : {</a>
<a name="9559"><span class="lineNum">    9559 </span><span class="lineNoCov">          0 :   SgBreakStmt* result = new SgBreakStmt();</span></a>
<a name="9560"><span class="lineNum">    9560 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9561"><span class="lineNum">    9561 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9562"><span class="lineNum">    9562 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9563"><span class="lineNum">    9563 </span>            : }</a>
<a name="9564"><span class="lineNum">    9564 </span>            : </a>
<a name="9565"><span class="lineNum">    9565 </span><span class="lineCov">        242 : SgBreakStmt * SageBuilder::buildBreakStmt_nfi()</span></a>
<a name="9566"><span class="lineNum">    9566 </span>            : {</a>
<a name="9567"><span class="lineNum">    9567 </span><span class="lineCov">        242 :   SgBreakStmt* result = new SgBreakStmt();</span></a>
<a name="9568"><span class="lineNum">    9568 </span><span class="lineCov">        242 :   ROSE_ASSERT(result);</span></a>
<a name="9569"><span class="lineNum">    9569 </span><span class="lineCov">        242 :   setOneSourcePositionNull(result);</span></a>
<a name="9570"><span class="lineNum">    9570 </span><span class="lineCov">        242 :   return result;</span></a>
<a name="9571"><span class="lineNum">    9571 </span>            : }</a>
<a name="9572"><span class="lineNum">    9572 </span>            : </a>
<a name="9573"><span class="lineNum">    9573 </span><span class="lineNoCov">          0 : SgContinueStmt * SageBuilder::buildContinueStmt()</span></a>
<a name="9574"><span class="lineNum">    9574 </span>            : {</a>
<a name="9575"><span class="lineNum">    9575 </span><span class="lineNoCov">          0 :   SgContinueStmt* result = new SgContinueStmt();</span></a>
<a name="9576"><span class="lineNum">    9576 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9577"><span class="lineNum">    9577 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9578"><span class="lineNum">    9578 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9579"><span class="lineNum">    9579 </span>            : }</a>
<a name="9580"><span class="lineNum">    9580 </span>            : </a>
<a name="9581"><span class="lineNum">    9581 </span><span class="lineCov">         16 : SgContinueStmt * SageBuilder::buildContinueStmt_nfi()</span></a>
<a name="9582"><span class="lineNum">    9582 </span>            : {</a>
<a name="9583"><span class="lineNum">    9583 </span><span class="lineCov">         16 :   SgContinueStmt* result = new SgContinueStmt();</span></a>
<a name="9584"><span class="lineNum">    9584 </span><span class="lineCov">         16 :   ROSE_ASSERT(result);</span></a>
<a name="9585"><span class="lineNum">    9585 </span><span class="lineCov">         16 :   setOneSourcePositionNull(result);</span></a>
<a name="9586"><span class="lineNum">    9586 </span><span class="lineCov">         16 :   return result;</span></a>
<a name="9587"><span class="lineNum">    9587 </span>            : }</a>
<a name="9588"><span class="lineNum">    9588 </span>            : </a>
<a name="9589"><span class="lineNum">    9589 </span><span class="lineNoCov">          0 : SgPassStatement * SageBuilder::buildPassStatement()</span></a>
<a name="9590"><span class="lineNum">    9590 </span>            : {</a>
<a name="9591"><span class="lineNum">    9591 </span><span class="lineNoCov">          0 :   SgPassStatement* result = new SgPassStatement();</span></a>
<a name="9592"><span class="lineNum">    9592 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9593"><span class="lineNum">    9593 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9594"><span class="lineNum">    9594 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9595"><span class="lineNum">    9595 </span>            : }</a>
<a name="9596"><span class="lineNum">    9596 </span>            : </a>
<a name="9597"><span class="lineNum">    9597 </span><span class="lineNoCov">          0 : SgPassStatement * SageBuilder::buildPassStatement_nfi()</span></a>
<a name="9598"><span class="lineNum">    9598 </span>            : {</a>
<a name="9599"><span class="lineNum">    9599 </span><span class="lineNoCov">          0 :   SgPassStatement* result = new SgPassStatement();</span></a>
<a name="9600"><span class="lineNum">    9600 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9601"><span class="lineNum">    9601 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9602"><span class="lineNum">    9602 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9603"><span class="lineNum">    9603 </span>            : }</a>
<a name="9604"><span class="lineNum">    9604 </span>            : </a>
<a name="9605"><span class="lineNum">    9605 </span><span class="lineCov">        120 : SgDeleteExp* SageBuilder::buildDeleteExp(SgExpression *target, bool is_array, bool need_global_specifier, SgFunctionDeclaration *deleteOperatorDeclaration)</span></a>
<a name="9606"><span class="lineNum">    9606 </span>            : {</a>
<a name="9607"><span class="lineNum">    9607 </span><span class="lineCov">        120 :     SgDeleteExp *result = new SgDeleteExp(target, is_array, need_global_specifier, deleteOperatorDeclaration);</span></a>
<a name="9608"><span class="lineNum">    9608 </span><span class="lineCov">        120 :     target-&gt;set_parent(result);</span></a>
<a name="9609"><span class="lineNum">    9609 </span><span class="lineCov">        120 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9610"><span class="lineNum">    9610 </span><span class="lineCov">        120 :     return result;</span></a>
<a name="9611"><span class="lineNum">    9611 </span>            : }</a>
<a name="9612"><span class="lineNum">    9612 </span>            : </a>
<a name="9613"><span class="lineNum">    9613 </span><span class="lineNoCov">          0 : SgDeleteExp* SageBuilder::buildDeleteExp_nfi(SgExpression *target, bool is_array, bool need_global_specifier, SgFunctionDeclaration *deleteOperatorDeclaration)</span></a>
<a name="9614"><span class="lineNum">    9614 </span>            : {</a>
<a name="9615"><span class="lineNum">    9615 </span><span class="lineNoCov">          0 :     SgDeleteExp *result = new SgDeleteExp(target, is_array, need_global_specifier, deleteOperatorDeclaration);</span></a>
<a name="9616"><span class="lineNum">    9616 </span><span class="lineNoCov">          0 :     target-&gt;set_parent(result);</span></a>
<a name="9617"><span class="lineNum">    9617 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9618"><span class="lineNum">    9618 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9619"><span class="lineNum">    9619 </span>            : }</a>
<a name="9620"><span class="lineNum">    9620 </span>            : </a>
<a name="9621"><span class="lineNum">    9621 </span><span class="lineNoCov">          0 : SgAssertStmt* SageBuilder::buildAssertStmt(SgExpression* test)</span></a>
<a name="9622"><span class="lineNum">    9622 </span>            : {</a>
<a name="9623"><span class="lineNum">    9623 </span><span class="lineNoCov">          0 :   SgAssertStmt* result = new SgAssertStmt(test);</span></a>
<a name="9624"><span class="lineNum">    9624 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(test != NULL);</span></a>
<a name="9625"><span class="lineNum">    9625 </span><span class="lineNoCov">          0 :   test-&gt;set_parent(result);</span></a>
<a name="9626"><span class="lineNum">    9626 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9627"><span class="lineNum">    9627 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9628"><span class="lineNum">    9628 </span>            : }</a>
<a name="9629"><span class="lineNum">    9629 </span>            : </a>
<a name="9630"><span class="lineNum">    9630 </span><span class="lineNoCov">          0 : SgAssertStmt* SageBuilder::buildAssertStmt(SgExpression* test, SgExpression* exceptionArgument)</span></a>
<a name="9631"><span class="lineNum">    9631 </span>            : {</a>
<a name="9632"><span class="lineNum">    9632 </span><span class="lineNoCov">          0 :   SgAssertStmt* result = new SgAssertStmt(test);</span></a>
<a name="9633"><span class="lineNum">    9633 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(test != NULL);</span></a>
<a name="9634"><span class="lineNum">    9634 </span><span class="lineNoCov">          0 :   test-&gt;set_parent(result);</span></a>
<a name="9635"><span class="lineNum">    9635 </span><span class="lineNoCov">          0 :   if (exceptionArgument != NULL) {</span></a>
<a name="9636"><span class="lineNum">    9636 </span><span class="lineNoCov">          0 :       result -&gt; set_exception_argument(exceptionArgument);</span></a>
<a name="9637"><span class="lineNum">    9637 </span><span class="lineNoCov">          0 :       exceptionArgument-&gt;set_parent(result);</span></a>
<a name="9638"><span class="lineNum">    9638 </span>            :   }</a>
<a name="9639"><span class="lineNum">    9639 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9640"><span class="lineNum">    9640 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9641"><span class="lineNum">    9641 </span>            : }</a>
<a name="9642"><span class="lineNum">    9642 </span>            : </a>
<a name="9643"><span class="lineNum">    9643 </span><span class="lineNoCov">          0 : SgAssertStmt* SageBuilder::buildAssertStmt_nfi(SgExpression* test)</span></a>
<a name="9644"><span class="lineNum">    9644 </span>            : {</a>
<a name="9645"><span class="lineNum">    9645 </span><span class="lineNoCov">          0 :   SgAssertStmt* result = new SgAssertStmt(test);</span></a>
<a name="9646"><span class="lineNum">    9646 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(test != NULL);</span></a>
<a name="9647"><span class="lineNum">    9647 </span><span class="lineNoCov">          0 :   test-&gt;set_parent(result);</span></a>
<a name="9648"><span class="lineNum">    9648 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9649"><span class="lineNum">    9649 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9650"><span class="lineNum">    9650 </span>            : }</a>
<a name="9651"><span class="lineNum">    9651 </span>            : </a>
<a name="9652"><span class="lineNum">    9652 </span><span class="lineNoCov">          0 : SgYieldExpression* SageBuilder::buildYieldExpression(SgExpression* value)</span></a>
<a name="9653"><span class="lineNum">    9653 </span>            : {</a>
<a name="9654"><span class="lineNum">    9654 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(value != NULL);</span></a>
<a name="9655"><span class="lineNum">    9655 </span><span class="lineNoCov">          0 :   SgYieldExpression* result = new SgYieldExpression(value);</span></a>
<a name="9656"><span class="lineNum">    9656 </span><span class="lineNoCov">          0 :   value-&gt;set_parent(result);</span></a>
<a name="9657"><span class="lineNum">    9657 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9658"><span class="lineNum">    9658 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9659"><span class="lineNum">    9659 </span>            : }</a>
<a name="9660"><span class="lineNum">    9660 </span>            : </a>
<a name="9661"><span class="lineNum">    9661 </span><span class="lineNoCov">          0 : SgYieldExpression* SageBuilder::buildYieldExpression_nfi(SgExpression* value)</span></a>
<a name="9662"><span class="lineNum">    9662 </span>            : {</a>
<a name="9663"><span class="lineNum">    9663 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(value != NULL);</span></a>
<a name="9664"><span class="lineNum">    9664 </span><span class="lineNoCov">          0 :   SgYieldExpression* result = new SgYieldExpression(value);</span></a>
<a name="9665"><span class="lineNum">    9665 </span><span class="lineNoCov">          0 :   value-&gt;set_parent(result);</span></a>
<a name="9666"><span class="lineNum">    9666 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="9667"><span class="lineNum">    9667 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9668"><span class="lineNum">    9668 </span>            : }</a>
<a name="9669"><span class="lineNum">    9669 </span>            : </a>
<a name="9670"><span class="lineNum">    9670 </span><span class="lineNoCov">          0 : SgKeyDatumPair* SageBuilder::buildKeyDatumPair(SgExpression* key, SgExpression* datum)</span></a>
<a name="9671"><span class="lineNum">    9671 </span>            : {</a>
<a name="9672"><span class="lineNum">    9672 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(key != NULL &amp;&amp; datum != NULL);</span></a>
<a name="9673"><span class="lineNum">    9673 </span><span class="lineNoCov">          0 :     SgKeyDatumPair *result = new SgKeyDatumPair(key, datum);</span></a>
<a name="9674"><span class="lineNum">    9674 </span><span class="lineNoCov">          0 :     key-&gt;set_parent(result);</span></a>
<a name="9675"><span class="lineNum">    9675 </span><span class="lineNoCov">          0 :     datum-&gt;set_parent(result);</span></a>
<a name="9676"><span class="lineNum">    9676 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9677"><span class="lineNum">    9677 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9678"><span class="lineNum">    9678 </span>            : }</a>
<a name="9679"><span class="lineNum">    9679 </span>            : </a>
<a name="9680"><span class="lineNum">    9680 </span><span class="lineNoCov">          0 : SgKeyDatumPair* SageBuilder::buildKeyDatumPair_nfi(SgExpression* key, SgExpression* datum)</span></a>
<a name="9681"><span class="lineNum">    9681 </span>            : {</a>
<a name="9682"><span class="lineNum">    9682 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(key != NULL &amp;&amp; datum != NULL);</span></a>
<a name="9683"><span class="lineNum">    9683 </span><span class="lineNoCov">          0 :     SgKeyDatumPair *result = new SgKeyDatumPair(key, datum);</span></a>
<a name="9684"><span class="lineNum">    9684 </span><span class="lineNoCov">          0 :     key-&gt;set_parent(result);</span></a>
<a name="9685"><span class="lineNum">    9685 </span><span class="lineNoCov">          0 :     datum-&gt;set_parent(result);</span></a>
<a name="9686"><span class="lineNum">    9686 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9687"><span class="lineNum">    9687 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9688"><span class="lineNum">    9688 </span>            : }</a>
<a name="9689"><span class="lineNum">    9689 </span>            : </a>
<a name="9690"><span class="lineNum">    9690 </span><span class="lineNoCov">          0 : SgDictionaryExp* SageBuilder::buildDictionaryExp(std::vector&lt;SgKeyDatumPair*&gt; pairs)</span></a>
<a name="9691"><span class="lineNum">    9691 </span>            : {</a>
<a name="9692"><span class="lineNum">    9692 </span><span class="lineNoCov">          0 :     SgDictionaryExp *result = new SgDictionaryExp();</span></a>
<a name="9693"><span class="lineNum">    9693 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(result);</span></a>
<a name="9694"><span class="lineNum">    9694 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; pairs.size(); ++i)</span></a>
<a name="9695"><span class="lineNum">    9695 </span><span class="lineNoCov">          0 :         result-&gt;append_pair(pairs[i]);</span></a>
<a name="9696"><span class="lineNum">    9696 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9697"><span class="lineNum">    9697 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9698"><span class="lineNum">    9698 </span>            : }</a>
<a name="9699"><span class="lineNum">    9699 </span>            : </a>
<a name="9700"><span class="lineNum">    9700 </span><span class="lineNoCov">          0 : SgDictionaryExp* SageBuilder::buildDictionaryExp_nfi(std::vector&lt;SgKeyDatumPair*&gt; pairs)</span></a>
<a name="9701"><span class="lineNum">    9701 </span>            : {</a>
<a name="9702"><span class="lineNum">    9702 </span><span class="lineNoCov">          0 :     SgDictionaryExp *result = new SgDictionaryExp();</span></a>
<a name="9703"><span class="lineNum">    9703 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(result);</span></a>
<a name="9704"><span class="lineNum">    9704 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; pairs.size(); ++i)</span></a>
<a name="9705"><span class="lineNum">    9705 </span><span class="lineNoCov">          0 :         result-&gt;append_pair(pairs[i]);</span></a>
<a name="9706"><span class="lineNum">    9706 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9707"><span class="lineNum">    9707 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9708"><span class="lineNum">    9708 </span>            : }</a>
<a name="9709"><span class="lineNum">    9709 </span>            : </a>
<a name="9710"><span class="lineNum">    9710 </span>            : SgComprehension*</a>
<a name="9711"><span class="lineNum">    9711 </span><span class="lineNoCov">          0 : SageBuilder::buildComprehension(SgExpression *target, SgExpression *iter, SgExprListExp *ifs)</span></a>
<a name="9712"><span class="lineNum">    9712 </span>            : {</a>
<a name="9713"><span class="lineNum">    9713 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(target != NULL);</span></a>
<a name="9714"><span class="lineNum">    9714 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(iter != NULL);</span></a>
<a name="9715"><span class="lineNum">    9715 </span><span class="lineNoCov">          0 :     SgComprehension *result = new SgComprehension(target, iter, ifs);</span></a>
<a name="9716"><span class="lineNum">    9716 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(result);</span></a>
<a name="9717"><span class="lineNum">    9717 </span>            : </a>
<a name="9718"><span class="lineNum">    9718 </span><span class="lineNoCov">          0 :     target-&gt;set_parent(result);</span></a>
<a name="9719"><span class="lineNum">    9719 </span><span class="lineNoCov">          0 :     iter-&gt;set_parent(result);</span></a>
<a name="9720"><span class="lineNum">    9720 </span><span class="lineNoCov">          0 :     if (ifs != NULL) ifs-&gt;set_parent(result);</span></a>
<a name="9721"><span class="lineNum">    9721 </span>            : </a>
<a name="9722"><span class="lineNum">    9722 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9723"><span class="lineNum">    9723 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9724"><span class="lineNum">    9724 </span>            : }</a>
<a name="9725"><span class="lineNum">    9725 </span>            : </a>
<a name="9726"><span class="lineNum">    9726 </span>            : SgComprehension*</a>
<a name="9727"><span class="lineNum">    9727 </span><span class="lineNoCov">          0 : SageBuilder::buildComprehension_nfi(SgExpression *target, SgExpression *iter, SgExprListExp *ifs)</span></a>
<a name="9728"><span class="lineNum">    9728 </span>            : {</a>
<a name="9729"><span class="lineNum">    9729 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(target != NULL);</span></a>
<a name="9730"><span class="lineNum">    9730 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(iter != NULL);</span></a>
<a name="9731"><span class="lineNum">    9731 </span><span class="lineNoCov">          0 :     SgComprehension *result = new SgComprehension(target, iter, ifs);</span></a>
<a name="9732"><span class="lineNum">    9732 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(result);</span></a>
<a name="9733"><span class="lineNum">    9733 </span><span class="lineNoCov">          0 :     target-&gt;set_parent(result);</span></a>
<a name="9734"><span class="lineNum">    9734 </span><span class="lineNoCov">          0 :     iter-&gt;set_parent(result);</span></a>
<a name="9735"><span class="lineNum">    9735 </span><span class="lineNoCov">          0 :     if (ifs != NULL) ifs-&gt;set_parent(result);</span></a>
<a name="9736"><span class="lineNum">    9736 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9737"><span class="lineNum">    9737 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9738"><span class="lineNum">    9738 </span>            : }</a>
<a name="9739"><span class="lineNum">    9739 </span>            : </a>
<a name="9740"><span class="lineNum">    9740 </span>            : SgListComprehension*</a>
<a name="9741"><span class="lineNum">    9741 </span><span class="lineNoCov">          0 : SageBuilder::buildListComprehension(SgExpression *elt, SgExprListExp *generators)</span></a>
<a name="9742"><span class="lineNum">    9742 </span>            : {</a>
<a name="9743"><span class="lineNum">    9743 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(elt != NULL);</span></a>
<a name="9744"><span class="lineNum">    9744 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9745"><span class="lineNum">    9745 </span><span class="lineNoCov">          0 :     SgListComprehension* result = new SgListComprehension(elt, generators);</span></a>
<a name="9746"><span class="lineNum">    9746 </span><span class="lineNoCov">          0 :     elt-&gt;set_parent(result);</span></a>
<a name="9747"><span class="lineNum">    9747 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9748"><span class="lineNum">    9748 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9749"><span class="lineNum">    9749 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9750"><span class="lineNum">    9750 </span>            : }</a>
<a name="9751"><span class="lineNum">    9751 </span>            : </a>
<a name="9752"><span class="lineNum">    9752 </span>            : SgListComprehension*</a>
<a name="9753"><span class="lineNum">    9753 </span><span class="lineNoCov">          0 : SageBuilder::buildListComprehension_nfi(SgExpression *elt, SgExprListExp *generators)</span></a>
<a name="9754"><span class="lineNum">    9754 </span>            : {</a>
<a name="9755"><span class="lineNum">    9755 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(elt != NULL);</span></a>
<a name="9756"><span class="lineNum">    9756 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9757"><span class="lineNum">    9757 </span><span class="lineNoCov">          0 :     SgListComprehension* result = new SgListComprehension(elt, generators);</span></a>
<a name="9758"><span class="lineNum">    9758 </span><span class="lineNoCov">          0 :     elt-&gt;set_parent(result);</span></a>
<a name="9759"><span class="lineNum">    9759 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9760"><span class="lineNum">    9760 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9761"><span class="lineNum">    9761 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9762"><span class="lineNum">    9762 </span>            : }</a>
<a name="9763"><span class="lineNum">    9763 </span>            : </a>
<a name="9764"><span class="lineNum">    9764 </span>            : SgSetComprehension*</a>
<a name="9765"><span class="lineNum">    9765 </span><span class="lineNoCov">          0 : SageBuilder::buildSetComprehension(SgExpression *elt, SgExprListExp *generators)</span></a>
<a name="9766"><span class="lineNum">    9766 </span>            : {</a>
<a name="9767"><span class="lineNum">    9767 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(elt != NULL);</span></a>
<a name="9768"><span class="lineNum">    9768 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9769"><span class="lineNum">    9769 </span><span class="lineNoCov">          0 :     SgSetComprehension* result = new SgSetComprehension(elt, generators);</span></a>
<a name="9770"><span class="lineNum">    9770 </span><span class="lineNoCov">          0 :     elt-&gt;set_parent(result);</span></a>
<a name="9771"><span class="lineNum">    9771 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9772"><span class="lineNum">    9772 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9773"><span class="lineNum">    9773 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9774"><span class="lineNum">    9774 </span>            : }</a>
<a name="9775"><span class="lineNum">    9775 </span>            : </a>
<a name="9776"><span class="lineNum">    9776 </span>            : SgSetComprehension*</a>
<a name="9777"><span class="lineNum">    9777 </span><span class="lineNoCov">          0 : SageBuilder::buildSetComprehension_nfi(SgExpression *elt, SgExprListExp *generators)</span></a>
<a name="9778"><span class="lineNum">    9778 </span>            : {</a>
<a name="9779"><span class="lineNum">    9779 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(elt != NULL);</span></a>
<a name="9780"><span class="lineNum">    9780 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9781"><span class="lineNum">    9781 </span><span class="lineNoCov">          0 :     SgSetComprehension* result = new SgSetComprehension(elt, generators);</span></a>
<a name="9782"><span class="lineNum">    9782 </span><span class="lineNoCov">          0 :     elt-&gt;set_parent(result);</span></a>
<a name="9783"><span class="lineNum">    9783 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9784"><span class="lineNum">    9784 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9785"><span class="lineNum">    9785 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9786"><span class="lineNum">    9786 </span>            : }</a>
<a name="9787"><span class="lineNum">    9787 </span>            : </a>
<a name="9788"><span class="lineNum">    9788 </span>            : SgDictionaryComprehension*</a>
<a name="9789"><span class="lineNum">    9789 </span><span class="lineNoCov">          0 : SageBuilder::buildDictionaryComprehension(SgKeyDatumPair *kd_pair, SgExprListExp *generators)</span></a>
<a name="9790"><span class="lineNum">    9790 </span>            : {</a>
<a name="9791"><span class="lineNum">    9791 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(kd_pair != NULL);</span></a>
<a name="9792"><span class="lineNum">    9792 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9793"><span class="lineNum">    9793 </span><span class="lineNoCov">          0 :     SgDictionaryComprehension* result = new SgDictionaryComprehension(kd_pair, generators);</span></a>
<a name="9794"><span class="lineNum">    9794 </span><span class="lineNoCov">          0 :     kd_pair-&gt;set_parent(result);</span></a>
<a name="9795"><span class="lineNum">    9795 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9796"><span class="lineNum">    9796 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9797"><span class="lineNum">    9797 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9798"><span class="lineNum">    9798 </span>            : }</a>
<a name="9799"><span class="lineNum">    9799 </span>            : </a>
<a name="9800"><span class="lineNum">    9800 </span>            : SgDictionaryComprehension*</a>
<a name="9801"><span class="lineNum">    9801 </span><span class="lineNoCov">          0 : SageBuilder::buildDictionaryComprehension_nfi(SgKeyDatumPair *kd_pair, SgExprListExp *generators)</span></a>
<a name="9802"><span class="lineNum">    9802 </span>            : {</a>
<a name="9803"><span class="lineNum">    9803 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(kd_pair != NULL);</span></a>
<a name="9804"><span class="lineNum">    9804 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(generators != NULL);</span></a>
<a name="9805"><span class="lineNum">    9805 </span><span class="lineNoCov">          0 :     SgDictionaryComprehension* result = new SgDictionaryComprehension(kd_pair, generators);</span></a>
<a name="9806"><span class="lineNum">    9806 </span><span class="lineNoCov">          0 :     kd_pair-&gt;set_parent(result);</span></a>
<a name="9807"><span class="lineNum">    9807 </span><span class="lineNoCov">          0 :     generators-&gt;set_parent(result);</span></a>
<a name="9808"><span class="lineNum">    9808 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9809"><span class="lineNum">    9809 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9810"><span class="lineNum">    9810 </span>            : }</a>
<a name="9811"><span class="lineNum">    9811 </span>            : </a>
<a name="9812"><span class="lineNum">    9812 </span>            : SgActualArgumentExpression*</a>
<a name="9813"><span class="lineNum">    9813 </span><span class="lineNoCov">          0 : SageBuilder::buildActualArgumentExpression(SgName arg_name, SgExpression* arg) {</span></a>
<a name="9814"><span class="lineNum">    9814 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(arg != NULL);</span></a>
<a name="9815"><span class="lineNum">    9815 </span><span class="lineNoCov">          0 :     SgActualArgumentExpression* result = new SgActualArgumentExpression(arg_name, arg);</span></a>
<a name="9816"><span class="lineNum">    9816 </span><span class="lineNoCov">          0 :     arg-&gt;set_parent(result);</span></a>
<a name="9817"><span class="lineNum">    9817 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="9818"><span class="lineNum">    9818 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9819"><span class="lineNum">    9819 </span>            : }</a>
<a name="9820"><span class="lineNum">    9820 </span>            : </a>
<a name="9821"><span class="lineNum">    9821 </span>            : SgActualArgumentExpression*</a>
<a name="9822"><span class="lineNum">    9822 </span><span class="lineNoCov">          0 : SageBuilder::buildActualArgumentExpression_nfi(SgName arg_name, SgExpression* arg) {</span></a>
<a name="9823"><span class="lineNum">    9823 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(arg != NULL);</span></a>
<a name="9824"><span class="lineNum">    9824 </span><span class="lineNoCov">          0 :     SgActualArgumentExpression* result = new SgActualArgumentExpression(arg_name, arg);</span></a>
<a name="9825"><span class="lineNum">    9825 </span><span class="lineNoCov">          0 :     arg-&gt;set_parent(result);</span></a>
<a name="9826"><span class="lineNum">    9826 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="9827"><span class="lineNum">    9827 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="9828"><span class="lineNum">    9828 </span>            : }</a>
<a name="9829"><span class="lineNum">    9829 </span>            : </a>
<a name="9830"><span class="lineNum">    9830 </span>            : SgPragmaDeclaration*</a>
<a name="9831"><span class="lineNum">    9831 </span><span class="lineCov">       1829 : SageBuilder::buildPragmaDeclaration(const string&amp; name, SgScopeStatement* scope)</span></a>
<a name="9832"><span class="lineNum">    9832 </span>            :    {</a>
<a name="9833"><span class="lineNum">    9833 </span><span class="lineCov">       1829 :      if (scope == NULL)</span></a>
<a name="9834"><span class="lineNum">    9834 </span><span class="lineCov">          1 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="9835"><span class="lineNum">    9835 </span>            : </a>
<a name="9836"><span class="lineNum">    9836 </span><span class="lineCov">       1829 :      SgPragma* pragma = new SgPragma(name);</span></a>
<a name="9837"><span class="lineNum">    9837 </span><span class="lineCov">       1829 :      ROSE_ASSERT(pragma);</span></a>
<a name="9838"><span class="lineNum">    9838 </span>            : </a>
<a name="9839"><span class="lineNum">    9839 </span><span class="lineCov">       1829 :      setOneSourcePositionForTransformation(pragma);</span></a>
<a name="9840"><span class="lineNum">    9840 </span>            : </a>
<a name="9841"><span class="lineNum">    9841 </span><span class="lineCov">       1829 :      SgPragmaDeclaration* result = new SgPragmaDeclaration(pragma);</span></a>
<a name="9842"><span class="lineNum">    9842 </span><span class="lineCov">       1829 :      ROSE_ASSERT(result);</span></a>
<a name="9843"><span class="lineNum">    9843 </span>            : </a>
<a name="9844"><span class="lineNum">    9844 </span><span class="lineCov">       1829 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="9845"><span class="lineNum">    9845 </span>            : </a>
<a name="9846"><span class="lineNum">    9846 </span><span class="lineCov">       1829 :      result-&gt;set_definingDeclaration (result);</span></a>
<a name="9847"><span class="lineNum">    9847 </span><span class="lineCov">       1829 :      result-&gt;set_firstNondefiningDeclaration(result);</span></a>
<a name="9848"><span class="lineNum">    9848 </span><span class="lineCov">       1829 :      pragma-&gt;set_parent(result);</span></a>
<a name="9849"><span class="lineNum">    9849 </span>            : </a>
<a name="9850"><span class="lineNum">    9850 </span>            :   // DQ (7/14/2012): Set the parent so that we can be consistent where possible (class declarations and</a>
<a name="9851"><span class="lineNum">    9851 </span>            :   // enum declaration can't have there parent set since they could be non-autonomous declarations).</a>
<a name="9852"><span class="lineNum">    9852 </span><span class="lineCov">       1829 :      result-&gt;set_parent(topScopeStack());</span></a>
<a name="9853"><span class="lineNum">    9853 </span>            : </a>
<a name="9854"><span class="lineNum">    9854 </span><span class="lineCov">       1829 :     if (topScopeStack())</span></a>
<a name="9855"><span class="lineNum">    9855 </span><span class="lineCov">       1715 :      ROSE_ASSERT(result-&gt;get_parent() != NULL);</span></a>
<a name="9856"><span class="lineNum">    9856 </span>            : </a>
<a name="9857"><span class="lineNum">    9857 </span><span class="lineCov">       1829 :      return result;</span></a>
<a name="9858"><span class="lineNum">    9858 </span>            :    }</a>
<a name="9859"><span class="lineNum">    9859 </span>            : </a>
<a name="9860"><span class="lineNum">    9860 </span>            : //!Build SgPragma</a>
<a name="9861"><span class="lineNum">    9861 </span><span class="lineNoCov">          0 : SgPragma* SageBuilder::buildPragma(const std::string &amp; name)</span></a>
<a name="9862"><span class="lineNum">    9862 </span>            : {</a>
<a name="9863"><span class="lineNum">    9863 </span><span class="lineNoCov">          0 :   SgPragma* result= new SgPragma(name);</span></a>
<a name="9864"><span class="lineNum">    9864 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="9865"><span class="lineNum">    9865 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9866"><span class="lineNum">    9866 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="9867"><span class="lineNum">    9867 </span>            : }</a>
<a name="9868"><span class="lineNum">    9868 </span>            : </a>
<a name="9869"><span class="lineNum">    9869 </span>            : </a>
<a name="9870"><span class="lineNum">    9870 </span><span class="lineNoCov">          0 : SgEmptyDeclaration* SageBuilder::buildEmptyDeclaration()</span></a>
<a name="9871"><span class="lineNum">    9871 </span>            :    {</a>
<a name="9872"><span class="lineNum">    9872 </span>            :   // Build an empty declaration (useful for adding precission to comments and CPP handling under token-based unparsing).</a>
<a name="9873"><span class="lineNum">    9873 </span><span class="lineNoCov">          0 :      SgEmptyDeclaration* emptyDeclaration = new SgEmptyDeclaration();</span></a>
<a name="9874"><span class="lineNum">    9874 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(emptyDeclaration != NULL);</span></a>
<a name="9875"><span class="lineNum">    9875 </span>            : </a>
<a name="9876"><span class="lineNum">    9876 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(emptyDeclaration);</span></a>
<a name="9877"><span class="lineNum">    9877 </span>            : </a>
<a name="9878"><span class="lineNum">    9878 </span><span class="lineNoCov">          0 :      emptyDeclaration-&gt;set_definingDeclaration (emptyDeclaration);</span></a>
<a name="9879"><span class="lineNum">    9879 </span><span class="lineNoCov">          0 :      emptyDeclaration-&gt;set_firstNondefiningDeclaration(emptyDeclaration);</span></a>
<a name="9880"><span class="lineNum">    9880 </span>            : </a>
<a name="9881"><span class="lineNum">    9881 </span>            :   // DQ (7/14/2012): Set the parent so that we can be consistent where possible (class declarations and</a>
<a name="9882"><span class="lineNum">    9882 </span>            :   // enum declaration can't have there parent set since they could be non-autonomous declarations).</a>
<a name="9883"><span class="lineNum">    9883 </span><span class="lineNoCov">          0 :      emptyDeclaration-&gt;set_parent(topScopeStack());</span></a>
<a name="9884"><span class="lineNum">    9884 </span>            : </a>
<a name="9885"><span class="lineNum">    9885 </span><span class="lineNoCov">          0 :      if (topScopeStack() != NULL)</span></a>
<a name="9886"><span class="lineNum">    9886 </span>            :         {</a>
<a name="9887"><span class="lineNum">    9887 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(emptyDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="9888"><span class="lineNum">    9888 </span>            :         }</a>
<a name="9889"><span class="lineNum">    9889 </span>            : </a>
<a name="9890"><span class="lineNum">    9890 </span><span class="lineNoCov">          0 :      return emptyDeclaration;</span></a>
<a name="9891"><span class="lineNum">    9891 </span>            :    }</a>
<a name="9892"><span class="lineNum">    9892 </span>            : </a>
<a name="9893"><span class="lineNum">    9893 </span>            : </a>
<a name="9894"><span class="lineNum">    9894 </span><span class="lineCov">        110 : SgBasicBlock * SageBuilder::buildBasicBlock(SgStatement * stmt1, SgStatement* stmt2, SgStatement* stmt3, SgStatement* stmt4, SgStatement* stmt5, SgStatement* stmt6, SgStatement* stmt7, SgStatement* stmt8, SgStatement* stmt9, SgStatement* stmt10)</span></a>
<a name="9895"><span class="lineNum">    9895 </span>            : {</a>
<a name="9896"><span class="lineNum">    9896 </span><span class="lineCov">        110 :   SgBasicBlock* result = new SgBasicBlock();</span></a>
<a name="9897"><span class="lineNum">    9897 </span><span class="lineCov">        110 :   ROSE_ASSERT(result);</span></a>
<a name="9898"><span class="lineNum">    9898 </span>            : </a>
<a name="9899"><span class="lineNum">    9899 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9900"><span class="lineNum">    9900 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9901"><span class="lineNum">    9901 </span><span class="lineCov">        110 :   if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9902"><span class="lineNum">    9902 </span><span class="lineCov">         20 :        result-&gt;setCaseInsensitive(true);</span></a>
<a name="9903"><span class="lineNum">    9903 </span>            : </a>
<a name="9904"><span class="lineNum">    9904 </span><span class="lineCov">        110 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9905"><span class="lineNum">    9905 </span><span class="lineCov">        110 :   if (stmt1) SageInterface::appendStatement(stmt1, result);</span></a>
<a name="9906"><span class="lineNum">    9906 </span><span class="lineCov">        110 :   if (stmt2) SageInterface::appendStatement(stmt2, result);</span></a>
<a name="9907"><span class="lineNum">    9907 </span><span class="lineCov">        110 :   if (stmt3) SageInterface::appendStatement(stmt3, result);</span></a>
<a name="9908"><span class="lineNum">    9908 </span><span class="lineCov">        110 :   if (stmt4) SageInterface::appendStatement(stmt4, result);</span></a>
<a name="9909"><span class="lineNum">    9909 </span><span class="lineCov">        110 :   if (stmt5) SageInterface::appendStatement(stmt5, result);</span></a>
<a name="9910"><span class="lineNum">    9910 </span><span class="lineCov">        110 :   if (stmt6) SageInterface::appendStatement(stmt6, result);</span></a>
<a name="9911"><span class="lineNum">    9911 </span><span class="lineCov">        110 :   if (stmt7) SageInterface::appendStatement(stmt7, result);</span></a>
<a name="9912"><span class="lineNum">    9912 </span><span class="lineCov">        110 :   if (stmt8) SageInterface::appendStatement(stmt8, result);</span></a>
<a name="9913"><span class="lineNum">    9913 </span><span class="lineCov">        110 :   if (stmt9) SageInterface::appendStatement(stmt9, result);</span></a>
<a name="9914"><span class="lineNum">    9914 </span><span class="lineCov">        110 :   if (stmt10) SageInterface::appendStatement(stmt10, result);</span></a>
<a name="9915"><span class="lineNum">    9915 </span>            : </a>
<a name="9916"><span class="lineNum">    9916 </span><span class="lineCov">        110 :   return result;</span></a>
<a name="9917"><span class="lineNum">    9917 </span>            : }</a>
<a name="9918"><span class="lineNum">    9918 </span>            : </a>
<a name="9919"><span class="lineNum">    9919 </span><span class="lineCov">       9473 : SgBasicBlock * SageBuilder::buildBasicBlock_nfi()</span></a>
<a name="9920"><span class="lineNum">    9920 </span>            :    {</a>
<a name="9921"><span class="lineNum">    9921 </span><span class="lineCov">       9473 :      SgBasicBlock* result = new SgBasicBlock();</span></a>
<a name="9922"><span class="lineNum">    9922 </span><span class="lineCov">       9473 :      ROSE_ASSERT(result);</span></a>
<a name="9923"><span class="lineNum">    9923 </span>            : </a>
<a name="9924"><span class="lineNum">    9924 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="9925"><span class="lineNum">    9925 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="9926"><span class="lineNum">    9926 </span><span class="lineCov">       9473 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="9927"><span class="lineNum">    9927 </span>            :         {</a>
<a name="9928"><span class="lineNum">    9928 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="9929"><span class="lineNum">    9929 </span>            :         }</a>
<a name="9930"><span class="lineNum">    9930 </span>            : </a>
<a name="9931"><span class="lineNum">    9931 </span><span class="lineCov">       9473 :      setOneSourcePositionNull(result);</span></a>
<a name="9932"><span class="lineNum">    9932 </span>            : </a>
<a name="9933"><span class="lineNum">    9933 </span>            : #if 0</a>
<a name="9934"><span class="lineNum">    9934 </span>            :      printf (&quot;In buildBasicBlock_nfi(): returning result = %p \n&quot;,result);</a>
<a name="9935"><span class="lineNum">    9935 </span>            : #endif</a>
<a name="9936"><span class="lineNum">    9936 </span>            : </a>
<a name="9937"><span class="lineNum">    9937 </span><span class="lineCov">       9473 :      return result;</span></a>
<a name="9938"><span class="lineNum">    9938 </span>            :    }</a>
<a name="9939"><span class="lineNum">    9939 </span>            : </a>
<a name="9940"><span class="lineNum">    9940 </span><span class="lineCov">          2 : SgBasicBlock* SageBuilder::buildBasicBlock_nfi(const vector&lt;SgStatement*&gt;&amp; stmts)</span></a>
<a name="9941"><span class="lineNum">    9941 </span>            :    {</a>
<a name="9942"><span class="lineNum">    9942 </span><span class="lineCov">          2 :      SgBasicBlock* result = buildBasicBlock_nfi();</span></a>
<a name="9943"><span class="lineNum">    9943 </span><span class="lineCov">          2 :      appendStatementList(stmts, result);</span></a>
<a name="9944"><span class="lineNum">    9944 </span>            : </a>
<a name="9945"><span class="lineNum">    9945 </span>            : #if 0</a>
<a name="9946"><span class="lineNum">    9946 </span>            :      printf (&quot;In buildBasicBlock_nfi(const vector&lt;SgStatement*&gt;&amp; stmts): returning result = %p \n&quot;,result);</a>
<a name="9947"><span class="lineNum">    9947 </span>            : #endif</a>
<a name="9948"><span class="lineNum">    9948 </span>            : </a>
<a name="9949"><span class="lineNum">    9949 </span>            : #if 0</a>
<a name="9950"><span class="lineNum">    9950 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="9951"><span class="lineNum">    9951 </span>            :      ROSE_ABORT();</a>
<a name="9952"><span class="lineNum">    9952 </span>            : #endif</a>
<a name="9953"><span class="lineNum">    9953 </span>            : </a>
<a name="9954"><span class="lineNum">    9954 </span><span class="lineCov">          2 :      return result;</span></a>
<a name="9955"><span class="lineNum">    9955 </span>            :    }</a>
<a name="9956"><span class="lineNum">    9956 </span>            : </a>
<a name="9957"><span class="lineNum">    9957 </span>            : // CR (7/24/2020): Added additional functionality.</a>
<a name="9958"><span class="lineNum">    9958 </span>            : // Build a SgBasicBlock and set its parent. This function does NOT link the parent scope to the block.</a>
<a name="9959"><span class="lineNum">    9959 </span>            : SgBasicBlock*</a>
<a name="9960"><span class="lineNum">    9960 </span><span class="lineNoCov">          0 : SageBuilder::buildBasicBlock_nfi(SgScopeStatement* parent)</span></a>
<a name="9961"><span class="lineNum">    9961 </span>            : {</a>
<a name="9962"><span class="lineNum">    9962 </span><span class="lineNoCov">          0 :    SgBasicBlock* block = buildBasicBlock_nfi();</span></a>
<a name="9963"><span class="lineNum">    9963 </span><span class="lineNoCov">          0 :    block-&gt;set_parent(parent);</span></a>
<a name="9964"><span class="lineNum">    9964 </span>            : </a>
<a name="9965"><span class="lineNum">    9965 </span><span class="lineNoCov">          0 :    return block;</span></a>
<a name="9966"><span class="lineNum">    9966 </span>            : }</a>
<a name="9967"><span class="lineNum">    9967 </span>            : </a>
<a name="9968"><span class="lineNum">    9968 </span>            : </a>
<a name="9969"><span class="lineNum">    9969 </span>            : SgGotoStatement *</a>
<a name="9970"><span class="lineNum">    9970 </span><span class="lineCov">          3 : SageBuilder::buildGotoStatement(SgLabelStatement *  label)</span></a>
<a name="9971"><span class="lineNum">    9971 </span>            : {</a>
<a name="9972"><span class="lineNum">    9972 </span><span class="lineCov">          3 :   SgGotoStatement* result = new SgGotoStatement(label);</span></a>
<a name="9973"><span class="lineNum">    9973 </span><span class="lineCov">          3 :   ROSE_ASSERT(result);</span></a>
<a name="9974"><span class="lineNum">    9974 </span><span class="lineCov">          3 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="9975"><span class="lineNum">    9975 </span><span class="lineCov">          3 :   return result;</span></a>
<a name="9976"><span class="lineNum">    9976 </span>            : }</a>
<a name="9977"><span class="lineNum">    9977 </span>            : </a>
<a name="9978"><span class="lineNum">    9978 </span>            : SgGotoStatement *</a>
<a name="9979"><span class="lineNum">    9979 </span><span class="lineCov">          1 : SageBuilder::buildGotoStatement(SgLabelSymbol*  symbol)</span></a>
<a name="9980"><span class="lineNum">    9980 </span>            : {</a>
<a name="9981"><span class="lineNum">    9981 </span><span class="lineCov">          1 :   SgGotoStatement* result = NULL;</span></a>
<a name="9982"><span class="lineNum">    9982 </span><span class="lineCov">          1 :   ROSE_ASSERT (symbol != NULL);</span></a>
<a name="9983"><span class="lineNum">    9983 </span><span class="lineCov">          1 :   if (SageInterface::is_Fortran_language())</span></a>
<a name="9984"><span class="lineNum">    9984 </span>            :   {  // Fortran case</a>
<a name="9985"><span class="lineNum">    9985 </span><span class="lineCov">          1 :     result = buildGotoStatement((SgLabelStatement *)NULL);</span></a>
<a name="9986"><span class="lineNum">    9986 </span><span class="lineCov">          1 :     SgLabelRefExp* l_exp = buildLabelRefExp(symbol);</span></a>
<a name="9987"><span class="lineNum">    9987 </span><span class="lineCov">          1 :     l_exp-&gt;set_parent(result);</span></a>
<a name="9988"><span class="lineNum">    9988 </span><span class="lineCov">          1 :     result-&gt;set_label_expression(l_exp);</span></a>
<a name="9989"><span class="lineNum">    9989 </span>            :   }</a>
<a name="9990"><span class="lineNum">    9990 </span>            :   else  // C/C++ case</a>
<a name="9991"><span class="lineNum">    9991 </span>            :   {</a>
<a name="9992"><span class="lineNum">    9992 </span><span class="lineNoCov">          0 :     SgLabelStatement* l_stmt = isSgLabelStatement(symbol-&gt;get_declaration());</span></a>
<a name="9993"><span class="lineNum">    9993 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (l_stmt != NULL);</span></a>
<a name="9994"><span class="lineNum">    9994 </span><span class="lineNoCov">          0 :     result = buildGotoStatement(l_stmt);</span></a>
<a name="9995"><span class="lineNum">    9995 </span>            :   }</a>
<a name="9996"><span class="lineNum">    9996 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="9997"><span class="lineNum">    9997 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="9998"><span class="lineNum">    9998 </span>            : }</a>
<a name="9999"><span class="lineNum">    9999 </span>            : </a>
<a name="10000"><span class="lineNum">   10000 </span>            : SgGotoStatement *</a>
<a name="10001"><span class="lineNum">   10001 </span><span class="lineCov">          1 : SageBuilder::buildGotoStatement_nfi(SgLabelStatement *  label)</span></a>
<a name="10002"><span class="lineNum">   10002 </span>            : {</a>
<a name="10003"><span class="lineNum">   10003 </span><span class="lineCov">          1 :   SgGotoStatement* result = new SgGotoStatement(label);</span></a>
<a name="10004"><span class="lineNum">   10004 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="10005"><span class="lineNum">   10005 </span><span class="lineCov">          1 :   setOneSourcePositionNull(result);</span></a>
<a name="10006"><span class="lineNum">   10006 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="10007"><span class="lineNum">   10007 </span>            : }</a>
<a name="10008"><span class="lineNum">   10008 </span>            : </a>
<a name="10009"><span class="lineNum">   10009 </span>            : // DQ (11/22/2017): Added support for computed code goto as defined by GNU C/C++ extension.</a>
<a name="10010"><span class="lineNum">   10010 </span>            : SgGotoStatement *</a>
<a name="10011"><span class="lineNum">   10011 </span><span class="lineNoCov">          0 : SageBuilder::buildGotoStatement_nfi(SgExpression*  label_expression)</span></a>
<a name="10012"><span class="lineNum">   10012 </span>            :    {</a>
<a name="10013"><span class="lineNum">   10013 </span><span class="lineNoCov">          0 :      SgLabelStatement* label = NULL;</span></a>
<a name="10014"><span class="lineNum">   10014 </span><span class="lineNoCov">          0 :      SgGotoStatement* result = new SgGotoStatement(label);</span></a>
<a name="10015"><span class="lineNum">   10015 </span><span class="lineNoCov">          0 :      result-&gt;set_selector_expression(label_expression);</span></a>
<a name="10016"><span class="lineNum">   10016 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="10017"><span class="lineNum">   10017 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="10018"><span class="lineNum">   10018 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="10019"><span class="lineNum">   10019 </span>            :    }</a>
<a name="10020"><span class="lineNum">   10020 </span>            : </a>
<a name="10021"><span class="lineNum">   10021 </span>            : //! Build a return statement</a>
<a name="10022"><span class="lineNum">   10022 </span><span class="lineCov">          1 : SgReturnStmt* SageBuilder::buildReturnStmt(SgExpression* expression /* = NULL */)</span></a>
<a name="10023"><span class="lineNum">   10023 </span>            : {</a>
<a name="10024"><span class="lineNum">   10024 </span>            :   // Liao 2/6/2013. We no longer allow NULL express pointer. Use SgNullExpression instead.</a>
<a name="10025"><span class="lineNum">   10025 </span>            :   // CR (4/27/18): The expression argument to the builder function is optional</a>
<a name="10026"><span class="lineNum">   10026 </span>            :   // (NULL is allowed).  What is not allowed is constructing an SgReturnStmt with a NULL</a>
<a name="10027"><span class="lineNum">   10027 </span>            :   // expression argument.</a>
<a name="10028"><span class="lineNum">   10028 </span><span class="lineCov">          1 :   if (expression == NULL)</span></a>
<a name="10029"><span class="lineNum">   10029 </span>            :   {</a>
<a name="10030"><span class="lineNum">   10030 </span><span class="lineCov">          1 :      expression = buildNullExpression();</span></a>
<a name="10031"><span class="lineNum">   10031 </span>            :   }</a>
<a name="10032"><span class="lineNum">   10032 </span><span class="lineCov">          1 :   SgReturnStmt * result = new SgReturnStmt(expression);</span></a>
<a name="10033"><span class="lineNum">   10033 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="10034"><span class="lineNum">   10034 </span><span class="lineCov">          1 :   if (expression != NULL) expression-&gt;set_parent(result);</span></a>
<a name="10035"><span class="lineNum">   10035 </span><span class="lineCov">          1 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10036"><span class="lineNum">   10036 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="10037"><span class="lineNum">   10037 </span>            : }</a>
<a name="10038"><span class="lineNum">   10038 </span>            : </a>
<a name="10039"><span class="lineNum">   10039 </span>            : //! Build a return statement</a>
<a name="10040"><span class="lineNum">   10040 </span><span class="lineCov">      14305 : SgReturnStmt* SageBuilder::buildReturnStmt_nfi(SgExpression* expression /* = NULL */)</span></a>
<a name="10041"><span class="lineNum">   10041 </span>            : {</a>
<a name="10042"><span class="lineNum">   10042 </span><span class="lineCov">      14305 :   SgReturnStmt * result = new SgReturnStmt(expression);</span></a>
<a name="10043"><span class="lineNum">   10043 </span><span class="lineCov">      14305 :   ROSE_ASSERT(result);</span></a>
<a name="10044"><span class="lineNum">   10044 </span><span class="lineCov">      14305 :   if (expression != NULL) expression-&gt;set_parent(result);</span></a>
<a name="10045"><span class="lineNum">   10045 </span><span class="lineCov">      14305 :   setOneSourcePositionNull(result);</span></a>
<a name="10046"><span class="lineNum">   10046 </span><span class="lineCov">      14305 :   return result;</span></a>
<a name="10047"><span class="lineNum">   10047 </span>            : }</a>
<a name="10048"><span class="lineNum">   10048 </span>            : </a>
<a name="10049"><span class="lineNum">   10049 </span><span class="lineNoCov">          0 : SgCaseOptionStmt * SageBuilder::buildCaseOptionStmt( SgExpression * key,SgStatement *body)</span></a>
<a name="10050"><span class="lineNum">   10050 </span>            : {</a>
<a name="10051"><span class="lineNum">   10051 </span><span class="lineNoCov">          0 :   SgCaseOptionStmt* result = new SgCaseOptionStmt(key,body);</span></a>
<a name="10052"><span class="lineNum">   10052 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10053"><span class="lineNum">   10053 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10054"><span class="lineNum">   10054 </span><span class="lineNoCov">          0 :   if (key) key-&gt;set_parent(result);</span></a>
<a name="10055"><span class="lineNum">   10055 </span><span class="lineNoCov">          0 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="10056"><span class="lineNum">   10056 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10057"><span class="lineNum">   10057 </span>            : }</a>
<a name="10058"><span class="lineNum">   10058 </span>            : </a>
<a name="10059"><span class="lineNum">   10059 </span><span class="lineCov">          1 : SgCaseOptionStmt * SageBuilder::buildCaseOptionStmt_nfi( SgExpression * key,SgStatement *body)</span></a>
<a name="10060"><span class="lineNum">   10060 </span>            : {</a>
<a name="10061"><span class="lineNum">   10061 </span><span class="lineCov">          1 :   SgCaseOptionStmt* result = new SgCaseOptionStmt(key,body);</span></a>
<a name="10062"><span class="lineNum">   10062 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="10063"><span class="lineNum">   10063 </span><span class="lineCov">          1 :   setOneSourcePositionNull(result);</span></a>
<a name="10064"><span class="lineNum">   10064 </span><span class="lineCov">          1 :   if (key) key-&gt;set_parent(result);</span></a>
<a name="10065"><span class="lineNum">   10065 </span><span class="lineCov">          1 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="10066"><span class="lineNum">   10066 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="10067"><span class="lineNum">   10067 </span>            : }</a>
<a name="10068"><span class="lineNum">   10068 </span>            : </a>
<a name="10069"><span class="lineNum">   10069 </span><span class="lineNoCov">          0 : SgDefaultOptionStmt * SageBuilder::buildDefaultOptionStmt( SgStatement *body)</span></a>
<a name="10070"><span class="lineNum">   10070 </span>            : {</a>
<a name="10071"><span class="lineNum">   10071 </span><span class="lineNoCov">          0 :   SgDefaultOptionStmt* result = new SgDefaultOptionStmt(body);</span></a>
<a name="10072"><span class="lineNum">   10072 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10073"><span class="lineNum">   10073 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10074"><span class="lineNum">   10074 </span><span class="lineNoCov">          0 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="10075"><span class="lineNum">   10075 </span>            : </a>
<a name="10076"><span class="lineNum">   10076 </span>            : #if 0</a>
<a name="10077"><span class="lineNum">   10077 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10078"><span class="lineNum">   10078 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10079"><span class="lineNum">   10079 </span>            :   printf (&quot;SageBuilder::buildDefaultOptionStmt() body = %p \n&quot;,body);</a>
<a name="10080"><span class="lineNum">   10080 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10081"><span class="lineNum">   10081 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10082"><span class="lineNum">   10082 </span>            : #endif</a>
<a name="10083"><span class="lineNum">   10083 </span>            : </a>
<a name="10084"><span class="lineNum">   10084 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10085"><span class="lineNum">   10085 </span>            : }</a>
<a name="10086"><span class="lineNum">   10086 </span>            : </a>
<a name="10087"><span class="lineNum">   10087 </span><span class="lineCov">          1 : SgDefaultOptionStmt * SageBuilder::buildDefaultOptionStmt_nfi( SgStatement *body)</span></a>
<a name="10088"><span class="lineNum">   10088 </span>            : {</a>
<a name="10089"><span class="lineNum">   10089 </span><span class="lineCov">          1 :   SgDefaultOptionStmt* result = new SgDefaultOptionStmt(body);</span></a>
<a name="10090"><span class="lineNum">   10090 </span><span class="lineCov">          1 :   ROSE_ASSERT(result);</span></a>
<a name="10091"><span class="lineNum">   10091 </span><span class="lineCov">          1 :   setOneSourcePositionNull(result);</span></a>
<a name="10092"><span class="lineNum">   10092 </span><span class="lineCov">          1 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="10093"><span class="lineNum">   10093 </span>            : </a>
<a name="10094"><span class="lineNum">   10094 </span>            : #if 0</a>
<a name="10095"><span class="lineNum">   10095 </span>            :   static int count = 0;</a>
<a name="10096"><span class="lineNum">   10096 </span>            : </a>
<a name="10097"><span class="lineNum">   10097 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10098"><span class="lineNum">   10098 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10099"><span class="lineNum">   10099 </span>            :   printf (&quot;SageBuilder::buildDefaultOptionStmt_nfi() body = %p \n&quot;,body);</a>
<a name="10100"><span class="lineNum">   10100 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10101"><span class="lineNum">   10101 </span>            :   printf (&quot;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD \n&quot;);</a>
<a name="10102"><span class="lineNum">   10102 </span>            : </a>
<a name="10103"><span class="lineNum">   10103 </span>            :   if (count &gt;= 1)</a>
<a name="10104"><span class="lineNum">   10104 </span>            :      {</a>
<a name="10105"><span class="lineNum">   10105 </span>            :        printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10106"><span class="lineNum">   10106 </span>            :        ROSE_ASSERT(false);</a>
<a name="10107"><span class="lineNum">   10107 </span>            :      }</a>
<a name="10108"><span class="lineNum">   10108 </span>            :   count++;</a>
<a name="10109"><span class="lineNum">   10109 </span>            : #endif</a>
<a name="10110"><span class="lineNum">   10110 </span>            : </a>
<a name="10111"><span class="lineNum">   10111 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="10112"><span class="lineNum">   10112 </span>            : }</a>
<a name="10113"><span class="lineNum">   10113 </span>            : </a>
<a name="10114"><span class="lineNum">   10114 </span><span class="lineNoCov">          0 : SgSwitchStatement* SageBuilder::buildSwitchStatement(SgStatement *item_selector,SgStatement *body)</span></a>
<a name="10115"><span class="lineNum">   10115 </span>            : {</a>
<a name="10116"><span class="lineNum">   10116 </span><span class="lineNoCov">          0 :   SgSwitchStatement* result = new SgSwitchStatement(item_selector,body);</span></a>
<a name="10117"><span class="lineNum">   10117 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10118"><span class="lineNum">   10118 </span>            : </a>
<a name="10119"><span class="lineNum">   10119 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="10120"><span class="lineNum">   10120 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="10121"><span class="lineNum">   10121 </span><span class="lineNoCov">          0 :   if (SageInterface::is_language_case_insensitive())</span></a>
<a name="10122"><span class="lineNum">   10122 </span><span class="lineNoCov">          0 :        result-&gt;setCaseInsensitive(true);</span></a>
<a name="10123"><span class="lineNum">   10123 </span>            : </a>
<a name="10124"><span class="lineNum">   10124 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10125"><span class="lineNum">   10125 </span><span class="lineNoCov">          0 :   if (item_selector) item_selector-&gt;set_parent(result);</span></a>
<a name="10126"><span class="lineNum">   10126 </span><span class="lineNoCov">          0 :   if (body) body-&gt;set_parent(result);</span></a>
<a name="10127"><span class="lineNum">   10127 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10128"><span class="lineNum">   10128 </span>            : }</a>
<a name="10129"><span class="lineNum">   10129 </span>            : </a>
<a name="10130"><span class="lineNum">   10130 </span>            : SgSwitchStatement*</a>
<a name="10131"><span class="lineNum">   10131 </span><span class="lineNoCov">          0 : SageBuilder::buildSwitchStatement_nfi(SgStatement *item_selector,SgStatement *body)</span></a>
<a name="10132"><span class="lineNum">   10132 </span>            :    {</a>
<a name="10133"><span class="lineNum">   10133 </span><span class="lineNoCov">          0 :      SgSwitchStatement* result = new SgSwitchStatement(item_selector,body);</span></a>
<a name="10134"><span class="lineNum">   10134 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="10135"><span class="lineNum">   10135 </span>            : </a>
<a name="10136"><span class="lineNum">   10136 </span>            : #if 0</a>
<a name="10137"><span class="lineNum">   10137 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="10138"><span class="lineNum">   10138 </span>            :      if (symbol_table_case_insensitive_semantics == true)</a>
<a name="10139"><span class="lineNum">   10139 </span>            :           result-&gt;setCaseInsensitive(true);</a>
<a name="10140"><span class="lineNum">   10140 </span>            : </a>
<a name="10141"><span class="lineNum">   10141 </span>            :      setOneSourcePositionNull(result);</a>
<a name="10142"><span class="lineNum">   10142 </span>            :      if (item_selector) item_selector-&gt;set_parent(result);</a>
<a name="10143"><span class="lineNum">   10143 </span>            :      if (body) body-&gt;set_parent(result);</a>
<a name="10144"><span class="lineNum">   10144 </span>            : #else</a>
<a name="10145"><span class="lineNum">   10145 </span>            :   // DQ (2/15/2012): Modified to handle C++ case where variable declarations are allowed in the condition.</a>
<a name="10146"><span class="lineNum">   10146 </span><span class="lineNoCov">          0 :      initializeSwitchStatement(result,item_selector,body);</span></a>
<a name="10147"><span class="lineNum">   10147 </span>            : #endif</a>
<a name="10148"><span class="lineNum">   10148 </span>            : </a>
<a name="10149"><span class="lineNum">   10149 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="10150"><span class="lineNum">   10150 </span>            :    }</a>
<a name="10151"><span class="lineNum">   10151 </span>            : </a>
<a name="10152"><span class="lineNum">   10152 </span>            : //! Build a NULL statement</a>
<a name="10153"><span class="lineNum">   10153 </span><span class="lineCov">          4 : SgNullStatement* SageBuilder::buildNullStatement()</span></a>
<a name="10154"><span class="lineNum">   10154 </span>            : {</a>
<a name="10155"><span class="lineNum">   10155 </span><span class="lineCov">          4 :   SgNullStatement* result = NULL;</span></a>
<a name="10156"><span class="lineNum">   10156 </span><span class="lineCov">          4 :   result = new SgNullStatement();</span></a>
<a name="10157"><span class="lineNum">   10157 </span><span class="lineCov">          4 :   ROSE_ASSERT(result);</span></a>
<a name="10158"><span class="lineNum">   10158 </span><span class="lineCov">          4 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10159"><span class="lineNum">   10159 </span><span class="lineCov">          4 :   return result;</span></a>
<a name="10160"><span class="lineNum">   10160 </span>            : }</a>
<a name="10161"><span class="lineNum">   10161 </span>            : </a>
<a name="10162"><span class="lineNum">   10162 </span>            : //! Build a NULL statement</a>
<a name="10163"><span class="lineNum">   10163 </span><span class="lineCov">        254 : SgNullStatement* SageBuilder::buildNullStatement_nfi()</span></a>
<a name="10164"><span class="lineNum">   10164 </span>            : {</a>
<a name="10165"><span class="lineNum">   10165 </span><span class="lineCov">        254 :   SgNullStatement* result = NULL;</span></a>
<a name="10166"><span class="lineNum">   10166 </span><span class="lineCov">        254 :   result = new SgNullStatement();</span></a>
<a name="10167"><span class="lineNum">   10167 </span><span class="lineCov">        254 :   ROSE_ASSERT(result);</span></a>
<a name="10168"><span class="lineNum">   10168 </span><span class="lineCov">        254 :   setOneSourcePositionNull(result);</span></a>
<a name="10169"><span class="lineNum">   10169 </span><span class="lineCov">        254 :   return result;</span></a>
<a name="10170"><span class="lineNum">   10170 </span>            : }</a>
<a name="10171"><span class="lineNum">   10171 </span>            : </a>
<a name="10172"><span class="lineNum">   10172 </span>            : //! Build an exec stmt</a>
<a name="10173"><span class="lineNum">   10173 </span><span class="lineNoCov">          0 : SgExecStatement* SageBuilder::buildExecStatement(SgExpression* executable,</span></a>
<a name="10174"><span class="lineNum">   10174 </span>            :                                                  SgExpression* globals,</a>
<a name="10175"><span class="lineNum">   10175 </span>            :                                                  SgExpression* locals) {</a>
<a name="10176"><span class="lineNum">   10176 </span><span class="lineNoCov">          0 :     if (locals != NULL &amp;&amp; globals == NULL)</span></a>
<a name="10177"><span class="lineNum">   10177 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(!&quot;buildExecStatement with non-NULL locals requires non-NULL globals&quot;);</span></a>
<a name="10178"><span class="lineNum">   10178 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(executable != NULL);</span></a>
<a name="10179"><span class="lineNum">   10179 </span>            : </a>
<a name="10180"><span class="lineNum">   10180 </span><span class="lineNoCov">          0 :     SgExecStatement* result = new SgExecStatement(executable, globals, locals);</span></a>
<a name="10181"><span class="lineNum">   10181 </span><span class="lineNoCov">          0 :     executable-&gt;set_parent(result);</span></a>
<a name="10182"><span class="lineNum">   10182 </span><span class="lineNoCov">          0 :     if (globals != NULL) globals-&gt;set_parent(result);</span></a>
<a name="10183"><span class="lineNum">   10183 </span><span class="lineNoCov">          0 :     if (locals != NULL) locals-&gt;set_parent(result);</span></a>
<a name="10184"><span class="lineNum">   10184 </span>            : </a>
<a name="10185"><span class="lineNum">   10185 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="10186"><span class="lineNum">   10186 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="10187"><span class="lineNum">   10187 </span>            : }</a>
<a name="10188"><span class="lineNum">   10188 </span>            : </a>
<a name="10189"><span class="lineNum">   10189 </span>            : //! Build an exec stmt</a>
<a name="10190"><span class="lineNum">   10190 </span><span class="lineNoCov">          0 : SgExecStatement* SageBuilder::buildExecStatement_nfi(SgExpression* executable,</span></a>
<a name="10191"><span class="lineNum">   10191 </span>            :                                                      SgExpression* globals,</a>
<a name="10192"><span class="lineNum">   10192 </span>            :                                                      SgExpression* locals) {</a>
<a name="10193"><span class="lineNum">   10193 </span><span class="lineNoCov">          0 :     if (locals != NULL &amp;&amp; globals == NULL)</span></a>
<a name="10194"><span class="lineNum">   10194 </span><span class="lineNoCov">          0 :         ROSE_ASSERT(!&quot;buildExecStatement with non-NULL locals requires non-NULL globals&quot;);</span></a>
<a name="10195"><span class="lineNum">   10195 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(executable != NULL);</span></a>
<a name="10196"><span class="lineNum">   10196 </span>            : </a>
<a name="10197"><span class="lineNum">   10197 </span><span class="lineNoCov">          0 :     SgExecStatement* result = new SgExecStatement(executable, globals, locals);</span></a>
<a name="10198"><span class="lineNum">   10198 </span><span class="lineNoCov">          0 :     executable-&gt;set_parent(result);</span></a>
<a name="10199"><span class="lineNum">   10199 </span><span class="lineNoCov">          0 :     if (globals != NULL) globals-&gt;set_parent(result);</span></a>
<a name="10200"><span class="lineNum">   10200 </span><span class="lineNoCov">          0 :     if (locals != NULL) locals-&gt;set_parent(result);</span></a>
<a name="10201"><span class="lineNum">   10201 </span>            : </a>
<a name="10202"><span class="lineNum">   10202 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="10203"><span class="lineNum">   10203 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="10204"><span class="lineNum">   10204 </span>            : }</a>
<a name="10205"><span class="lineNum">   10205 </span>            : </a>
<a name="10206"><span class="lineNum">   10206 </span>            : //! Build a try statement</a>
<a name="10207"><span class="lineNum">   10207 </span><span class="lineCov">        514 : SgTryStmt* SageBuilder::buildTryStmt(SgStatement* body,</span></a>
<a name="10208"><span class="lineNum">   10208 </span>            :                                      SgCatchOptionStmt* catch0,</a>
<a name="10209"><span class="lineNum">   10209 </span>            :                                      SgCatchOptionStmt* catch1,</a>
<a name="10210"><span class="lineNum">   10210 </span>            :                                      SgCatchOptionStmt* catch2,</a>
<a name="10211"><span class="lineNum">   10211 </span>            :                                      SgCatchOptionStmt* catch3,</a>
<a name="10212"><span class="lineNum">   10212 </span>            :                                      SgCatchOptionStmt* catch4</a>
<a name="10213"><span class="lineNum">   10213 </span>            :                                      )</a>
<a name="10214"><span class="lineNum">   10214 </span>            :    {</a>
<a name="10215"><span class="lineNum">   10215 </span><span class="lineCov">        514 :      ROSE_ASSERT(body != NULL);</span></a>
<a name="10216"><span class="lineNum">   10216 </span><span class="lineCov">        514 :      SgTryStmt* try_stmt = new SgTryStmt(body);</span></a>
<a name="10217"><span class="lineNum">   10217 </span><span class="lineCov">        514 :      body-&gt;set_parent(try_stmt);</span></a>
<a name="10218"><span class="lineNum">   10218 </span>            : </a>
<a name="10219"><span class="lineNum">   10219 </span>            :   // DQ (11/3/2012): Added setting default source position info.</a>
<a name="10220"><span class="lineNum">   10220 </span><span class="lineCov">        514 :      setSourcePosition(try_stmt);</span></a>
<a name="10221"><span class="lineNum">   10221 </span>            : </a>
<a name="10222"><span class="lineNum">   10222 </span><span class="lineCov">        514 :      if (try_stmt-&gt;get_catch_statement_seq_root() != NULL)</span></a>
<a name="10223"><span class="lineNum">   10223 </span>            :         {</a>
<a name="10224"><span class="lineNum">   10224 </span><span class="lineCov">        514 :           if (try_stmt-&gt;get_catch_statement_seq_root()-&gt;get_startOfConstruct() == NULL)</span></a>
<a name="10225"><span class="lineNum">   10225 </span>            :              {</a>
<a name="10226"><span class="lineNum">   10226 </span><span class="lineCov">        514 :                ROSE_ASSERT(try_stmt-&gt;get_catch_statement_seq_root()-&gt;get_endOfConstruct() == NULL);</span></a>
<a name="10227"><span class="lineNum">   10227 </span><span class="lineCov">        514 :                setSourcePosition(try_stmt-&gt;get_catch_statement_seq_root());</span></a>
<a name="10228"><span class="lineNum">   10228 </span>            :              }</a>
<a name="10229"><span class="lineNum">   10229 </span>            : </a>
<a name="10230"><span class="lineNum">   10230 </span><span class="lineCov">        514 :           ROSE_ASSERT(try_stmt-&gt;get_catch_statement_seq_root()-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="10231"><span class="lineNum">   10231 </span><span class="lineCov">        514 :           ROSE_ASSERT(try_stmt-&gt;get_catch_statement_seq_root()-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="10232"><span class="lineNum">   10232 </span>            :         }</a>
<a name="10233"><span class="lineNum">   10233 </span>            : </a>
<a name="10234"><span class="lineNum">   10234 </span><span class="lineCov">        514 :      if (catch0 != NULL) try_stmt-&gt;append_catch_statement(catch0);</span></a>
<a name="10235"><span class="lineNum">   10235 </span><span class="lineCov">        514 :      if (catch1 != NULL) try_stmt-&gt;append_catch_statement(catch1);</span></a>
<a name="10236"><span class="lineNum">   10236 </span><span class="lineCov">        514 :      if (catch2 != NULL) try_stmt-&gt;append_catch_statement(catch2);</span></a>
<a name="10237"><span class="lineNum">   10237 </span><span class="lineCov">        514 :      if (catch3 != NULL) try_stmt-&gt;append_catch_statement(catch3);</span></a>
<a name="10238"><span class="lineNum">   10238 </span><span class="lineCov">        514 :      if (catch4 != NULL) try_stmt-&gt;append_catch_statement(catch4);</span></a>
<a name="10239"><span class="lineNum">   10239 </span>            : </a>
<a name="10240"><span class="lineNum">   10240 </span><span class="lineCov">        514 :      return try_stmt;</span></a>
<a name="10241"><span class="lineNum">   10241 </span>            :    }</a>
<a name="10242"><span class="lineNum">   10242 </span>            : </a>
<a name="10243"><span class="lineNum">   10243 </span>            : </a>
<a name="10244"><span class="lineNum">   10244 </span>            : // charles4 09/16/2011</a>
<a name="10245"><span class="lineNum">   10245 </span>            : //! Build a try statement (used for Java)</a>
<a name="10246"><span class="lineNum">   10246 </span><span class="lineNoCov">          0 : SgTryStmt *SageBuilder::buildTryStmt(SgBasicBlock *try_body, SgBasicBlock *finally_body)</span></a>
<a name="10247"><span class="lineNum">   10247 </span>            :    {</a>
<a name="10248"><span class="lineNum">   10248 </span>            :     //</a>
<a name="10249"><span class="lineNum">   10249 </span>            :     // charles4 09/23/2011 - Note that when an SgTryStmt is allocated, its constructor</a>
<a name="10250"><span class="lineNum">   10250 </span>            :     // preallocates a SgCatchStementSeq for the field p_catch_statement_sequence_root.</a>
<a name="10251"><span class="lineNum">   10251 </span>            :     // So, although the method set_catch_statement_seq_root(catch_statement_sequence) is</a>
<a name="10252"><span class="lineNum">   10252 </span>            :     // available, it should not be used to set the catch_statement_sequence_root as that</a>
<a name="10253"><span class="lineNum">   10253 </span>            :     // would leave the one that was allocated by the constructor dangling!</a>
<a name="10254"><span class="lineNum">   10254 </span>            :     //</a>
<a name="10255"><span class="lineNum">   10255 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(try_body != NULL);</span></a>
<a name="10256"><span class="lineNum">   10256 </span><span class="lineNoCov">          0 :     SgTryStmt* try_stmt = new SgTryStmt(try_body);</span></a>
<a name="10257"><span class="lineNum">   10257 </span><span class="lineNoCov">          0 :     try_body -&gt; set_parent(try_stmt);</span></a>
<a name="10258"><span class="lineNum">   10258 </span>            : </a>
<a name="10259"><span class="lineNum">   10259 </span>            :   // DQ (11/3/2012): Added setting default source position info.</a>
<a name="10260"><span class="lineNum">   10260 </span><span class="lineNoCov">          0 :      setSourcePosition(try_stmt);</span></a>
<a name="10261"><span class="lineNum">   10261 </span>            : </a>
<a name="10262"><span class="lineNum">   10262 </span><span class="lineNoCov">          0 :     if (finally_body) {</span></a>
<a name="10263"><span class="lineNum">   10263 </span><span class="lineNoCov">          0 :         try_stmt -&gt; set_finally_body(finally_body);</span></a>
<a name="10264"><span class="lineNum">   10264 </span><span class="lineNoCov">          0 :         finally_body -&gt; set_parent(try_stmt);</span></a>
<a name="10265"><span class="lineNum">   10265 </span>            :    }</a>
<a name="10266"><span class="lineNum">   10266 </span>            : </a>
<a name="10267"><span class="lineNum">   10267 </span><span class="lineNoCov">          0 :     return try_stmt;</span></a>
<a name="10268"><span class="lineNum">   10268 </span>            : }</a>
<a name="10269"><span class="lineNum">   10269 </span>            : </a>
<a name="10270"><span class="lineNum">   10270 </span>            : // charles4 09/16/2011</a>
<a name="10271"><span class="lineNum">   10271 </span>            : // ! Build an initial sequence of Catch blocks containing 0 or 1 element.</a>
<a name="10272"><span class="lineNum">   10272 </span><span class="lineNoCov">          0 : SgCatchStatementSeq *SageBuilder::buildCatchStatementSeq(SgCatchOptionStmt *catch_option_stmt) {</span></a>
<a name="10273"><span class="lineNum">   10273 </span><span class="lineNoCov">          0 :     SgCatchStatementSeq *catch_statement_sequence = new SgCatchStatementSeq();</span></a>
<a name="10274"><span class="lineNum">   10274 </span>            : </a>
<a name="10275"><span class="lineNum">   10275 </span>            :   // DQ (11/3/2012): Added setting default source position info.</a>
<a name="10276"><span class="lineNum">   10276 </span><span class="lineNoCov">          0 :      setSourcePosition(catch_statement_sequence);</span></a>
<a name="10277"><span class="lineNum">   10277 </span>            : </a>
<a name="10278"><span class="lineNum">   10278 </span><span class="lineNoCov">          0 :     if (catch_option_stmt) {</span></a>
<a name="10279"><span class="lineNum">   10279 </span><span class="lineNoCov">          0 :         catch_statement_sequence -&gt; append_catch_statement(catch_option_stmt);</span></a>
<a name="10280"><span class="lineNum">   10280 </span><span class="lineNoCov">          0 :         catch_option_stmt -&gt; set_parent(catch_statement_sequence);</span></a>
<a name="10281"><span class="lineNum">   10281 </span>            :     }</a>
<a name="10282"><span class="lineNum">   10282 </span>            : </a>
<a name="10283"><span class="lineNum">   10283 </span><span class="lineNoCov">          0 :     return catch_statement_sequence;</span></a>
<a name="10284"><span class="lineNum">   10284 </span>            : }</a>
<a name="10285"><span class="lineNum">   10285 </span>            : </a>
<a name="10286"><span class="lineNum">   10286 </span>            : // charles4 09/21/2011 - Make condition and body arguments optional.</a>
<a name="10287"><span class="lineNum">   10287 </span>            : //! Build a catch statement</a>
<a name="10288"><span class="lineNum">   10288 </span><span class="lineCov">        802 : SgCatchOptionStmt* SageBuilder::buildCatchOptionStmt(SgVariableDeclaration* condition, SgStatement* body) {</span></a>
<a name="10289"><span class="lineNum">   10289 </span><span class="lineCov">        802 :     SgCatchOptionStmt* result = new SgCatchOptionStmt(condition, body, /* SgTryStmt*= */ NULL);</span></a>
<a name="10290"><span class="lineNum">   10290 </span><span class="lineCov">        802 :     if (condition) condition-&gt;set_parent(result);</span></a>
<a name="10291"><span class="lineNum">   10291 </span><span class="lineCov">        802 :     if (body) body-&gt;set_parent(result);</span></a>
<a name="10292"><span class="lineNum">   10292 </span><span class="lineCov">        802 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="10293"><span class="lineNum">   10293 </span><span class="lineCov">        802 :     return result;</span></a>
<a name="10294"><span class="lineNum">   10294 </span>            : }</a>
<a name="10295"><span class="lineNum">   10295 </span>            : </a>
<a name="10296"><span class="lineNum">   10296 </span>            : // DQ (4/30/2010): Added support for building asm statements.</a>
<a name="10297"><span class="lineNum">   10297 </span>            : //! Build an asm statement</a>
<a name="10298"><span class="lineNum">   10298 </span><span class="lineNoCov">          0 : SgAsmStmt* SageBuilder::buildAsmStatement( std::string s )</span></a>
<a name="10299"><span class="lineNum">   10299 </span>            : {</a>
<a name="10300"><span class="lineNum">   10300 </span><span class="lineNoCov">          0 :   SgAsmStmt* result = NULL;</span></a>
<a name="10301"><span class="lineNum">   10301 </span><span class="lineNoCov">          0 :   result = new SgAsmStmt();</span></a>
<a name="10302"><span class="lineNum">   10302 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10303"><span class="lineNum">   10303 </span><span class="lineNoCov">          0 :   result-&gt;set_assemblyCode(s);</span></a>
<a name="10304"><span class="lineNum">   10304 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(result);</span></a>
<a name="10305"><span class="lineNum">   10305 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10306"><span class="lineNum">   10306 </span>            : }</a>
<a name="10307"><span class="lineNum">   10307 </span>            : </a>
<a name="10308"><span class="lineNum">   10308 </span>            : // DQ (4/30/2010): Added support for building asm statements.</a>
<a name="10309"><span class="lineNum">   10309 </span>            : //! Build an asm statement</a>
<a name="10310"><span class="lineNum">   10310 </span><span class="lineNoCov">          0 : SgAsmStmt* SageBuilder::buildAsmStatement_nfi( std::string s )</span></a>
<a name="10311"><span class="lineNum">   10311 </span>            : {</a>
<a name="10312"><span class="lineNum">   10312 </span><span class="lineNoCov">          0 :   SgAsmStmt* result = NULL;</span></a>
<a name="10313"><span class="lineNum">   10313 </span><span class="lineNoCov">          0 :   result = new SgAsmStmt();</span></a>
<a name="10314"><span class="lineNum">   10314 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10315"><span class="lineNum">   10315 </span><span class="lineNoCov">          0 :   result-&gt;set_assemblyCode(s);</span></a>
<a name="10316"><span class="lineNum">   10316 </span><span class="lineNoCov">          0 :   setOneSourcePositionNull(result);</span></a>
<a name="10317"><span class="lineNum">   10317 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10318"><span class="lineNum">   10318 </span>            : }</a>
<a name="10319"><span class="lineNum">   10319 </span>            : </a>
<a name="10320"><span class="lineNum">   10320 </span>            : SgAsmStmt*</a>
<a name="10321"><span class="lineNum">   10321 </span><span class="lineNoCov">          0 : SageBuilder::buildMultibyteNopStatement( int n )</span></a>
<a name="10322"><span class="lineNum">   10322 </span>            :    {</a>
<a name="10323"><span class="lineNum">   10323 </span>            : // Multi-byte NOP instructions.</a>
<a name="10324"><span class="lineNum">   10324 </span>            : // Note: I can't seem to get the memonic versions to work properly</a>
<a name="10325"><span class="lineNum">   10325 </span>            : #define NOP_1_BYTE_STRING &quot;nop&quot;</a>
<a name="10326"><span class="lineNum">   10326 </span>            : #define NOP_2_BYTE_STRING &quot;.byte 0x66,0x90&quot;</a>
<a name="10327"><span class="lineNum">   10327 </span>            : #define NOP_3_BYTE_STRING &quot;nopl (%eax)&quot;</a>
<a name="10328"><span class="lineNum">   10328 </span>            : #define NOP_4_BYTE_STRING &quot;nopl 0x01(%eax)&quot;</a>
<a name="10329"><span class="lineNum">   10329 </span>            : #define NOP_5_BYTE_STRING &quot;.byte 0x0f,0x1f,0x44,0x00,0x00&quot;</a>
<a name="10330"><span class="lineNum">   10330 </span>            : #define NOP_6_BYTE_STRING &quot;.byte 0x66,0x0f,0x1f,0x44,0x00,0x00&quot;</a>
<a name="10331"><span class="lineNum">   10331 </span>            : #define NOP_7_BYTE_STRING &quot;.byte 0x0f,0x1f,0x80,0x00,0x00,0x00,0x00&quot;</a>
<a name="10332"><span class="lineNum">   10332 </span>            : #define NOP_8_BYTE_STRING &quot;.byte 0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00&quot;</a>
<a name="10333"><span class="lineNum">   10333 </span>            : #define NOP_9_BYTE_STRING &quot;.byte 0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00&quot;</a>
<a name="10334"><span class="lineNum">   10334 </span>            : </a>
<a name="10335"><span class="lineNum">   10335 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(n &gt; 0);</span></a>
<a name="10336"><span class="lineNum">   10336 </span>            : </a>
<a name="10337"><span class="lineNum">   10337 </span><span class="lineNoCov">          0 :      SgAsmStmt* nopStatement = NULL;</span></a>
<a name="10338"><span class="lineNum">   10338 </span>            : </a>
<a name="10339"><span class="lineNum">   10339 </span><span class="lineNoCov">          0 :      switch (n)</span></a>
<a name="10340"><span class="lineNum">   10340 </span>            :         {</a>
<a name="10341"><span class="lineNum">   10341 </span><span class="lineNoCov">          0 :           case 1: nopStatement = buildAsmStatement(NOP_1_BYTE_STRING); break;</span></a>
<a name="10342"><span class="lineNum">   10342 </span><span class="lineNoCov">          0 :           case 2: nopStatement = buildAsmStatement(NOP_2_BYTE_STRING); break;</span></a>
<a name="10343"><span class="lineNum">   10343 </span><span class="lineNoCov">          0 :           case 3: nopStatement = buildAsmStatement(NOP_3_BYTE_STRING); break;</span></a>
<a name="10344"><span class="lineNum">   10344 </span><span class="lineNoCov">          0 :           case 4: nopStatement = buildAsmStatement(NOP_4_BYTE_STRING); break;</span></a>
<a name="10345"><span class="lineNum">   10345 </span><span class="lineNoCov">          0 :           case 5: nopStatement = buildAsmStatement(NOP_5_BYTE_STRING); break;</span></a>
<a name="10346"><span class="lineNum">   10346 </span><span class="lineNoCov">          0 :           case 6: nopStatement = buildAsmStatement(NOP_6_BYTE_STRING); break;</span></a>
<a name="10347"><span class="lineNum">   10347 </span><span class="lineNoCov">          0 :           case 7: nopStatement = buildAsmStatement(NOP_7_BYTE_STRING); break;</span></a>
<a name="10348"><span class="lineNum">   10348 </span><span class="lineNoCov">          0 :           case 8: nopStatement = buildAsmStatement(NOP_8_BYTE_STRING); break;</span></a>
<a name="10349"><span class="lineNum">   10349 </span><span class="lineNoCov">          0 :           case 9: nopStatement = buildAsmStatement(NOP_9_BYTE_STRING); break;</span></a>
<a name="10350"><span class="lineNum">   10350 </span>            : </a>
<a name="10351"><span class="lineNum">   10351 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="10352"><span class="lineNum">   10352 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="10353"><span class="lineNum">   10353 </span><span class="lineNoCov">          0 :                printf (&quot;Only supporting values of multi-byte nop's up to 9 bytes long. \n&quot;);</span></a>
<a name="10354"><span class="lineNum">   10354 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="10355"><span class="lineNum">   10355 </span>            :              }</a>
<a name="10356"><span class="lineNum">   10356 </span>            :         }</a>
<a name="10357"><span class="lineNum">   10357 </span>            : </a>
<a name="10358"><span class="lineNum">   10358 </span><span class="lineNoCov">          0 :      return nopStatement;</span></a>
<a name="10359"><span class="lineNum">   10359 </span>            :    }</a>
<a name="10360"><span class="lineNum">   10360 </span>            : </a>
<a name="10361"><span class="lineNum">   10361 </span><span class="lineCov">        156 : SgStaticAssertionDeclaration* SageBuilder::buildStaticAssertionDeclaration(SgExpression* condition, const SgName &amp; string_literal)</span></a>
<a name="10362"><span class="lineNum">   10362 </span>            :    {</a>
<a name="10363"><span class="lineNum">   10363 </span>            :   // DQ (7/25/2014): Adding support for C11 static assertions.</a>
<a name="10364"><span class="lineNum">   10364 </span>            : </a>
<a name="10365"><span class="lineNum">   10365 </span><span class="lineCov">        156 :      ROSE_ASSERT(condition != NULL);</span></a>
<a name="10366"><span class="lineNum">   10366 </span>            : </a>
<a name="10367"><span class="lineNum">   10367 </span><span class="lineCov">        156 :      SgStaticAssertionDeclaration* result = new SgStaticAssertionDeclaration(condition,string_literal);</span></a>
<a name="10368"><span class="lineNum">   10368 </span><span class="lineCov">        156 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10369"><span class="lineNum">   10369 </span>            : </a>
<a name="10370"><span class="lineNum">   10370 </span>            :   // DQ (7/25/2014): It is enforced that at least the firstNondefiningDeclaration be set.</a>
<a name="10371"><span class="lineNum">   10371 </span><span class="lineCov">        156 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() == NULL);</span></a>
<a name="10372"><span class="lineNum">   10372 </span><span class="lineCov">        156 :      result-&gt;set_firstNondefiningDeclaration(result);</span></a>
<a name="10373"><span class="lineNum">   10373 </span><span class="lineCov">        156 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="10374"><span class="lineNum">   10374 </span>            : </a>
<a name="10375"><span class="lineNum">   10375 </span><span class="lineCov">        156 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="10376"><span class="lineNum">   10376 </span>            : </a>
<a name="10377"><span class="lineNum">   10377 </span><span class="lineCov">        156 :      return result;</span></a>
<a name="10378"><span class="lineNum">   10378 </span>            :    }</a>
<a name="10379"><span class="lineNum">   10379 </span>            : </a>
<a name="10380"><span class="lineNum">   10380 </span>            : </a>
<a name="10381"><span class="lineNum">   10381 </span>            : // DQ (8/17/2014): Adding support for Microsoft MSVC specific attributes.</a>
<a name="10382"><span class="lineNum">   10382 </span><span class="lineNoCov">          0 : SgMicrosoftAttributeDeclaration* SageBuilder::buildMicrosoftAttributeDeclaration (const SgName &amp; attribute_string)</span></a>
<a name="10383"><span class="lineNum">   10383 </span>            :    {</a>
<a name="10384"><span class="lineNum">   10384 </span><span class="lineNoCov">          0 :      SgMicrosoftAttributeDeclaration* result = new SgMicrosoftAttributeDeclaration(attribute_string);</span></a>
<a name="10385"><span class="lineNum">   10385 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10386"><span class="lineNum">   10386 </span>            : </a>
<a name="10387"><span class="lineNum">   10387 </span>            :   // DQ (8/17/2014): It is enforced that at least the firstNondefiningDeclaration be set.</a>
<a name="10388"><span class="lineNum">   10388 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() == NULL);</span></a>
<a name="10389"><span class="lineNum">   10389 </span><span class="lineNoCov">          0 :      result-&gt;set_firstNondefiningDeclaration(result);</span></a>
<a name="10390"><span class="lineNum">   10390 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="10391"><span class="lineNum">   10391 </span>            : </a>
<a name="10392"><span class="lineNum">   10392 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="10393"><span class="lineNum">   10393 </span>            : </a>
<a name="10394"><span class="lineNum">   10394 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="10395"><span class="lineNum">   10395 </span>            :    }</a>
<a name="10396"><span class="lineNum">   10396 </span>            : </a>
<a name="10397"><span class="lineNum">   10397 </span>            : //! Build a statement from an arbitrary string, used for irregular statements with macros, platform-specified attributes etc.</a>
<a name="10398"><span class="lineNum">   10398 </span>            : // This does not work properly since the global scope expects declaration statement, not just SgNullStatement</a>
<a name="10399"><span class="lineNum">   10399 </span>            : #if 0</a>
<a name="10400"><span class="lineNum">   10400 </span>            : SgStatement* SageBuilder::buildStatementFromString(std::string str)</a>
<a name="10401"><span class="lineNum">   10401 </span>            : {</a>
<a name="10402"><span class="lineNum">   10402 </span>            :   SgStatement* result = NULL;</a>
<a name="10403"><span class="lineNum">   10403 </span>            : </a>
<a name="10404"><span class="lineNum">   10404 </span>            :     return result;</a>
<a name="10405"><span class="lineNum">   10405 </span>            : </a>
<a name="10406"><span class="lineNum">   10406 </span>            : } //buildStatementFromString()</a>
<a name="10407"><span class="lineNum">   10407 </span>            : #endif</a>
<a name="10408"><span class="lineNum">   10408 </span>            : </a>
<a name="10409"><span class="lineNum">   10409 </span><span class="lineCov">      27072 : SgPointerType* SageBuilder::buildPointerType(SgType * base_type /*= NULL*/)</span></a>
<a name="10410"><span class="lineNum">   10410 </span>            :    {</a>
<a name="10411"><span class="lineNum">   10411 </span>            :   // DQ (7/26/2010): This needs to call the SgPointerType::createType() function so that we can properly abstract the creation of types into the type table.</a>
<a name="10412"><span class="lineNum">   10412 </span>            :   // printf (&quot;ERROR: This function needs to call the SgPointerType::createType() function so that we can properly abstract the creation of types into the type table. \n&quot;);</a>
<a name="10413"><span class="lineNum">   10413 </span>            :   // ROSE_ASSERT(false);</a>
<a name="10414"><span class="lineNum">   10414 </span>            : </a>
<a name="10415"><span class="lineNum">   10415 </span>            :   // DQ (7/29/2010): This function needs to call the SgPointerType::createType() function to support the new type table.</a>
<a name="10416"><span class="lineNum">   10416 </span>            :   // SgPointerType* result = new SgPointerType(base_type);</a>
<a name="10417"><span class="lineNum">   10417 </span><span class="lineCov">      27072 :      if (isSgReferenceType (base_type))</span></a>
<a name="10418"><span class="lineNum">   10418 </span>            :      {</a>
<a name="10419"><span class="lineNum">   10419 </span><span class="lineNoCov">          0 :        cerr&lt;&lt;&quot;Error in SageBuilder::buildPointerType(): trying to build a pointer to a reference type! This is not allowed in C++.&quot;&lt;&lt;endl;</span></a>
<a name="10420"><span class="lineNum">   10420 </span><span class="lineNoCov">          0 :        ROSE_ABORT ();</span></a>
<a name="10421"><span class="lineNum">   10421 </span>            :      }</a>
<a name="10422"><span class="lineNum">   10422 </span>            : </a>
<a name="10423"><span class="lineNum">   10423 </span><span class="lineCov">      27072 :      SgPointerType* result = SgPointerType::createType(base_type);</span></a>
<a name="10424"><span class="lineNum">   10424 </span><span class="lineCov">      27072 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10425"><span class="lineNum">   10425 </span>            : </a>
<a name="10426"><span class="lineNum">   10426 </span><span class="lineCov">      27072 :      return result;</span></a>
<a name="10427"><span class="lineNum">   10427 </span>            :    }</a>
<a name="10428"><span class="lineNum">   10428 </span>            : </a>
<a name="10429"><span class="lineNum">   10429 </span><span class="lineCov">       6863 : SgReferenceType* SageBuilder::buildReferenceType(SgType * base_type /*= NULL*/)</span></a>
<a name="10430"><span class="lineNum">   10430 </span>            :    {</a>
<a name="10431"><span class="lineNum">   10431 </span>            :   // DQ (7/26/2010): This needs to call the SgReferenceType::createType() function so that we can properly abstract the creation of types into the type table.</a>
<a name="10432"><span class="lineNum">   10432 </span>            :   // printf (&quot;ERROR: This function needs to call the SgReferenceType::createType() function so that we can properly abstract the creation of types into the type table. \n&quot;);</a>
<a name="10433"><span class="lineNum">   10433 </span>            :   // ROSE_ASSERT(false);</a>
<a name="10434"><span class="lineNum">   10434 </span>            : </a>
<a name="10435"><span class="lineNum">   10435 </span>            :   // DQ (7/29/2010): This function needs to call the SgPointerType::createType() function to support the new type table.</a>
<a name="10436"><span class="lineNum">   10436 </span>            :   // SgReferenceType* result= new SgReferenceType(base_type);</a>
<a name="10437"><span class="lineNum">   10437 </span><span class="lineCov">       6863 :      SgReferenceType* result = SgReferenceType::createType(base_type);</span></a>
<a name="10438"><span class="lineNum">   10438 </span><span class="lineCov">       6863 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10439"><span class="lineNum">   10439 </span>            : </a>
<a name="10440"><span class="lineNum">   10440 </span><span class="lineCov">       6863 :      return result;</span></a>
<a name="10441"><span class="lineNum">   10441 </span>            :    }</a>
<a name="10442"><span class="lineNum">   10442 </span>            : </a>
<a name="10443"><span class="lineNum">   10443 </span><span class="lineCov">       1783 : SgRvalueReferenceType* SageBuilder::buildRvalueReferenceType(SgType* base_type /*= NULL*/)</span></a>
<a name="10444"><span class="lineNum">   10444 </span>            :    {</a>
<a name="10445"><span class="lineNum">   10445 </span><span class="lineCov">       1783 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="10446"><span class="lineNum">   10446 </span><span class="lineCov">       1783 :      SgRvalueReferenceType* result = SgRvalueReferenceType::createType(base_type);</span></a>
<a name="10447"><span class="lineNum">   10447 </span><span class="lineCov">       1783 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10448"><span class="lineNum">   10448 </span>            : </a>
<a name="10449"><span class="lineNum">   10449 </span><span class="lineCov">       1783 :      return result;</span></a>
<a name="10450"><span class="lineNum">   10450 </span>            :    }</a>
<a name="10451"><span class="lineNum">   10451 </span>            : </a>
<a name="10452"><span class="lineNum">   10452 </span><span class="lineCov">       1044 : SgDeclType* SageBuilder::buildDeclType ( SgExpression *base_expression, SgType* base_type )</span></a>
<a name="10453"><span class="lineNum">   10453 </span>            :    {</a>
<a name="10454"><span class="lineNum">   10454 </span><span class="lineCov">       1044 :      ROSE_ASSERT(base_expression != NULL);</span></a>
<a name="10455"><span class="lineNum">   10455 </span>            : #if 0</a>
<a name="10456"><span class="lineNum">   10456 </span>            :      printf (&quot;In SageBuilder::buildDeclType(): base_expression = %p = %s \n&quot;,base_expression,base_expression-&gt;class_name().c_str());</a>
<a name="10457"><span class="lineNum">   10457 </span>            : #endif</a>
<a name="10458"><span class="lineNum">   10458 </span>            : </a>
<a name="10459"><span class="lineNum">   10459 </span>            :   // SgDeclType* result = SgDeclType::createType(base_expression);</a>
<a name="10460"><span class="lineNum">   10460 </span><span class="lineCov">       1044 :      SgDeclType* result = NULL;</span></a>
<a name="10461"><span class="lineNum">   10461 </span><span class="lineCov">       1044 :      if (isSgFunctionParameterRefExp(base_expression) != NULL)</span></a>
<a name="10462"><span class="lineNum">   10462 </span>            :         {</a>
<a name="10463"><span class="lineNum">   10463 </span>            :        // result = SgDeclType::createType(base_type);</a>
<a name="10464"><span class="lineNum">   10464 </span><span class="lineNoCov">          0 :            result = new SgDeclType(base_expression);</span></a>
<a name="10465"><span class="lineNum">   10465 </span><span class="lineNoCov">          0 :            result-&gt;set_base_type(base_type);</span></a>
<a name="10466"><span class="lineNum">   10466 </span>            :         }</a>
<a name="10467"><span class="lineNum">   10467 </span>            :        else</a>
<a name="10468"><span class="lineNum">   10468 </span>            :         {</a>
<a name="10469"><span class="lineNum">   10469 </span><span class="lineCov">       1044 :           result = SgDeclType::createType(base_expression);</span></a>
<a name="10470"><span class="lineNum">   10470 </span>            :         }</a>
<a name="10471"><span class="lineNum">   10471 </span>            : </a>
<a name="10472"><span class="lineNum">   10472 </span><span class="lineCov">       1044 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10473"><span class="lineNum">   10473 </span>            : </a>
<a name="10474"><span class="lineNum">   10474 </span>            :   // DQ (8/12/2014): Set the parent in the expression.</a>
<a name="10475"><span class="lineNum">   10475 </span><span class="lineCov">       1044 :      base_expression-&gt;set_parent(result);</span></a>
<a name="10476"><span class="lineNum">   10476 </span>            : </a>
<a name="10477"><span class="lineNum">   10477 </span><span class="lineCov">       1044 :      return result;</span></a>
<a name="10478"><span class="lineNum">   10478 </span>            :    }</a>
<a name="10479"><span class="lineNum">   10479 </span>            : </a>
<a name="10480"><span class="lineNum">   10480 </span>            : //! Build a GNU typeof operator</a>
<a name="10481"><span class="lineNum">   10481 </span><span class="lineCov">         36 : SgTypeOfType* SageBuilder::buildTypeOfType(SgExpression *base_expression, SgType* base_type)</span></a>
<a name="10482"><span class="lineNum">   10482 </span>            :    {</a>
<a name="10483"><span class="lineNum">   10483 </span>            :   // ROSE_ASSERT(base_expression != NULL);</a>
<a name="10484"><span class="lineNum">   10484 </span>            : </a>
<a name="10485"><span class="lineNum">   10485 </span>            : #define DEBUG_TYPEOF_TYPE 0</a>
<a name="10486"><span class="lineNum">   10486 </span>            : </a>
<a name="10487"><span class="lineNum">   10487 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10488"><span class="lineNum">   10488 </span>            :      printf (&quot;In SageBuilder::buildTypeOfType(): base_expression = %p = %s \n&quot;,base_expression,base_expression != NULL ? base_expression-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="10489"><span class="lineNum">   10489 </span>            :      printf (&quot;   ------------------------------- base_type       = %p = %s \n&quot;,base_type,base_type != NULL ? base_type-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="10490"><span class="lineNum">   10490 </span>            : #endif</a>
<a name="10491"><span class="lineNum">   10491 </span>            : </a>
<a name="10492"><span class="lineNum">   10492 </span><span class="lineCov">         36 :      SgTypeOfType* result = NULL;</span></a>
<a name="10493"><span class="lineNum">   10493 </span><span class="lineCov">         36 :      if (isSgFunctionParameterRefExp(base_expression) != NULL)</span></a>
<a name="10494"><span class="lineNum">   10494 </span>            :         {</a>
<a name="10495"><span class="lineNum">   10495 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10496"><span class="lineNum">   10496 </span>            :           printf (&quot;In SageBuilder::buildTypeOfType(): isSgFunctionParameterRefExp(base_expression) != NULL: calling new SgTypeOfType(base_expression,NULL) \n&quot;);</a>
<a name="10497"><span class="lineNum">   10497 </span>            : #endif</a>
<a name="10498"><span class="lineNum">   10498 </span><span class="lineNoCov">          0 :           result = new SgTypeOfType(base_expression,NULL);</span></a>
<a name="10499"><span class="lineNum">   10499 </span>            : </a>
<a name="10500"><span class="lineNum">   10500 </span>            :        // DQ (3/28/2015): Testing for corruption in return value.</a>
<a name="10501"><span class="lineNum">   10501 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(result != NULL);</span></a>
<a name="10502"><span class="lineNum">   10502 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10503"><span class="lineNum">   10503 </span>            :           printf (&quot;In buildTypeOfType(): test 1: result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="10504"><span class="lineNum">   10504 </span>            : #endif</a>
<a name="10505"><span class="lineNum">   10505 </span><span class="lineNoCov">          0 :           result-&gt;set_base_type(base_type);</span></a>
<a name="10506"><span class="lineNum">   10506 </span>            :         }</a>
<a name="10507"><span class="lineNum">   10507 </span>            :        else</a>
<a name="10508"><span class="lineNum">   10508 </span>            :         {</a>
<a name="10509"><span class="lineNum">   10509 </span>            :        // result = SgTypeOfType::createType(base_expression);</a>
<a name="10510"><span class="lineNum">   10510 </span><span class="lineCov">         36 :           if (base_expression != NULL)</span></a>
<a name="10511"><span class="lineNum">   10511 </span>            :              {</a>
<a name="10512"><span class="lineNum">   10512 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10513"><span class="lineNum">   10513 </span>            :                printf (&quot;In SageBuilder::buildTypeOfType(): isSgFunctionParameterRefExp(base_expression) == NULL: base_expression != NULL: calling SgTypeOfType::createType(base_expression,NULL) \n&quot;);</a>
<a name="10514"><span class="lineNum">   10514 </span>            : #endif</a>
<a name="10515"><span class="lineNum">   10515 </span><span class="lineCov">         30 :                result = SgTypeOfType::createType(base_expression,NULL);</span></a>
<a name="10516"><span class="lineNum">   10516 </span>            : </a>
<a name="10517"><span class="lineNum">   10517 </span>            :             // DQ (3/28/2015): Testing for corruption in return value.</a>
<a name="10518"><span class="lineNum">   10518 </span><span class="lineCov">         30 :                ROSE_ASSERT(result != NULL);</span></a>
<a name="10519"><span class="lineNum">   10519 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10520"><span class="lineNum">   10520 </span>            :                printf (&quot;In buildTypeOfType(): test 2: result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="10521"><span class="lineNum">   10521 </span>            : #endif</a>
<a name="10522"><span class="lineNum">   10522 </span>            :              }</a>
<a name="10523"><span class="lineNum">   10523 </span>            :             else</a>
<a name="10524"><span class="lineNum">   10524 </span>            :              {</a>
<a name="10525"><span class="lineNum">   10525 </span>            :             // result = SgTypeOfType::createType((SgType*)NULL);</a>
<a name="10526"><span class="lineNum">   10526 </span><span class="lineCov">          6 :                ROSE_ASSERT(base_type != NULL);</span></a>
<a name="10527"><span class="lineNum">   10527 </span>            : </a>
<a name="10528"><span class="lineNum">   10528 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10529"><span class="lineNum">   10529 </span>            :                printf (&quot;In SageBuilder::buildTypeOfType(): isSgFunctionParameterRefExp(base_expression) == NULL: base_expression == NULL: calling SgTypeOfType::createType(base_type,NULL) \n&quot;);</a>
<a name="10530"><span class="lineNum">   10530 </span>            : #endif</a>
<a name="10531"><span class="lineNum">   10531 </span><span class="lineCov">          6 :                result = SgTypeOfType::createType(base_type,NULL);</span></a>
<a name="10532"><span class="lineNum">   10532 </span>            : </a>
<a name="10533"><span class="lineNum">   10533 </span>            :             // DQ (3/28/2015): Testing for corruption in return value.</a>
<a name="10534"><span class="lineNum">   10534 </span><span class="lineCov">          6 :                ROSE_ASSERT(result != NULL);</span></a>
<a name="10535"><span class="lineNum">   10535 </span>            : </a>
<a name="10536"><span class="lineNum">   10536 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10537"><span class="lineNum">   10537 </span>            :                printf (&quot;In buildTypeOfType(): test 3: result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="10538"><span class="lineNum">   10538 </span>            : #endif</a>
<a name="10539"><span class="lineNum">   10539 </span>            :             // result-&gt;set_base_type(base_type);</a>
<a name="10540"><span class="lineNum">   10540 </span><span class="lineCov">          6 :                if (result-&gt;get_base_type() != base_type)</span></a>
<a name="10541"><span class="lineNum">   10541 </span>            :                   {</a>
<a name="10542"><span class="lineNum">   10542 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(result-&gt;get_base_type() != NULL);</span></a>
<a name="10543"><span class="lineNum">   10543 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10544"><span class="lineNum">   10544 </span>            :                     printf (&quot;result-&gt;get_base_type() = %p = %s \n&quot;,result-&gt;get_base_type(),result-&gt;get_base_type()-&gt;class_name().c_str());</a>
<a name="10545"><span class="lineNum">   10545 </span>            : #endif</a>
<a name="10546"><span class="lineNum">   10546 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(base_type != NULL);</span></a>
<a name="10547"><span class="lineNum">   10547 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10548"><span class="lineNum">   10548 </span>            :                     printf (&quot;base_type               = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str());</a>
<a name="10549"><span class="lineNum">   10549 </span>            : #endif</a>
<a name="10550"><span class="lineNum">   10550 </span>            :                   }</a>
<a name="10551"><span class="lineNum">   10551 </span>            :             // ROSE_ASSERT(result-&gt;get_base_type() == base_type);</a>
<a name="10552"><span class="lineNum">   10552 </span>            :              }</a>
<a name="10553"><span class="lineNum">   10553 </span>            :         }</a>
<a name="10554"><span class="lineNum">   10554 </span>            : </a>
<a name="10555"><span class="lineNum">   10555 </span><span class="lineCov">         36 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10556"><span class="lineNum">   10556 </span>            : </a>
<a name="10557"><span class="lineNum">   10557 </span><span class="lineCov">         36 :      if (base_expression != NULL)</span></a>
<a name="10558"><span class="lineNum">   10558 </span>            :         {</a>
<a name="10559"><span class="lineNum">   10559 </span><span class="lineCov">         30 :           base_expression-&gt;set_parent(result);</span></a>
<a name="10560"><span class="lineNum">   10560 </span>            :         }</a>
<a name="10561"><span class="lineNum">   10561 </span>            : </a>
<a name="10562"><span class="lineNum">   10562 </span>            :   // DQ (3/28/2015): Testing for corruption in return value.</a>
<a name="10563"><span class="lineNum">   10563 </span><span class="lineCov">         36 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10564"><span class="lineNum">   10564 </span>            : </a>
<a name="10565"><span class="lineNum">   10565 </span>            : #if DEBUG_TYPEOF_TYPE</a>
<a name="10566"><span class="lineNum">   10566 </span>            :      printf (&quot;In buildTypeOfType(): test 4: result = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="10567"><span class="lineNum">   10567 </span>            : #endif</a>
<a name="10568"><span class="lineNum">   10568 </span>            : </a>
<a name="10569"><span class="lineNum">   10569 </span><span class="lineCov">         36 :      return result;</span></a>
<a name="10570"><span class="lineNum">   10570 </span>            :    }</a>
<a name="10571"><span class="lineNum">   10571 </span>            : </a>
<a name="10572"><span class="lineNum">   10572 </span>            : </a>
<a name="10573"><span class="lineNum">   10573 </span>            : </a>
<a name="10574"><span class="lineNum">   10574 </span>            : #if 0</a>
<a name="10575"><span class="lineNum">   10575 </span>            : // Liao, 8/16/2010, This function is being phased out. Please don't call this!!</a>
<a name="10576"><span class="lineNum">   10576 </span>            : SgModifierType* SageBuilder::buildModifierType(SgType * base_type /*= NULL*/)</a>
<a name="10577"><span class="lineNum">   10577 </span>            :    {</a>
<a name="10578"><span class="lineNum">   10578 </span>            :   // DQ (7/30/2010): Note that this is called by the outline test: tests/nonsmoke/functional/roseTests/astOutliningTests/moreTest3.cpp</a>
<a name="10579"><span class="lineNum">   10579 </span>            :   // DQ (7/28/2010): Now we want to make calling this function an error, the functions buildConst() will return SgModifierType objects instead.</a>
<a name="10580"><span class="lineNum">   10580 </span>            :      printf (&quot;Error: this function SageBuilder::buildModifierType() should not be called! (call the buildConst() function (or whatever other function is required) directly \n&quot;);</a>
<a name="10581"><span class="lineNum">   10581 </span>            :    ROSE_ABORT();</a>
<a name="10582"><span class="lineNum">   10582 </span>            :    // Liao, 8/13/2010, This function is being phased out. Please don't call this!!</a>
<a name="10583"><span class="lineNum">   10583 </span>            : </a>
<a name="10584"><span class="lineNum">   10584 </span>            :   // DQ (7/26/2010): This needs to call the SgModifierType::createType() function so that we can properly abstract the creation of types into the type table.</a>
<a name="10585"><span class="lineNum">   10585 </span>            :      SgModifierType* result = new SgModifierType(base_type);</a>
<a name="10586"><span class="lineNum">   10586 </span>            :   // SgModifierType* result = SgModifierType::createType(base_type);</a>
<a name="10587"><span class="lineNum">   10587 </span>            :      ROSE_ASSERT(result != NULL);</a>
<a name="10588"><span class="lineNum">   10588 </span>            : </a>
<a name="10589"><span class="lineNum">   10589 </span>            :   // DQ (7/28/2010): Insert result type into type table and return it, or</a>
<a name="10590"><span class="lineNum">   10590 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="10591"><span class="lineNum">   10591 </span>            :   // the type from type table.</a>
<a name="10592"><span class="lineNum">   10592 </span>            :      result = SgModifierType::insertModifierTypeIntoTypeTable(result);</a>
<a name="10593"><span class="lineNum">   10593 </span>            : </a>
<a name="10594"><span class="lineNum">   10594 </span>            :      return result;</a>
<a name="10595"><span class="lineNum">   10595 </span>            :    }</a>
<a name="10596"><span class="lineNum">   10596 </span>            : #endif</a>
<a name="10597"><span class="lineNum">   10597 </span>            : </a>
<a name="10598"><span class="lineNum">   10598 </span>            : // CR (2/20/2020): Added builder functions for type size (kind) expressions for Fortran and Jovial</a>
<a name="10599"><span class="lineNum">   10599 </span><span class="lineCov">         69 : SgTypeBool * SageBuilder::buildBoolType(SgExpression* kind_expr) {</span></a>
<a name="10600"><span class="lineNum">   10600 </span><span class="lineCov">         69 :   SgTypeBool * result = SgTypeBool::createType(kind_expr);</span></a>
<a name="10601"><span class="lineNum">   10601 </span><span class="lineCov">         69 :   ROSE_ASSERT(result);</span></a>
<a name="10602"><span class="lineNum">   10602 </span><span class="lineCov">         69 :   if (kind_expr != NULL) kind_expr-&gt;set_parent(result);</span></a>
<a name="10603"><span class="lineNum">   10603 </span><span class="lineCov">         69 :   return result;</span></a>
<a name="10604"><span class="lineNum">   10604 </span>            : }</a>
<a name="10605"><span class="lineNum">   10605 </span>            : </a>
<a name="10606"><span class="lineNum">   10606 </span><span class="lineCov">         69 : SgTypeBool * SageBuilder::buildBoolType() {</span></a>
<a name="10607"><span class="lineNum">   10607 </span><span class="lineCov">         69 :   return buildBoolType(NULL);</span></a>
<a name="10608"><span class="lineNum">   10608 </span>            : }</a>
<a name="10609"><span class="lineNum">   10609 </span>            : </a>
<a name="10610"><span class="lineNum">   10610 </span><span class="lineCov">         66 : SgTypeNullptr* SageBuilder::buildNullptrType()</span></a>
<a name="10611"><span class="lineNum">   10611 </span>            :    {</a>
<a name="10612"><span class="lineNum">   10612 </span><span class="lineCov">         66 :      SgTypeNullptr * result = SgTypeNullptr::createType();</span></a>
<a name="10613"><span class="lineNum">   10613 </span><span class="lineCov">         66 :      ROSE_ASSERT(result);</span></a>
<a name="10614"><span class="lineNum">   10614 </span><span class="lineCov">         66 :      return result;</span></a>
<a name="10615"><span class="lineNum">   10615 </span>            :    }</a>
<a name="10616"><span class="lineNum">   10616 </span>            : </a>
<a name="10617"><span class="lineNum">   10617 </span><span class="lineCov">        364 : SgTypeChar * SageBuilder::buildCharType()</span></a>
<a name="10618"><span class="lineNum">   10618 </span>            : {</a>
<a name="10619"><span class="lineNum">   10619 </span><span class="lineCov">        364 :   SgTypeChar * result =SgTypeChar::createType();</span></a>
<a name="10620"><span class="lineNum">   10620 </span><span class="lineCov">        364 :   ROSE_ASSERT(result);</span></a>
<a name="10621"><span class="lineNum">   10621 </span><span class="lineCov">        364 :   return result;</span></a>
<a name="10622"><span class="lineNum">   10622 </span>            : }</a>
<a name="10623"><span class="lineNum">   10623 </span>            : </a>
<a name="10624"><span class="lineNum">   10624 </span>            : #if 0 // did not work, build##itemType would be expanded correctly</a>
<a name="10625"><span class="lineNum">   10625 </span>            : #define BUILD_SGTYPE_DEF(item) \</a>
<a name="10626"><span class="lineNum">   10626 </span>            :   SgType##item * SageBuilder::build##itemType() { \</a>
<a name="10627"><span class="lineNum">   10627 </span>            :   SgType##item * result =SgType##item::createType(); \</a>
<a name="10628"><span class="lineNum">   10628 </span>            :   ROSE_ASSERT(result); \</a>
<a name="10629"><span class="lineNum">   10629 </span>            :   return result; \</a>
<a name="10630"><span class="lineNum">   10630 </span>            :   }</a>
<a name="10631"><span class="lineNum">   10631 </span>            : </a>
<a name="10632"><span class="lineNum">   10632 </span>            :   BUILD_SGTYPE_DEF(Bool)</a>
<a name="10633"><span class="lineNum">   10633 </span>            :   BUILD_SGTYPE_DEF(Char)</a>
<a name="10634"><span class="lineNum">   10634 </span>            :   BUILD_SGTYPE_DEF(Double)</a>
<a name="10635"><span class="lineNum">   10635 </span>            :   BUILD_SGTYPE_DEF(Float)</a>
<a name="10636"><span class="lineNum">   10636 </span>            :   BUILD_SGTYPE_DEF(Int)</a>
<a name="10637"><span class="lineNum">   10637 </span>            :   BUILD_SGTYPE_DEF(Long)</a>
<a name="10638"><span class="lineNum">   10638 </span>            :   BUILD_SGTYPE_DEF(LongDouble)</a>
<a name="10639"><span class="lineNum">   10639 </span>            :   BUILD_SGTYPE_DEF(LongLong)</a>
<a name="10640"><span class="lineNum">   10640 </span>            :   BUILD_SGTYPE_DEF(Short)</a>
<a name="10641"><span class="lineNum">   10641 </span>            :   BUILD_SGTYPE_DEF(Void)</a>
<a name="10642"><span class="lineNum">   10642 </span>            : </a>
<a name="10643"><span class="lineNum">   10643 </span>            :   BUILD_SGTYPE_DEF(Wchar)</a>
<a name="10644"><span class="lineNum">   10644 </span>            : </a>
<a name="10645"><span class="lineNum">   10645 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="10646"><span class="lineNum">   10646 </span>            :   BUILD_SGTYPE_DEF(Char16)</a>
<a name="10647"><span class="lineNum">   10647 </span>            :   BUILD_SGTYPE_DEF(Char32)</a>
<a name="10648"><span class="lineNum">   10648 </span>            : </a>
<a name="10649"><span class="lineNum">   10649 </span>            :   BUILD_SGTYPE_DEF(SignedChar)</a>
<a name="10650"><span class="lineNum">   10650 </span>            :   BUILD_SGTYPE_DEF(SignedInt)</a>
<a name="10651"><span class="lineNum">   10651 </span>            :   BUILD_SGTYPE_DEF(SignedLong)</a>
<a name="10652"><span class="lineNum">   10652 </span>            :   BUILD_SGTYPE_DEF(SignedShort)</a>
<a name="10653"><span class="lineNum">   10653 </span>            :   BUILD_SGTYPE_DEF(UnsignedChar)</a>
<a name="10654"><span class="lineNum">   10654 </span>            :   BUILD_SGTYPE_DEF(UnsignedInt)</a>
<a name="10655"><span class="lineNum">   10655 </span>            :   BUILD_SGTYPE_DEF(UnsignedLong)</a>
<a name="10656"><span class="lineNum">   10656 </span>            :   BUILD_SGTYPE_DEF(UnsignedLongLong)</a>
<a name="10657"><span class="lineNum">   10657 </span>            :   BUILD_SGTYPE_DEF(UnsignedShort)</a>
<a name="10658"><span class="lineNum">   10658 </span>            : #undef BUILD_SGTYPE_DEF</a>
<a name="10659"><span class="lineNum">   10659 </span>            : #endif</a>
<a name="10660"><span class="lineNum">   10660 </span><span class="lineCov">        320 : SgTypeLongLong * SageBuilder::buildLongLongType()</span></a>
<a name="10661"><span class="lineNum">   10661 </span>            : {</a>
<a name="10662"><span class="lineNum">   10662 </span><span class="lineCov">        320 :   SgTypeLongLong * result =SgTypeLongLong::createType();</span></a>
<a name="10663"><span class="lineNum">   10663 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10664"><span class="lineNum">   10664 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10665"><span class="lineNum">   10665 </span>            : }</a>
<a name="10666"><span class="lineNum">   10666 </span>            : </a>
<a name="10667"><span class="lineNum">   10667 </span><span class="lineCov">        640 : SgTypeLongDouble * SageBuilder::buildLongDoubleType()</span></a>
<a name="10668"><span class="lineNum">   10668 </span>            : {</a>
<a name="10669"><span class="lineNum">   10669 </span><span class="lineCov">        640 :   SgTypeLongDouble * result =SgTypeLongDouble::createType();</span></a>
<a name="10670"><span class="lineNum">   10670 </span><span class="lineCov">        640 :   ROSE_ASSERT(result);</span></a>
<a name="10671"><span class="lineNum">   10671 </span><span class="lineCov">        640 :   return result;</span></a>
<a name="10672"><span class="lineNum">   10672 </span>            : }</a>
<a name="10673"><span class="lineNum">   10673 </span>            : </a>
<a name="10674"><span class="lineNum">   10674 </span><span class="lineCov">        320 : SgTypeUnsignedLongLong * SageBuilder::buildUnsignedLongLongType()</span></a>
<a name="10675"><span class="lineNum">   10675 </span>            : {</a>
<a name="10676"><span class="lineNum">   10676 </span><span class="lineCov">        320 :   SgTypeUnsignedLongLong * result =SgTypeUnsignedLongLong::createType();</span></a>
<a name="10677"><span class="lineNum">   10677 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10678"><span class="lineNum">   10678 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10679"><span class="lineNum">   10679 </span>            : }</a>
<a name="10680"><span class="lineNum">   10680 </span>            : </a>
<a name="10681"><span class="lineNum">   10681 </span><span class="lineCov">        320 : SgTypeUnsignedLong * SageBuilder::buildUnsignedLongType()</span></a>
<a name="10682"><span class="lineNum">   10682 </span>            : {</a>
<a name="10683"><span class="lineNum">   10683 </span><span class="lineCov">        320 :   SgTypeUnsignedLong * result = SgTypeUnsignedLong::createType();</span></a>
<a name="10684"><span class="lineNum">   10684 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10685"><span class="lineNum">   10685 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10686"><span class="lineNum">   10686 </span>            : }</a>
<a name="10687"><span class="lineNum">   10687 </span>            : </a>
<a name="10688"><span class="lineNum">   10688 </span>            : // CR (2/20/2020): Added builder functions for type size (kind) expressions for Fortran and Jovial</a>
<a name="10689"><span class="lineNum">   10689 </span><span class="lineCov">        320 : SgTypeUnsignedInt * SageBuilder::buildUnsignedIntType(SgExpression* kind_expr)</span></a>
<a name="10690"><span class="lineNum">   10690 </span>            : {</a>
<a name="10691"><span class="lineNum">   10691 </span><span class="lineCov">        320 :   SgTypeUnsignedInt * result = SgTypeUnsignedInt::createType(kind_expr);</span></a>
<a name="10692"><span class="lineNum">   10692 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10693"><span class="lineNum">   10693 </span><span class="lineCov">        320 :   if (kind_expr != NULL) kind_expr-&gt;set_parent(result);</span></a>
<a name="10694"><span class="lineNum">   10694 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10695"><span class="lineNum">   10695 </span>            : }</a>
<a name="10696"><span class="lineNum">   10696 </span><span class="lineCov">        320 : SgTypeUnsignedInt * SageBuilder::buildUnsignedIntType()</span></a>
<a name="10697"><span class="lineNum">   10697 </span>            : {</a>
<a name="10698"><span class="lineNum">   10698 </span><span class="lineCov">        320 :   return buildUnsignedIntType(NULL);</span></a>
<a name="10699"><span class="lineNum">   10699 </span>            : }</a>
<a name="10700"><span class="lineNum">   10700 </span>            : </a>
<a name="10701"><span class="lineNum">   10701 </span><span class="lineCov">        198 : SgTypeSignedShort * SageBuilder::buildSignedShortType()</span></a>
<a name="10702"><span class="lineNum">   10702 </span>            : {</a>
<a name="10703"><span class="lineNum">   10703 </span><span class="lineCov">        198 :   SgTypeSignedShort * result = SgTypeSignedShort::createType();</span></a>
<a name="10704"><span class="lineNum">   10704 </span><span class="lineCov">        198 :   ROSE_ASSERT(result);</span></a>
<a name="10705"><span class="lineNum">   10705 </span><span class="lineCov">        198 :   return result;</span></a>
<a name="10706"><span class="lineNum">   10706 </span>            : }</a>
<a name="10707"><span class="lineNum">   10707 </span>            : </a>
<a name="10708"><span class="lineNum">   10708 </span><span class="lineNoCov">          0 : SgTypeFloat80*  SageBuilder::buildFloat80Type() {</span></a>
<a name="10709"><span class="lineNum">   10709 </span><span class="lineNoCov">          0 :   SgTypeFloat80 * result = SgTypeFloat80::createType();</span></a>
<a name="10710"><span class="lineNum">   10710 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10711"><span class="lineNum">   10711 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10712"><span class="lineNum">   10712 </span>            : }</a>
<a name="10713"><span class="lineNum">   10713 </span>            : </a>
<a name="10714"><span class="lineNum">   10714 </span><span class="lineCov">         26 : SgTypeFloat128* SageBuilder::buildFloat128Type() {</span></a>
<a name="10715"><span class="lineNum">   10715 </span><span class="lineCov">         26 :   SgTypeFloat128 * result = SgTypeFloat128::createType();</span></a>
<a name="10716"><span class="lineNum">   10716 </span><span class="lineCov">         26 :   ROSE_ASSERT(result);</span></a>
<a name="10717"><span class="lineNum">   10717 </span><span class="lineCov">         26 :   return result;</span></a>
<a name="10718"><span class="lineNum">   10718 </span>            : }</a>
<a name="10719"><span class="lineNum">   10719 </span>            : </a>
<a name="10720"><span class="lineNum">   10720 </span><span class="lineCov">        198 : SgTypeSignedInt * SageBuilder::buildSignedIntType()</span></a>
<a name="10721"><span class="lineNum">   10721 </span>            : {</a>
<a name="10722"><span class="lineNum">   10722 </span><span class="lineCov">        198 :   SgTypeSignedInt * result = SgTypeSignedInt::createType();</span></a>
<a name="10723"><span class="lineNum">   10723 </span><span class="lineCov">        198 :   ROSE_ASSERT(result);</span></a>
<a name="10724"><span class="lineNum">   10724 </span><span class="lineCov">        198 :   return result;</span></a>
<a name="10725"><span class="lineNum">   10725 </span>            : }</a>
<a name="10726"><span class="lineNum">   10726 </span>            : </a>
<a name="10727"><span class="lineNum">   10727 </span><span class="lineCov">        320 : SgTypeUnsignedChar * SageBuilder::buildUnsignedCharType()</span></a>
<a name="10728"><span class="lineNum">   10728 </span>            : {</a>
<a name="10729"><span class="lineNum">   10729 </span><span class="lineCov">        320 :   SgTypeUnsignedChar * result = SgTypeUnsignedChar::createType();</span></a>
<a name="10730"><span class="lineNum">   10730 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10731"><span class="lineNum">   10731 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10732"><span class="lineNum">   10732 </span>            : }</a>
<a name="10733"><span class="lineNum">   10733 </span>            : </a>
<a name="10734"><span class="lineNum">   10734 </span><span class="lineCov">        198 : SgTypeSignedLong * SageBuilder::buildSignedLongType()</span></a>
<a name="10735"><span class="lineNum">   10735 </span>            : {</a>
<a name="10736"><span class="lineNum">   10736 </span><span class="lineCov">        198 :   SgTypeSignedLong * result = SgTypeSignedLong::createType();</span></a>
<a name="10737"><span class="lineNum">   10737 </span><span class="lineCov">        198 :   ROSE_ASSERT(result);</span></a>
<a name="10738"><span class="lineNum">   10738 </span><span class="lineCov">        198 :   return result;</span></a>
<a name="10739"><span class="lineNum">   10739 </span>            : }</a>
<a name="10740"><span class="lineNum">   10740 </span>            : </a>
<a name="10741"><span class="lineNum">   10741 </span><span class="lineCov">         10 : SgTypeSignedLongLong * SageBuilder::buildSignedLongLongType()</span></a>
<a name="10742"><span class="lineNum">   10742 </span>            : {</a>
<a name="10743"><span class="lineNum">   10743 </span><span class="lineCov">         10 :   SgTypeSignedLongLong * result = SgTypeSignedLongLong::createType();</span></a>
<a name="10744"><span class="lineNum">   10744 </span><span class="lineCov">         10 :   ROSE_ASSERT(result);</span></a>
<a name="10745"><span class="lineNum">   10745 </span><span class="lineCov">         10 :   return result;</span></a>
<a name="10746"><span class="lineNum">   10746 </span>            : }</a>
<a name="10747"><span class="lineNum">   10747 </span>            : </a>
<a name="10748"><span class="lineNum">   10748 </span>            : #if 1</a>
<a name="10749"><span class="lineNum">   10749 </span><span class="lineCov">         66 : SgTypeSigned128bitInteger* SageBuilder::buildSigned128bitIntegerType()</span></a>
<a name="10750"><span class="lineNum">   10750 </span>            : {</a>
<a name="10751"><span class="lineNum">   10751 </span><span class="lineCov">         66 :   SgTypeSigned128bitInteger* result = SgTypeSigned128bitInteger::createType();</span></a>
<a name="10752"><span class="lineNum">   10752 </span><span class="lineCov">         66 :   ROSE_ASSERT(result);</span></a>
<a name="10753"><span class="lineNum">   10753 </span><span class="lineCov">         66 :   return result;</span></a>
<a name="10754"><span class="lineNum">   10754 </span>            : }</a>
<a name="10755"><span class="lineNum">   10755 </span>            : </a>
<a name="10756"><span class="lineNum">   10756 </span><span class="lineCov">         10 : SgTypeUnsigned128bitInteger* SageBuilder::buildUnsigned128bitIntegerType()</span></a>
<a name="10757"><span class="lineNum">   10757 </span>            : {</a>
<a name="10758"><span class="lineNum">   10758 </span><span class="lineCov">         10 :   SgTypeUnsigned128bitInteger* result = SgTypeUnsigned128bitInteger::createType();</span></a>
<a name="10759"><span class="lineNum">   10759 </span><span class="lineCov">         10 :   ROSE_ASSERT(result);</span></a>
<a name="10760"><span class="lineNum">   10760 </span><span class="lineCov">         10 :   return result;</span></a>
<a name="10761"><span class="lineNum">   10761 </span>            : }</a>
<a name="10762"><span class="lineNum">   10762 </span>            : #endif</a>
<a name="10763"><span class="lineNum">   10763 </span>            : </a>
<a name="10764"><span class="lineNum">   10764 </span>            : </a>
<a name="10765"><span class="lineNum">   10765 </span><span class="lineCov">         13 : SgTypeWchar * SageBuilder::buildWcharType()</span></a>
<a name="10766"><span class="lineNum">   10766 </span>            : {</a>
<a name="10767"><span class="lineNum">   10767 </span><span class="lineCov">         13 :   SgTypeWchar * result =SgTypeWchar::createType();</span></a>
<a name="10768"><span class="lineNum">   10768 </span><span class="lineCov">         13 :   ROSE_ASSERT(result);</span></a>
<a name="10769"><span class="lineNum">   10769 </span><span class="lineCov">         13 :   return result;</span></a>
<a name="10770"><span class="lineNum">   10770 </span>            : }</a>
<a name="10771"><span class="lineNum">   10771 </span>            : </a>
<a name="10772"><span class="lineNum">   10772 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="10773"><span class="lineNum">   10773 </span><span class="lineCov">         10 : SgTypeChar16 * SageBuilder::buildChar16Type()</span></a>
<a name="10774"><span class="lineNum">   10774 </span>            : {</a>
<a name="10775"><span class="lineNum">   10775 </span><span class="lineCov">         10 :   SgTypeChar16 * result =SgTypeChar16::createType();</span></a>
<a name="10776"><span class="lineNum">   10776 </span><span class="lineCov">         10 :   ROSE_ASSERT(result);</span></a>
<a name="10777"><span class="lineNum">   10777 </span><span class="lineCov">         10 :   return result;</span></a>
<a name="10778"><span class="lineNum">   10778 </span>            : }</a>
<a name="10779"><span class="lineNum">   10779 </span>            : </a>
<a name="10780"><span class="lineNum">   10780 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="10781"><span class="lineNum">   10781 </span><span class="lineCov">         10 : SgTypeChar32 * SageBuilder::buildChar32Type()</span></a>
<a name="10782"><span class="lineNum">   10782 </span>            : {</a>
<a name="10783"><span class="lineNum">   10783 </span><span class="lineCov">         10 :   SgTypeChar32 * result =SgTypeChar32::createType();</span></a>
<a name="10784"><span class="lineNum">   10784 </span><span class="lineCov">         10 :   ROSE_ASSERT(result);</span></a>
<a name="10785"><span class="lineNum">   10785 </span><span class="lineCov">         10 :   return result;</span></a>
<a name="10786"><span class="lineNum">   10786 </span>            : }</a>
<a name="10787"><span class="lineNum">   10787 </span>            : </a>
<a name="10788"><span class="lineNum">   10788 </span>            : </a>
<a name="10789"><span class="lineNum">   10789 </span><span class="lineCov">        198 : SgTypeSignedChar * SageBuilder::buildSignedCharType()</span></a>
<a name="10790"><span class="lineNum">   10790 </span>            : {</a>
<a name="10791"><span class="lineNum">   10791 </span><span class="lineCov">        198 :   SgTypeSignedChar * result =SgTypeSignedChar::createType();</span></a>
<a name="10792"><span class="lineNum">   10792 </span><span class="lineCov">        198 :   ROSE_ASSERT(result);</span></a>
<a name="10793"><span class="lineNum">   10793 </span><span class="lineCov">        198 :   return result;</span></a>
<a name="10794"><span class="lineNum">   10794 </span>            : }</a>
<a name="10795"><span class="lineNum">   10795 </span>            : </a>
<a name="10796"><span class="lineNum">   10796 </span><span class="lineCov">        683 : SgTypeVoid * SageBuilder::buildVoidType()</span></a>
<a name="10797"><span class="lineNum">   10797 </span>            : {</a>
<a name="10798"><span class="lineNum">   10798 </span><span class="lineCov">        683 :   SgTypeVoid * result =SgTypeVoid::createType();</span></a>
<a name="10799"><span class="lineNum">   10799 </span><span class="lineCov">        683 :   ROSE_ASSERT(result);</span></a>
<a name="10800"><span class="lineNum">   10800 </span><span class="lineCov">        683 :   return result;</span></a>
<a name="10801"><span class="lineNum">   10801 </span>            : }</a>
<a name="10802"><span class="lineNum">   10802 </span>            : </a>
<a name="10803"><span class="lineNum">   10803 </span><span class="lineNoCov">          0 : SgTypeUnknown * SageBuilder::buildUnknownType()</span></a>
<a name="10804"><span class="lineNum">   10804 </span>            : {</a>
<a name="10805"><span class="lineNum">   10805 </span><span class="lineNoCov">          0 :   SgTypeUnknown * result =SgTypeUnknown::createType();</span></a>
<a name="10806"><span class="lineNum">   10806 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10807"><span class="lineNum">   10807 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10808"><span class="lineNum">   10808 </span>            : }</a>
<a name="10809"><span class="lineNum">   10809 </span>            : </a>
<a name="10810"><span class="lineNum">   10810 </span><span class="lineNoCov">          0 : SgAutoType * SageBuilder::buildAutoType()</span></a>
<a name="10811"><span class="lineNum">   10811 </span>            : {</a>
<a name="10812"><span class="lineNum">   10812 </span><span class="lineNoCov">          0 :   SgAutoType * result =new SgAutoType();</span></a>
<a name="10813"><span class="lineNum">   10813 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10814"><span class="lineNum">   10814 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10815"><span class="lineNum">   10815 </span>            : }</a>
<a name="10816"><span class="lineNum">   10816 </span>            : </a>
<a name="10817"><span class="lineNum">   10817 </span><span class="lineCov">        320 : SgTypeShort * SageBuilder::buildShortType()</span></a>
<a name="10818"><span class="lineNum">   10818 </span>            : {</a>
<a name="10819"><span class="lineNum">   10819 </span><span class="lineCov">        320 :   SgTypeShort * result =SgTypeShort::createType();</span></a>
<a name="10820"><span class="lineNum">   10820 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10821"><span class="lineNum">   10821 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10822"><span class="lineNum">   10822 </span>            : }</a>
<a name="10823"><span class="lineNum">   10823 </span>            : </a>
<a name="10824"><span class="lineNum">   10824 </span><span class="lineCov">        320 : SgTypeUnsignedShort * SageBuilder::buildUnsignedShortType()</span></a>
<a name="10825"><span class="lineNum">   10825 </span>            : {</a>
<a name="10826"><span class="lineNum">   10826 </span><span class="lineCov">        320 :   SgTypeUnsignedShort * result = SgTypeUnsignedShort::createType();</span></a>
<a name="10827"><span class="lineNum">   10827 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10828"><span class="lineNum">   10828 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10829"><span class="lineNum">   10829 </span>            : }</a>
<a name="10830"><span class="lineNum">   10830 </span>            : </a>
<a name="10831"><span class="lineNum">   10831 </span><span class="lineCov">        320 : SgTypeLong * SageBuilder::buildLongType()</span></a>
<a name="10832"><span class="lineNum">   10832 </span>            : {</a>
<a name="10833"><span class="lineNum">   10833 </span><span class="lineCov">        320 :   SgTypeLong * result =SgTypeLong::createType();</span></a>
<a name="10834"><span class="lineNum">   10834 </span><span class="lineCov">        320 :   ROSE_ASSERT(result);</span></a>
<a name="10835"><span class="lineNum">   10835 </span><span class="lineCov">        320 :   return result;</span></a>
<a name="10836"><span class="lineNum">   10836 </span>            : }</a>
<a name="10837"><span class="lineNum">   10837 </span>            : </a>
<a name="10838"><span class="lineNum">   10838 </span><span class="lineNoCov">          0 : SgTypeString * SageBuilder::buildStringType()</span></a>
<a name="10839"><span class="lineNum">   10839 </span>            :    {</a>
<a name="10840"><span class="lineNum">   10840 </span>            :   // DQ (8/17/2010): This function needs to use a different API to handle a literal</a>
<a name="10841"><span class="lineNum">   10841 </span>            :   // value for the string size (typical) or an expression for the string size (rare).</a>
<a name="10842"><span class="lineNum">   10842 </span>            :   // For now we will make it an error to call this function.</a>
<a name="10843"><span class="lineNum">   10843 </span>            : </a>
<a name="10844"><span class="lineNum">   10844 </span>            :   // SgTypeString * result =SgTypeString::createType();</a>
<a name="10845"><span class="lineNum">   10845 </span><span class="lineNoCov">          0 :      SgTypeString * result = NULL;</span></a>
<a name="10846"><span class="lineNum">   10846 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10847"><span class="lineNum">   10847 </span>            :      return result;</a>
<a name="10848"><span class="lineNum">   10848 </span>            :    }</a>
<a name="10849"><span class="lineNum">   10849 </span>            : </a>
<a name="10850"><span class="lineNum">   10850 </span>            : // SgTypeString * SageBuilder::buildStringType( SgExpression* stringLengthExpression, size_t stringLengthLiteral )</a>
<a name="10851"><span class="lineNum">   10851 </span><span class="lineCov">          1 : SgTypeString * SageBuilder::buildStringType( SgExpression* stringLengthExpression )</span></a>
<a name="10852"><span class="lineNum">   10852 </span>            :    {</a>
<a name="10853"><span class="lineNum">   10853 </span>            :   // DQ (8/21/2010): This is a new API for this function.  This type is specific to Fortran use,</a>
<a name="10854"><span class="lineNum">   10854 </span>            :   // in C/C++ a string is just an array of char. We could have a consistant handling between</a>
<a name="10855"><span class="lineNum">   10855 </span>            :   // C/C++ and Fortrna, but we have just corrected the implementation in Fortran to use this IR</a>
<a name="10856"><span class="lineNum">   10856 </span>            :   // node and we would have to add such support to C/C++.  The current implementation reflects</a>
<a name="10857"><span class="lineNum">   10857 </span>            :   // the grammar of the two languages.</a>
<a name="10858"><span class="lineNum">   10858 </span>            : </a>
<a name="10859"><span class="lineNum">   10859 </span>            :   // This function needs to use a different API to handle a literal</a>
<a name="10860"><span class="lineNum">   10860 </span>            :   // value for the string size (typical) or an expression for the string size (rare).</a>
<a name="10861"><span class="lineNum">   10861 </span>            : </a>
<a name="10862"><span class="lineNum">   10862 </span>            :   // SgTypeString* result = SgTypeString::createType(stringLengthExpression,stringLengthLiteral);</a>
<a name="10863"><span class="lineNum">   10863 </span><span class="lineCov">          1 :      SgTypeString* result = SgTypeString::createType(stringLengthExpression);</span></a>
<a name="10864"><span class="lineNum">   10864 </span><span class="lineCov">          1 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10865"><span class="lineNum">   10865 </span><span class="lineCov">          1 :      return result;</span></a>
<a name="10866"><span class="lineNum">   10866 </span>            :    }</a>
<a name="10867"><span class="lineNum">   10867 </span>            : </a>
<a name="10868"><span class="lineNum">   10868 </span>            : // CR (2/20/2020): Added builder functions for type size (kind) expressions for Fortran and Jovial</a>
<a name="10869"><span class="lineNum">   10869 </span><span class="lineCov">        452 : SgTypeInt * SageBuilder::buildIntType(SgExpression* kind_expr)</span></a>
<a name="10870"><span class="lineNum">   10870 </span>            : {</a>
<a name="10871"><span class="lineNum">   10871 </span><span class="lineCov">        452 :   SgTypeInt * result;</span></a>
<a name="10872"><span class="lineNum">   10872 </span><span class="lineCov">        452 :   if (kind_expr != NULL)</span></a>
<a name="10873"><span class="lineNum">   10873 </span>            :      {</a>
<a name="10874"><span class="lineNum">   10874 </span><span class="lineNoCov">          0 :        result = SgTypeInt::createType(0, kind_expr);</span></a>
<a name="10875"><span class="lineNum">   10875 </span><span class="lineNoCov">          0 :        kind_expr-&gt;set_parent(result);</span></a>
<a name="10876"><span class="lineNum">   10876 </span>            :      }</a>
<a name="10877"><span class="lineNum">   10877 </span>            :   else</a>
<a name="10878"><span class="lineNum">   10878 </span>            :      {</a>
<a name="10879"><span class="lineNum">   10879 </span><span class="lineCov">        452 :        result = SgTypeInt::createType();</span></a>
<a name="10880"><span class="lineNum">   10880 </span>            :      }</a>
<a name="10881"><span class="lineNum">   10881 </span><span class="lineCov">        452 :   ROSE_ASSERT(result);</span></a>
<a name="10882"><span class="lineNum">   10882 </span><span class="lineCov">        452 :   return result;</span></a>
<a name="10883"><span class="lineNum">   10883 </span>            : }</a>
<a name="10884"><span class="lineNum">   10884 </span><span class="lineCov">        452 : SgTypeInt * SageBuilder::buildIntType()</span></a>
<a name="10885"><span class="lineNum">   10885 </span>            : {</a>
<a name="10886"><span class="lineNum">   10886 </span><span class="lineCov">        452 :   return buildIntType(NULL);</span></a>
<a name="10887"><span class="lineNum">   10887 </span>            : }</a>
<a name="10888"><span class="lineNum">   10888 </span>            : </a>
<a name="10889"><span class="lineNum">   10889 </span><span class="lineCov">      11202 : SgTypeDouble * SageBuilder::buildDoubleType()</span></a>
<a name="10890"><span class="lineNum">   10890 </span>            : {</a>
<a name="10891"><span class="lineNum">   10891 </span><span class="lineCov">      11202 :   SgTypeDouble * result =SgTypeDouble::createType();</span></a>
<a name="10892"><span class="lineNum">   10892 </span><span class="lineCov">      11202 :   ROSE_ASSERT(result);</span></a>
<a name="10893"><span class="lineNum">   10893 </span><span class="lineCov">      11202 :   return result;</span></a>
<a name="10894"><span class="lineNum">   10894 </span>            : }</a>
<a name="10895"><span class="lineNum">   10895 </span>            : </a>
<a name="10896"><span class="lineNum">   10896 </span>            : // CR (3/6/2020): Added builder functions for type size (kind) expressions for Fortran and Jovial</a>
<a name="10897"><span class="lineNum">   10897 </span><span class="lineNoCov">          0 : SgTypeFloat * SageBuilder::buildFloatType(SgExpression* kind_expr)</span></a>
<a name="10898"><span class="lineNum">   10898 </span>            : {</a>
<a name="10899"><span class="lineNum">   10899 </span><span class="lineNoCov">          0 :   SgTypeFloat * result;</span></a>
<a name="10900"><span class="lineNum">   10900 </span><span class="lineNoCov">          0 :   if (kind_expr != NULL)</span></a>
<a name="10901"><span class="lineNum">   10901 </span>            :      {</a>
<a name="10902"><span class="lineNum">   10902 </span><span class="lineNoCov">          0 :        result = SgTypeFloat::createType(kind_expr);</span></a>
<a name="10903"><span class="lineNum">   10903 </span><span class="lineNoCov">          0 :        kind_expr-&gt;set_parent(result);</span></a>
<a name="10904"><span class="lineNum">   10904 </span>            :      }</a>
<a name="10905"><span class="lineNum">   10905 </span>            :   else</a>
<a name="10906"><span class="lineNum">   10906 </span>            :      {</a>
<a name="10907"><span class="lineNum">   10907 </span><span class="lineNoCov">          0 :        result = SgTypeFloat::createType();</span></a>
<a name="10908"><span class="lineNum">   10908 </span>            :      }</a>
<a name="10909"><span class="lineNum">   10909 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10910"><span class="lineNum">   10910 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10911"><span class="lineNum">   10911 </span>            : }</a>
<a name="10912"><span class="lineNum">   10912 </span><span class="lineCov">        647 : SgTypeFloat * SageBuilder::buildFloatType()</span></a>
<a name="10913"><span class="lineNum">   10913 </span>            : {</a>
<a name="10914"><span class="lineNum">   10914 </span><span class="lineCov">        647 :   SgTypeFloat * result =SgTypeFloat::createType();</span></a>
<a name="10915"><span class="lineNum">   10915 </span><span class="lineCov">        647 :   ROSE_ASSERT(result);</span></a>
<a name="10916"><span class="lineNum">   10916 </span><span class="lineCov">        647 :   return result;</span></a>
<a name="10917"><span class="lineNum">   10917 </span>            : }</a>
<a name="10918"><span class="lineNum">   10918 </span>            : </a>
<a name="10919"><span class="lineNum">   10919 </span>            : // CR (2/20/2020): Added builder for Jovial fixed type</a>
<a name="10920"><span class="lineNum">   10920 </span><span class="lineNoCov">          0 : SgTypeFixed* SageBuilder::buildFixedType(SgExpression* scale, SgExpression* fraction)</span></a>
<a name="10921"><span class="lineNum">   10921 </span>            : {</a>
<a name="10922"><span class="lineNum">   10922 </span><span class="lineNoCov">          0 :   SgTypeFixed * result = SgTypeFixed::createType(scale, fraction);</span></a>
<a name="10923"><span class="lineNum">   10923 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="10924"><span class="lineNum">   10924 </span>            : </a>
<a name="10925"><span class="lineNum">   10925 </span><span class="lineNoCov">          0 :   if (scale) scale-&gt;set_parent(result);</span></a>
<a name="10926"><span class="lineNum">   10926 </span><span class="lineNoCov">          0 :   if (fraction) fraction-&gt;set_parent(result);</span></a>
<a name="10927"><span class="lineNum">   10927 </span>            : </a>
<a name="10928"><span class="lineNum">   10928 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10929"><span class="lineNum">   10929 </span>            : }</a>
<a name="10930"><span class="lineNum">   10930 </span>            : </a>
<a name="10931"><span class="lineNum">   10931 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="10932"><span class="lineNum">   10932 </span>            : //! Build a modifier type.</a>
<a name="10933"><span class="lineNum">   10933 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildModifierType(SgType* base_type /* = NULL*/)</span></a>
<a name="10934"><span class="lineNum">   10934 </span>            :    {</a>
<a name="10935"><span class="lineNum">   10935 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="10936"><span class="lineNum">   10936 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="10937"><span class="lineNum">   10937 </span>            : </a>
<a name="10938"><span class="lineNum">   10938 </span>            :   // DQ (7/28/2010): New (similar) approach using type table support.</a>
<a name="10939"><span class="lineNum">   10939 </span><span class="lineNoCov">          0 :      SgModifierType* result = new SgModifierType(base_type);</span></a>
<a name="10940"><span class="lineNum">   10940 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="10941"><span class="lineNum">   10941 </span>            : </a>
<a name="10942"><span class="lineNum">   10942 </span>            :   // DQ (3/10/2018): Adding assertion.</a>
<a name="10943"><span class="lineNum">   10943 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != base_type);</span></a>
<a name="10944"><span class="lineNum">   10944 </span>            : </a>
<a name="10945"><span class="lineNum">   10945 </span>            : #if 0</a>
<a name="10946"><span class="lineNum">   10946 </span>            :      printf (&quot;In SageBuilder::buildModifierType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="10947"><span class="lineNum">   10947 </span>            : #endif</a>
<a name="10948"><span class="lineNum">   10948 </span>            : </a>
<a name="10949"><span class="lineNum">   10949 </span>            :   // DQ (7/28/2010): Insert result type into type table and return it, or</a>
<a name="10950"><span class="lineNum">   10950 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="10951"><span class="lineNum">   10951 </span>            :   // the type from type table.</a>
<a name="10952"><span class="lineNum">   10952 </span><span class="lineNoCov">          0 :      SgModifierType* result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="10953"><span class="lineNum">   10953 </span>            : </a>
<a name="10954"><span class="lineNum">   10954 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="10955"><span class="lineNum">   10955 </span>            :         {</a>
<a name="10956"><span class="lineNum">   10956 </span>            : #if 1</a>
<a name="10957"><span class="lineNum">   10957 </span>            :        // DQ (10/27/2015): This is the cause of a bug in the test2015_97.C (boost template problem).</a>
<a name="10958"><span class="lineNum">   10958 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: In SageBuilder::buildModifierType(): using previously build SgModifierType from global type table: result2 = %p = %s \n&quot;,result2,result2-&gt;class_name().c_str());</span></a>
<a name="10959"><span class="lineNum">   10959 </span>            : #endif</a>
<a name="10960"><span class="lineNum">   10960 </span>            : #if 0</a>
<a name="10961"><span class="lineNum">   10961 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="10962"><span class="lineNum">   10962 </span>            :           printf (&quot;(debugging) In SageBuilder::buildModifierType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="10963"><span class="lineNum">   10963 </span>            : #else</a>
<a name="10964"><span class="lineNum">   10964 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="10965"><span class="lineNum">   10965 </span>            : #endif</a>
<a name="10966"><span class="lineNum">   10966 </span>            :         }</a>
<a name="10967"><span class="lineNum">   10967 </span>            : </a>
<a name="10968"><span class="lineNum">   10968 </span>            :   // DQ (3/10/2018): Adding assertion.</a>
<a name="10969"><span class="lineNum">   10969 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result2 != base_type);</span></a>
<a name="10970"><span class="lineNum">   10970 </span>            : </a>
<a name="10971"><span class="lineNum">   10971 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="10972"><span class="lineNum">   10972 </span>            :    }</a>
<a name="10973"><span class="lineNum">   10973 </span>            : </a>
<a name="10974"><span class="lineNum">   10974 </span>            :   //! Build a constant type.</a>
<a name="10975"><span class="lineNum">   10975 </span><span class="lineCov">        104 : SgModifierType* SageBuilder::buildConstType(SgType* base_type /*=NULL*/)</span></a>
<a name="10976"><span class="lineNum">   10976 </span>            :    {</a>
<a name="10977"><span class="lineNum">   10977 </span>            : #if 0</a>
<a name="10978"><span class="lineNum">   10978 </span>            :   // DQ (7/28/2010): Old approach before type table support.</a>
<a name="10979"><span class="lineNum">   10979 </span>            :      SgModifierType *result = new SgModifierType(base_type);</a>
<a name="10980"><span class="lineNum">   10980 </span>            :      ROSE_ASSERT(result!=NULL);</a>
<a name="10981"><span class="lineNum">   10981 </span>            :      result-&gt;get_typeModifier().get_constVolatileModifier().setConst();</a>
<a name="10982"><span class="lineNum">   10982 </span>            :      return result;</a>
<a name="10983"><span class="lineNum">   10983 </span>            : #else</a>
<a name="10984"><span class="lineNum">   10984 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="10985"><span class="lineNum">   10985 </span><span class="lineCov">        104 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="10986"><span class="lineNum">   10986 </span>            : </a>
<a name="10987"><span class="lineNum">   10987 </span>            : #if 0 // Liao May 18, 2021</a>
<a name="10988"><span class="lineNum">   10988 </span>            :      if (isConstType(base_type))</a>
<a name="10989"><span class="lineNum">   10989 </span>            :      {</a>
<a name="10990"><span class="lineNum">   10990 </span>            :        cerr&lt;&lt;&quot;Error in SageBuilder::buildConstType(): base_type is already a const type!&quot;&lt;&lt;endl;</a>
<a name="10991"><span class="lineNum">   10991 </span>            :        ROSE_ASSERT(false);</a>
<a name="10992"><span class="lineNum">   10992 </span>            :      }</a>
<a name="10993"><span class="lineNum">   10993 </span>            : #endif</a>
<a name="10994"><span class="lineNum">   10994 </span>            :   // DQ (7/28/2010): New (similar) approach using type table support.</a>
<a name="10995"><span class="lineNum">   10995 </span><span class="lineCov">        104 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="10996"><span class="lineNum">   10996 </span><span class="lineCov">        104 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="10997"><span class="lineNum">   10997 </span><span class="lineCov">        104 :      result-&gt;get_typeModifier().get_constVolatileModifier().setConst();</span></a>
<a name="10998"><span class="lineNum">   10998 </span>            : </a>
<a name="10999"><span class="lineNum">   10999 </span>            : #if 0</a>
<a name="11000"><span class="lineNum">   11000 </span>            :      printf (&quot;In SageBuilder::buildConstType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11001"><span class="lineNum">   11001 </span>            : #endif</a>
<a name="11002"><span class="lineNum">   11002 </span>            : </a>
<a name="11003"><span class="lineNum">   11003 </span>            :   // DQ (7/28/2010): Insert result type into type table and return it, or</a>
<a name="11004"><span class="lineNum">   11004 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11005"><span class="lineNum">   11005 </span>            :   // the type from type table.</a>
<a name="11006"><span class="lineNum">   11006 </span><span class="lineCov">        104 :      SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11007"><span class="lineNum">   11007 </span>            : </a>
<a name="11008"><span class="lineNum">   11008 </span><span class="lineCov">        104 :      if (result != result2)</span></a>
<a name="11009"><span class="lineNum">   11009 </span>            :         {</a>
<a name="11010"><span class="lineNum">   11010 </span>            : #if 0</a>
<a name="11011"><span class="lineNum">   11011 </span>            :           printf (&quot;In SageBuilder::buildConstType(result = %p) using type from type table (result2 = %p) deleting result = %p (skipping delete) \n&quot;,result,result2,result);</a>
<a name="11012"><span class="lineNum">   11012 </span>            : #endif</a>
<a name="11013"><span class="lineNum">   11013 </span>            : </a>
<a name="11014"><span class="lineNum">   11014 </span>            : #if 0</a>
<a name="11015"><span class="lineNum">   11015 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11016"><span class="lineNum">   11016 </span>            :           printf (&quot;(debugging) In SageBuilder::buildConstType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11017"><span class="lineNum">   11017 </span>            : #else</a>
<a name="11018"><span class="lineNum">   11018 </span><span class="lineCov">         43 :           delete result;</span></a>
<a name="11019"><span class="lineNum">   11019 </span>            : #endif</a>
<a name="11020"><span class="lineNum">   11020 </span>            :         }</a>
<a name="11021"><span class="lineNum">   11021 </span>            : </a>
<a name="11022"><span class="lineNum">   11022 </span>            :   // DQ (3/10/2018): Adding assertion.</a>
<a name="11023"><span class="lineNum">   11023 </span><span class="lineCov">        104 :      ROSE_ASSERT(result2 != base_type);</span></a>
<a name="11024"><span class="lineNum">   11024 </span>            : </a>
<a name="11025"><span class="lineNum">   11025 </span><span class="lineCov">        104 :      return result2;</span></a>
<a name="11026"><span class="lineNum">   11026 </span>            : #endif</a>
<a name="11027"><span class="lineNum">   11027 </span>            :  }</a>
<a name="11028"><span class="lineNum">   11028 </span>            : </a>
<a name="11029"><span class="lineNum">   11029 </span>            : // DQ (8/27/2010): Added Fortran specific support for types based on kind expressions.</a>
<a name="11030"><span class="lineNum">   11030 </span>            : SgModifierType*</a>
<a name="11031"><span class="lineNum">   11031 </span><span class="lineNoCov">          0 : SageBuilder::buildFortranKindType(SgType* base_type, SgExpression* kindExpression )</span></a>
<a name="11032"><span class="lineNum">   11032 </span>            :    {</a>
<a name="11033"><span class="lineNum">   11033 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11034"><span class="lineNum">   11034 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11035"><span class="lineNum">   11035 </span>            : </a>
<a name="11036"><span class="lineNum">   11036 </span><span class="lineNoCov">          0 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11037"><span class="lineNum">   11037 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11038"><span class="lineNum">   11038 </span>            : </a>
<a name="11039"><span class="lineNum">   11039 </span><span class="lineNoCov">          0 :      result-&gt;set_type_kind(kindExpression);</span></a>
<a name="11040"><span class="lineNum">   11040 </span>            : </a>
<a name="11041"><span class="lineNum">   11041 </span>            : #if 0</a>
<a name="11042"><span class="lineNum">   11042 </span>            :      printf (&quot;In SageBuilder::buildFortranKindType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11043"><span class="lineNum">   11043 </span>            : #endif</a>
<a name="11044"><span class="lineNum">   11044 </span>            : </a>
<a name="11045"><span class="lineNum">   11045 </span><span class="lineNoCov">          0 :      SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11046"><span class="lineNum">   11046 </span>            : </a>
<a name="11047"><span class="lineNum">   11047 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="11048"><span class="lineNum">   11048 </span>            :         {</a>
<a name="11049"><span class="lineNum">   11049 </span>            : #if 0</a>
<a name="11050"><span class="lineNum">   11050 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11051"><span class="lineNum">   11051 </span>            :           printf (&quot;(debugging) In SageBuilder::buildFortranKindType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11052"><span class="lineNum">   11052 </span>            : #else</a>
<a name="11053"><span class="lineNum">   11053 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11054"><span class="lineNum">   11054 </span>            : #endif</a>
<a name="11055"><span class="lineNum">   11055 </span>            :         }</a>
<a name="11056"><span class="lineNum">   11056 </span>            : </a>
<a name="11057"><span class="lineNum">   11057 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11058"><span class="lineNum">   11058 </span>            :    }</a>
<a name="11059"><span class="lineNum">   11059 </span>            : </a>
<a name="11060"><span class="lineNum">   11060 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11061"><span class="lineNum">   11061 </span>            :   //! Build a volatile type.</a>
<a name="11062"><span class="lineNum">   11062 </span><span class="lineCov">          1 : SgModifierType* SageBuilder::buildVolatileType(SgType* base_type /*=NULL*/)</span></a>
<a name="11063"><span class="lineNum">   11063 </span>            :    {</a>
<a name="11064"><span class="lineNum">   11064 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11065"><span class="lineNum">   11065 </span><span class="lineCov">          1 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11066"><span class="lineNum">   11066 </span>            : </a>
<a name="11067"><span class="lineNum">   11067 </span><span class="lineCov">          1 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11068"><span class="lineNum">   11068 </span><span class="lineCov">          1 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11069"><span class="lineNum">   11069 </span>            : </a>
<a name="11070"><span class="lineNum">   11070 </span><span class="lineCov">          1 :      result-&gt;get_typeModifier().get_constVolatileModifier().setVolatile();</span></a>
<a name="11071"><span class="lineNum">   11071 </span>            : </a>
<a name="11072"><span class="lineNum">   11072 </span>            : #if 0</a>
<a name="11073"><span class="lineNum">   11073 </span>            :      printf (&quot;In SageBuilder::buildVolatileType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11074"><span class="lineNum">   11074 </span>            : #endif</a>
<a name="11075"><span class="lineNum">   11075 </span>            : </a>
<a name="11076"><span class="lineNum">   11076 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11077"><span class="lineNum">   11077 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11078"><span class="lineNum">   11078 </span>            :   // the type from type table.</a>
<a name="11079"><span class="lineNum">   11079 </span><span class="lineCov">          1 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11080"><span class="lineNum">   11080 </span><span class="lineCov">          1 :      if (result != result2)</span></a>
<a name="11081"><span class="lineNum">   11081 </span>            :         {</a>
<a name="11082"><span class="lineNum">   11082 </span>            : #if 0</a>
<a name="11083"><span class="lineNum">   11083 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11084"><span class="lineNum">   11084 </span>            :           printf (&quot;(debugging) In SageBuilder::buildVolatileType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11085"><span class="lineNum">   11085 </span>            : #else</a>
<a name="11086"><span class="lineNum">   11086 </span><span class="lineCov">          1 :           delete result;</span></a>
<a name="11087"><span class="lineNum">   11087 </span>            : #endif</a>
<a name="11088"><span class="lineNum">   11088 </span>            :         }</a>
<a name="11089"><span class="lineNum">   11089 </span>            : </a>
<a name="11090"><span class="lineNum">   11090 </span><span class="lineCov">          1 :      return result2;</span></a>
<a name="11091"><span class="lineNum">   11091 </span>            :    }</a>
<a name="11092"><span class="lineNum">   11092 </span>            : </a>
<a name="11093"><span class="lineNum">   11093 </span>            : // DQ (1/19/2019): Adding support for const volatile type (both together as another value).</a>
<a name="11094"><span class="lineNum">   11094 </span>            : //! Build a const volatile type.</a>
<a name="11095"><span class="lineNum">   11095 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildConstVolatileType(SgType* base_type /*=NULL*/)</span></a>
<a name="11096"><span class="lineNum">   11096 </span>            :    {</a>
<a name="11097"><span class="lineNum">   11097 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11098"><span class="lineNum">   11098 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11099"><span class="lineNum">   11099 </span>            : </a>
<a name="11100"><span class="lineNum">   11100 </span><span class="lineNoCov">          0 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11101"><span class="lineNum">   11101 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11102"><span class="lineNum">   11102 </span>            : </a>
<a name="11103"><span class="lineNum">   11103 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_constVolatileModifier().setConst();</span></a>
<a name="11104"><span class="lineNum">   11104 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_constVolatileModifier().setVolatile();</span></a>
<a name="11105"><span class="lineNum">   11105 </span>            : </a>
<a name="11106"><span class="lineNum">   11106 </span>            : #if 1</a>
<a name="11107"><span class="lineNum">   11107 </span><span class="lineNoCov">          0 :      printf (&quot;In SageBuilder::buildConstVolatileType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</span></a>
<a name="11108"><span class="lineNum">   11108 </span>            : #endif</a>
<a name="11109"><span class="lineNum">   11109 </span>            : </a>
<a name="11110"><span class="lineNum">   11110 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11111"><span class="lineNum">   11111 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11112"><span class="lineNum">   11112 </span>            :   // the type from type table.</a>
<a name="11113"><span class="lineNum">   11113 </span><span class="lineNoCov">          0 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11114"><span class="lineNum">   11114 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="11115"><span class="lineNum">   11115 </span>            :         {</a>
<a name="11116"><span class="lineNum">   11116 </span>            : #if 0</a>
<a name="11117"><span class="lineNum">   11117 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11118"><span class="lineNum">   11118 </span>            :           printf (&quot;(debugging) In SageBuilder::buildConstVolatileType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11119"><span class="lineNum">   11119 </span>            : #else</a>
<a name="11120"><span class="lineNum">   11120 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11121"><span class="lineNum">   11121 </span>            : #endif</a>
<a name="11122"><span class="lineNum">   11122 </span>            :         }</a>
<a name="11123"><span class="lineNum">   11123 </span>            : </a>
<a name="11124"><span class="lineNum">   11124 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11125"><span class="lineNum">   11125 </span>            :    }</a>
<a name="11126"><span class="lineNum">   11126 </span>            : </a>
<a name="11127"><span class="lineNum">   11127 </span>            : string</a>
<a name="11128"><span class="lineNum">   11128 </span><span class="lineNoCov">          0 : generate_type_list (SgType* type)</span></a>
<a name="11129"><span class="lineNum">   11129 </span>            :    {</a>
<a name="11130"><span class="lineNum">   11130 </span>            :   // This function generates a list of types for each level of the type structure.</a>
<a name="11131"><span class="lineNum">   11131 </span><span class="lineNoCov">          0 :      string returnString;</span></a>
<a name="11132"><span class="lineNum">   11132 </span>            : </a>
<a name="11133"><span class="lineNum">   11133 </span><span class="lineNoCov">          0 :      unsigned char bit_array = (SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_POINTER_TYPE | SgType::STRIP_ARRAY_TYPE | SgType::STRIP_TYPEDEF_TYPE);</span></a>
<a name="11134"><span class="lineNum">   11134 </span>            : </a>
<a name="11135"><span class="lineNum">   11135 </span><span class="lineNoCov">          0 :      SgType* currentType = type;</span></a>
<a name="11136"><span class="lineNum">   11136 </span>            : </a>
<a name="11137"><span class="lineNum">   11137 </span><span class="lineNoCov">          0 :      SgModifierType*        modType     = NULL;</span></a>
<a name="11138"><span class="lineNum">   11138 </span><span class="lineNoCov">          0 :      SgPointerType*         pointType   = NULL;</span></a>
<a name="11139"><span class="lineNum">   11139 </span><span class="lineNoCov">          0 :      SgReferenceType*       refType     = NULL;</span></a>
<a name="11140"><span class="lineNum">   11140 </span><span class="lineNoCov">          0 :      SgRvalueReferenceType* rRefType     = NULL;</span></a>
<a name="11141"><span class="lineNum">   11141 </span><span class="lineNoCov">          0 :      SgArrayType*           arrayType   = NULL;</span></a>
<a name="11142"><span class="lineNum">   11142 </span><span class="lineNoCov">          0 :      SgTypedefType*         typedefType = NULL;</span></a>
<a name="11143"><span class="lineNum">   11143 </span>            : </a>
<a name="11144"><span class="lineNum">   11144 </span><span class="lineNoCov">          0 :      while (currentType != NULL)</span></a>
<a name="11145"><span class="lineNum">   11145 </span>            :         {</a>
<a name="11146"><span class="lineNum">   11146 </span><span class="lineNoCov">          0 :           returnString += currentType-&gt;class_name();</span></a>
<a name="11147"><span class="lineNum">   11147 </span>            : #if 0</a>
<a name="11148"><span class="lineNum">   11148 </span>            :           printf (&quot;In generate_type_list(): returnString = %s \n&quot;,returnString.c_str());</a>
<a name="11149"><span class="lineNum">   11149 </span>            : #endif</a>
<a name="11150"><span class="lineNum">   11150 </span><span class="lineNoCov">          0 :           if ( (bit_array &amp; SgType::STRIP_MODIFIER_TYPE) &amp;&amp; (modType = isSgModifierType(currentType)) )</span></a>
<a name="11151"><span class="lineNum">   11151 </span>            :              {</a>
<a name="11152"><span class="lineNum">   11152 </span><span class="lineNoCov">          0 :                currentType = modType-&gt;get_base_type();</span></a>
<a name="11153"><span class="lineNum">   11153 </span>            :              }</a>
<a name="11154"><span class="lineNum">   11154 </span><span class="lineNoCov">          0 :           else if ( (bit_array &amp; SgType::STRIP_REFERENCE_TYPE) &amp;&amp;  (refType = isSgReferenceType(currentType)) )</span></a>
<a name="11155"><span class="lineNum">   11155 </span>            :              {</a>
<a name="11156"><span class="lineNum">   11156 </span><span class="lineNoCov">          0 :                currentType = refType-&gt;get_base_type();</span></a>
<a name="11157"><span class="lineNum">   11157 </span>            :              }</a>
<a name="11158"><span class="lineNum">   11158 </span><span class="lineNoCov">          0 :           else if ( (bit_array &amp; SgType::STRIP_RVALUE_REFERENCE_TYPE) &amp;&amp;  (rRefType = isSgRvalueReferenceType(currentType)) )</span></a>
<a name="11159"><span class="lineNum">   11159 </span>            :              {</a>
<a name="11160"><span class="lineNum">   11160 </span><span class="lineNoCov">          0 :                currentType = rRefType-&gt;get_base_type();</span></a>
<a name="11161"><span class="lineNum">   11161 </span>            :              }</a>
<a name="11162"><span class="lineNum">   11162 </span><span class="lineNoCov">          0 :           else if ( (bit_array &amp; SgType::STRIP_POINTER_TYPE) &amp;&amp; (pointType = isSgPointerType(currentType)) )</span></a>
<a name="11163"><span class="lineNum">   11163 </span>            :              {</a>
<a name="11164"><span class="lineNum">   11164 </span><span class="lineNoCov">          0 :                currentType = pointType-&gt;get_base_type();</span></a>
<a name="11165"><span class="lineNum">   11165 </span>            :              }</a>
<a name="11166"><span class="lineNum">   11166 </span><span class="lineNoCov">          0 :           else if ( (bit_array &amp; SgType::STRIP_ARRAY_TYPE) &amp;&amp; (arrayType = isSgArrayType(currentType)) )</span></a>
<a name="11167"><span class="lineNum">   11167 </span>            :              {</a>
<a name="11168"><span class="lineNum">   11168 </span><span class="lineNoCov">          0 :                currentType = arrayType-&gt;get_base_type();</span></a>
<a name="11169"><span class="lineNum">   11169 </span>            :              }</a>
<a name="11170"><span class="lineNum">   11170 </span><span class="lineNoCov">          0 :           else  if ( (bit_array &amp; SgType::STRIP_TYPEDEF_TYPE) &amp;&amp; (typedefType = isSgTypedefType(currentType)) )</span></a>
<a name="11171"><span class="lineNum">   11171 </span>            :              {</a>
<a name="11172"><span class="lineNum">   11172 </span><span class="lineNoCov">          0 :                currentType = typedefType-&gt;get_base_type();</span></a>
<a name="11173"><span class="lineNum">   11173 </span>            :              }</a>
<a name="11174"><span class="lineNum">   11174 </span>            :           else</a>
<a name="11175"><span class="lineNum">   11175 </span>            :              {</a>
<a name="11176"><span class="lineNum">   11176 </span>            :                break;</a>
<a name="11177"><span class="lineNum">   11177 </span>            :              }</a>
<a name="11178"><span class="lineNum">   11178 </span>            : </a>
<a name="11179"><span class="lineNum">   11179 </span><span class="lineNoCov">          0 :           if (type != NULL)</span></a>
<a name="11180"><span class="lineNum">   11180 </span><span class="lineNoCov">          0 :                returnString += &quot; , &quot;;</span></a>
<a name="11181"><span class="lineNum">   11181 </span>            :         }</a>
<a name="11182"><span class="lineNum">   11182 </span>            : </a>
<a name="11183"><span class="lineNum">   11183 </span><span class="lineNoCov">          0 :      return returnString;</span></a>
<a name="11184"><span class="lineNum">   11184 </span>            :    }</a>
<a name="11185"><span class="lineNum">   11185 </span>            : </a>
<a name="11186"><span class="lineNum">   11186 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11187"><span class="lineNum">   11187 </span>            :   //! Build a restrict type.</a>
<a name="11188"><span class="lineNum">   11188 </span><span class="lineCov">          1 : SgModifierType* SageBuilder::buildRestrictType(SgType* base_type)</span></a>
<a name="11189"><span class="lineNum">   11189 </span>            :    {</a>
<a name="11190"><span class="lineNum">   11190 </span><span class="lineCov">          1 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11191"><span class="lineNum">   11191 </span>            : </a>
<a name="11192"><span class="lineNum">   11192 </span>            :   // DQ (1/30/2014): We need to include typedefs here as well (see test2014_77.c).</a>
<a name="11193"><span class="lineNum">   11193 </span>            :   // DQ (9/28/2012): Added that the base type could be an array (see test2012_03.c (C test code)).</a>
<a name="11194"><span class="lineNum">   11194 </span>            :   // if (!isSgPointerType(base_type) &amp;&amp; !isSgReferenceType(base_type))</a>
<a name="11195"><span class="lineNum">   11195 </span>            :   // if (!isSgPointerType(base_type) &amp;&amp; !isSgReferenceType(base_type) &amp;&amp; !isSgArrayType(base_type))</a>
<a name="11196"><span class="lineNum">   11196 </span>            :   // if (!isSgPointerType(base_type) &amp;&amp; !isSgReferenceType(base_type) &amp;&amp; !isSgArrayType(base_type) &amp;&amp; !isSgTypedefType(base_type))</a>
<a name="11197"><span class="lineNum">   11197 </span><span class="lineCov">          1 :      if (!isSgPointerType(base_type) &amp;&amp; !isSgReferenceType(base_type) &amp;&amp; !isSgArrayType(base_type) &amp;&amp; !isSgTypedefType(base_type) &amp;&amp; !isSgModifierType(base_type))</span></a>
<a name="11198"><span class="lineNum">   11198 </span>            :         {</a>
<a name="11199"><span class="lineNum">   11199 </span><span class="lineNoCov">          0 :           printf(&quot;ERROR: Base type of restrict type must be on a pointer or reference or array or typedef type: base_type = %p = %s \n&quot;,base_type,base_type-&gt;class_name().c_str());</span></a>
<a name="11200"><span class="lineNum">   11200 </span><span class="lineNoCov">          0 :           printf (&quot;  --- generate_type_list() = %s \n&quot;,generate_type_list(base_type).c_str());</span></a>
<a name="11201"><span class="lineNum">   11201 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="11202"><span class="lineNum">   11202 </span>            :         }</a>
<a name="11203"><span class="lineNum">   11203 </span>            : </a>
<a name="11204"><span class="lineNum">   11204 </span><span class="lineCov">          1 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11205"><span class="lineNum">   11205 </span><span class="lineCov">          1 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11206"><span class="lineNum">   11206 </span>            : </a>
<a name="11207"><span class="lineNum">   11207 </span><span class="lineCov">          1 :      result-&gt;get_typeModifier().setRestrict();</span></a>
<a name="11208"><span class="lineNum">   11208 </span>            : </a>
<a name="11209"><span class="lineNum">   11209 </span>            : #if 0</a>
<a name="11210"><span class="lineNum">   11210 </span>            :      printf (&quot;In SageBuilder::buildRestrictType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11211"><span class="lineNum">   11211 </span>            : #endif</a>
<a name="11212"><span class="lineNum">   11212 </span>            : </a>
<a name="11213"><span class="lineNum">   11213 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11214"><span class="lineNum">   11214 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11215"><span class="lineNum">   11215 </span>            :   // the type from type table.</a>
<a name="11216"><span class="lineNum">   11216 </span><span class="lineCov">          1 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11217"><span class="lineNum">   11217 </span><span class="lineCov">          1 :      if (result != result2)</span></a>
<a name="11218"><span class="lineNum">   11218 </span>            :         {</a>
<a name="11219"><span class="lineNum">   11219 </span>            : #if 0</a>
<a name="11220"><span class="lineNum">   11220 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11221"><span class="lineNum">   11221 </span>            :           printf (&quot;(debugging) In SageBuilder::buildRestrictType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11222"><span class="lineNum">   11222 </span>            : #else</a>
<a name="11223"><span class="lineNum">   11223 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11224"><span class="lineNum">   11224 </span>            : #endif</a>
<a name="11225"><span class="lineNum">   11225 </span>            :         }</a>
<a name="11226"><span class="lineNum">   11226 </span>            : </a>
<a name="11227"><span class="lineNum">   11227 </span><span class="lineCov">          1 :      return result2;</span></a>
<a name="11228"><span class="lineNum">   11228 </span>            :    }</a>
<a name="11229"><span class="lineNum">   11229 </span>            : </a>
<a name="11230"><span class="lineNum">   11230 </span>            : </a>
<a name="11231"><span class="lineNum">   11231 </span>            : // PP (7/7/21): model builder function after buildRestrictType</a>
<a name="11232"><span class="lineNum">   11232 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildAliasedType(SgType* base_type)</span></a>
<a name="11233"><span class="lineNum">   11233 </span>            :    {</a>
<a name="11234"><span class="lineNum">   11234 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11235"><span class="lineNum">   11235 </span>            : </a>
<a name="11236"><span class="lineNum">   11236 </span><span class="lineNoCov">          0 :      SgModifierType* result = new SgModifierType(base_type);</span></a>
<a name="11237"><span class="lineNum">   11237 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11238"><span class="lineNum">   11238 </span>            : </a>
<a name="11239"><span class="lineNum">   11239 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().setAliased();</span></a>
<a name="11240"><span class="lineNum">   11240 </span>            : </a>
<a name="11241"><span class="lineNum">   11241 </span><span class="lineNoCov">          0 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11242"><span class="lineNum">   11242 </span><span class="lineNoCov">          0 :      if (result != result2) delete result;</span></a>
<a name="11243"><span class="lineNum">   11243 </span>            : </a>
<a name="11244"><span class="lineNum">   11244 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11245"><span class="lineNum">   11245 </span>            :    }</a>
<a name="11246"><span class="lineNum">   11246 </span>            : </a>
<a name="11247"><span class="lineNum">   11247 </span>            : </a>
<a name="11248"><span class="lineNum">   11248 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11249"><span class="lineNum">   11249 </span>            :   //! Build a UPC strict type.</a>
<a name="11250"><span class="lineNum">   11250 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcStrictType(SgType* base_type /*=NULL*/)</span></a>
<a name="11251"><span class="lineNum">   11251 </span>            :    {</a>
<a name="11252"><span class="lineNum">   11252 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11253"><span class="lineNum">   11253 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11254"><span class="lineNum">   11254 </span>            : </a>
<a name="11255"><span class="lineNum">   11255 </span><span class="lineNoCov">          0 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11256"><span class="lineNum">   11256 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11257"><span class="lineNum">   11257 </span>            : </a>
<a name="11258"><span class="lineNum">   11258 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_modifier(SgUPC_AccessModifier::e_upc_strict);</span></a>
<a name="11259"><span class="lineNum">   11259 </span>            : </a>
<a name="11260"><span class="lineNum">   11260 </span>            : #if 0</a>
<a name="11261"><span class="lineNum">   11261 </span>            :      printf (&quot;In SageBuilder::buildUpcStrictType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11262"><span class="lineNum">   11262 </span>            : #endif</a>
<a name="11263"><span class="lineNum">   11263 </span>            : </a>
<a name="11264"><span class="lineNum">   11264 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11265"><span class="lineNum">   11265 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11266"><span class="lineNum">   11266 </span>            :   // the type from type table.</a>
<a name="11267"><span class="lineNum">   11267 </span><span class="lineNoCov">          0 :      SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11268"><span class="lineNum">   11268 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="11269"><span class="lineNum">   11269 </span>            :         {</a>
<a name="11270"><span class="lineNum">   11270 </span>            : #if 0</a>
<a name="11271"><span class="lineNum">   11271 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11272"><span class="lineNum">   11272 </span>            :           printf (&quot;(debugging) In SageBuilder::buildUpcStrictType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11273"><span class="lineNum">   11273 </span>            : #else</a>
<a name="11274"><span class="lineNum">   11274 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11275"><span class="lineNum">   11275 </span>            : #endif</a>
<a name="11276"><span class="lineNum">   11276 </span>            :         }</a>
<a name="11277"><span class="lineNum">   11277 </span>            : </a>
<a name="11278"><span class="lineNum">   11278 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11279"><span class="lineNum">   11279 </span>            :    }</a>
<a name="11280"><span class="lineNum">   11280 </span>            : </a>
<a name="11281"><span class="lineNum">   11281 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11282"><span class="lineNum">   11282 </span>            :   //! Build a UPC relaxed type.</a>
<a name="11283"><span class="lineNum">   11283 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcRelaxedType(SgType* base_type /*=NULL*/)</span></a>
<a name="11284"><span class="lineNum">   11284 </span>            :    {</a>
<a name="11285"><span class="lineNum">   11285 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11286"><span class="lineNum">   11286 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11287"><span class="lineNum">   11287 </span>            : </a>
<a name="11288"><span class="lineNum">   11288 </span><span class="lineNoCov">          0 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11289"><span class="lineNum">   11289 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11290"><span class="lineNum">   11290 </span>            : </a>
<a name="11291"><span class="lineNum">   11291 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_modifier(SgUPC_AccessModifier::e_upc_relaxed);</span></a>
<a name="11292"><span class="lineNum">   11292 </span>            : </a>
<a name="11293"><span class="lineNum">   11293 </span>            : #if 0</a>
<a name="11294"><span class="lineNum">   11294 </span>            :      printf (&quot;In SageBuilder::buildUpcRelaxedType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11295"><span class="lineNum">   11295 </span>            : #endif</a>
<a name="11296"><span class="lineNum">   11296 </span>            : </a>
<a name="11297"><span class="lineNum">   11297 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11298"><span class="lineNum">   11298 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11299"><span class="lineNum">   11299 </span>            :   // the type from type table.</a>
<a name="11300"><span class="lineNum">   11300 </span><span class="lineNoCov">          0 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11301"><span class="lineNum">   11301 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="11302"><span class="lineNum">   11302 </span>            :         {</a>
<a name="11303"><span class="lineNum">   11303 </span>            : #if 0</a>
<a name="11304"><span class="lineNum">   11304 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11305"><span class="lineNum">   11305 </span>            :           printf (&quot;(debugging) In SageBuilder::buildUpcRelaxedType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11306"><span class="lineNum">   11306 </span>            : #else</a>
<a name="11307"><span class="lineNum">   11307 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11308"><span class="lineNum">   11308 </span>            : #endif</a>
<a name="11309"><span class="lineNum">   11309 </span>            :         }</a>
<a name="11310"><span class="lineNum">   11310 </span>            : </a>
<a name="11311"><span class="lineNum">   11311 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11312"><span class="lineNum">   11312 </span>            :    }</a>
<a name="11313"><span class="lineNum">   11313 </span>            : </a>
<a name="11314"><span class="lineNum">   11314 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11315"><span class="lineNum">   11315 </span>            :   //! Build a UPC shared type.</a>
<a name="11316"><span class="lineNum">   11316 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcSharedType(SgType* base_type /*=NULL*/, long layout /*= -1*/)</span></a>
<a name="11317"><span class="lineNum">   11317 </span>            :    {</a>
<a name="11318"><span class="lineNum">   11318 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11319"><span class="lineNum">   11319 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11320"><span class="lineNum">   11320 </span>            : </a>
<a name="11321"><span class="lineNum">   11321 </span><span class="lineNoCov">          0 :      SgModifierType *result = new SgModifierType(base_type);</span></a>
<a name="11322"><span class="lineNum">   11322 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11323"><span class="lineNum">   11323 </span>            : </a>
<a name="11324"><span class="lineNum">   11324 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_isShared(true);</span></a>
<a name="11325"><span class="lineNum">   11325 </span>            : </a>
<a name="11326"><span class="lineNum">   11326 </span>            :   // DQ (7/29/2010): Modified to use new input parameter.</a>
<a name="11327"><span class="lineNum">   11327 </span>            :   // result-&gt;get_typeModifier().get_upcModifier().set_layout(-1); // No layout (&quot;shared&quot; without a block size)</a>
<a name="11328"><span class="lineNum">   11328 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_layout(layout); // No layout (&quot;shared&quot; without a block size)</span></a>
<a name="11329"><span class="lineNum">   11329 </span>            : </a>
<a name="11330"><span class="lineNum">   11330 </span>            : #if 0</a>
<a name="11331"><span class="lineNum">   11331 </span>            :      printf (&quot;In SageBuilder::buildUpcSharedType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11332"><span class="lineNum">   11332 </span>            : #endif</a>
<a name="11333"><span class="lineNum">   11333 </span>            : </a>
<a name="11334"><span class="lineNum">   11334 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11335"><span class="lineNum">   11335 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11336"><span class="lineNum">   11336 </span>            :   // the type from type table.</a>
<a name="11337"><span class="lineNum">   11337 </span><span class="lineNoCov">          0 :      SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11338"><span class="lineNum">   11338 </span><span class="lineNoCov">          0 :      if (result != result2)</span></a>
<a name="11339"><span class="lineNum">   11339 </span>            :         {</a>
<a name="11340"><span class="lineNum">   11340 </span>            : #if 0</a>
<a name="11341"><span class="lineNum">   11341 </span>            :        // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.</a>
<a name="11342"><span class="lineNum">   11342 </span>            :           printf (&quot;(debugging) In SageBuilder::buildUpcSharedType(): Skipping delete of SgModifierType = %p = %s \n&quot;,result,result-&gt;class_name().c_str());</a>
<a name="11343"><span class="lineNum">   11343 </span>            : #else</a>
<a name="11344"><span class="lineNum">   11344 </span><span class="lineNoCov">          0 :           delete result;</span></a>
<a name="11345"><span class="lineNum">   11345 </span>            : #endif</a>
<a name="11346"><span class="lineNum">   11346 </span>            :         }</a>
<a name="11347"><span class="lineNum">   11347 </span>            : </a>
<a name="11348"><span class="lineNum">   11348 </span><span class="lineNoCov">          0 :      return result2;</span></a>
<a name="11349"><span class="lineNum">   11349 </span>            :    }</a>
<a name="11350"><span class="lineNum">   11350 </span>            : </a>
<a name="11351"><span class="lineNum">   11351 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11352"><span class="lineNum">   11352 </span>            :   //! Build a UPC shared[] type.</a>
<a name="11353"><span class="lineNum">   11353 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcBlockIndefiniteType(SgType* base_type /*=NULL*/)</span></a>
<a name="11354"><span class="lineNum">   11354 </span>            :    {</a>
<a name="11355"><span class="lineNum">   11355 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11356"><span class="lineNum">   11356 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11357"><span class="lineNum">   11357 </span>            : </a>
<a name="11358"><span class="lineNum">   11358 </span><span class="lineNoCov">          0 :      SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));</span></a>
<a name="11359"><span class="lineNum">   11359 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11360"><span class="lineNum">   11360 </span>            : </a>
<a name="11361"><span class="lineNum">   11361 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_layout(0); // [] layout</span></a>
<a name="11362"><span class="lineNum">   11362 </span>            : </a>
<a name="11363"><span class="lineNum">   11363 </span>            : #if 0</a>
<a name="11364"><span class="lineNum">   11364 </span>            :      printf (&quot;In SageBuilder::buildUpcBlockIndefiniteType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11365"><span class="lineNum">   11365 </span>            : #endif</a>
<a name="11366"><span class="lineNum">   11366 </span>            : </a>
<a name="11367"><span class="lineNum">   11367 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11368"><span class="lineNum">   11368 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11369"><span class="lineNum">   11369 </span>            :   // the type from type table.</a>
<a name="11370"><span class="lineNum">   11370 </span><span class="lineNoCov">          0 :      result = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11371"><span class="lineNum">   11371 </span>            : </a>
<a name="11372"><span class="lineNum">   11372 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11373"><span class="lineNum">   11373 </span>            :    }</a>
<a name="11374"><span class="lineNum">   11374 </span>            : </a>
<a name="11375"><span class="lineNum">   11375 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11376"><span class="lineNum">   11376 </span>            :   //! Build a UPC shared[*] type.</a>
<a name="11377"><span class="lineNum">   11377 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcBlockStarType(SgType* base_type /*=NULL*/)</span></a>
<a name="11378"><span class="lineNum">   11378 </span>            :    {</a>
<a name="11379"><span class="lineNum">   11379 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11380"><span class="lineNum">   11380 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11381"><span class="lineNum">   11381 </span>            : </a>
<a name="11382"><span class="lineNum">   11382 </span><span class="lineNoCov">          0 :      SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));</span></a>
<a name="11383"><span class="lineNum">   11383 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11384"><span class="lineNum">   11384 </span>            : </a>
<a name="11385"><span class="lineNum">   11385 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_layout(-2); // [*] layout</span></a>
<a name="11386"><span class="lineNum">   11386 </span>            : </a>
<a name="11387"><span class="lineNum">   11387 </span>            : #if 0</a>
<a name="11388"><span class="lineNum">   11388 </span>            :      printf (&quot;In SageBuilder::buildUpcBlockStarType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11389"><span class="lineNum">   11389 </span>            : #endif</a>
<a name="11390"><span class="lineNum">   11390 </span>            : </a>
<a name="11391"><span class="lineNum">   11391 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11392"><span class="lineNum">   11392 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11393"><span class="lineNum">   11393 </span>            :   // the type from type table.</a>
<a name="11394"><span class="lineNum">   11394 </span><span class="lineNoCov">          0 :      result = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11395"><span class="lineNum">   11395 </span>            : </a>
<a name="11396"><span class="lineNum">   11396 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11397"><span class="lineNum">   11397 </span>            :    }</a>
<a name="11398"><span class="lineNum">   11398 </span>            : </a>
<a name="11399"><span class="lineNum">   11399 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType</a>
<a name="11400"><span class="lineNum">   11400 </span>            :   //! Build a UPC shared[n] type.</a>
<a name="11401"><span class="lineNum">   11401 </span><span class="lineNoCov">          0 : SgModifierType* SageBuilder::buildUpcBlockNumberType(SgType* base_type, long block_factor)</span></a>
<a name="11402"><span class="lineNum">   11402 </span>            :    {</a>
<a name="11403"><span class="lineNum">   11403 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11404"><span class="lineNum">   11404 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11405"><span class="lineNum">   11405 </span>            : </a>
<a name="11406"><span class="lineNum">   11406 </span><span class="lineNoCov">          0 :      SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));</span></a>
<a name="11407"><span class="lineNum">   11407 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result!=NULL);</span></a>
<a name="11408"><span class="lineNum">   11408 </span>            : </a>
<a name="11409"><span class="lineNum">   11409 </span><span class="lineNoCov">          0 :      result-&gt;get_typeModifier().get_upcModifier().set_layout(block_factor); // [block_factor] layout</span></a>
<a name="11410"><span class="lineNum">   11410 </span>            : </a>
<a name="11411"><span class="lineNum">   11411 </span>            : #if 0</a>
<a name="11412"><span class="lineNum">   11412 </span>            :      printf (&quot;In SageBuilder::buildUpcBlockNumberType(): Building a SgModifierType: result = %p base_type = %p = %s \n&quot;,result,base_type,base_type-&gt;class_name().c_str());</a>
<a name="11413"><span class="lineNum">   11413 </span>            : #endif</a>
<a name="11414"><span class="lineNum">   11414 </span>            : </a>
<a name="11415"><span class="lineNum">   11415 </span>            :   // DQ (7/29/2010): Insert result type into type table and return it, or</a>
<a name="11416"><span class="lineNum">   11416 </span>            :   // replace the result type, if already available in the type table, with</a>
<a name="11417"><span class="lineNum">   11417 </span>            :   // the type from type table.</a>
<a name="11418"><span class="lineNum">   11418 </span><span class="lineNoCov">          0 :      result = SgModifierType::insertModifierTypeIntoTypeTable(result);</span></a>
<a name="11419"><span class="lineNum">   11419 </span>            : </a>
<a name="11420"><span class="lineNum">   11420 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11421"><span class="lineNum">   11421 </span>            :    }</a>
<a name="11422"><span class="lineNum">   11422 </span>            : </a>
<a name="11423"><span class="lineNum">   11423 </span>            : </a>
<a name="11424"><span class="lineNum">   11424 </span>            : </a>
<a name="11425"><span class="lineNum">   11425 </span>            :   //! Build a complex type.</a>
<a name="11426"><span class="lineNum">   11426 </span><span class="lineCov">        973 : SgTypeComplex* SageBuilder::buildComplexType(SgType* base_type /*=NULL*/)</span></a>
<a name="11427"><span class="lineNum">   11427 </span>            :  {</a>
<a name="11428"><span class="lineNum">   11428 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11429"><span class="lineNum">   11429 </span><span class="lineCov">        973 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11430"><span class="lineNum">   11430 </span>            : </a>
<a name="11431"><span class="lineNum">   11431 </span><span class="lineCov">        973 :    SgTypeComplex *result = new SgTypeComplex(base_type);</span></a>
<a name="11432"><span class="lineNum">   11432 </span><span class="lineCov">        973 :    ROSE_ASSERT(result!=NULL);</span></a>
<a name="11433"><span class="lineNum">   11433 </span><span class="lineCov">        973 :    return result;</span></a>
<a name="11434"><span class="lineNum">   11434 </span>            :  }</a>
<a name="11435"><span class="lineNum">   11435 </span>            : </a>
<a name="11436"><span class="lineNum">   11436 </span>            :   //! Build an imaginary type.</a>
<a name="11437"><span class="lineNum">   11437 </span><span class="lineNoCov">          0 : SgTypeImaginary* SageBuilder::buildImaginaryType(SgType* base_type /*=NULL*/)</span></a>
<a name="11438"><span class="lineNum">   11438 </span>            :  {</a>
<a name="11439"><span class="lineNum">   11439 </span>            :   // DQ (9/3/2012): Added assertion.</a>
<a name="11440"><span class="lineNum">   11440 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(base_type != NULL);</span></a>
<a name="11441"><span class="lineNum">   11441 </span>            : </a>
<a name="11442"><span class="lineNum">   11442 </span><span class="lineNoCov">          0 :    SgTypeImaginary *result = new SgTypeImaginary(base_type);</span></a>
<a name="11443"><span class="lineNum">   11443 </span><span class="lineNoCov">          0 :    ROSE_ASSERT(result!=NULL);</span></a>
<a name="11444"><span class="lineNum">   11444 </span><span class="lineNoCov">          0 :    return result;</span></a>
<a name="11445"><span class="lineNum">   11445 </span>            :  }</a>
<a name="11446"><span class="lineNum">   11446 </span>            : </a>
<a name="11447"><span class="lineNum">   11447 </span>            : //! Build a Matrix Type for Matlab</a>
<a name="11448"><span class="lineNum">   11448 </span><span class="lineNoCov">          0 : SgTypeMatrix* SageBuilder::buildMatrixType()</span></a>
<a name="11449"><span class="lineNum">   11449 </span>            : {</a>
<a name="11450"><span class="lineNum">   11450 </span><span class="lineNoCov">          0 :   SgTypeMatrix *result = new SgTypeMatrix();</span></a>
<a name="11451"><span class="lineNum">   11451 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11452"><span class="lineNum">   11452 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11453"><span class="lineNum">   11453 </span>            : }</a>
<a name="11454"><span class="lineNum">   11454 </span>            : </a>
<a name="11455"><span class="lineNum">   11455 </span>            : //! Build a type that holds multiple types. Used to represent the return type of a matlab function when it returns multiple variables of different types</a>
<a name="11456"><span class="lineNum">   11456 </span><span class="lineNoCov">          0 : SgTypeTuple* SageBuilder::buildTupleType(SgType *t1, SgType *t2, SgType *t3, SgType *t4, SgType *t5, SgType *t6, SgType *t7, SgType *t8, SgType *t9, SgType *t10)</span></a>
<a name="11457"><span class="lineNum">   11457 </span>            : {</a>
<a name="11458"><span class="lineNum">   11458 </span><span class="lineNoCov">          0 :   SgTypeTuple *result = new SgTypeTuple();</span></a>
<a name="11459"><span class="lineNum">   11459 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11460"><span class="lineNum">   11460 </span>            : </a>
<a name="11461"><span class="lineNum">   11461 </span><span class="lineNoCov">          0 :   if(t1) result-&gt;append_type(t1);</span></a>
<a name="11462"><span class="lineNum">   11462 </span><span class="lineNoCov">          0 :   if(t2) result-&gt;append_type(t2);</span></a>
<a name="11463"><span class="lineNum">   11463 </span><span class="lineNoCov">          0 :   if(t3) result-&gt;append_type(t3);</span></a>
<a name="11464"><span class="lineNum">   11464 </span><span class="lineNoCov">          0 :   if(t4) result-&gt;append_type(t4);</span></a>
<a name="11465"><span class="lineNum">   11465 </span><span class="lineNoCov">          0 :   if(t5) result-&gt;append_type(t5);</span></a>
<a name="11466"><span class="lineNum">   11466 </span><span class="lineNoCov">          0 :   if(t6) result-&gt;append_type(t6);</span></a>
<a name="11467"><span class="lineNum">   11467 </span><span class="lineNoCov">          0 :   if(t7) result-&gt;append_type(t7);</span></a>
<a name="11468"><span class="lineNum">   11468 </span><span class="lineNoCov">          0 :   if(t8) result-&gt;append_type(t8);</span></a>
<a name="11469"><span class="lineNum">   11469 </span><span class="lineNoCov">          0 :   if(t9) result-&gt;append_type(t9);</span></a>
<a name="11470"><span class="lineNum">   11470 </span><span class="lineNoCov">          0 :   if(t10) result-&gt;append_type(t10);</span></a>
<a name="11471"><span class="lineNum">   11471 </span>            : </a>
<a name="11472"><span class="lineNum">   11472 </span><span class="lineNoCov">          0 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="11473"><span class="lineNum">   11473 </span>            : </a>
<a name="11474"><span class="lineNum">   11474 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11475"><span class="lineNum">   11475 </span>            : }</a>
<a name="11476"><span class="lineNum">   11476 </span>            : </a>
<a name="11477"><span class="lineNum">   11477 </span>            : //! Build a non real type used for template parameter. Internally a SgNorealDecl is also built.</a>
<a name="11478"><span class="lineNum">   11478 </span><span class="lineCov">          1 : SgNonrealType * SageBuilder::buildNonrealType(const SgName &amp; name, SgDeclarationScope * scope) {</span></a>
<a name="11479"><span class="lineNum">   11479 </span><span class="lineCov">          1 :   SgNonrealDecl * nrdecl = buildNonrealDecl(name, scope);</span></a>
<a name="11480"><span class="lineNum">   11480 </span><span class="lineCov">          1 :   nrdecl-&gt;set_parent(scope);</span></a>
<a name="11481"><span class="lineNum">   11481 </span><span class="lineCov">          1 :   nrdecl-&gt;set_is_template_param (true);</span></a>
<a name="11482"><span class="lineNum">   11482 </span><span class="lineCov">          1 :   return nrdecl-&gt;get_type();</span></a>
<a name="11483"><span class="lineNum">   11483 </span>            : }</a>
<a name="11484"><span class="lineNum">   11484 </span>            : </a>
<a name="11485"><span class="lineNum">   11485 </span><span class="lineNoCov">          0 : SgRangeExp* SageBuilder::buildRangeExp(SgExpression *start)</span></a>
<a name="11486"><span class="lineNum">   11486 </span>            : {</a>
<a name="11487"><span class="lineNum">   11487 </span><span class="lineNoCov">          0 :   SgRangeExp *result = new SgRangeExp();</span></a>
<a name="11488"><span class="lineNum">   11488 </span><span class="lineNoCov">          0 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="11489"><span class="lineNum">   11489 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11490"><span class="lineNum">   11490 </span>            : </a>
<a name="11491"><span class="lineNum">   11491 </span><span class="lineNoCov">          0 :   result-&gt;append(start);</span></a>
<a name="11492"><span class="lineNum">   11492 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11493"><span class="lineNum">   11493 </span>            : }</a>
<a name="11494"><span class="lineNum">   11494 </span>            : </a>
<a name="11495"><span class="lineNum">   11495 </span><span class="lineNoCov">          0 : SgRangeExp* SageBuilder::buildRangeExp(SgExpression *start, SgExpression *end, SgExpression *stride)</span></a>
<a name="11496"><span class="lineNum">   11496 </span>            : {</a>
<a name="11497"><span class="lineNum">   11497 </span><span class="lineNoCov">          0 :   SgRangeExp *result = new SgRangeExp();</span></a>
<a name="11498"><span class="lineNum">   11498 </span><span class="lineNoCov">          0 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="11499"><span class="lineNum">   11499 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11500"><span class="lineNum">   11500 </span>            : </a>
<a name="11501"><span class="lineNum">   11501 </span><span class="lineNoCov">          0 :   result-&gt;set_start(start);</span></a>
<a name="11502"><span class="lineNum">   11502 </span><span class="lineNoCov">          0 :   start-&gt;set_parent(result);</span></a>
<a name="11503"><span class="lineNum">   11503 </span>            : </a>
<a name="11504"><span class="lineNum">   11504 </span><span class="lineNoCov">          0 :   result-&gt;set_end(end);</span></a>
<a name="11505"><span class="lineNum">   11505 </span><span class="lineNoCov">          0 :   end-&gt;set_parent(result);</span></a>
<a name="11506"><span class="lineNum">   11506 </span>            : </a>
<a name="11507"><span class="lineNum">   11507 </span><span class="lineNoCov">          0 :   result-&gt;set_stride(stride);</span></a>
<a name="11508"><span class="lineNum">   11508 </span><span class="lineNoCov">          0 :   stride-&gt;set_parent(result);</span></a>
<a name="11509"><span class="lineNum">   11509 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11510"><span class="lineNum">   11510 </span>            : }</a>
<a name="11511"><span class="lineNum">   11511 </span>            : </a>
<a name="11512"><span class="lineNum">   11512 </span>            : </a>
<a name="11513"><span class="lineNum">   11513 </span><span class="lineNoCov">          0 : SgMatrixExp* SageBuilder::buildMatrixExp(SgExprListExp *firstRow)</span></a>
<a name="11514"><span class="lineNum">   11514 </span>            : {</a>
<a name="11515"><span class="lineNum">   11515 </span><span class="lineNoCov">          0 :   SgMatrixExp *result = new SgMatrixExp();</span></a>
<a name="11516"><span class="lineNum">   11516 </span><span class="lineNoCov">          0 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="11517"><span class="lineNum">   11517 </span>            : </a>
<a name="11518"><span class="lineNum">   11518 </span><span class="lineNoCov">          0 :   result-&gt;append_expression(firstRow);</span></a>
<a name="11519"><span class="lineNum">   11519 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11520"><span class="lineNum">   11520 </span>            : </a>
<a name="11521"><span class="lineNum">   11521 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11522"><span class="lineNum">   11522 </span>            : }</a>
<a name="11523"><span class="lineNum">   11523 </span>            : </a>
<a name="11524"><span class="lineNum">   11524 </span><span class="lineNoCov">          0 : SgMagicColonExp* SageBuilder::buildMagicColonExp()</span></a>
<a name="11525"><span class="lineNum">   11525 </span>            : {</a>
<a name="11526"><span class="lineNum">   11526 </span><span class="lineNoCov">          0 :   SgMagicColonExp *result = new SgMagicColonExp();</span></a>
<a name="11527"><span class="lineNum">   11527 </span><span class="lineNoCov">          0 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="11528"><span class="lineNum">   11528 </span>            : </a>
<a name="11529"><span class="lineNum">   11529 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result != NULL);</span></a>
<a name="11530"><span class="lineNum">   11530 </span>            : </a>
<a name="11531"><span class="lineNum">   11531 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11532"><span class="lineNum">   11532 </span>            : }</a>
<a name="11533"><span class="lineNum">   11533 </span>            : </a>
<a name="11534"><span class="lineNum">   11534 </span>            : //! Build a const/volatile type qualifier</a>
<a name="11535"><span class="lineNum">   11535 </span><span class="lineNoCov">          0 : SgConstVolatileModifier * SageBuilder::buildConstVolatileModifier (SgConstVolatileModifier::cv_modifier_enum mtype/*=SgConstVolatileModifier::e_unknown*/)</span></a>
<a name="11536"><span class="lineNum">   11536 </span>            : {</a>
<a name="11537"><span class="lineNum">   11537 </span><span class="lineNoCov">          0 :   SgConstVolatileModifier * result = NULL;</span></a>
<a name="11538"><span class="lineNum">   11538 </span><span class="lineNoCov">          0 :   result = new SgConstVolatileModifier();</span></a>
<a name="11539"><span class="lineNum">   11539 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (result != NULL);</span></a>
<a name="11540"><span class="lineNum">   11540 </span><span class="lineNoCov">          0 :   result-&gt;set_modifier (mtype);</span></a>
<a name="11541"><span class="lineNum">   11541 </span>            : </a>
<a name="11542"><span class="lineNum">   11542 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="11543"><span class="lineNum">   11543 </span>            : }</a>
<a name="11544"><span class="lineNum">   11544 </span>            : </a>
<a name="11545"><span class="lineNum">   11545 </span>            : //! Build lambda expression</a>
<a name="11546"><span class="lineNum">   11546 </span>            : SgLambdaRefExp*</a>
<a name="11547"><span class="lineNum">   11547 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaRefExp(SgType* return_type, SgFunctionParameterList* params, SgScopeStatement* scope)</span></a>
<a name="11548"><span class="lineNum">   11548 </span>            :    {</a>
<a name="11549"><span class="lineNum">   11549 </span>            :   // SgFunctionDeclaration* func_decl = buildDefiningFunctionDeclaration(&quot;__rose__lambda__&quot;,return_type,params,scope,NULL,NULL);</a>
<a name="11550"><span class="lineNum">   11550 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* func_decl = buildDefiningFunctionDeclaration(&quot;__rose__lambda__&quot;,return_type,params,scope,NULL,false,NULL,NULL);</span></a>
<a name="11551"><span class="lineNum">   11551 </span>            : </a>
<a name="11552"><span class="lineNum">   11552 </span><span class="lineNoCov">          0 :      SgLambdaRefExp* result = new SgLambdaRefExp(func_decl);</span></a>
<a name="11553"><span class="lineNum">   11553 </span><span class="lineNoCov">          0 :      func_decl-&gt;set_parent(result);</span></a>
<a name="11554"><span class="lineNum">   11554 </span>            : </a>
<a name="11555"><span class="lineNum">   11555 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="11556"><span class="lineNum">   11556 </span>            : </a>
<a name="11557"><span class="lineNum">   11557 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11558"><span class="lineNum">   11558 </span>            :    }</a>
<a name="11559"><span class="lineNum">   11559 </span>            : </a>
<a name="11560"><span class="lineNum">   11560 </span>            : SgTypeExpression*</a>
<a name="11561"><span class="lineNum">   11561 </span><span class="lineNoCov">          0 : SageBuilder::buildTypeExpression(SgType *type)</span></a>
<a name="11562"><span class="lineNum">   11562 </span>            :    {</a>
<a name="11563"><span class="lineNum">   11563 </span><span class="lineNoCov">          0 :      SgTypeExpression *expr = new SgTypeExpression(type);</span></a>
<a name="11564"><span class="lineNum">   11564 </span><span class="lineNoCov">          0 :      SageInterface::setSourcePosition(expr);</span></a>
<a name="11565"><span class="lineNum">   11565 </span><span class="lineNoCov">          0 :      return expr;</span></a>
<a name="11566"><span class="lineNum">   11566 </span>            :    }</a>
<a name="11567"><span class="lineNum">   11567 </span>            : </a>
<a name="11568"><span class="lineNum">   11568 </span>            : // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.</a>
<a name="11569"><span class="lineNum">   11569 </span>            : SgFunctionParameterRefExp*</a>
<a name="11570"><span class="lineNum">   11570 </span><span class="lineCov">        600 : SageBuilder::buildFunctionParameterRefExp(int parameter_number, int parameter_level )</span></a>
<a name="11571"><span class="lineNum">   11571 </span>            :    {</a>
<a name="11572"><span class="lineNum">   11572 </span><span class="lineCov">        600 :      SgFunctionParameterRefExp *expr = new SgFunctionParameterRefExp(NULL,parameter_number,parameter_level);</span></a>
<a name="11573"><span class="lineNum">   11573 </span><span class="lineCov">        600 :      ROSE_ASSERT(expr != NULL);</span></a>
<a name="11574"><span class="lineNum">   11574 </span>            : </a>
<a name="11575"><span class="lineNum">   11575 </span><span class="lineCov">        600 :      setSourcePosition(expr);</span></a>
<a name="11576"><span class="lineNum">   11576 </span><span class="lineCov">        600 :      return expr;</span></a>
<a name="11577"><span class="lineNum">   11577 </span>            :    }</a>
<a name="11578"><span class="lineNum">   11578 </span>            : </a>
<a name="11579"><span class="lineNum">   11579 </span>            : </a>
<a name="11580"><span class="lineNum">   11580 </span>            : // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.</a>
<a name="11581"><span class="lineNum">   11581 </span>            : SgFunctionParameterRefExp*</a>
<a name="11582"><span class="lineNum">   11582 </span><span class="lineNoCov">          0 : SageBuilder::buildFunctionParameterRefExp_nfi(int parameter_number, int parameter_level )</span></a>
<a name="11583"><span class="lineNum">   11583 </span>            :    {</a>
<a name="11584"><span class="lineNum">   11584 </span><span class="lineNoCov">          0 :      SgFunctionParameterRefExp *expr = new SgFunctionParameterRefExp(NULL,parameter_number,parameter_level);</span></a>
<a name="11585"><span class="lineNum">   11585 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(expr != NULL);</span></a>
<a name="11586"><span class="lineNum">   11586 </span>            : </a>
<a name="11587"><span class="lineNum">   11587 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(expr);</span></a>
<a name="11588"><span class="lineNum">   11588 </span><span class="lineNoCov">          0 :      return expr;</span></a>
<a name="11589"><span class="lineNum">   11589 </span>            :    }</a>
<a name="11590"><span class="lineNum">   11590 </span>            : </a>
<a name="11591"><span class="lineNum">   11591 </span>            : // DQ (9/3/2014): Adding support for C++11 Lambda expressions</a>
<a name="11592"><span class="lineNum">   11592 </span>            : SgLambdaExp*</a>
<a name="11593"><span class="lineNum">   11593 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaExp(SgLambdaCaptureList* lambda_capture_list, SgClassDeclaration* lambda_closure_class, SgFunctionDeclaration* lambda_function)</span></a>
<a name="11594"><span class="lineNum">   11594 </span>            :    {</a>
<a name="11595"><span class="lineNum">   11595 </span><span class="lineNoCov">          0 :      SgLambdaExp *expr = new SgLambdaExp(lambda_capture_list,lambda_closure_class,lambda_function);</span></a>
<a name="11596"><span class="lineNum">   11596 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(expr != NULL);</span></a>
<a name="11597"><span class="lineNum">   11597 </span>            : </a>
<a name="11598"><span class="lineNum">   11598 </span>            :   // Set the parents</a>
<a name="11599"><span class="lineNum">   11599 </span><span class="lineNoCov">          0 :      if (lambda_capture_list != NULL)</span></a>
<a name="11600"><span class="lineNum">   11600 </span>            :         {</a>
<a name="11601"><span class="lineNum">   11601 </span><span class="lineNoCov">          0 :           lambda_capture_list-&gt;set_parent(expr);</span></a>
<a name="11602"><span class="lineNum">   11602 </span>            :         }</a>
<a name="11603"><span class="lineNum">   11603 </span>            : </a>
<a name="11604"><span class="lineNum">   11604 </span><span class="lineNoCov">          0 :      if (lambda_closure_class != NULL)</span></a>
<a name="11605"><span class="lineNum">   11605 </span>            :         {</a>
<a name="11606"><span class="lineNum">   11606 </span><span class="lineNoCov">          0 :           lambda_closure_class-&gt;set_parent(expr);</span></a>
<a name="11607"><span class="lineNum">   11607 </span>            :         }</a>
<a name="11608"><span class="lineNum">   11608 </span>            : </a>
<a name="11609"><span class="lineNum">   11609 </span><span class="lineNoCov">          0 :      if (lambda_function != NULL)</span></a>
<a name="11610"><span class="lineNum">   11610 </span>            :         {</a>
<a name="11611"><span class="lineNum">   11611 </span>            : #if 1</a>
<a name="11612"><span class="lineNum">   11612 </span><span class="lineNoCov">          0 :           lambda_function-&gt;set_parent(expr);</span></a>
<a name="11613"><span class="lineNum">   11613 </span>            : #else</a>
<a name="11614"><span class="lineNum">   11614 </span>            :           if (lambda_closure_class != NULL)</a>
<a name="11615"><span class="lineNum">   11615 </span>            :              {</a>
<a name="11616"><span class="lineNum">   11616 </span>            :                lambda_function-&gt;set_parent(lambda_closure_class);</a>
<a name="11617"><span class="lineNum">   11617 </span>            :              }</a>
<a name="11618"><span class="lineNum">   11618 </span>            :             else</a>
<a name="11619"><span class="lineNum">   11619 </span>            :              {</a>
<a name="11620"><span class="lineNum">   11620 </span>            :                printf (&quot;Warning: In SageBuilder::buildLambdaExp(): lambda_closure_class == NULL: lambda_function parent not set! \n&quot;);</a>
<a name="11621"><span class="lineNum">   11621 </span>            :              }</a>
<a name="11622"><span class="lineNum">   11622 </span>            : #endif</a>
<a name="11623"><span class="lineNum">   11623 </span>            :         }</a>
<a name="11624"><span class="lineNum">   11624 </span>            : </a>
<a name="11625"><span class="lineNum">   11625 </span><span class="lineNoCov">          0 :      setSourcePosition(expr);</span></a>
<a name="11626"><span class="lineNum">   11626 </span><span class="lineNoCov">          0 :      return expr;</span></a>
<a name="11627"><span class="lineNum">   11627 </span>            :    }</a>
<a name="11628"><span class="lineNum">   11628 </span>            : </a>
<a name="11629"><span class="lineNum">   11629 </span>            : SgLambdaExp*</a>
<a name="11630"><span class="lineNum">   11630 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaExp_nfi(SgLambdaCaptureList* lambda_capture_list, SgClassDeclaration* lambda_closure_class, SgFunctionDeclaration* lambda_function)</span></a>
<a name="11631"><span class="lineNum">   11631 </span>            :    {</a>
<a name="11632"><span class="lineNum">   11632 </span><span class="lineNoCov">          0 :      SgLambdaExp *expr = new SgLambdaExp(lambda_capture_list,lambda_closure_class,lambda_function);</span></a>
<a name="11633"><span class="lineNum">   11633 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(expr != NULL);</span></a>
<a name="11634"><span class="lineNum">   11634 </span>            : </a>
<a name="11635"><span class="lineNum">   11635 </span>            :   // Set the parents</a>
<a name="11636"><span class="lineNum">   11636 </span><span class="lineNoCov">          0 :      if (lambda_capture_list != NULL)</span></a>
<a name="11637"><span class="lineNum">   11637 </span>            :         {</a>
<a name="11638"><span class="lineNum">   11638 </span><span class="lineNoCov">          0 :           lambda_capture_list-&gt;set_parent(expr);</span></a>
<a name="11639"><span class="lineNum">   11639 </span>            :         }</a>
<a name="11640"><span class="lineNum">   11640 </span>            : </a>
<a name="11641"><span class="lineNum">   11641 </span><span class="lineNoCov">          0 :      if (lambda_closure_class != NULL)</span></a>
<a name="11642"><span class="lineNum">   11642 </span>            :         {</a>
<a name="11643"><span class="lineNum">   11643 </span><span class="lineNoCov">          0 :           lambda_closure_class-&gt;set_parent(expr);</span></a>
<a name="11644"><span class="lineNum">   11644 </span>            :         }</a>
<a name="11645"><span class="lineNum">   11645 </span>            : </a>
<a name="11646"><span class="lineNum">   11646 </span><span class="lineNoCov">          0 :      if (lambda_function != NULL)</span></a>
<a name="11647"><span class="lineNum">   11647 </span>            :         {</a>
<a name="11648"><span class="lineNum">   11648 </span>            : #if 1</a>
<a name="11649"><span class="lineNum">   11649 </span><span class="lineNoCov">          0 :           lambda_function-&gt;set_parent(expr);</span></a>
<a name="11650"><span class="lineNum">   11650 </span>            : #else</a>
<a name="11651"><span class="lineNum">   11651 </span>            :           if (lambda_closure_class != NULL)</a>
<a name="11652"><span class="lineNum">   11652 </span>            :              {</a>
<a name="11653"><span class="lineNum">   11653 </span>            :                lambda_function-&gt;set_parent(lambda_closure_class);</a>
<a name="11654"><span class="lineNum">   11654 </span>            :              }</a>
<a name="11655"><span class="lineNum">   11655 </span>            :             else</a>
<a name="11656"><span class="lineNum">   11656 </span>            :              {</a>
<a name="11657"><span class="lineNum">   11657 </span>            :                printf (&quot;Warning: In SageBuilder::buildLambdaExp(): lambda_closure_class == NULL: lambda_function parent not set! \n&quot;);</a>
<a name="11658"><span class="lineNum">   11658 </span>            :              }</a>
<a name="11659"><span class="lineNum">   11659 </span>            : #endif</a>
<a name="11660"><span class="lineNum">   11660 </span>            :         }</a>
<a name="11661"><span class="lineNum">   11661 </span>            : </a>
<a name="11662"><span class="lineNum">   11662 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(expr);</span></a>
<a name="11663"><span class="lineNum">   11663 </span><span class="lineNoCov">          0 :      return expr;</span></a>
<a name="11664"><span class="lineNum">   11664 </span>            :    }</a>
<a name="11665"><span class="lineNum">   11665 </span>            : </a>
<a name="11666"><span class="lineNum">   11666 </span>            : #if 0</a>
<a name="11667"><span class="lineNum">   11667 </span>            : SgLambdaCapture*</a>
<a name="11668"><span class="lineNum">   11668 </span>            : SageBuilder::buildLambdaCapture(SgInitializedName* capture_variable, SgInitializedName* source_closure_variable, SgInitializedName* closure_variable)</a>
<a name="11669"><span class="lineNum">   11669 </span>            :    {</a>
<a name="11670"><span class="lineNum">   11670 </span>            :       SgLambdaCapture *lambdaCapture = new SgLambdaCapture(NULL,capture_variable,source_closure_variable,closure_variable);</a>
<a name="11671"><span class="lineNum">   11671 </span>            :      ROSE_ASSERT(lambdaCapture != NULL);</a>
<a name="11672"><span class="lineNum">   11672 </span>            : </a>
<a name="11673"><span class="lineNum">   11673 </span>            :      setSourcePosition(lambdaCapture);</a>
<a name="11674"><span class="lineNum">   11674 </span>            :      return lambdaCapture;</a>
<a name="11675"><span class="lineNum">   11675 </span>            :    }</a>
<a name="11676"><span class="lineNum">   11676 </span>            : </a>
<a name="11677"><span class="lineNum">   11677 </span>            : SgLambdaCapture*</a>
<a name="11678"><span class="lineNum">   11678 </span>            : SageBuilder::buildLambdaCapture_nfi(SgInitializedName* capture_variable, SgInitializedName* source_closure_variable, SgInitializedName* closure_variable)</a>
<a name="11679"><span class="lineNum">   11679 </span>            :    {</a>
<a name="11680"><span class="lineNum">   11680 </span>            :      SgLambdaCapture *lambdaCapture = new SgLambdaCapture(NULL,capture_variable,source_closure_variable,closure_variable);</a>
<a name="11681"><span class="lineNum">   11681 </span>            :      ROSE_ASSERT(lambdaCapture != NULL);</a>
<a name="11682"><span class="lineNum">   11682 </span>            : </a>
<a name="11683"><span class="lineNum">   11683 </span>            :      setOneSourcePositionNull(lambdaCapture);</a>
<a name="11684"><span class="lineNum">   11684 </span>            :      return lambdaCapture;</a>
<a name="11685"><span class="lineNum">   11685 </span>            :    }</a>
<a name="11686"><span class="lineNum">   11686 </span>            : #else</a>
<a name="11687"><span class="lineNum">   11687 </span>            : SgLambdaCapture*</a>
<a name="11688"><span class="lineNum">   11688 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaCapture(SgExpression* capture_variable, SgExpression* source_closure_variable, SgExpression* closure_variable)</span></a>
<a name="11689"><span class="lineNum">   11689 </span>            :    {</a>
<a name="11690"><span class="lineNum">   11690 </span><span class="lineNoCov">          0 :       SgLambdaCapture *lambdaCapture = new SgLambdaCapture(NULL,capture_variable,source_closure_variable,closure_variable);</span></a>
<a name="11691"><span class="lineNum">   11691 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lambdaCapture != NULL);</span></a>
<a name="11692"><span class="lineNum">   11692 </span>            : </a>
<a name="11693"><span class="lineNum">   11693 </span><span class="lineNoCov">          0 :      setSourcePosition(lambdaCapture);</span></a>
<a name="11694"><span class="lineNum">   11694 </span><span class="lineNoCov">          0 :      return lambdaCapture;</span></a>
<a name="11695"><span class="lineNum">   11695 </span>            :    }</a>
<a name="11696"><span class="lineNum">   11696 </span>            : </a>
<a name="11697"><span class="lineNum">   11697 </span>            : SgLambdaCapture*</a>
<a name="11698"><span class="lineNum">   11698 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaCapture_nfi(SgExpression* capture_variable, SgExpression* source_closure_variable, SgExpression* closure_variable)</span></a>
<a name="11699"><span class="lineNum">   11699 </span>            :    {</a>
<a name="11700"><span class="lineNum">   11700 </span><span class="lineNoCov">          0 :      SgLambdaCapture *lambdaCapture = new SgLambdaCapture(NULL,capture_variable,source_closure_variable,closure_variable);</span></a>
<a name="11701"><span class="lineNum">   11701 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lambdaCapture != NULL);</span></a>
<a name="11702"><span class="lineNum">   11702 </span>            : </a>
<a name="11703"><span class="lineNum">   11703 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(lambdaCapture);</span></a>
<a name="11704"><span class="lineNum">   11704 </span><span class="lineNoCov">          0 :      return lambdaCapture;</span></a>
<a name="11705"><span class="lineNum">   11705 </span>            :    }</a>
<a name="11706"><span class="lineNum">   11706 </span>            : #endif</a>
<a name="11707"><span class="lineNum">   11707 </span>            : </a>
<a name="11708"><span class="lineNum">   11708 </span>            : SgLambdaCaptureList*</a>
<a name="11709"><span class="lineNum">   11709 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaCaptureList()</span></a>
<a name="11710"><span class="lineNum">   11710 </span>            :    {</a>
<a name="11711"><span class="lineNum">   11711 </span><span class="lineNoCov">          0 :      SgLambdaCaptureList *lambdaCaptureList = new SgLambdaCaptureList(NULL);</span></a>
<a name="11712"><span class="lineNum">   11712 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lambdaCaptureList != NULL);</span></a>
<a name="11713"><span class="lineNum">   11713 </span>            : </a>
<a name="11714"><span class="lineNum">   11714 </span><span class="lineNoCov">          0 :      setSourcePosition(lambdaCaptureList);</span></a>
<a name="11715"><span class="lineNum">   11715 </span><span class="lineNoCov">          0 :      return lambdaCaptureList;</span></a>
<a name="11716"><span class="lineNum">   11716 </span>            :    }</a>
<a name="11717"><span class="lineNum">   11717 </span>            : </a>
<a name="11718"><span class="lineNum">   11718 </span>            : SgLambdaCaptureList*</a>
<a name="11719"><span class="lineNum">   11719 </span><span class="lineNoCov">          0 : SageBuilder::buildLambdaCaptureList_nfi()</span></a>
<a name="11720"><span class="lineNum">   11720 </span>            :    {</a>
<a name="11721"><span class="lineNum">   11721 </span><span class="lineNoCov">          0 :      SgLambdaCaptureList *lambdaCaptureList = new SgLambdaCaptureList(NULL);</span></a>
<a name="11722"><span class="lineNum">   11722 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lambdaCaptureList != NULL);</span></a>
<a name="11723"><span class="lineNum">   11723 </span>            : </a>
<a name="11724"><span class="lineNum">   11724 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(lambdaCaptureList);</span></a>
<a name="11725"><span class="lineNum">   11725 </span><span class="lineNoCov">          0 :      return lambdaCaptureList;</span></a>
<a name="11726"><span class="lineNum">   11726 </span>            :    }</a>
<a name="11727"><span class="lineNum">   11727 </span>            : </a>
<a name="11728"><span class="lineNum">   11728 </span>            : // DQ (7/25/2020): Adding C++17 support</a>
<a name="11729"><span class="lineNum">   11729 </span>            : SgFoldExpression*</a>
<a name="11730"><span class="lineNum">   11730 </span><span class="lineNoCov">          0 : SageBuilder::buildFoldExpression(SgExpression* operands, string operator_token_string, bool is_left_associative)</span></a>
<a name="11731"><span class="lineNum">   11731 </span>            :    {</a>
<a name="11732"><span class="lineNum">   11732 </span><span class="lineNoCov">          0 :      SgFoldExpression* result = new SgFoldExpression(NULL,operands,operator_token_string,is_left_associative);</span></a>
<a name="11733"><span class="lineNum">   11733 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11734"><span class="lineNum">   11734 </span>            : </a>
<a name="11735"><span class="lineNum">   11735 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="11736"><span class="lineNum">   11736 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11737"><span class="lineNum">   11737 </span>            :    }</a>
<a name="11738"><span class="lineNum">   11738 </span>            : </a>
<a name="11739"><span class="lineNum">   11739 </span>            : SgFoldExpression*</a>
<a name="11740"><span class="lineNum">   11740 </span><span class="lineNoCov">          0 : SageBuilder::buildFoldExpression_nfi(SgExpression* operands, string operator_token_string, bool is_left_associative)</span></a>
<a name="11741"><span class="lineNum">   11741 </span>            :    {</a>
<a name="11742"><span class="lineNum">   11742 </span><span class="lineNoCov">          0 :      SgFoldExpression* result = new SgFoldExpression(NULL,operands,operator_token_string,is_left_associative);</span></a>
<a name="11743"><span class="lineNum">   11743 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11744"><span class="lineNum">   11744 </span>            : </a>
<a name="11745"><span class="lineNum">   11745 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="11746"><span class="lineNum">   11746 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11747"><span class="lineNum">   11747 </span>            :    }</a>
<a name="11748"><span class="lineNum">   11748 </span>            : </a>
<a name="11749"><span class="lineNum">   11749 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="11750"><span class="lineNum">   11750 </span>            : SgAwaitExpression*</a>
<a name="11751"><span class="lineNum">   11751 </span><span class="lineNoCov">          0 : SageBuilder::buildAwaitExpression()</span></a>
<a name="11752"><span class="lineNum">   11752 </span>            :    {</a>
<a name="11753"><span class="lineNum">   11753 </span><span class="lineNoCov">          0 :      SgAwaitExpression* result = new SgAwaitExpression(NULL,NULL);</span></a>
<a name="11754"><span class="lineNum">   11754 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11755"><span class="lineNum">   11755 </span>            : </a>
<a name="11756"><span class="lineNum">   11756 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="11757"><span class="lineNum">   11757 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11758"><span class="lineNum">   11758 </span>            :    }</a>
<a name="11759"><span class="lineNum">   11759 </span>            : SgAwaitExpression*</a>
<a name="11760"><span class="lineNum">   11760 </span><span class="lineNoCov">          0 : SageBuilder::buildAwaitExpression_nfi()</span></a>
<a name="11761"><span class="lineNum">   11761 </span>            :    {</a>
<a name="11762"><span class="lineNum">   11762 </span><span class="lineNoCov">          0 :      SgAwaitExpression* result = new SgAwaitExpression(NULL,NULL);</span></a>
<a name="11763"><span class="lineNum">   11763 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11764"><span class="lineNum">   11764 </span>            : </a>
<a name="11765"><span class="lineNum">   11765 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="11766"><span class="lineNum">   11766 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11767"><span class="lineNum">   11767 </span>            :    }</a>
<a name="11768"><span class="lineNum">   11768 </span>            : </a>
<a name="11769"><span class="lineNum">   11769 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="11770"><span class="lineNum">   11770 </span>            : SgChooseExpression*</a>
<a name="11771"><span class="lineNum">   11771 </span><span class="lineNoCov">          0 : SageBuilder::buildChooseExpression()</span></a>
<a name="11772"><span class="lineNum">   11772 </span>            :    {</a>
<a name="11773"><span class="lineNum">   11773 </span><span class="lineNoCov">          0 :      SgChooseExpression* result = new SgChooseExpression(NULL,NULL);</span></a>
<a name="11774"><span class="lineNum">   11774 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11775"><span class="lineNum">   11775 </span>            : </a>
<a name="11776"><span class="lineNum">   11776 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="11777"><span class="lineNum">   11777 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11778"><span class="lineNum">   11778 </span>            :    }</a>
<a name="11779"><span class="lineNum">   11779 </span>            : </a>
<a name="11780"><span class="lineNum">   11780 </span>            : SgChooseExpression*</a>
<a name="11781"><span class="lineNum">   11781 </span><span class="lineNoCov">          0 : SageBuilder::buildChooseExpression_nfi()</span></a>
<a name="11782"><span class="lineNum">   11782 </span>            :    {</a>
<a name="11783"><span class="lineNum">   11783 </span><span class="lineNoCov">          0 :      SgChooseExpression* result = new SgChooseExpression(NULL,NULL);</span></a>
<a name="11784"><span class="lineNum">   11784 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="11785"><span class="lineNum">   11785 </span>            : </a>
<a name="11786"><span class="lineNum">   11786 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="11787"><span class="lineNum">   11787 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11788"><span class="lineNum">   11788 </span>            :    }</a>
<a name="11789"><span class="lineNum">   11789 </span>            : </a>
<a name="11790"><span class="lineNum">   11790 </span>            : </a>
<a name="11791"><span class="lineNum">   11791 </span>            : </a>
<a name="11792"><span class="lineNum">   11792 </span>            : SgNamespaceDefinitionStatement*</a>
<a name="11793"><span class="lineNum">   11793 </span><span class="lineCov">       1276 : SageBuilder::buildNamespaceDefinition(SgNamespaceDeclarationStatement* d)</span></a>
<a name="11794"><span class="lineNum">   11794 </span>            :   {</a>
<a name="11795"><span class="lineNum">   11795 </span><span class="lineCov">       1276 :     SgNamespaceDefinitionStatement* result = NULL;</span></a>
<a name="11796"><span class="lineNum">   11796 </span><span class="lineCov">       1276 :     if (d!=NULL) // the constructor does not check for NULL d, causing segmentation fault</span></a>
<a name="11797"><span class="lineNum">   11797 </span>            :        {</a>
<a name="11798"><span class="lineNum">   11798 </span><span class="lineNoCov">          0 :          result = new SgNamespaceDefinitionStatement(d);</span></a>
<a name="11799"><span class="lineNum">   11799 </span><span class="lineNoCov">          0 :          result-&gt;set_parent(d); // set_declaration() == set_parent() in this case</span></a>
<a name="11800"><span class="lineNum">   11800 </span>            :        }</a>
<a name="11801"><span class="lineNum">   11801 </span>            :       else</a>
<a name="11802"><span class="lineNum">   11802 </span>            :        {</a>
<a name="11803"><span class="lineNum">   11803 </span><span class="lineCov">       1276 :          result = new SgNamespaceDefinitionStatement(d);</span></a>
<a name="11804"><span class="lineNum">   11804 </span>            :        }</a>
<a name="11805"><span class="lineNum">   11805 </span>            : </a>
<a name="11806"><span class="lineNum">   11806 </span><span class="lineCov">       1276 :     ROSE_ASSERT(result);</span></a>
<a name="11807"><span class="lineNum">   11807 </span>            : </a>
<a name="11808"><span class="lineNum">   11808 </span><span class="lineCov">       1276 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="11809"><span class="lineNum">   11809 </span><span class="lineCov">       1276 :     return result;</span></a>
<a name="11810"><span class="lineNum">   11810 </span>            :   }</a>
<a name="11811"><span class="lineNum">   11811 </span>            : </a>
<a name="11812"><span class="lineNum">   11812 </span>            : //! Build a scope statement. Used to build SgNonrealDecl and SgNonrealType</a>
<a name="11813"><span class="lineNum">   11813 </span><span class="lineCov">          1 : SgDeclarationScope* SageBuilder::buildDeclarationScope()</span></a>
<a name="11814"><span class="lineNum">   11814 </span>            : {</a>
<a name="11815"><span class="lineNum">   11815 </span><span class="lineCov">          1 :   SgDeclarationScope * nonreal_decl_scope = new SgDeclarationScope();</span></a>
<a name="11816"><span class="lineNum">   11816 </span><span class="lineCov">          1 :   SageInterface::setSourcePosition(nonreal_decl_scope);</span></a>
<a name="11817"><span class="lineNum">   11817 </span><span class="lineCov">          1 :   nonreal_decl_scope-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="11818"><span class="lineNum">   11818 </span><span class="lineCov">          1 :   nonreal_decl_scope-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="11819"><span class="lineNum">   11819 </span><span class="lineCov">          1 :   return nonreal_decl_scope;</span></a>
<a name="11820"><span class="lineNum">   11820 </span>            : }</a>
<a name="11821"><span class="lineNum">   11821 </span>            : </a>
<a name="11822"><span class="lineNum">   11822 </span>            : SgClassDefinition*</a>
<a name="11823"><span class="lineNum">   11823 </span><span class="lineCov">      12209 : SageBuilder::buildClassDefinition(SgClassDeclaration *d/*= NULL*/, bool buildTemplateInstantiation )</span></a>
<a name="11824"><span class="lineNum">   11824 </span>            :    {</a>
<a name="11825"><span class="lineNum">   11825 </span><span class="lineCov">      12209 :      SgClassDefinition* result = NULL;</span></a>
<a name="11826"><span class="lineNum">   11826 </span><span class="lineCov">      12209 :      if (d != NULL) // the constructor does not check for NULL d, causing segmentation fault</span></a>
<a name="11827"><span class="lineNum">   11827 </span>            :         {</a>
<a name="11828"><span class="lineNum">   11828 </span>            :        // result-&gt;set_parent(d); // set_declaration() == set_parent() in this case</a>
<a name="11829"><span class="lineNum">   11829 </span>            :        // result = new SgClassDefinition(d);</a>
<a name="11830"><span class="lineNum">   11830 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(buildTemplateInstantiation == false || isSgTemplateInstantiationDecl(d) != NULL);</span></a>
<a name="11831"><span class="lineNum">   11831 </span><span class="lineNoCov">          0 :           result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn(isSgTemplateInstantiationDecl(d)) : new SgClassDefinition(d);</span></a>
<a name="11832"><span class="lineNum">   11832 </span>            :         }</a>
<a name="11833"><span class="lineNum">   11833 </span>            :        else</a>
<a name="11834"><span class="lineNum">   11834 </span>            :         {</a>
<a name="11835"><span class="lineNum">   11835 </span>            :        // result = new SgClassDefinition();</a>
<a name="11836"><span class="lineNum">   11836 </span><span class="lineCov">      12209 :           result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn() : new SgClassDefinition();</span></a>
<a name="11837"><span class="lineNum">   11837 </span>            :         }</a>
<a name="11838"><span class="lineNum">   11838 </span>            : </a>
<a name="11839"><span class="lineNum">   11839 </span><span class="lineCov">      12209 :      ROSE_ASSERT(result);</span></a>
<a name="11840"><span class="lineNum">   11840 </span>            : </a>
<a name="11841"><span class="lineNum">   11841 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="11842"><span class="lineNum">   11842 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="11843"><span class="lineNum">   11843 </span><span class="lineCov">      12209 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="11844"><span class="lineNum">   11844 </span>            :         {</a>
<a name="11845"><span class="lineNum">   11845 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="11846"><span class="lineNum">   11846 </span>            :         }</a>
<a name="11847"><span class="lineNum">   11847 </span>            : </a>
<a name="11848"><span class="lineNum">   11848 </span><span class="lineCov">      12209 :      setOneSourcePositionForTransformation(result);</span></a>
<a name="11849"><span class="lineNum">   11849 </span>            : </a>
<a name="11850"><span class="lineNum">   11850 </span><span class="lineCov">      12209 :      return result;</span></a>
<a name="11851"><span class="lineNum">   11851 </span>            :    }</a>
<a name="11852"><span class="lineNum">   11852 </span>            : </a>
<a name="11853"><span class="lineNum">   11853 </span>            : </a>
<a name="11854"><span class="lineNum">   11854 </span>            : </a>
<a name="11855"><span class="lineNum">   11855 </span>            : SgClassDefinition*</a>
<a name="11856"><span class="lineNum">   11856 </span><span class="lineNoCov">          0 : SageBuilder::buildClassDefinition_nfi(SgClassDeclaration *d/*= NULL*/, bool buildTemplateInstantiation )</span></a>
<a name="11857"><span class="lineNum">   11857 </span>            :    {</a>
<a name="11858"><span class="lineNum">   11858 </span><span class="lineNoCov">          0 :      SgClassDefinition* result = NULL;</span></a>
<a name="11859"><span class="lineNum">   11859 </span><span class="lineNoCov">          0 :      if (d!=NULL) // the constructor does not check for NULL d, causing segmentation fault</span></a>
<a name="11860"><span class="lineNum">   11860 </span>            :         {</a>
<a name="11861"><span class="lineNum">   11861 </span>            :        // result-&gt;set_parent(d); // set_declaration() == set_parent() in this case</a>
<a name="11862"><span class="lineNum">   11862 </span>            :        // result = new SgClassDefinition(d);</a>
<a name="11863"><span class="lineNum">   11863 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(buildTemplateInstantiation == false || isSgTemplateInstantiationDecl(d) != NULL);</span></a>
<a name="11864"><span class="lineNum">   11864 </span><span class="lineNoCov">          0 :           result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn(isSgTemplateInstantiationDecl(d)) : new SgClassDefinition(d);</span></a>
<a name="11865"><span class="lineNum">   11865 </span>            :         }</a>
<a name="11866"><span class="lineNum">   11866 </span>            :        else</a>
<a name="11867"><span class="lineNum">   11867 </span>            :         {</a>
<a name="11868"><span class="lineNum">   11868 </span>            :        // result = new SgClassDefinition();</a>
<a name="11869"><span class="lineNum">   11869 </span><span class="lineNoCov">          0 :           result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn() : new SgClassDefinition();</span></a>
<a name="11870"><span class="lineNum">   11870 </span>            :         }</a>
<a name="11871"><span class="lineNum">   11871 </span>            : </a>
<a name="11872"><span class="lineNum">   11872 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result);</span></a>
<a name="11873"><span class="lineNum">   11873 </span>            : </a>
<a name="11874"><span class="lineNum">   11874 </span>            :   // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="11875"><span class="lineNum">   11875 </span>            :   // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="11876"><span class="lineNum">   11876 </span><span class="lineNoCov">          0 :      if (SageInterface::is_language_case_insensitive())</span></a>
<a name="11877"><span class="lineNum">   11877 </span><span class="lineNoCov">          0 :           result-&gt;setCaseInsensitive(true);</span></a>
<a name="11878"><span class="lineNum">   11878 </span>            : </a>
<a name="11879"><span class="lineNum">   11879 </span><span class="lineNoCov">          0 :      setOneSourcePositionNull(result);</span></a>
<a name="11880"><span class="lineNum">   11880 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="11881"><span class="lineNum">   11881 </span>            :    }</a>
<a name="11882"><span class="lineNum">   11882 </span>            : </a>
<a name="11883"><span class="lineNum">   11883 </span>            : </a>
<a name="11884"><span class="lineNum">   11884 </span>            : SgClassDeclaration*</a>
<a name="11885"><span class="lineNum">   11885 </span><span class="lineCov">       4813 : SageBuilder::buildNondefiningClassDeclaration_nfi(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList)</span></a>
<a name="11886"><span class="lineNum">   11886 </span>            :    {</a>
<a name="11887"><span class="lineNum">   11887 </span><span class="lineCov">       9626 :      SgName nameWithoutTemplateArguments = XXX_name;</span></a>
<a name="11888"><span class="lineNum">   11888 </span>            : </a>
<a name="11889"><span class="lineNum">   11889 </span><span class="lineCov">       4813 :      SgName nameWithTemplateArguments = nameWithoutTemplateArguments;</span></a>
<a name="11890"><span class="lineNum">   11890 </span>            : </a>
<a name="11891"><span class="lineNum">   11891 </span>            :   // SgClassDeclaration* nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);</a>
<a name="11892"><span class="lineNum">   11892 </span><span class="lineCov">       4813 :      SgClassDeclaration* nondefdecl = NULL;</span></a>
<a name="11893"><span class="lineNum">   11893 </span>            : </a>
<a name="11894"><span class="lineNum">   11894 </span>            : #define DEBUG_NONDEFINING_CLASS_DECLARATION 0</a>
<a name="11895"><span class="lineNum">   11895 </span>            : </a>
<a name="11896"><span class="lineNum">   11896 </span>            :   // DQ (11/26/2011): Debugging EDG 3.3 use of templateArguments.</a>
<a name="11897"><span class="lineNum">   11897 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11898"><span class="lineNum">   11898 </span>            :      printf (&quot;Building a SgClassDeclaration: buildNondefiningClassDeclaration_nfi() nameWithoutTemplateArguments = %s buildTemplateInstantiation = %s \n&quot;,nameWithoutTemplateArguments.str(),buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</a>
<a name="11899"><span class="lineNum">   11899 </span>            :      printf (&quot;   --- scope = %p = %s \n&quot;,scope,(scope != NULL) ? scope-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="11900"><span class="lineNum">   11900 </span>            : #endif</a>
<a name="11901"><span class="lineNum">   11901 </span>            : </a>
<a name="11902"><span class="lineNum">   11902 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="11903"><span class="lineNum">   11903 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="11904"><span class="lineNum">   11904 </span><span class="lineCov">       4813 :      ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);</span></a>
<a name="11905"><span class="lineNum">   11905 </span>            : </a>
<a name="11906"><span class="lineNum">   11906 </span><span class="lineCov">       4813 :      if (buildTemplateInstantiation == true)</span></a>
<a name="11907"><span class="lineNum">   11907 </span>            :         {</a>
<a name="11908"><span class="lineNum">   11908 </span><span class="lineCov">       3097 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="11909"><span class="lineNum">   11909 </span><span class="lineCov">       3097 :           nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);</span></a>
<a name="11910"><span class="lineNum">   11910 </span>            : </a>
<a name="11911"><span class="lineNum">   11911 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11912"><span class="lineNum">   11912 </span>            :           printf (&quot;Building a SgClassDeclaration: buildNondefiningClassDeclaration_nfi() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n&quot;,nameWithTemplateArguments.str(),buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</a>
<a name="11913"><span class="lineNum">   11913 </span>            : #endif</a>
<a name="11914"><span class="lineNum">   11914 </span>            : </a>
<a name="11915"><span class="lineNum">   11915 </span>            :        // SgTemplateInstantiationDecl (SgName name, SgClassDeclaration::class_types class_type, SgClassType *type, SgClassDefinition *definition, SgTemplateDeclaration *templateDeclaration, SgTemplateArgumentPtrList templateArguments)</a>
<a name="11916"><span class="lineNum">   11916 </span><span class="lineCov">       6194 :           SgTemplateArgumentPtrList emptyList;</span></a>
<a name="11917"><span class="lineNum">   11917 </span>            :        // nondefdecl = new SgTemplateInstantiationDecl(name,kind,NULL,NULL,NULL,emptyList);</a>
<a name="11918"><span class="lineNum">   11918 </span><span class="lineCov">       3097 :           nondefdecl = new SgTemplateInstantiationDecl(nameWithTemplateArguments,kind,NULL,NULL,NULL,emptyList);</span></a>
<a name="11919"><span class="lineNum">   11919 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11920"><span class="lineNum">   11920 </span>            :           printf (&quot;In buildNondefiningClassDeclaration_nfi(): built new SgTemplateInstantiationDecl: nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="11921"><span class="lineNum">   11921 </span>            : #endif</a>
<a name="11922"><span class="lineNum">   11922 </span><span class="lineCov">       3097 :           ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="11923"><span class="lineNum">   11923 </span><span class="lineCov">       3097 :           ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl) != NULL);</span></a>
<a name="11924"><span class="lineNum">   11924 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11925"><span class="lineNum">   11925 </span>            :           printf (&quot;In buildNondefiningClassDeclaration_nfi(): nondefdecl-&gt;get_name() = %s nondefdecl-&gt;get_templateName() = %s \n&quot;,</a>
<a name="11926"><span class="lineNum">   11926 </span>            :                nondefdecl-&gt;get_name().str(),isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().str());</a>
<a name="11927"><span class="lineNum">   11927 </span>            : #endif</a>
<a name="11928"><span class="lineNum">   11928 </span>            :        // DQ (6/6/2012): Added support for template arguments so that they can be a part of any generated type.</a>
<a name="11929"><span class="lineNum">   11929 </span><span class="lineCov">       3097 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="11930"><span class="lineNum">   11930 </span>            : </a>
<a name="11931"><span class="lineNum">   11931 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11932"><span class="lineNum">   11932 </span>            :           printf (&quot;nondefdecl-&gt;get_name() = %s \n&quot;,nondefdecl-&gt;get_name().str());</a>
<a name="11933"><span class="lineNum">   11933 </span>            :           printf (&quot;nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="11934"><span class="lineNum">   11934 </span>            :           printf (&quot;Output templateArgumentsList: \n&quot;);</a>
<a name="11935"><span class="lineNum">   11935 </span>            :           for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="11936"><span class="lineNum">   11936 </span>            :              {</a>
<a name="11937"><span class="lineNum">   11937 </span>            :                printf (&quot;   --- --- templateArgumentsList-&gt;[%zu] = %p \n&quot;,i,templateArgumentsList-&gt;operator[](i));</a>
<a name="11938"><span class="lineNum">   11938 </span>            :                printf (&quot;   --- --- name = %s \n&quot;,unparseTemplateArgumentToString(templateArgumentsList-&gt;operator[](i)).str());</a>
<a name="11939"><span class="lineNum">   11939 </span>            :              }</a>
<a name="11940"><span class="lineNum">   11940 </span>            : #endif</a>
<a name="11941"><span class="lineNum">   11941 </span>            : </a>
<a name="11942"><span class="lineNum">   11942 </span>            :        // DQ (3/9/2018): Added assertion.</a>
<a name="11943"><span class="lineNum">   11943 </span><span class="lineCov">       3097 :           ROSE_ASSERT(nondefdecl-&gt;get_name() == nameWithTemplateArguments);</span></a>
<a name="11944"><span class="lineNum">   11944 </span>            : </a>
<a name="11945"><span class="lineNum">   11945 </span>            :        // DQ (5/8/2013): This fails for explicit template instantation examples (e.g. template &lt;&gt; class RepeatedPtrField&lt;string&gt;::TypeHandler {};, in test2013_159.C)</a>
<a name="11946"><span class="lineNum">   11946 </span>            :        // ROSE_ASSERT(templateArgumentsList-&gt;size() &gt; 0);</a>
<a name="11947"><span class="lineNum">   11947 </span>            : #if 0</a>
<a name="11948"><span class="lineNum">   11948 </span>            :        // DQ (9/16/2012): Call the newly refactored function after the firstNondefiningDeclaration is set.</a>
<a name="11949"><span class="lineNum">   11949 </span>            : </a>
<a name="11950"><span class="lineNum">   11950 </span>            :        // Calling the assignment operator for the STL container class.</a>
<a name="11951"><span class="lineNum">   11951 </span>            :           isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateArguments() = *templateArgumentsList;</a>
<a name="11952"><span class="lineNum">   11952 </span>            : </a>
<a name="11953"><span class="lineNum">   11953 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="11954"><span class="lineNum">   11954 </span>            : </a>
<a name="11955"><span class="lineNum">   11955 </span>            : #if 1</a>
<a name="11956"><span class="lineNum">   11956 </span>            :        // DQ (9/13/2012): Refactored this code.</a>
<a name="11957"><span class="lineNum">   11957 </span>            :           setTemplateArgumentParents(nondefdecl);</a>
<a name="11958"><span class="lineNum">   11958 </span>            : #else</a>
<a name="11959"><span class="lineNum">   11959 </span>            :        // DQ (7/25/2012): Added this code here to reset the parents of the template arguments.</a>
<a name="11960"><span class="lineNum">   11960 </span>            :           for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="11961"><span class="lineNum">   11961 </span>            :              {</a>
<a name="11962"><span class="lineNum">   11962 </span>            :             // DQ (7/25/2012): This should be true because the template argument was set to the functions</a>
<a name="11963"><span class="lineNum">   11963 </span>            :             // scope so that the name with template arguments could be computed (with name qualification).</a>
<a name="11964"><span class="lineNum">   11964 </span>            :                 ROSE_ASSERT((*templateArgumentsList)[i]-&gt;get_parent() != NULL);</a>
<a name="11965"><span class="lineNum">   11965 </span>            : </a>
<a name="11966"><span class="lineNum">   11966 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="11967"><span class="lineNum">   11967 </span>            : </a>
<a name="11968"><span class="lineNum">   11968 </span>            :             // ROSE_ASSERT(isSgGlobal(templateArgumentsList[i]-&gt;get_parent()) == NULL);</a>
<a name="11969"><span class="lineNum">   11969 </span>            :             // ROSE_ASSERT(templateArgumentsList[i]-&gt;get_parent() == nondefining_templateInstantiation);</a>
<a name="11970"><span class="lineNum">   11970 </span>            : </a>
<a name="11971"><span class="lineNum">   11971 </span>            :             // Be we want to reset it to be the function (now that it is available, because this is more precise).</a>
<a name="11972"><span class="lineNum">   11972 </span>            :             // All qualified names should compute to the same qualified name (if not then it is a bug in the name</a>
<a name="11973"><span class="lineNum">   11973 </span>            :             // qualification mechanism).</a>
<a name="11974"><span class="lineNum">   11974 </span>            :                (*templateArgumentsList)[i]-&gt;set_parent(nondefdecl);</a>
<a name="11975"><span class="lineNum">   11975 </span>            :              }</a>
<a name="11976"><span class="lineNum">   11976 </span>            : #endif</a>
<a name="11977"><span class="lineNum">   11977 </span>            : #endif</a>
<a name="11978"><span class="lineNum">   11978 </span><span class="lineCov">       3097 :           ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().is_null() == true);</span></a>
<a name="11979"><span class="lineNum">   11979 </span><span class="lineCov">       3097 :           isSgTemplateInstantiationDecl(nondefdecl)-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="11980"><span class="lineNum">   11980 </span>            :         }</a>
<a name="11981"><span class="lineNum">   11981 </span>            :        else</a>
<a name="11982"><span class="lineNum">   11982 </span>            :         {</a>
<a name="11983"><span class="lineNum">   11983 </span>            :        // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);</a>
<a name="11984"><span class="lineNum">   11984 </span><span class="lineCov">       1716 :           nondefdecl = new SgClassDeclaration(nameWithoutTemplateArguments,kind,NULL,NULL);</span></a>
<a name="11985"><span class="lineNum">   11985 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="11986"><span class="lineNum">   11986 </span>            :           printf (&quot;In buildNondefiningClassDeclaration_nfi(): built new SgClassDeclaration: nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="11987"><span class="lineNum">   11987 </span>            : #endif</a>
<a name="11988"><span class="lineNum">   11988 </span>            :        // The default name for nameWithTemplateArguments is nameWithoutTemplateArguments so that we can use</a>
<a name="11989"><span class="lineNum">   11989 </span>            :        // nameWithTemplateArguments uniformally as the name of the function and it will work from non-template</a>
<a name="11990"><span class="lineNum">   11990 </span>            :        // instantiations.</a>
<a name="11991"><span class="lineNum">   11991 </span><span class="lineCov">       1716 :           ROSE_ASSERT(nameWithoutTemplateArguments == nameWithTemplateArguments);</span></a>
<a name="11992"><span class="lineNum">   11992 </span>            :         }</a>
<a name="11993"><span class="lineNum">   11993 </span>            : </a>
<a name="11994"><span class="lineNum">   11994 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="11995"><span class="lineNum">   11995 </span>            : </a>
<a name="11996"><span class="lineNum">   11996 </span>            :   // DQ (6/9/2013): Added assertion to debug test2013_198.C.</a>
<a name="11997"><span class="lineNum">   11997 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="11998"><span class="lineNum">   11998 </span>            : </a>
<a name="11999"><span class="lineNum">   11999 </span>            :   // DQ (3/22/2012): I think we can assert this! No, in fact we can assert that it is not built yet.</a>
<a name="12000"><span class="lineNum">   12000 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="12001"><span class="lineNum">   12001 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="12002"><span class="lineNum">   12002 </span>            : </a>
<a name="12003"><span class="lineNum">   12003 </span>            : #if 0</a>
<a name="12004"><span class="lineNum">   12004 </span>            :   // DQ (3/22/2012): I think this may be too early.</a>
<a name="12005"><span class="lineNum">   12005 </span>            :   // Liao, we ask for explicit creation of SgClassType to avoid duplicated type nodes</a>
<a name="12006"><span class="lineNum">   12006 </span>            :      if (nondefdecl-&gt;get_type() == NULL)</a>
<a name="12007"><span class="lineNum">   12007 </span>            :         {</a>
<a name="12008"><span class="lineNum">   12008 </span>            :           nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="12009"><span class="lineNum">   12009 </span>            :         }</a>
<a name="12010"><span class="lineNum">   12010 </span>            : #endif</a>
<a name="12011"><span class="lineNum">   12011 </span>            : </a>
<a name="12012"><span class="lineNum">   12012 </span>            : #if 0</a>
<a name="12013"><span class="lineNum">   12013 </span>            :      printf (&quot;SageBuilder::buildNondefiningClassDeclaration_nfi(): (and setting source position) nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="12014"><span class="lineNum">   12014 </span>            : #endif</a>
<a name="12015"><span class="lineNum">   12015 </span>            : </a>
<a name="12016"><span class="lineNum">   12016 </span>            :   // The non-defining declaration asociated with a declaration does not have a</a>
<a name="12017"><span class="lineNum">   12017 </span>            :   // source position...unless it is the position of the defining declaration.</a>
<a name="12018"><span class="lineNum">   12018 </span>            :   // setOneSourcePositionNull(nondefdecl);</a>
<a name="12019"><span class="lineNum">   12019 </span><span class="lineCov">       4813 :      setSourcePosition(nondefdecl);</span></a>
<a name="12020"><span class="lineNum">   12020 </span>            : </a>
<a name="12021"><span class="lineNum">   12021 </span>            :   // This is find for now, but a little later in this function (if we can find a symbol)</a>
<a name="12022"><span class="lineNum">   12022 </span>            :   // we want to find the first non-defining declaration (using the symbol table) and use</a>
<a name="12023"><span class="lineNum">   12023 </span>            :   // that as a paramter to &quot;nondefdecl-&gt;set_firstNondefiningDeclaration()&quot;.</a>
<a name="12024"><span class="lineNum">   12024 </span><span class="lineCov">       4813 :      nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="12025"><span class="lineNum">   12025 </span><span class="lineCov">       4813 :      nondefdecl-&gt;set_definingDeclaration(NULL);</span></a>
<a name="12026"><span class="lineNum">   12026 </span><span class="lineCov">       4813 :      nondefdecl-&gt;setForward();</span></a>
<a name="12027"><span class="lineNum">   12027 </span>            : </a>
<a name="12028"><span class="lineNum">   12028 </span>            :   // This is the structural parent (the logical scope can be different than the parent).</a>
<a name="12029"><span class="lineNum">   12029 </span>            :   // TPS (09/18/2009) added a condition to be able to build this properly</a>
<a name="12030"><span class="lineNum">   12030 </span><span class="lineCov">       4813 :      if (scope == NULL)</span></a>
<a name="12031"><span class="lineNum">   12031 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_parent(topScopeStack());</span></a>
<a name="12032"><span class="lineNum">   12032 </span>            :        else</a>
<a name="12033"><span class="lineNum">   12033 </span><span class="lineCov">       4813 :           nondefdecl-&gt;set_parent(scope);</span></a>
<a name="12034"><span class="lineNum">   12034 </span>            : </a>
<a name="12035"><span class="lineNum">   12035 </span>            :   // This is the logical scope...</a>
<a name="12036"><span class="lineNum">   12036 </span><span class="lineCov">       4813 :      nondefdecl-&gt;set_scope(scope);</span></a>
<a name="12037"><span class="lineNum">   12037 </span>            : </a>
<a name="12038"><span class="lineNum">   12038 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</span></a>
<a name="12039"><span class="lineNum">   12039 </span>            : </a>
<a name="12040"><span class="lineNum">   12040 </span><span class="lineCov">       4813 :      SgClassDeclaration* firstNondefdecl = NULL;</span></a>
<a name="12041"><span class="lineNum">   12041 </span><span class="lineCov">       4813 :      if (scope != NULL)</span></a>
<a name="12042"><span class="lineNum">   12042 </span>            :         {</a>
<a name="12043"><span class="lineNum">   12043 </span>            : #if 0</a>
<a name="12044"><span class="lineNum">   12044 </span>            :           SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="12045"><span class="lineNum">   12045 </span>            :           ROSE_ASSERT(mysymbol != NULL);</a>
<a name="12046"><span class="lineNum">   12046 </span>            : </a>
<a name="12047"><span class="lineNum">   12047 </span>            :        // printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): for nondefdecl = %p built SgClassSymbol = %p \n&quot;,nondefdecl,mysymbol);</a>
<a name="12048"><span class="lineNum">   12048 </span>            : </a>
<a name="12049"><span class="lineNum">   12049 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="12050"><span class="lineNum">   12050 </span>            : </a>
<a name="12051"><span class="lineNum">   12051 </span>            :           scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="12052"><span class="lineNum">   12052 </span>            : #else</a>
<a name="12053"><span class="lineNum">   12053 </span>            :        // DQ (8/22/2012): Use the template arguments to further disambiguate names that would</a>
<a name="12054"><span class="lineNum">   12054 </span>            :        // not include name qualification on template arguments.</a>
<a name="12055"><span class="lineNum">   12055 </span>            :        // Reuse any previously defined symbols (to avoid redundant symbols in the symbol table)</a>
<a name="12056"><span class="lineNum">   12056 </span>            :        // and find the firstNondefiningDeclaration.</a>
<a name="12057"><span class="lineNum">   12057 </span>            :        // SgClassSymbol* mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="12058"><span class="lineNum">   12058 </span>            :        // SgClassSymbol* mysymbol = scope-&gt;lookup_nontemplate_class_symbol(name);</a>
<a name="12059"><span class="lineNum">   12059 </span>            :        // SgClassSymbol* mysymbol = scope-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments);</a>
<a name="12060"><span class="lineNum">   12060 </span><span class="lineCov">       4813 :           SgClassSymbol* mysymbol = scope-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);</span></a>
<a name="12061"><span class="lineNum">   12061 </span>            : </a>
<a name="12062"><span class="lineNum">   12062 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12063"><span class="lineNum">   12063 </span>            :           printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): mysymbol = %p = %s \n&quot;,mysymbol,(mysymbol != NULL) ? mysymbol-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="12064"><span class="lineNum">   12064 </span>            : #endif</a>
<a name="12065"><span class="lineNum">   12065 </span><span class="lineCov">       4813 :           if (mysymbol != NULL)</span></a>
<a name="12066"><span class="lineNum">   12066 </span>            :              {</a>
<a name="12067"><span class="lineNum">   12067 </span><span class="lineCov">        856 :                firstNondefdecl = isSgClassDeclaration(mysymbol-&gt;get_declaration());</span></a>
<a name="12068"><span class="lineNum">   12068 </span><span class="lineCov">        856 :                ROSE_ASSERT(firstNondefdecl != NULL);</span></a>
<a name="12069"><span class="lineNum">   12069 </span>            : </a>
<a name="12070"><span class="lineNum">   12070 </span>            :             // DQ (9/4/2012): Added assertion.</a>
<a name="12071"><span class="lineNum">   12071 </span><span class="lineCov">        856 :                ROSE_ASSERT(firstNondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12072"><span class="lineNum">   12072 </span>            : </a>
<a name="12073"><span class="lineNum">   12073 </span>            :             // DQ (3/22/2012): Now we can built the type and have it use the same nondefining declaration as from the symbol (required to match).</a>
<a name="12074"><span class="lineNum">   12074 </span><span class="lineCov">        856 :                ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="12075"><span class="lineNum">   12075 </span>            : </a>
<a name="12076"><span class="lineNum">   12076 </span><span class="lineCov">        856 :                if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="12077"><span class="lineNum">   12077 </span>            :                   {</a>
<a name="12078"><span class="lineNum">   12078 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12079"><span class="lineNum">   12079 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): Why are we creating a new type instead of reusing the type (firstNondefdecl-&gt;get_type() = %p) from the firstNondefdecl = %p \n&quot;,firstNondefdecl-&gt;get_type(),firstNondefdecl);</a>
<a name="12080"><span class="lineNum">   12080 </span>            : #endif</a>
<a name="12081"><span class="lineNum">   12081 </span>            :                  // Note: It would be better to just call: &quot;nondefdecl-&gt;set_type(firstNondefdecl-&gt;get_type());&quot;</a>
<a name="12082"><span class="lineNum">   12082 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12083"><span class="lineNum">   12083 </span>            :                     printf (&quot;NOTE: Call nondefdecl-&gt;set_type(firstNondefdecl-&gt;get_type()); instead of nondefdecl-&gt;set_type(SgClassType::createType(firstNondefdecl)); \n&quot;);</a>
<a name="12084"><span class="lineNum">   12084 </span>            : #endif</a>
<a name="12085"><span class="lineNum">   12085 </span>            :                  // DQ (3/22/2012): Be careful to use the same declaration as from the symbol.</a>
<a name="12086"><span class="lineNum">   12086 </span>            :                  // nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="12087"><span class="lineNum">   12087 </span><span class="lineCov">        856 :                     nondefdecl-&gt;set_type(SgClassType::createType(firstNondefdecl));</span></a>
<a name="12088"><span class="lineNum">   12088 </span><span class="lineCov">        856 :                     ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12089"><span class="lineNum">   12089 </span>            : #if 0</a>
<a name="12090"><span class="lineNum">   12090 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): built class type: part 1: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="12091"><span class="lineNum">   12091 </span>            : #endif</a>
<a name="12092"><span class="lineNum">   12092 </span>            : </a>
<a name="12093"><span class="lineNum">   12093 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12094"><span class="lineNum">   12094 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="12095"><span class="lineNum">   12095 </span>            : #endif</a>
<a name="12096"><span class="lineNum">   12096 </span>            :                  // DQ (9/4/2012): Added assertion.</a>
<a name="12097"><span class="lineNum">   12097 </span><span class="lineCov">        856 :                     ROSE_ASSERT(nondefdecl-&gt;get_type() == firstNondefdecl-&gt;get_type());</span></a>
<a name="12098"><span class="lineNum">   12098 </span>            :                   }</a>
<a name="12099"><span class="lineNum">   12099 </span>            : </a>
<a name="12100"><span class="lineNum">   12100 </span>            : #if (REUSE_CLASS_DECLARATION_FROM_SYMBOL == 0)</a>
<a name="12101"><span class="lineNum">   12101 </span><span class="lineCov">        856 :                ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12102"><span class="lineNum">   12102 </span><span class="lineCov">        856 :                ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</span></a>
<a name="12103"><span class="lineNum">   12103 </span>            : </a>
<a name="12104"><span class="lineNum">   12104 </span>            :             // DQ (5/18/2014): Added test to match that in set_firstNondefiningDeclaration().</a>
<a name="12105"><span class="lineNum">   12105 </span>            :             // This is a problem for the Boost code after the fix to detec templates vs. template instantiation declarations.</a>
<a name="12106"><span class="lineNum">   12106 </span><span class="lineCov">        856 :                if (nondefdecl-&gt;variantT() != firstNondefdecl-&gt;variantT())</span></a>
<a name="12107"><span class="lineNum">   12107 </span>            :                   {</a>
<a name="12108"><span class="lineNum">   12108 </span><span class="lineNoCov">          0 :                     printf (&quot;ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): nondefdecl = %p = %s IS NOT THE SAME AS firstNondefiningDeclaration = %p = %s \n&quot;,</span></a>
<a name="12109"><span class="lineNum">   12109 </span><span class="lineNoCov">          0 :                          nondefdecl,nondefdecl-&gt;class_name().c_str(),firstNondefdecl,firstNondefdecl-&gt;class_name().c_str());</span></a>
<a name="12110"><span class="lineNum">   12110 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(nondefdecl-&gt;get_file_info() != NULL);</span></a>
<a name="12111"><span class="lineNum">   12111 </span><span class="lineNoCov">          0 :                     nondefdecl-&gt;get_file_info()-&gt;display(&quot;ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): nondefdecl: debug&quot;);</span></a>
<a name="12112"><span class="lineNum">   12112 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(firstNondefdecl-&gt;get_file_info() != NULL);</span></a>
<a name="12113"><span class="lineNum">   12113 </span><span class="lineNoCov">          0 :                     firstNondefdecl-&gt;get_file_info()-&gt;display(&quot;ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): firstNondefdecl: debug&quot;);</span></a>
<a name="12114"><span class="lineNum">   12114 </span>            :                   }</a>
<a name="12115"><span class="lineNum">   12115 </span>            : </a>
<a name="12116"><span class="lineNum">   12116 </span>            :             // DQ (5/18/2014): Added test to match that in set_firstNondefiningDeclaration().</a>
<a name="12117"><span class="lineNum">   12117 </span><span class="lineCov">        856 :                ROSE_ASSERT(nondefdecl-&gt;variantT() == firstNondefdecl-&gt;variantT());</span></a>
<a name="12118"><span class="lineNum">   12118 </span>            : </a>
<a name="12119"><span class="lineNum">   12119 </span><span class="lineCov">        856 :                nondefdecl-&gt;set_firstNondefiningDeclaration(firstNondefdecl);</span></a>
<a name="12120"><span class="lineNum">   12120 </span>            : </a>
<a name="12121"><span class="lineNum">   12121 </span>            :             // This might be NULL if the defining declaration has not been seen yet!</a>
<a name="12122"><span class="lineNum">   12122 </span><span class="lineCov">        856 :                nondefdecl-&gt;set_definingDeclaration(firstNondefdecl-&gt;get_definingDeclaration());</span></a>
<a name="12123"><span class="lineNum">   12123 </span>            : </a>
<a name="12124"><span class="lineNum">   12124 </span>            :             // DQ (3/22/2012): New assertions.</a>
<a name="12125"><span class="lineNum">   12125 </span><span class="lineCov">        856 :                ROSE_ASSERT(firstNondefdecl != NULL);</span></a>
<a name="12126"><span class="lineNum">   12126 </span><span class="lineCov">        856 :                ROSE_ASSERT(firstNondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12127"><span class="lineNum">   12127 </span>            : </a>
<a name="12128"><span class="lineNum">   12128 </span>            :             // DQ (9/16/2012): This is a newly refactored function (call this after we know the firstNondefiningDeclaration is set correctly).</a>
<a name="12129"><span class="lineNum">   12129 </span>            :             // This is called in the other branch (mysymbol == NULL), but there is must be called before the symbol table is appended with</a>
<a name="12130"><span class="lineNum">   12130 </span>            :             // the new symbol for this declaration. So we have to call this in this brach and re can't refactor this be be called one before</a>
<a name="12131"><span class="lineNum">   12131 </span>            :             // both branches or once after both branches.</a>
<a name="12132"><span class="lineNum">   12132 </span><span class="lineCov">        856 :                if (buildTemplateInstantiation == true)</span></a>
<a name="12133"><span class="lineNum">   12133 </span>            :                   {</a>
<a name="12134"><span class="lineNum">   12134 </span><span class="lineCov">        458 :                     setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);</span></a>
<a name="12135"><span class="lineNum">   12135 </span>            :                   }</a>
<a name="12136"><span class="lineNum">   12136 </span>            : </a>
<a name="12137"><span class="lineNum">   12137 </span>            :             // DQ (9/4/2012): We can now assert this because of how the type is constructed above.</a>
<a name="12138"><span class="lineNum">   12138 </span><span class="lineCov">        856 :                ROSE_ASSERT (nondefdecl-&gt;get_type() == firstNondefdecl-&gt;get_type());</span></a>
<a name="12139"><span class="lineNum">   12139 </span>            : </a>
<a name="12140"><span class="lineNum">   12140 </span>            :             // Share the type!</a>
<a name="12141"><span class="lineNum">   12141 </span><span class="lineCov">        856 :                if (nondefdecl-&gt;get_type() != firstNondefdecl-&gt;get_type())</span></a>
<a name="12142"><span class="lineNum">   12142 </span>            :                   {</a>
<a name="12143"><span class="lineNum">   12143 </span>            :                  // Remove the type from the new SgClassDeclaration and set the reference to the type in the firstNondefiningDeclaration.</a>
<a name="12144"><span class="lineNum">   12144 </span><span class="lineNoCov">          0 :                     printf (&quot;Deleting type in associated non-defining declaration (sharing type) nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="12145"><span class="lineNum">   12145 </span><span class="lineNoCov">          0 :                     printf (&quot;Skipping delete of %p so we can maintain unique type pointers \n&quot;,nondefdecl-&gt;get_type());</span></a>
<a name="12146"><span class="lineNum">   12146 </span>            :                  // delete nondefdecl-&gt;get_type();</a>
<a name="12147"><span class="lineNum">   12147 </span><span class="lineNoCov">          0 :                     printf (&quot;Setting the new type to be from firstNondefdecl = %p (sharing type) firstNondefdecl-&gt;get_type() = %p = %s \n&quot;,firstNondefdecl,firstNondefdecl-&gt;get_type(),firstNondefdecl-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="12148"><span class="lineNum">   12148 </span><span class="lineNoCov">          0 :                     nondefdecl-&gt;set_type(firstNondefdecl-&gt;get_type());</span></a>
<a name="12149"><span class="lineNum">   12149 </span>            : #if 1</a>
<a name="12150"><span class="lineNum">   12150 </span>            :                  // DQ (12/13/2011): Is this executed!</a>
<a name="12151"><span class="lineNum">   12151 </span><span class="lineNoCov">          0 :                     printf (&quot;Unclear if this code is executed \n&quot;);</span></a>
<a name="12152"><span class="lineNum">   12152 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="12153"><span class="lineNum">   12153 </span>            : #endif</a>
<a name="12154"><span class="lineNum">   12154 </span>            :                   }</a>
<a name="12155"><span class="lineNum">   12155 </span>            : #else</a>
<a name="12156"><span class="lineNum">   12156 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="12157"><span class="lineNum">   12157 </span>            : </a>
<a name="12158"><span class="lineNum">   12158 </span>            :                ROSE_ASSERT(nondefdecl == NULL);</a>
<a name="12159"><span class="lineNum">   12159 </span>            : #endif</a>
<a name="12160"><span class="lineNum">   12160 </span>            :             // This function should return a new nondefining declaration each time (to support multile class prototypes!).</a>
<a name="12161"><span class="lineNum">   12161 </span>            :             // nondefdecl = firstNondefdecl;</a>
<a name="12162"><span class="lineNum">   12162 </span>            :              }</a>
<a name="12163"><span class="lineNum">   12163 </span>            :             else</a>
<a name="12164"><span class="lineNum">   12164 </span>            :              {</a>
<a name="12165"><span class="lineNum">   12165 </span>            : #if REUSE_CLASS_DECLARATION_FROM_SYMBOL</a>
<a name="12166"><span class="lineNum">   12166 </span>            :             // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.</a>
<a name="12167"><span class="lineNum">   12167 </span>            : </a>
<a name="12168"><span class="lineNum">   12168 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="12169"><span class="lineNum">   12169 </span>            : </a>
<a name="12170"><span class="lineNum">   12170 </span>            :                nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);</a>
<a name="12171"><span class="lineNum">   12171 </span>            : </a>
<a name="12172"><span class="lineNum">   12172 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="12173"><span class="lineNum">   12173 </span>            : </a>
<a name="12174"><span class="lineNum">   12174 </span>            :                ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="12175"><span class="lineNum">   12175 </span>            :                if (nondefdecl-&gt;get_type() == NULL)</a>
<a name="12176"><span class="lineNum">   12176 </span>            :                     nondefdel-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="12177"><span class="lineNum">   12177 </span>            : </a>
<a name="12178"><span class="lineNum">   12178 </span>            :                printf (&quot;SageBuilder::buildNondefiningClassDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="12179"><span class="lineNum">   12179 </span>            : </a>
<a name="12180"><span class="lineNum">   12180 </span>            :                setOneSourcePositionNull(nondefdecl);</a>
<a name="12181"><span class="lineNum">   12181 </span>            : </a>
<a name="12182"><span class="lineNum">   12182 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="12183"><span class="lineNum">   12183 </span>            : </a>
<a name="12184"><span class="lineNum">   12184 </span>            :                nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="12185"><span class="lineNum">   12185 </span>            :                nondefdecl-&gt;set_definingDeclaration(NULL);</a>
<a name="12186"><span class="lineNum">   12186 </span>            :                nondefdecl-&gt;setForward();</a>
<a name="12187"><span class="lineNum">   12187 </span>            : #endif</a>
<a name="12188"><span class="lineNum">   12188 </span>            : </a>
<a name="12189"><span class="lineNum">   12189 </span>            :             // DQ (6/9/2013): Added assertion to debug test2013_198.C.</a>
<a name="12190"><span class="lineNum">   12190 </span><span class="lineCov">       3957 :                ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="12191"><span class="lineNum">   12191 </span>            : </a>
<a name="12192"><span class="lineNum">   12192 </span><span class="lineCov">       3957 :                mysymbol = new SgClassSymbol(nondefdecl);</span></a>
<a name="12193"><span class="lineNum">   12193 </span><span class="lineCov">       3957 :                firstNondefdecl = nondefdecl;</span></a>
<a name="12194"><span class="lineNum">   12194 </span>            : </a>
<a name="12195"><span class="lineNum">   12195 </span>            :             // DQ (6/9/2013): Adding assertions to make sure that symbols only reference non-defining declarations.</a>
<a name="12196"><span class="lineNum">   12196 </span><span class="lineCov">       3957 :                ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="12197"><span class="lineNum">   12197 </span><span class="lineCov">       3957 :                ROSE_ASSERT(mysymbol-&gt;get_declaration()-&gt;get_definition() == NULL);</span></a>
<a name="12198"><span class="lineNum">   12198 </span>            : </a>
<a name="12199"><span class="lineNum">   12199 </span>            :             // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).</a>
<a name="12200"><span class="lineNum">   12200 </span>            :             // Note that since the symbol tables use the template arguments associated with the declaration it is best to</a>
<a name="12201"><span class="lineNum">   12201 </span>            :             // fixup the template arguments before the symbol table is fixup to have a symbol for this declaration. So we</a>
<a name="12202"><span class="lineNum">   12202 </span>            :             // fixup the template arguments here (just after we know that the firstNondefiningDeclaration is set correctly</a>
<a name="12203"><span class="lineNum">   12203 </span>            :             // and just before the symbol is inserted into the symbol table.</a>
<a name="12204"><span class="lineNum">   12204 </span><span class="lineCov">       3957 :                if (buildTemplateInstantiation == true)</span></a>
<a name="12205"><span class="lineNum">   12205 </span>            :                   {</a>
<a name="12206"><span class="lineNum">   12206 </span><span class="lineCov">       2639 :                     setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);</span></a>
<a name="12207"><span class="lineNum">   12207 </span>            :                   }</a>
<a name="12208"><span class="lineNum">   12208 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="12209"><span class="lineNum">   12209 </span>            :                printf (&quot;BEFORE scope-&gt;insert_symbol(): scope = %p = %s nameWithTemplateArguments = %s mysymbol = %p = %s \n&quot;,</a>
<a name="12210"><span class="lineNum">   12210 </span>            :                     scope,scope-&gt;class_name().c_str(),nameWithTemplateArguments.str(),mysymbol,mysymbol-&gt;class_name().c_str());</a>
<a name="12211"><span class="lineNum">   12211 </span>            : #endif</a>
<a name="12212"><span class="lineNum">   12212 </span>            : </a>
<a name="12213"><span class="lineNum">   12213 </span>            :             // scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="12214"><span class="lineNum">   12214 </span><span class="lineCov">       3957 :                scope-&gt;insert_symbol(nameWithTemplateArguments, mysymbol);</span></a>
<a name="12215"><span class="lineNum">   12215 </span>            : </a>
<a name="12216"><span class="lineNum">   12216 </span>            :             // DQ (3/22/2012): Now we can built the type and have it use the same nondefining declaration as from the symbol (required to match).</a>
<a name="12217"><span class="lineNum">   12217 </span><span class="lineCov">       3957 :                ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="12218"><span class="lineNum">   12218 </span><span class="lineCov">       3957 :                if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="12219"><span class="lineNum">   12219 </span>            :                   {</a>
<a name="12220"><span class="lineNum">   12220 </span>            : #if 0</a>
<a name="12221"><span class="lineNum">   12221 </span>            :                     printf (&quot;In buildNondefiningClassDeclaration_nfi(): nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="12222"><span class="lineNum">   12222 </span>            :                     printf (&quot;In buildNondefiningClassDeclaration_nfi(): nondefdecl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="12223"><span class="lineNum">   12223 </span>            : #endif</a>
<a name="12224"><span class="lineNum">   12224 </span><span class="lineCov">       3957 :                     nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</span></a>
<a name="12225"><span class="lineNum">   12225 </span>            : #if 0</a>
<a name="12226"><span class="lineNum">   12226 </span>            :                     printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): built class type: part 2: nondefdecl-&gt;get_type() = %p = %s = %s \n&quot;,</a>
<a name="12227"><span class="lineNum">   12227 </span>            :                          nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str(),nondefdecl-&gt;get_type()-&gt;unparseToString().c_str());</a>
<a name="12228"><span class="lineNum">   12228 </span>            : #endif</a>
<a name="12229"><span class="lineNum">   12229 </span>            :                   }</a>
<a name="12230"><span class="lineNum">   12230 </span>            : </a>
<a name="12231"><span class="lineNum">   12231 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12232"><span class="lineNum">   12232 </span>            :                printf (&quot;NOTE: In buildNondefiningClassDeclaration_nfi(): 2nd time this is a performance issue (maybe) to call the lookup_nontemplate_class_symbol() again \n&quot;);</a>
<a name="12233"><span class="lineNum">   12233 </span>            : #endif</a>
<a name="12234"><span class="lineNum">   12234 </span>            :             // DQ (8/22/2012): Use the template arguments to further disambiguate names that would</a>
<a name="12235"><span class="lineNum">   12235 </span>            :             // not include name qualification on template arguments.</a>
<a name="12236"><span class="lineNum">   12236 </span>            :             // DQ (12/27/2011): Added new test.</a>
<a name="12237"><span class="lineNum">   12237 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_nontemplate_class_symbol(name) != NULL);</a>
<a name="12238"><span class="lineNum">   12238 </span>            :             // TV (07/01/2013): this assertion fail when building basic class (buildTemplateInstantiation = false , templateArgumentsList = NULL)</a>
<a name="12239"><span class="lineNum">   12239 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList) != NULL);</a>
<a name="12240"><span class="lineNum">   12240 </span>            : </a>
<a name="12241"><span class="lineNum">   12241 </span>            :             // DQ (6/9/2013): Added test to make sure that symbols only reference non-defining declarations.</a>
<a name="12242"><span class="lineNum">   12242 </span><span class="lineCov">       3957 :                SgClassSymbol* temp_classSymbol = nondefdecl-&gt;get_scope()-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);</span></a>
<a name="12243"><span class="lineNum">   12243 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="12244"><span class="lineNum">   12244 </span>            :             // DQ (12/28/2018): When can this be NULL?</a>
<a name="12245"><span class="lineNum">   12245 </span>            :                printf (&quot;In buildNondefiningClassDeclaration_nfi(): temp_classSymbol = %p \n&quot;,temp_classSymbol);</a>
<a name="12246"><span class="lineNum">   12246 </span>            :                printf (&quot;In buildNondefiningClassDeclaration_nfi(): nondefdecl-&gt;get_scope() = %p = %s scope = %p \n&quot;,nondefdecl-&gt;get_scope(),nondefdecl-&gt;get_scope()-&gt;class_name().c_str(),scope);</a>
<a name="12247"><span class="lineNum">   12247 </span>            : </a>
<a name="12248"><span class="lineNum">   12248 </span>            :                printf (&quot;In buildNondefiningClassDeclaration_nfi(): nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="12249"><span class="lineNum">   12249 </span>            :                if (templateArgumentsList != NULL)</a>
<a name="12250"><span class="lineNum">   12250 </span>            :                   {</a>
<a name="12251"><span class="lineNum">   12251 </span>            :                     printf (&quot;   --- templateArgumentsList elements: \n&quot;);</a>
<a name="12252"><span class="lineNum">   12252 </span>            :                     for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="12253"><span class="lineNum">   12253 </span>            :                        {</a>
<a name="12254"><span class="lineNum">   12254 </span>            :                          printf (&quot;   --- --- templateArgumentsList-&gt;[%zu] = %p \n&quot;,i,templateArgumentsList-&gt;operator[](i));</a>
<a name="12255"><span class="lineNum">   12255 </span>            :                          printf (&quot;   --- --- templateArgumentsList-&gt;[%zu] = %s \n&quot;,i,templateArgumentsList-&gt;operator[](i)-&gt;class_name().c_str());</a>
<a name="12256"><span class="lineNum">   12256 </span>            :                          templateArgumentsList-&gt;operator[](i)-&gt;display(&quot;In SageBuilder::buildNondefiningClassDeclaration_nfi()&quot;);</a>
<a name="12257"><span class="lineNum">   12257 </span>            :                        }</a>
<a name="12258"><span class="lineNum">   12258 </span>            :                   }</a>
<a name="12259"><span class="lineNum">   12259 </span>            : #endif</a>
<a name="12260"><span class="lineNum">   12260 </span>            :             // DQ (12/28/2018): When can this be NULL?  When we call lookup_class_symbol() later it is NULL, so test it here.</a>
<a name="12261"><span class="lineNum">   12261 </span><span class="lineCov">       3957 :                ROSE_ASSERT(nondefdecl-&gt;get_scope()-&gt;lookup_class_symbol(nameWithTemplateArguments,templateArgumentsList) != NULL);</span></a>
<a name="12262"><span class="lineNum">   12262 </span><span class="lineCov">       3957 :                ROSE_ASSERT(nondefdecl-&gt;get_scope() == scope);</span></a>
<a name="12263"><span class="lineNum">   12263 </span>            : </a>
<a name="12264"><span class="lineNum">   12264 </span>            :             // TV (07/01/2013): temp_classSymbol can be NULL, but lookup_class_symbol return a symbol</a>
<a name="12265"><span class="lineNum">   12265 </span>            :             // ROSE_ASSERT(temp_classSymbol-&gt;get_declaration()-&gt;get_definition() == NULL);</a>
<a name="12266"><span class="lineNum">   12266 </span><span class="lineCov">       3957 :                ROSE_ASSERT(temp_classSymbol == NULL || temp_classSymbol-&gt;get_declaration()-&gt;get_definition() == NULL);</span></a>
<a name="12267"><span class="lineNum">   12267 </span>            :              }</a>
<a name="12268"><span class="lineNum">   12268 </span>            : </a>
<a name="12269"><span class="lineNum">   12269 </span><span class="lineCov">       4813 :           ROSE_ASSERT(mysymbol != NULL);</span></a>
<a name="12270"><span class="lineNum">   12270 </span><span class="lineCov">       4813 :           ROSE_ASSERT(firstNondefdecl != NULL);</span></a>
<a name="12271"><span class="lineNum">   12271 </span>            : #endif</a>
<a name="12272"><span class="lineNum">   12272 </span><span class="lineCov">       4813 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="12273"><span class="lineNum">   12273 </span>            : </a>
<a name="12274"><span class="lineNum">   12274 </span>            :        // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).</a>
<a name="12275"><span class="lineNum">   12275 </span>            :        // TPS (09/18/2009) added a condition to be able to build this properly</a>
<a name="12276"><span class="lineNum">   12276 </span><span class="lineCov">       4813 :           if (scope==NULL)</span></a>
<a name="12277"><span class="lineNum">   12277 </span>            :             nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="12278"><span class="lineNum">   12278 </span>            :           else</a>
<a name="12279"><span class="lineNum">   12279 </span><span class="lineCov">       4813 :             nondefdecl-&gt;set_parent(scope);</span></a>
<a name="12280"><span class="lineNum">   12280 </span>            :         }</a>
<a name="12281"><span class="lineNum">   12281 </span>            : </a>
<a name="12282"><span class="lineNum">   12282 </span>            :   // The support for SgEnumDeclaration handles the type, but why not for SgClassDeclaration?</a>
<a name="12283"><span class="lineNum">   12283 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12284"><span class="lineNum">   12284 </span>            : </a>
<a name="12285"><span class="lineNum">   12285 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</span></a>
<a name="12286"><span class="lineNum">   12286 </span>            : </a>
<a name="12287"><span class="lineNum">   12287 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="12288"><span class="lineNum">   12288 </span>            :      printf (&quot;NOTE: In buildNondefiningClassDeclaration_nfi(): 3rd time this is a performance issue (maybe) to call the lookup_nontemplate_class_symbol() again \n&quot;);</a>
<a name="12289"><span class="lineNum">   12289 </span>            : #endif</a>
<a name="12290"><span class="lineNum">   12290 </span>            : </a>
<a name="12291"><span class="lineNum">   12291 </span>            :   // DQ (8/22/2012): Use the template arguments to further disambiguate names that would not include name qualification on template arguments.</a>
<a name="12292"><span class="lineNum">   12292 </span>            :   // DQ (12/27/2011): Added new test.</a>
<a name="12293"><span class="lineNum">   12293 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_scope()-&gt;lookup_nontemplate_class_symbol(name) != NULL);</a>
<a name="12294"><span class="lineNum">   12294 </span>            :   // TV (07/01/2013): this assertion fail when building basic class (buildTemplateInstantiation = false , templateArgumentsList = NULL)</a>
<a name="12295"><span class="lineNum">   12295 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_scope()-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList) != NULL);</a>
<a name="12296"><span class="lineNum">   12296 </span>            : </a>
<a name="12297"><span class="lineNum">   12297 </span>            :   // DQ (6/9/2013): Added test to make sure that symbols only reference non-defining declarations.</a>
<a name="12298"><span class="lineNum">   12298 </span><span class="lineCov">       4813 :      SgClassSymbol* temp_classSymbol = nondefdecl-&gt;get_scope()-&gt;lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);</span></a>
<a name="12299"><span class="lineNum">   12299 </span>            :   // TV (07/01/2013): temp_classSymbol can be NULL, but lookup_class_symbol return a symbol</a>
<a name="12300"><span class="lineNum">   12300 </span><span class="lineCov">       4813 :      ROSE_ASSERT(temp_classSymbol == NULL || temp_classSymbol-&gt;get_declaration()-&gt;get_definition() == NULL);</span></a>
<a name="12301"><span class="lineNum">   12301 </span>            : </a>
<a name="12302"><span class="lineNum">   12302 </span>            :   // DQ (3/9/2018): Added assertion.</a>
<a name="12303"><span class="lineNum">   12303 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12304"><span class="lineNum">   12304 </span><span class="lineCov">       4813 :      ROSE_ASSERT(nondefdecl-&gt;get_name() == nameWithTemplateArguments);</span></a>
<a name="12305"><span class="lineNum">   12305 </span>            : </a>
<a name="12306"><span class="lineNum">   12306 </span>            :   // DQ (3/9/2018): Test the consistancy of the template instantiation name.</a>
<a name="12307"><span class="lineNum">   12307 </span><span class="lineCov">       4813 :      if (isSgTemplateInstantiationDecl(nondefdecl) != NULL)</span></a>
<a name="12308"><span class="lineNum">   12308 </span>            :         {</a>
<a name="12309"><span class="lineNum">   12309 </span><span class="lineCov">       3097 :           SgTemplateInstantiationDecl* templateInstantiationDecl = isSgTemplateInstantiationDecl(nondefdecl);</span></a>
<a name="12310"><span class="lineNum">   12310 </span><span class="lineCov">       3097 :           SgName finalName = appendTemplateArgumentsToName(templateInstantiationDecl-&gt;get_templateName(),templateInstantiationDecl-&gt;get_templateArguments());</span></a>
<a name="12311"><span class="lineNum">   12311 </span><span class="lineCov">       3097 :           ROSE_ASSERT(finalName == nameWithTemplateArguments);</span></a>
<a name="12312"><span class="lineNum">   12312 </span><span class="lineCov">       3097 :           ROSE_ASSERT(finalName == nondefdecl-&gt;get_name());</span></a>
<a name="12313"><span class="lineNum">   12313 </span>            :         }</a>
<a name="12314"><span class="lineNum">   12314 </span>            : </a>
<a name="12315"><span class="lineNum">   12315 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="12316"><span class="lineNum">   12316 </span>            :      printf (&quot;Leaving buildNondefiningClassDeclaration_nfi(): nondefdecl = %p nondefdecl-&gt;unparseNameToString() = %s \n&quot;,nondefdecl,nondefdecl-&gt;unparseNameToString().c_str());</a>
<a name="12317"><span class="lineNum">   12317 </span>            :      printf (&quot; --- nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="12318"><span class="lineNum">   12318 </span>            : #endif</a>
<a name="12319"><span class="lineNum">   12319 </span>            : </a>
<a name="12320"><span class="lineNum">   12320 </span>            : #if DEBUG_NONDEFINING_CLASS_DECLARATION</a>
<a name="12321"><span class="lineNum">   12321 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="12322"><span class="lineNum">   12322 </span>            :      printf (&quot;Leaving buildNondefiningClassDeclaration_nfi(): Calling find_symbol_from_declaration() \n&quot;);</a>
<a name="12323"><span class="lineNum">   12323 </span>            :      SgSymbol* test_symbol = nondefdecl-&gt;get_scope()-&gt;find_symbol_from_declaration(nondefdecl);</a>
<a name="12324"><span class="lineNum">   12324 </span>            : </a>
<a name="12325"><span class="lineNum">   12325 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="12326"><span class="lineNum">   12326 </span>            :      printf (&quot;Leaving buildNondefiningClassDeclaration_nfi(): Calling get_symbol_from_symbol_table() \n&quot;);</a>
<a name="12327"><span class="lineNum">   12327 </span>            :      ROSE_ASSERT(nondefdecl-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="12328"><span class="lineNum">   12328 </span>            : #endif</a>
<a name="12329"><span class="lineNum">   12329 </span>            : </a>
<a name="12330"><span class="lineNum">   12330 </span><span class="lineCov">       9626 :      return nondefdecl;</span></a>
<a name="12331"><span class="lineNum">   12331 </span>            :    }</a>
<a name="12332"><span class="lineNum">   12332 </span>            : </a>
<a name="12333"><span class="lineNum">   12333 </span>            : SgStmtDeclarationStatement*</a>
<a name="12334"><span class="lineNum">   12334 </span><span class="lineNoCov">          0 : SageBuilder::buildStmtDeclarationStatement_nfi(SgStatement* stmt) {</span></a>
<a name="12335"><span class="lineNum">   12335 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(stmt != NULL);</span></a>
<a name="12336"><span class="lineNum">   12336 </span>            : </a>
<a name="12337"><span class="lineNum">   12337 </span><span class="lineNoCov">          0 :     SgStmtDeclarationStatement* result = new SgStmtDeclarationStatement(stmt);</span></a>
<a name="12338"><span class="lineNum">   12338 </span><span class="lineNoCov">          0 :     stmt-&gt;set_parent(result);</span></a>
<a name="12339"><span class="lineNum">   12339 </span>            : </a>
<a name="12340"><span class="lineNum">   12340 </span><span class="lineNoCov">          0 :     result-&gt;set_definingDeclaration(result);</span></a>
<a name="12341"><span class="lineNum">   12341 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="12342"><span class="lineNum">   12342 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="12343"><span class="lineNum">   12343 </span>            : }</a>
<a name="12344"><span class="lineNum">   12344 </span>            : </a>
<a name="12345"><span class="lineNum">   12345 </span>            : SgStmtDeclarationStatement*</a>
<a name="12346"><span class="lineNum">   12346 </span><span class="lineNoCov">          0 : SageBuilder::buildStmtDeclarationStatement(SgStatement* stmt) {</span></a>
<a name="12347"><span class="lineNum">   12347 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(stmt != NULL);</span></a>
<a name="12348"><span class="lineNum">   12348 </span>            : </a>
<a name="12349"><span class="lineNum">   12349 </span><span class="lineNoCov">          0 :     SgStmtDeclarationStatement* result = new SgStmtDeclarationStatement(stmt);</span></a>
<a name="12350"><span class="lineNum">   12350 </span><span class="lineNoCov">          0 :     stmt-&gt;set_parent(result);</span></a>
<a name="12351"><span class="lineNum">   12351 </span>            : </a>
<a name="12352"><span class="lineNum">   12352 </span><span class="lineNoCov">          0 :     result-&gt;set_definingDeclaration(result);</span></a>
<a name="12353"><span class="lineNum">   12353 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="12354"><span class="lineNum">   12354 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="12355"><span class="lineNum">   12355 </span>            : }</a>
<a name="12356"><span class="lineNum">   12356 </span>            : </a>
<a name="12357"><span class="lineNum">   12357 </span>            : // This should take a SgClassDeclaration::class_types kind parameter!</a>
<a name="12358"><span class="lineNum">   12358 </span><span class="lineCov">          4 : SgClassDeclaration * SageBuilder::buildStructDeclaration(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="12359"><span class="lineNum">   12359 </span>            :    {</a>
<a name="12360"><span class="lineNum">   12360 </span>            : #if 0</a>
<a name="12361"><span class="lineNum">   12361 </span>            : </a>
<a name="12362"><span class="lineNum">   12362 </span>            :      if (scope == NULL)</a>
<a name="12363"><span class="lineNum">   12363 </span>            :           scope = SageBuilder::topScopeStack();</a>
<a name="12364"><span class="lineNum">   12364 </span>            : </a>
<a name="12365"><span class="lineNum">   12365 </span>            :   // TODO How about class type??</a>
<a name="12366"><span class="lineNum">   12366 </span>            :   // build defining declaration</a>
<a name="12367"><span class="lineNum">   12367 </span>            :      SgClassDefinition* classDef = buildClassDefinition();</a>
<a name="12368"><span class="lineNum">   12368 </span>            : </a>
<a name="12369"><span class="lineNum">   12369 </span>            :      SgClassDeclaration* defdecl = new SgClassDeclaration (name,SgClassDeclaration::e_struct,NULL,classDef);</a>
<a name="12370"><span class="lineNum">   12370 </span>            :      ROSE_ASSERT(defdecl);</a>
<a name="12371"><span class="lineNum">   12371 </span>            :      setOneSourcePositionForTransformation(defdecl);</a>
<a name="12372"><span class="lineNum">   12372 </span>            :   // constructor is side-effect free</a>
<a name="12373"><span class="lineNum">   12373 </span>            :      classDef-&gt;set_declaration(defdecl);</a>
<a name="12374"><span class="lineNum">   12374 </span>            :      defdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12375"><span class="lineNum">   12375 </span>            : </a>
<a name="12376"><span class="lineNum">   12376 </span>            :   // build the nondefining declaration</a>
<a name="12377"><span class="lineNum">   12377 </span>            :      SgClassDeclaration* nondefdecl = new SgClassDeclaration (name,SgClassDeclaration::e_struct,NULL,NULL);</a>
<a name="12378"><span class="lineNum">   12378 </span>            :      ROSE_ASSERT(nondefdecl);</a>
<a name="12379"><span class="lineNum">   12379 </span>            : </a>
<a name="12380"><span class="lineNum">   12380 </span>            :      setOneSourcePositionForTransformation(nondefdecl);</a>
<a name="12381"><span class="lineNum">   12381 </span>            :      nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="12382"><span class="lineNum">   12382 </span>            :      nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12383"><span class="lineNum">   12383 </span>            :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="12384"><span class="lineNum">   12384 </span>            :      nondefdecl-&gt;setForward();</a>
<a name="12385"><span class="lineNum">   12385 </span>            : </a>
<a name="12386"><span class="lineNum">   12386 </span>            :      if (scope !=NULL )  // put into fixStructDeclaration() or alike later on</a>
<a name="12387"><span class="lineNum">   12387 </span>            :         {</a>
<a name="12388"><span class="lineNum">   12388 </span>            :           fixStructDeclaration(nondefdecl,scope);</a>
<a name="12389"><span class="lineNum">   12389 </span>            :           fixStructDeclaration(defdecl,scope);</a>
<a name="12390"><span class="lineNum">   12390 </span>            : #if 0</a>
<a name="12391"><span class="lineNum">   12391 </span>            :           SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="12392"><span class="lineNum">   12392 </span>            :           ROSE_ASSERT(mysymbol);</a>
<a name="12393"><span class="lineNum">   12393 </span>            :           scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="12394"><span class="lineNum">   12394 </span>            :           defdecl-&gt;set_scope(scope);</a>
<a name="12395"><span class="lineNum">   12395 </span>            :           nondefdecl-&gt;set_scope(scope);</a>
<a name="12396"><span class="lineNum">   12396 </span>            :           defdecl-&gt;set_parent(scope);</a>
<a name="12397"><span class="lineNum">   12397 </span>            :           nondefdecl-&gt;set_parent(scope);</a>
<a name="12398"><span class="lineNum">   12398 </span>            : #endif</a>
<a name="12399"><span class="lineNum">   12399 </span>            :         }</a>
<a name="12400"><span class="lineNum">   12400 </span>            : #else</a>
<a name="12401"><span class="lineNum">   12401 </span>            :   // DQ (1/24/2009): Refactored to use the buildStructDeclaration_nfi function.</a>
<a name="12402"><span class="lineNum">   12402 </span>            :   // (if this work it needs to be done uniformally for the other nfi functions)</a>
<a name="12403"><span class="lineNum">   12403 </span>            :   // Also, &quot;_nfi&quot; is not a great name.</a>
<a name="12404"><span class="lineNum">   12404 </span>            :   // SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL);</a>
<a name="12405"><span class="lineNum">   12405 </span><span class="lineCov">          4 :      bool buildTemplateInstantiation = false;</span></a>
<a name="12406"><span class="lineNum">   12406 </span>            :   // SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL,buildTemplateInstantiation);</a>
<a name="12407"><span class="lineNum">   12407 </span><span class="lineCov">          4 :      SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL,buildTemplateInstantiation,NULL);</span></a>
<a name="12408"><span class="lineNum">   12408 </span>            : </a>
<a name="12409"><span class="lineNum">   12409 </span><span class="lineCov">          4 :      setOneSourcePositionForTransformation(defdecl);</span></a>
<a name="12410"><span class="lineNum">   12410 </span><span class="lineCov">          4 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12411"><span class="lineNum">   12411 </span><span class="lineCov">          4 :      setOneSourcePositionForTransformation(defdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12412"><span class="lineNum">   12412 </span>            : #endif</a>
<a name="12413"><span class="lineNum">   12413 </span>            : </a>
<a name="12414"><span class="lineNum">   12414 </span>            :   // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="12415"><span class="lineNum">   12415 </span>            :   // break the existing interface. Need to discuss this with Liao.</a>
<a name="12416"><span class="lineNum">   12416 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_parent() != NULL);</a>
<a name="12417"><span class="lineNum">   12417 </span>            : </a>
<a name="12418"><span class="lineNum">   12418 </span><span class="lineCov">          4 :      return defdecl;</span></a>
<a name="12419"><span class="lineNum">   12419 </span>            :    }</a>
<a name="12420"><span class="lineNum">   12420 </span>            : </a>
<a name="12421"><span class="lineNum">   12421 </span>            : //! Build a Fortran derived type declaration.</a>
<a name="12422"><span class="lineNum">   12422 </span><span class="lineNoCov">          0 : SgDerivedTypeStatement * SageBuilder::buildDerivedTypeStatement(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="12423"><span class="lineNum">   12423 </span>            :    {</a>
<a name="12424"><span class="lineNum">   12424 </span><span class="lineNoCov">          0 :      SgClassDeclaration::class_types kind = SgClassDeclaration::e_struct;</span></a>
<a name="12425"><span class="lineNum">   12425 </span><span class="lineNoCov">          0 :      SgDerivedTypeStatement* type_decl = buildClassDeclarationStatement_nfi &lt;SgDerivedTypeStatement&gt; (name, kind, scope);</span></a>
<a name="12426"><span class="lineNum">   12426 </span>            : </a>
<a name="12427"><span class="lineNum">   12427 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(type_decl);</span></a>
<a name="12428"><span class="lineNum">   12428 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(type_decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12429"><span class="lineNum">   12429 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(type_decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12430"><span class="lineNum">   12430 </span>            : </a>
<a name="12431"><span class="lineNum">   12431 </span><span class="lineNoCov">          0 :      return type_decl;</span></a>
<a name="12432"><span class="lineNum">   12432 </span>            :    }</a>
<a name="12433"><span class="lineNum">   12433 </span>            : </a>
<a name="12434"><span class="lineNum">   12434 </span>            : //! Build a Fortran module declaration.</a>
<a name="12435"><span class="lineNum">   12435 </span><span class="lineNoCov">          0 : SgModuleStatement * SageBuilder::buildModuleStatement(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="12436"><span class="lineNum">   12436 </span>            :    {</a>
<a name="12437"><span class="lineNum">   12437 </span><span class="lineNoCov">          0 :      SgClassDeclaration::class_types kind = SgClassDeclaration::e_fortran_module;</span></a>
<a name="12438"><span class="lineNum">   12438 </span><span class="lineNoCov">          0 :      SgModuleStatement* module_stmt = buildClassDeclarationStatement_nfi &lt;SgModuleStatement&gt; (name, kind, scope);</span></a>
<a name="12439"><span class="lineNum">   12439 </span>            : </a>
<a name="12440"><span class="lineNum">   12440 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(module_stmt);</span></a>
<a name="12441"><span class="lineNum">   12441 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(module_stmt-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12442"><span class="lineNum">   12442 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(module_stmt-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12443"><span class="lineNum">   12443 </span>            : </a>
<a name="12444"><span class="lineNum">   12444 </span><span class="lineNoCov">          0 :      return module_stmt;</span></a>
<a name="12445"><span class="lineNum">   12445 </span>            :    }</a>
<a name="12446"><span class="lineNum">   12446 </span>            : </a>
<a name="12447"><span class="lineNum">   12447 </span>            : //! Build a generic class declaration statement (SgClassDeclaration or subclass).</a>
<a name="12448"><span class="lineNum">   12448 </span>            : template &lt;class DeclClass&gt; DeclClass *</a>
<a name="12449"><span class="lineNum">   12449 </span><span class="lineNoCov">          0 : SageBuilder::buildClassDeclarationStatement_nfi(const SgName &amp; name, SgClassDeclaration::class_types kind,</span></a>
<a name="12450"><span class="lineNum">   12450 </span>            :                                                 SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl)</a>
<a name="12451"><span class="lineNum">   12451 </span>            :    {</a>
<a name="12452"><span class="lineNum">   12452 </span>            :   // DQ (3/15/2012): Added function to build C++ class (builds both the non-defining and defining declarations; in that order).</a>
<a name="12453"><span class="lineNum">   12453 </span>            :   // The implementation of this function could be simplified to directly call both:</a>
<a name="12454"><span class="lineNum">   12454 </span>            :   //    SgClassDeclaration* buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope );</a>
<a name="12455"><span class="lineNum">   12455 </span>            :   // and</a>
<a name="12456"><span class="lineNum">   12456 </span>            :   //    SgClassDeclaration* buildDefiningClassDeclaration    ( SgName name, SgScopeStatement* scope );</a>
<a name="12457"><span class="lineNum">   12457 </span>            :   // This might refactor the implementation nicely.</a>
<a name="12458"><span class="lineNum">   12458 </span>            : </a>
<a name="12459"><span class="lineNum">   12459 </span><span class="lineNoCov">          0 :      if (scope == NULL)</span></a>
<a name="12460"><span class="lineNum">   12460 </span>            :         {</a>
<a name="12461"><span class="lineNum">   12461 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="12462"><span class="lineNum">   12462 </span>            :         }</a>
<a name="12463"><span class="lineNum">   12463 </span>            : </a>
<a name="12464"><span class="lineNum">   12464 </span>            :   // Step 1. Build the nondefining declaration (but only if the input nonDefiningDecl pointer was NULL and it does not exist)</a>
<a name="12465"><span class="lineNum">   12465 </span>            :   // -----------------------------------------</a>
<a name="12466"><span class="lineNum">   12466 </span>            :   //</a>
<a name="12467"><span class="lineNum">   12467 </span>            : </a>
<a name="12468"><span class="lineNum">   12468 </span>            :   // Get the nondefining declaration from the symbol if it has been built (if this works,</a>
<a name="12469"><span class="lineNum">   12469 </span>            :   // then we likely don't need the &quot;SgClassDeclaration* nonDefiningDecl&quot; parameter).</a>
<a name="12470"><span class="lineNum">   12470 </span>            : </a>
<a name="12471"><span class="lineNum">   12471 </span><span class="lineNoCov">          0 :      SgClassDeclaration* nondefdecl = NULL;</span></a>
<a name="12472"><span class="lineNum">   12472 </span><span class="lineNoCov">          0 :      SgClassSymbol* mysymbol = NULL;</span></a>
<a name="12473"><span class="lineNum">   12473 </span>            : </a>
<a name="12474"><span class="lineNum">   12474 </span><span class="lineNoCov">          0 :      if (scope != NULL)</span></a>
<a name="12475"><span class="lineNum">   12475 </span>            :         {</a>
<a name="12476"><span class="lineNum">   12476 </span>            :         // DQ (10/10/2015): look up the correct type of symbol.</a>
<a name="12477"><span class="lineNum">   12477 </span><span class="lineNoCov">          0 :            mysymbol = scope-&gt;lookup_class_symbol(name);</span></a>
<a name="12478"><span class="lineNum">   12478 </span>            : </a>
<a name="12479"><span class="lineNum">   12479 </span><span class="lineNoCov">          0 :            if (mysymbol == NULL)</span></a>
<a name="12480"><span class="lineNum">   12480 </span>            :               {</a>
<a name="12481"><span class="lineNum">   12481 </span>            :               // Note: this is an input parameter (could/should go away?) [CR]</a>
<a name="12482"><span class="lineNum">   12482 </span><span class="lineNoCov">          0 :                  if (nonDefiningDecl != NULL)</span></a>
<a name="12483"><span class="lineNum">   12483 </span>            :                     {</a>
<a name="12484"><span class="lineNum">   12484 </span>            :                     // DQ (3/4/2018): I think this is the correct API to use (internal use only).</a>
<a name="12485"><span class="lineNum">   12485 </span><span class="lineNoCov">          0 :                        SgSymbol* temp_mysymbol = nonDefiningDecl-&gt;get_symbol_from_symbol_table();</span></a>
<a name="12486"><span class="lineNum">   12486 </span><span class="lineNoCov">          0 :                        ROSE_ASSERT(temp_mysymbol != NULL);</span></a>
<a name="12487"><span class="lineNum">   12487 </span>            : </a>
<a name="12488"><span class="lineNum">   12488 </span><span class="lineNoCov">          0 :                        mysymbol = isSgClassSymbol(temp_mysymbol);</span></a>
<a name="12489"><span class="lineNum">   12489 </span><span class="lineNoCov">          0 :                        ROSE_ASSERT(mysymbol != NULL);</span></a>
<a name="12490"><span class="lineNum">   12490 </span>            : </a>
<a name="12491"><span class="lineNum">   12491 </span>            :                     // check that the scopes are the same.</a>
<a name="12492"><span class="lineNum">   12492 </span><span class="lineNoCov">          0 :                        ROSE_ASSERT(scope == nonDefiningDecl-&gt;get_scope());</span></a>
<a name="12493"><span class="lineNum">   12493 </span>            :                     }</a>
<a name="12494"><span class="lineNum">   12494 </span>            :               }</a>
<a name="12495"><span class="lineNum">   12495 </span>            :         }</a>
<a name="12496"><span class="lineNum">   12496 </span>            : </a>
<a name="12497"><span class="lineNum">   12497 </span><span class="lineNoCov">          0 :      if (mysymbol != NULL) // set links for existing nondefining declaration</span></a>
<a name="12498"><span class="lineNum">   12498 </span>            :         {</a>
<a name="12499"><span class="lineNum">   12499 </span><span class="lineNoCov">          0 :           nondefdecl = (mysymbol-&gt;get_declaration() == NULL)</span></a>
<a name="12500"><span class="lineNum">   12500 </span><span class="lineNoCov">          0 :                      ? NULL : dynamic_cast&lt;DeclClass*&gt;(mysymbol-&gt;get_declaration());</span></a>
<a name="12501"><span class="lineNum">   12501 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12502"><span class="lineNum">   12502 </span>            : </a>
<a name="12503"><span class="lineNum">   12503 </span>            :        // DQ (6/8/2013): This should not be true (see test2013_198.C).</a>
<a name="12504"><span class="lineNum">   12504 </span>            :        // Fundamentally the symbol should always only have a pointer to a non-defining</a>
<a name="12505"><span class="lineNum">   12505 </span>            :        // declaration, where by definition (get_definition() == NULL).</a>
<a name="12506"><span class="lineNum">   12506 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="12507"><span class="lineNum">   12507 </span>            : </a>
<a name="12508"><span class="lineNum">   12508 </span>            :        // DQ (9/16/2012): This should be true by definition (verify).</a>
<a name="12509"><span class="lineNum">   12509 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl == nondefdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12510"><span class="lineNum">   12510 </span>            : </a>
<a name="12511"><span class="lineNum">   12511 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_type()   != NULL);</span></a>
<a name="12512"><span class="lineNum">   12512 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</span></a>
<a name="12513"><span class="lineNum">   12513 </span>            : </a>
<a name="12514"><span class="lineNum">   12514 </span>            :        // DQ (9/7/2012): I think this might be the root of a problem in the haskell tests (ROSE compiling ROSE).</a>
<a name="12515"><span class="lineNum">   12515 </span><span class="lineNoCov">          0 :           if (nondefdecl-&gt;get_definingDeclaration() != NULL)</span></a>
<a name="12516"><span class="lineNum">   12516 </span>            :              {</a>
<a name="12517"><span class="lineNum">   12517 </span><span class="lineNoCov">          0 :                DeclClass* nondefining_classDeclaration = (nondefdecl == NULL) ? NULL : dynamic_cast&lt;DeclClass*&gt;(nondefdecl);</span></a>
<a name="12518"><span class="lineNum">   12518 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefining_classDeclaration != NULL);</span></a>
<a name="12519"><span class="lineNum">   12519 </span><span class="lineNoCov">          0 :                DeclClass* defining_classDeclaration = (nondefdecl-&gt;get_definingDeclaration() == NULL)</span></a>
<a name="12520"><span class="lineNum">   12520 </span><span class="lineNoCov">          0 :                                                     ? NULL : dynamic_cast&lt;DeclClass*&gt;(nondefdecl-&gt;get_definingDeclaration());</span></a>
<a name="12521"><span class="lineNum">   12521 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(defining_classDeclaration != NULL);</span></a>
<a name="12522"><span class="lineNum">   12522 </span>            : </a>
<a name="12523"><span class="lineNum">   12523 </span><span class="lineNoCov">          0 :                return defining_classDeclaration;</span></a>
<a name="12524"><span class="lineNum">   12524 </span>            :              }</a>
<a name="12525"><span class="lineNum">   12525 </span>            :         }</a>
<a name="12526"><span class="lineNum">   12526 </span>            :       else // build a nondefining declaration since it does not exist</a>
<a name="12527"><span class="lineNum">   12527 </span>            :         {</a>
<a name="12528"><span class="lineNum">   12528 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl == NULL);</span></a>
<a name="12529"><span class="lineNum">   12529 </span>            : </a>
<a name="12530"><span class="lineNum">   12530 </span>            :        // DeclClass is the template type parameter</a>
<a name="12531"><span class="lineNum">   12531 </span><span class="lineNoCov">          0 :           nondefdecl = new DeclClass(name, kind, NULL, NULL);</span></a>
<a name="12532"><span class="lineNum">   12532 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12533"><span class="lineNum">   12533 </span>            : </a>
<a name="12534"><span class="lineNum">   12534 </span>            :        // The first nondefining declaration has to be set before we generate the type.</a>
<a name="12535"><span class="lineNum">   12535 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="12536"><span class="lineNum">   12536 </span>            : </a>
<a name="12537"><span class="lineNum">   12537 </span>            :        // DQ (7/25/2017): This will be true, but it might not be what we want since it can be caught as an error in the code below.</a>
<a name="12538"><span class="lineNum">   12538 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_file_info() == NULL);</span></a>
<a name="12539"><span class="lineNum">   12539 </span>            : </a>
<a name="12540"><span class="lineNum">   12540 </span>            :        // DQ (3/14/2012): For C++ we need the scope set so that types will have proper locations to resolve them</a>
<a name="12541"><span class="lineNum">   12541 </span>            :        // from being ambiguous or not properly defined.  Basically, we need a handle from which to generate something</a>
<a name="12542"><span class="lineNum">   12542 </span>            :        // that amounts to a kind of name qualification internally (maybe even exactly name qualification, but I would</a>
<a name="12543"><span class="lineNum">   12543 </span>            :        // have to think about that a bit more).</a>
<a name="12544"><span class="lineNum">   12544 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="12545"><span class="lineNum">   12545 </span>            : </a>
<a name="12546"><span class="lineNum">   12546 </span>            :        // Set the parent before calling the SgClassType::createType() as the name mangling will require it.</a>
<a name="12547"><span class="lineNum">   12547 </span>            :        // This is true for Fortran SgDerivedTypeStatement at least.</a>
<a name="12548"><span class="lineNum">   12548 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_parent(scope);</span></a>
<a name="12549"><span class="lineNum">   12549 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="12550"><span class="lineNum">   12550 </span>            : </a>
<a name="12551"><span class="lineNum">   12551 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_scope() != NULL);</span></a>
<a name="12552"><span class="lineNum">   12552 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="12553"><span class="lineNum">   12553 </span>            : </a>
<a name="12554"><span class="lineNum">   12554 </span><span class="lineNoCov">          0 :           if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="12555"><span class="lineNum">   12555 </span>            :              {</a>
<a name="12556"><span class="lineNum">   12556 </span><span class="lineNoCov">          0 :                SgClassType* class_type = NULL;</span></a>
<a name="12557"><span class="lineNum">   12557 </span>            :                switch (kind)</a>
<a name="12558"><span class="lineNum">   12558 </span>            :                   {</a>
<a name="12559"><span class="lineNum">   12559 </span>            :                     default:</a>
<a name="12560"><span class="lineNum">   12560 </span><span class="lineNoCov">          0 :                        class_type = SgClassType::createType(nondefdecl);</span></a>
<a name="12561"><span class="lineNum">   12561 </span>            :                        break;</a>
<a name="12562"><span class="lineNum">   12562 </span>            :                   }</a>
<a name="12563"><span class="lineNum">   12563 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(class_type != NULL);</span></a>
<a name="12564"><span class="lineNum">   12564 </span>            : </a>
<a name="12565"><span class="lineNum">   12565 </span><span class="lineNoCov">          0 :                nondefdecl-&gt;set_type(class_type);</span></a>
<a name="12566"><span class="lineNum">   12566 </span>            : </a>
<a name="12567"><span class="lineNum">   12567 </span><span class="lineNoCov">          0 :                SgClassDeclaration* tmp_classDeclarationFromType = isSgClassDeclaration(class_type-&gt;get_declaration());</span></a>
<a name="12568"><span class="lineNum">   12568 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(tmp_classDeclarationFromType != NULL);</span></a>
<a name="12569"><span class="lineNum">   12569 </span>            :              }</a>
<a name="12570"><span class="lineNum">   12570 </span>            : </a>
<a name="12571"><span class="lineNum">   12571 </span>            :        // DQ (3/22/2012): Added assertions.</a>
<a name="12572"><span class="lineNum">   12572 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12573"><span class="lineNum">   12573 </span><span class="lineNoCov">          0 :           if (nondefdecl-&gt;get_type()-&gt;get_declaration() != nondefdecl)</span></a>
<a name="12574"><span class="lineNum">   12574 </span>            :              {</a>
<a name="12575"><span class="lineNum">   12575 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</span></a>
<a name="12576"><span class="lineNum">   12576 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="12577"><span class="lineNum">   12577 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl-&gt;get_type()-&gt;get_declaration() = %p = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration(),nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;class_name().c_str());</span></a>
<a name="12578"><span class="lineNum">   12578 </span>            : </a>
<a name="12579"><span class="lineNum">   12579 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclarationFromType = isSgClassDeclaration(nondefdecl-&gt;get_type()-&gt;get_declaration());</span></a>
<a name="12580"><span class="lineNum">   12580 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classDeclarationFromType != NULL);</span></a>
<a name="12581"><span class="lineNum">   12581 </span>            : </a>
<a name="12582"><span class="lineNum">   12582 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_name() = %s \n&quot;,nondefdecl-&gt;get_name().str());</span></a>
<a name="12583"><span class="lineNum">   12583 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_name() = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_name().str());</span></a>
<a name="12584"><span class="lineNum">   12584 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_name() = %s \n&quot;,classDeclarationFromType-&gt;get_name().str());</span></a>
<a name="12585"><span class="lineNum">   12585 </span>            : </a>
<a name="12586"><span class="lineNum">   12586 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_mangled_name() = %s \n&quot;,nondefdecl-&gt;get_mangled_name().getString().c_str());</span></a>
<a name="12587"><span class="lineNum">   12587 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_mangled() = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_mangled().getString().c_str());</span></a>
<a name="12588"><span class="lineNum">   12588 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_mangled_name() = %s \n&quot;,classDeclarationFromType-&gt;get_mangled_name().getString().c_str());</span></a>
<a name="12589"><span class="lineNum">   12589 </span>            : </a>
<a name="12590"><span class="lineNum">   12590 </span>            :             // DQ (12/27/2018): Added additional debugging support.</a>
<a name="12591"><span class="lineNum">   12591 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration() = %s \n&quot;,classDeclarationFromType-&gt;get_firstNondefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="12592"><span class="lineNum">   12592 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_firstNondefiningDeclaration()                                = %s \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="12593"><span class="lineNum">   12593 </span>            : </a>
<a name="12594"><span class="lineNum">   12594 </span>            :             // DQ (12/27/2018): I think that if this is a base class declaration then it is OK for the type's declaration to not match.</a>
<a name="12595"><span class="lineNum">   12595 </span>            :             // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="12596"><span class="lineNum">   12596 </span><span class="lineNoCov">          0 :                if (nondefdecl-&gt;get_parent() != NULL)</span></a>
<a name="12597"><span class="lineNum">   12597 </span>            :                   {</a>
<a name="12598"><span class="lineNum">   12598 </span><span class="lineNoCov">          0 :                     printf (&quot;nondefdecl-&gt;get_parent() = %p = %s \n&quot;,nondefdecl-&gt;get_parent(),nondefdecl-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="12599"><span class="lineNum">   12599 </span>            :                   }</a>
<a name="12600"><span class="lineNum">   12600 </span>            :              }</a>
<a name="12601"><span class="lineNum">   12601 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefdecl-&gt;get_type()-&gt;get_declaration() == nondefdecl);</span></a>
<a name="12602"><span class="lineNum">   12602 </span>            : </a>
<a name="12603"><span class="lineNum">   12603 </span>            :        // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="12604"><span class="lineNum">   12604 </span>            :        // generated (so we have something about the class that we can reference; e.g in</a>
<a name="12605"><span class="lineNum">   12605 </span>            :        // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="12606"><span class="lineNum">   12606 </span>            :        // of source position that would be more precise.  FIXME.</a>
<a name="12607"><span class="lineNum">   12607 </span>            :        // setOneSourcePositionNull(nondefdecl);</a>
<a name="12608"><span class="lineNum">   12608 </span><span class="lineNoCov">          0 :           setOneSourcePositionForTransformation(nondefdecl);</span></a>
<a name="12609"><span class="lineNum">   12609 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (nondefdecl-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="12610"><span class="lineNum">   12610 </span>            : </a>
<a name="12611"><span class="lineNum">   12611 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="12612"><span class="lineNum">   12612 </span>            :        // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="12613"><span class="lineNum">   12613 </span>            :           if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="12614"><span class="lineNum">   12614 </span>            :              {</a>
<a name="12615"><span class="lineNum">   12615 </span>            :                detectTransformations(nondefdecl);</a>
<a name="12616"><span class="lineNum">   12616 </span>            :              }</a>
<a name="12617"><span class="lineNum">   12617 </span>            : #endif</a>
<a name="12618"><span class="lineNum">   12618 </span>            : </a>
<a name="12619"><span class="lineNum">   12619 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;setForward();</span></a>
<a name="12620"><span class="lineNum">   12620 </span>            : </a>
<a name="12621"><span class="lineNum">   12621 </span>            :           if (scope != NULL)</a>
<a name="12622"><span class="lineNum">   12622 </span>            :              {</a>
<a name="12623"><span class="lineNum">   12623 </span><span class="lineNoCov">          0 :                mysymbol = new SgClassSymbol(nondefdecl);</span></a>
<a name="12624"><span class="lineNum">   12624 </span><span class="lineNoCov">          0 :                scope-&gt;insert_symbol(name, mysymbol);</span></a>
<a name="12625"><span class="lineNum">   12625 </span>            : </a>
<a name="12626"><span class="lineNum">   12626 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefdecl-&gt;get_scope() == scope);</span></a>
<a name="12627"><span class="lineNum">   12627 </span>            :              }</a>
<a name="12628"><span class="lineNum">   12628 </span>            :         }</a>
<a name="12629"><span class="lineNum">   12629 </span>            : </a>
<a name="12630"><span class="lineNum">   12630 </span>            :   // DQ (3/15/2012): I have moved construction of defining declaration to be AFTER the nondefining declaration!</a>
<a name="12631"><span class="lineNum">   12631 </span>            :   // This is a better organization ans also should make sure that the declaration in the SgClassType will</a>
<a name="12632"><span class="lineNum">   12632 </span>            :   // properly reference the firstNondefiningDeclaration (instead of the defining declaration).</a>
<a name="12633"><span class="lineNum">   12633 </span>            : </a>
<a name="12634"><span class="lineNum">   12634 </span>            :   // Step 2. Build the defining declaration</a>
<a name="12635"><span class="lineNum">   12635 </span>            :   // --------------------------------------</a>
<a name="12636"><span class="lineNum">   12636 </span>            :   //</a>
<a name="12637"><span class="lineNum">   12637 </span><span class="lineNoCov">          0 :      SgClassDefinition* classDef = buildClassDefinition();</span></a>
<a name="12638"><span class="lineNum">   12638 </span>            : </a>
<a name="12639"><span class="lineNum">   12639 </span><span class="lineNoCov">          0 :      DeclClass* defdecl = new DeclClass(name,kind,NULL,classDef);</span></a>
<a name="12640"><span class="lineNum">   12640 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="12641"><span class="lineNum">   12641 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</span></a>
<a name="12642"><span class="lineNum">   12642 </span>            : </a>
<a name="12643"><span class="lineNum">   12643 </span>            :   // DQ (3/5/2012): Check that the SgClassDefinition is properly matching.</a>
<a name="12644"><span class="lineNum">   12644 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_definition() != NULL);</span></a>
<a name="12645"><span class="lineNum">   12645 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="12646"><span class="lineNum">   12646 </span>            : </a>
<a name="12647"><span class="lineNum">   12647 </span>            :   // DQ (3/15/2012): Moved from original location above...</a>
<a name="12648"><span class="lineNum">   12648 </span><span class="lineNoCov">          0 :      nondefdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="12649"><span class="lineNum">   12649 </span>            : </a>
<a name="12650"><span class="lineNum">   12650 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="12651"><span class="lineNum">   12651 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</span></a>
<a name="12652"><span class="lineNum">   12652 </span>            : </a>
<a name="12653"><span class="lineNum">   12653 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(defdecl);</span></a>
<a name="12654"><span class="lineNum">   12654 </span>            :   // constructor is side-effect free</a>
<a name="12655"><span class="lineNum">   12655 </span><span class="lineNoCov">          0 :      classDef-&gt;set_declaration(defdecl);</span></a>
<a name="12656"><span class="lineNum">   12656 </span><span class="lineNoCov">          0 :      defdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="12657"><span class="lineNum">   12657 </span>            : </a>
<a name="12658"><span class="lineNum">   12658 </span><span class="lineNoCov">          0 :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="12659"><span class="lineNum">   12659 </span>            : </a>
<a name="12660"><span class="lineNum">   12660 </span>            :   // DQ (3/22/2012): I think we can assert this.</a>
<a name="12661"><span class="lineNum">   12661 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</span></a>
<a name="12662"><span class="lineNum">   12662 </span>            : </a>
<a name="12663"><span class="lineNum">   12663 </span>            :   // Liao, 10/30/2009</a>
<a name="12664"><span class="lineNum">   12664 </span>            :   // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType</a>
<a name="12665"><span class="lineNum">   12665 </span>            :   // This is not desired when building a defining declaration and an inefficience in the constructor</a>
<a name="12666"><span class="lineNum">   12666 </span>            :   // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and</a>
<a name="12667"><span class="lineNum">   12667 </span>            :   // the defining class declaration (and other nondefining declaration) just share that SgClassType.</a>
<a name="12668"><span class="lineNum">   12668 </span><span class="lineNoCov">          0 :      if (defdecl-&gt;get_type() != NULL)</span></a>
<a name="12669"><span class="lineNum">   12669 </span>            :         {</a>
<a name="12670"><span class="lineNum">   12670 </span>            :            // Removed several lines of dead code because of the assertion just above</a>
<a name="12671"><span class="lineNum">   12671 </span>            :         }</a>
<a name="12672"><span class="lineNum">   12672 </span>            :        else</a>
<a name="12673"><span class="lineNum">   12673 </span>            :         {</a>
<a name="12674"><span class="lineNum">   12674 </span>            :        // DQ (3/15/2012): Make sure that both the defining and non-defining declarations use the same type.</a>
<a name="12675"><span class="lineNum">   12675 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12676"><span class="lineNum">   12676 </span><span class="lineNoCov">          0 :           defdecl-&gt;set_type(nondefdecl-&gt;get_type());</span></a>
<a name="12677"><span class="lineNum">   12677 </span>            : </a>
<a name="12678"><span class="lineNum">   12678 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12679"><span class="lineNum">   12679 </span>            :         }</a>
<a name="12680"><span class="lineNum">   12680 </span>            : </a>
<a name="12681"><span class="lineNum">   12681 </span>            :   // DQ (9/4/2012): Added assertion.</a>
<a name="12682"><span class="lineNum">   12682 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="12683"><span class="lineNum">   12683 </span>            : </a>
<a name="12684"><span class="lineNum">   12684 </span>            :   // patch up the SgClassType for the defining class declaration</a>
<a name="12685"><span class="lineNum">   12685 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="12686"><span class="lineNum">   12686 </span>            :   // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="12687"><span class="lineNum">   12687 </span>            :   // ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl));</a>
<a name="12688"><span class="lineNum">   12688 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (defdecl-&gt;get_type() != NULL);</span></a>
<a name="12689"><span class="lineNum">   12689 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() != NULL);</span></a>
<a name="12690"><span class="lineNum">   12690 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(defdecl));</span></a>
<a name="12691"><span class="lineNum">   12691 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12692"><span class="lineNum">   12692 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() == nondefdecl);</span></a>
<a name="12693"><span class="lineNum">   12693 </span>            : </a>
<a name="12694"><span class="lineNum">   12694 </span>            :   // DQ (9/4/2012): Added assertion.</a>
<a name="12695"><span class="lineNum">   12695 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="12696"><span class="lineNum">   12696 </span>            : </a>
<a name="12697"><span class="lineNum">   12697 </span>            :   // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).</a>
<a name="12698"><span class="lineNum">   12698 </span>            :   // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless</a>
<a name="12699"><span class="lineNum">   12699 </span>            :   // used in a defining declaration).</a>
<a name="12700"><span class="lineNum">   12700 </span><span class="lineNoCov">          0 :      nondefdecl-&gt;setForward();</span></a>
<a name="12701"><span class="lineNum">   12701 </span>            : </a>
<a name="12702"><span class="lineNum">   12702 </span><span class="lineNoCov">          0 :      if (scope != NULL)  // put into fixStructDeclaration() or alike later on</span></a>
<a name="12703"><span class="lineNum">   12703 </span>            :         {</a>
<a name="12704"><span class="lineNum">   12704 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="12705"><span class="lineNum">   12705 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="12706"><span class="lineNum">   12706 </span>            : </a>
<a name="12707"><span class="lineNum">   12707 </span>            :        // Note, this function sets the parent to be the scope if it is not already set.</a>
<a name="12708"><span class="lineNum">   12708 </span><span class="lineNoCov">          0 :           fixStructDeclaration(defdecl,scope);</span></a>
<a name="12709"><span class="lineNum">   12709 </span>            : </a>
<a name="12710"><span class="lineNum">   12710 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="12711"><span class="lineNum">   12711 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="12712"><span class="lineNum">   12712 </span>            : </a>
<a name="12713"><span class="lineNum">   12713 </span><span class="lineNoCov">          0 :           fixStructDeclaration(nondefdecl,scope);</span></a>
<a name="12714"><span class="lineNum">   12714 </span>            : </a>
<a name="12715"><span class="lineNum">   12715 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="12716"><span class="lineNum">   12716 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="12717"><span class="lineNum">   12717 </span>            :         }</a>
<a name="12718"><span class="lineNum">   12718 </span>            : </a>
<a name="12719"><span class="lineNum">   12719 </span>            :   // DQ (1/26/2009): I think we should assert this, but it breaks the interface as defined</a>
<a name="12720"><span class="lineNum">   12720 </span>            :   // by the test code in tests/nonsmoke/functional/roseTests/astInterfaceTests.</a>
<a name="12721"><span class="lineNum">   12721 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_parent() != NULL);</a>
<a name="12722"><span class="lineNum">   12722 </span>            : </a>
<a name="12723"><span class="lineNum">   12723 </span>            :   // ROSE_ASSERT(nonDefiningDecl-&gt;get_parent() != NULL);</a>
<a name="12724"><span class="lineNum">   12724 </span>            : </a>
<a name="12725"><span class="lineNum">   12725 </span>            :   // DQ (2/27/2012): Tracking down where parents are not set correctly (class declaration in typedef is incorrectly set to SgGlobal).</a>
<a name="12726"><span class="lineNum">   12726 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_parent() == NULL);</span></a>
<a name="12727"><span class="lineNum">   12727 </span>            : </a>
<a name="12728"><span class="lineNum">   12728 </span>            :   // DQ (2/29/2012):  We can't assert this (fails for test2012_09.C).</a>
<a name="12729"><span class="lineNum">   12729 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_parent() == NULL);</a>
<a name="12730"><span class="lineNum">   12730 </span>            : </a>
<a name="12731"><span class="lineNum">   12731 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="12732"><span class="lineNum">   12732 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != defdecl-&gt;get_definingDeclaration());</span></a>
<a name="12733"><span class="lineNum">   12733 </span>            : </a>
<a name="12734"><span class="lineNum">   12734 </span>            :   // DQ (3/8/2018): Added for debugging.</a>
<a name="12735"><span class="lineNum">   12735 </span><span class="lineNoCov">          0 :      SgClassDeclaration* temp_firstNondefiningDeclaration = isSgClassDeclaration(defdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12736"><span class="lineNum">   12736 </span><span class="lineNoCov">          0 :      SgClassDeclaration* temp_definingDeclaration         = isSgClassDeclaration(defdecl-&gt;get_definingDeclaration());</span></a>
<a name="12737"><span class="lineNum">   12737 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(temp_firstNondefiningDeclaration != NULL);</span></a>
<a name="12738"><span class="lineNum">   12738 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(temp_definingDeclaration != NULL);</span></a>
<a name="12739"><span class="lineNum">   12739 </span>            : </a>
<a name="12740"><span class="lineNum">   12740 </span>            :   // DQ (3/8/2018): Added assertion.</a>
<a name="12741"><span class="lineNum">   12741 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(temp_firstNondefiningDeclaration-&gt;get_name() == temp_definingDeclaration-&gt;get_name());</span></a>
<a name="12742"><span class="lineNum">   12742 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(temp_firstNondefiningDeclaration-&gt;get_type() == temp_definingDeclaration-&gt;get_type());</span></a>
<a name="12743"><span class="lineNum">   12743 </span>            : </a>
<a name="12744"><span class="lineNum">   12744 </span>            : #if 0</a>
<a name="12745"><span class="lineNum">   12745 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="12746"><span class="lineNum">   12746 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): Calling find_symbol_from_declaration() \n&quot;);</a>
<a name="12747"><span class="lineNum">   12747 </span>            :      SgSymbol* test_symbol = nondefdecl-&gt;get_scope()-&gt;find_symbol_from_declaration(nondefdecl);</a>
<a name="12748"><span class="lineNum">   12748 </span>            : </a>
<a name="12749"><span class="lineNum">   12749 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="12750"><span class="lineNum">   12750 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): Calling get_symbol_from_symbol_table() \n&quot;);</a>
<a name="12751"><span class="lineNum">   12751 </span>            :      ROSE_ASSERT(nondefdecl-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="12752"><span class="lineNum">   12752 </span>            : #endif</a>
<a name="12753"><span class="lineNum">   12753 </span>            : </a>
<a name="12754"><span class="lineNum">   12754 </span><span class="lineNoCov">          0 :      return defdecl;</span></a>
<a name="12755"><span class="lineNum">   12755 </span>            :    }</a>
<a name="12756"><span class="lineNum">   12756 </span>            : </a>
<a name="12757"><span class="lineNum">   12757 </span>            : </a>
<a name="12758"><span class="lineNum">   12758 </span>            : SgNamespaceDeclarationStatement*</a>
<a name="12759"><span class="lineNum">   12759 </span><span class="lineNoCov">          0 : SageBuilder::buildNamespaceDeclaration(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="12760"><span class="lineNum">   12760 </span>            :    {</a>
<a name="12761"><span class="lineNum">   12761 </span><span class="lineNoCov">          0 :      SgNamespaceDeclarationStatement* defdecl = buildNamespaceDeclaration_nfi(name,false,scope);</span></a>
<a name="12762"><span class="lineNum">   12762 </span>            : </a>
<a name="12763"><span class="lineNum">   12763 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(defdecl);</span></a>
<a name="12764"><span class="lineNum">   12764 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="12765"><span class="lineNum">   12765 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(defdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="12766"><span class="lineNum">   12766 </span>            : </a>
<a name="12767"><span class="lineNum">   12767 </span><span class="lineNoCov">          0 :      return defdecl;</span></a>
<a name="12768"><span class="lineNum">   12768 </span>            :    }</a>
<a name="12769"><span class="lineNum">   12769 </span>            : </a>
<a name="12770"><span class="lineNum">   12770 </span>            : SgNamespaceDeclarationStatement*</a>
<a name="12771"><span class="lineNum">   12771 </span><span class="lineCov">       1127 : SageBuilder::buildNamespaceDeclaration_nfi(const SgName&amp; name, bool unnamednamespace, SgScopeStatement* scope)</span></a>
<a name="12772"><span class="lineNum">   12772 </span>            :    {</a>
<a name="12773"><span class="lineNum">   12773 </span><span class="lineCov">       1127 :      if (scope == NULL)</span></a>
<a name="12774"><span class="lineNum">   12774 </span><span class="lineCov">        126 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="12775"><span class="lineNum">   12775 </span>            : </a>
<a name="12776"><span class="lineNum">   12776 </span><span class="lineCov">       1127 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="12777"><span class="lineNum">   12777 </span>            : </a>
<a name="12778"><span class="lineNum">   12778 </span>            : #if 0</a>
<a name="12779"><span class="lineNum">   12779 </span>            :      printf (&quot;In SageBuilder::buildNamespaceDeclaration_nfi(): scope = %p = %s = %s \n&quot;,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="12780"><span class="lineNum">   12780 </span>            : #endif</a>
<a name="12781"><span class="lineNum">   12781 </span>            : </a>
<a name="12782"><span class="lineNum">   12782 </span>            :   // TODO How about class type??</a>
<a name="12783"><span class="lineNum">   12783 </span>            :   // build defining declaration</a>
<a name="12784"><span class="lineNum">   12784 </span><span class="lineCov">       1127 :      SgNamespaceDefinitionStatement* namespaceDef = buildNamespaceDefinition();</span></a>
<a name="12785"><span class="lineNum">   12785 </span>            : </a>
<a name="12786"><span class="lineNum">   12786 </span><span class="lineCov">       1127 :      SgNamespaceDeclarationStatement* defdecl = new SgNamespaceDeclarationStatement(name,namespaceDef,unnamednamespace);</span></a>
<a name="12787"><span class="lineNum">   12787 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="12788"><span class="lineNum">   12788 </span><span class="lineCov">       1127 :      namespaceDef-&gt;set_parent(defdecl);</span></a>
<a name="12789"><span class="lineNum">   12789 </span>            : </a>
<a name="12790"><span class="lineNum">   12790 </span>            : #if 0</a>
<a name="12791"><span class="lineNum">   12791 </span>            :      printf (&quot;#################### SageBuilder::buildNamespaceDeclaration_nfi(): defdecl = %p = %s namespaceDef = %p \n&quot;,defdecl,defdecl-&gt;get_name().str(),namespaceDef);</a>
<a name="12792"><span class="lineNum">   12792 </span>            : #endif</a>
<a name="12793"><span class="lineNum">   12793 </span>            : </a>
<a name="12794"><span class="lineNum">   12794 </span>            :   // setOneSourcePositionForTransformation(defdecl);</a>
<a name="12795"><span class="lineNum">   12795 </span><span class="lineCov">       1127 :      setOneSourcePositionNull(defdecl);</span></a>
<a name="12796"><span class="lineNum">   12796 </span>            : </a>
<a name="12797"><span class="lineNum">   12797 </span>            :   // constructor is side-effect free</a>
<a name="12798"><span class="lineNum">   12798 </span><span class="lineCov">       1127 :      namespaceDef-&gt;set_namespaceDeclaration(defdecl);</span></a>
<a name="12799"><span class="lineNum">   12799 </span>            : </a>
<a name="12800"><span class="lineNum">   12800 </span>            :   // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.</a>
<a name="12801"><span class="lineNum">   12801 </span>            :   // defdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12802"><span class="lineNum">   12802 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="12803"><span class="lineNum">   12803 </span>            : </a>
<a name="12804"><span class="lineNum">   12804 </span>            :   // Get the nondefining declaration from the symbol if it has been built (if this works,</a>
<a name="12805"><span class="lineNum">   12805 </span>            :   // then we likely don't need the &quot;SgClassDeclaration* nonDefiningDecl&quot; parameter).</a>
<a name="12806"><span class="lineNum">   12806 </span><span class="lineCov">       1127 :      SgNamespaceDeclarationStatement* nondefdecl = NULL;</span></a>
<a name="12807"><span class="lineNum">   12807 </span>            : </a>
<a name="12808"><span class="lineNum">   12808 </span>            :   // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/nonsmoke/functional/roseTests/astInterfaceTests test codes.</a>
<a name="12809"><span class="lineNum">   12809 </span>            :   // ROSE_ASSERT(scope != NULL);</a>
<a name="12810"><span class="lineNum">   12810 </span><span class="lineCov">       1127 :      SgNamespaceSymbol* mysymbol = NULL;</span></a>
<a name="12811"><span class="lineNum">   12811 </span><span class="lineCov">       1127 :      if (scope != NULL)</span></a>
<a name="12812"><span class="lineNum">   12812 </span>            :         {</a>
<a name="12813"><span class="lineNum">   12813 </span><span class="lineCov">       1127 :           mysymbol = scope-&gt;lookup_namespace_symbol(name);</span></a>
<a name="12814"><span class="lineNum">   12814 </span>            :         }</a>
<a name="12815"><span class="lineNum">   12815 </span>            :        else</a>
<a name="12816"><span class="lineNum">   12816 </span>            :         {</a>
<a name="12817"><span class="lineNum">   12817 </span>            :        // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="12818"><span class="lineNum">   12818 </span>            :        // break the existing interface. Need to discuss this with Liao.</a>
<a name="12819"><span class="lineNum">   12819 </span><span class="lineCov">       1127 :           printf (&quot;Warning: In SageBuilder::buildNamespaceDeclaration_nfi(): scope == NULL \n&quot;);</span></a>
<a name="12820"><span class="lineNum">   12820 </span>            :         }</a>
<a name="12821"><span class="lineNum">   12821 </span>            : </a>
<a name="12822"><span class="lineNum">   12822 </span>            : #if 0</a>
<a name="12823"><span class="lineNum">   12823 </span>            :      printf (&quot;In SageBuilder::buildNamespaceDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="12824"><span class="lineNum">   12824 </span>            : #endif</a>
<a name="12825"><span class="lineNum">   12825 </span>            : </a>
<a name="12826"><span class="lineNum">   12826 </span><span class="lineCov">       1127 :      if (mysymbol != NULL)</span></a>
<a name="12827"><span class="lineNum">   12827 </span>            :         {</a>
<a name="12828"><span class="lineNum">   12828 </span>            :        // nondefdecl = isSgNamespaceDeclarationStatement(mysymbol-&gt;get_declaration());</a>
<a name="12829"><span class="lineNum">   12829 </span><span class="lineCov">        978 :           SgNamespaceDeclarationStatement* namespaceDeclaration = mysymbol-&gt;get_declaration();</span></a>
<a name="12830"><span class="lineNum">   12830 </span><span class="lineCov">        978 :           ROSE_ASSERT(namespaceDeclaration != NULL);</span></a>
<a name="12831"><span class="lineNum">   12831 </span><span class="lineCov">        978 :           nondefdecl = isSgNamespaceDeclarationStatement(namespaceDeclaration);</span></a>
<a name="12832"><span class="lineNum">   12832 </span>            : </a>
<a name="12833"><span class="lineNum">   12833 </span><span class="lineCov">        978 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12834"><span class="lineNum">   12834 </span><span class="lineCov">        978 :           ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</span></a>
<a name="12835"><span class="lineNum">   12835 </span>            : </a>
<a name="12836"><span class="lineNum">   12836 </span>            :        // DQ (5/16/2013): These should be non-defining declarations for the case of a C++ namespace (all instances are a non-defining declaration).</a>
<a name="12837"><span class="lineNum">   12837 </span>            :        // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12838"><span class="lineNum">   12838 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="12839"><span class="lineNum">   12839 </span><span class="lineCov">        978 :           ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="12840"><span class="lineNum">   12840 </span><span class="lineCov">        978 :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</span></a>
<a name="12841"><span class="lineNum">   12841 </span>            : </a>
<a name="12842"><span class="lineNum">   12842 </span>            :        // DQ (5/16/2013): Set the global definition for the new namespace definition.</a>
<a name="12843"><span class="lineNum">   12843 </span><span class="lineCov">        978 :           ROSE_ASSERT(namespaceDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="12844"><span class="lineNum">   12844 </span><span class="lineCov">        978 :           if (namespaceDeclaration-&gt;get_definition()-&gt;get_global_definition() == NULL)</span></a>
<a name="12845"><span class="lineNum">   12845 </span>            :              {</a>
<a name="12846"><span class="lineNum">   12846 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: namespaceDeclaration-&gt;get_definition()-&gt;get_global_definition() == NULL: namespaceDeclaration = %p = %s namespaceDeclaration-&gt;get_definition() = %p \n&quot;,</span></a>
<a name="12847"><span class="lineNum">   12847 </span><span class="lineNoCov">          0 :                     namespaceDeclaration,namespaceDeclaration-&gt;get_name().str(),namespaceDeclaration-&gt;get_definition());</span></a>
<a name="12848"><span class="lineNum">   12848 </span>            :              }</a>
<a name="12849"><span class="lineNum">   12849 </span><span class="lineCov">        978 :           ROSE_ASSERT(namespaceDeclaration-&gt;get_definition()-&gt;get_global_definition() != NULL);</span></a>
<a name="12850"><span class="lineNum">   12850 </span><span class="lineCov">        978 :           namespaceDef-&gt;set_global_definition(namespaceDeclaration-&gt;get_definition()-&gt;get_global_definition());</span></a>
<a name="12851"><span class="lineNum">   12851 </span><span class="lineCov">        978 :           ROSE_ASSERT(namespaceDef-&gt;get_global_definition() != NULL);</span></a>
<a name="12852"><span class="lineNum">   12852 </span>            : </a>
<a name="12853"><span class="lineNum">   12853 </span>            :        // DQ (5/19/2013): Make the global_definition point to itself.</a>
<a name="12854"><span class="lineNum">   12854 </span><span class="lineCov">        978 :           ROSE_ASSERT(namespaceDef-&gt;get_global_definition() == namespaceDef-&gt;get_global_definition()-&gt;get_global_definition());</span></a>
<a name="12855"><span class="lineNum">   12855 </span>            : </a>
<a name="12856"><span class="lineNum">   12856 </span><span class="lineCov">        978 :           ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() != NULL);</span></a>
<a name="12857"><span class="lineNum">   12857 </span>            : </a>
<a name="12858"><span class="lineNum">   12858 </span><span class="lineCov">        978 :           ROSE_ASSERT(nondefdecl-&gt;get_definition()-&gt;get_previousNamespaceDefinition() == NULL);</span></a>
<a name="12859"><span class="lineNum">   12859 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_definition()-&gt;get_nextNamespaceDefinition() == NULL);</a>
<a name="12860"><span class="lineNum">   12860 </span>            : </a>
<a name="12861"><span class="lineNum">   12861 </span><span class="lineCov">        978 :           SgNamespaceDefinitionStatement* i = namespaceDeclaration-&gt;get_definition();</span></a>
<a name="12862"><span class="lineNum">   12862 </span><span class="lineCov">        978 :           ROSE_ASSERT(i != NULL);</span></a>
<a name="12863"><span class="lineNum">   12863 </span><span class="lineCov">      29090 :           while (i != NULL &amp;&amp; i-&gt;get_nextNamespaceDefinition() != NULL)</span></a>
<a name="12864"><span class="lineNum">   12864 </span>            :              {</a>
<a name="12865"><span class="lineNum">   12865 </span><span class="lineCov">      28112 :                i = i-&gt;get_nextNamespaceDefinition();</span></a>
<a name="12866"><span class="lineNum">   12866 </span><span class="lineCov">      28112 :                ROSE_ASSERT(i-&gt;get_previousNamespaceDefinition() != NULL);</span></a>
<a name="12867"><span class="lineNum">   12867 </span>            :              }</a>
<a name="12868"><span class="lineNum">   12868 </span>            : </a>
<a name="12869"><span class="lineNum">   12869 </span><span class="lineCov">        978 :           ROSE_ASSERT(i != NULL);</span></a>
<a name="12870"><span class="lineNum">   12870 </span><span class="lineCov">        978 :           i-&gt;set_nextNamespaceDefinition(namespaceDef);</span></a>
<a name="12871"><span class="lineNum">   12871 </span><span class="lineCov">        978 :           namespaceDef-&gt;set_previousNamespaceDefinition(i);</span></a>
<a name="12872"><span class="lineNum">   12872 </span>            :         }</a>
<a name="12873"><span class="lineNum">   12873 </span>            :        else</a>
<a name="12874"><span class="lineNum">   12874 </span>            :         {</a>
<a name="12875"><span class="lineNum">   12875 </span>            :        // DQ (5/16/2013): Note that since we don't build a SgNamespaceDefinition for the declaration we can't</a>
<a name="12876"><span class="lineNum">   12876 </span>            :        // build the global_definition.  This is a potential problem.</a>
<a name="12877"><span class="lineNum">   12877 </span>            : </a>
<a name="12878"><span class="lineNum">   12878 </span>            : #if 1</a>
<a name="12879"><span class="lineNum">   12879 </span><span class="lineCov">        149 :           nondefdecl = defdecl;</span></a>
<a name="12880"><span class="lineNum">   12880 </span><span class="lineCov">        149 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12881"><span class="lineNum">   12881 </span><span class="lineCov">        149 :           namespaceDef = nondefdecl-&gt;get_definition();</span></a>
<a name="12882"><span class="lineNum">   12882 </span><span class="lineCov">        149 :           ROSE_ASSERT(namespaceDef-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="12883"><span class="lineNum">   12883 </span>            : #else</a>
<a name="12884"><span class="lineNum">   12884 </span>            :        // DQ (5/16/2013): We want to build an associated SgNamespaceDefinitionStatement so that we can</a>
<a name="12885"><span class="lineNum">   12885 </span>            :        // support a reference to a SgNamespaceDefinitionStatement as a global definition.</a>
<a name="12886"><span class="lineNum">   12886 </span>            :        // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.</a>
<a name="12887"><span class="lineNum">   12887 </span>            :        // nondefdecl = new SgNamespaceDeclarationStatement(name,NULL, unnamednamespace);</a>
<a name="12888"><span class="lineNum">   12888 </span>            : </a>
<a name="12889"><span class="lineNum">   12889 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="12890"><span class="lineNum">   12890 </span>            : </a>
<a name="12891"><span class="lineNum">   12891 </span>            :           SgNamespaceDefinitionStatement* namespaceDef = buildNamespaceDefinition();</a>
<a name="12892"><span class="lineNum">   12892 </span>            :           nondefdecl = new SgNamespaceDeclarationStatement(name,namespaceDef,unnamednamespace);</a>
<a name="12893"><span class="lineNum">   12893 </span>            :           ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="12894"><span class="lineNum">   12894 </span>            : #if 0</a>
<a name="12895"><span class="lineNum">   12895 </span>            :           printf (&quot;In SageBuilder::buildNamespaceDeclaration_nfi(): Built namespace definition for nondefdecl = %p = %s definition = %p \n&quot;,nondefdecl,nondefdecl-&gt;get_name().str(),namespaceDef);</a>
<a name="12896"><span class="lineNum">   12896 </span>            : #endif</a>
<a name="12897"><span class="lineNum">   12897 </span>            :        // DQ (5/16/2013): Added tests and setting of the associated declaration.</a>
<a name="12898"><span class="lineNum">   12898 </span>            :           ROSE_ASSERT(namespaceDef-&gt;get_namespaceDeclaration() == NULL);</a>
<a name="12899"><span class="lineNum">   12899 </span>            :           namespaceDef-&gt;set_namespaceDeclaration(nondefdecl);</a>
<a name="12900"><span class="lineNum">   12900 </span>            :           ROSE_ASSERT(namespaceDef-&gt;get_namespaceDeclaration() != NULL);</a>
<a name="12901"><span class="lineNum">   12901 </span>            : #endif</a>
<a name="12902"><span class="lineNum">   12902 </span>            : </a>
<a name="12903"><span class="lineNum">   12903 </span>            :        // DQ (5/16/2013): Now add the global definition where we will accumulate all of the symbols for the logical namespace.</a>
<a name="12904"><span class="lineNum">   12904 </span><span class="lineCov">        149 :           SgNamespaceDefinitionStatement* global_definition_namespaceDef = buildNamespaceDefinition();</span></a>
<a name="12905"><span class="lineNum">   12905 </span><span class="lineCov">        149 :           namespaceDef-&gt;set_global_definition(global_definition_namespaceDef);</span></a>
<a name="12906"><span class="lineNum">   12906 </span><span class="lineCov">        149 :           ROSE_ASSERT(namespaceDef-&gt;get_global_definition() != NULL);</span></a>
<a name="12907"><span class="lineNum">   12907 </span>            : </a>
<a name="12908"><span class="lineNum">   12908 </span>            :        // DQ (5/19/2013): Make the global_definition point to itself.</a>
<a name="12909"><span class="lineNum">   12909 </span><span class="lineCov">        149 :           global_definition_namespaceDef-&gt;set_global_definition(global_definition_namespaceDef);</span></a>
<a name="12910"><span class="lineNum">   12910 </span>            : </a>
<a name="12911"><span class="lineNum">   12911 </span><span class="lineCov">        149 :           global_definition_namespaceDef-&gt;set_isUnionOfReentrantNamespaceDefinitions(true);</span></a>
<a name="12912"><span class="lineNum">   12912 </span>            : </a>
<a name="12913"><span class="lineNum">   12913 </span>            :        // DQ (8/23/2013): Set the parent of the global_definition_namespaceDef.</a>
<a name="12914"><span class="lineNum">   12914 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef-&gt;get_parent() == NULL);</span></a>
<a name="12915"><span class="lineNum">   12915 </span><span class="lineCov">        149 :           global_definition_namespaceDef-&gt;set_parent(defdecl);</span></a>
<a name="12916"><span class="lineNum">   12916 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef-&gt;get_parent() != NULL);</span></a>
<a name="12917"><span class="lineNum">   12917 </span>            : </a>
<a name="12918"><span class="lineNum">   12918 </span>            :        // DQ (5/16/2013): Added tests and setting of the associated declaration.</a>
<a name="12919"><span class="lineNum">   12919 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef-&gt;get_namespaceDeclaration() == NULL);</span></a>
<a name="12920"><span class="lineNum">   12920 </span><span class="lineCov">        149 :           global_definition_namespaceDef-&gt;set_namespaceDeclaration(nondefdecl);</span></a>
<a name="12921"><span class="lineNum">   12921 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="12922"><span class="lineNum">   12922 </span>            : </a>
<a name="12923"><span class="lineNum">   12923 </span>            :        // DQ (5/16/2013): Set the associated declaration to be the nondefdecl.</a>
<a name="12924"><span class="lineNum">   12924 </span><span class="lineCov">        149 :           global_definition_namespaceDef-&gt;set_namespaceDeclaration(nondefdecl);</span></a>
<a name="12925"><span class="lineNum">   12925 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="12926"><span class="lineNum">   12926 </span>            : </a>
<a name="12927"><span class="lineNum">   12927 </span>            : #if 0</a>
<a name="12928"><span class="lineNum">   12928 </span>            :           ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() == NULL);</a>
<a name="12929"><span class="lineNum">   12929 </span>            :        // defdecl-&gt;get_definition()-&gt;set_global_definition(namespaceDef-&gt;get_global_definition());</a>
<a name="12930"><span class="lineNum">   12930 </span>            :           defdecl-&gt;get_definition()-&gt;set_global_definition(global_definition_namespaceDef);</a>
<a name="12931"><span class="lineNum">   12931 </span>            : #else</a>
<a name="12932"><span class="lineNum">   12932 </span>            : #if 0</a>
<a name="12933"><span class="lineNum">   12933 </span>            :           printf (&quot;In SageBuilder::buildNamespaceDeclaration_nfi(): defdecl-&gt;get_definition()-&gt;get_global_definition() = %p \n&quot;,defdecl-&gt;get_definition()-&gt;get_global_definition());</a>
<a name="12934"><span class="lineNum">   12934 </span>            : #endif</a>
<a name="12935"><span class="lineNum">   12935 </span><span class="lineCov">        149 :           if (defdecl-&gt;get_definition()-&gt;get_global_definition() == NULL)</span></a>
<a name="12936"><span class="lineNum">   12936 </span>            :              {</a>
<a name="12937"><span class="lineNum">   12937 </span><span class="lineNoCov">          0 :                defdecl-&gt;get_definition()-&gt;set_global_definition(global_definition_namespaceDef);</span></a>
<a name="12938"><span class="lineNum">   12938 </span>            :              }</a>
<a name="12939"><span class="lineNum">   12939 </span>            : </a>
<a name="12940"><span class="lineNum">   12940 </span>            :        // DQ (5/19/2013): Make the global_definition point to itself.</a>
<a name="12941"><span class="lineNum">   12941 </span><span class="lineCov">        149 :           ROSE_ASSERT(global_definition_namespaceDef == global_definition_namespaceDef-&gt;get_global_definition());</span></a>
<a name="12942"><span class="lineNum">   12942 </span>            : #endif</a>
<a name="12943"><span class="lineNum">   12943 </span><span class="lineCov">        149 :           ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() != NULL);</span></a>
<a name="12944"><span class="lineNum">   12944 </span><span class="lineCov">        149 :           ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() == namespaceDef-&gt;get_global_definition());</span></a>
<a name="12945"><span class="lineNum">   12945 </span>            : #if 0</a>
<a name="12946"><span class="lineNum">   12946 </span>            :           printf (&quot;In SageBuilder::buildNamespaceDeclaration_nfi(): Built namespace definition for nondefdecl = %p = %s get_global_definition() = %p \n&quot;,nondefdecl,nondefdecl-&gt;get_name().str(),namespaceDef-&gt;get_global_definition());</a>
<a name="12947"><span class="lineNum">   12947 </span>            : #endif</a>
<a name="12948"><span class="lineNum">   12948 </span>            :        // printf (&quot;SageBuilder::buildNamespaceDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="12949"><span class="lineNum">   12949 </span>            : </a>
<a name="12950"><span class="lineNum">   12950 </span>            :        // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="12951"><span class="lineNum">   12951 </span>            :        // generated (so we have something about the class that we can reference; e.g in</a>
<a name="12952"><span class="lineNum">   12952 </span>            :        // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="12953"><span class="lineNum">   12953 </span>            :        // of source position that would be more precise.  FIXME.</a>
<a name="12954"><span class="lineNum">   12954 </span>            :        // setOneSourcePositionNull(nondefdecl);</a>
<a name="12955"><span class="lineNum">   12955 </span>            :        // setOneSourcePositionForTransformation(nondefdecl);</a>
<a name="12956"><span class="lineNum">   12956 </span>            : </a>
<a name="12957"><span class="lineNum">   12957 </span><span class="lineCov">        149 :           nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="12958"><span class="lineNum">   12958 </span>            : </a>
<a name="12959"><span class="lineNum">   12959 </span>            :        // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.</a>
<a name="12960"><span class="lineNum">   12960 </span>            :        // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12961"><span class="lineNum">   12961 </span><span class="lineCov">        149 :           ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="12962"><span class="lineNum">   12962 </span><span class="lineCov">        149 :           ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="12963"><span class="lineNum">   12963 </span>            : </a>
<a name="12964"><span class="lineNum">   12964 </span><span class="lineCov">        149 :           nondefdecl-&gt;setForward();</span></a>
<a name="12965"><span class="lineNum">   12965 </span>            : </a>
<a name="12966"><span class="lineNum">   12966 </span>            :        // nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="12967"><span class="lineNum">   12967 </span><span class="lineCov">        149 :           nondefdecl-&gt;set_parent(scope);</span></a>
<a name="12968"><span class="lineNum">   12968 </span><span class="lineCov">        149 :           ROSE_ASSERT(nondefdecl-&gt;get_parent());</span></a>
<a name="12969"><span class="lineNum">   12969 </span>            : </a>
<a name="12970"><span class="lineNum">   12970 </span><span class="lineCov">        149 :           if (scope != NULL)</span></a>
<a name="12971"><span class="lineNum">   12971 </span>            :              {</a>
<a name="12972"><span class="lineNum">   12972 </span><span class="lineCov">        149 :                mysymbol = new SgNamespaceSymbol(name,nondefdecl); // tps: added name to constructor</span></a>
<a name="12973"><span class="lineNum">   12973 </span><span class="lineCov">        149 :                scope-&gt;insert_symbol(name, mysymbol);</span></a>
<a name="12974"><span class="lineNum">   12974 </span>            :              }</a>
<a name="12975"><span class="lineNum">   12975 </span>            :             else</a>
<a name="12976"><span class="lineNum">   12976 </span>            :              {</a>
<a name="12977"><span class="lineNum">   12977 </span>            :             // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="12978"><span class="lineNum">   12978 </span>            :             // break the existing interface. Need to discuss this with Liao.</a>
<a name="12979"><span class="lineNum">   12979 </span><span class="lineCov">        149 :                printf (&quot;Warning: no scope provided to support symbol table entry! \n&quot;);</span></a>
<a name="12980"><span class="lineNum">   12980 </span>            :              }</a>
<a name="12981"><span class="lineNum">   12981 </span>            : </a>
<a name="12982"><span class="lineNum">   12982 </span><span class="lineCov">        149 :           ROSE_ASSERT(defdecl-&gt;get_definition() != NULL);</span></a>
<a name="12983"><span class="lineNum">   12983 </span><span class="lineCov">        149 :           ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() != NULL);</span></a>
<a name="12984"><span class="lineNum">   12984 </span>            : </a>
<a name="12985"><span class="lineNum">   12985 </span><span class="lineCov">        149 :           ROSE_ASSERT(nondefdecl-&gt;get_definition()-&gt;get_previousNamespaceDefinition() == NULL);</span></a>
<a name="12986"><span class="lineNum">   12986 </span><span class="lineCov">        149 :           ROSE_ASSERT(nondefdecl-&gt;get_definition()-&gt;get_nextNamespaceDefinition() == NULL);</span></a>
<a name="12987"><span class="lineNum">   12987 </span>            :         }</a>
<a name="12988"><span class="lineNum">   12988 </span>            : </a>
<a name="12989"><span class="lineNum">   12989 </span><span class="lineCov">       1127 :      ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="12990"><span class="lineNum">   12990 </span>            : </a>
<a name="12991"><span class="lineNum">   12991 </span>            :   // printf (&quot;SageBuilder::buildNamespaceDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="12992"><span class="lineNum">   12992 </span>            : </a>
<a name="12993"><span class="lineNum">   12993 </span>            :   // setOneSourcePositionForTransformation(nondefdecl);</a>
<a name="12994"><span class="lineNum">   12994 </span>            :   // setOneSourcePositionNull(nondefdecl);</a>
<a name="12995"><span class="lineNum">   12995 </span>            : </a>
<a name="12996"><span class="lineNum">   12996 </span>            :   // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="12997"><span class="lineNum">   12997 </span>            :   // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="12998"><span class="lineNum">   12998 </span><span class="lineCov">       1127 :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="12999"><span class="lineNum">   12999 </span>            : </a>
<a name="13000"><span class="lineNum">   13000 </span>            :   // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).</a>
<a name="13001"><span class="lineNum">   13001 </span>            :   // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless</a>
<a name="13002"><span class="lineNum">   13002 </span>            :   // used in a defining declaration).</a>
<a name="13003"><span class="lineNum">   13003 </span><span class="lineCov">       1127 :      nondefdecl-&gt;setForward();</span></a>
<a name="13004"><span class="lineNum">   13004 </span>            : </a>
<a name="13005"><span class="lineNum">   13005 </span><span class="lineCov">       1127 :      if (scope != NULL)  // put into fixStructDeclaration() or alike later on</span></a>
<a name="13006"><span class="lineNum">   13006 </span>            :         {</a>
<a name="13007"><span class="lineNum">   13007 </span><span class="lineCov">       1127 :           fixNamespaceDeclaration(nondefdecl,scope);</span></a>
<a name="13008"><span class="lineNum">   13008 </span><span class="lineCov">       1127 :           fixNamespaceDeclaration(defdecl,scope);</span></a>
<a name="13009"><span class="lineNum">   13009 </span>            : #if 0</a>
<a name="13010"><span class="lineNum">   13010 </span>            :           SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="13011"><span class="lineNum">   13011 </span>            :           ROSE_ASSERT(mysymbol);</a>
<a name="13012"><span class="lineNum">   13012 </span>            :           scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="13013"><span class="lineNum">   13013 </span>            : #endif</a>
<a name="13014"><span class="lineNum">   13014 </span>            : </a>
<a name="13015"><span class="lineNum">   13015 </span>            :           // tps namespace has no scope</a>
<a name="13016"><span class="lineNum">   13016 </span>            :           //defdecl-&gt;set_scope(scope);</a>
<a name="13017"><span class="lineNum">   13017 </span>            :           //nondefdecl-&gt;set_scope(scope);</a>
<a name="13018"><span class="lineNum">   13018 </span>            : </a>
<a name="13019"><span class="lineNum">   13019 </span>            :        // defdecl-&gt;set_parent(scope);</a>
<a name="13020"><span class="lineNum">   13020 </span>            : </a>
<a name="13021"><span class="lineNum">   13021 </span>            :        // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).</a>
<a name="13022"><span class="lineNum">   13022 </span>            :        // nondefdecl-&gt;set_parent(scope);</a>
<a name="13023"><span class="lineNum">   13023 </span>            :         //  nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="13024"><span class="lineNum">   13024 </span>            :         }</a>
<a name="13025"><span class="lineNum">   13025 </span>            : </a>
<a name="13026"><span class="lineNum">   13026 </span>            :   //   defdecl-&gt;set_parent(topScopeStack());</a>
<a name="13027"><span class="lineNum">   13027 </span>            : </a>
<a name="13028"><span class="lineNum">   13028 </span>            :   // DQ (1/26/2009): I think we should assert this, but it breaks the interface as defined</a>
<a name="13029"><span class="lineNum">   13029 </span>            :   // by the test code in tests/nonsmoke/functional/roseTests/astInterfaceTests.</a>
<a name="13030"><span class="lineNum">   13030 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_parent() != NULL);</a>
<a name="13031"><span class="lineNum">   13031 </span>            : </a>
<a name="13032"><span class="lineNum">   13032 </span>            :   // ROSE_ASSERT(nonDefiningDecl-&gt;get_parent() != NULL);</a>
<a name="13033"><span class="lineNum">   13033 </span>            : </a>
<a name="13034"><span class="lineNum">   13034 </span>            :   // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.</a>
<a name="13035"><span class="lineNum">   13035 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="13036"><span class="lineNum">   13036 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != defdecl-&gt;get_definingDeclaration());</span></a>
<a name="13037"><span class="lineNum">   13037 </span>            : </a>
<a name="13038"><span class="lineNum">   13038 </span>            :   // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.</a>
<a name="13039"><span class="lineNum">   13039 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == NULL);</span></a>
<a name="13040"><span class="lineNum">   13040 </span>            : </a>
<a name="13041"><span class="lineNum">   13041 </span>            :   // DQ (5/16/2013): Added tests.</a>
<a name="13042"><span class="lineNum">   13042 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="13043"><span class="lineNum">   13043 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_definition() != NULL);</span></a>
<a name="13044"><span class="lineNum">   13044 </span><span class="lineCov">       1127 :      ROSE_ASSERT(defdecl-&gt;get_definition()-&gt;get_global_definition() != NULL);</span></a>
<a name="13045"><span class="lineNum">   13045 </span>            : </a>
<a name="13046"><span class="lineNum">   13046 </span>            : #if 0</a>
<a name="13047"><span class="lineNum">   13047 </span>            :   // DQ (5/19/2013): There should always be proper source file position infomation so this should not be required.</a>
<a name="13048"><span class="lineNum">   13048 </span>            :      if (defdecl-&gt;get_file_info()-&gt;isOutputInCodeGeneration() == true)</a>
<a name="13049"><span class="lineNum">   13049 </span>            :         {</a>
<a name="13050"><span class="lineNum">   13050 </span>            :           defdecl-&gt;get_file_info()-&gt;display(&quot;In buildNamespaceDeclaration_nfi(): namespaceDeclaration: debug&quot;);</a>
<a name="13051"><span class="lineNum">   13051 </span>            :         }</a>
<a name="13052"><span class="lineNum">   13052 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_file_info()-&gt;isOutputInCodeGeneration() == false);</a>
<a name="13053"><span class="lineNum">   13053 </span>            : #endif</a>
<a name="13054"><span class="lineNum">   13054 </span>            : </a>
<a name="13055"><span class="lineNum">   13055 </span><span class="lineCov">       1127 :      return defdecl;</span></a>
<a name="13056"><span class="lineNum">   13056 </span>            :    }</a>
<a name="13057"><span class="lineNum">   13057 </span>            : </a>
<a name="13058"><span class="lineNum">   13058 </span>            : // driscoll6 (7/20/11) : Support n-ary operators for python</a>
<a name="13059"><span class="lineNum">   13059 </span>            : SgNaryComparisonOp*</a>
<a name="13060"><span class="lineNum">   13060 </span><span class="lineNoCov">          0 : SageBuilder::buildNaryComparisonOp(SgExpression* lhs) {</span></a>
<a name="13061"><span class="lineNum">   13061 </span><span class="lineNoCov">          0 :     SgNaryComparisonOp* result = new SgNaryComparisonOp();</span></a>
<a name="13062"><span class="lineNum">   13062 </span>            : </a>
<a name="13063"><span class="lineNum">   13063 </span><span class="lineNoCov">          0 :     result-&gt;get_operands().push_back(lhs);</span></a>
<a name="13064"><span class="lineNum">   13064 </span><span class="lineNoCov">          0 :     lhs-&gt;set_parent(result);</span></a>
<a name="13065"><span class="lineNum">   13065 </span>            : </a>
<a name="13066"><span class="lineNum">   13066 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="13067"><span class="lineNum">   13067 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13068"><span class="lineNum">   13068 </span>            : }</a>
<a name="13069"><span class="lineNum">   13069 </span>            : </a>
<a name="13070"><span class="lineNum">   13070 </span>            : SgNaryComparisonOp*</a>
<a name="13071"><span class="lineNum">   13071 </span><span class="lineNoCov">          0 : SageBuilder::buildNaryComparisonOp_nfi(SgExpression* lhs) {</span></a>
<a name="13072"><span class="lineNum">   13072 </span><span class="lineNoCov">          0 :     SgNaryComparisonOp* result = new SgNaryComparisonOp();</span></a>
<a name="13073"><span class="lineNum">   13073 </span>            : </a>
<a name="13074"><span class="lineNum">   13074 </span><span class="lineNoCov">          0 :     result-&gt;get_operands().push_back(lhs);</span></a>
<a name="13075"><span class="lineNum">   13075 </span><span class="lineNoCov">          0 :     lhs-&gt;set_parent(result);</span></a>
<a name="13076"><span class="lineNum">   13076 </span>            : </a>
<a name="13077"><span class="lineNum">   13077 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="13078"><span class="lineNum">   13078 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13079"><span class="lineNum">   13079 </span>            : }</a>
<a name="13080"><span class="lineNum">   13080 </span>            : </a>
<a name="13081"><span class="lineNum">   13081 </span>            : SgNaryBooleanOp*</a>
<a name="13082"><span class="lineNum">   13082 </span><span class="lineNoCov">          0 : SageBuilder::buildNaryBooleanOp(SgExpression* lhs) {</span></a>
<a name="13083"><span class="lineNum">   13083 </span><span class="lineNoCov">          0 :     SgNaryBooleanOp* result = new SgNaryBooleanOp();</span></a>
<a name="13084"><span class="lineNum">   13084 </span>            : </a>
<a name="13085"><span class="lineNum">   13085 </span><span class="lineNoCov">          0 :     result-&gt;get_operands().push_back(lhs);</span></a>
<a name="13086"><span class="lineNum">   13086 </span><span class="lineNoCov">          0 :     lhs-&gt;set_parent(result);</span></a>
<a name="13087"><span class="lineNum">   13087 </span>            : </a>
<a name="13088"><span class="lineNum">   13088 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="13089"><span class="lineNum">   13089 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13090"><span class="lineNum">   13090 </span>            : }</a>
<a name="13091"><span class="lineNum">   13091 </span>            : </a>
<a name="13092"><span class="lineNum">   13092 </span>            : SgNaryBooleanOp*</a>
<a name="13093"><span class="lineNum">   13093 </span><span class="lineNoCov">          0 : SageBuilder::buildNaryBooleanOp_nfi(SgExpression* lhs) {</span></a>
<a name="13094"><span class="lineNum">   13094 </span><span class="lineNoCov">          0 :     SgNaryBooleanOp* result = new SgNaryBooleanOp();</span></a>
<a name="13095"><span class="lineNum">   13095 </span>            : </a>
<a name="13096"><span class="lineNum">   13096 </span><span class="lineNoCov">          0 :     result-&gt;get_operands().push_back(lhs);</span></a>
<a name="13097"><span class="lineNum">   13097 </span><span class="lineNoCov">          0 :     lhs-&gt;set_parent(result);</span></a>
<a name="13098"><span class="lineNum">   13098 </span>            : </a>
<a name="13099"><span class="lineNum">   13099 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="13100"><span class="lineNum">   13100 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13101"><span class="lineNum">   13101 </span>            : }</a>
<a name="13102"><span class="lineNum">   13102 </span>            : </a>
<a name="13103"><span class="lineNum">   13103 </span>            : SgStringConversion*</a>
<a name="13104"><span class="lineNum">   13104 </span><span class="lineNoCov">          0 : SageBuilder::buildStringConversion(SgExpression* exp) {</span></a>
<a name="13105"><span class="lineNum">   13105 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(exp);</span></a>
<a name="13106"><span class="lineNum">   13106 </span><span class="lineNoCov">          0 :     SgStringConversion* result = new SgStringConversion(exp);</span></a>
<a name="13107"><span class="lineNum">   13107 </span><span class="lineNoCov">          0 :     exp-&gt;set_parent(result);</span></a>
<a name="13108"><span class="lineNum">   13108 </span>            : </a>
<a name="13109"><span class="lineNum">   13109 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="13110"><span class="lineNum">   13110 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13111"><span class="lineNum">   13111 </span>            : }</a>
<a name="13112"><span class="lineNum">   13112 </span>            : </a>
<a name="13113"><span class="lineNum">   13113 </span>            : </a>
<a name="13114"><span class="lineNum">   13114 </span>            : SgStringConversion*</a>
<a name="13115"><span class="lineNum">   13115 </span><span class="lineNoCov">          0 : SageBuilder::buildStringConversion_nfi(SgExpression* exp) {</span></a>
<a name="13116"><span class="lineNum">   13116 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(exp);</span></a>
<a name="13117"><span class="lineNum">   13117 </span><span class="lineNoCov">          0 :     SgStringConversion* result = new SgStringConversion(exp);</span></a>
<a name="13118"><span class="lineNum">   13118 </span><span class="lineNoCov">          0 :     exp-&gt;set_parent(result);</span></a>
<a name="13119"><span class="lineNum">   13119 </span>            : </a>
<a name="13120"><span class="lineNum">   13120 </span><span class="lineNoCov">          0 :     setOneSourcePositionNull(result);</span></a>
<a name="13121"><span class="lineNum">   13121 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="13122"><span class="lineNum">   13122 </span>            : }</a>
<a name="13123"><span class="lineNum">   13123 </span>            : </a>
<a name="13124"><span class="lineNum">   13124 </span>            : // DQ (11/7/2009): Added more uniform support for building class declarations.</a>
<a name="13125"><span class="lineNum">   13125 </span>            : SgClassDeclaration*</a>
<a name="13126"><span class="lineNum">   13126 </span><span class="lineNoCov">          0 : SageBuilder::buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope )</span></a>
<a name="13127"><span class="lineNum">   13127 </span>            :    {</a>
<a name="13128"><span class="lineNum">   13128 </span><span class="lineNoCov">          0 :      SgClassDeclaration* defdecl    = NULL;</span></a>
<a name="13129"><span class="lineNum">   13129 </span><span class="lineNoCov">          0 :      SgClassDeclaration* nondefdecl = NULL;</span></a>
<a name="13130"><span class="lineNum">   13130 </span>            : </a>
<a name="13131"><span class="lineNum">   13131 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="13132"><span class="lineNum">   13132 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="13133"><span class="lineNum">   13133 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);</span></a>
<a name="13134"><span class="lineNum">   13134 </span>            : </a>
<a name="13135"><span class="lineNum">   13135 </span>            : #if 1</a>
<a name="13136"><span class="lineNum">   13136 </span><span class="lineNoCov">          0 :      printf (&quot;In buildNondefiningClassDeclaration(): name = %s scope = %p = %s \n&quot;,name.str(),scope,scope != NULL ? scope-&gt;class_name().c_str() : &quot;NULL&quot;);</span></a>
<a name="13137"><span class="lineNum">   13137 </span>            : </a>
<a name="13138"><span class="lineNum">   13138 </span>            :   // DQ (8/12/2013): If this function were to be called then we would have to</a>
<a name="13139"><span class="lineNum">   13139 </span>            :   // support a template argument list for the call to lookup_class_symbol().</a>
<a name="13140"><span class="lineNum">   13140 </span>            : </a>
<a name="13141"><span class="lineNum">   13141 </span>            :   // DQ (6/9/2013): I want to know that I'm not debugging this function.</a>
<a name="13142"><span class="lineNum">   13142 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="13143"><span class="lineNum">   13143 </span>            : #endif</a>
<a name="13144"><span class="lineNum">   13144 </span>            : </a>
<a name="13145"><span class="lineNum">   13145 </span>            :   // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/nonsmoke/functional/roseTests/astInterfaceTests test codes.</a>
<a name="13146"><span class="lineNum">   13146 </span>            :   // ROSE_ASSERT(scope != NULL);</a>
<a name="13147"><span class="lineNum">   13147 </span>            :      SgClassSymbol* mysymbol = NULL;</a>
<a name="13148"><span class="lineNum">   13148 </span>            :      if (scope != NULL)</a>
<a name="13149"><span class="lineNum">   13149 </span>            :         {</a>
<a name="13150"><span class="lineNum">   13150 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="13151"><span class="lineNum">   13151 </span>            :           mysymbol = scope-&gt;lookup_class_symbol(name,NULL);</a>
<a name="13152"><span class="lineNum">   13152 </span>            :         }</a>
<a name="13153"><span class="lineNum">   13153 </span>            :        else</a>
<a name="13154"><span class="lineNum">   13154 </span>            :         {</a>
<a name="13155"><span class="lineNum">   13155 </span>            :        // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.</a>
<a name="13156"><span class="lineNum">   13156 </span>            :        // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="13157"><span class="lineNum">   13157 </span>            :        // break the existing interface. Need to discuss this with Liao.</a>
<a name="13158"><span class="lineNum">   13158 </span>            :        // printf (&quot;Warning: In SageBuilder::buildClassDeclaration_nfi(): scope == NULL \n&quot;);</a>
<a name="13159"><span class="lineNum">   13159 </span>            :         }</a>
<a name="13160"><span class="lineNum">   13160 </span>            : </a>
<a name="13161"><span class="lineNum">   13161 </span>            : #if 0</a>
<a name="13162"><span class="lineNum">   13162 </span>            :      printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="13163"><span class="lineNum">   13163 </span>            : #endif</a>
<a name="13164"><span class="lineNum">   13164 </span>            : </a>
<a name="13165"><span class="lineNum">   13165 </span>            :      if (mysymbol != NULL) // set links if nondefining declaration already exists.</a>
<a name="13166"><span class="lineNum">   13166 </span>            :         {</a>
<a name="13167"><span class="lineNum">   13167 </span>            :           nondefdecl = isSgClassDeclaration(mysymbol-&gt;get_declaration());</a>
<a name="13168"><span class="lineNum">   13168 </span>            : </a>
<a name="13169"><span class="lineNum">   13169 </span>            :           ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="13170"><span class="lineNum">   13170 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13171"><span class="lineNum">   13171 </span>            : </a>
<a name="13172"><span class="lineNum">   13172 </span>            :           nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="13173"><span class="lineNum">   13173 </span>            : </a>
<a name="13174"><span class="lineNum">   13174 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="13175"><span class="lineNum">   13175 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</a>
<a name="13176"><span class="lineNum">   13176 </span>            : </a>
<a name="13177"><span class="lineNum">   13177 </span>            :        // DQ (10/30/2010): There should be a properly defined type at this point!</a>
<a name="13178"><span class="lineNum">   13178 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="13179"><span class="lineNum">   13179 </span>            : </a>
<a name="13180"><span class="lineNum">   13180 </span>            :        // DQ (7/31/2019): Check that this is true.</a>
<a name="13181"><span class="lineNum">   13181 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13182"><span class="lineNum">   13182 </span>            :         }</a>
<a name="13183"><span class="lineNum">   13183 </span>            :        else // build a nondefnining declaration if it does not exist</a>
<a name="13184"><span class="lineNum">   13184 </span>            :         {</a>
<a name="13185"><span class="lineNum">   13185 </span>            :        // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.</a>
<a name="13186"><span class="lineNum">   13186 </span>            : </a>
<a name="13187"><span class="lineNum">   13187 </span>            :           SgClassDeclaration::class_types kind = SgClassDeclaration::e_class;</a>
<a name="13188"><span class="lineNum">   13188 </span>            :           nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);</a>
<a name="13189"><span class="lineNum">   13189 </span>            :           ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="13190"><span class="lineNum">   13190 </span>            :           if (nondefdecl-&gt;get_type() == NULL)</a>
<a name="13191"><span class="lineNum">   13191 </span>            :              {</a>
<a name="13192"><span class="lineNum">   13192 </span>            :                nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="13193"><span class="lineNum">   13193 </span>            : #if 0</a>
<a name="13194"><span class="lineNum">   13194 </span>            :                printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): built class type: part 3: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="13195"><span class="lineNum">   13195 </span>            : #endif</a>
<a name="13196"><span class="lineNum">   13196 </span>            :              }</a>
<a name="13197"><span class="lineNum">   13197 </span>            : </a>
<a name="13198"><span class="lineNum">   13198 </span>            :  //         printf (&quot;SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="13199"><span class="lineNum">   13199 </span>            : </a>
<a name="13200"><span class="lineNum">   13200 </span>            :        // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="13201"><span class="lineNum">   13201 </span>            :        // generated (so we have something about the class that we can reference; e.g in</a>
<a name="13202"><span class="lineNum">   13202 </span>            :        // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="13203"><span class="lineNum">   13203 </span>            :        // of source position that would be more precise.  FIXME.</a>
<a name="13204"><span class="lineNum">   13204 </span>            :        // setOneSourcePositionNull(nondefdecl);</a>
<a name="13205"><span class="lineNum">   13205 </span>            :           setOneSourcePositionForTransformation(nondefdecl);</a>
<a name="13206"><span class="lineNum">   13206 </span>            : </a>
<a name="13207"><span class="lineNum">   13207 </span>            :           nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="13208"><span class="lineNum">   13208 </span>            :           nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="13209"><span class="lineNum">   13209 </span>            :           nondefdecl-&gt;setForward();</a>
<a name="13210"><span class="lineNum">   13210 </span>            :        // Liao, 9/2/2009. scope stack is optional, it can be empty</a>
<a name="13211"><span class="lineNum">   13211 </span>            :        // nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="13212"><span class="lineNum">   13212 </span>            :        // nondefdecl-&gt;set_parent(scope);</a>
<a name="13213"><span class="lineNum">   13213 </span>            : </a>
<a name="13214"><span class="lineNum">   13214 </span>            :        // DQ (7/31/2019): Check that this is true.</a>
<a name="13215"><span class="lineNum">   13215 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13216"><span class="lineNum">   13216 </span>            : </a>
<a name="13217"><span class="lineNum">   13217 </span>            :        // DQ (3/24/2011): This should be NULL before we set it (if the scope is known).</a>
<a name="13218"><span class="lineNum">   13218 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_scope() == NULL);</a>
<a name="13219"><span class="lineNum">   13219 </span>            :           if (scope != NULL)</a>
<a name="13220"><span class="lineNum">   13220 </span>            :              {</a>
<a name="13221"><span class="lineNum">   13221 </span>            :             // DQ (3/24/2011): Decided with Liao that we should set the scope where possible.  The AST consistancy test will make sure it is consistant with where it is inserted into the AST.</a>
<a name="13222"><span class="lineNum">   13222 </span>            :                nondefdecl-&gt;set_scope(scope);</a>
<a name="13223"><span class="lineNum">   13223 </span>            :                ROSE_ASSERT(nondefdecl-&gt;get_scope() != NULL);</a>
<a name="13224"><span class="lineNum">   13224 </span>            : </a>
<a name="13225"><span class="lineNum">   13225 </span>            :                mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="13226"><span class="lineNum">   13226 </span>            : #if 0</a>
<a name="13227"><span class="lineNum">   13227 </span>            :                printf (&quot;In buildNondefiningClassDeclaration(): Adding SgClassSymbol: mysymbol = %p from nondefdecl = %p = %s to scope = %p = %s \n&quot;,mysymbol,nondefdecl,nondefdecl-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13228"><span class="lineNum">   13228 </span>            : #endif</a>
<a name="13229"><span class="lineNum">   13229 </span>            :                scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="13230"><span class="lineNum">   13230 </span>            :              }</a>
<a name="13231"><span class="lineNum">   13231 </span>            :             else</a>
<a name="13232"><span class="lineNum">   13232 </span>            :              {</a>
<a name="13233"><span class="lineNum">   13233 </span>            :             // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unknown.</a>
<a name="13234"><span class="lineNum">   13234 </span>            :             // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="13235"><span class="lineNum">   13235 </span>            :             // break the existing interface. Need to discuss this with Liao.</a>
<a name="13236"><span class="lineNum">   13236 </span>            :             // printf (&quot;Warning: no scope provided to support symbol table entry! \n&quot;);</a>
<a name="13237"><span class="lineNum">   13237 </span>            :              }</a>
<a name="13238"><span class="lineNum">   13238 </span>            : </a>
<a name="13239"><span class="lineNum">   13239 </span>            :        // DQ (10/30/2010): There should be a properly defined type at this point!</a>
<a name="13240"><span class="lineNum">   13240 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="13241"><span class="lineNum">   13241 </span>            : </a>
<a name="13242"><span class="lineNum">   13242 </span>            :        // DQ (3/24/2011): The scope should be set if the scope was available.</a>
<a name="13243"><span class="lineNum">   13243 </span>            :           ROSE_ASSERT(scope == NULL || (scope != NULL &amp;&amp; nondefdecl-&gt;get_scope() != NULL));</a>
<a name="13244"><span class="lineNum">   13244 </span>            :         }</a>
<a name="13245"><span class="lineNum">   13245 </span>            : </a>
<a name="13246"><span class="lineNum">   13246 </span>            :      ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="13247"><span class="lineNum">   13247 </span>            : </a>
<a name="13248"><span class="lineNum">   13248 </span>            :      return nondefdecl;</a>
<a name="13249"><span class="lineNum">   13249 </span>            :    }</a>
<a name="13250"><span class="lineNum">   13250 </span>            : </a>
<a name="13251"><span class="lineNum">   13251 </span>            : // DQ (11/7/2009): Added more uniform support for building class declarations.</a>
<a name="13252"><span class="lineNum">   13252 </span>            : SgClassDeclaration*</a>
<a name="13253"><span class="lineNum">   13253 </span><span class="lineNoCov">          0 : SageBuilder::buildDefiningClassDeclaration ( SgName name, SgScopeStatement* scope )</span></a>
<a name="13254"><span class="lineNum">   13254 </span>            :    {</a>
<a name="13255"><span class="lineNum">   13255 </span>            :   // Note that the semantics of this function now differs from that of the buildDefiningFunctionDeclaration().</a>
<a name="13256"><span class="lineNum">   13256 </span>            :   // We want to have the non-defining declaration already exist before calling this function.</a>
<a name="13257"><span class="lineNum">   13257 </span>            :   // We could still build a higher level function that built both together.  Or we could provide two versions</a>
<a name="13258"><span class="lineNum">   13258 </span>            :   // named differently (from this one) and deprecate this function...which I like much better.</a>
<a name="13259"><span class="lineNum">   13259 </span><span class="lineNoCov">          0 :      printf (&quot;WARNING: This function for building defining class declarations has different semantics from that of the function to build defining function declarations. \n&quot;);</span></a>
<a name="13260"><span class="lineNum">   13260 </span>            : </a>
<a name="13261"><span class="lineNum">   13261 </span>            : #if 1</a>
<a name="13262"><span class="lineNum">   13262 </span><span class="lineNoCov">          0 :      printf (&quot;In buildDefiningClassDeclaration(): name = %s scope = %p = %s \n&quot;,name.str(),scope,scope != NULL ? scope-&gt;class_name().c_str() : &quot;NULL&quot;);</span></a>
<a name="13263"><span class="lineNum">   13263 </span>            : </a>
<a name="13264"><span class="lineNum">   13264 </span>            :   // DQ (6/9/2013): I want to know that I'm not debugging this function.</a>
<a name="13265"><span class="lineNum">   13265 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="13266"><span class="lineNum">   13266 </span>            : #endif</a>
<a name="13267"><span class="lineNum">   13267 </span>            : </a>
<a name="13268"><span class="lineNum">   13268 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="13269"><span class="lineNum">   13269 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="13270"><span class="lineNum">   13270 </span>            :      ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);</a>
<a name="13271"><span class="lineNum">   13271 </span>            : </a>
<a name="13272"><span class="lineNum">   13272 </span>            :      SgClassDeclaration* nondefiningClassDeclaration = buildNondefiningClassDeclaration(name,scope);</a>
<a name="13273"><span class="lineNum">   13273 </span>            :      ROSE_ASSERT(nondefiningClassDeclaration != NULL);</a>
<a name="13274"><span class="lineNum">   13274 </span>            : </a>
<a name="13275"><span class="lineNum">   13275 </span>            :      SgClassDefinition* definingClassDefinition = buildClassDefinition();</a>
<a name="13276"><span class="lineNum">   13276 </span>            :      ROSE_ASSERT(definingClassDefinition != NULL);</a>
<a name="13277"><span class="lineNum">   13277 </span>            : </a>
<a name="13278"><span class="lineNum">   13278 </span>            :   // DQ (10/30/2010): There should be a properly defined type at this point!</a>
<a name="13279"><span class="lineNum">   13279 </span>            :      SgClassType* classType = nondefiningClassDeclaration-&gt;get_type();</a>
<a name="13280"><span class="lineNum">   13280 </span>            :      ROSE_ASSERT(classType != NULL);</a>
<a name="13281"><span class="lineNum">   13281 </span>            : </a>
<a name="13282"><span class="lineNum">   13282 </span>            :      SgClassDeclaration::class_types kind = SgClassDeclaration::e_class;</a>
<a name="13283"><span class="lineNum">   13283 </span>            : </a>
<a name="13284"><span class="lineNum">   13284 </span>            :   // DQ (10/30/2010): We need to make sure that there is a type defined.</a>
<a name="13285"><span class="lineNum">   13285 </span>            :   // SgClassDeclaration* definingClassDeclaration = new SgClassDeclaration (name,kind,NULL,definingClassDefinition);</a>
<a name="13286"><span class="lineNum">   13286 </span>            :      SgClassDeclaration* definingClassDeclaration = new SgClassDeclaration (name,kind,classType,definingClassDefinition);</a>
<a name="13287"><span class="lineNum">   13287 </span>            :      ROSE_ASSERT(definingClassDeclaration != NULL);</a>
<a name="13288"><span class="lineNum">   13288 </span>            : </a>
<a name="13289"><span class="lineNum">   13289 </span>            :   // printf (&quot;SageBuilder::buildDefiningClassDeclaration(): definingClassDeclaration = %p \n&quot;,definingClassDeclaration);</a>
<a name="13290"><span class="lineNum">   13290 </span>            : </a>
<a name="13291"><span class="lineNum">   13291 </span>            :      setOneSourcePositionForTransformation(definingClassDeclaration);</a>
<a name="13292"><span class="lineNum">   13292 </span>            : </a>
<a name="13293"><span class="lineNum">   13293 </span>            :   // constructor is side-effect free</a>
<a name="13294"><span class="lineNum">   13294 </span>            :      definingClassDefinition-&gt;set_declaration(definingClassDeclaration);</a>
<a name="13295"><span class="lineNum">   13295 </span>            :      definingClassDeclaration-&gt;set_definingDeclaration(definingClassDeclaration);</a>
<a name="13296"><span class="lineNum">   13296 </span>            :      definingClassDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</a>
<a name="13297"><span class="lineNum">   13297 </span>            : </a>
<a name="13298"><span class="lineNum">   13298 </span>            :      nondefiningClassDeclaration-&gt;set_definingDeclaration(definingClassDeclaration);</a>
<a name="13299"><span class="lineNum">   13299 </span>            : </a>
<a name="13300"><span class="lineNum">   13300 </span>            :   // some error checking</a>
<a name="13301"><span class="lineNum">   13301 </span>            :      ROSE_ASSERT(nondefiningClassDeclaration-&gt;get_definingDeclaration() != NULL);</a>
<a name="13302"><span class="lineNum">   13302 </span>            :      ROSE_ASSERT(nondefiningClassDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="13303"><span class="lineNum">   13303 </span>            :      ROSE_ASSERT(definingClassDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="13304"><span class="lineNum">   13304 </span>            :      ROSE_ASSERT(definingClassDeclaration-&gt;get_definition() != NULL);</a>
<a name="13305"><span class="lineNum">   13305 </span>            : </a>
<a name="13306"><span class="lineNum">   13306 </span>            :      ROSE_ASSERT(definingClassDeclaration-&gt;get_scope() == NULL);</a>
<a name="13307"><span class="lineNum">   13307 </span>            :      if (scope != NULL)</a>
<a name="13308"><span class="lineNum">   13308 </span>            :         {</a>
<a name="13309"><span class="lineNum">   13309 </span>            :           definingClassDeclaration-&gt;set_scope(scope);</a>
<a name="13310"><span class="lineNum">   13310 </span>            :           ROSE_ASSERT(definingClassDeclaration-&gt;get_scope() != NULL);</a>
<a name="13311"><span class="lineNum">   13311 </span>            :           ROSE_ASSERT(nondefiningClassDeclaration-&gt;get_scope() != NULL);</a>
<a name="13312"><span class="lineNum">   13312 </span>            :         }</a>
<a name="13313"><span class="lineNum">   13313 </span>            : </a>
<a name="13314"><span class="lineNum">   13314 </span>            :      ROSE_ASSERT(definingClassDeclaration-&gt;get_definition()-&gt;get_parent() != NULL);</a>
<a name="13315"><span class="lineNum">   13315 </span>            : </a>
<a name="13316"><span class="lineNum">   13316 </span>            :   // DQ (10/30/2010): There should be a properly defined type at this point!</a>
<a name="13317"><span class="lineNum">   13317 </span>            :      ROSE_ASSERT(definingClassDeclaration-&gt;get_type() != NULL);</a>
<a name="13318"><span class="lineNum">   13318 </span>            : </a>
<a name="13319"><span class="lineNum">   13319 </span>            :      return definingClassDeclaration;</a>
<a name="13320"><span class="lineNum">   13320 </span>            :    }</a>
<a name="13321"><span class="lineNum">   13321 </span>            : </a>
<a name="13322"><span class="lineNum">   13322 </span>            : // DQ (11/7/2009): Added more uniform support for building class declarations.</a>
<a name="13323"><span class="lineNum">   13323 </span>            : SgClassDeclaration*</a>
<a name="13324"><span class="lineNum">   13324 </span><span class="lineNoCov">          0 : SageBuilder::buildClassDeclaration ( SgName name, SgScopeStatement* scope )</span></a>
<a name="13325"><span class="lineNum">   13325 </span>            :    {</a>
<a name="13326"><span class="lineNum">   13326 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="13327"><span class="lineNum">   13327 </span><span class="lineNoCov">          0 :      SgClassDeclaration* definingClassDeclaration = buildDefiningClassDeclaration(name,scope);</span></a>
<a name="13328"><span class="lineNum">   13328 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="13329"><span class="lineNum">   13329 </span>            : </a>
<a name="13330"><span class="lineNum">   13330 </span><span class="lineNoCov">          0 :      return definingClassDeclaration;</span></a>
<a name="13331"><span class="lineNum">   13331 </span>            :    }</a>
<a name="13332"><span class="lineNum">   13332 </span>            : </a>
<a name="13333"><span class="lineNum">   13333 </span>            : </a>
<a name="13334"><span class="lineNum">   13334 </span>            : // DQ (6/6/2012): Added support for template arguments (so that the type could be computing using the template arguments when building a template instantiation).</a>
<a name="13335"><span class="lineNum">   13335 </span>            : // DQ (1/24/2009): Built this &quot;nfi&quot; version but factored the code.</a>
<a name="13336"><span class="lineNum">   13336 </span>            : // SgClassDeclaration* SageBuilder::buildClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl , bool buildTemplateInstantiation )</a>
<a name="13337"><span class="lineNum">   13337 </span>            : SgClassDeclaration*</a>
<a name="13338"><span class="lineNum">   13338 </span><span class="lineCov">      12209 : SageBuilder::buildClassDeclaration_nfi(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl , bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList )</span></a>
<a name="13339"><span class="lineNum">   13339 </span>            :    {</a>
<a name="13340"><span class="lineNum">   13340 </span>            :   // DQ (3/15/2012): Added function to build C++ class (builds both the non-defining and defining declarations; in that order).</a>
<a name="13341"><span class="lineNum">   13341 </span>            :   // The implementation of this function could be simplified to directly call both:</a>
<a name="13342"><span class="lineNum">   13342 </span>            :   //    SgClassDeclaration* buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope );</a>
<a name="13343"><span class="lineNum">   13343 </span>            :   // and</a>
<a name="13344"><span class="lineNum">   13344 </span>            :   //    SgClassDeclaration* buildDefiningClassDeclaration    ( SgName name, SgScopeStatement* scope );</a>
<a name="13345"><span class="lineNum">   13345 </span>            :   // This might refactor the implementation nicely.</a>
<a name="13346"><span class="lineNum">   13346 </span>            : </a>
<a name="13347"><span class="lineNum">   13347 </span>            : #define DEBUG_CLASS_DECLARATION 0</a>
<a name="13348"><span class="lineNum">   13348 </span>            : </a>
<a name="13349"><span class="lineNum">   13349 </span>            :   // Note that the nonDefiningDecl pointer does not appear to be used.</a>
<a name="13350"><span class="lineNum">   13350 </span>            : #if 0</a>
<a name="13351"><span class="lineNum">   13351 </span>            :      printf (&quot;WARNING: In SageBuilder::buildClassDeclaration_nfi(): the nonDefiningDecl pointer = %p (input parameter) does not appear to be used. \n&quot;,nonDefiningDecl);</a>
<a name="13352"><span class="lineNum">   13352 </span>            : #endif</a>
<a name="13353"><span class="lineNum">   13353 </span>            : </a>
<a name="13354"><span class="lineNum">   13354 </span>            : #if 0</a>
<a name="13355"><span class="lineNum">   13355 </span>            :   // DQ (3/4/2018): Adding testing.</a>
<a name="13356"><span class="lineNum">   13356 </span>            :   // ROSE_ASSERT(nonDefiningDecl != NULL);</a>
<a name="13357"><span class="lineNum">   13357 </span>            :      if (nonDefiningDecl != NULL)</a>
<a name="13358"><span class="lineNum">   13358 </span>            :         {</a>
<a name="13359"><span class="lineNum">   13359 </span>            :           ROSE_ASSERT(nonDefiningDecl-&gt;get_type() != NULL);</a>
<a name="13360"><span class="lineNum">   13360 </span>            :           ROSE_ASSERT(nonDefiningDecl-&gt;get_type()-&gt;get_declaration() != NULL);</a>
<a name="13361"><span class="lineNum">   13361 </span>            :           printf (&quot;nonDefiningDecl-&gt;get_type() = %p = %s \n&quot;,nonDefiningDecl-&gt;get_type(),nonDefiningDecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="13362"><span class="lineNum">   13362 </span>            :           printf (&quot;nonDefiningDecl-&gt;get_type()-&gt;get_declaration() = %p = %s \n&quot;,nonDefiningDecl-&gt;get_type()-&gt;get_declaration(),nonDefiningDecl-&gt;get_type()-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="13363"><span class="lineNum">   13363 </span>            : #if 0</a>
<a name="13364"><span class="lineNum">   13364 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): nonDefiningDecl: unparseNameToString() = %s \n&quot;,nonDefiningDecl-&gt;unparseNameToString().c_str());</a>
<a name="13365"><span class="lineNum">   13365 </span>            : #endif</a>
<a name="13366"><span class="lineNum">   13366 </span>            : </a>
<a name="13367"><span class="lineNum">   13367 </span>            :         }</a>
<a name="13368"><span class="lineNum">   13368 </span>            : #endif</a>
<a name="13369"><span class="lineNum">   13369 </span>            : </a>
<a name="13370"><span class="lineNum">   13370 </span>            : </a>
<a name="13371"><span class="lineNum">   13371 </span>            :   // DQ (10/10/2015): I think we can assert this! NO we can't (see test2015_87.C).</a>
<a name="13372"><span class="lineNum">   13372 </span>            :   // ROSE_ASSERT(nonDefiningDecl != NULL);</a>
<a name="13373"><span class="lineNum">   13373 </span>            : </a>
<a name="13374"><span class="lineNum">   13374 </span>            :   // DQ (10/10/2015): OK, now we have a valid use on the input non-defining declaration.</a>
<a name="13375"><span class="lineNum">   13375 </span><span class="lineCov">      12209 :      bool buildTemplateDeclaration = (isSgTemplateClassDeclaration(nonDefiningDecl) != NULL);</span></a>
<a name="13376"><span class="lineNum">   13376 </span>            : </a>
<a name="13377"><span class="lineNum">   13377 </span>            :   // DQ (10/10/2015): If this is true, then we should have called a different function to build the associated SgTemplateClassDeclaration.</a>
<a name="13378"><span class="lineNum">   13378 </span><span class="lineCov">      12209 :      if (buildTemplateDeclaration == true)</span></a>
<a name="13379"><span class="lineNum">   13379 </span>            :         {</a>
<a name="13380"><span class="lineNum">   13380 </span>            :        // Error checking.</a>
<a name="13381"><span class="lineNum">   13381 </span><span class="lineNoCov">          0 :           printf (&quot;ERROR: If buildTemplateDeclaration == true, then we should have called a different function to build the associated SgTemplateClassDeclaration \n&quot;);</span></a>
<a name="13382"><span class="lineNum">   13382 </span>            :         }</a>
<a name="13383"><span class="lineNum">   13383 </span><span class="lineCov">      12209 :      ROSE_ASSERT(buildTemplateDeclaration == false);</span></a>
<a name="13384"><span class="lineNum">   13384 </span>            : </a>
<a name="13385"><span class="lineNum">   13385 </span>            : #if 0</a>
<a name="13386"><span class="lineNum">   13386 </span>            :      printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): XXX_name = %s \n&quot;,XXX_name.str());</a>
<a name="13387"><span class="lineNum">   13387 </span>            :      printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): the nonDefiningDecl pointer = %p = %s \n&quot;,nonDefiningDecl,nonDefiningDecl != NULL ? nonDefiningDecl-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="13388"><span class="lineNum">   13388 </span>            :      printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): buildTemplateDeclaration    = %s \n&quot;,buildTemplateDeclaration ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13389"><span class="lineNum">   13389 </span>            :      printf (&quot;   --- templateArgumentsList = %p \n&quot;,templateArgumentsList);</a>
<a name="13390"><span class="lineNum">   13390 </span>            :      if (templateArgumentsList != NULL)</a>
<a name="13391"><span class="lineNum">   13391 </span>            :         {</a>
<a name="13392"><span class="lineNum">   13392 </span>            :           printf (&quot;   --- templateArgumentsList.size() = %zu \n&quot;,templateArgumentsList-&gt;size());</a>
<a name="13393"><span class="lineNum">   13393 </span>            :           for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="13394"><span class="lineNum">   13394 </span>            :              {</a>
<a name="13395"><span class="lineNum">   13395 </span>            :                printf (&quot;   --- --- argument pointer: templateArgumentsList-&gt;[%zu] = %p \n&quot;,i,templateArgumentsList-&gt;operator[](i));</a>
<a name="13396"><span class="lineNum">   13396 </span>            :              }</a>
<a name="13397"><span class="lineNum">   13397 </span>            :         }</a>
<a name="13398"><span class="lineNum">   13398 </span>            : #endif</a>
<a name="13399"><span class="lineNum">   13399 </span>            : </a>
<a name="13400"><span class="lineNum">   13400 </span><span class="lineCov">      12209 :      if (scope == NULL)</span></a>
<a name="13401"><span class="lineNum">   13401 </span>            :         {</a>
<a name="13402"><span class="lineNum">   13402 </span><span class="lineCov">          1 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="13403"><span class="lineNum">   13403 </span>            : #if 0</a>
<a name="13404"><span class="lineNum">   13404 </span>            :           printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): no scope was provided so using the SageBuilder::topScopeStack() = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="13405"><span class="lineNum">   13405 </span>            : #endif</a>
<a name="13406"><span class="lineNum">   13406 </span>            :         }</a>
<a name="13407"><span class="lineNum">   13407 </span>            :        else</a>
<a name="13408"><span class="lineNum">   13408 </span>            :         {</a>
<a name="13409"><span class="lineNum">   13409 </span>            : #if 0</a>
<a name="13410"><span class="lineNum">   13410 </span>            :           printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): scope was provided scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="13411"><span class="lineNum">   13411 </span>            : #endif</a>
<a name="13412"><span class="lineNum">   13412 </span>            :         }</a>
<a name="13413"><span class="lineNum">   13413 </span>            : </a>
<a name="13414"><span class="lineNum">   13414 </span>            : #if 0</a>
<a name="13415"><span class="lineNum">   13415 </span>            :      printf (&quot;Building a SgClassDeclaration: buildClassDeclaration_nfi() XXX_name = %s buildTemplateInstantiation = %s \n&quot;,XXX_name.str(),buildTemplateInstantiation ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13416"><span class="lineNum">   13416 </span>            : #endif</a>
<a name="13417"><span class="lineNum">   13417 </span>            : </a>
<a name="13418"><span class="lineNum">   13418 </span>            :   // Step 2 (now step 1). build the nondefining declaration,</a>
<a name="13419"><span class="lineNum">   13419 </span>            :   // but only if the input nonDefiningDecl pointer was NULL and it does not exist</a>
<a name="13420"><span class="lineNum">   13420 </span>            : </a>
<a name="13421"><span class="lineNum">   13421 </span>            :   // Get the nondefining declaration from the symbol if it has been built (if this works,</a>
<a name="13422"><span class="lineNum">   13422 </span>            :   // then we likely don't need the &quot;SgClassDeclaration* nonDefiningDecl&quot; parameter).</a>
<a name="13423"><span class="lineNum">   13423 </span><span class="lineCov">      12209 :      SgClassDeclaration* nondefdecl = NULL;</span></a>
<a name="13424"><span class="lineNum">   13424 </span>            : </a>
<a name="13425"><span class="lineNum">   13425 </span><span class="lineCov">      24418 :      SgName nameWithoutTemplateArguments = XXX_name;</span></a>
<a name="13426"><span class="lineNum">   13426 </span><span class="lineCov">      12209 :      SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;</span></a>
<a name="13427"><span class="lineNum">   13427 </span><span class="lineCov">      12209 :      if (buildTemplateInstantiation == true)</span></a>
<a name="13428"><span class="lineNum">   13428 </span>            :         {</a>
<a name="13429"><span class="lineNum">   13429 </span><span class="lineCov">       5417 :           ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="13430"><span class="lineNum">   13430 </span><span class="lineCov">       5417 :           nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);</span></a>
<a name="13431"><span class="lineNum">   13431 </span>            :         }</a>
<a name="13432"><span class="lineNum">   13432 </span>            : </a>
<a name="13433"><span class="lineNum">   13433 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13434"><span class="lineNum">   13434 </span>            :       printf (&quot;In SageBuilder::buildClassDeclaration_nfi():\n&quot;);</a>
<a name="13435"><span class="lineNum">   13435 </span>            :       printf (&quot;  -- nameWithoutTemplateArguments = %s\n&quot;, nameWithoutTemplateArguments.str());</a>
<a name="13436"><span class="lineNum">   13436 </span>            :       printf (&quot;  -- nameWithTemplateArguments    = %s\n&quot;, nameWithTemplateArguments.str());</a>
<a name="13437"><span class="lineNum">   13437 </span>            : #endif</a>
<a name="13438"><span class="lineNum">   13438 </span>            : </a>
<a name="13439"><span class="lineNum">   13439 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="13440"><span class="lineNum">   13440 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="13441"><span class="lineNum">   13441 </span>            :   // This fails for test2005_35.C</a>
<a name="13442"><span class="lineNum">   13442 </span>            :   // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);</a>
<a name="13443"><span class="lineNum">   13443 </span>            : </a>
<a name="13444"><span class="lineNum">   13444 </span>            :   // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/nonsmoke/functional/roseTests/astInterfaceTests test codes.</a>
<a name="13445"><span class="lineNum">   13445 </span>            :   // ROSE_ASSERT(scope != NULL);</a>
<a name="13446"><span class="lineNum">   13446 </span><span class="lineCov">      12209 :      SgClassSymbol* mysymbol = NULL;</span></a>
<a name="13447"><span class="lineNum">   13447 </span><span class="lineCov">      12209 :      if (scope != NULL)</span></a>
<a name="13448"><span class="lineNum">   13448 </span>            :         {</a>
<a name="13449"><span class="lineNum">   13449 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13450"><span class="lineNum">   13450 </span>            :           printf (&quot;Looking up the SgClassSymbol in scope = %p = %s nameWithTemplateArguments = %s \n&quot;,scope,scope-&gt;class_name().c_str(),nameWithTemplateArguments.str());</a>
<a name="13451"><span class="lineNum">   13451 </span>            : #endif</a>
<a name="13452"><span class="lineNum">   13452 </span>            : </a>
<a name="13453"><span class="lineNum">   13453 </span>            :        // DQ (8/22/2012): We need to provide more information ofr the symbol table lookup to correctly resolve</a>
<a name="13454"><span class="lineNum">   13454 </span>            :        // (and disambiguate template instantations where the name qualification of the template arguments would</a>
<a name="13455"><span class="lineNum">   13455 </span>            :        // be significant).</a>
<a name="13456"><span class="lineNum">   13456 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="13457"><span class="lineNum">   13457 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="13458"><span class="lineNum">   13458 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(nameWithTemplateArguments);</a>
<a name="13459"><span class="lineNum">   13459 </span>            : #if 0</a>
<a name="13460"><span class="lineNum">   13460 </span>            :        // DQ (7/25/2017): Since this is overwritten below, for both branches, we don't need to call this here.</a>
<a name="13461"><span class="lineNum">   13461 </span>            :           printf (&quot;This was a redundant call to lookup_class_symbol \n&quot;);</a>
<a name="13462"><span class="lineNum">   13462 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(nameWithTemplateArguments,templateArgumentsList);</a>
<a name="13463"><span class="lineNum">   13463 </span>            : #endif</a>
<a name="13464"><span class="lineNum">   13464 </span>            : </a>
<a name="13465"><span class="lineNum">   13465 </span>            :        // DQ (10/10/2015): look up the correct type of symbol.</a>
<a name="13466"><span class="lineNum">   13466 </span><span class="lineCov">      12209 :           if (buildTemplateDeclaration == true)</span></a>
<a name="13467"><span class="lineNum">   13467 </span>            :              {</a>
<a name="13468"><span class="lineNum">   13468 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13469"><span class="lineNum">   13469 </span>            :                printf (&quot;Note: In SageBuilder::buildClassDeclaration_nfi(): Need to look up a template symbol \n&quot;);</a>
<a name="13470"><span class="lineNum">   13470 </span>            : #endif</a>
<a name="13471"><span class="lineNum">   13471 </span>            :                ROSE_ASSERT(nonDefiningDecl != NULL);</a>
<a name="13472"><span class="lineNum">   13472 </span>            : </a>
<a name="13473"><span class="lineNum">   13473 </span>            :                SgTemplateParameterPtrList templateParameterList;</a>
<a name="13474"><span class="lineNum">   13474 </span>            :                SgTemplateArgumentPtrList templateSpecializationArgumentList;</a>
<a name="13475"><span class="lineNum">   13475 </span>            : </a>
<a name="13476"><span class="lineNum">   13476 </span>            :                ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(nameWithTemplateArguments,&amp;templateParameterList,&amp;templateSpecializationArgumentList) != NULL);</a>
<a name="13477"><span class="lineNum">   13477 </span>            : </a>
<a name="13478"><span class="lineNum">   13478 </span>            :                mysymbol = scope-&gt;lookup_template_class_symbol(nameWithTemplateArguments,&amp;templateParameterList,&amp;templateSpecializationArgumentList);</a>
<a name="13479"><span class="lineNum">   13479 </span>            : </a>
<a name="13480"><span class="lineNum">   13480 </span>            :                ROSE_ASSERT(mysymbol != NULL);</a>
<a name="13481"><span class="lineNum">   13481 </span>            : #if 0</a>
<a name="13482"><span class="lineNum">   13482 </span>            :                printf (&quot;ERROR: Need to look up a template symbol \n&quot;);</a>
<a name="13483"><span class="lineNum">   13483 </span>            :                ROSE_ABORT();</a>
<a name="13484"><span class="lineNum">   13484 </span>            : #endif</a>
<a name="13485"><span class="lineNum">   13485 </span>            :              }</a>
<a name="13486"><span class="lineNum">   13486 </span>            :             else</a>
<a name="13487"><span class="lineNum">   13487 </span>            :              {</a>
<a name="13488"><span class="lineNum">   13488 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13489"><span class="lineNum">   13489 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): calling lookup_class_symbol(nameWithTemplateArguments = %s,templateArgumentsList-&gt;size() = %zu \n&quot;,</a>
<a name="13490"><span class="lineNum">   13490 </span>            :                        nameWithTemplateArguments.str(),(templateArgumentsList != NULL) ? templateArgumentsList-&gt;size() : 999);</a>
<a name="13491"><span class="lineNum">   13491 </span>            :                if (templateArgumentsList != NULL)</a>
<a name="13492"><span class="lineNum">   13492 </span>            :                   {</a>
<a name="13493"><span class="lineNum">   13493 </span>            :                     printf (&quot;   --- templateArgumentsList elements: \n&quot;);</a>
<a name="13494"><span class="lineNum">   13494 </span>            :                     for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="13495"><span class="lineNum">   13495 </span>            :                        {</a>
<a name="13496"><span class="lineNum">   13496 </span>            :                          printf (&quot;   --- --- templateArgumentsList-&gt;[%zu] = %p \n&quot;,i,templateArgumentsList-&gt;operator[](i));</a>
<a name="13497"><span class="lineNum">   13497 </span>            :                          printf (&quot;   --- --- templateArgumentsList-&gt;[%zu] = %s \n&quot;,i,templateArgumentsList-&gt;operator[](i)-&gt;class_name().c_str());</a>
<a name="13498"><span class="lineNum">   13498 </span>            :                          templateArgumentsList-&gt;operator[](i)-&gt;display(&quot;In SageBuilder::buildClassDeclaration_nfi()&quot;);</a>
<a name="13499"><span class="lineNum">   13499 </span>            :                        }</a>
<a name="13500"><span class="lineNum">   13500 </span>            :                   }</a>
<a name="13501"><span class="lineNum">   13501 </span>            : #endif</a>
<a name="13502"><span class="lineNum">   13502 </span><span class="lineCov">      12209 :                mysymbol = scope-&gt;lookup_class_symbol(nameWithTemplateArguments,templateArgumentsList);</span></a>
<a name="13503"><span class="lineNum">   13503 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13504"><span class="lineNum">   13504 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="13505"><span class="lineNum">   13505 </span>            : #endif</a>
<a name="13506"><span class="lineNum">   13506 </span>            :             // DQ (3/4/2018): The only time I see this failing is when we should have used the nonDefiningDecl (see Cxx11_tests/test2015_08.C).</a>
<a name="13507"><span class="lineNum">   13507 </span><span class="lineCov">      12209 :                if (mysymbol == NULL)</span></a>
<a name="13508"><span class="lineNum">   13508 </span>            :                   {</a>
<a name="13509"><span class="lineNum">   13509 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13510"><span class="lineNum">   13510 </span>            :                     printf (&quot;WARNING: scope-&gt;lookup_class_symbol(nameWithTemplateArguments = %s,templateArgumentsList-&gt;size() = %zu) == NULL \n&quot;,nameWithTemplateArguments.str(),templateArgumentsList-&gt;size());</a>
<a name="13511"><span class="lineNum">   13511 </span>            : #endif</a>
<a name="13512"><span class="lineNum">   13512 </span>            :                  // ROSE_ASSERT(nonDefiningDecl != NULL);</a>
<a name="13513"><span class="lineNum">   13513 </span>            : </a>
<a name="13514"><span class="lineNum">   13514 </span>            :                  // DQ (12/28/2018): Could it be that we wanted to use the name without template arguments.</a>
<a name="13515"><span class="lineNum">   13515 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13516"><span class="lineNum">   13516 </span>            :                     printf (&quot;Checking lookup_class_symbol() using nameWithoutTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="13517"><span class="lineNum">   13517 </span>            : #endif</a>
<a name="13518"><span class="lineNum">   13518 </span><span class="lineCov">       9579 :                     ROSE_ASSERT(scope-&gt;lookup_class_symbol(nameWithoutTemplateArguments,templateArgumentsList) == NULL);</span></a>
<a name="13519"><span class="lineNum">   13519 </span>            : </a>
<a name="13520"><span class="lineNum">   13520 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13521"><span class="lineNum">   13521 </span>            :                     printf (&quot;nonDefiningDecl = %p \n&quot;,nonDefiningDecl);</a>
<a name="13522"><span class="lineNum">   13522 </span>            : #endif</a>
<a name="13523"><span class="lineNum">   13523 </span><span class="lineCov">       9579 :                     if (nonDefiningDecl != NULL)</span></a>
<a name="13524"><span class="lineNum">   13524 </span>            :                        {</a>
<a name="13525"><span class="lineNum">   13525 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13526"><span class="lineNum">   13526 </span>            :                          printf (&quot;nonDefiningDecl = %p = %s \n&quot;,nonDefiningDecl,nonDefiningDecl-&gt;class_name().c_str());</a>
<a name="13527"><span class="lineNum">   13527 </span>            : #endif</a>
<a name="13528"><span class="lineNum">   13528 </span>            :                       // DQ (3/4/2018): I think this is the correct API to use (internal use only).</a>
<a name="13529"><span class="lineNum">   13529 </span><span class="lineNoCov">          0 :                          SgSymbol* temp_mysymbol = nonDefiningDecl-&gt;get_symbol_from_symbol_table();</span></a>
<a name="13530"><span class="lineNum">   13530 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(temp_mysymbol != NULL);</span></a>
<a name="13531"><span class="lineNum">   13531 </span>            : </a>
<a name="13532"><span class="lineNum">   13532 </span><span class="lineNoCov">          0 :                          mysymbol = isSgClassSymbol(temp_mysymbol);</span></a>
<a name="13533"><span class="lineNum">   13533 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(mysymbol != NULL);</span></a>
<a name="13534"><span class="lineNum">   13534 </span>            : </a>
<a name="13535"><span class="lineNum">   13535 </span>            :                       // DQ (3/4/2018): check that the scopes are the same.</a>
<a name="13536"><span class="lineNum">   13536 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope == nonDefiningDecl-&gt;get_scope());</span></a>
<a name="13537"><span class="lineNum">   13537 </span>            :                        }</a>
<a name="13538"><span class="lineNum">   13538 </span>            :                   }</a>
<a name="13539"><span class="lineNum">   13539 </span>            :              }</a>
<a name="13540"><span class="lineNum">   13540 </span>            : </a>
<a name="13541"><span class="lineNum">   13541 </span>            : #if 0</a>
<a name="13542"><span class="lineNum">   13542 </span>            :        // DQ (11/21/2013): Added test based on debugging session with Philippe.</a>
<a name="13543"><span class="lineNum">   13543 </span>            :        // This test is not a test for a bug, since we require that symbols in base classes be aliased in the derived classes.</a>
<a name="13544"><span class="lineNum">   13544 </span>            :           if (mysymbol != NULL)</a>
<a name="13545"><span class="lineNum">   13545 </span>            :              {</a>
<a name="13546"><span class="lineNum">   13546 </span>            :                SgClassDeclaration* symbol_declaration = isSgClassDeclaration(mysymbol-&gt;get_declaration());</a>
<a name="13547"><span class="lineNum">   13547 </span>            :                ROSE_ASSERT(symbol_declaration != NULL);</a>
<a name="13548"><span class="lineNum">   13548 </span>            :                ROSE_ASSERT(symbol_declaration-&gt;get_scope() == scope);</a>
<a name="13549"><span class="lineNum">   13549 </span>            : </a>
<a name="13550"><span class="lineNum">   13550 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): Testing scope-&gt;get_symbol_table()-&gt;exists(mysymbol) == true (expensive) \n&quot;);</a>
<a name="13551"><span class="lineNum">   13551 </span>            : </a>
<a name="13552"><span class="lineNum">   13552 </span>            :                ROSE_ASSERT(scope-&gt;get_symbol_table()-&gt;exists(mysymbol) == true);</a>
<a name="13553"><span class="lineNum">   13553 </span>            :              }</a>
<a name="13554"><span class="lineNum">   13554 </span>            : #endif</a>
<a name="13555"><span class="lineNum">   13555 </span>            :         }</a>
<a name="13556"><span class="lineNum">   13556 </span>            :        else</a>
<a name="13557"><span class="lineNum">   13557 </span>            :         {</a>
<a name="13558"><span class="lineNum">   13558 </span>            :        // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unknow.</a>
<a name="13559"><span class="lineNum">   13559 </span>            :        // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="13560"><span class="lineNum">   13560 </span>            :        // break the existing interface. Need to discuss this with Liao.</a>
<a name="13561"><span class="lineNum">   13561 </span>            :        // printf (&quot;Warning: In SageBuilder::buildClassDeclaration_nfi(): scope == NULL \n&quot;);</a>
<a name="13562"><span class="lineNum">   13562 </span>            :         }</a>
<a name="13563"><span class="lineNum">   13563 </span>            : </a>
<a name="13564"><span class="lineNum">   13564 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13565"><span class="lineNum">   13565 </span>            :      printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="13566"><span class="lineNum">   13566 </span>            : #endif</a>
<a name="13567"><span class="lineNum">   13567 </span>            : </a>
<a name="13568"><span class="lineNum">   13568 </span><span class="lineCov">      12209 :      if (mysymbol != NULL) // set links if nondefining declaration already exists.</span></a>
<a name="13569"><span class="lineNum">   13569 </span>            :         {</a>
<a name="13570"><span class="lineNum">   13570 </span><span class="lineCov">       2630 :           nondefdecl = isSgClassDeclaration(mysymbol-&gt;get_declaration());</span></a>
<a name="13571"><span class="lineNum">   13571 </span>            : </a>
<a name="13572"><span class="lineNum">   13572 </span><span class="lineCov">       2630 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="13573"><span class="lineNum">   13573 </span>            : </a>
<a name="13574"><span class="lineNum">   13574 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13575"><span class="lineNum">   13575 </span>            :           printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): mysymbol-&gt;get_declaration(): nondefdecl = %p = %s nondefdecl-&gt;get_definition() = %p = %s \n&quot;,</a>
<a name="13576"><span class="lineNum">   13576 </span>            :                nondefdecl,nondefdecl-&gt;class_name().c_str(),nondefdecl-&gt;get_definition(),</a>
<a name="13577"><span class="lineNum">   13577 </span>            :                nondefdecl-&gt;get_definition() != NULL ? nondefdecl-&gt;get_definition()-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="13578"><span class="lineNum">   13578 </span>            : #endif</a>
<a name="13579"><span class="lineNum">   13579 </span>            :        // DQ (6/8/2013): This should not be true (see test2013_198.C).</a>
<a name="13580"><span class="lineNum">   13580 </span>            :        // Fundamentally the symbol should always only have a pointer to a non-defining</a>
<a name="13581"><span class="lineNum">   13581 </span>            :        // declaration, where by definition (get_definition() == NULL).</a>
<a name="13582"><span class="lineNum">   13582 </span><span class="lineCov">       2630 :           ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="13583"><span class="lineNum">   13583 </span>            : </a>
<a name="13584"><span class="lineNum">   13584 </span>            :        // DQ (9/16/2012): This should be true by definition (verify).</a>
<a name="13585"><span class="lineNum">   13585 </span><span class="lineCov">       2630 :           ROSE_ASSERT(nondefdecl == nondefdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="13586"><span class="lineNum">   13586 </span>            : </a>
<a name="13587"><span class="lineNum">   13587 </span>            :        // DQ (9/16/2012): The declaration was build previously, but test it to make sure the template arguments were setup properly.</a>
<a name="13588"><span class="lineNum">   13588 </span><span class="lineCov">       2630 :           testTemplateArgumentParents(nondefdecl);</span></a>
<a name="13589"><span class="lineNum">   13589 </span>            : </a>
<a name="13590"><span class="lineNum">   13590 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="13591"><span class="lineNum">   13591 </span>            :        // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="13592"><span class="lineNum">   13592 </span>            :           detectTransformations(nondefdecl);</a>
<a name="13593"><span class="lineNum">   13593 </span>            : #endif</a>
<a name="13594"><span class="lineNum">   13594 </span>            : </a>
<a name="13595"><span class="lineNum">   13595 </span>            :        // DQ (3/22/2012): I think we can assert this.</a>
<a name="13596"><span class="lineNum">   13596 </span><span class="lineCov">       2630 :           ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="13597"><span class="lineNum">   13597 </span>            : </a>
<a name="13598"><span class="lineNum">   13598 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13599"><span class="lineNum">   13599 </span><span class="lineCov">       2630 :           if (nondefdecl-&gt;get_parent() == NULL)</span></a>
<a name="13600"><span class="lineNum">   13600 </span>            :              {</a>
<a name="13601"><span class="lineNum">   13601 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13602"><span class="lineNum">   13602 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): Note that nondefdecl-&gt;get_parent() == NULL, this might be OK. \n&quot;);</a>
<a name="13603"><span class="lineNum">   13603 </span>            : #endif</a>
<a name="13604"><span class="lineNum">   13604 </span>            :              }</a>
<a name="13605"><span class="lineNum">   13605 </span>            : </a>
<a name="13606"><span class="lineNum">   13606 </span>            : #if 0</a>
<a name="13607"><span class="lineNum">   13607 </span>            :        // DQ (12/22/2019): This is the code that causes the class declarations between defining</a>
<a name="13608"><span class="lineNum">   13608 </span>            :        // class declarations across multiple translation units to be shared.</a>
<a name="13609"><span class="lineNum">   13609 </span>            : </a>
<a name="13610"><span class="lineNum">   13610 </span>            :        // DQ (9/7/2012): I think this might be the root of a problem in the haskell tests (ROSE compiling ROSE).</a>
<a name="13611"><span class="lineNum">   13611 </span>            :           if (nondefdecl-&gt;get_definingDeclaration() != NULL)</a>
<a name="13612"><span class="lineNum">   13612 </span>            :              {</a>
<a name="13613"><span class="lineNum">   13613 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13614"><span class="lineNum">   13614 </span>            :                printf (&quot;ERROR: In SageBuilder::buildClassDeclaration_nfi(): Non defining declaration nondefdecl = %p = %s already has a defining declaration, so we would be build another nondefdecl-&gt;get_definingDeclaration() = %p = %s \n&quot;,</a>
<a name="13615"><span class="lineNum">   13615 </span>            :                     nondefdecl,nondefdecl-&gt;class_name().c_str(),nondefdecl-&gt;get_definingDeclaration(),nondefdecl-&gt;get_definingDeclaration()-&gt;class_name().c_str());</a>
<a name="13616"><span class="lineNum">   13616 </span>            : #endif</a>
<a name="13617"><span class="lineNum">   13617 </span>            :                SgClassDeclaration* nondefining_classDeclaration = isSgClassDeclaration(nondefdecl);</a>
<a name="13618"><span class="lineNum">   13618 </span>            :                ROSE_ASSERT(nondefining_classDeclaration != NULL);</a>
<a name="13619"><span class="lineNum">   13619 </span>            :                SgClassDeclaration* defining_classDeclaration = isSgClassDeclaration(nondefdecl-&gt;get_definingDeclaration());</a>
<a name="13620"><span class="lineNum">   13620 </span>            :                ROSE_ASSERT(defining_classDeclaration != NULL);</a>
<a name="13621"><span class="lineNum">   13621 </span>            : </a>
<a name="13622"><span class="lineNum">   13622 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13623"><span class="lineNum">   13623 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): nondefining_classDeclaration: scope = %p = %s name = %s \n&quot;,</a>
<a name="13624"><span class="lineNum">   13624 </span>            :                     nondefining_classDeclaration-&gt;get_scope(),nondefining_classDeclaration-&gt;get_scope()-&gt;class_name().c_str(),nondefining_classDeclaration-&gt;get_name().str());</a>
<a name="13625"><span class="lineNum">   13625 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): defining_classDeclaration:    scope = %p = %s name = %s \n&quot;,</a>
<a name="13626"><span class="lineNum">   13626 </span>            :                     defining_classDeclaration-&gt;get_scope(),defining_classDeclaration-&gt;get_scope()-&gt;class_name().c_str(),defining_classDeclaration-&gt;get_name().str());</a>
<a name="13627"><span class="lineNum">   13627 </span>            :                defining_classDeclaration-&gt;get_file_info()-&gt;display(&quot;already has a defining declaration&quot;);</a>
<a name="13628"><span class="lineNum">   13628 </span>            : #endif</a>
<a name="13629"><span class="lineNum">   13629 </span>            : #if 0</a>
<a name="13630"><span class="lineNum">   13630 </span>            :                printf (&quot;Error: In SageBuilder::buildClassDeclaration_nfi(): exiting as part of test \n&quot;);</a>
<a name="13631"><span class="lineNum">   13631 </span>            :                ROSE_ABORT();</a>
<a name="13632"><span class="lineNum">   13632 </span>            : #endif</a>
<a name="13633"><span class="lineNum">   13633 </span>            :             // DQ (9/24/2012): This only appears to happen for large tests (e.g. ROSE compiling ROSE), alow it for the moment and look into this later.</a>
<a name="13634"><span class="lineNum">   13634 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13635"><span class="lineNum">   13635 </span>            :                printf (&quot;WARNING: In SageBuilder::buildClassDeclaration_nfi(): but a defining declaration was found to have already been built (might be an error), so returning it defining_classDeclaration = %p \n&quot;,defining_classDeclaration);</a>
<a name="13636"><span class="lineNum">   13636 </span>            : #endif</a>
<a name="13637"><span class="lineNum">   13637 </span>            : </a>
<a name="13638"><span class="lineNum">   13638 </span>            : #if 0</a>
<a name="13639"><span class="lineNum">   13639 </span>            :             // DQ (2/26/2019): Debugging support for multiple files on the command line.</a>
<a name="13640"><span class="lineNum">   13640 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="13641"><span class="lineNum">   13641 </span>            :                ROSE_ABORT();</a>
<a name="13642"><span class="lineNum">   13642 </span>            : #endif</a>
<a name="13643"><span class="lineNum">   13643 </span>            :                return defining_classDeclaration;</a>
<a name="13644"><span class="lineNum">   13644 </span>            :              }</a>
<a name="13645"><span class="lineNum">   13645 </span>            : #endif</a>
<a name="13646"><span class="lineNum">   13646 </span>            : </a>
<a name="13647"><span class="lineNum">   13647 </span>            : #if 0</a>
<a name="13648"><span class="lineNum">   13648 </span>            :           nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="13649"><span class="lineNum">   13649 </span>            : </a>
<a name="13650"><span class="lineNum">   13650 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="13651"><span class="lineNum">   13651 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</a>
<a name="13652"><span class="lineNum">   13652 </span>            : #endif</a>
<a name="13653"><span class="lineNum">   13653 </span>            :         }</a>
<a name="13654"><span class="lineNum">   13654 </span>            :        else // build a nondefnining declaration if it does not exist</a>
<a name="13655"><span class="lineNum">   13655 </span>            :         {</a>
<a name="13656"><span class="lineNum">   13656 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13657"><span class="lineNum">   13657 </span>            :           printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): building a nondefining declaration since it does not exist \n&quot;);</a>
<a name="13658"><span class="lineNum">   13658 </span>            : #endif</a>
<a name="13659"><span class="lineNum">   13659 </span>            :        // DQ (10/10/2015): This should be true.</a>
<a name="13660"><span class="lineNum">   13660 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl == NULL);</span></a>
<a name="13661"><span class="lineNum">   13661 </span>            : </a>
<a name="13662"><span class="lineNum">   13662 </span>            :        // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.</a>
<a name="13663"><span class="lineNum">   13663 </span>            :        // DQ (1/1/2012): Fixed to force matching types or IR nodes for defining and non-defining declarations.</a>
<a name="13664"><span class="lineNum">   13664 </span><span class="lineCov">       9579 :           if (buildTemplateInstantiation == true)</span></a>
<a name="13665"><span class="lineNum">   13665 </span>            :              {</a>
<a name="13666"><span class="lineNum">   13666 </span>            :             // This adds: SgTemplateDeclaration *templateDeclaration and SgTemplateArgumentPtrList templateArguments</a>
<a name="13667"><span class="lineNum">   13667 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13668"><span class="lineNum">   13668 </span>            :                printf (&quot;************************************************************************* \n&quot;);</a>
<a name="13669"><span class="lineNum">   13669 </span>            :                printf (&quot;Building SgTemplateInstantiationDecl with empty SgTemplateArgumentPtrList \n&quot;);</a>
<a name="13670"><span class="lineNum">   13670 </span>            :                printf (&quot;   --- using nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="13671"><span class="lineNum">   13671 </span>            :                printf (&quot;************************************************************************* \n&quot;);</a>
<a name="13672"><span class="lineNum">   13672 </span>            : #endif</a>
<a name="13673"><span class="lineNum">   13673 </span><span class="lineCov">       6658 :                SgTemplateArgumentPtrList emptyList;</span></a>
<a name="13674"><span class="lineNum">   13674 </span>            :             // nondefdecl = new SgTemplateInstantiationDecl (name,kind,NULL,NULL,NULL,emptyList);</a>
<a name="13675"><span class="lineNum">   13675 </span><span class="lineCov">       3329 :                nondefdecl = new SgTemplateInstantiationDecl (nameWithTemplateArguments,kind,NULL,NULL,NULL,emptyList);</span></a>
<a name="13676"><span class="lineNum">   13676 </span><span class="lineCov">       3329 :                ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="13677"><span class="lineNum">   13677 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13678"><span class="lineNum">   13678 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): Build SgTemplateInstantiationDecl: nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="13679"><span class="lineNum">   13679 </span>            : #endif</a>
<a name="13680"><span class="lineNum">   13680 </span>            :             // DQ (2/27/2018): Added assertion now that we have implemented more consistant semantics</a>
<a name="13681"><span class="lineNum">   13681 </span>            :             // for template instantiations (types are not generated in the constructor calls).</a>
<a name="13682"><span class="lineNum">   13682 </span><span class="lineCov">       3329 :                ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="13683"><span class="lineNum">   13683 </span><span class="lineCov">       3329 :                ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl) != NULL);</span></a>
<a name="13684"><span class="lineNum">   13684 </span>            : #if 0</a>
<a name="13685"><span class="lineNum">   13685 </span>            :                printf (&quot;In buildClassDeclaration_nfi(): nondefdecl-&gt;get_name() = %s nondefdecl-&gt;get_templateName() = %s \n&quot;,nondefdecl-&gt;get_name().str(),isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().str());</a>
<a name="13686"><span class="lineNum">   13686 </span>            : #endif</a>
<a name="13687"><span class="lineNum">   13687 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="13688"><span class="lineNum">   13688 </span>            :             // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="13689"><span class="lineNum">   13689 </span>            :             // detectTransformations(nondefdecl);</a>
<a name="13690"><span class="lineNum">   13690 </span>            : #endif</a>
<a name="13691"><span class="lineNum">   13691 </span>            :             // DQ (6/6/2012): Set the first non-defining declaration to be itself.</a>
<a name="13692"><span class="lineNum">   13692 </span>            :             // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="13693"><span class="lineNum">   13693 </span>            : </a>
<a name="13694"><span class="lineNum">   13694 </span>            :             // DQ (1/1/2012): Added support for setting the template name (I think this should be fixed in the constructor).</a>
<a name="13695"><span class="lineNum">   13695 </span>            :             // It can't be fixed in the constructor since it has to be set after construction (or passed in explicitly).</a>
<a name="13696"><span class="lineNum">   13696 </span><span class="lineCov">       3329 :                ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().is_null() == true);</span></a>
<a name="13697"><span class="lineNum">   13697 </span>            : </a>
<a name="13698"><span class="lineNum">   13698 </span>            :             // DQ (6/6/2012): Added support for template arguments so that types would be computed with the template arguments.</a>
<a name="13699"><span class="lineNum">   13699 </span><span class="lineCov">       3329 :                ROSE_ASSERT(templateArgumentsList != NULL);</span></a>
<a name="13700"><span class="lineNum">   13700 </span>            : </a>
<a name="13701"><span class="lineNum">   13701 </span>            : #if 0</a>
<a name="13702"><span class="lineNum">   13702 </span>            :             // DQ (5/30/2014): Removing output spew.</a>
<a name="13703"><span class="lineNum">   13703 </span>            :             // DQ (5/17/2014): This must be allowed for some template instantiations (see test2014_77.C).</a>
<a name="13704"><span class="lineNum">   13704 </span>            :             // This occurs now under some revised rules for when to interpret a class or struct as a template</a>
<a name="13705"><span class="lineNum">   13705 </span>            :             // declaration or template instantiation declaration. This revisions is required for test2014_56.C</a>
<a name="13706"><span class="lineNum">   13706 </span>            :             // but has had a small cascading effect on other parts of ROSE (all fixed on 5/17/2014, if I can</a>
<a name="13707"><span class="lineNum">   13707 </span>            :             // finish this work today).</a>
<a name="13708"><span class="lineNum">   13708 </span>            :             // ROSE_ASSERT(templateArgumentsList-&gt;size() &gt; 0);</a>
<a name="13709"><span class="lineNum">   13709 </span>            :                if (templateArgumentsList-&gt;size() == 0)</a>
<a name="13710"><span class="lineNum">   13710 </span>            :                   {</a>
<a name="13711"><span class="lineNum">   13711 </span>            :                     printf (&quot;Warning: In SageBuilder::buildClassDeclaration_nfi(): templateArgumentsList-&gt;size() == 0 \n&quot;);</a>
<a name="13712"><span class="lineNum">   13712 </span>            :                   }</a>
<a name="13713"><span class="lineNum">   13713 </span>            : #endif</a>
<a name="13714"><span class="lineNum">   13714 </span>            :             // DQ (9/16/2012): Set the firstNondefiningDeclaration so that we can set the template parameters.</a>
<a name="13715"><span class="lineNum">   13715 </span><span class="lineCov">       3329 :                nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="13716"><span class="lineNum">   13716 </span>            : #if 1</a>
<a name="13717"><span class="lineNum">   13717 </span>            :             // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).</a>
<a name="13718"><span class="lineNum">   13718 </span><span class="lineCov">       3329 :                setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);</span></a>
<a name="13719"><span class="lineNum">   13719 </span>            : #else</a>
<a name="13720"><span class="lineNum">   13720 </span>            :                isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateArguments() = *templateArgumentsList;</a>
<a name="13721"><span class="lineNum">   13721 </span>            : </a>
<a name="13722"><span class="lineNum">   13722 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="13723"><span class="lineNum">   13723 </span>            : </a>
<a name="13724"><span class="lineNum">   13724 </span>            :             // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).</a>
<a name="13725"><span class="lineNum">   13725 </span>            :             // printf (&quot;Calling setTemplateArgumentParents(): nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="13726"><span class="lineNum">   13726 </span>            :                setTemplateArgumentParents(nondefdecl);</a>
<a name="13727"><span class="lineNum">   13727 </span>            :             // printf (&quot;DONE: Calling setTemplateArgumentParents(): nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="13728"><span class="lineNum">   13728 </span>            : </a>
<a name="13729"><span class="lineNum">   13729 </span>            :                testTemplateArgumentParents(nondefdecl);</a>
<a name="13730"><span class="lineNum">   13730 </span>            : #endif</a>
<a name="13731"><span class="lineNum">   13731 </span>            :             // DQ (6/6/2012): Generate the name without the template arguments.</a>
<a name="13732"><span class="lineNum">   13732 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13733"><span class="lineNum">   13733 </span>            :                printf (&quot;Warning: In buildClassDeclaration_nfi(): calling set_templateName(nameWithTemplateArguments = %s) for nondefining declaration \n&quot;,nameWithTemplateArguments.str());</a>
<a name="13734"><span class="lineNum">   13734 </span>            : #endif</a>
<a name="13735"><span class="lineNum">   13735 </span>            :             // isSgTemplateInstantiationDecl(nondefdecl)-&gt;set_templateName(name);</a>
<a name="13736"><span class="lineNum">   13736 </span>            :             // isSgTemplateInstantiationDecl(nondefdecl)-&gt;set_templateName(&quot;SETME_NONDEFINING_DECL&lt;&gt;&quot;);</a>
<a name="13737"><span class="lineNum">   13737 </span>            :             // isSgTemplateInstantiationDecl(nondefdecl)-&gt;set_templateName(name);</a>
<a name="13738"><span class="lineNum">   13738 </span><span class="lineCov">       3329 :                isSgTemplateInstantiationDecl(nondefdecl)-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="13739"><span class="lineNum">   13739 </span>            : </a>
<a name="13740"><span class="lineNum">   13740 </span>            :             // DQ (6/6/2012): I don't think we want this test any more (should apply only to the result of get_templateName()).</a>
<a name="13741"><span class="lineNum">   13741 </span>            :             // DQ (5/31/2012): Find locations where this is set and include template syntax.</a>
<a name="13742"><span class="lineNum">   13742 </span>            :             // ROSE_ASSERT(name.getString().find('&lt;') == string::npos);</a>
<a name="13743"><span class="lineNum">   13743 </span>            :             // printf (&quot;Commented out test for: name.getString().find('&lt;') == string::npos (should apply only to the result of get_templateName() \n&quot;);</a>
<a name="13744"><span class="lineNum">   13744 </span>            : </a>
<a name="13745"><span class="lineNum">   13745 </span><span class="lineCov">       3329 :                ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().is_null() == false);</span></a>
<a name="13746"><span class="lineNum">   13746 </span>            : </a>
<a name="13747"><span class="lineNum">   13747 </span>            :             // DQ (3/25/2017): Fixed Clang warning: warning: if statement has empty body [-Wempty-body]</a>
<a name="13748"><span class="lineNum">   13748 </span>            :             // DQ (3/22/2012): Make sure there is template syntax present.</a>
<a name="13749"><span class="lineNum">   13749 </span>            :             // if (isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().getString().find('&gt;') == string::npos)</a>
<a name="13750"><span class="lineNum">   13750 </span>            :             // if (hasTemplateSyntax(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName()) == false);</a>
<a name="13751"><span class="lineNum">   13751 </span><span class="lineCov">       3329 :                if (hasTemplateSyntax(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName()) == false)</span></a>
<a name="13752"><span class="lineNum">   13752 </span>            :                   {</a>
<a name="13753"><span class="lineNum">   13753 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13754"><span class="lineNum">   13754 </span>            :                     printf (&quot;WARNING: No template syntax present in name of template class instantiation (nondefdecl) \n&quot;);</a>
<a name="13755"><span class="lineNum">   13755 </span>            : #endif</a>
<a name="13756"><span class="lineNum">   13756 </span>            :                   }</a>
<a name="13757"><span class="lineNum">   13757 </span>            :             // ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)-&gt;get_templateName().getString().find('&gt;') != string::npos);</a>
<a name="13758"><span class="lineNum">   13758 </span>            : </a>
<a name="13759"><span class="lineNum">   13759 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="13760"><span class="lineNum">   13760 </span>            :             // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="13761"><span class="lineNum">   13761 </span>            :             // detectTransformations(nondefdecl);</a>
<a name="13762"><span class="lineNum">   13762 </span>            : #endif</a>
<a name="13763"><span class="lineNum">   13763 </span>            :             // DQ (7/25/2017): This will be true, but it might not be what we want since it can be caught as an error in the code below.</a>
<a name="13764"><span class="lineNum">   13764 </span><span class="lineCov">       3329 :                ROSE_ASSERT(nondefdecl-&gt;get_file_info() == NULL);</span></a>
<a name="13765"><span class="lineNum">   13765 </span>            :              }</a>
<a name="13766"><span class="lineNum">   13766 </span>            :             else</a>
<a name="13767"><span class="lineNum">   13767 </span>            :              {</a>
<a name="13768"><span class="lineNum">   13768 </span>            :             // We know that the name without template arguments should be used here (but they are the same).</a>
<a name="13769"><span class="lineNum">   13769 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13770"><span class="lineNum">   13770 </span>            :                printf (&quot;WARNING: In buildClassDeclaration_nfi(): Are we building a new SgClassDeclaration as a nondefining declaration when we should be using the nonDefiningDecl = %p \n&quot;,nonDefiningDecl);</a>
<a name="13771"><span class="lineNum">   13771 </span>            :                printf (&quot;   --- nameWithoutTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="13772"><span class="lineNum">   13772 </span>            : #endif</a>
<a name="13773"><span class="lineNum">   13773 </span>            :             // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);</a>
<a name="13774"><span class="lineNum">   13774 </span><span class="lineCov">       6250 :                nondefdecl = new SgClassDeclaration(nameWithoutTemplateArguments,kind,NULL,NULL);</span></a>
<a name="13775"><span class="lineNum">   13775 </span>            : </a>
<a name="13776"><span class="lineNum">   13776 </span><span class="lineCov">       6250 :                ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="13777"><span class="lineNum">   13777 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13778"><span class="lineNum">   13778 </span>            :                printf (&quot;In buildClassDeclaration_nfi(): (no file info set): nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="13779"><span class="lineNum">   13779 </span>            : #endif</a>
<a name="13780"><span class="lineNum">   13780 </span>            :             // DQ (10/9/2015): Added assertion. We can't assert this yet (see test2015_87.C).</a>
<a name="13781"><span class="lineNum">   13781 </span>            :             // ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="13782"><span class="lineNum">   13782 </span>            : </a>
<a name="13783"><span class="lineNum">   13783 </span><span class="lineCov">       6250 :                ROSE_ASSERT(nameWithoutTemplateArguments == nameWithTemplateArguments);</span></a>
<a name="13784"><span class="lineNum">   13784 </span>            : </a>
<a name="13785"><span class="lineNum">   13785 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="13786"><span class="lineNum">   13786 </span>            :             // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="13787"><span class="lineNum">   13787 </span>            :             // detectTransformations(nondefdecl);</a>
<a name="13788"><span class="lineNum">   13788 </span>            : #endif</a>
<a name="13789"><span class="lineNum">   13789 </span>            :             // DQ (9/16/2012): Set the firstNondefiningDeclaration because this is the one branch left were it</a>
<a name="13790"><span class="lineNum">   13790 </span>            :             // was not set (required in the true branch so that we could set the template parameters).</a>
<a name="13791"><span class="lineNum">   13791 </span><span class="lineCov">       6250 :                nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="13792"><span class="lineNum">   13792 </span>            : </a>
<a name="13793"><span class="lineNum">   13793 </span><span class="lineCov">       6250 :                testTemplateArgumentParents(nondefdecl);</span></a>
<a name="13794"><span class="lineNum">   13794 </span>            : </a>
<a name="13795"><span class="lineNum">   13795 </span>            :             // DQ (7/25/2017): This will be true, but it might not be what we want since it can be caught as an error in the code below.</a>
<a name="13796"><span class="lineNum">   13796 </span><span class="lineCov">       6250 :                ROSE_ASSERT(nondefdecl-&gt;get_file_info() == NULL);</span></a>
<a name="13797"><span class="lineNum">   13797 </span>            :              }</a>
<a name="13798"><span class="lineNum">   13798 </span>            : </a>
<a name="13799"><span class="lineNum">   13799 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="13800"><span class="lineNum">   13800 </span>            : </a>
<a name="13801"><span class="lineNum">   13801 </span>            :        // DQ (6/6/2012): This has to be set before we generate the type.</a>
<a name="13802"><span class="lineNum">   13802 </span>            :        // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="13803"><span class="lineNum">   13803 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl == nondefdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="13804"><span class="lineNum">   13804 </span>            : </a>
<a name="13805"><span class="lineNum">   13805 </span>            :        // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).</a>
<a name="13806"><span class="lineNum">   13806 </span>            :        // setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);</a>
<a name="13807"><span class="lineNum">   13807 </span>            : </a>
<a name="13808"><span class="lineNum">   13808 </span>            :        // DQ (3/14/2012): For C++ we need the scope set so that types will have proper locations to revolve them</a>
<a name="13809"><span class="lineNum">   13809 </span>            :        // from being ambiguous or not properly defined.  Basically, we need a handle from which to generate something</a>
<a name="13810"><span class="lineNum">   13810 </span>            :        // that amounts to a kind of name qualification internally (maybe even exactly name qualification, but I would</a>
<a name="13811"><span class="lineNum">   13811 </span>            :        // have to think about that a bit more).</a>
<a name="13812"><span class="lineNum">   13812 </span><span class="lineCov">       9579 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="13813"><span class="lineNum">   13813 </span>            : </a>
<a name="13814"><span class="lineNum">   13814 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13815"><span class="lineNum">   13815 </span>            :           printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): Set the scope of the new non-defining declaration to %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="13816"><span class="lineNum">   13816 </span>            : #endif</a>
<a name="13817"><span class="lineNum">   13817 </span><span class="lineCov">       9579 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="13818"><span class="lineNum">   13818 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl-&gt;get_scope() != NULL);</span></a>
<a name="13819"><span class="lineNum">   13819 </span>            : </a>
<a name="13820"><span class="lineNum">   13820 </span>            :        // DQ (8/2/2019): The was required becuase the parent pointers were not being set when reading a file from the SageBuilder::buildFil() API.</a>
<a name="13821"><span class="lineNum">   13821 </span>            :        // However the bug was that the astPostprocessing's call to resetParentPointersInMemoryPool() was not properly working to find the global</a>
<a name="13822"><span class="lineNum">   13822 </span>            :        // scope in anyother case but when it was called usign a SgProject node.  This is not fixed to permit caloling using a SgSourceFile node</a>
<a name="13823"><span class="lineNum">   13823 </span>            :        // and it is now an error to call it using any other kind of IR node.</a>
<a name="13824"><span class="lineNum">   13824 </span>            :        // DQ (8/1/2019): Set the parent for the non defining declaration to be the same as the scope by default.</a>
<a name="13825"><span class="lineNum">   13825 </span>            :        // nondefdecl-&gt;set_parent(scope);</a>
<a name="13826"><span class="lineNum">   13826 </span>            : #if 0</a>
<a name="13827"><span class="lineNum">   13827 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): setting the parent of the non defining declaration to be the scope by default) \n&quot;);</a>
<a name="13828"><span class="lineNum">   13828 </span>            : #endif</a>
<a name="13829"><span class="lineNum">   13829 </span>            :        // DQ (7/31/2019): Check that the parent is set if this was used a the declaration referenced by a symbol.</a>
<a name="13830"><span class="lineNum">   13830 </span>            :        // ROSE_ASSERT (nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13831"><span class="lineNum">   13831 </span>            : </a>
<a name="13832"><span class="lineNum">   13832 </span>            :        // DQ (3/22/2012): I think we can assert this.</a>
<a name="13833"><span class="lineNum">   13833 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="13834"><span class="lineNum">   13834 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</span></a>
<a name="13835"><span class="lineNum">   13835 </span>            : </a>
<a name="13836"><span class="lineNum">   13836 </span><span class="lineCov">       9579 :           if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="13837"><span class="lineNum">   13837 </span>            :              {</a>
<a name="13838"><span class="lineNum">   13838 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13839"><span class="lineNum">   13839 </span>            :             // DQ (12/27/2018): If we have already built a type, then why did we need to build a nondefining declaration?</a>
<a name="13840"><span class="lineNum">   13840 </span>            :                printf (&quot;Calling scope-&gt;get_type_table()-&gt;lookup_type(): nameWithTemplateArguments = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="13841"><span class="lineNum">   13841 </span>            : </a>
<a name="13842"><span class="lineNum">   13842 </span>            :                printf (&quot;WE NEED THE MANGLED NAME FOR THIS TO BE RELEVANT! \n&quot;);</a>
<a name="13843"><span class="lineNum">   13843 </span>            : </a>
<a name="13844"><span class="lineNum">   13844 </span>            :             // SgType* existingType = scope-&gt;get_type_table()-&gt;lookup_type(nameWithTemplateArguments);</a>
<a name="13845"><span class="lineNum">   13845 </span>            :             // ROSE_ASSERT(existingType == NULL);</a>
<a name="13846"><span class="lineNum">   13846 </span>            : #endif</a>
<a name="13847"><span class="lineNum">   13847 </span>            : </a>
<a name="13848"><span class="lineNum">   13848 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13849"><span class="lineNum">   13849 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): kind == SgClassDeclaration::e_java_parameter = %s \n&quot;,(kind == SgClassDeclaration::e_java_parameter) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13850"><span class="lineNum">   13850 </span>            : #endif</a>
<a name="13851"><span class="lineNum">   13851 </span><span class="lineCov">       9579 :                SgClassType *class_type = (SgClassType *) SgClassType::createType(nondefdecl);</span></a>
<a name="13852"><span class="lineNum">   13852 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13853"><span class="lineNum">   13853 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): nondefdecl-&gt;get_type() == NULL: building a new class_type = %p = %s \n&quot;,class_type,class_type-&gt;class_name().c_str());</a>
<a name="13854"><span class="lineNum">   13854 </span>            : #endif</a>
<a name="13855"><span class="lineNum">   13855 </span><span class="lineCov">       9579 :                nondefdecl-&gt;set_type(class_type);</span></a>
<a name="13856"><span class="lineNum">   13856 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13857"><span class="lineNum">   13857 </span>            :                printf (&quot;In SageBuilder::buildNondefiningClassDeclaration(): built class type: part 4: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="13858"><span class="lineNum">   13858 </span>            : #endif</a>
<a name="13859"><span class="lineNum">   13859 </span><span class="lineCov">       9579 :                SgClassDeclaration* tmp_classDeclarationFromType = isSgClassDeclaration(class_type-&gt;get_declaration());</span></a>
<a name="13860"><span class="lineNum">   13860 </span><span class="lineCov">       9579 :                ROSE_ASSERT(tmp_classDeclarationFromType != NULL);</span></a>
<a name="13861"><span class="lineNum">   13861 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13862"><span class="lineNum">   13862 </span>            :                SgScopeStatement* scope = tmp_classDeclarationFromType-&gt;get_scope();</a>
<a name="13863"><span class="lineNum">   13863 </span>            :                printf (&quot;tmp_classDeclarationFromType: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="13864"><span class="lineNum">   13864 </span>            :                printf (&quot;tmp_classDeclarationFromType = %p = %s \n&quot;,tmp_classDeclarationFromType,tmp_classDeclarationFromType-&gt;class_name().c_str());</a>
<a name="13865"><span class="lineNum">   13865 </span>            :                printf (&quot;tmp_classDeclarationFromType name = %s \n&quot;,tmp_classDeclarationFromType-&gt;get_name().str());</a>
<a name="13866"><span class="lineNum">   13866 </span>            :                if (tmp_classDeclarationFromType-&gt;get_file_info() != NULL)</a>
<a name="13867"><span class="lineNum">   13867 </span>            :                   {</a>
<a name="13868"><span class="lineNum">   13868 </span>            :                     tmp_classDeclarationFromType-&gt;get_file_info()-&gt;display(&quot;tmp_classDeclarationFromType: debug&quot;);</a>
<a name="13869"><span class="lineNum">   13869 </span>            :                   }</a>
<a name="13870"><span class="lineNum">   13870 </span>            : #endif</a>
<a name="13871"><span class="lineNum">   13871 </span>            :              }</a>
<a name="13872"><span class="lineNum">   13872 </span>            : </a>
<a name="13873"><span class="lineNum">   13873 </span>            :        // DQ (3/22/2012): Added assertions.</a>
<a name="13874"><span class="lineNum">   13874 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="13875"><span class="lineNum">   13875 </span><span class="lineCov">       9579 :           if (nondefdecl-&gt;get_type()-&gt;get_declaration() != nondefdecl)</span></a>
<a name="13876"><span class="lineNum">   13876 </span>            :              {</a>
<a name="13877"><span class="lineNum">   13877 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</span></a>
<a name="13878"><span class="lineNum">   13878 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="13879"><span class="lineNum">   13879 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: nondefdecl-&gt;get_type()-&gt;get_declaration() = %p = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration(),nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;class_name().c_str());</span></a>
<a name="13880"><span class="lineNum">   13880 </span>            : </a>
<a name="13881"><span class="lineNum">   13881 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclarationFromType = isSgClassDeclaration(nondefdecl-&gt;get_type()-&gt;get_declaration());</span></a>
<a name="13882"><span class="lineNum">   13882 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classDeclarationFromType != NULL);</span></a>
<a name="13883"><span class="lineNum">   13883 </span>            : </a>
<a name="13884"><span class="lineNum">   13884 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_name() = %s \n&quot;,nondefdecl-&gt;get_name().str());</span></a>
<a name="13885"><span class="lineNum">   13885 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_name() = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_name().str());</span></a>
<a name="13886"><span class="lineNum">   13886 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_name() = %s \n&quot;,classDeclarationFromType-&gt;get_name().str());</span></a>
<a name="13887"><span class="lineNum">   13887 </span>            : </a>
<a name="13888"><span class="lineNum">   13888 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_mangled_name() = %s \n&quot;,nondefdecl-&gt;get_mangled_name().getString().c_str());</span></a>
<a name="13889"><span class="lineNum">   13889 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_mangled() = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_mangled().getString().c_str());</span></a>
<a name="13890"><span class="lineNum">   13890 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_mangled_name() = %s \n&quot;,classDeclarationFromType-&gt;get_mangled_name().getString().c_str());</span></a>
<a name="13891"><span class="lineNum">   13891 </span>            : </a>
<a name="13892"><span class="lineNum">   13892 </span>            :             // DQ (12/27/2018): Added additional debugging support.</a>
<a name="13893"><span class="lineNum">   13893 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration() = %s \n&quot;,classDeclarationFromType-&gt;get_firstNondefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="13894"><span class="lineNum">   13894 </span><span class="lineNoCov">          0 :                printf (&quot;nondefdecl-&gt;get_firstNondefiningDeclaration()                                = %s \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration() ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="13895"><span class="lineNum">   13895 </span>            : </a>
<a name="13896"><span class="lineNum">   13896 </span>            :             // DQ (12/27/2018): I think that if this is a base class declaration then it is OK for the type's declaration to not match.</a>
<a name="13897"><span class="lineNum">   13897 </span>            :             // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13898"><span class="lineNum">   13898 </span><span class="lineNoCov">          0 :                {</span></a>
<a name="13899"><span class="lineNum">   13899 </span><span class="lineNoCov">          0 :                   SgNode* parent = nondefdecl-&gt;get_parent();</span></a>
<a name="13900"><span class="lineNum">   13900 </span><span class="lineNoCov">          0 :                   if (parent != NULL)</span></a>
<a name="13901"><span class="lineNum">   13901 </span>            :                      {</a>
<a name="13902"><span class="lineNum">   13902 </span><span class="lineNoCov">          0 :                        printf (&quot;nondefdecl-&gt;get_parent() = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</span></a>
<a name="13903"><span class="lineNum">   13903 </span>            :                      }</a>
<a name="13904"><span class="lineNum">   13904 </span>            :                }</a>
<a name="13905"><span class="lineNum">   13905 </span>            : </a>
<a name="13906"><span class="lineNum">   13906 </span>            :             // DQ (12/27/2018): Activate this debugging support.</a>
<a name="13907"><span class="lineNum">   13907 </span>            : #if DEBUG_CLASS_DECLARATION</a>
<a name="13908"><span class="lineNum">   13908 </span>            :                nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;get_file_info()-&gt;display(&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()&quot;);</a>
<a name="13909"><span class="lineNum">   13909 </span>            : </a>
<a name="13910"><span class="lineNum">   13910 </span>            :             // DQ (7/24/2017): Added more debug information to support debugging test2014_187.C.</a>
<a name="13911"><span class="lineNum">   13911 </span>            :             // Note that this can be caught as an error if the class declaration was built in the code above when</a>
<a name="13912"><span class="lineNum">   13912 </span>            :             // the symbol was not found.  But if the nondefdecl-&gt;get_type()-&gt;get_declaration() == nondefdecl,</a>
<a name="13913"><span class="lineNum">   13913 </span>            :             // then this branch will not be taken (which is simply debugging information to assert that</a>
<a name="13914"><span class="lineNum">   13914 </span>            :             // nondefdecl-&gt;get_type()-&gt;get_declaration() == nondefdecl is true (below).</a>
<a name="13915"><span class="lineNum">   13915 </span>            :                if (nondefdecl-&gt;get_file_info() == NULL)</a>
<a name="13916"><span class="lineNum">   13916 </span>            :                   {</a>
<a name="13917"><span class="lineNum">   13917 </span>            :                     printf (&quot;ERROR: In SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p = %s does not have its source position information setup \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="13918"><span class="lineNum">   13918 </span>            :                     printf (&quot;   --- nondefdecl                                    = %s \n&quot;,nondefdecl-&gt;get_name().str());</a>
<a name="13919"><span class="lineNum">   13919 </span>            :                     printf (&quot;   --- nondefdecl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="13920"><span class="lineNum">   13920 </span>            :                     printf (&quot;   --- nondefdecl-&gt;get_definingDeclaration()         = %p \n&quot;,nondefdecl-&gt;get_definingDeclaration());</a>
<a name="13921"><span class="lineNum">   13921 </span>            :                     printf (&quot;   --- nondefdecl-&gt;get_type()                        = %p \n&quot;,nondefdecl-&gt;get_type());</a>
<a name="13922"><span class="lineNum">   13922 </span>            :                     printf (&quot;   --- nondefdecl-&gt;get_type()-&gt;get_declaration()     = %p \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration());</a>
<a name="13923"><span class="lineNum">   13923 </span>            :                     printf (&quot;The real error is: (nondefdecl-&gt;get_type()-&gt;get_declaration() != nondefdecl) \n&quot;);</a>
<a name="13924"><span class="lineNum">   13924 </span>            :                   }</a>
<a name="13925"><span class="lineNum">   13925 </span>            :                  else</a>
<a name="13926"><span class="lineNum">   13926 </span>            :                   {</a>
<a name="13927"><span class="lineNum">   13927 </span>            :                     ROSE_ASSERT(nondefdecl-&gt;get_file_info() != NULL);</a>
<a name="13928"><span class="lineNum">   13928 </span>            :                     nondefdecl-&gt;get_file_info()-&gt;display(&quot;nondefdecl&quot;);</a>
<a name="13929"><span class="lineNum">   13929 </span>            :                   }</a>
<a name="13930"><span class="lineNum">   13930 </span>            : #endif</a>
<a name="13931"><span class="lineNum">   13931 </span>            :              }</a>
<a name="13932"><span class="lineNum">   13932 </span><span class="lineCov">       9579 :           ROSE_ASSERT(nondefdecl-&gt;get_type()-&gt;get_declaration() == nondefdecl);</span></a>
<a name="13933"><span class="lineNum">   13933 </span>            : </a>
<a name="13934"><span class="lineNum">   13934 </span>            : #if 0</a>
<a name="13935"><span class="lineNum">   13935 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): after set_type(): nondefdecl = %p = %s nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str(),nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="13936"><span class="lineNum">   13936 </span>            : #endif</a>
<a name="13937"><span class="lineNum">   13937 </span>            : </a>
<a name="13938"><span class="lineNum">   13938 </span>            :        // printf (&quot;SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="13939"><span class="lineNum">   13939 </span>            : </a>
<a name="13940"><span class="lineNum">   13940 </span>            :        // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="13941"><span class="lineNum">   13941 </span>            :        // generated (so we have something about the class that we can reference; e.g in</a>
<a name="13942"><span class="lineNum">   13942 </span>            :        // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="13943"><span class="lineNum">   13943 </span>            :        // of source position that would be more precise.  FIXME.</a>
<a name="13944"><span class="lineNum">   13944 </span>            :        // setOneSourcePositionNull(nondefdecl);</a>
<a name="13945"><span class="lineNum">   13945 </span><span class="lineCov">       9579 :           setOneSourcePositionForTransformation(nondefdecl);</span></a>
<a name="13946"><span class="lineNum">   13946 </span><span class="lineCov">       9579 :           ROSE_ASSERT (nondefdecl-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="13947"><span class="lineNum">   13947 </span>            : </a>
<a name="13948"><span class="lineNum">   13948 </span>            : #if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS</a>
<a name="13949"><span class="lineNum">   13949 </span>            :        // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.</a>
<a name="13950"><span class="lineNum">   13950 </span>            :           if (SourcePositionClassificationMode != e_sourcePositionTransformation)</a>
<a name="13951"><span class="lineNum">   13951 </span>            :              {</a>
<a name="13952"><span class="lineNum">   13952 </span>            :                detectTransformations(nondefdecl);</a>
<a name="13953"><span class="lineNum">   13953 </span>            :              }</a>
<a name="13954"><span class="lineNum">   13954 </span>            : #endif</a>
<a name="13955"><span class="lineNum">   13955 </span>            :        // DQ (6/6/2012): This has to be set before we generate the type.</a>
<a name="13956"><span class="lineNum">   13956 </span>            :        // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="13957"><span class="lineNum">   13957 </span>            : </a>
<a name="13958"><span class="lineNum">   13958 </span>            :        // DQ (3/15/2012): This is now set below.</a>
<a name="13959"><span class="lineNum">   13959 </span>            :        // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="13960"><span class="lineNum">   13960 </span><span class="lineCov">       9579 :           nondefdecl-&gt;setForward();</span></a>
<a name="13961"><span class="lineNum">   13961 </span>            : </a>
<a name="13962"><span class="lineNum">   13962 </span>            :        // DQ (2/27/2012): I don't like that this is setting the parent to be a scope (not a bad default, but must be reset later if required).</a>
<a name="13963"><span class="lineNum">   13963 </span>            :        // Liao, 9/2/2009. scope stack is optional, it can be empty</a>
<a name="13964"><span class="lineNum">   13964 </span>            :        // nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="13965"><span class="lineNum">   13965 </span>            : #if 0</a>
<a name="13966"><span class="lineNum">   13966 </span>            :           printf (&quot;WARNING: In buildClassDeclaration_nfi(): Skipping the setting of the parents (for both defining and nondefining declaration) to be the same as the scope \n&quot;);</a>
<a name="13967"><span class="lineNum">   13967 </span>            : #endif</a>
<a name="13968"><span class="lineNum">   13968 </span>            :        // nondefdecl-&gt;set_parent(scope);</a>
<a name="13969"><span class="lineNum">   13969 </span>            :        // defdecl-&gt;set_parent(scope);</a>
<a name="13970"><span class="lineNum">   13970 </span>            : </a>
<a name="13971"><span class="lineNum">   13971 </span><span class="lineCov">       9579 :           if (scope != NULL)</span></a>
<a name="13972"><span class="lineNum">   13972 </span>            :              {</a>
<a name="13973"><span class="lineNum">   13973 </span><span class="lineCov">       9579 :                mysymbol = new SgClassSymbol(nondefdecl);</span></a>
<a name="13974"><span class="lineNum">   13974 </span>            : #if 0</a>
<a name="13975"><span class="lineNum">   13975 </span>            :                printf (&quot;In buildClassDeclaration_nfi(): Insert the new SgClassSymbol = %p from nondefdecl = %p = %s into the scope = %p = %s \n&quot;,mysymbol,nondefdecl,nondefdecl-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13976"><span class="lineNum">   13976 </span>            : #endif</a>
<a name="13977"><span class="lineNum">   13977 </span>            :             // scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="13978"><span class="lineNum">   13978 </span><span class="lineCov">       9579 :                scope-&gt;insert_symbol(nameWithTemplateArguments, mysymbol);</span></a>
<a name="13979"><span class="lineNum">   13979 </span>            : </a>
<a name="13980"><span class="lineNum">   13980 </span>            :             // DQ (11/21/2013): Added test based on debugging session with Philippe.</a>
<a name="13981"><span class="lineNum">   13981 </span><span class="lineCov">       9579 :                ROSE_ASSERT(nondefdecl-&gt;get_scope() == scope);</span></a>
<a name="13982"><span class="lineNum">   13982 </span>            :              }</a>
<a name="13983"><span class="lineNum">   13983 </span>            :             else</a>
<a name="13984"><span class="lineNum">   13984 </span>            :              {</a>
<a name="13985"><span class="lineNum">   13985 </span>            :             // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.</a>
<a name="13986"><span class="lineNum">   13986 </span>            :             // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="13987"><span class="lineNum">   13987 </span>            :             // break the existing interface. Need to discuss this with Liao.</a>
<a name="13988"><span class="lineNum">   13988 </span><span class="lineCov">      12209 :                printf (&quot;Warning: no scope provided to support symbol table entry! \n&quot;);</span></a>
<a name="13989"><span class="lineNum">   13989 </span>            :              }</a>
<a name="13990"><span class="lineNum">   13990 </span>            : </a>
<a name="13991"><span class="lineNum">   13991 </span>            :        // DQ (7/31/2019): Check that the parent is set if this was used a the declaration referenced by a symbol.</a>
<a name="13992"><span class="lineNum">   13992 </span>            :        // ROSE_ASSERT (nondefdecl-&gt;get_parent() != NULL);</a>
<a name="13993"><span class="lineNum">   13993 </span>            :         }</a>
<a name="13994"><span class="lineNum">   13994 </span>            : </a>
<a name="13995"><span class="lineNum">   13995 </span>            :   // printf (&quot;SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="13996"><span class="lineNum">   13996 </span>            : </a>
<a name="13997"><span class="lineNum">   13997 </span>            : #if 1</a>
<a name="13998"><span class="lineNum">   13998 </span>            :   // Refactored this code.</a>
<a name="13999"><span class="lineNum">   13999 </span><span class="lineCov">      12209 :      testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14000"><span class="lineNum">   14000 </span>            : #else</a>
<a name="14001"><span class="lineNum">   14001 </span>            :      if (buildTemplateInstantiation == true)</a>
<a name="14002"><span class="lineNum">   14002 </span>            :         {</a>
<a name="14003"><span class="lineNum">   14003 </span>            :        // DQ (7/25/2012): Added this code here to reset the parents of the template arguments.</a>
<a name="14004"><span class="lineNum">   14004 </span>            :           for (size_t i = 0; i &lt; templateArgumentsList-&gt;size(); i++)</a>
<a name="14005"><span class="lineNum">   14005 </span>            :              {</a>
<a name="14006"><span class="lineNum">   14006 </span>            :             // DQ (7/25/2012): This should be true because the template argument was set to the functions</a>
<a name="14007"><span class="lineNum">   14007 </span>            :             // scope so that the name with template arguments could be computed (with name qualification).</a>
<a name="14008"><span class="lineNum">   14008 </span>            :                ROSE_ASSERT((*templateArgumentsList)[i]-&gt;get_parent() != NULL);</a>
<a name="14009"><span class="lineNum">   14009 </span>            : </a>
<a name="14010"><span class="lineNum">   14010 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="14011"><span class="lineNum">   14011 </span>            : </a>
<a name="14012"><span class="lineNum">   14012 </span>            :             // ROSE_ASSERT(isSgGlobal(templateArgumentsList[i]-&gt;get_parent()) == NULL);</a>
<a name="14013"><span class="lineNum">   14013 </span>            :             // ROSE_ASSERT(templateArgumentsList[i]-&gt;get_parent() == nondefining_templateInstantiation);</a>
<a name="14014"><span class="lineNum">   14014 </span>            : </a>
<a name="14015"><span class="lineNum">   14015 </span>            :             // Be we want to reset it to be the function (now that it is available, because this is more precise).</a>
<a name="14016"><span class="lineNum">   14016 </span>            :             // All qualified names should compute to the same qualified name (if not then it is a bug in the name</a>
<a name="14017"><span class="lineNum">   14017 </span>            :             // qualification mechanism).</a>
<a name="14018"><span class="lineNum">   14018 </span>            :                (*templateArgumentsList)[i]-&gt;set_parent(nondefdecl);</a>
<a name="14019"><span class="lineNum">   14019 </span>            :              }</a>
<a name="14020"><span class="lineNum">   14020 </span>            :         }</a>
<a name="14021"><span class="lineNum">   14021 </span>            : #endif</a>
<a name="14022"><span class="lineNum">   14022 </span>            : </a>
<a name="14023"><span class="lineNum">   14023 </span>            :   // DQ (3/15/2012): I hhava moved construction of defining declaration to be AFTER the nondefining declaration!</a>
<a name="14024"><span class="lineNum">   14024 </span>            :   // This is a better organization ans also should make sure that the declaration in the SgClassType will</a>
<a name="14025"><span class="lineNum">   14025 </span>            :   // properly reference the firstNondefiningDeclaration (instead of the defining declaration).</a>
<a name="14026"><span class="lineNum">   14026 </span>            : </a>
<a name="14027"><span class="lineNum">   14027 </span>            :   // step 1 (now step 2). Build defining declaration</a>
<a name="14028"><span class="lineNum">   14028 </span>            :   // SgClassDefinition* classDef = buildClassDefinition();</a>
<a name="14029"><span class="lineNum">   14029 </span><span class="lineCov">      12209 :      SgClassDefinition* classDef = buildClassDefinition(NULL,buildTemplateInstantiation);</span></a>
<a name="14030"><span class="lineNum">   14030 </span>            : </a>
<a name="14031"><span class="lineNum">   14031 </span>            :   // DQ (11/26/2011): Debugging EDG 3.3 use of templateArguments.</a>
<a name="14032"><span class="lineNum">   14032 </span>            : #if 0</a>
<a name="14033"><span class="lineNum">   14033 </span>            :      printf (&quot;Building a SgClassDeclaration: buildClassDeclaration_nfi() buildTemplateInstantiation = %s \n&quot;,buildTemplateInstantiation ? &quot;true:&quot; : &quot;false&quot;);</a>
<a name="14034"><span class="lineNum">   14034 </span>            : #endif</a>
<a name="14035"><span class="lineNum">   14035 </span>            : </a>
<a name="14036"><span class="lineNum">   14036 </span>            :   // SgClassDeclaration* defdecl = new SgClassDeclaration (name,kind,NULL,classDef);</a>
<a name="14037"><span class="lineNum">   14037 </span><span class="lineCov">      12209 :      SgClassDeclaration* defdecl = NULL;</span></a>
<a name="14038"><span class="lineNum">   14038 </span><span class="lineCov">      12209 :      if (buildTemplateInstantiation == true)</span></a>
<a name="14039"><span class="lineNum">   14039 </span>            :         {</a>
<a name="14040"><span class="lineNum">   14040 </span>            :        // This adds: SgTemplateDeclaration *templateDeclaration and SgTemplateArgumentPtrList templateArguments</a>
<a name="14041"><span class="lineNum">   14041 </span><span class="lineCov">      10834 :           SgTemplateArgumentPtrList emptyList;</span></a>
<a name="14042"><span class="lineNum">   14042 </span>            :        // defdecl = new SgTemplateInstantiationDecl (name,kind,NULL,classDef,NULL,emptyList);</a>
<a name="14043"><span class="lineNum">   14043 </span><span class="lineCov">       5417 :           defdecl = new SgTemplateInstantiationDecl (nameWithTemplateArguments,kind,NULL,classDef,NULL,emptyList);</span></a>
<a name="14044"><span class="lineNum">   14044 </span>            : </a>
<a name="14045"><span class="lineNum">   14045 </span>            :        // DQ (2/27/2018): Added assertion now that we have implemented more consistant semantics</a>
<a name="14046"><span class="lineNum">   14046 </span>            :        // for template instantiations (types are not generated in the constructor calls).</a>
<a name="14047"><span class="lineNum">   14047 </span><span class="lineCov">       5417 :           ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</span></a>
<a name="14048"><span class="lineNum">   14048 </span><span class="lineCov">       5417 :           ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl) != NULL);</span></a>
<a name="14049"><span class="lineNum">   14049 </span>            : #if 0</a>
<a name="14050"><span class="lineNum">   14050 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): defdecl-&gt;get_name() = %s defdecl-&gt;get_templateName() = %s \n&quot;,defdecl-&gt;get_name().str(),isSgTemplateInstantiationDecl(defdecl)-&gt;get_templateName().str());</a>
<a name="14051"><span class="lineNum">   14051 </span>            : #endif</a>
<a name="14052"><span class="lineNum">   14052 </span>            :        // DQ (1/1/2012): Added support for setting the template name (I think this should be fixed in the constructor).</a>
<a name="14053"><span class="lineNum">   14053 </span>            :        // It can't be fixed in the constructor since it has to be set after construction (or passed in explicitly).</a>
<a name="14054"><span class="lineNum">   14054 </span><span class="lineCov">       5417 :           ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)-&gt;get_templateName().is_null() == true);</span></a>
<a name="14055"><span class="lineNum">   14055 </span>            : </a>
<a name="14056"><span class="lineNum">   14056 </span>            : #if 0</a>
<a name="14057"><span class="lineNum">   14057 </span>            :           printf (&quot;Warning: In buildClassDeclaration_nfi(): calling set_templateName(name = %s) for defining declaration \n&quot;,name.str());</a>
<a name="14058"><span class="lineNum">   14058 </span>            : #if 0</a>
<a name="14059"><span class="lineNum">   14059 </span>            :        // isSgTemplateInstantiationDecl(defdecl)-&gt;set_templateName(name);</a>
<a name="14060"><span class="lineNum">   14060 </span>            :        // isSgTemplateInstantiationDecl(defdecl)-&gt;set_templateName(&quot;SETME_DEFINING_DECL&lt;&gt;&quot;);</a>
<a name="14061"><span class="lineNum">   14061 </span>            :           isSgTemplateInstantiationDecl(defdecl)-&gt;set_templateName(name);</a>
<a name="14062"><span class="lineNum">   14062 </span>            : </a>
<a name="14063"><span class="lineNum">   14063 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="14064"><span class="lineNum">   14064 </span>            : </a>
<a name="14065"><span class="lineNum">   14065 </span>            :        // DQ (5/31/2012): Find locations where this is set and include template syntax.</a>
<a name="14066"><span class="lineNum">   14066 </span>            :           ROSE_ASSERT(name.getString().find('&lt;') == string::npos);</a>
<a name="14067"><span class="lineNum">   14067 </span>            : #else</a>
<a name="14068"><span class="lineNum">   14068 </span>            :        // DQ (6/1/2012): Make sure that the templateName is set and they it does not include the template syntax.</a>
<a name="14069"><span class="lineNum">   14069 </span>            :           SgName templateName = generateTemplateNameFromTemplateNameWithTemplateArguments(name);</a>
<a name="14070"><span class="lineNum">   14070 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): templateName = %s \n&quot;,templateName.str());</a>
<a name="14071"><span class="lineNum">   14071 </span>            :           isSgTemplateInstantiationDecl(defdecl)-&gt;set_templateName(templateName);</a>
<a name="14072"><span class="lineNum">   14072 </span>            : </a>
<a name="14073"><span class="lineNum">   14073 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="14074"><span class="lineNum">   14074 </span>            : </a>
<a name="14075"><span class="lineNum">   14075 </span>            :        // DQ (5/31/2012): Find locations where this is set and include template syntax.</a>
<a name="14076"><span class="lineNum">   14076 </span>            :        // ROSE_ASSERT(templateName.getString().find('&lt;') == string::npos);</a>
<a name="14077"><span class="lineNum">   14077 </span>            :           ROSE_ASSERT(hasTemplateSyntax(templateName) == false);</a>
<a name="14078"><span class="lineNum">   14078 </span>            : </a>
<a name="14079"><span class="lineNum">   14079 </span>            :        // DQ (6/1/2012): Not clear if this is always true (for all template instantations).</a>
<a name="14080"><span class="lineNum">   14080 </span>            :        // ROSE_ASSERT(name.getString().find('&lt;') != string::npos);</a>
<a name="14081"><span class="lineNum">   14081 </span>            :           ROSE_ASSERT(hasTemplateSyntax(name) == true);</a>
<a name="14082"><span class="lineNum">   14082 </span>            : #endif</a>
<a name="14083"><span class="lineNum">   14083 </span>            : #else</a>
<a name="14084"><span class="lineNum">   14084 </span>            : #if 0</a>
<a name="14085"><span class="lineNum">   14085 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): nameWithoutTemplateArguments = %s nameWithTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str(),nameWithTemplateArguments.str());</a>
<a name="14086"><span class="lineNum">   14086 </span>            : #endif</a>
<a name="14087"><span class="lineNum">   14087 </span><span class="lineCov">       5417 :           isSgTemplateInstantiationDecl(defdecl)-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="14088"><span class="lineNum">   14088 </span>            : </a>
<a name="14089"><span class="lineNum">   14089 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="14090"><span class="lineNum">   14090 </span>            :        // DQ (5/8/2013): This fails for test2013_159.C, and it appears that we have been overly restrictive here.</a>
<a name="14091"><span class="lineNum">   14091 </span>            :           if (hasTemplateSyntax(nameWithTemplateArguments) == false)</a>
<a name="14092"><span class="lineNum">   14092 </span>            :              {</a>
<a name="14093"><span class="lineNum">   14093 </span>            :                printf (&quot;WARNING: In buildClassDeclaration_nfi(): nameWithTemplateArguments = %s is not using template syntax \n&quot;,nameWithTemplateArguments.str());</a>
<a name="14094"><span class="lineNum">   14094 </span>            :              }</a>
<a name="14095"><span class="lineNum">   14095 </span>            : #endif</a>
<a name="14096"><span class="lineNum">   14096 </span>            :        // ROSE_ASSERT(hasTemplateSyntax(nameWithTemplateArguments) == true);</a>
<a name="14097"><span class="lineNum">   14097 </span>            : </a>
<a name="14098"><span class="lineNum">   14098 </span>            :        // DQ (7/27/2012): This fails for test2005_35.C where conversion operators are seen.</a>
<a name="14099"><span class="lineNum">   14099 </span>            :        // ROSE_ASSERT(hasTemplateSyntax(nameWithoutTemplateArguments) == false);</a>
<a name="14100"><span class="lineNum">   14100 </span>            : #endif</a>
<a name="14101"><span class="lineNum">   14101 </span>            : </a>
<a name="14102"><span class="lineNum">   14102 </span><span class="lineCov">       5417 :           ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)-&gt;get_templateName().is_null() == false);</span></a>
<a name="14103"><span class="lineNum">   14103 </span>            : </a>
<a name="14104"><span class="lineNum">   14104 </span>            :        // DQ (3/22/2012): Make sure there is template syntax present.</a>
<a name="14105"><span class="lineNum">   14105 </span><span class="lineCov">       5417 :           if (isSgTemplateInstantiationDecl(defdecl)-&gt;get_templateName().getString().find('&gt;') == string::npos)</span></a>
<a name="14106"><span class="lineNum">   14106 </span>            :              {</a>
<a name="14107"><span class="lineNum">   14107 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="14108"><span class="lineNum">   14108 </span>            :                printf (&quot;WARNING: No template syntax present in name of template class instantiation (defdecl) \n&quot;);</a>
<a name="14109"><span class="lineNum">   14109 </span>            : #endif</a>
<a name="14110"><span class="lineNum">   14110 </span>            :              }</a>
<a name="14111"><span class="lineNum">   14111 </span>            :        // ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)-&gt;get_templateName().getString().find('&gt;') != string::npos);</a>
<a name="14112"><span class="lineNum">   14112 </span>            : #if 0</a>
<a name="14113"><span class="lineNum">   14113 </span>            :           printf (&quot;Should we have set the template instantiation name at this point? \n&quot;);</a>
<a name="14114"><span class="lineNum">   14114 </span>            :           ROSE_ABORT();</a>
<a name="14115"><span class="lineNum">   14115 </span>            : #endif</a>
<a name="14116"><span class="lineNum">   14116 </span>            :        // DQ (3/5/2012): Check that the SgClassDefinition is properly matching.</a>
<a name="14117"><span class="lineNum">   14117 </span><span class="lineCov">       5417 :           ROSE_ASSERT(defdecl-&gt;get_definition() != NULL);</span></a>
<a name="14118"><span class="lineNum">   14118 </span><span class="lineCov">       5417 :           ROSE_ASSERT(isSgTemplateInstantiationDefn(defdecl-&gt;get_definition()) != NULL);</span></a>
<a name="14119"><span class="lineNum">   14119 </span>            :         }</a>
<a name="14120"><span class="lineNum">   14120 </span>            :        else</a>
<a name="14121"><span class="lineNum">   14121 </span>            :         {</a>
<a name="14122"><span class="lineNum">   14122 </span>            : #if 0</a>
<a name="14123"><span class="lineNum">   14123 </span>            :           printf (&quot;Building a SgClassDeclaration, but we might require a SgTemplateClassDeclaration \n&quot;);</a>
<a name="14124"><span class="lineNum">   14124 </span>            : #endif</a>
<a name="14125"><span class="lineNum">   14125 </span>            :        // defdecl = new SgClassDeclaration (name,kind,NULL,classDef);</a>
<a name="14126"><span class="lineNum">   14126 </span>            :        // defdecl = new SgClassDeclaration (nameWithoutTemplateArguments,kind,NULL,classDef);</a>
<a name="14127"><span class="lineNum">   14127 </span>            : </a>
<a name="14128"><span class="lineNum">   14128 </span>            :        // DQ (10/11/2015): Try to build a matching SgTemplateClassDeclaration.  The problem with this fix is that</a>
<a name="14129"><span class="lineNum">   14129 </span>            :        // I would prefer that the other function be called instead. We might still want to implementat that instead.</a>
<a name="14130"><span class="lineNum">   14130 </span><span class="lineCov">       6792 :           if (buildTemplateDeclaration == true)</span></a>
<a name="14131"><span class="lineNum">   14131 </span>            :              {</a>
<a name="14132"><span class="lineNum">   14132 </span>            :                printf (&quot;In buildClassDeclaration_nfi(): I think we also want template specialization arguments to be more general: using nameWithoutTemplateArguments = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="14133"><span class="lineNum">   14133 </span>            : </a>
<a name="14134"><span class="lineNum">   14134 </span>            :             //         = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,classType,(SgClassDefinition*)NULL);</a>
<a name="14135"><span class="lineNum">   14135 </span>            :                defdecl = new SgTemplateClassDeclaration (nameWithoutTemplateArguments,kind,NULL,classDef);</a>
<a name="14136"><span class="lineNum">   14136 </span>            : </a>
<a name="14137"><span class="lineNum">   14137 </span>            :             // DQ (2/27/2018): We should be able to enforce this, it should have always been true.</a>
<a name="14138"><span class="lineNum">   14138 </span>            :                ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</a>
<a name="14139"><span class="lineNum">   14139 </span>            : #if 0</a>
<a name="14140"><span class="lineNum">   14140 </span>            :                printf (&quot;Exiting afte test! \n&quot;);</a>
<a name="14141"><span class="lineNum">   14141 </span>            :                ROSE_ABORT();</a>
<a name="14142"><span class="lineNum">   14142 </span>            : #endif</a>
<a name="14143"><span class="lineNum">   14143 </span>            :              }</a>
<a name="14144"><span class="lineNum">   14144 </span>            :             else</a>
<a name="14145"><span class="lineNum">   14145 </span>            :              {</a>
<a name="14146"><span class="lineNum">   14146 </span><span class="lineCov">       6792 :                defdecl = new SgClassDeclaration (nameWithoutTemplateArguments,kind,NULL,classDef);</span></a>
<a name="14147"><span class="lineNum">   14147 </span>            : </a>
<a name="14148"><span class="lineNum">   14148 </span>            : #if 0</a>
<a name="14149"><span class="lineNum">   14149 </span>            :             // DQ (12/22/2019): Debugging the case of shared class declarations between multiple files referencing the same defining declaration.</a>
<a name="14150"><span class="lineNum">   14150 </span>            :                printf (&quot;In SageBuilder::buildClassDeclaration_nfi(): build a SgClassDeclaration: defdecl = %p \n&quot;,defdecl);</a>
<a name="14151"><span class="lineNum">   14151 </span>            : #endif</a>
<a name="14152"><span class="lineNum">   14152 </span>            : </a>
<a name="14153"><span class="lineNum">   14153 </span>            :             // DQ (2/27/2018): We should be able to enforce this, it should have always been true.</a>
<a name="14154"><span class="lineNum">   14154 </span><span class="lineCov">       6792 :                ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</span></a>
<a name="14155"><span class="lineNum">   14155 </span>            :              }</a>
<a name="14156"><span class="lineNum">   14156 </span>            : </a>
<a name="14157"><span class="lineNum">   14157 </span>            :        // DQ (3/5/2012): Check that the SgClassDefinition is properly matching.</a>
<a name="14158"><span class="lineNum">   14158 </span><span class="lineCov">       6792 :           ROSE_ASSERT(defdecl-&gt;get_definition() != NULL);</span></a>
<a name="14159"><span class="lineNum">   14159 </span><span class="lineCov">       6792 :           ROSE_ASSERT(isSgTemplateInstantiationDefn(defdecl-&gt;get_definition()) == NULL);</span></a>
<a name="14160"><span class="lineNum">   14160 </span>            :         }</a>
<a name="14161"><span class="lineNum">   14161 </span><span class="lineCov">      12209 :      ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="14162"><span class="lineNum">   14162 </span>            : </a>
<a name="14163"><span class="lineNum">   14163 </span>            : #if 0</a>
<a name="14164"><span class="lineNum">   14164 </span>            :      printf (&quot;In buildClassDeclaration_nfi(): nondefdecl = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="14165"><span class="lineNum">   14165 </span>            : #endif</a>
<a name="14166"><span class="lineNum">   14166 </span>            : </a>
<a name="14167"><span class="lineNum">   14167 </span>            :   // DQ (3/15/2012): Moved from original location above...</a>
<a name="14168"><span class="lineNum">   14168 </span><span class="lineCov">      12209 :      nondefdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="14169"><span class="lineNum">   14169 </span>            : </a>
<a name="14170"><span class="lineNum">   14170 </span><span class="lineCov">      12209 :      ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="14171"><span class="lineNum">   14171 </span><span class="lineCov">      12209 :      ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</span></a>
<a name="14172"><span class="lineNum">   14172 </span>            : </a>
<a name="14173"><span class="lineNum">   14173 </span>            :   // printf (&quot;SageBuilder::buildClassDeclaration_nfi(): defdecl = %p \n&quot;,defdecl);</a>
<a name="14174"><span class="lineNum">   14174 </span>            : </a>
<a name="14175"><span class="lineNum">   14175 </span><span class="lineCov">      12209 :      setOneSourcePositionForTransformation(defdecl);</span></a>
<a name="14176"><span class="lineNum">   14176 </span>            :   // constructor is side-effect free</a>
<a name="14177"><span class="lineNum">   14177 </span><span class="lineCov">      12209 :      classDef-&gt;set_declaration(defdecl);</span></a>
<a name="14178"><span class="lineNum">   14178 </span><span class="lineCov">      12209 :      defdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="14179"><span class="lineNum">   14179 </span>            : </a>
<a name="14180"><span class="lineNum">   14180 </span><span class="lineCov">      12209 :      testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14181"><span class="lineNum">   14181 </span><span class="lineCov">      12209 :      testTemplateArgumentParents(defdecl);</span></a>
<a name="14182"><span class="lineNum">   14182 </span>            : </a>
<a name="14183"><span class="lineNum">   14183 </span>            :   // setOneSourcePositionForTransformation(nondefdecl);</a>
<a name="14184"><span class="lineNum">   14184 </span>            :   //</a>
<a name="14185"><span class="lineNum">   14185 </span>            :   // Liao 1/18/2011, I changed the semantics of setOneSourcePositionNull to set file_info to null regardless the existence of</a>
<a name="14186"><span class="lineNum">   14186 </span>            :   // file_info of the input node.</a>
<a name="14187"><span class="lineNum">   14187 </span>            :   // We do want to keep the file_info of nodefdecl if it is set already as compiler generated.</a>
<a name="14188"><span class="lineNum">   14188 </span>            :   //    setOneSourcePositionNull(nondefdecl);</a>
<a name="14189"><span class="lineNum">   14189 </span>            : </a>
<a name="14190"><span class="lineNum">   14190 </span>            :   // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="14191"><span class="lineNum">   14191 </span>            :   // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="14192"><span class="lineNum">   14192 </span><span class="lineCov">      12209 :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="14193"><span class="lineNum">   14193 </span>            : </a>
<a name="14194"><span class="lineNum">   14194 </span><span class="lineCov">      12209 :      if (buildTemplateInstantiation == true)</span></a>
<a name="14195"><span class="lineNum">   14195 </span>            :         {</a>
<a name="14196"><span class="lineNum">   14196 </span>            :        // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).</a>
<a name="14197"><span class="lineNum">   14197 </span><span class="lineCov">       5417 :           setTemplateArgumentsInDeclaration(defdecl,templateArgumentsList);</span></a>
<a name="14198"><span class="lineNum">   14198 </span>            :         }</a>
<a name="14199"><span class="lineNum">   14199 </span>            : </a>
<a name="14200"><span class="lineNum">   14200 </span>            :   // DQ (3/22/2012): I think we can assert this.</a>
<a name="14201"><span class="lineNum">   14201 </span><span class="lineCov">      12209 :      ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</span></a>
<a name="14202"><span class="lineNum">   14202 </span>            : </a>
<a name="14203"><span class="lineNum">   14203 </span>            :   // Liao, 10/30/2009</a>
<a name="14204"><span class="lineNum">   14204 </span>            :   // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType</a>
<a name="14205"><span class="lineNum">   14205 </span>            :   // This is not desired when building a defining declaration and an inefficience in the constructor</a>
<a name="14206"><span class="lineNum">   14206 </span>            :   // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and</a>
<a name="14207"><span class="lineNum">   14207 </span>            :   // the defining class declaration (and other nondefining declaration) just shared that SgClassType.</a>
<a name="14208"><span class="lineNum">   14208 </span><span class="lineCov">      12209 :      if (defdecl-&gt;get_type() != NULL)</span></a>
<a name="14209"><span class="lineNum">   14209 </span>            :         {</a>
<a name="14210"><span class="lineNum">   14210 </span>            :        // if a defining class declaration's type is associated with a defining class.</a>
<a name="14211"><span class="lineNum">   14211 </span>            :        // This is a wrong SgClassType and has to be reset</a>
<a name="14212"><span class="lineNum">   14212 </span><span class="lineNoCov">          0 :           if (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl))</span></a>
<a name="14213"><span class="lineNum">   14213 </span>            :              {</a>
<a name="14214"><span class="lineNum">   14214 </span>            :             // DQ (3/21/2012): Added this test.</a>
<a name="14215"><span class="lineNum">   14215 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14216"><span class="lineNum">   14216 </span>            : </a>
<a name="14217"><span class="lineNum">   14217 </span>            :             // DQ (3/15/2012): Make this conditional upon the types not already being equal.</a>
<a name="14218"><span class="lineNum">   14218 </span><span class="lineNoCov">          0 :                if (nondefdecl-&gt;get_type() != defdecl-&gt;get_type())</span></a>
<a name="14219"><span class="lineNum">   14219 </span>            :                   {</a>
<a name="14220"><span class="lineNum">   14220 </span>            : #if 0</a>
<a name="14221"><span class="lineNum">   14221 </span>            :                     printf (&quot;Deleting defdecl-&gt;get_type() = %p = %s (using type from nondefdecl = %p) \n&quot;,defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str(),nondefdecl);</a>
<a name="14222"><span class="lineNum">   14222 </span>            :                     printf (&quot;Skipping delete of %p to maintain unique type pointers \n&quot;,defdecl-&gt;get_type());</a>
<a name="14223"><span class="lineNum">   14223 </span>            : #else</a>
<a name="14224"><span class="lineNum">   14224 </span><span class="lineNoCov">          0 :                     delete defdecl-&gt;get_type();</span></a>
<a name="14225"><span class="lineNum">   14225 </span>            : #endif</a>
<a name="14226"><span class="lineNum">   14226 </span>            :                  // DQ (3/15/2012): This will be reset below.</a>
<a name="14227"><span class="lineNum">   14227 </span><span class="lineNoCov">          0 :                     defdecl-&gt;set_type(NULL);</span></a>
<a name="14228"><span class="lineNum">   14228 </span>            : #if 0</a>
<a name="14229"><span class="lineNum">   14229 </span>            :                     printf (&quot;In SageBuilder::buildClassDeclaration(): built class type: part 5: defdecl-&gt;get_type() = %p = %s \n&quot;,defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14230"><span class="lineNum">   14230 </span>            : #endif</a>
<a name="14231"><span class="lineNum">   14231 </span>            : #if 0</a>
<a name="14232"><span class="lineNum">   14232 </span>            :                  // DQ (12/13/2011): Is this executed...</a>
<a name="14233"><span class="lineNum">   14233 </span>            :                     printf (&quot;Is this executed! \n&quot;);</a>
<a name="14234"><span class="lineNum">   14234 </span>            :                     ROSE_ABORT();</a>
<a name="14235"><span class="lineNum">   14235 </span>            : #endif</a>
<a name="14236"><span class="lineNum">   14236 </span>            :                  // DQ (3/21/2012): set the types to be the same type.</a>
<a name="14237"><span class="lineNum">   14237 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14238"><span class="lineNum">   14238 </span><span class="lineNoCov">          0 :                     defdecl-&gt;set_type(nondefdecl-&gt;get_type());</span></a>
<a name="14239"><span class="lineNum">   14239 </span>            : #if 0</a>
<a name="14240"><span class="lineNum">   14240 </span>            :                     printf (&quot;In SageBuilder::buildClassDeclaration(): built class type: part 6: nondefdecl-&gt;get_type() = %p = %s \n&quot;,defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14241"><span class="lineNum">   14241 </span>            : #endif</a>
<a name="14242"><span class="lineNum">   14242 </span>            :                  // DQ (3/21/2012): Added these checks...</a>
<a name="14243"><span class="lineNum">   14243 </span><span class="lineNoCov">          0 :                     SgClassType* classType = nondefdecl-&gt;get_type();</span></a>
<a name="14244"><span class="lineNum">   14244 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(classType != NULL);</span></a>
<a name="14245"><span class="lineNum">   14245 </span><span class="lineNoCov">          0 :                     SgClassDeclaration* local_classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="14246"><span class="lineNum">   14246 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT (local_classDeclaration != NULL);</span></a>
<a name="14247"><span class="lineNum">   14247 </span><span class="lineNoCov">          0 :                     printf (&quot;In buildClassDeclaration_nfi(): classType = %p local_classDeclaration = %p \n&quot;,classType,local_classDeclaration);</span></a>
<a name="14248"><span class="lineNum">   14248 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT (local_classDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="14249"><span class="lineNum">   14249 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT (local_classDeclaration-&gt;get_firstNondefiningDeclaration() == local_classDeclaration);</span></a>
<a name="14250"><span class="lineNum">   14250 </span>            :                   }</a>
<a name="14251"><span class="lineNum">   14251 </span>            :              }</a>
<a name="14252"><span class="lineNum">   14252 </span>            :         }</a>
<a name="14253"><span class="lineNum">   14253 </span>            :        else</a>
<a name="14254"><span class="lineNum">   14254 </span>            :         {</a>
<a name="14255"><span class="lineNum">   14255 </span>            :        // DQ (3/15/2012): Make sure that both the defining and non-defining declarations use the same type.</a>
<a name="14256"><span class="lineNum">   14256 </span><span class="lineCov">      12209 :           ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14257"><span class="lineNum">   14257 </span><span class="lineCov">      12209 :           defdecl-&gt;set_type(nondefdecl-&gt;get_type());</span></a>
<a name="14258"><span class="lineNum">   14258 </span>            : #if 0</a>
<a name="14259"><span class="lineNum">   14259 </span>            :           printf (&quot;In buildClassDeclaration_nfi(): defdecl = %p = %s defdecl-&gt;get_type() = %p = %s \n&quot;,defdecl,defdecl-&gt;class_name().c_str(),defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14260"><span class="lineNum">   14260 </span>            : #endif</a>
<a name="14261"><span class="lineNum">   14261 </span>            : </a>
<a name="14262"><span class="lineNum">   14262 </span><span class="lineCov">      12209 :           ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="14263"><span class="lineNum">   14263 </span>            : #if 0</a>
<a name="14264"><span class="lineNum">   14264 </span>            :        // DQ (11/20/2017): Commented out output spew.</a>
<a name="14265"><span class="lineNum">   14265 </span>            :        // DQ (2/28/2015): This test is failing in the new application support for templates within the testRoseHeaders_01.C.</a>
<a name="14266"><span class="lineNum">   14266 </span>            :           if (nondefdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()))</a>
<a name="14267"><span class="lineNum">   14267 </span>            :              {</a>
<a name="14268"><span class="lineNum">   14268 </span>            :                printf (&quot;WARNING: In buildClassDeclaration_nfi(): inner test: commented out test for equality between the declaration asociated with the type and that associated with the firstNondefiningDeclaration \n&quot;);</a>
<a name="14269"><span class="lineNum">   14269 </span>            :                printf (&quot;   --- nondefdecl-&gt;get_type()                        = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14270"><span class="lineNum">   14270 </span>            :                printf (&quot;   --- nondefdecl-&gt;get_type()-&gt;get_declaration()     = %p \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration());</a>
<a name="14271"><span class="lineNum">   14271 </span>            :                printf (&quot;   --- nondefdecl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration(),nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="14272"><span class="lineNum">   14272 </span>            :              }</a>
<a name="14273"><span class="lineNum">   14273 </span>            :        // DQ (7/22/2017): Uncomment this test to better understand why this is a new issue (after two years).</a>
<a name="14274"><span class="lineNum">   14274 </span>            :        // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()));</a>
<a name="14275"><span class="lineNum">   14275 </span>            : #endif</a>
<a name="14276"><span class="lineNum">   14276 </span>            : #if 0</a>
<a name="14277"><span class="lineNum">   14277 </span>            :           ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()));</a>
<a name="14278"><span class="lineNum">   14278 </span>            : #endif</a>
<a name="14279"><span class="lineNum">   14279 </span>            :         }</a>
<a name="14280"><span class="lineNum">   14280 </span>            : </a>
<a name="14281"><span class="lineNum">   14281 </span>            :   // DQ (9/4/2012): Added assertion.</a>
<a name="14282"><span class="lineNum">   14282 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14283"><span class="lineNum">   14283 </span>            : </a>
<a name="14284"><span class="lineNum">   14284 </span>            :   // patch up the SgClassType for the defining class declaration</a>
<a name="14285"><span class="lineNum">   14285 </span><span class="lineCov">      12209 :      ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14286"><span class="lineNum">   14286 </span>            :   // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="14287"><span class="lineNum">   14287 </span>            : #if 0</a>
<a name="14288"><span class="lineNum">   14288 </span>            :      if (nondefdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl))</a>
<a name="14289"><span class="lineNum">   14289 </span>            :         {</a>
<a name="14290"><span class="lineNum">   14290 </span>            :           printf (&quot;nondefdecl                                    = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="14291"><span class="lineNum">   14291 </span>            :           printf (&quot;nondefdecl-&gt;get_type()                        = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14292"><span class="lineNum">   14292 </span>            :           printf (&quot;nondefdecl-&gt;get_type()-&gt;get_declaration()     = %p = %s \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration(),nondefdecl-&gt;get_type()-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="14293"><span class="lineNum">   14293 </span>            :           printf (&quot;nondefdecl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration(),nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="14294"><span class="lineNum">   14294 </span>            :         }</a>
<a name="14295"><span class="lineNum">   14295 </span>            : #endif</a>
<a name="14296"><span class="lineNum">   14296 </span>            :   // ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl));</a>
<a name="14297"><span class="lineNum">   14297 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type() != NULL);</span></a>
<a name="14298"><span class="lineNum">   14298 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() != NULL);</span></a>
<a name="14299"><span class="lineNum">   14299 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(defdecl));</span></a>
<a name="14300"><span class="lineNum">   14300 </span><span class="lineCov">      12209 :      ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="14301"><span class="lineNum">   14301 </span><span class="lineCov">      12209 :      ROSE_ASSERT (nondefdecl-&gt;get_firstNondefiningDeclaration() == nondefdecl);</span></a>
<a name="14302"><span class="lineNum">   14302 </span>            : #if 0</a>
<a name="14303"><span class="lineNum">   14303 </span>            :      ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()));</a>
<a name="14304"><span class="lineNum">   14304 </span>            : #else</a>
<a name="14305"><span class="lineNum">   14305 </span>            : </a>
<a name="14306"><span class="lineNum">   14306 </span>            : #if 0</a>
<a name="14307"><span class="lineNum">   14307 </span>            :   // DQ (11/20/2017): Commented out output spew.</a>
<a name="14308"><span class="lineNum">   14308 </span>            :   // DQ (2/28/2015): This test is failing in the new application support for templates within the testRoseHeaders_01.C.</a>
<a name="14309"><span class="lineNum">   14309 </span>            :      if (nondefdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()))</a>
<a name="14310"><span class="lineNum">   14310 </span>            :         {</a>
<a name="14311"><span class="lineNum">   14311 </span>            :           printf (&quot;WARNING: In buildClassDeclaration_nfi(): outer test (test 1): commented out test for equality between the declaration asociated with the type and that associated with the firstNondefiningDeclaration \n&quot;);</a>
<a name="14312"><span class="lineNum">   14312 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_type()                        = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14313"><span class="lineNum">   14313 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_type()-&gt;get_declaration()     = %p \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration());</a>
<a name="14314"><span class="lineNum">   14314 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,nondefdecl-&gt;get_firstNondefiningDeclaration(),nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str());</a>
<a name="14315"><span class="lineNum">   14315 </span>            :         }</a>
<a name="14316"><span class="lineNum">   14316 </span>            :   // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl-&gt;get_firstNondefiningDeclaration()));</a>
<a name="14317"><span class="lineNum">   14317 </span>            :      if (nondefdecl-&gt;get_type()-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl))</a>
<a name="14318"><span class="lineNum">   14318 </span>            :         {</a>
<a name="14319"><span class="lineNum">   14319 </span>            :           printf (&quot;WARNING: In buildClassDeclaration_nfi(): outer test (test 2): commented out test for equality between the declaration asociated with the type and that associated with the firstNondefiningDeclaration \n&quot;);</a>
<a name="14320"><span class="lineNum">   14320 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_type()                        = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14321"><span class="lineNum">   14321 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_type()-&gt;get_declaration()     = %p \n&quot;,nondefdecl-&gt;get_type()-&gt;get_declaration());</a>
<a name="14322"><span class="lineNum">   14322 </span>            :           printf (&quot;   --- nondefdecl-&gt;get_firstNondefiningDeclaration() = %p = %s \n&quot;,nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="14323"><span class="lineNum">   14323 </span>            :         }</a>
<a name="14324"><span class="lineNum">   14324 </span>            :   // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="14325"><span class="lineNum">   14325 </span>            : #endif</a>
<a name="14326"><span class="lineNum">   14326 </span>            : </a>
<a name="14327"><span class="lineNum">   14327 </span>            : #endif</a>
<a name="14328"><span class="lineNum">   14328 </span>            : </a>
<a name="14329"><span class="lineNum">   14329 </span>            :   // DQ (9/4/2012): Added assertion.</a>
<a name="14330"><span class="lineNum">   14330 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14331"><span class="lineNum">   14331 </span>            : </a>
<a name="14332"><span class="lineNum">   14332 </span>            :   // This appears to be redundant...is it?</a>
<a name="14333"><span class="lineNum">   14333 </span><span class="lineCov">      12209 :      defdecl-&gt;set_type(nondefdecl-&gt;get_type());</span></a>
<a name="14334"><span class="lineNum">   14334 </span>            : </a>
<a name="14335"><span class="lineNum">   14335 </span>            : #if 0</a>
<a name="14336"><span class="lineNum">   14336 </span>            :      printf (&quot;In buildClassDeclaration_nfi(): after calling set_type() again: defdecl = %p = %s defdecl-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="14337"><span class="lineNum">   14337 </span>            :           defdecl,defdecl-&gt;class_name().c_str(),defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14338"><span class="lineNum">   14338 </span>            : #endif</a>
<a name="14339"><span class="lineNum">   14339 </span>            : </a>
<a name="14340"><span class="lineNum">   14340 </span>            :   // DQ (9/4/2012): Added assertion.</a>
<a name="14341"><span class="lineNum">   14341 </span><span class="lineCov">      12209 :      ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14342"><span class="lineNum">   14342 </span>            : </a>
<a name="14343"><span class="lineNum">   14343 </span>            :   // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).</a>
<a name="14344"><span class="lineNum">   14344 </span>            :   // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless</a>
<a name="14345"><span class="lineNum">   14345 </span>            :   // used in a defining declaration).</a>
<a name="14346"><span class="lineNum">   14346 </span><span class="lineCov">      12209 :      nondefdecl-&gt;setForward();</span></a>
<a name="14347"><span class="lineNum">   14347 </span>            : </a>
<a name="14348"><span class="lineNum">   14348 </span><span class="lineCov">      12209 :      if (scope != NULL)  // put into fixStructDeclaration() or alike later on</span></a>
<a name="14349"><span class="lineNum">   14349 </span>            :         {</a>
<a name="14350"><span class="lineNum">   14350 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="14351"><span class="lineNum">   14351 </span><span class="lineCov">      12209 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14352"><span class="lineNum">   14352 </span>            : </a>
<a name="14353"><span class="lineNum">   14353 </span>            :        // Note, this function sets the parent to be the scope if it is not already set.</a>
<a name="14354"><span class="lineNum">   14354 </span><span class="lineCov">      12209 :           fixStructDeclaration(defdecl,scope);</span></a>
<a name="14355"><span class="lineNum">   14355 </span>            : </a>
<a name="14356"><span class="lineNum">   14356 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="14357"><span class="lineNum">   14357 </span><span class="lineCov">      12209 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14358"><span class="lineNum">   14358 </span>            : </a>
<a name="14359"><span class="lineNum">   14359 </span><span class="lineCov">      12209 :           fixStructDeclaration(nondefdecl,scope);</span></a>
<a name="14360"><span class="lineNum">   14360 </span>            : </a>
<a name="14361"><span class="lineNum">   14361 </span>            :        // DQ (9/4/2012): Added assertion.</a>
<a name="14362"><span class="lineNum">   14362 </span><span class="lineCov">      12209 :           ROSE_ASSERT (defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</span></a>
<a name="14363"><span class="lineNum">   14363 </span>            : </a>
<a name="14364"><span class="lineNum">   14364 </span>            : #if 0</a>
<a name="14365"><span class="lineNum">   14365 </span>            :           SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="14366"><span class="lineNum">   14366 </span>            :           ROSE_ASSERT(mysymbol);</a>
<a name="14367"><span class="lineNum">   14367 </span>            :           scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="14368"><span class="lineNum">   14368 </span>            :           printf (&quot;@@@@@@@@@@@@@@ In buildClassDeclaration_nfi(): setting scope of defining and non-defining declaration to scope = %s \n&quot;,scope-&gt;class_name().c_str());</a>
<a name="14369"><span class="lineNum">   14369 </span>            :           defdecl-&gt;set_scope(scope);</a>
<a name="14370"><span class="lineNum">   14370 </span>            :           nondefdecl-&gt;set_scope(scope);</a>
<a name="14371"><span class="lineNum">   14371 </span>            : </a>
<a name="14372"><span class="lineNum">   14372 </span>            :        // defdecl-&gt;set_parent(scope);</a>
<a name="14373"><span class="lineNum">   14373 </span>            : </a>
<a name="14374"><span class="lineNum">   14374 </span>            :        // Liao, 9/2/2009. merged into fixStructDeclaration</a>
<a name="14375"><span class="lineNum">   14375 </span>            :        // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).</a>
<a name="14376"><span class="lineNum">   14376 </span>            :           nondefdecl-&gt;set_parent(scope);</a>
<a name="14377"><span class="lineNum">   14377 </span>            :        // nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="14378"><span class="lineNum">   14378 </span>            :        // Liao, 9/2/2009. scope stack is optional, it can be empty</a>
<a name="14379"><span class="lineNum">   14379 </span>            :           defdecl-&gt;set_parent(scope);</a>
<a name="14380"><span class="lineNum">   14380 </span>            :        // defdecl-&gt;set_parent(topScopeStack());</a>
<a name="14381"><span class="lineNum">   14381 </span>            : #endif</a>
<a name="14382"><span class="lineNum">   14382 </span>            :         }</a>
<a name="14383"><span class="lineNum">   14383 </span>            : </a>
<a name="14384"><span class="lineNum">   14384 </span>            :   // DQ (1/26/2009): I think we should assert this, but it breaks the interface as defined</a>
<a name="14385"><span class="lineNum">   14385 </span>            :   // by the test code in tests/nonsmoke/functional/roseTests/astInterfaceTests.</a>
<a name="14386"><span class="lineNum">   14386 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_parent() != NULL);</a>
<a name="14387"><span class="lineNum">   14387 </span>            : </a>
<a name="14388"><span class="lineNum">   14388 </span>            :   // ROSE_ASSERT(nonDefiningDecl-&gt;get_parent() != NULL);</a>
<a name="14389"><span class="lineNum">   14389 </span>            : </a>
<a name="14390"><span class="lineNum">   14390 </span>            :   // DQ (2/27/2012): Tracking down where parents are not set correctly (class declaration in typedef is incorrectly set to SgGlobal).</a>
<a name="14391"><span class="lineNum">   14391 </span><span class="lineCov">      12209 :      ROSE_ASSERT(defdecl-&gt;get_parent()    == NULL);</span></a>
<a name="14392"><span class="lineNum">   14392 </span>            : </a>
<a name="14393"><span class="lineNum">   14393 </span>            :   // DQ (2/29/2012):  We can't assert this (fails for test2012_09.C).</a>
<a name="14394"><span class="lineNum">   14394 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_parent() == NULL);</a>
<a name="14395"><span class="lineNum">   14395 </span>            : </a>
<a name="14396"><span class="lineNum">   14396 </span><span class="lineCov">      12209 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="14397"><span class="lineNum">   14397 </span><span class="lineCov">      12209 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != defdecl-&gt;get_definingDeclaration());</span></a>
<a name="14398"><span class="lineNum">   14398 </span>            : </a>
<a name="14399"><span class="lineNum">   14399 </span><span class="lineCov">      12209 :      testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14400"><span class="lineNum">   14400 </span><span class="lineCov">      12209 :      testTemplateArgumentParents(defdecl);</span></a>
<a name="14401"><span class="lineNum">   14401 </span>            : </a>
<a name="14402"><span class="lineNum">   14402 </span>            :   // DQ (3/8/2018): Added for debugging.</a>
<a name="14403"><span class="lineNum">   14403 </span><span class="lineCov">      12209 :      SgClassDeclaration* temp_firstNondefiningDeclaration = isSgClassDeclaration(defdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="14404"><span class="lineNum">   14404 </span><span class="lineCov">      12209 :      SgClassDeclaration* temp_definingDeclaration         = isSgClassDeclaration(defdecl-&gt;get_definingDeclaration());</span></a>
<a name="14405"><span class="lineNum">   14405 </span><span class="lineCov">      12209 :      ROSE_ASSERT(temp_firstNondefiningDeclaration != NULL);</span></a>
<a name="14406"><span class="lineNum">   14406 </span><span class="lineCov">      12209 :      ROSE_ASSERT(temp_definingDeclaration != NULL);</span></a>
<a name="14407"><span class="lineNum">   14407 </span>            : </a>
<a name="14408"><span class="lineNum">   14408 </span>            : #if 0</a>
<a name="14409"><span class="lineNum">   14409 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): defdecl = %p = %s = %s \n&quot;,defdecl,defdecl-&gt;class_name().c_str(),defdecl-&gt;get_name().str());</a>
<a name="14410"><span class="lineNum">   14410 </span>            :      printf (&quot;   --- defdecl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,defdecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="14411"><span class="lineNum">   14411 </span>            :      printf (&quot;   --- defdecl-&gt;get_definingDeclaration()         = %p \n&quot;,defdecl-&gt;get_definingDeclaration());</a>
<a name="14412"><span class="lineNum">   14412 </span>            : </a>
<a name="14413"><span class="lineNum">   14413 </span>            :      printf (&quot;   --- defdecl-&gt;get_firstNondefiningDeclaration()-&gt;get_name() = %s \n&quot;,temp_firstNondefiningDeclaration-&gt;get_name().str());</a>
<a name="14414"><span class="lineNum">   14414 </span>            :      printf (&quot;   --- defdecl-&gt;get_definingDeclaration()-&gt;get_name()         = %s \n&quot;,temp_definingDeclaration-&gt;get_name().str());</a>
<a name="14415"><span class="lineNum">   14415 </span>            : </a>
<a name="14416"><span class="lineNum">   14416 </span>            :      printf (&quot;   --- defdecl-&gt;get_firstNondefiningDeclaration()-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="14417"><span class="lineNum">   14417 </span>            :           temp_firstNondefiningDeclaration-&gt;get_type(),temp_firstNondefiningDeclaration-&gt;get_type()-&gt;unparseToString().c_str());</a>
<a name="14418"><span class="lineNum">   14418 </span>            :      printf (&quot;   --- defdecl-&gt;get_definingDeclaration()-&gt;get_type()         = %p = %s \n&quot;,</a>
<a name="14419"><span class="lineNum">   14419 </span>            :           temp_definingDeclaration-&gt;get_type(),temp_definingDeclaration-&gt;get_type()-&gt;unparseToString().c_str());</a>
<a name="14420"><span class="lineNum">   14420 </span>            : </a>
<a name="14421"><span class="lineNum">   14421 </span>            :      printf (&quot;   --- nameWithoutTemplateArguments               = %s \n&quot;,nameWithoutTemplateArguments.str());</a>
<a name="14422"><span class="lineNum">   14422 </span>            :      printf (&quot;   --- nameWithTemplateArguments                  = %s \n&quot;,nameWithTemplateArguments.str());</a>
<a name="14423"><span class="lineNum">   14423 </span>            : </a>
<a name="14424"><span class="lineNum">   14424 </span>            : #if 0</a>
<a name="14425"><span class="lineNum">   14425 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): defdecl: unparseNameToString() = %s \n&quot;,defdecl-&gt;unparseNameToString().c_str());</a>
<a name="14426"><span class="lineNum">   14426 </span>            : #endif</a>
<a name="14427"><span class="lineNum">   14427 </span>            : #endif</a>
<a name="14428"><span class="lineNum">   14428 </span>            : </a>
<a name="14429"><span class="lineNum">   14429 </span>            :   // DQ (3/8/2018): Added assertion.</a>
<a name="14430"><span class="lineNum">   14430 </span><span class="lineCov">      12209 :      ROSE_ASSERT(temp_firstNondefiningDeclaration-&gt;get_name() == temp_definingDeclaration-&gt;get_name());</span></a>
<a name="14431"><span class="lineNum">   14431 </span><span class="lineCov">      12209 :      ROSE_ASSERT(temp_firstNondefiningDeclaration-&gt;get_type() == temp_definingDeclaration-&gt;get_type());</span></a>
<a name="14432"><span class="lineNum">   14432 </span>            : </a>
<a name="14433"><span class="lineNum">   14433 </span>            :   // DQ (3/7/2015): Only in EDG 4.7 does the defining declaration not have a valid templateDeclaration pointer (sometimes).</a>
<a name="14434"><span class="lineNum">   14434 </span><span class="lineCov">      12209 :      SgTemplateInstantiationDecl* nondefiningDeclaration = isSgTemplateInstantiationDecl(defdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="14435"><span class="lineNum">   14435 </span><span class="lineCov">      12209 :      SgTemplateInstantiationDecl* definingDeclaration    = isSgTemplateInstantiationDecl(defdecl-&gt;get_definingDeclaration());</span></a>
<a name="14436"><span class="lineNum">   14436 </span><span class="lineCov">      12209 :      if (definingDeclaration != NULL &amp;&amp; nondefiningDeclaration != NULL)</span></a>
<a name="14437"><span class="lineNum">   14437 </span>            :         {</a>
<a name="14438"><span class="lineNum">   14438 </span><span class="lineCov">       5417 :           SgTemplateClassDeclaration* templateDeclaration = nondefiningDeclaration-&gt;get_templateDeclaration();</span></a>
<a name="14439"><span class="lineNum">   14439 </span><span class="lineCov">       5417 :           if (templateDeclaration != NULL &amp;&amp; definingDeclaration-&gt;get_templateDeclaration() == NULL)</span></a>
<a name="14440"><span class="lineNum">   14440 </span>            :              {</a>
<a name="14441"><span class="lineNum">   14441 </span>            : #if 0</a>
<a name="14442"><span class="lineNum">   14442 </span>            :                printf (&quot;NOTE: buildClassDeclaration_nfi(): Setting the templateDeclaration for the defining declaration = %p using the value = %p from the nondefiningDeclaration = %p \n&quot;,</a>
<a name="14443"><span class="lineNum">   14443 </span>            :                     definingDeclaration,templateDeclaration,nondefiningDeclaration);</a>
<a name="14444"><span class="lineNum">   14444 </span>            : #endif</a>
<a name="14445"><span class="lineNum">   14445 </span><span class="lineCov">       2088 :                definingDeclaration-&gt;set_templateDeclaration(templateDeclaration);</span></a>
<a name="14446"><span class="lineNum">   14446 </span>            : </a>
<a name="14447"><span class="lineNum">   14447 </span><span class="lineCov">       2088 :                ROSE_ASSERT(definingDeclaration-&gt;get_templateDeclaration() != NULL);</span></a>
<a name="14448"><span class="lineNum">   14448 </span>            :              }</a>
<a name="14449"><span class="lineNum">   14449 </span>            :        // ROSE_ASSERT(definingDeclaration-&gt;get_templateDeclaration() != NULL);</a>
<a name="14450"><span class="lineNum">   14450 </span>            :         }</a>
<a name="14451"><span class="lineNum">   14451 </span>            : </a>
<a name="14452"><span class="lineNum">   14452 </span>            :   // DQ (3/7/2015): Only in EDG 4.7 does the defining declaration not have a valid templateDeclaration pointer (sometimes).</a>
<a name="14453"><span class="lineNum">   14453 </span><span class="lineCov">      12209 :      if (definingDeclaration != NULL)</span></a>
<a name="14454"><span class="lineNum">   14454 </span>            :         {</a>
<a name="14455"><span class="lineNum">   14455 </span><span class="lineCov">       5417 :           if (definingDeclaration-&gt;get_templateDeclaration() == NULL)</span></a>
<a name="14456"><span class="lineNum">   14456 </span>            :              {</a>
<a name="14457"><span class="lineNum">   14457 </span>            : #if 0</a>
<a name="14458"><span class="lineNum">   14458 </span>            :                printf (&quot;NOTE: buildClassDeclaration_nfi(): definingDeclaration-&gt;get_templateDeclaration() == NULL \n&quot;);</a>
<a name="14459"><span class="lineNum">   14459 </span>            : #endif</a>
<a name="14460"><span class="lineNum">   14460 </span>            :              }</a>
<a name="14461"><span class="lineNum">   14461 </span>            :        // ROSE_ASSERT(definingDeclaration-&gt;get_templateDeclaration() != NULL);</a>
<a name="14462"><span class="lineNum">   14462 </span>            :         }</a>
<a name="14463"><span class="lineNum">   14463 </span>            : </a>
<a name="14464"><span class="lineNum">   14464 </span>            : #if 0</a>
<a name="14465"><span class="lineNum">   14465 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): defdecl = %p defdecl-&gt;unparseNameToString() = %s \n&quot;,defdecl,defdecl-&gt;unparseNameToString().c_str());</a>
<a name="14466"><span class="lineNum">   14466 </span>            : #endif</a>
<a name="14467"><span class="lineNum">   14467 </span>            : </a>
<a name="14468"><span class="lineNum">   14468 </span>            : #if 0</a>
<a name="14469"><span class="lineNum">   14469 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="14470"><span class="lineNum">   14470 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): Calling find_symbol_from_declaration() \n&quot;);</a>
<a name="14471"><span class="lineNum">   14471 </span>            :      SgSymbol* test_symbol = nondefdecl-&gt;get_scope()-&gt;find_symbol_from_declaration(nondefdecl);</a>
<a name="14472"><span class="lineNum">   14472 </span>            : </a>
<a name="14473"><span class="lineNum">   14473 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="14474"><span class="lineNum">   14474 </span>            :      printf (&quot;Leaving buildClassDeclaration_nfi(): Calling get_symbol_from_symbol_table() \n&quot;);</a>
<a name="14475"><span class="lineNum">   14475 </span>            :      ROSE_ASSERT(nondefdecl-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="14476"><span class="lineNum">   14476 </span>            : #endif</a>
<a name="14477"><span class="lineNum">   14477 </span>            : </a>
<a name="14478"><span class="lineNum">   14478 </span><span class="lineCov">      24418 :      return defdecl;</span></a>
<a name="14479"><span class="lineNum">   14479 </span>            :    }</a>
<a name="14480"><span class="lineNum">   14480 </span>            : </a>
<a name="14481"><span class="lineNum">   14481 </span>            : </a>
<a name="14482"><span class="lineNum">   14482 </span><span class="lineNoCov">          0 : SgClassDeclaration* SageBuilder::buildStructDeclaration(const string&amp; name, SgScopeStatement* scope/*=NULL*/)</span></a>
<a name="14483"><span class="lineNum">   14483 </span>            :    {</a>
<a name="14484"><span class="lineNum">   14484 </span><span class="lineNoCov">          0 :      SgName myname(name);</span></a>
<a name="14485"><span class="lineNum">   14485 </span><span class="lineNoCov">          0 :      return buildStructDeclaration(myname, scope);</span></a>
<a name="14486"><span class="lineNum">   14486 </span>            :    }</a>
<a name="14487"><span class="lineNum">   14487 </span>            : </a>
<a name="14488"><span class="lineNum">   14488 </span><span class="lineCov">          4 : SgClassDeclaration* SageBuilder::buildStructDeclaration(const char* name, SgScopeStatement* scope/*=NULL*/)</span></a>
<a name="14489"><span class="lineNum">   14489 </span>            :    {</a>
<a name="14490"><span class="lineNum">   14490 </span><span class="lineCov">          8 :      SgName myname(name);</span></a>
<a name="14491"><span class="lineNum">   14491 </span><span class="lineCov">          8 :      return buildStructDeclaration(myname, scope);</span></a>
<a name="14492"><span class="lineNum">   14492 </span>            :    }</a>
<a name="14493"><span class="lineNum">   14493 </span>            : </a>
<a name="14494"><span class="lineNum">   14494 </span>            : </a>
<a name="14495"><span class="lineNum">   14495 </span>            : #if 0</a>
<a name="14496"><span class="lineNum">   14496 </span>            : // DQ (11/19/2011): Added more uniform support for building class declarations.</a>
<a name="14497"><span class="lineNum">   14497 </span>            : SgTemplateClassDeclaration*</a>
<a name="14498"><span class="lineNum">   14498 </span>            : SageBuilder::buildTemplateClassDeclaration ( SgName name, SgScopeStatement* scope )</a>
<a name="14499"><span class="lineNum">   14499 </span>            :    {</a>
<a name="14500"><span class="lineNum">   14500 </span>            :      ROSE_ASSERT(scope != NULL);</a>
<a name="14501"><span class="lineNum">   14501 </span>            :      SgTemplateClassDeclaration* definingClassDeclaration = buildDefiningTemplateClassDeclaration(name,scope);</a>
<a name="14502"><span class="lineNum">   14502 </span>            :      ROSE_ASSERT(definingClassDeclaration != NULL);</a>
<a name="14503"><span class="lineNum">   14503 </span>            : </a>
<a name="14504"><span class="lineNum">   14504 </span>            :      return definingClassDeclaration;</a>
<a name="14505"><span class="lineNum">   14505 </span>            :    }</a>
<a name="14506"><span class="lineNum">   14506 </span>            : #endif</a>
<a name="14507"><span class="lineNum">   14507 </span>            : </a>
<a name="14508"><span class="lineNum">   14508 </span>            : </a>
<a name="14509"><span class="lineNum">   14509 </span>            : SgTemplateClassDefinition*</a>
<a name="14510"><span class="lineNum">   14510 </span><span class="lineCov">       4922 : SageBuilder::buildTemplateClassDefinition(SgTemplateClassDeclaration *d /*= NULL*/ )</span></a>
<a name="14511"><span class="lineNum">   14511 </span>            :   {</a>
<a name="14512"><span class="lineNum">   14512 </span><span class="lineCov">       4922 :     SgTemplateClassDefinition* result = NULL;</span></a>
<a name="14513"><span class="lineNum">   14513 </span><span class="lineCov">       4922 :     if (d != NULL) // the constructor does not check for NULL d, causing segmentation fault</span></a>
<a name="14514"><span class="lineNum">   14514 </span>            :        {</a>
<a name="14515"><span class="lineNum">   14515 </span><span class="lineNoCov">          0 :          result = new SgTemplateClassDefinition(d);</span></a>
<a name="14516"><span class="lineNum">   14516 </span>            :       // result-&gt;set_parent(d); // set_declaration() == set_parent() in this case</a>
<a name="14517"><span class="lineNum">   14517 </span>            :        }</a>
<a name="14518"><span class="lineNum">   14518 </span>            :       else</a>
<a name="14519"><span class="lineNum">   14519 </span>            :        {</a>
<a name="14520"><span class="lineNum">   14520 </span><span class="lineCov">       4922 :          result = new SgTemplateClassDefinition();</span></a>
<a name="14521"><span class="lineNum">   14521 </span>            :        }</a>
<a name="14522"><span class="lineNum">   14522 </span>            : </a>
<a name="14523"><span class="lineNum">   14523 </span><span class="lineCov">       4922 :     ROSE_ASSERT(result);</span></a>
<a name="14524"><span class="lineNum">   14524 </span>            : </a>
<a name="14525"><span class="lineNum">   14525 </span>            :  // CR (3/22/2020): Fixed setting case insensitivity</a>
<a name="14526"><span class="lineNum">   14526 </span>            :  // if (symbol_table_case_insensitive_semantics == true)</a>
<a name="14527"><span class="lineNum">   14527 </span><span class="lineCov">       4922 :     if (SageInterface::is_language_case_insensitive())</span></a>
<a name="14528"><span class="lineNum">   14528 </span><span class="lineNoCov">          0 :          result-&gt;setCaseInsensitive(true);</span></a>
<a name="14529"><span class="lineNum">   14529 </span>            : </a>
<a name="14530"><span class="lineNum">   14530 </span><span class="lineCov">       4922 :     setOneSourcePositionForTransformation(result);</span></a>
<a name="14531"><span class="lineNum">   14531 </span><span class="lineCov">       4922 :     return result;</span></a>
<a name="14532"><span class="lineNum">   14532 </span>            :   }</a>
<a name="14533"><span class="lineNum">   14533 </span>            : </a>
<a name="14534"><span class="lineNum">   14534 </span>            : SgTemplateClassDeclaration*</a>
<a name="14535"><span class="lineNum">   14535 </span><span class="lineNoCov">          0 : SageBuilder::buildNondefiningTemplateClassDeclaration(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )</span></a>
<a name="14536"><span class="lineNum">   14536 </span>            : {</a>
<a name="14537"><span class="lineNum">   14537 </span><span class="lineNoCov">          0 :   SgTemplateClassDeclaration* res = buildNondefiningTemplateClassDeclaration_nfi (XXX_name, kind, scope, templateParameterList, templateSpecializationArgumentList);</span></a>
<a name="14538"><span class="lineNum">   14538 </span><span class="lineNoCov">          0 :   setSourcePositionForTransformation(res);</span></a>
<a name="14539"><span class="lineNum">   14539 </span><span class="lineNoCov">          0 :   return res;</span></a>
<a name="14540"><span class="lineNum">   14540 </span>            : }</a>
<a name="14541"><span class="lineNum">   14541 </span>            : </a>
<a name="14542"><span class="lineNum">   14542 </span>            : // SgTemplateClassDeclaration * SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope )</a>
<a name="14543"><span class="lineNum">   14543 </span>            : SgTemplateClassDeclaration*</a>
<a name="14544"><span class="lineNum">   14544 </span><span class="lineCov">       1158 : SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )</span></a>
<a name="14545"><span class="lineNum">   14545 </span>            :    {</a>
<a name="14546"><span class="lineNum">   14546 </span>            : #if 0</a>
<a name="14547"><span class="lineNum">   14547 </span>            :      printf(&quot;In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(XXX_name = %p):\n&quot;, XXX_name.str());</a>
<a name="14548"><span class="lineNum">   14548 </span>            : #endif</a>
<a name="14549"><span class="lineNum">   14549 </span>            : </a>
<a name="14550"><span class="lineNum">   14550 </span><span class="lineCov">       1158 :      if (scope == NULL)</span></a>
<a name="14551"><span class="lineNum">   14551 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="14552"><span class="lineNum">   14552 </span>            : </a>
<a name="14553"><span class="lineNum">   14553 </span>            :   // DQ (11/20/2011): This is for initial debugging only.</a>
<a name="14554"><span class="lineNum">   14554 </span><span class="lineCov">       1158 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="14555"><span class="lineNum">   14555 </span>            : </a>
<a name="14556"><span class="lineNum">   14556 </span>            : #if 0</a>
<a name="14557"><span class="lineNum">   14557 </span>            :      printf (&quot;SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): XXX_name = %s scope = %p = %s \n&quot;,XXX_name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="14558"><span class="lineNum">   14558 </span>            : #endif</a>
<a name="14559"><span class="lineNum">   14559 </span>            : </a>
<a name="14560"><span class="lineNum">   14560 </span>            :   // DQ (9/12/2012): We want to add the template arguments of any specialization to the template name and keep track of the name with and without template specialization arguments.</a>
<a name="14561"><span class="lineNum">   14561 </span><span class="lineCov">       2316 :      SgName nameWithoutTemplateArguments            = XXX_name;</span></a>
<a name="14562"><span class="lineNum">   14562 </span><span class="lineCov">       1158 :      SgName nameWithTemplateSpecializationArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateSpecializationArgumentList);</span></a>
<a name="14563"><span class="lineNum">   14563 </span>            : </a>
<a name="14564"><span class="lineNum">   14564 </span>            : #if 0</a>
<a name="14565"><span class="lineNum">   14565 </span>            :      printf (&quot;SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): nameWithTemplateSpecializationArguments = %s \n&quot;,nameWithTemplateSpecializationArguments.str());</a>
<a name="14566"><span class="lineNum">   14566 </span>            : #endif</a>
<a name="14567"><span class="lineNum">   14567 </span>            : </a>
<a name="14568"><span class="lineNum">   14568 </span>            :   // SgTemplateClassDeclaration::class_types template_class_kind = SgTemplateClassDeclaration::e_class;</a>
<a name="14569"><span class="lineNum">   14569 </span>            : </a>
<a name="14570"><span class="lineNum">   14570 </span>            :   // Step 2. build the nondefining declaration,</a>
<a name="14571"><span class="lineNum">   14571 </span>            :   // but only if the input nonDefiningDecl pointer was NULL and it does not exist</a>
<a name="14572"><span class="lineNum">   14572 </span>            : </a>
<a name="14573"><span class="lineNum">   14573 </span>            :   // Get the nondefining declaration from the symbol if it has been built (if this works,</a>
<a name="14574"><span class="lineNum">   14574 </span>            :   // then we likely don't need the &quot;SgClassDeclaration* nonDefiningDecl&quot; parameter).</a>
<a name="14575"><span class="lineNum">   14575 </span><span class="lineCov">       1158 :      SgTemplateClassDeclaration* nondefdecl = NULL;</span></a>
<a name="14576"><span class="lineNum">   14576 </span>            : </a>
<a name="14577"><span class="lineNum">   14577 </span>            :   // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/nonsmoke/functional/roseTests/astInterfaceTests test codes.</a>
<a name="14578"><span class="lineNum">   14578 </span>            :   // ROSE_ASSERT(scope != NULL);</a>
<a name="14579"><span class="lineNum">   14579 </span>            : </a>
<a name="14580"><span class="lineNum">   14580 </span>            :   // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.</a>
<a name="14581"><span class="lineNum">   14581 </span>            :   // SgTemplateSymbol* mysymbol = NULL;</a>
<a name="14582"><span class="lineNum">   14582 </span><span class="lineCov">       1158 :      SgClassSymbol* mysymbol = NULL;</span></a>
<a name="14583"><span class="lineNum">   14583 </span>            : </a>
<a name="14584"><span class="lineNum">   14584 </span><span class="lineCov">       1158 :      if (scope != NULL)</span></a>
<a name="14585"><span class="lineNum">   14585 </span>            :         {</a>
<a name="14586"><span class="lineNum">   14586 </span>            :        // DQ (9/12/2012): We want to include the template specialization into the name where it is required (this handling</a>
<a name="14587"><span class="lineNum">   14587 </span>            :        // is similar to normal template arguments for non-template declaration, but different than template parameters).</a>
<a name="14588"><span class="lineNum">   14588 </span>            :        // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.</a>
<a name="14589"><span class="lineNum">   14589 </span>            :        // mysymbol = scope-&gt;lookup_template_symbol(name);</a>
<a name="14590"><span class="lineNum">   14590 </span>            :        // mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="14591"><span class="lineNum">   14591 </span>            :        // mysymbol = scope-&gt;lookup_template_class_symbol(name);</a>
<a name="14592"><span class="lineNum">   14592 </span>            :        // mysymbol = scope-&gt;lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList);</a>
<a name="14593"><span class="lineNum">   14593 </span><span class="lineCov">       1158 :           mysymbol = scope-&gt;lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList);</span></a>
<a name="14594"><span class="lineNum">   14594 </span>            :         }</a>
<a name="14595"><span class="lineNum">   14595 </span>            :        else</a>
<a name="14596"><span class="lineNum">   14596 </span>            :         {</a>
<a name="14597"><span class="lineNum">   14597 </span>            :        // Liao 9/2/2009: This is not an error. We support bottom-up AST construction and scope can be unknown.</a>
<a name="14598"><span class="lineNum">   14598 </span>            :        // DQ (1/26/2009): I think this should be an error, but that appears it would</a>
<a name="14599"><span class="lineNum">   14599 </span>            :        // break the existing interface. Need to discuss this with Liao.</a>
<a name="14600"><span class="lineNum">   14600 </span><span class="lineCov">       1158 :           printf (&quot;Warning: In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): scope == NULL \n&quot;);</span></a>
<a name="14601"><span class="lineNum">   14601 </span>            :         }</a>
<a name="14602"><span class="lineNum">   14602 </span>            : #if 0</a>
<a name="14603"><span class="lineNum">   14603 </span>            :      printf (&quot;In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="14604"><span class="lineNum">   14604 </span>            : #endif</a>
<a name="14605"><span class="lineNum">   14605 </span>            : </a>
<a name="14606"><span class="lineNum">   14606 </span><span class="lineCov">       1158 :      if (mysymbol != NULL) // set links if nondefining declaration already exists.</span></a>
<a name="14607"><span class="lineNum">   14607 </span>            :         {</a>
<a name="14608"><span class="lineNum">   14608 </span>            :        // DQ (3/7/2012): Build a seperate non-defining declaration (reusing the existing one will cause the test for unique statements to fail).</a>
<a name="14609"><span class="lineNum">   14609 </span>            :        // printf (&quot;WARNING: Even if the first non-defining SgTemplateClassDeclaration is found in the symbol table then likely we still might want to build a 2nd one. \n&quot;);</a>
<a name="14610"><span class="lineNum">   14610 </span>            :        // nondefdecl = isSgTemplateClassDeclaration(mysymbol-&gt;get_declaration());</a>
<a name="14611"><span class="lineNum">   14611 </span><span class="lineCov">         98 :           SgClassType* classType = isSgClassType(mysymbol-&gt;get_type());</span></a>
<a name="14612"><span class="lineNum">   14612 </span><span class="lineCov">         98 :           ROSE_ASSERT(classType != NULL);</span></a>
<a name="14613"><span class="lineNum">   14613 </span>            : </a>
<a name="14614"><span class="lineNum">   14614 </span>            :        // DQ (9/12/2012): We want to include the template specialization into the name where it is required.</a>
<a name="14615"><span class="lineNum">   14615 </span>            :        // nondefdecl = new SgTemplateClassDeclaration(name,kind,classType,(SgClassDefinition*)NULL);</a>
<a name="14616"><span class="lineNum">   14616 </span><span class="lineCov">         98 :           nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,classType,(SgClassDefinition*)NULL);</span></a>
<a name="14617"><span class="lineNum">   14617 </span>            : </a>
<a name="14618"><span class="lineNum">   14618 </span>            : #if 0</a>
<a name="14619"><span class="lineNum">   14619 </span>            :        // DQ (3/4/2018): relax this requirement for SgTemplateInstantiationClassDeclaration.</a>
<a name="14620"><span class="lineNum">   14620 </span>            :        // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to</a>
<a name="14621"><span class="lineNum">   14621 </span>            :        // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.</a>
<a name="14622"><span class="lineNum">   14622 </span>            :           if (nondefdecl-&gt;get_type() != NULL)</a>
<a name="14623"><span class="lineNum">   14623 </span>            :              {</a>
<a name="14624"><span class="lineNum">   14624 </span>            :                printf (&quot;Note: SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): nondefdecl-&gt;get_type() != NULL: name = %s \n&quot;,nondefdecl-&gt;get_name().str());</a>
<a name="14625"><span class="lineNum">   14625 </span>            :              }</a>
<a name="14626"><span class="lineNum">   14626 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_type() == NULL);</a>
<a name="14627"><span class="lineNum">   14627 </span>            : #endif</a>
<a name="14628"><span class="lineNum">   14628 </span>            : </a>
<a name="14629"><span class="lineNum">   14629 </span><span class="lineCov">         98 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="14630"><span class="lineNum">   14630 </span>            : </a>
<a name="14631"><span class="lineNum">   14631 </span>            :        // DQ (9/10/2012): Initialize the template parameter list.</a>
<a name="14632"><span class="lineNum">   14632 </span><span class="lineCov">         98 :           ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="14633"><span class="lineNum">   14633 </span><span class="lineCov">         98 :           nondefdecl-&gt;get_templateParameters() = *templateParameterList;</span></a>
<a name="14634"><span class="lineNum">   14634 </span>            : </a>
<a name="14635"><span class="lineNum">   14635 </span>            :        // DQ (9/16/2012): Moved this initialization of firstNondefiningDeclaration from farther down in this branch (and added assertion).</a>
<a name="14636"><span class="lineNum">   14636 </span><span class="lineCov">         98 :           nondefdecl-&gt;set_firstNondefiningDeclaration(mysymbol-&gt;get_declaration());</span></a>
<a name="14637"><span class="lineNum">   14637 </span><span class="lineCov">         98 :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="14638"><span class="lineNum">   14638 </span>            : </a>
<a name="14639"><span class="lineNum">   14639 </span>            :       // TV (04/12/2018): Add a scope for nonreal classes (and their member) on the first non-defining declaration of template classes</a>
<a name="14640"><span class="lineNum">   14640 </span><span class="lineCov">         98 :           if (nondefdecl == nondefdecl-&gt;get_firstNondefiningDeclaration()) {</span></a>
<a name="14641"><span class="lineNum">   14641 </span><span class="lineNoCov">          0 :             SgDeclarationScope * nonreal_decl_scope = new SgDeclarationScope();</span></a>
<a name="14642"><span class="lineNum">   14642 </span>            : </a>
<a name="14643"><span class="lineNum">   14643 </span><span class="lineNoCov">          0 :             nonreal_decl_scope-&gt;set_parent(nondefdecl);</span></a>
<a name="14644"><span class="lineNum">   14644 </span><span class="lineNoCov">          0 :             nondefdecl-&gt;set_nonreal_decl_scope(nonreal_decl_scope);</span></a>
<a name="14645"><span class="lineNum">   14645 </span>            : </a>
<a name="14646"><span class="lineNum">   14646 </span><span class="lineNoCov">          0 :             SageInterface::setSourcePosition(nonreal_decl_scope);</span></a>
<a name="14647"><span class="lineNum">   14647 </span><span class="lineNoCov">          0 :             nonreal_decl_scope-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="14648"><span class="lineNum">   14648 </span><span class="lineNoCov">          0 :             nonreal_decl_scope-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="14649"><span class="lineNum">   14649 </span>            : #if 0</a>
<a name="14650"><span class="lineNum">   14650 </span>            :             printf(&quot;In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(XXX_name = %p): nrscope = %p (new)\n&quot;, XXX_name.str(), nonreal_decl_scope);</a>
<a name="14651"><span class="lineNum">   14651 </span>            : #endif</a>
<a name="14652"><span class="lineNum">   14652 </span>            :           }</a>
<a name="14653"><span class="lineNum">   14653 </span>            : </a>
<a name="14654"><span class="lineNum">   14654 </span>            : #if 1</a>
<a name="14655"><span class="lineNum">   14655 </span>            :        // DQ (9/16/2012): This newly refactored function can only be called after firstNondefiningDeclaration is set.</a>
<a name="14656"><span class="lineNum">   14656 </span>            :        // This also sets the template argument parents to the firstNondefiningDeclaration.</a>
<a name="14657"><span class="lineNum">   14657 </span><span class="lineCov">         98 :           setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);</span></a>
<a name="14658"><span class="lineNum">   14658 </span>            : #else</a>
<a name="14659"><span class="lineNum">   14659 </span>            :        // DQ (9/12/2012): Adding support for template specialization.</a>
<a name="14660"><span class="lineNum">   14660 </span>            :           ROSE_ASSERT(templateSpecializationArgumentList != NULL);</a>
<a name="14661"><span class="lineNum">   14661 </span>            :           nondefdecl-&gt;get_templateSpecializationArguments() = *templateSpecializationArgumentList;</a>
<a name="14662"><span class="lineNum">   14662 </span>            : #endif</a>
<a name="14663"><span class="lineNum">   14663 </span>            :        // DQ (9/10/2012): Test the just built template with its template parameters.</a>
<a name="14664"><span class="lineNum">   14664 </span><span class="lineCov">         98 :           if (nondefdecl-&gt;get_templateParameters().size() == 0)</span></a>
<a name="14665"><span class="lineNum">   14665 </span>            :              {</a>
<a name="14666"><span class="lineNum">   14666 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="14667"><span class="lineNum">   14667 </span>            :                printf (&quot;WARNING: In buildNondefiningTemplateClassDeclaration_nfi(): (part 1) nondefdecl-&gt;get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="14668"><span class="lineNum">   14668 </span>            : #endif</a>
<a name="14669"><span class="lineNum">   14669 </span>            :              }</a>
<a name="14670"><span class="lineNum">   14670 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_templateParameters().size() &gt; 0);</a>
<a name="14671"><span class="lineNum">   14671 </span>            : </a>
<a name="14672"><span class="lineNum">   14672 </span>            :        // DQ (3/7/2012): We want this to be set later, so we can't test it here.</a>
<a name="14673"><span class="lineNum">   14673 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_parent() != NULL);</a>
<a name="14674"><span class="lineNum">   14674 </span>            : #if 0</a>
<a name="14675"><span class="lineNum">   14675 </span>            :           nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="14676"><span class="lineNum">   14676 </span>            : </a>
<a name="14677"><span class="lineNum">   14677 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="14678"><span class="lineNum">   14678 </span>            :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</a>
<a name="14679"><span class="lineNum">   14679 </span>            : #endif</a>
<a name="14680"><span class="lineNum">   14680 </span>            :        // DQ (3/7/2012): But always refer to the first non-defining declaration so it will be unique (and set the scope).</a>
<a name="14681"><span class="lineNum">   14681 </span><span class="lineCov">         98 :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="14682"><span class="lineNum">   14682 </span><span class="lineCov">         98 :           ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != nondefdecl);</span></a>
<a name="14683"><span class="lineNum">   14683 </span><span class="lineCov">         98 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="14684"><span class="lineNum">   14684 </span><span class="lineCov">         98 :           nondefdecl-&gt;setForward();</span></a>
<a name="14685"><span class="lineNum">   14685 </span>            : </a>
<a name="14686"><span class="lineNum">   14686 </span>            :        // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.</a>
<a name="14687"><span class="lineNum">   14687 </span><span class="lineCov">         98 :           nondefdecl-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="14688"><span class="lineNum">   14688 </span>            : </a>
<a name="14689"><span class="lineNum">   14689 </span><span class="lineCov">         98 :           testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14690"><span class="lineNum">   14690 </span>            :         }</a>
<a name="14691"><span class="lineNum">   14691 </span>            :        else // build a nondefnining declaration if it does not exist</a>
<a name="14692"><span class="lineNum">   14692 </span>            :         {</a>
<a name="14693"><span class="lineNum">   14693 </span><span class="lineCov">       1060 :           nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,(SgClassType*)NULL,(SgClassDefinition*)NULL);</span></a>
<a name="14694"><span class="lineNum">   14694 </span><span class="lineCov">       1060 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="14695"><span class="lineNum">   14695 </span>            : </a>
<a name="14696"><span class="lineNum">   14696 </span>            :        // DQ (9/10/2012): Initialize the template parameter list.</a>
<a name="14697"><span class="lineNum">   14697 </span><span class="lineCov">       1060 :           ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="14698"><span class="lineNum">   14698 </span><span class="lineCov">       1060 :           nondefdecl-&gt;get_templateParameters() = *templateParameterList;</span></a>
<a name="14699"><span class="lineNum">   14699 </span>            : </a>
<a name="14700"><span class="lineNum">   14700 </span>            :        // DQ (9/16/2012): Moved this initialization of firstNondefiningDeclaration from farther down in this branch.</a>
<a name="14701"><span class="lineNum">   14701 </span><span class="lineCov">       1060 :           nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="14702"><span class="lineNum">   14702 </span>            : </a>
<a name="14703"><span class="lineNum">   14703 </span>            :        // DQ (9/16/2012): This newly refactored function can only be called after firstNondefiningDeclaration is set.</a>
<a name="14704"><span class="lineNum">   14704 </span>            :        // This also sets the template argument parents to the firstNondefiningDeclaration.</a>
<a name="14705"><span class="lineNum">   14705 </span><span class="lineCov">       1060 :           setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);</span></a>
<a name="14706"><span class="lineNum">   14706 </span>            : </a>
<a name="14707"><span class="lineNum">   14707 </span>            :        // DQ (9/10/2012): Test the just built template with its template parameters.</a>
<a name="14708"><span class="lineNum">   14708 </span><span class="lineCov">       1060 :           if (nondefdecl-&gt;get_templateParameters().size() == 0)</span></a>
<a name="14709"><span class="lineNum">   14709 </span>            :              {</a>
<a name="14710"><span class="lineNum">   14710 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="14711"><span class="lineNum">   14711 </span>            :                printf (&quot;WARNING: In buildNondefiningTemplateClassDeclaration_nfi(): (part 2) nondefdecl-&gt;get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="14712"><span class="lineNum">   14712 </span>            : #endif</a>
<a name="14713"><span class="lineNum">   14713 </span>            :              }</a>
<a name="14714"><span class="lineNum">   14714 </span>            :        // ROSE_ASSERT(nondefdecl-&gt;get_templateParameters().size() &gt; 0);</a>
<a name="14715"><span class="lineNum">   14715 </span>            : </a>
<a name="14716"><span class="lineNum">   14716 </span>            :        // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.</a>
<a name="14717"><span class="lineNum">   14717 </span><span class="lineCov">       1060 :           nondefdecl-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="14718"><span class="lineNum">   14718 </span>            : </a>
<a name="14719"><span class="lineNum">   14719 </span>            : #if 0</a>
<a name="14720"><span class="lineNum">   14720 </span>            :        // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.</a>
<a name="14721"><span class="lineNum">   14721 </span>            :           if (nondefdecl-&gt;get_type() == NULL)</a>
<a name="14722"><span class="lineNum">   14722 </span>            :              {</a>
<a name="14723"><span class="lineNum">   14723 </span>            :             // nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="14724"><span class="lineNum">   14724 </span>            :             // nondefdecl-&gt;set_type(NULL);</a>
<a name="14725"><span class="lineNum">   14725 </span>            :             // nondefdecl-&gt;set_type(SgTemplateType::createType(nondefdecl));</a>
<a name="14726"><span class="lineNum">   14726 </span>            :             // nondefdecl-&gt;set_type(SgTemplateType::createType());</a>
<a name="14727"><span class="lineNum">   14727 </span>            :                nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="14728"><span class="lineNum">   14728 </span>            :                ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</a>
<a name="14729"><span class="lineNum">   14729 </span>            :              }</a>
<a name="14730"><span class="lineNum">   14730 </span>            : #endif</a>
<a name="14731"><span class="lineNum">   14731 </span>            :        // printf (&quot;SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="14732"><span class="lineNum">   14732 </span>            : </a>
<a name="14733"><span class="lineNum">   14733 </span>            :        // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="14734"><span class="lineNum">   14734 </span>            :        // generated (so we have something about the class that we can reference; e.g in</a>
<a name="14735"><span class="lineNum">   14735 </span>            :        // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="14736"><span class="lineNum">   14736 </span>            :        // of source position that would be more precise.  FIXME.</a>
<a name="14737"><span class="lineNum">   14737 </span>            :        // setOneSourcePositionNull(nondefdecl);</a>
<a name="14738"><span class="lineNum">   14738 </span><span class="lineCov">       1060 :           setOneSourcePositionForTransformation(nondefdecl);</span></a>
<a name="14739"><span class="lineNum">   14739 </span><span class="lineCov">       1060 :           ROSE_ASSERT (nondefdecl-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="14740"><span class="lineNum">   14740 </span>            : </a>
<a name="14741"><span class="lineNum">   14741 </span>            :        // nondefdecl-&gt;set_definingDeclaration(defdecl);</a>
<a name="14742"><span class="lineNum">   14742 </span><span class="lineCov">       1060 :           nondefdecl-&gt;setForward();</span></a>
<a name="14743"><span class="lineNum">   14743 </span>            : </a>
<a name="14744"><span class="lineNum">   14744 </span>            :        // Liao, 9/2/2009. scope stack is optional, it can be empty</a>
<a name="14745"><span class="lineNum">   14745 </span>            :        // nondefdecl-&gt;set_parent(topScopeStack());</a>
<a name="14746"><span class="lineNum">   14746 </span>            : #if 0</a>
<a name="14747"><span class="lineNum">   14747 </span>            :           printf (&quot;In buildNondefiningTemplateClassDeclaration_nfi(): Commented out setting the parent to the scope. \n&quot;);</a>
<a name="14748"><span class="lineNum">   14748 </span>            : #endif</a>
<a name="14749"><span class="lineNum">   14749 </span>            :        // printf (&quot;Note that for C++, the parent may not be the same as the scope (dangerous code). \n&quot;);</a>
<a name="14750"><span class="lineNum">   14750 </span>            :        // nondefdecl-&gt;set_parent(scope);</a>
<a name="14751"><span class="lineNum">   14751 </span>            : </a>
<a name="14752"><span class="lineNum">   14752 </span><span class="lineCov">       1060 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="14753"><span class="lineNum">   14753 </span>            : </a>
<a name="14754"><span class="lineNum">   14754 </span>            : #if 1</a>
<a name="14755"><span class="lineNum">   14755 </span>            :        // DQ (12/4/2011): Set the scope first and then set the type (scope is required to compute the type (name mangling)).</a>
<a name="14756"><span class="lineNum">   14756 </span>            :        // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.</a>
<a name="14757"><span class="lineNum">   14757 </span><span class="lineCov">       1060 :           if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="14758"><span class="lineNum">   14758 </span>            :              {</a>
<a name="14759"><span class="lineNum">   14759 </span>            :             // nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</a>
<a name="14760"><span class="lineNum">   14760 </span>            :             // nondefdecl-&gt;set_type(NULL);</a>
<a name="14761"><span class="lineNum">   14761 </span>            :             // nondefdecl-&gt;set_type(SgTemplateType::createType(nondefdecl));</a>
<a name="14762"><span class="lineNum">   14762 </span>            :             // nondefdecl-&gt;set_type(SgTemplateType::createType());</a>
<a name="14763"><span class="lineNum">   14763 </span><span class="lineCov">       1060 :                nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</span></a>
<a name="14764"><span class="lineNum">   14764 </span><span class="lineCov">       1060 :                ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14765"><span class="lineNum">   14765 </span>            : #if 0</a>
<a name="14766"><span class="lineNum">   14766 </span>            :                printf (&quot;In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): built class type: part 1: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="14767"><span class="lineNum">   14767 </span>            : #endif</a>
<a name="14768"><span class="lineNum">   14768 </span>            :              }</a>
<a name="14769"><span class="lineNum">   14769 </span>            : #endif</a>
<a name="14770"><span class="lineNum">   14770 </span>            : </a>
<a name="14771"><span class="lineNum">   14771 </span>            :        // Build a SgTemplateClassSymbol and put it into the specified scope.</a>
<a name="14772"><span class="lineNum">   14772 </span><span class="lineCov">       1060 :           if (scope != NULL)</span></a>
<a name="14773"><span class="lineNum">   14773 </span>            :              {</a>
<a name="14774"><span class="lineNum">   14774 </span>            : #if 0</a>
<a name="14775"><span class="lineNum">   14775 </span>            :                printf (&quot;Building a SgTemplateSymbol using nameWithTemplateSpecializationArguments = %s and nondefdecl = %p = %s \n&quot;,nameWithTemplateSpecializationArguments.str(),nondefdecl,nondefdecl-&gt;class_name().c_str());</a>
<a name="14776"><span class="lineNum">   14776 </span>            : #endif</a>
<a name="14777"><span class="lineNum">   14777 </span>            :             // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.</a>
<a name="14778"><span class="lineNum">   14778 </span>            :             // mysymbol = new SgTemplateSymbol(nondefdecl);</a>
<a name="14779"><span class="lineNum">   14779 </span>            :             // mysymbol = new SgClassSymbol(nondefdecl);</a>
<a name="14780"><span class="lineNum">   14780 </span><span class="lineCov">       1060 :                mysymbol = new SgTemplateClassSymbol(nondefdecl);</span></a>
<a name="14781"><span class="lineNum">   14781 </span><span class="lineCov">       1060 :                ROSE_ASSERT(mysymbol != NULL);</span></a>
<a name="14782"><span class="lineNum">   14782 </span>            : </a>
<a name="14783"><span class="lineNum">   14783 </span>            :             // DQ (9/12/2012): We want to include the template specialization into the name where it is required.</a>
<a name="14784"><span class="lineNum">   14784 </span>            :             // DQ (3/6/2012): Added test for existing symbol (see test2012_18.C).</a>
<a name="14785"><span class="lineNum">   14785 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(name) == NULL);</a>
<a name="14786"><span class="lineNum">   14786 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList) == NULL);</a>
<a name="14787"><span class="lineNum">   14787 </span><span class="lineCov">       1060 :                ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList) == NULL);</span></a>
<a name="14788"><span class="lineNum">   14788 </span>            : </a>
<a name="14789"><span class="lineNum">   14789 </span>            :             // DQ (9/12/2012): We want to include the template specialization into the name where it is required.</a>
<a name="14790"><span class="lineNum">   14790 </span>            :             // scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="14791"><span class="lineNum">   14791 </span><span class="lineCov">       1060 :                scope-&gt;insert_symbol(nameWithTemplateSpecializationArguments, mysymbol);</span></a>
<a name="14792"><span class="lineNum">   14792 </span>            : #if 0</a>
<a name="14793"><span class="lineNum">   14793 </span>            :                printf (&quot;SageBuilder::buildNondefiningTemplateClassDeclaration_nfi() (after building symbol): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="14794"><span class="lineNum">   14794 </span>            : #endif</a>
<a name="14795"><span class="lineNum">   14795 </span><span class="lineCov">       1060 :                ROSE_ASSERT(nondefdecl-&gt;get_scope() != NULL);</span></a>
<a name="14796"><span class="lineNum">   14796 </span>            : </a>
<a name="14797"><span class="lineNum">   14797 </span><span class="lineCov">       1060 :                ROSE_ASSERT(nondefdecl-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="14798"><span class="lineNum">   14798 </span>            : </a>
<a name="14799"><span class="lineNum">   14799 </span>            :             // DQ (9/12/2012): We want to include the template specialization into the name where it is required.</a>
<a name="14800"><span class="lineNum">   14800 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(name) != NULL);</a>
<a name="14801"><span class="lineNum">   14801 </span>            :             // ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList) != NULL);</a>
<a name="14802"><span class="lineNum">   14802 </span><span class="lineCov">       1060 :                ROSE_ASSERT(scope-&gt;lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList) != NULL);</span></a>
<a name="14803"><span class="lineNum">   14803 </span>            :              }</a>
<a name="14804"><span class="lineNum">   14804 </span>            :             else</a>
<a name="14805"><span class="lineNum">   14805 </span>            :              {</a>
<a name="14806"><span class="lineNum">   14806 </span>            :             // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unknown.</a>
<a name="14807"><span class="lineNum">   14807 </span>            :              }</a>
<a name="14808"><span class="lineNum">   14808 </span>            : </a>
<a name="14809"><span class="lineNum">   14809 </span><span class="lineCov">       1060 :           testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14810"><span class="lineNum">   14810 </span>            : </a>
<a name="14811"><span class="lineNum">   14811 </span>            : #if 1</a>
<a name="14812"><span class="lineNum">   14812 </span>            :        // DQ (7/16/2017): Added code to set the template parameters in the just build declaration (if it is a template declaration).</a>
<a name="14813"><span class="lineNum">   14813 </span>            :        // We want to set the parents of the template paremters to the frst nondefining template class declaration, and we want to reset</a>
<a name="14814"><span class="lineNum">   14814 </span>            :        // the scope of the declarations associated with any previously marked SgClassType objects associated with any template parameters.</a>
<a name="14815"><span class="lineNum">   14815 </span>            :        // printf (&quot;SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): Calling setTemplateParametersInDeclaration(): nameWithTemplateSpecializationArguments = %s \n&quot;,nameWithTemplateSpecializationArguments.str());</a>
<a name="14816"><span class="lineNum">   14816 </span>            : </a>
<a name="14817"><span class="lineNum">   14817 </span><span class="lineCov">       1060 :           setTemplateParametersInDeclaration(nondefdecl,templateParameterList);</span></a>
<a name="14818"><span class="lineNum">   14818 </span>            : </a>
<a name="14819"><span class="lineNum">   14819 </span>            :        // DQ (8/13/2013): Adding test of template parameter lists.</a>
<a name="14820"><span class="lineNum">   14820 </span><span class="lineCov">       1060 :           SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(nondefdecl);</span></a>
<a name="14821"><span class="lineNum">   14821 </span><span class="lineCov">       1060 :           ROSE_ASSERT(templateClassDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateClassDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="14822"><span class="lineNum">   14822 </span>            : #endif</a>
<a name="14823"><span class="lineNum">   14823 </span>            :         }</a>
<a name="14824"><span class="lineNum">   14824 </span>            : </a>
<a name="14825"><span class="lineNum">   14825 </span>            :   // defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="14826"><span class="lineNum">   14826 </span>            : </a>
<a name="14827"><span class="lineNum">   14827 </span>            :   // DQ (11/3/2012): Setup the default source position information.</a>
<a name="14828"><span class="lineNum">   14828 </span><span class="lineCov">       1158 :      setSourcePosition(nondefdecl);</span></a>
<a name="14829"><span class="lineNum">   14829 </span>            : </a>
<a name="14830"><span class="lineNum">   14830 </span>            : #if 0</a>
<a name="14831"><span class="lineNum">   14831 </span>            :   // DQ (11/20/2011): SgTemplateClassDeclaration IR nodes don't have a SgType associated with them (template declarations don't have a type in C++, I think).</a>
<a name="14832"><span class="lineNum">   14832 </span>            : </a>
<a name="14833"><span class="lineNum">   14833 </span>            :   // Liao, 10/30/2009</a>
<a name="14834"><span class="lineNum">   14834 </span>            :   // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType</a>
<a name="14835"><span class="lineNum">   14835 </span>            :   // This is not desired when building a defining declaration and an inefficience in the constructor</a>
<a name="14836"><span class="lineNum">   14836 </span>            :   // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and</a>
<a name="14837"><span class="lineNum">   14837 </span>            :   // the defining class declaration (and other nondefining declaration) just shared that SgClassType.</a>
<a name="14838"><span class="lineNum">   14838 </span>            :      if (defdecl-&gt;get_type() != NULL)</a>
<a name="14839"><span class="lineNum">   14839 </span>            :         {</a>
<a name="14840"><span class="lineNum">   14840 </span>            :        // if a defining class declaration's type is associated with a defining class.</a>
<a name="14841"><span class="lineNum">   14841 </span>            :        // This is a wrong SgClassType and has to be reset</a>
<a name="14842"><span class="lineNum">   14842 </span>            :           if (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl) )</a>
<a name="14843"><span class="lineNum">   14843 </span>            :              {</a>
<a name="14844"><span class="lineNum">   14844 </span>            :                delete defdecl-&gt;get_type();</a>
<a name="14845"><span class="lineNum">   14845 </span>            :              }</a>
<a name="14846"><span class="lineNum">   14846 </span>            :         }</a>
<a name="14847"><span class="lineNum">   14847 </span>            : </a>
<a name="14848"><span class="lineNum">   14848 </span>            :   // patch up the SgClassType for the defining class declaration</a>
<a name="14849"><span class="lineNum">   14849 </span>            :      ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</a>
<a name="14850"><span class="lineNum">   14850 </span>            :      ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="14851"><span class="lineNum">   14851 </span>            :      defdecl-&gt;set_type(nondefdecl-&gt;get_type());</a>
<a name="14852"><span class="lineNum">   14852 </span>            : #else</a>
<a name="14853"><span class="lineNum">   14853 </span>            :   // printf (&quot;We might need to force the types used for defining and non-defining SgTemplateClassDeclaration to be the same! \n&quot;);</a>
<a name="14854"><span class="lineNum">   14854 </span><span class="lineCov">       1158 :      ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14855"><span class="lineNum">   14855 </span>            : #endif</a>
<a name="14856"><span class="lineNum">   14856 </span>            : </a>
<a name="14857"><span class="lineNum">   14857 </span>            :   // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).</a>
<a name="14858"><span class="lineNum">   14858 </span>            :   // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless</a>
<a name="14859"><span class="lineNum">   14859 </span>            :   // used in a defining declaration).</a>
<a name="14860"><span class="lineNum">   14860 </span><span class="lineCov">       1158 :      nondefdecl-&gt;setForward();</span></a>
<a name="14861"><span class="lineNum">   14861 </span>            : </a>
<a name="14862"><span class="lineNum">   14862 </span><span class="lineCov">       1158 :      if (scope != NULL)  // put into fixStructDeclaration() or alike later on</span></a>
<a name="14863"><span class="lineNum">   14863 </span>            :         {</a>
<a name="14864"><span class="lineNum">   14864 </span>            :        // fixStructDeclaration(defdecl,scope);</a>
<a name="14865"><span class="lineNum">   14865 </span>            :        // fixStructDeclaration(nondefdecl,scope);</a>
<a name="14866"><span class="lineNum">   14866 </span>            : </a>
<a name="14867"><span class="lineNum">   14867 </span>            :        // printf (&quot;***** WARNING *****: Commented out call to fixStructDeclaration() \n&quot;);</a>
<a name="14868"><span class="lineNum">   14868 </span>            :        // ROSE_ASSERT(false);</a>
<a name="14869"><span class="lineNum">   14869 </span>            :         }</a>
<a name="14870"><span class="lineNum">   14870 </span>            : </a>
<a name="14871"><span class="lineNum">   14871 </span>            : #if 0</a>
<a name="14872"><span class="lineNum">   14872 </span>            :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == defdecl);</a>
<a name="14873"><span class="lineNum">   14873 </span>            :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != defdecl-&gt;get_definingDeclaration());</a>
<a name="14874"><span class="lineNum">   14874 </span>            : </a>
<a name="14875"><span class="lineNum">   14875 </span>            :      ROSE_ASSERT(defdecl-&gt;get_scope() != NULL);</a>
<a name="14876"><span class="lineNum">   14876 </span>            : #endif</a>
<a name="14877"><span class="lineNum">   14877 </span>            : </a>
<a name="14878"><span class="lineNum">   14878 </span>            :   // DQ (7/15/2012): We want to enforce this to not be set yet (might be part of non-autonomous declaration (e.g. nested in a typedef).</a>
<a name="14879"><span class="lineNum">   14879 </span><span class="lineCov">       1158 :      ROSE_ASSERT(nondefdecl-&gt;get_parent() == NULL);</span></a>
<a name="14880"><span class="lineNum">   14880 </span>            : </a>
<a name="14881"><span class="lineNum">   14881 </span>            :   // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).</a>
<a name="14882"><span class="lineNum">   14882 </span><span class="lineCov">       1158 :      ROSE_ASSERT(nondefdecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="14883"><span class="lineNum">   14883 </span>            : </a>
<a name="14884"><span class="lineNum">   14884 </span><span class="lineCov">       1158 :      testTemplateArgumentParents(nondefdecl);</span></a>
<a name="14885"><span class="lineNum">   14885 </span>            : </a>
<a name="14886"><span class="lineNum">   14886 </span>            : #if 0</a>
<a name="14887"><span class="lineNum">   14887 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="14888"><span class="lineNum">   14888 </span>            :      printf (&quot;Leaving buildNondefiningTemplateClassDeclaration_nfi(): Calling find_symbol_from_declaration() \n&quot;);</a>
<a name="14889"><span class="lineNum">   14889 </span>            :      SgClassDeclaration* tmp_classDeclaration = nondefdecl;</a>
<a name="14890"><span class="lineNum">   14890 </span>            :      SgSymbol* test_symbol = nondefdecl-&gt;get_scope()-&gt;find_symbol_from_declaration(tmp_classDeclaration);</a>
<a name="14891"><span class="lineNum">   14891 </span>            : </a>
<a name="14892"><span class="lineNum">   14892 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="14893"><span class="lineNum">   14893 </span>            :      printf (&quot;Leaving buildNondefiningTemplateClassDeclaration_nfi(): Calling get_symbol_from_symbol_table() \n&quot;);</a>
<a name="14894"><span class="lineNum">   14894 </span>            :      ROSE_ASSERT(nondefdecl-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="14895"><span class="lineNum">   14895 </span>            : #endif</a>
<a name="14896"><span class="lineNum">   14896 </span>            : </a>
<a name="14897"><span class="lineNum">   14897 </span><span class="lineCov">       2316 :      return nondefdecl;</span></a>
<a name="14898"><span class="lineNum">   14898 </span>            :    }</a>
<a name="14899"><span class="lineNum">   14899 </span>            : </a>
<a name="14900"><span class="lineNum">   14900 </span>            : SgTemplateClassDeclaration *</a>
<a name="14901"><span class="lineNum">   14901 </span><span class="lineCov">          1 : SageBuilder::buildTemplateClassDeclaration(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl,</span></a>
<a name="14902"><span class="lineNum">   14902 </span>            :                                                SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )</a>
<a name="14903"><span class="lineNum">   14903 </span>            : {</a>
<a name="14904"><span class="lineNum">   14904 </span><span class="lineCov">          1 :   SgTemplateClassDeclaration * res = buildTemplateClassDeclaration_nfi (XXX_name, kind, scope, nonDefiningDecl, templateParameterList, templateSpecializationArgumentList);</span></a>
<a name="14905"><span class="lineNum">   14905 </span><span class="lineCov">          1 :   setSourcePositionForTransformation (res);</span></a>
<a name="14906"><span class="lineNum">   14906 </span><span class="lineCov">          1 :   return res;</span></a>
<a name="14907"><span class="lineNum">   14907 </span>            : }</a>
<a name="14908"><span class="lineNum">   14908 </span>            : </a>
<a name="14909"><span class="lineNum">   14909 </span>            : SgTemplateClassDeclaration *</a>
<a name="14910"><span class="lineNum">   14910 </span><span class="lineCov">       4922 : SageBuilder::buildTemplateClassDeclaration_nfi(const SgName&amp; XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl,</span></a>
<a name="14911"><span class="lineNum">   14911 </span>            :                                                SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )</a>
<a name="14912"><span class="lineNum">   14912 </span>            :    {</a>
<a name="14913"><span class="lineNum">   14913 </span>            :   // DQ (12/26/2011): Notes that the input nonDefiningDecl is not used...this is a confusing point.</a>
<a name="14914"><span class="lineNum">   14914 </span>            :   // The specification of the scope appears to be enough.</a>
<a name="14915"><span class="lineNum">   14915 </span>            : </a>
<a name="14916"><span class="lineNum">   14916 </span><span class="lineCov">       4922 :      if (scope == NULL)</span></a>
<a name="14917"><span class="lineNum">   14917 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="14918"><span class="lineNum">   14918 </span>            : </a>
<a name="14919"><span class="lineNum">   14919 </span>            : #if 0</a>
<a name="14920"><span class="lineNum">   14920 </span>            :      printf (&quot;In buildTemplateClassDeclaration_nfi(): nonDefiningDecl = %p \n&quot;,nonDefiningDecl);</a>
<a name="14921"><span class="lineNum">   14921 </span>            :      if (nonDefiningDecl != NULL)</a>
<a name="14922"><span class="lineNum">   14922 </span>            :         {</a>
<a name="14923"><span class="lineNum">   14923 </span>            :           printf (&quot;--- nonDefiningDecl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,nonDefiningDecl-&gt;get_firstNondefiningDeclaration());</a>
<a name="14924"><span class="lineNum">   14924 </span>            :           printf (&quot;--- nonDefiningDecl-&gt;get_definingDeclaration()         = %p \n&quot;,nonDefiningDecl-&gt;get_definingDeclaration());</a>
<a name="14925"><span class="lineNum">   14925 </span>            :         }</a>
<a name="14926"><span class="lineNum">   14926 </span>            : #endif</a>
<a name="14927"><span class="lineNum">   14927 </span>            : </a>
<a name="14928"><span class="lineNum">   14928 </span>            :   // DQ (11/20/2011): This is for initial debugging only.</a>
<a name="14929"><span class="lineNum">   14929 </span><span class="lineCov">       4922 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="14930"><span class="lineNum">   14930 </span>            : </a>
<a name="14931"><span class="lineNum">   14931 </span>            :   // DQ (9/12/2012): We want to add the template arguments of any specialization to the template name and keep track of the name with and without template specialization arguments.</a>
<a name="14932"><span class="lineNum">   14932 </span><span class="lineCov">       9844 :      SgName nameWithoutTemplateArguments            = XXX_name;</span></a>
<a name="14933"><span class="lineNum">   14933 </span><span class="lineCov">       9844 :      SgName nameWithTemplateSpecializationArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateSpecializationArgumentList);</span></a>
<a name="14934"><span class="lineNum">   14934 </span>            : </a>
<a name="14935"><span class="lineNum">   14935 </span>            :   // step 1. Build defining declaration</a>
<a name="14936"><span class="lineNum">   14936 </span>            :   // Note that even the SgTemplateClassDeclaration uses a regular SgClassDefinition instead of the currently unused SgTemplateClassDefinition.</a>
<a name="14937"><span class="lineNum">   14937 </span>            :   // SgClassDefinition* classDef = buildClassDefinition();</a>
<a name="14938"><span class="lineNum">   14938 </span>            :   // SgTemplateClassDefinition* classDef = buildTemplateClassDefinition(name,);</a>
<a name="14939"><span class="lineNum">   14939 </span>            : </a>
<a name="14940"><span class="lineNum">   14940 </span>            :   // DQ (11/29/2011): Added checks...</a>
<a name="14941"><span class="lineNum">   14941 </span><span class="lineCov">       4922 :      if (nonDefiningDecl != NULL)</span></a>
<a name="14942"><span class="lineNum">   14942 </span>            :         {</a>
<a name="14943"><span class="lineNum">   14943 </span><span class="lineCov">        444 :           ROSE_ASSERT(nonDefiningDecl-&gt;get_firstNondefiningDeclaration() == nonDefiningDecl);</span></a>
<a name="14944"><span class="lineNum">   14944 </span>            :         }</a>
<a name="14945"><span class="lineNum">   14945 </span>            : </a>
<a name="14946"><span class="lineNum">   14946 </span><span class="lineCov">       4922 :      SgName templateString = &quot;template string&quot;;</span></a>
<a name="14947"><span class="lineNum">   14947 </span>            :   // SgTemplateDeclaration::template_type_enum template_kind = SgTemplateDeclaration::e_template_class;</a>
<a name="14948"><span class="lineNum">   14948 </span><span class="lineCov">       9844 :      SgTemplateParameterPtrList templateParameters;</span></a>
<a name="14949"><span class="lineNum">   14949 </span>            : </a>
<a name="14950"><span class="lineNum">   14950 </span>            :   // SgTemplateDeclaration (SgName name, SgName string, SgTemplateDeclaration::template_type_enum template_kind, SgTemplateParameterPtrList templateParameters)</a>
<a name="14951"><span class="lineNum">   14951 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,kind,NULL,classDef);</a>
<a name="14952"><span class="lineNum">   14952 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters);</a>
<a name="14953"><span class="lineNum">   14953 </span>            : </a>
<a name="14954"><span class="lineNum">   14954 </span>            :   // SgTemplateClassDeclaration::class_types template_class_kind = SgTemplateClassDeclaration::e_class;</a>
<a name="14955"><span class="lineNum">   14955 </span>            :   // SgTemplateType*            classType = NULL;</a>
<a name="14956"><span class="lineNum">   14956 </span>            :   // SgTemplateClassDefinition* classDef  = NULL;</a>
<a name="14957"><span class="lineNum">   14957 </span><span class="lineCov">       4922 :      SgTemplateClassDefinition* classDef = buildTemplateClassDefinition();</span></a>
<a name="14958"><span class="lineNum">   14958 </span>            : </a>
<a name="14959"><span class="lineNum">   14959 </span>            :   // Constructure arguments: SgName, SgName, SgTemplateDeclaration::template_type_enum, SgTemplateParameterPtrList, SgTemplateClassDeclaration::class_types, SgClassType*, SgTemplateClassDefinition*</a>
<a name="14960"><span class="lineNum">   14960 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters);</a>
<a name="14961"><span class="lineNum">   14961 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,template_class_kind,classType,classDef);</a>
<a name="14962"><span class="lineNum">   14962 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,template_class_kind,classDef);</a>
<a name="14963"><span class="lineNum">   14963 </span>            : </a>
<a name="14964"><span class="lineNum">   14964 </span>            : #if 0</a>
<a name="14965"><span class="lineNum">   14965 </span>            :      printf (&quot;In buildTemplateClassDeclaration_nfi(): calling new SgTemplateClassDeclaration() name = %s \n&quot;,nameWithTemplateSpecializationArguments.str());</a>
<a name="14966"><span class="lineNum">   14966 </span>            : #endif</a>
<a name="14967"><span class="lineNum">   14967 </span>            : </a>
<a name="14968"><span class="lineNum">   14968 </span>            :   // DQ (9/12/2012): We want to include the template specialization into the name where it is required (this handling</a>
<a name="14969"><span class="lineNum">   14969 </span>            :   // is similar to normal template arguments for non-template declaration, but different than template parameters).</a>
<a name="14970"><span class="lineNum">   14970 </span>            :   // This copy of SgName is required to support passing it to the SgTemplateClassDeclaration constructor.</a>
<a name="14971"><span class="lineNum">   14971 </span>            :   // SgName localName = name;</a>
<a name="14972"><span class="lineNum">   14972 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,template_class_kind,classDef);</a>
<a name="14973"><span class="lineNum">   14973 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,kind,NULL,classDef);</a>
<a name="14974"><span class="lineNum">   14974 </span>            : </a>
<a name="14975"><span class="lineNum">   14975 </span>            :   // DQ (1/13/2013): This is causing two defining declarations to be built for test2012_278.C (and the parent for the second defining</a>
<a name="14976"><span class="lineNum">   14976 </span>            :   // declaration is not being set, though the larger issue is that we have two defining declarations, however this might be acceptable</a>
<a name="14977"><span class="lineNum">   14977 </span>            :   // if this is a specialization).</a>
<a name="14978"><span class="lineNum">   14978 </span>            :   // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (nameWithTemplateSpecializationArguments,kind,NULL,classDef);</a>
<a name="14979"><span class="lineNum">   14979 </span><span class="lineCov">       4922 :      SgTemplateClassDeclaration* defdecl = NULL;</span></a>
<a name="14980"><span class="lineNum">   14980 </span><span class="lineCov">       4922 :      if (nonDefiningDecl != NULL)</span></a>
<a name="14981"><span class="lineNum">   14981 </span>            :         {</a>
<a name="14982"><span class="lineNum">   14982 </span>            :        // If we have a non-defining declaration specified, try to use any existing defining declaration withouth building a 2nd one</a>
<a name="14983"><span class="lineNum">   14983 </span>            :        // (which would be an error, unless maybe if this is a specialization).</a>
<a name="14984"><span class="lineNum">   14984 </span><span class="lineCov">        444 :           if (nonDefiningDecl-&gt;get_definingDeclaration() != NULL)</span></a>
<a name="14985"><span class="lineNum">   14985 </span>            :              {</a>
<a name="14986"><span class="lineNum">   14986 </span>            :             // This must be a valid SgTemplateClassDefinition.</a>
<a name="14987"><span class="lineNum">   14987 </span><span class="lineNoCov">          0 :                defdecl = isSgTemplateClassDeclaration(nonDefiningDecl-&gt;get_definingDeclaration());</span></a>
<a name="14988"><span class="lineNum">   14988 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="14989"><span class="lineNum">   14989 </span>            : #if 0</a>
<a name="14990"><span class="lineNum">   14990 </span>            :                printf (&quot;In buildTemplateClassDeclaration_nfi(): Reusing the defining declaration previously build: defdecl = %p = %s \n&quot;,defdecl,defdecl-&gt;get_name().str());</a>
<a name="14991"><span class="lineNum">   14991 </span>            : #endif</a>
<a name="14992"><span class="lineNum">   14992 </span>            :              }</a>
<a name="14993"><span class="lineNum">   14993 </span>            :             else</a>
<a name="14994"><span class="lineNum">   14994 </span>            :              {</a>
<a name="14995"><span class="lineNum">   14995 </span>            : #if 0</a>
<a name="14996"><span class="lineNum">   14996 </span>            :                printf (&quot;In buildTemplateClassDeclaration_nfi(): No defining declaration found, so we have to build one. \n&quot;);</a>
<a name="14997"><span class="lineNum">   14997 </span>            : #endif</a>
<a name="14998"><span class="lineNum">   14998 </span>            :              }</a>
<a name="14999"><span class="lineNum">   14999 </span>            :         }</a>
<a name="15000"><span class="lineNum">   15000 </span>            : </a>
<a name="15001"><span class="lineNum">   15001 </span><span class="lineNoCov">          0 :      if (defdecl == NULL)</span></a>
<a name="15002"><span class="lineNum">   15002 </span>            :         {</a>
<a name="15003"><span class="lineNum">   15003 </span>            : #if 0</a>
<a name="15004"><span class="lineNum">   15004 </span>            :           printf (&quot;Building a defining declaration \n&quot;);</a>
<a name="15005"><span class="lineNum">   15005 </span>            : #endif</a>
<a name="15006"><span class="lineNum">   15006 </span><span class="lineCov">       4922 :           defdecl = new SgTemplateClassDeclaration (nameWithTemplateSpecializationArguments,kind,NULL,classDef);</span></a>
<a name="15007"><span class="lineNum">   15007 </span>            :         }</a>
<a name="15008"><span class="lineNum">   15008 </span>            : </a>
<a name="15009"><span class="lineNum">   15009 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl != NULL);</span></a>
<a name="15010"><span class="lineNum">   15010 </span>            : </a>
<a name="15011"><span class="lineNum">   15011 </span>            : #if 0</a>
<a name="15012"><span class="lineNum">   15012 </span>            :      printf (&quot;In buildTemplateClassDeclaration_nfi(): defdecl = %p = %s \n&quot;,defdecl,defdecl-&gt;class_name().c_str());</a>
<a name="15013"><span class="lineNum">   15013 </span>            : #endif</a>
<a name="15014"><span class="lineNum">   15014 </span>            : </a>
<a name="15015"><span class="lineNum">   15015 </span>            :   // DQ (9/10/2012): Initialize the template parameter list.</a>
<a name="15016"><span class="lineNum">   15016 </span><span class="lineCov">       4922 :      ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="15017"><span class="lineNum">   15017 </span><span class="lineCov">       4922 :      defdecl-&gt;get_templateParameters() = *templateParameterList;</span></a>
<a name="15018"><span class="lineNum">   15018 </span>            : </a>
<a name="15019"><span class="lineNum">   15019 </span>            :   // DQ (9/12/2012): Adding support for template specialization.</a>
<a name="15020"><span class="lineNum">   15020 </span><span class="lineCov">       4922 :      ROSE_ASSERT(templateSpecializationArgumentList != NULL);</span></a>
<a name="15021"><span class="lineNum">   15021 </span><span class="lineCov">       4922 :      defdecl-&gt;get_templateSpecializationArguments() = *templateSpecializationArgumentList;</span></a>
<a name="15022"><span class="lineNum">   15022 </span>            : </a>
<a name="15023"><span class="lineNum">   15023 </span>            :   // DQ (9/16/2012): We can't test this yet, since the firstNondefiningDeclaration has not be set.</a>
<a name="15024"><span class="lineNum">   15024 </span>            :   // testTemplateArgumentParents(defdecl);</a>
<a name="15025"><span class="lineNum">   15025 </span>            : </a>
<a name="15026"><span class="lineNum">   15026 </span>            :   // DQ (9/10/2012): Test the just built template with its template parameters.</a>
<a name="15027"><span class="lineNum">   15027 </span><span class="lineCov">       4922 :      if (defdecl-&gt;get_templateParameters().size() == 0)</span></a>
<a name="15028"><span class="lineNum">   15028 </span>            :         {</a>
<a name="15029"><span class="lineNum">   15029 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="15030"><span class="lineNum">   15030 </span>            :           printf (&quot;WARNING: In buildTemplateClassDeclaration_nfi(): defdecl-&gt;get_templateParameters().size() == 0: OK for nested classes/structs in template declarations defdecl = %p \n&quot;,defdecl);</a>
<a name="15031"><span class="lineNum">   15031 </span>            : #endif</a>
<a name="15032"><span class="lineNum">   15032 </span>            :         }</a>
<a name="15033"><span class="lineNum">   15033 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_templateParameters().size() &gt; 0);</a>
<a name="15034"><span class="lineNum">   15034 </span>            : </a>
<a name="15035"><span class="lineNum">   15035 </span>            :   // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.</a>
<a name="15036"><span class="lineNum">   15036 </span><span class="lineCov">       4922 :      defdecl-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="15037"><span class="lineNum">   15037 </span>            : </a>
<a name="15038"><span class="lineNum">   15038 </span>            : #if 0</a>
<a name="15039"><span class="lineNum">   15039 </span>            :      printf (&quot;SageBuilder::buildTemplateClassDeclaration_nfi(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="15040"><span class="lineNum">   15040 </span>            : #endif</a>
<a name="15041"><span class="lineNum">   15041 </span>            : </a>
<a name="15042"><span class="lineNum">   15042 </span><span class="lineCov">       4922 :      defdecl-&gt;set_scope(scope);</span></a>
<a name="15043"><span class="lineNum">   15043 </span>            : </a>
<a name="15044"><span class="lineNum">   15044 </span>            :   // DQ (7/15/2012): To support non-autonomous declarations (declarations nested in types) we don't want to set the parent here.  It will be set later.</a>
<a name="15045"><span class="lineNum">   15045 </span>            :   // DQ (11/20/2011): Can name qualification make this incorrect?</a>
<a name="15046"><span class="lineNum">   15046 </span>            :   // defdecl-&gt;set_parent(scope);</a>
<a name="15047"><span class="lineNum">   15047 </span>            : </a>
<a name="15048"><span class="lineNum">   15048 </span><span class="lineCov">       4922 :      ROSE_ASSERT(classDef != NULL);</span></a>
<a name="15049"><span class="lineNum">   15049 </span>            : </a>
<a name="15050"><span class="lineNum">   15050 </span>            :   // printf (&quot;SageBuilder::buildTemplateClassDeclaration_nfi(): defdecl = %p \n&quot;,defdecl);</a>
<a name="15051"><span class="lineNum">   15051 </span>            : </a>
<a name="15052"><span class="lineNum">   15052 </span><span class="lineCov">       4922 :      setOneSourcePositionForTransformation(defdecl);</span></a>
<a name="15053"><span class="lineNum">   15053 </span>            : </a>
<a name="15054"><span class="lineNum">   15054 </span>            :   // constructor is side-effect free</a>
<a name="15055"><span class="lineNum">   15055 </span><span class="lineCov">       4922 :      classDef-&gt;set_declaration(defdecl);</span></a>
<a name="15056"><span class="lineNum">   15056 </span><span class="lineCov">       4922 :      defdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15057"><span class="lineNum">   15057 </span>            : </a>
<a name="15058"><span class="lineNum">   15058 </span>            :   // Step 2. build the nondefining declaration,</a>
<a name="15059"><span class="lineNum">   15059 </span>            :   // but only if the input nonDefiningDecl pointer was NULL and it does not exist</a>
<a name="15060"><span class="lineNum">   15060 </span>            : </a>
<a name="15061"><span class="lineNum">   15061 </span>            :   // Get the nondefining declaration from the symbol if it has been built (if this works,</a>
<a name="15062"><span class="lineNum">   15062 </span>            :   // then we likely don't need the &quot;SgClassDeclaration* nonDefiningDecl&quot; parameter).</a>
<a name="15063"><span class="lineNum">   15063 </span><span class="lineCov">       4922 :      SgTemplateClassDeclaration* nondefdecl = nonDefiningDecl;</span></a>
<a name="15064"><span class="lineNum">   15064 </span><span class="lineCov">       4922 :      if (nondefdecl == NULL) {</span></a>
<a name="15065"><span class="lineNum">   15065 </span><span class="lineCov">       4478 :        ROSE_ASSERT(scope != NULL);</span></a>
<a name="15066"><span class="lineNum">   15066 </span>            : </a>
<a name="15067"><span class="lineNum">   15067 </span><span class="lineCov">       4478 :        SgClassSymbol* mysymbol = scope-&gt;lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList);</span></a>
<a name="15068"><span class="lineNum">   15068 </span>            : #if 0</a>
<a name="15069"><span class="lineNum">   15069 </span>            :        printf (&quot;In buildTemplateClassDeclaration_nfi(): mysymbol = %p \n&quot;,mysymbol);</a>
<a name="15070"><span class="lineNum">   15070 </span>            : #endif</a>
<a name="15071"><span class="lineNum">   15071 </span>            : </a>
<a name="15072"><span class="lineNum">   15072 </span><span class="lineCov">       4478 :        if (mysymbol != NULL) {</span></a>
<a name="15073"><span class="lineNum">   15073 </span><span class="lineNoCov">          0 :          nondefdecl = isSgTemplateClassDeclaration(mysymbol-&gt;get_declaration());</span></a>
<a name="15074"><span class="lineNum">   15074 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="15075"><span class="lineNum">   15075 </span>            : </a>
<a name="15076"><span class="lineNum">   15076 </span><span class="lineNoCov">          0 :          nondefdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15077"><span class="lineNum">   15077 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="15078"><span class="lineNum">   15078 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != defdecl);</span></a>
<a name="15079"><span class="lineNum">   15079 </span>            : </a>
<a name="15080"><span class="lineNum">   15080 </span>            :       // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).</a>
<a name="15081"><span class="lineNum">   15081 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(nondefdecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="15082"><span class="lineNum">   15082 </span>            : </a>
<a name="15083"><span class="lineNum">   15083 </span>            :       // DQ (9/16/2012): Test this previously setup firstNondefiningDeclaration.</a>
<a name="15084"><span class="lineNum">   15084 </span><span class="lineNoCov">          0 :          ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() == nondefdecl);</span></a>
<a name="15085"><span class="lineNum">   15085 </span><span class="lineNoCov">          0 :          testTemplateArgumentParents(nondefdecl);</span></a>
<a name="15086"><span class="lineNum">   15086 </span>            :        } else {</a>
<a name="15087"><span class="lineNum">   15087 </span>            : #if 0</a>
<a name="15088"><span class="lineNum">   15088 </span>            :          printf(&quot;  start build non-defn decl for %p\n&quot;,defdecl);</a>
<a name="15089"><span class="lineNum">   15089 </span>            : #endif</a>
<a name="15090"><span class="lineNum">   15090 </span>            :       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.</a>
<a name="15091"><span class="lineNum">   15091 </span><span class="lineCov">       4478 :          nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,NULL,NULL);</span></a>
<a name="15092"><span class="lineNum">   15092 </span><span class="lineCov">       4478 :          ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="15093"><span class="lineNum">   15093 </span>            : </a>
<a name="15094"><span class="lineNum">   15094 </span><span class="lineCov">       4478 :          nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="15095"><span class="lineNum">   15095 </span><span class="lineCov">       4478 :          nondefdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15096"><span class="lineNum">   15096 </span>            : #if 0</a>
<a name="15097"><span class="lineNum">   15097 </span>            :          printf(&quot;  nondefdecl = %p\n&quot;,nondefdecl);</a>
<a name="15098"><span class="lineNum">   15098 </span>            : #endif</a>
<a name="15099"><span class="lineNum">   15099 </span>            : #if 0</a>
<a name="15100"><span class="lineNum">   15100 </span>            :       // TV (04/12/2018): Add a scope for nonreal classes (and their member) on the first non-defining declaration of template classes</a>
<a name="15101"><span class="lineNum">   15101 </span>            :          SgDeclarationScope * nonreal_decl_scope = new SgDeclarationScope();</a>
<a name="15102"><span class="lineNum">   15102 </span>            : </a>
<a name="15103"><span class="lineNum">   15103 </span>            :          nonreal_decl_scope-&gt;set_parent(nondefdecl);</a>
<a name="15104"><span class="lineNum">   15104 </span>            :          nondefdecl-&gt;set_nonreal_decl_scope(nonreal_decl_scope);</a>
<a name="15105"><span class="lineNum">   15105 </span>            : </a>
<a name="15106"><span class="lineNum">   15106 </span>            :          SageInterface::setSourcePosition(nonreal_decl_scope);</a>
<a name="15107"><span class="lineNum">   15107 </span>            :          nonreal_decl_scope-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</a>
<a name="15108"><span class="lineNum">   15108 </span>            :          nonreal_decl_scope-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</a>
<a name="15109"><span class="lineNum">   15109 </span>            : #if 1</a>
<a name="15110"><span class="lineNum">   15110 </span>            :          printf(&quot;In buildTemplateClassDeclaration_nfi(): nrscope = %p\n&quot;, nonreal_decl_scope);</a>
<a name="15111"><span class="lineNum">   15111 </span>            : #endif</a>
<a name="15112"><span class="lineNum">   15112 </span>            : #endif</a>
<a name="15113"><span class="lineNum">   15113 </span>            :       // DQ (9/10/2012): Initialize the template parameter list.</a>
<a name="15114"><span class="lineNum">   15114 </span><span class="lineCov">       4478 :          ROSE_ASSERT(templateParameterList != NULL);</span></a>
<a name="15115"><span class="lineNum">   15115 </span><span class="lineCov">       4478 :          nondefdecl-&gt;get_templateParameters() = *templateParameterList;</span></a>
<a name="15116"><span class="lineNum">   15116 </span>            : </a>
<a name="15117"><span class="lineNum">   15117 </span>            :       // DQ (9/16/2012): Newly refactored code.</a>
<a name="15118"><span class="lineNum">   15118 </span><span class="lineCov">       4478 :          setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);</span></a>
<a name="15119"><span class="lineNum">   15119 </span><span class="lineCov">       4478 :          testTemplateArgumentParents(nondefdecl);</span></a>
<a name="15120"><span class="lineNum">   15120 </span>            : </a>
<a name="15121"><span class="lineNum">   15121 </span>            :       // DQ (9/10/2012): Test the just built template with its template parameters.</a>
<a name="15122"><span class="lineNum">   15122 </span>            :       // ROSE_ASSERT(nondefdecl-&gt;get_templateParameters().size() &gt; 0);</a>
<a name="15123"><span class="lineNum">   15123 </span><span class="lineCov">       4478 :          if (nondefdecl-&gt;get_templateParameters().size() == 0)</span></a>
<a name="15124"><span class="lineNum">   15124 </span>            :             {</a>
<a name="15125"><span class="lineNum">   15125 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="15126"><span class="lineNum">   15126 </span>            :               printf (&quot;WARNING: In buildTemplateClassDeclaration_nfi(): nondefdecl-&gt;get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="15127"><span class="lineNum">   15127 </span>            : #endif</a>
<a name="15128"><span class="lineNum">   15128 </span>            :             }</a>
<a name="15129"><span class="lineNum">   15129 </span>            :       // ROSE_ASSERT(nondefdecl-&gt;get_templateParameters().size() &gt; 0);</a>
<a name="15130"><span class="lineNum">   15130 </span>            : #if 0</a>
<a name="15131"><span class="lineNum">   15131 </span>            :          printf(&quot;  next 1\n&quot;);</a>
<a name="15132"><span class="lineNum">   15132 </span>            : #endif</a>
<a name="15133"><span class="lineNum">   15133 </span>            : </a>
<a name="15134"><span class="lineNum">   15134 </span>            :       // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.</a>
<a name="15135"><span class="lineNum">   15135 </span><span class="lineCov">       4478 :          nondefdecl-&gt;set_templateName(nameWithoutTemplateArguments);</span></a>
<a name="15136"><span class="lineNum">   15136 </span>            : </a>
<a name="15137"><span class="lineNum">   15137 </span>            :       // DQ (12/26/2011): The non defining declaration should not have a valid pointer to the class definition.</a>
<a name="15138"><span class="lineNum">   15138 </span><span class="lineCov">       4478 :          ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="15139"><span class="lineNum">   15139 </span>            : </a>
<a name="15140"><span class="lineNum">   15140 </span>            :       // The nondefining declaration will not appear in the source code, but is compiler</a>
<a name="15141"><span class="lineNum">   15141 </span>            :       // generated (so we have something about the class that we can reference; e.g in</a>
<a name="15142"><span class="lineNum">   15142 </span>            :       // types).  At the moment we make it a transformation, there might be another kind</a>
<a name="15143"><span class="lineNum">   15143 </span>            :       // of source position that would be more precise.  FIXME.</a>
<a name="15144"><span class="lineNum">   15144 </span><span class="lineCov">       4478 :          setOneSourcePositionForTransformation(nondefdecl);</span></a>
<a name="15145"><span class="lineNum">   15145 </span><span class="lineCov">       4478 :          ROSE_ASSERT (nondefdecl-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="15146"><span class="lineNum">   15146 </span>            : </a>
<a name="15147"><span class="lineNum">   15147 </span><span class="lineCov">       4478 :          nondefdecl-&gt;setForward();</span></a>
<a name="15148"><span class="lineNum">   15148 </span>            : </a>
<a name="15149"><span class="lineNum">   15149 </span>            :       // Liao, 9/2/2009. scope stack is optional, it can be empty</a>
<a name="15150"><span class="lineNum">   15150 </span><span class="lineCov">       4478 :          nondefdecl-&gt;set_parent(scope);</span></a>
<a name="15151"><span class="lineNum">   15151 </span><span class="lineCov">       4478 :          nondefdecl-&gt;set_scope(scope);</span></a>
<a name="15152"><span class="lineNum">   15152 </span>            : #if 0</a>
<a name="15153"><span class="lineNum">   15153 </span>            :          printf(&quot;  next 2\n&quot;);</a>
<a name="15154"><span class="lineNum">   15154 </span>            : #endif</a>
<a name="15155"><span class="lineNum">   15155 </span>            : </a>
<a name="15156"><span class="lineNum">   15156 </span><span class="lineCov">       4478 :          if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="15157"><span class="lineNum">   15157 </span>            :             {</a>
<a name="15158"><span class="lineNum">   15158 </span><span class="lineCov">       4478 :               nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</span></a>
<a name="15159"><span class="lineNum">   15159 </span>            : #if 0</a>
<a name="15160"><span class="lineNum">   15160 </span>            :               printf (&quot;In SageBuilder::buildTemplateClassDeclaration_nfi(): built class type: part 1: nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="15161"><span class="lineNum">   15161 </span>            : #endif</a>
<a name="15162"><span class="lineNum">   15162 </span>            :             }</a>
<a name="15163"><span class="lineNum">   15163 </span>            : #if 0</a>
<a name="15164"><span class="lineNum">   15164 </span>            :          printf(&quot;  next 3\n&quot;);</a>
<a name="15165"><span class="lineNum">   15165 </span>            : #endif</a>
<a name="15166"><span class="lineNum">   15166 </span>            : </a>
<a name="15167"><span class="lineNum">   15167 </span>            :       // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).</a>
<a name="15168"><span class="lineNum">   15168 </span><span class="lineCov">       4478 :          ROSE_ASSERT(nondefdecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="15169"><span class="lineNum">   15169 </span>            : </a>
<a name="15170"><span class="lineNum">   15170 </span>            :       // DQ (7/16/2017): Added code to set the template parameters in the just build declaration (if it is a template declaration).</a>
<a name="15171"><span class="lineNum">   15171 </span>            :       // We want to set the parents of the template paremters to the frst nondefining template class declaration, and we want to reset</a>
<a name="15172"><span class="lineNum">   15172 </span>            :       // the scope of the declarations associated with any previously marked SgClassType objects associated with any template parameters.</a>
<a name="15173"><span class="lineNum">   15173 </span>            :       // printf (&quot;SageBuilder::buildTemplateClassDeclaration_nfi(): Calling setTemplateParametersInDeclaration(): nameWithTemplateSpecializationArguments = %s \n&quot;,nameWithTemplateSpecializationArguments.str());</a>
<a name="15174"><span class="lineNum">   15174 </span>            : </a>
<a name="15175"><span class="lineNum">   15175 </span><span class="lineCov">       4478 :          setTemplateParametersInDeclaration(nondefdecl,templateParameterList);</span></a>
<a name="15176"><span class="lineNum">   15176 </span>            : </a>
<a name="15177"><span class="lineNum">   15177 </span>            :       // DQ (8/13/2013): Adding test of template parameter lists.</a>
<a name="15178"><span class="lineNum">   15178 </span><span class="lineCov">       4478 :          SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(nondefdecl);</span></a>
<a name="15179"><span class="lineNum">   15179 </span><span class="lineCov">       4478 :          ROSE_ASSERT(templateClassDeclaration == NULL || (templateParameterList != NULL &amp;&amp; templateParameterList-&gt;size() == templateClassDeclaration-&gt;get_templateParameters().size()));</span></a>
<a name="15180"><span class="lineNum">   15180 </span>            : </a>
<a name="15181"><span class="lineNum">   15181 </span><span class="lineCov">       4478 :          mysymbol = new SgTemplateClassSymbol(nondefdecl);</span></a>
<a name="15182"><span class="lineNum">   15182 </span><span class="lineCov">       4478 :          scope-&gt;insert_symbol(nameWithTemplateSpecializationArguments, mysymbol);</span></a>
<a name="15183"><span class="lineNum">   15183 </span>            : #if 0</a>
<a name="15184"><span class="lineNum">   15184 </span>            :          printf(&quot;  end build non-defn decl\n&quot;);</a>
<a name="15185"><span class="lineNum">   15185 </span>            : #endif</a>
<a name="15186"><span class="lineNum">   15186 </span>            :        }</a>
<a name="15187"><span class="lineNum">   15187 </span>            :      } else {</a>
<a name="15188"><span class="lineNum">   15188 </span><span class="lineCov">        444 :        SgClassSymbol* mysymbol = scope-&gt;lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList);</span></a>
<a name="15189"><span class="lineNum">   15189 </span><span class="lineCov">        444 :        if (mysymbol == NULL) {</span></a>
<a name="15190"><span class="lineNum">   15190 </span><span class="lineNoCov">          0 :          printf(&quot;WARNING: In buildTemplateClassDeclaration_nfi(): non-defining declaration was provided but cannot be located in the associated scope.\n&quot;);</span></a>
<a name="15191"><span class="lineNum">   15191 </span>            :        }</a>
<a name="15192"><span class="lineNum">   15192 </span>            :      }</a>
<a name="15193"><span class="lineNum">   15193 </span>            : </a>
<a name="15194"><span class="lineNum">   15194 </span>            : #if 0</a>
<a name="15195"><span class="lineNum">   15195 </span>            :      printf (&quot;In buildTemplateClassDeclaration_nfi(): Setting the firstNondefiningDeclaration to be nondefdecl = %p \n&quot;,nondefdecl);</a>
<a name="15196"><span class="lineNum">   15196 </span>            : #endif</a>
<a name="15197"><span class="lineNum">   15197 </span>            : </a>
<a name="15198"><span class="lineNum">   15198 </span><span class="lineCov">       4922 :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="15199"><span class="lineNum">   15199 </span>            : </a>
<a name="15200"><span class="lineNum">   15200 </span>            :   // DQ (9/16/2012): Setup the template specialization arguments on the defining declaration (tested below at base of function).</a>
<a name="15201"><span class="lineNum">   15201 </span><span class="lineCov">       4922 :      setTemplateSpecializationArgumentsInDeclaration(defdecl,templateSpecializationArgumentList);</span></a>
<a name="15202"><span class="lineNum">   15202 </span>            : </a>
<a name="15203"><span class="lineNum">   15203 </span>            : #if 1</a>
<a name="15204"><span class="lineNum">   15204 </span>            :   // DQ (11/20/2011): SgTemplateClassDeclaration IR nodes don't have a SgType associated with them (template declarations don't have a type in C++, I think).</a>
<a name="15205"><span class="lineNum">   15205 </span>            : </a>
<a name="15206"><span class="lineNum">   15206 </span>            :   // Liao, 10/30/2009</a>
<a name="15207"><span class="lineNum">   15207 </span>            :   // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType</a>
<a name="15208"><span class="lineNum">   15208 </span>            :   // This is not desired when building a defining declaration and an inefficience in the constructor</a>
<a name="15209"><span class="lineNum">   15209 </span>            :   // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and</a>
<a name="15210"><span class="lineNum">   15210 </span>            :   // the defining class declaration (and other nondefining declaration) just shared that SgClassType.</a>
<a name="15211"><span class="lineNum">   15211 </span><span class="lineCov">       4922 :      if (defdecl-&gt;get_type() != NULL)</span></a>
<a name="15212"><span class="lineNum">   15212 </span>            :         {</a>
<a name="15213"><span class="lineNum">   15213 </span>            :        // if a defining class declaration's type is associated with a defining class.</a>
<a name="15214"><span class="lineNum">   15214 </span>            :        // This is a wrong SgClassType and has to be reset</a>
<a name="15215"><span class="lineNum">   15215 </span>            : #if 0</a>
<a name="15216"><span class="lineNum">   15216 </span>            :        // if (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl) )</a>
<a name="15217"><span class="lineNum">   15217 </span>            :           if (defdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(defdecl) )</a>
<a name="15218"><span class="lineNum">   15218 </span>            :              {</a>
<a name="15219"><span class="lineNum">   15219 </span>            :                delete defdecl-&gt;get_type();</a>
<a name="15220"><span class="lineNum">   15220 </span>            :              }</a>
<a name="15221"><span class="lineNum">   15221 </span>            : #else</a>
<a name="15222"><span class="lineNum">   15222 </span>            :        // DQ (1/13/2013): I am not clear what this means... if (defdecl-&gt;get_type() != NULL) then it makes</a>
<a name="15223"><span class="lineNum">   15223 </span>            :        // no sense to assert that (defdecl-&gt;get_type() == NULL).  This is related to the reuse of the defining</a>
<a name="15224"><span class="lineNum">   15224 </span>            :        // declaration when it is available (instead of building a new one, which still might be required for a</a>
<a name="15225"><span class="lineNum">   15225 </span>            :        // template specialization (or template partial specialization)).</a>
<a name="15226"><span class="lineNum">   15226 </span>            :        // ROSE_ASSERT(defdecl-&gt;get_type() == NULL);</a>
<a name="15227"><span class="lineNum">   15227 </span>            : #endif</a>
<a name="15228"><span class="lineNum">   15228 </span>            :         }</a>
<a name="15229"><span class="lineNum">   15229 </span>            : </a>
<a name="15230"><span class="lineNum">   15230 </span>            :   // patch up the SgClassType for the defining class declaration</a>
<a name="15231"><span class="lineNum">   15231 </span><span class="lineCov">       4922 :      ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="15232"><span class="lineNum">   15232 </span>            :   // ROSE_ASSERT (nondefdecl-&gt;get_type()-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="15233"><span class="lineNum">   15233 </span>            : </a>
<a name="15234"><span class="lineNum">   15234 </span>            :   // DQ (1/22/2013): This assertion is a problem for boost code represented by ROSE compiling ROSE (see testRoseHeaders_01.C)</a>
<a name="15235"><span class="lineNum">   15235 </span><span class="lineCov">       4922 :      if (isSgClassType(nondefdecl-&gt;get_type())-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl))</span></a>
<a name="15236"><span class="lineNum">   15236 </span>            :         {</a>
<a name="15237"><span class="lineNum">   15237 </span>            : #if 0</a>
<a name="15238"><span class="lineNum">   15238 </span>            :           printf (&quot;In buildTemplateClassDeclaration_nfi(): detected isSgClassType(nondefdecl-&gt;get_type())-&gt;get_declaration() != isSgDeclarationStatement(nondefdecl) (problem with Boost code in ROSE compiling ROSE) \n&quot;);</a>
<a name="15239"><span class="lineNum">   15239 </span>            : #endif</a>
<a name="15240"><span class="lineNum">   15240 </span>            :         }</a>
<a name="15241"><span class="lineNum">   15241 </span>            :   // ROSE_ASSERT (isSgClassType(nondefdecl-&gt;get_type())-&gt;get_declaration() == isSgDeclarationStatement(nondefdecl));</a>
<a name="15242"><span class="lineNum">   15242 </span>            : </a>
<a name="15243"><span class="lineNum">   15243 </span><span class="lineCov">       4922 :      defdecl-&gt;set_type(nondefdecl-&gt;get_type());</span></a>
<a name="15244"><span class="lineNum">   15244 </span>            : </a>
<a name="15245"><span class="lineNum">   15245 </span>            : #if 0</a>
<a name="15246"><span class="lineNum">   15246 </span>            :      printf (&quot;In SageBuilder::buildTemplateClassDeclaration_nfi(): built class type: part 2: defdecl-&gt;get_type() = %p = %s \n&quot;,defdecl-&gt;get_type(),defdecl-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="15247"><span class="lineNum">   15247 </span>            : #endif</a>
<a name="15248"><span class="lineNum">   15248 </span>            : #endif</a>
<a name="15249"><span class="lineNum">   15249 </span>            : </a>
<a name="15250"><span class="lineNum">   15250 </span>            :   // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).</a>
<a name="15251"><span class="lineNum">   15251 </span>            :   // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless</a>
<a name="15252"><span class="lineNum">   15252 </span>            :   // used in a defining declaration).</a>
<a name="15253"><span class="lineNum">   15253 </span><span class="lineCov">       4922 :      nondefdecl-&gt;setForward();</span></a>
<a name="15254"><span class="lineNum">   15254 </span>            : </a>
<a name="15255"><span class="lineNum">   15255 </span>            : #if 0</a>
<a name="15256"><span class="lineNum">   15256 </span>            :      if (scope != NULL)  // put into fixStructDeclaration() or alike later on</a>
<a name="15257"><span class="lineNum">   15257 </span>            :         {</a>
<a name="15258"><span class="lineNum">   15258 </span>            :        // fixStructDeclaration(defdecl,scope);</a>
<a name="15259"><span class="lineNum">   15259 </span>            :        // fixStructDeclaration(nondefdecl,scope);</a>
<a name="15260"><span class="lineNum">   15260 </span>            : </a>
<a name="15261"><span class="lineNum">   15261 </span>            :           printf (&quot;***** WARNING *****: Commented out call to fixStructDeclaration() \n&quot;);</a>
<a name="15262"><span class="lineNum">   15262 </span>            :        // ROSE_ASSERT(false);</a>
<a name="15263"><span class="lineNum">   15263 </span>            :         }</a>
<a name="15264"><span class="lineNum">   15264 </span>            : #endif</a>
<a name="15265"><span class="lineNum">   15265 </span>            : </a>
<a name="15266"><span class="lineNum">   15266 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() == defdecl);</span></a>
<a name="15267"><span class="lineNum">   15267 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != defdecl-&gt;get_definingDeclaration());</span></a>
<a name="15268"><span class="lineNum">   15268 </span>            : </a>
<a name="15269"><span class="lineNum">   15269 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl-&gt;get_scope() != NULL);</span></a>
<a name="15270"><span class="lineNum">   15270 </span>            : </a>
<a name="15271"><span class="lineNum">   15271 </span>            :   // DQ (12/4/2011): We need a concept for type for SgTemplateClassDeclaration so that we can construct SgMemberFunctionType nodes for template member functions.</a>
<a name="15272"><span class="lineNum">   15272 </span>            :   // We use a SgClassType which has been fixed to permit it to hold either a SgClassDeclaration or an SgTemplateClassDeclaration.</a>
<a name="15273"><span class="lineNum">   15273 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl-&gt;get_type() != NULL);</span></a>
<a name="15274"><span class="lineNum">   15274 </span>            : </a>
<a name="15275"><span class="lineNum">   15275 </span>            :   // DQ (12/26/2011): The non defining declaration should not have a valid pointer to the class definition.</a>
<a name="15276"><span class="lineNum">   15276 </span><span class="lineCov">       4922 :      ROSE_ASSERT(nondefdecl-&gt;get_definition() == NULL);</span></a>
<a name="15277"><span class="lineNum">   15277 </span>            : </a>
<a name="15278"><span class="lineNum">   15278 </span>            :   // DQ (7/15/2012): We want to inforce this.</a>
<a name="15279"><span class="lineNum">   15279 </span>            :   // ROSE_ASSERT(defdecl-&gt;get_parent() == NULL);</a>
<a name="15280"><span class="lineNum">   15280 </span><span class="lineCov">       4922 :      if (defdecl-&gt;get_parent() != NULL)</span></a>
<a name="15281"><span class="lineNum">   15281 </span>            :         {</a>
<a name="15282"><span class="lineNum">   15282 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="15283"><span class="lineNum">   15283 </span>            :           printf (&quot;WARNING: the parent will have been set if the defining declaration was found and reused! defdecl = %p = %s \n&quot;,defdecl,defdecl-&gt;class_name().c_str());</a>
<a name="15284"><span class="lineNum">   15284 </span>            : #endif</a>
<a name="15285"><span class="lineNum">   15285 </span>            :         }</a>
<a name="15286"><span class="lineNum">   15286 </span>            : </a>
<a name="15287"><span class="lineNum">   15287 </span>            :   // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).</a>
<a name="15288"><span class="lineNum">   15288 </span><span class="lineCov">       4922 :      ROSE_ASSERT(defdecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="15289"><span class="lineNum">   15289 </span>            : </a>
<a name="15290"><span class="lineNum">   15290 </span>            :   // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).</a>
<a name="15291"><span class="lineNum">   15291 </span><span class="lineCov">       4922 :      ROSE_ASSERT(nondefdecl-&gt;get_templateName().is_null() == false);</span></a>
<a name="15292"><span class="lineNum">   15292 </span>            : </a>
<a name="15293"><span class="lineNum">   15293 </span><span class="lineCov">       4922 :      testTemplateArgumentParents(defdecl);</span></a>
<a name="15294"><span class="lineNum">   15294 </span><span class="lineCov">       4922 :      testTemplateArgumentParents(nondefdecl);</span></a>
<a name="15295"><span class="lineNum">   15295 </span>            : </a>
<a name="15296"><span class="lineNum">   15296 </span>            : #if 0</a>
<a name="15297"><span class="lineNum">   15297 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="15298"><span class="lineNum">   15298 </span>            :      printf (&quot;Leaving buildTemplateClassDeclaration_nfi(): Calling find_symbol_from_declaration() \n&quot;);</a>
<a name="15299"><span class="lineNum">   15299 </span>            :      SgClassDeclaration* tmp_classDeclaration = defdecl;</a>
<a name="15300"><span class="lineNum">   15300 </span>            :      SgSymbol* test_symbol = defdecl-&gt;get_scope()-&gt;find_symbol_from_declaration(tmp_classDeclaration);</a>
<a name="15301"><span class="lineNum">   15301 </span>            : </a>
<a name="15302"><span class="lineNum">   15302 </span>            :   // DQ (1/27/2019): Test that symbol table to debug Cxx11_tests/test2019)33.C.</a>
<a name="15303"><span class="lineNum">   15303 </span>            :      printf (&quot;Leaving buildTemplateClassDeclaration_nfi(): Calling get_symbol_from_symbol_table() \n&quot;);</a>
<a name="15304"><span class="lineNum">   15304 </span>            :      ROSE_ASSERT(defdecl-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="15305"><span class="lineNum">   15305 </span>            : #endif</a>
<a name="15306"><span class="lineNum">   15306 </span>            : </a>
<a name="15307"><span class="lineNum">   15307 </span><span class="lineCov">       9844 :      return defdecl;</span></a>
<a name="15308"><span class="lineNum">   15308 </span>            :    }</a>
<a name="15309"><span class="lineNum">   15309 </span>            : </a>
<a name="15310"><span class="lineNum">   15310 </span><span class="lineNoCov">          0 : SgEnumDeclaration * SageBuilder::buildEnumDeclaration(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="15311"><span class="lineNum">   15311 </span>            :   {</a>
<a name="15312"><span class="lineNum">   15312 </span>            :  // DQ (1/11/2009): This function has semantics very different from the buildEnumDeclaration_nfi() function!</a>
<a name="15313"><span class="lineNum">   15313 </span>            : </a>
<a name="15314"><span class="lineNum">   15314 </span><span class="lineNoCov">          0 :     if (scope == NULL)</span></a>
<a name="15315"><span class="lineNum">   15315 </span><span class="lineNoCov">          0 :          scope = SageBuilder::topScopeStack();</span></a>
<a name="15316"><span class="lineNum">   15316 </span>            : </a>
<a name="15317"><span class="lineNum">   15317 </span><span class="lineNoCov">          0 :     SgEnumDeclaration* decl = buildEnumDeclaration_nfi(name, scope);</span></a>
<a name="15318"><span class="lineNum">   15318 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(decl);</span></a>
<a name="15319"><span class="lineNum">   15319 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="15320"><span class="lineNum">   15320 </span><span class="lineNoCov">          0 :     setOneSourcePositionForTransformation(decl-&gt;get_definingDeclaration());</span></a>
<a name="15321"><span class="lineNum">   15321 </span>            : </a>
<a name="15322"><span class="lineNum">   15322 </span>            :   // DQ (7/15/2012): We want to inforce this.</a>
<a name="15323"><span class="lineNum">   15323 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(decl-&gt;get_parent() == NULL);</span></a>
<a name="15324"><span class="lineNum">   15324 </span>            : </a>
<a name="15325"><span class="lineNum">   15325 </span><span class="lineNoCov">          0 :     return decl;</span></a>
<a name="15326"><span class="lineNum">   15326 </span>            :   } //buildEnumDeclaration()</a>
<a name="15327"><span class="lineNum">   15327 </span>            : </a>
<a name="15328"><span class="lineNum">   15328 </span>            : </a>
<a name="15329"><span class="lineNum">   15329 </span>            : SgEnumDeclaration*</a>
<a name="15330"><span class="lineNum">   15330 </span><span class="lineCov">       1490 : SageBuilder::buildNondefiningEnumDeclaration_nfi(const SgName&amp; name, SgScopeStatement* scope)</span></a>
<a name="15331"><span class="lineNum">   15331 </span>            :    {</a>
<a name="15332"><span class="lineNum">   15332 </span>            :   // The support for SgEnumDeclaration is identical to that for SgClassDeclaration (excpet for the type handleing, why is that?).</a>
<a name="15333"><span class="lineNum">   15333 </span>            : </a>
<a name="15334"><span class="lineNum">   15334 </span>            :   // DQ (7/27/2012): Note that the input name should not have template argument syntax.</a>
<a name="15335"><span class="lineNum">   15335 </span>            :   // I think this could still fail for a function with a name such as &quot;X&lt;Y&gt;&quot;  strange converstion operators.</a>
<a name="15336"><span class="lineNum">   15336 </span><span class="lineCov">       1490 :      ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);</span></a>
<a name="15337"><span class="lineNum">   15337 </span>            : </a>
<a name="15338"><span class="lineNum">   15338 </span>            :   // DQ (4/22/2013): We need this to be provided.</a>
<a name="15339"><span class="lineNum">   15339 </span><span class="lineCov">       1490 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="15340"><span class="lineNum">   15340 </span>            : </a>
<a name="15341"><span class="lineNum">   15341 </span>            : #if 0</a>
<a name="15342"><span class="lineNum">   15342 </span>            :      printf (&quot;In buildNondefiningEnumDeclaration_nfi(): name = %s scope = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="15343"><span class="lineNum">   15343 </span>            : #endif</a>
<a name="15344"><span class="lineNum">   15344 </span>            : </a>
<a name="15345"><span class="lineNum">   15345 </span>            :   // DQ (5/8/2013): For testing with test2007_140.C, make sure this is not the SgBasicBlock (should be SgClassDefinition).</a>
<a name="15346"><span class="lineNum">   15346 </span>            :   // ROSE_ASSERT(isSgBasicBlock(scope) == NULL);</a>
<a name="15347"><span class="lineNum">   15347 </span>            : </a>
<a name="15348"><span class="lineNum">   15348 </span>            :   // DQ (5/8/2013): I think if we searched for the type it might exist and this would allow the types to be shared.</a>
<a name="15349"><span class="lineNum">   15349 </span><span class="lineCov">       1490 :      SgEnumType* enumType = NULL;</span></a>
<a name="15350"><span class="lineNum">   15350 </span>            :   // SgEnumDeclaration* nondefdecl = NULL;</a>
<a name="15351"><span class="lineNum">   15351 </span><span class="lineCov">       1490 :      SgEnumDeclaration* first_nondefdecl = NULL;</span></a>
<a name="15352"><span class="lineNum">   15352 </span>            : </a>
<a name="15353"><span class="lineNum">   15353 </span><span class="lineCov">       1490 :      if (scope != NULL)</span></a>
<a name="15354"><span class="lineNum">   15354 </span>            :         {</a>
<a name="15355"><span class="lineNum">   15355 </span><span class="lineCov">       1490 :           SgEnumSymbol* existing_symbol = scope-&gt;lookup_enum_symbol(name);</span></a>
<a name="15356"><span class="lineNum">   15356 </span><span class="lineCov">       1490 :           if (existing_symbol != NULL)</span></a>
<a name="15357"><span class="lineNum">   15357 </span>            :              {</a>
<a name="15358"><span class="lineNum">   15358 </span><span class="lineNoCov">          0 :                enumType = isSgEnumType(existing_symbol-&gt;get_type());</span></a>
<a name="15359"><span class="lineNum">   15359 </span><span class="lineNoCov">          0 :                first_nondefdecl = existing_symbol-&gt;get_declaration();</span></a>
<a name="15360"><span class="lineNum">   15360 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(first_nondefdecl != NULL);</span></a>
<a name="15361"><span class="lineNum">   15361 </span>            :              }</a>
<a name="15362"><span class="lineNum">   15362 </span>            :         }</a>
<a name="15363"><span class="lineNum">   15363 </span>            : </a>
<a name="15364"><span class="lineNum">   15364 </span>            : #if 0</a>
<a name="15365"><span class="lineNum">   15365 </span>            :      printf (&quot;In buildNondefiningEnumDeclaration_nfi(): name = %s building using enumType = %p first_nondefdecl = %p \n&quot;,name.str(),enumType,first_nondefdecl);</a>
<a name="15366"><span class="lineNum">   15366 </span>            : #endif</a>
<a name="15367"><span class="lineNum">   15367 </span>            : </a>
<a name="15368"><span class="lineNum">   15368 </span>            :   // DQ (5/8/2013): We do want to build a new SgEnumDeclaration (to avoid sharing).</a>
<a name="15369"><span class="lineNum">   15369 </span>            :   // This forces each call to buildNondefiningEnumDeclaration_nfi() to build a unique declaration</a>
<a name="15370"><span class="lineNum">   15370 </span>            :   // required to avoid sharing declaration in examples such as test2007_29.C.</a>
<a name="15371"><span class="lineNum">   15371 </span>            :   // SgEnumDeclaration* nondefdecl = new SgEnumDeclaration(name, NULL);</a>
<a name="15372"><span class="lineNum">   15372 </span><span class="lineCov">       1490 :      SgEnumDeclaration* nondefdecl = new SgEnumDeclaration(name, enumType);</span></a>
<a name="15373"><span class="lineNum">   15373 </span>            : </a>
<a name="15374"><span class="lineNum">   15374 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl);</span></a>
<a name="15375"><span class="lineNum">   15375 </span><span class="lineCov">       1490 :      setOneSourcePositionNull(nondefdecl);</span></a>
<a name="15376"><span class="lineNum">   15376 </span>            : </a>
<a name="15377"><span class="lineNum">   15377 </span>            :   // DQ (5/8/2013): Set the definig and first non-defining declarations.</a>
<a name="15378"><span class="lineNum">   15378 </span>            :   // nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="15379"><span class="lineNum">   15379 </span>            :   // nondefdecl-&gt;set_definingDeclaration(NULL);</a>
<a name="15380"><span class="lineNum">   15380 </span><span class="lineCov">       1490 :      if (first_nondefdecl != NULL)</span></a>
<a name="15381"><span class="lineNum">   15381 </span>            :         {</a>
<a name="15382"><span class="lineNum">   15382 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_firstNondefiningDeclaration(first_nondefdecl);</span></a>
<a name="15383"><span class="lineNum">   15383 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_definingDeclaration(first_nondefdecl-&gt;get_definingDeclaration());</span></a>
<a name="15384"><span class="lineNum">   15384 </span>            :         }</a>
<a name="15385"><span class="lineNum">   15385 </span>            :        else</a>
<a name="15386"><span class="lineNum">   15386 </span>            :         {</a>
<a name="15387"><span class="lineNum">   15387 </span><span class="lineCov">       1490 :           nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</span></a>
<a name="15388"><span class="lineNum">   15388 </span><span class="lineCov">       1490 :           nondefdecl-&gt;set_definingDeclaration(NULL);</span></a>
<a name="15389"><span class="lineNum">   15389 </span>            :         }</a>
<a name="15390"><span class="lineNum">   15390 </span>            : </a>
<a name="15391"><span class="lineNum">   15391 </span>            :   // Any non-defining declaration is not always a forward declaration.</a>
<a name="15392"><span class="lineNum">   15392 </span><span class="lineCov">       1490 :      nondefdecl-&gt;setForward();</span></a>
<a name="15393"><span class="lineNum">   15393 </span>            : </a>
<a name="15394"><span class="lineNum">   15394 </span>            :   // SgEnumDeclaration* first_nondefdecl = NULL;</a>
<a name="15395"><span class="lineNum">   15395 </span>            : </a>
<a name="15396"><span class="lineNum">   15396 </span>            :   // DQ (5/8/2013): Make sure that the enum type is available.</a>
<a name="15397"><span class="lineNum">   15397 </span><span class="lineCov">       1490 :      SgType* type = nondefdecl-&gt;get_type();</span></a>
<a name="15398"><span class="lineNum">   15398 </span><span class="lineCov">       1490 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="15399"><span class="lineNum">   15399 </span>            : </a>
<a name="15400"><span class="lineNum">   15400 </span><span class="lineCov">       1490 :      if (scope != NULL)</span></a>
<a name="15401"><span class="lineNum">   15401 </span>            :         {</a>
<a name="15402"><span class="lineNum">   15402 </span>            :        // DQ (4/22/2013): check for an existing symbol (reuse it if it is found).</a>
<a name="15403"><span class="lineNum">   15403 </span><span class="lineCov">       1490 :           SgEnumSymbol* mysymbol = NULL;</span></a>
<a name="15404"><span class="lineNum">   15404 </span><span class="lineCov">       1490 :           SgEnumSymbol* existing_symbol = scope-&gt;lookup_enum_symbol(name);</span></a>
<a name="15405"><span class="lineNum">   15405 </span>            :        // ROSE_ASSERT(existing_symbol == NULL);</a>
<a name="15406"><span class="lineNum">   15406 </span>            : </a>
<a name="15407"><span class="lineNum">   15407 </span><span class="lineCov">       1490 :           if (existing_symbol != NULL)</span></a>
<a name="15408"><span class="lineNum">   15408 </span>            :              {</a>
<a name="15409"><span class="lineNum">   15409 </span><span class="lineNoCov">          0 :                mysymbol = existing_symbol;</span></a>
<a name="15410"><span class="lineNum">   15410 </span>            : #if 0</a>
<a name="15411"><span class="lineNum">   15411 </span>            :                nondefdecl = new SgEnumDeclaration(name, NULL);</a>
<a name="15412"><span class="lineNum">   15412 </span>            :                ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="15413"><span class="lineNum">   15413 </span>            : #else</a>
<a name="15414"><span class="lineNum">   15414 </span><span class="lineNoCov">          0 :                first_nondefdecl = mysymbol-&gt;get_declaration();</span></a>
<a name="15415"><span class="lineNum">   15415 </span>            : #endif</a>
<a name="15416"><span class="lineNum">   15416 </span>            :              }</a>
<a name="15417"><span class="lineNum">   15417 </span>            :             else</a>
<a name="15418"><span class="lineNum">   15418 </span>            :              {</a>
<a name="15419"><span class="lineNum">   15419 </span>            : #if 0</a>
<a name="15420"><span class="lineNum">   15420 </span>            :                nondefdecl = new SgEnumDeclaration(name, NULL);</a>
<a name="15421"><span class="lineNum">   15421 </span>            :                ROSE_ASSERT(nondefdecl != NULL);</a>
<a name="15422"><span class="lineNum">   15422 </span>            :                setOneSourcePositionNull(nondefdecl);</a>
<a name="15423"><span class="lineNum">   15423 </span>            :                nondefdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="15424"><span class="lineNum">   15424 </span>            :                nondefdecl-&gt;set_definingDeclaration(NULL);</a>
<a name="15425"><span class="lineNum">   15425 </span>            : </a>
<a name="15426"><span class="lineNum">   15426 </span>            :             // Any non-defining declaration is not always a forward declaration.</a>
<a name="15427"><span class="lineNum">   15427 </span>            :                nondefdecl-&gt;setForward();</a>
<a name="15428"><span class="lineNum">   15428 </span>            : #endif</a>
<a name="15429"><span class="lineNum">   15429 </span><span class="lineCov">       1490 :                first_nondefdecl = nondefdecl;</span></a>
<a name="15430"><span class="lineNum">   15430 </span>            : </a>
<a name="15431"><span class="lineNum">   15431 </span><span class="lineCov">       1490 :                mysymbol = new SgEnumSymbol(nondefdecl);</span></a>
<a name="15432"><span class="lineNum">   15432 </span><span class="lineCov">       1490 :                ROSE_ASSERT(mysymbol != NULL);</span></a>
<a name="15433"><span class="lineNum">   15433 </span><span class="lineCov">       1490 :                scope-&gt;insert_symbol(name, mysymbol);</span></a>
<a name="15434"><span class="lineNum">   15434 </span>            :              }</a>
<a name="15435"><span class="lineNum">   15435 </span>            : </a>
<a name="15436"><span class="lineNum">   15436 </span>            :        // SgEnumSymbol* mysymbol = new SgEnumSymbol(nondefdecl);</a>
<a name="15437"><span class="lineNum">   15437 </span>            : </a>
<a name="15438"><span class="lineNum">   15438 </span><span class="lineCov">       1490 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="15439"><span class="lineNum">   15439 </span>            : </a>
<a name="15440"><span class="lineNum">   15440 </span>            :        // Can this be defined in C++ so that it is in a logical scope different from its structural scope?</a>
<a name="15441"><span class="lineNum">   15441 </span><span class="lineCov">       1490 :           nondefdecl-&gt;set_parent(scope);</span></a>
<a name="15442"><span class="lineNum">   15442 </span>            :         }</a>
<a name="15443"><span class="lineNum">   15443 </span>            : </a>
<a name="15444"><span class="lineNum">   15444 </span><span class="lineCov">       1490 :      if (first_nondefdecl != nondefdecl)</span></a>
<a name="15445"><span class="lineNum">   15445 </span>            :         {</a>
<a name="15446"><span class="lineNum">   15446 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_firstNondefiningDeclaration(first_nondefdecl);</span></a>
<a name="15447"><span class="lineNum">   15447 </span>            :        // nondefdecl-&gt;set_definingDeclaration(first_nondefdecl-&gt;get_definingDeclaration());</a>
<a name="15448"><span class="lineNum">   15448 </span>            : </a>
<a name="15449"><span class="lineNum">   15449 </span><span class="lineNoCov">          0 :           if (first_nondefdecl-&gt;get_definingDeclaration() != NULL)</span></a>
<a name="15450"><span class="lineNum">   15450 </span>            :              {</a>
<a name="15451"><span class="lineNum">   15451 </span><span class="lineNoCov">          0 :                nondefdecl-&gt;set_definingDeclaration(first_nondefdecl-&gt;get_definingDeclaration());</span></a>
<a name="15452"><span class="lineNum">   15452 </span>            :              }</a>
<a name="15453"><span class="lineNum">   15453 </span>            :         }</a>
<a name="15454"><span class="lineNum">   15454 </span>            : </a>
<a name="15455"><span class="lineNum">   15455 </span>            :   // DQ (1/25/2009): I want to check into this later, since it is not symetric with SageBuilder::buildNondefiningClassDeclaration()</a>
<a name="15456"><span class="lineNum">   15456 </span>            : #if 0</a>
<a name="15457"><span class="lineNum">   15457 </span>            :      printf (&quot;In buildNondefiningEnumDeclaration_nfi(): Need to check if SgEnumDeclaration constructor builds the SgEnumType already nondefdecl-&gt;get_type() = %p \n&quot;,nondefdecl-&gt;get_type());</a>
<a name="15458"><span class="lineNum">   15458 </span>            : #endif</a>
<a name="15459"><span class="lineNum">   15459 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="15460"><span class="lineNum">   15460 </span>            : </a>
<a name="15461"><span class="lineNum">   15461 </span>            :   // DQ (4/22/2013): This type should already exist (likely built by call to get_type()).</a>
<a name="15462"><span class="lineNum">   15462 </span>            :   // SgEnumType* t = new SgEnumType(nondefdecl);</a>
<a name="15463"><span class="lineNum">   15463 </span>            :   // nondefdecl-&gt;set_type(t);</a>
<a name="15464"><span class="lineNum">   15464 </span>            : </a>
<a name="15465"><span class="lineNum">   15465 </span>            : #if 0</a>
<a name="15466"><span class="lineNum">   15466 </span>            :      printf (&quot;Leaving buildNondefiningEnumDeclaration_nfi(): name = %s nondefdecl = %p \n&quot;,name.str(),nondefdecl);</a>
<a name="15467"><span class="lineNum">   15467 </span>            : #endif</a>
<a name="15468"><span class="lineNum">   15468 </span>            : </a>
<a name="15469"><span class="lineNum">   15469 </span>            :   // DQ (5/8/2013): Check that the symbol is present.</a>
<a name="15470"><span class="lineNum">   15470 </span><span class="lineCov">       1490 :      ROSE_ASSERT(scope-&gt;lookup_enum_symbol(name) != NULL);</span></a>
<a name="15471"><span class="lineNum">   15471 </span>            : </a>
<a name="15472"><span class="lineNum">   15472 </span><span class="lineCov">       1490 :      return nondefdecl;</span></a>
<a name="15473"><span class="lineNum">   15473 </span>            :    }</a>
<a name="15474"><span class="lineNum">   15474 </span>            : </a>
<a name="15475"><span class="lineNum">   15475 </span>            : </a>
<a name="15476"><span class="lineNum">   15476 </span>            : SgEnumDeclaration*</a>
<a name="15477"><span class="lineNum">   15477 </span><span class="lineCov">       1490 : SageBuilder::buildEnumDeclaration_nfi(const SgName&amp; name, SgScopeStatement* scope)</span></a>
<a name="15478"><span class="lineNum">   15478 </span>            :    {</a>
<a name="15479"><span class="lineNum">   15479 </span><span class="lineCov">       1490 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="15480"><span class="lineNum">   15480 </span>            : </a>
<a name="15481"><span class="lineNum">   15481 </span>            : #if 0</a>
<a name="15482"><span class="lineNum">   15482 </span>            :      printf (&quot;In buildEnumDeclaration_nfi(): name = %s scope = %p = %s \n&quot;,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="15483"><span class="lineNum">   15483 </span>            : #endif</a>
<a name="15484"><span class="lineNum">   15484 </span>            : </a>
<a name="15485"><span class="lineNum">   15485 </span>            :   // DQ (5/8/2013): I think if we searched for the type it might exist and this would allow the types to be shared.</a>
<a name="15486"><span class="lineNum">   15486 </span><span class="lineCov">       1490 :      SgEnumType* enumType = NULL;</span></a>
<a name="15487"><span class="lineNum">   15487 </span>            : </a>
<a name="15488"><span class="lineNum">   15488 </span><span class="lineCov">       1490 :      if (scope != NULL)</span></a>
<a name="15489"><span class="lineNum">   15489 </span>            :         {</a>
<a name="15490"><span class="lineNum">   15490 </span><span class="lineCov">       1490 :           SgEnumSymbol* existing_symbol = scope-&gt;lookup_enum_symbol(name);</span></a>
<a name="15491"><span class="lineNum">   15491 </span><span class="lineCov">       1490 :           if (existing_symbol != NULL)</span></a>
<a name="15492"><span class="lineNum">   15492 </span>            :              {</a>
<a name="15493"><span class="lineNum">   15493 </span><span class="lineCov">         48 :                enumType = isSgEnumType(existing_symbol-&gt;get_type());</span></a>
<a name="15494"><span class="lineNum">   15494 </span>            :              }</a>
<a name="15495"><span class="lineNum">   15495 </span>            :         }</a>
<a name="15496"><span class="lineNum">   15496 </span>            : </a>
<a name="15497"><span class="lineNum">   15497 </span>            : #if 0</a>
<a name="15498"><span class="lineNum">   15498 </span>            :      printf (&quot;In buildEnumDeclaration_nfi(): name = %s building using enumType = %p \n&quot;,name.str(),enumType);</a>
<a name="15499"><span class="lineNum">   15499 </span>            : #endif</a>
<a name="15500"><span class="lineNum">   15500 </span>            : </a>
<a name="15501"><span class="lineNum">   15501 </span>            :   // SgEnumDeclaration* defdecl = new SgEnumDeclaration (name,NULL);</a>
<a name="15502"><span class="lineNum">   15502 </span><span class="lineCov">       1490 :      SgEnumDeclaration* defdecl = new SgEnumDeclaration (name,enumType);</span></a>
<a name="15503"><span class="lineNum">   15503 </span><span class="lineCov">       1490 :      ROSE_ASSERT(defdecl);</span></a>
<a name="15504"><span class="lineNum">   15504 </span>            : </a>
<a name="15505"><span class="lineNum">   15505 </span>            : #if 0</a>
<a name="15506"><span class="lineNum">   15506 </span>            :      printf (&quot;In buildEnumDeclaration_nfi(): built defining declaration = %p name = %s scope = %p = %s \n&quot;,defdecl,name.str(),scope,scope-&gt;class_name().c_str());</a>
<a name="15507"><span class="lineNum">   15507 </span>            : #endif</a>
<a name="15508"><span class="lineNum">   15508 </span>            : </a>
<a name="15509"><span class="lineNum">   15509 </span>            :   // DQ (5/8/2013): Make sure that the enum type is available.</a>
<a name="15510"><span class="lineNum">   15510 </span><span class="lineCov">       1490 :      SgType* type = defdecl-&gt;get_type();</span></a>
<a name="15511"><span class="lineNum">   15511 </span><span class="lineCov">       1490 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="15512"><span class="lineNum">   15512 </span>            : </a>
<a name="15513"><span class="lineNum">   15513 </span><span class="lineCov">       1490 :      setOneSourcePositionNull(defdecl);</span></a>
<a name="15514"><span class="lineNum">   15514 </span>            :   // constructor is side-effect free</a>
<a name="15515"><span class="lineNum">   15515 </span><span class="lineCov">       1490 :      defdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15516"><span class="lineNum">   15516 </span>            : </a>
<a name="15517"><span class="lineNum">   15517 </span>            : #if 0</a>
<a name="15518"><span class="lineNum">   15518 </span>            :      printf (&quot;In buildEnumDeclaration_nfi(): name = %s \n&quot;,name.str());</a>
<a name="15519"><span class="lineNum">   15519 </span>            : #endif</a>
<a name="15520"><span class="lineNum">   15520 </span>            : </a>
<a name="15521"><span class="lineNum">   15521 </span>            : #if 1</a>
<a name="15522"><span class="lineNum">   15522 </span>            :   // DQ (4/3/2017): Check for an existing non-defining declaration before building one (to avoid multiple versions). See test2017_13.C.</a>
<a name="15523"><span class="lineNum">   15523 </span><span class="lineCov">       1490 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="15524"><span class="lineNum">   15524 </span><span class="lineCov">       1490 :      SgEnumSymbol* enumSymbol = scope-&gt;lookup_enum_symbol(name);</span></a>
<a name="15525"><span class="lineNum">   15525 </span>            :   // ROSE_ASSERT(enumSymbol != NULL);</a>
<a name="15526"><span class="lineNum">   15526 </span><span class="lineCov">       1490 :      SgEnumDeclaration* nondefdecl = NULL;</span></a>
<a name="15527"><span class="lineNum">   15527 </span><span class="lineCov">       1490 :      if (enumSymbol != NULL)</span></a>
<a name="15528"><span class="lineNum">   15528 </span>            :         {</a>
<a name="15529"><span class="lineNum">   15529 </span><span class="lineCov">         48 :           ROSE_ASSERT(enumSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="15530"><span class="lineNum">   15530 </span><span class="lineCov">         48 :           nondefdecl = enumSymbol-&gt;get_declaration();</span></a>
<a name="15531"><span class="lineNum">   15531 </span><span class="lineCov">         48 :           ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="15532"><span class="lineNum">   15532 </span>            :         }</a>
<a name="15533"><span class="lineNum">   15533 </span>            :        else</a>
<a name="15534"><span class="lineNum">   15534 </span>            :         {</a>
<a name="15535"><span class="lineNum">   15535 </span>            :        // build the nondefining declaration</a>
<a name="15536"><span class="lineNum">   15536 </span><span class="lineCov">       1442 :           nondefdecl = buildNondefiningEnumDeclaration_nfi(name, scope);</span></a>
<a name="15537"><span class="lineNum">   15537 </span>            : #if 0</a>
<a name="15538"><span class="lineNum">   15538 </span>            :           printf (&quot;###### In buildEnumDeclaration_nfi(): built a non-defining declaration to support the symbol table: name = %s nondefdecl = %p \n&quot;,name.str(),nondefdecl);</a>
<a name="15539"><span class="lineNum">   15539 </span>            : #endif</a>
<a name="15540"><span class="lineNum">   15540 </span>            :         }</a>
<a name="15541"><span class="lineNum">   15541 </span>            : #else</a>
<a name="15542"><span class="lineNum">   15542 </span>            :   // build the nondefining declaration</a>
<a name="15543"><span class="lineNum">   15543 </span>            :      SgEnumDeclaration* nondefdecl = buildNondefiningEnumDeclaration_nfi(name, scope);</a>
<a name="15544"><span class="lineNum">   15544 </span>            : #endif</a>
<a name="15545"><span class="lineNum">   15545 </span>            : </a>
<a name="15546"><span class="lineNum">   15546 </span><span class="lineCov">       1490 :      nondefdecl-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15547"><span class="lineNum">   15547 </span>            :   // defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl);</a>
<a name="15548"><span class="lineNum">   15548 </span><span class="lineCov">       1490 :      defdecl-&gt;set_firstNondefiningDeclaration(nondefdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="15549"><span class="lineNum">   15549 </span>            : </a>
<a name="15550"><span class="lineNum">   15550 </span>            :   // DQ (4/22/2013): We need to set the defining declaration on the first non-defining declaration.</a>
<a name="15551"><span class="lineNum">   15551 </span><span class="lineCov">       1490 :      if (nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL &amp;&amp; nondefdecl-&gt;get_firstNondefiningDeclaration() != nondefdecl)</span></a>
<a name="15552"><span class="lineNum">   15552 </span>            :         {</a>
<a name="15553"><span class="lineNum">   15553 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;set_definingDeclaration(defdecl);</span></a>
<a name="15554"><span class="lineNum">   15554 </span>            :         }</a>
<a name="15555"><span class="lineNum">   15555 </span>            : </a>
<a name="15556"><span class="lineNum">   15556 </span>            :   // DQ (4/22/2013): Thing that should be true at this point.</a>
<a name="15557"><span class="lineNum">   15557 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="15558"><span class="lineNum">   15558 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="15559"><span class="lineNum">   15559 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="15560"><span class="lineNum">   15560 </span><span class="lineCov">       1490 :      ROSE_ASSERT(nondefdecl-&gt;get_firstNondefiningDeclaration()-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="15561"><span class="lineNum">   15561 </span><span class="lineCov">       1490 :      ROSE_ASSERT(defdecl-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="15562"><span class="lineNum">   15562 </span><span class="lineCov">       1490 :      ROSE_ASSERT(defdecl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="15563"><span class="lineNum">   15563 </span>            : </a>
<a name="15564"><span class="lineNum">   15564 </span>            :   // DQ (1/11/2009): The buildNondefiningEnumDeclaration function builds an entry in the symbol table, and so we don't want a second one!</a>
<a name="15565"><span class="lineNum">   15565 </span>            : #if 0</a>
<a name="15566"><span class="lineNum">   15566 </span>            :      SgEnumSymbol* mysymbol = new SgEnumSymbol(nondefdecl);</a>
<a name="15567"><span class="lineNum">   15567 </span>            :      ROSE_ASSERT(mysymbol);</a>
<a name="15568"><span class="lineNum">   15568 </span>            :   // scope-&gt;print_symboltable(&quot;buildEnumDeclaration_nfi(): before inserting new SgEnumSymbol&quot;);</a>
<a name="15569"><span class="lineNum">   15569 </span>            :      scope-&gt;insert_symbol(name, mysymbol);</a>
<a name="15570"><span class="lineNum">   15570 </span>            : #endif</a>
<a name="15571"><span class="lineNum">   15571 </span>            : </a>
<a name="15572"><span class="lineNum">   15572 </span><span class="lineCov">       1490 :      defdecl-&gt;set_scope(scope);</span></a>
<a name="15573"><span class="lineNum">   15573 </span><span class="lineCov">       1490 :      nondefdecl-&gt;set_scope(scope);</span></a>
<a name="15574"><span class="lineNum">   15574 </span>            : </a>
<a name="15575"><span class="lineNum">   15575 </span>            : #if 0</a>
<a name="15576"><span class="lineNum">   15576 </span>            :   // DQ (7/12/2012): We can't set the parent here because if this is a non-autonomous declaration then it must be set later (to the outer declaration where this declaration is nested).</a>
<a name="15577"><span class="lineNum">   15577 </span>            :      defdecl-&gt;set_parent(scope);</a>
<a name="15578"><span class="lineNum">   15578 </span>            :      nondefdecl-&gt;set_parent(scope);</a>
<a name="15579"><span class="lineNum">   15579 </span>            : #endif</a>
<a name="15580"><span class="lineNum">   15580 </span>            : </a>
<a name="15581"><span class="lineNum">   15581 </span>            :   // DQ (7/12/2012): When this is an unnamed enum declaration, this it is NON-AUTONIMOUS</a>
<a name="15582"><span class="lineNum">   15582 </span>            :   // (and will have it's parent set in the associated variable or typedef declaration.</a>
<a name="15583"><span class="lineNum">   15583 </span>            :   // In the case of a class declaration this is always NULL (this should be similar).</a>
<a name="15584"><span class="lineNum">   15584 </span><span class="lineCov">       1490 :      ROSE_ASSERT(defdecl-&gt;get_parent() == NULL);</span></a>
<a name="15585"><span class="lineNum">   15585 </span>            : </a>
<a name="15586"><span class="lineNum">   15586 </span>            : #if 0</a>
<a name="15587"><span class="lineNum">   15587 </span>            :      printf (&quot;In buildEnumDeclaration_nfi(): name = %s defdecl = %p \n&quot;,name.str(),defdecl);</a>
<a name="15588"><span class="lineNum">   15588 </span>            : #endif</a>
<a name="15589"><span class="lineNum">   15589 </span>            : </a>
<a name="15590"><span class="lineNum">   15590 </span>            :   // DQ (5/8/2013): Check that the symbol is present.</a>
<a name="15591"><span class="lineNum">   15591 </span><span class="lineCov">       1490 :      ROSE_ASSERT(scope-&gt;lookup_enum_symbol(name) != NULL);</span></a>
<a name="15592"><span class="lineNum">   15592 </span>            : </a>
<a name="15593"><span class="lineNum">   15593 </span><span class="lineCov">       1490 :      return defdecl;</span></a>
<a name="15594"><span class="lineNum">   15594 </span>            :    } //buildEnumDeclaration_nfi()</a>
<a name="15595"><span class="lineNum">   15595 </span>            : </a>
<a name="15596"><span class="lineNum">   15596 </span>            : </a>
<a name="15597"><span class="lineNum">   15597 </span>            : SgBaseClass*</a>
<a name="15598"><span class="lineNum">   15598 </span><span class="lineCov">       3817 : SageBuilder::buildBaseClass ( SgClassDeclaration* classDeclaration, SgClassDefinition* classDefinition, bool isVirtual, bool isDirect )</span></a>
<a name="15599"><span class="lineNum">   15599 </span>            :    {</a>
<a name="15600"><span class="lineNum">   15600 </span>            :   // DQ (5/6/2013): Refactored the construction of the SgBaseClass support to the builder API.</a>
<a name="15601"><span class="lineNum">   15601 </span>            : </a>
<a name="15602"><span class="lineNum">   15602 </span>            :   // Note: classDeclaration should be the first non-defining class declaration, not required to be the the declaration associated with the SgClassDefinition.</a>
<a name="15603"><span class="lineNum">   15603 </span><span class="lineCov">       3817 :      ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="15604"><span class="lineNum">   15604 </span><span class="lineCov">       3817 :      ROSE_ASSERT(classDefinition  != NULL);</span></a>
<a name="15605"><span class="lineNum">   15605 </span>            : </a>
<a name="15606"><span class="lineNum">   15606 </span>            :   // DQ (5/6/2013): This is not always true (see test2013_63.C).</a>
<a name="15607"><span class="lineNum">   15607 </span>            :   // ROSE_ASSERT(classDeclaration == classDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="15608"><span class="lineNum">   15608 </span>            : </a>
<a name="15609"><span class="lineNum">   15609 </span><span class="lineCov">       3817 :      ROSE_ASSERT(classDefinition-&gt;get_declaration() != NULL);</span></a>
<a name="15610"><span class="lineNum">   15610 </span>            : </a>
<a name="15611"><span class="lineNum">   15611 </span>            :   // DQ (5/6/2013): This is not always true (see test2004_30.C).</a>
<a name="15612"><span class="lineNum">   15612 </span>            :   // ROSE_ASSERT(classDefinition-&gt;get_declaration() == classDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="15613"><span class="lineNum">   15613 </span>            : </a>
<a name="15614"><span class="lineNum">   15614 </span><span class="lineCov">       3817 :      SgBaseClass* baseclass = new SgBaseClass ( classDeclaration, isDirect );</span></a>
<a name="15615"><span class="lineNum">   15615 </span><span class="lineCov">       3817 :      ROSE_ASSERT(baseclass != NULL);</span></a>
<a name="15616"><span class="lineNum">   15616 </span>            : </a>
<a name="15617"><span class="lineNum">   15617 </span><span class="lineCov">       3817 :      if (isVirtual == true)</span></a>
<a name="15618"><span class="lineNum">   15618 </span>            :         {</a>
<a name="15619"><span class="lineNum">   15619 </span>            :        // DQ (1/21/2019): get_baseClassModifier() uses ROSETTA generated access functions which return a pointer.</a>
<a name="15620"><span class="lineNum">   15620 </span>            :        // baseclass-&gt;get_baseClassModifier().setVirtual();</a>
<a name="15621"><span class="lineNum">   15621 </span><span class="lineCov">         32 :           ROSE_ASSERT(baseclass-&gt;get_baseClassModifier() != NULL);</span></a>
<a name="15622"><span class="lineNum">   15622 </span><span class="lineCov">         32 :           baseclass-&gt;get_baseClassModifier()-&gt;setVirtual();</span></a>
<a name="15623"><span class="lineNum">   15623 </span>            :         }</a>
<a name="15624"><span class="lineNum">   15624 </span>            : </a>
<a name="15625"><span class="lineNum">   15625 </span>            :   // DQ (4/29/2004): add support to set access specifier</a>
<a name="15626"><span class="lineNum">   15626 </span>            :   // baseclass-&gt;get_baseClassModifier().get_accessModifier() = set_access_modifiers(bcdp-&gt;access);</a>
<a name="15627"><span class="lineNum">   15627 </span>            :   // baseclass-&gt;get_baseClassModifier().get_accessModifier() = buildAccessModifier(accessModifiers);</a>
<a name="15628"><span class="lineNum">   15628 </span>            : </a>
<a name="15629"><span class="lineNum">   15629 </span>            :   // DQ (6/21/2005): Set the parent of the base class to the class definition</a>
<a name="15630"><span class="lineNum">   15630 </span>            :   // (these are not traversed in ROSE currently, so their parents are not set).</a>
<a name="15631"><span class="lineNum">   15631 </span><span class="lineCov">       3817 :      baseclass-&gt;set_parent(classDefinition);</span></a>
<a name="15632"><span class="lineNum">   15632 </span>            : </a>
<a name="15633"><span class="lineNum">   15633 </span>            :   // DQ (6/21/2005): Notice that this is copied by value (the base class list should be a list of pointers to SgBaseClass (later)</a>
<a name="15634"><span class="lineNum">   15634 </span><span class="lineCov">       3817 :      classDefinition-&gt;append_inheritance(baseclass);</span></a>
<a name="15635"><span class="lineNum">   15635 </span>            : </a>
<a name="15636"><span class="lineNum">   15636 </span><span class="lineCov">       3817 :      return baseclass;</span></a>
<a name="15637"><span class="lineNum">   15637 </span>            :    }</a>
<a name="15638"><span class="lineNum">   15638 </span>            : </a>
<a name="15639"><span class="lineNum">   15639 </span>            : </a>
<a name="15640"><span class="lineNum">   15640 </span>            : SgNonrealBaseClass*</a>
<a name="15641"><span class="lineNum">   15641 </span><span class="lineCov">       1908 : SageBuilder::buildNonrealBaseClass ( SgNonrealDecl* nrdecl, SgClassDefinition* classDefinition, bool isVirtual, bool isDirect )</span></a>
<a name="15642"><span class="lineNum">   15642 </span>            :    {</a>
<a name="15643"><span class="lineNum">   15643 </span><span class="lineCov">       1908 :      ROSE_ASSERT(nrdecl != NULL);</span></a>
<a name="15644"><span class="lineNum">   15644 </span><span class="lineCov">       1908 :      ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="15645"><span class="lineNum">   15645 </span>            : </a>
<a name="15646"><span class="lineNum">   15646 </span><span class="lineCov">       1908 :      SgNonrealBaseClass * baseclass = new SgNonrealBaseClass ( NULL , isDirect , nrdecl );</span></a>
<a name="15647"><span class="lineNum">   15647 </span><span class="lineCov">       1908 :      ROSE_ASSERT(baseclass != NULL);</span></a>
<a name="15648"><span class="lineNum">   15648 </span>            : </a>
<a name="15649"><span class="lineNum">   15649 </span><span class="lineCov">       1908 :      if (isVirtual == true)</span></a>
<a name="15650"><span class="lineNum">   15650 </span>            :         {</a>
<a name="15651"><span class="lineNum">   15651 </span><span class="lineCov">         16 :           baseclass-&gt;get_baseClassModifier()-&gt;setVirtual();</span></a>
<a name="15652"><span class="lineNum">   15652 </span>            :         }</a>
<a name="15653"><span class="lineNum">   15653 </span>            : </a>
<a name="15654"><span class="lineNum">   15654 </span><span class="lineCov">       1908 :      baseclass-&gt;set_parent(classDefinition);</span></a>
<a name="15655"><span class="lineNum">   15655 </span>            : </a>
<a name="15656"><span class="lineNum">   15656 </span><span class="lineCov">       1908 :      classDefinition-&gt;append_inheritance(baseclass);</span></a>
<a name="15657"><span class="lineNum">   15657 </span>            : </a>
<a name="15658"><span class="lineNum">   15658 </span><span class="lineCov">       1908 :      return baseclass;</span></a>
<a name="15659"><span class="lineNum">   15659 </span>            :    }</a>
<a name="15660"><span class="lineNum">   15660 </span>            : </a>
<a name="15661"><span class="lineNum">   15661 </span>            : </a>
<a name="15662"><span class="lineNum">   15662 </span>            : #if 0</a>
<a name="15663"><span class="lineNum">   15663 </span>            : // This function would be more complex that I want to support at present since the mapping of</a>
<a name="15664"><span class="lineNum">   15664 </span>            : // edg modifier values to ROSE modifier values is offset and backwards (reversed in numerical order).</a>
<a name="15665"><span class="lineNum">   15665 </span>            : SgAccessModifier</a>
<a name="15666"><span class="lineNum">   15666 </span>            : SageBuilder::buildAccessModifier ( unsigned int access )</a>
<a name="15667"><span class="lineNum">   15667 </span>            :    {</a>
<a name="15668"><span class="lineNum">   15668 </span>            :      SgAccessModifier a;</a>
<a name="15669"><span class="lineNum">   15669 </span>            : </a>
<a name="15670"><span class="lineNum">   15670 </span>            :      switch (access)</a>
<a name="15671"><span class="lineNum">   15671 </span>            :         {</a>
<a name="15672"><span class="lineNum">   15672 </span>            :           case as_public:</a>
<a name="15673"><span class="lineNum">   15673 </span>            : #if 0</a>
<a name="15674"><span class="lineNum">   15674 </span>            :                printf (&quot;In SageBuilder::set_access_modifiers(): Mark as public \n&quot;);</a>
<a name="15675"><span class="lineNum">   15675 </span>            : #endif</a>
<a name="15676"><span class="lineNum">   15676 </span>            :                a.setPublic();</a>
<a name="15677"><span class="lineNum">   15677 </span>            :                break;</a>
<a name="15678"><span class="lineNum">   15678 </span>            : </a>
<a name="15679"><span class="lineNum">   15679 </span>            :           case as_protected:</a>
<a name="15680"><span class="lineNum">   15680 </span>            : #if 0</a>
<a name="15681"><span class="lineNum">   15681 </span>            :                printf (&quot;In SageBuilder::set_access_modifiers(): Mark as protected \n&quot;);</a>
<a name="15682"><span class="lineNum">   15682 </span>            : #endif</a>
<a name="15683"><span class="lineNum">   15683 </span>            :                a.setProtected();</a>
<a name="15684"><span class="lineNum">   15684 </span>            :                break;</a>
<a name="15685"><span class="lineNum">   15685 </span>            : </a>
<a name="15686"><span class="lineNum">   15686 </span>            :           case as_private:</a>
<a name="15687"><span class="lineNum">   15687 </span>            : #if 0</a>
<a name="15688"><span class="lineNum">   15688 </span>            :                printf (&quot;In SageBuilder::set_access_modifiers(): Mark as private \n&quot;);</a>
<a name="15689"><span class="lineNum">   15689 </span>            : #endif</a>
<a name="15690"><span class="lineNum">   15690 </span>            :                a.setPrivate();</a>
<a name="15691"><span class="lineNum">   15691 </span>            :                break;</a>
<a name="15692"><span class="lineNum">   15692 </span>            : </a>
<a name="15693"><span class="lineNum">   15693 </span>            :           default:</a>
<a name="15694"><span class="lineNum">   15694 </span>            :                printf (&quot;Error: default reached in SageBuilder::set_access_modifiers() \n&quot;);</a>
<a name="15695"><span class="lineNum">   15695 </span>            :                ROSE_ABORT ();</a>
<a name="15696"><span class="lineNum">   15696 </span>            :         }</a>
<a name="15697"><span class="lineNum">   15697 </span>            : </a>
<a name="15698"><span class="lineNum">   15698 </span>            :      return a;</a>
<a name="15699"><span class="lineNum">   15699 </span>            :    }</a>
<a name="15700"><span class="lineNum">   15700 </span>            : #endif</a>
<a name="15701"><span class="lineNum">   15701 </span>            : </a>
<a name="15702"><span class="lineNum">   15702 </span>            : </a>
<a name="15703"><span class="lineNum">   15703 </span>            : void</a>
<a name="15704"><span class="lineNum">   15704 </span><span class="lineNoCov">          0 : SageBuilder::fixupSourcePositionFileSpecification(SgNode* subtreeRoot, const std::string&amp; newFileName)</span></a>
<a name="15705"><span class="lineNum">   15705 </span>            :    {</a>
<a name="15706"><span class="lineNum">   15706 </span>            :   // DQ (11/8/2019): This function changes the filename designation in all of the Sg_File_Info objects</a>
<a name="15707"><span class="lineNum">   15707 </span>            :   // associated with the designated AST subtree.</a>
<a name="15708"><span class="lineNum">   15708 </span>            : </a>
<a name="15709"><span class="lineNum">   15709 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(subtreeRoot != NULL);</span></a>
<a name="15710"><span class="lineNum">   15710 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(newFileName != &quot;&quot;);</span></a>
<a name="15711"><span class="lineNum">   15711 </span>            : </a>
<a name="15712"><span class="lineNum">   15712 </span>            : #define DEBUG_FIXUP 0</a>
<a name="15713"><span class="lineNum">   15713 </span>            : </a>
<a name="15714"><span class="lineNum">   15714 </span>            : #if DEBUG_FIXUP</a>
<a name="15715"><span class="lineNum">   15715 </span>            :      printf (&quot;In SageBuilder::fixupSourcePositionFileSpecification(): newFileName = %s \n&quot;,newFileName.c_str());</a>
<a name="15716"><span class="lineNum">   15716 </span>            :      printf (&quot;In SageBuilder::fixupSourcePositionFileSpecification(): subtreeRoot = %p = %s \n&quot;,subtreeRoot,subtreeRoot-&gt;class_name().c_str());</a>
<a name="15717"><span class="lineNum">   15717 </span>            : #endif</a>
<a name="15718"><span class="lineNum">   15718 </span>            : </a>
<a name="15719"><span class="lineNum">   15719 </span><span class="lineNoCov">          0 :      class Traversal : public AstSimpleProcessing</span></a>
<a name="15720"><span class="lineNum">   15720 </span>            :         {</a>
<a name="15721"><span class="lineNum">   15721 </span>            :           public:</a>
<a name="15722"><span class="lineNum">   15722 </span>            : </a>
<a name="15723"><span class="lineNum">   15723 </span><span class="lineNoCov">          0 :                Traversal(const std::string&amp; tmp_newFileName, int tmp_new_file_id, int tmp_originalFileId)</span></a>
<a name="15724"><span class="lineNum">   15724 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="15725"><span class="lineNum">   15725 </span><span class="lineNoCov">          0 :                     newFileName    = tmp_newFileName;</span></a>
<a name="15726"><span class="lineNum">   15726 </span><span class="lineNoCov">          0 :                     new_file_id    = tmp_new_file_id;</span></a>
<a name="15727"><span class="lineNum">   15727 </span><span class="lineNoCov">          0 :                     originalFileId = tmp_originalFileId;</span></a>
<a name="15728"><span class="lineNum">   15728 </span>            : #if DEBUG_FIXUP</a>
<a name="15729"><span class="lineNum">   15729 </span>            :                     printf (&quot;In SageBuilder::fixupSourcePositionFileSpecification(): newFileName = %s new_file_id = %d originalFileId = %d \n&quot;,newFileName.c_str(),new_file_id,originalFileId);</a>
<a name="15730"><span class="lineNum">   15730 </span>            : #endif</a>
<a name="15731"><span class="lineNum">   15731 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="15732"><span class="lineNum">   15732 </span>            : </a>
<a name="15733"><span class="lineNum">   15733 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="15734"><span class="lineNum">   15734 </span>            :                   {</a>
<a name="15735"><span class="lineNum">   15735 </span>            : #if DEBUG_FIXUP</a>
<a name="15736"><span class="lineNum">   15736 </span>            :                     printf (&quot;In fixupSourcePositionFileSpecification visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="15737"><span class="lineNum">   15737 </span>            : #endif</a>
<a name="15738"><span class="lineNum">   15738 </span>            : </a>
<a name="15739"><span class="lineNum">   15739 </span><span class="lineNoCov">          0 :                     SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="15740"><span class="lineNum">   15740 </span><span class="lineNoCov">          0 :                     if (locatedNode != NULL)</span></a>
<a name="15741"><span class="lineNum">   15741 </span>            :                        {</a>
<a name="15742"><span class="lineNum">   15742 </span>            :                       // if (locatedNode-&gt;get_startOfConstruct()-&gt;get_file_id() == originalFileId)</a>
<a name="15743"><span class="lineNum">   15743 </span><span class="lineNoCov">          0 :                          if (locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id() == originalFileId)</span></a>
<a name="15744"><span class="lineNum">   15744 </span>            :                             {</a>
<a name="15745"><span class="lineNum">   15745 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="15746"><span class="lineNum">   15746 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="15747"><span class="lineNum">   15747 </span>            : </a>
<a name="15748"><span class="lineNum">   15748 </span><span class="lineNoCov">          0 :                               if (locatedNode-&gt;get_startOfConstruct()-&gt;isShared() == true)</span></a>
<a name="15749"><span class="lineNum">   15749 </span>            :                                  {</a>
<a name="15750"><span class="lineNum">   15750 </span>            : #if DEBUG_FIXUP</a>
<a name="15751"><span class="lineNum">   15751 </span>            :                                    printf (&quot;Found SgLocatedNode marked as isShared() == true: locatedNode = %p = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="15752"><span class="lineNum">   15752 </span>            : #endif</a>
<a name="15753"><span class="lineNum">   15753 </span>            : #if 0</a>
<a name="15754"><span class="lineNum">   15754 </span>            :                                    printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15755"><span class="lineNum">   15755 </span>            :                                    ROSE_ABORT();</a>
<a name="15756"><span class="lineNum">   15756 </span>            : #endif</a>
<a name="15757"><span class="lineNum">   15757 </span>            :                                  }</a>
<a name="15758"><span class="lineNum">   15758 </span><span class="lineNoCov">          0 :                               locatedNode-&gt;get_startOfConstruct()-&gt;set_file_id(new_file_id);</span></a>
<a name="15759"><span class="lineNum">   15759 </span><span class="lineNoCov">          0 :                               locatedNode-&gt;get_endOfConstruct  ()-&gt;set_file_id(new_file_id);</span></a>
<a name="15760"><span class="lineNum">   15760 </span>            : </a>
<a name="15761"><span class="lineNum">   15761 </span><span class="lineNoCov">          0 :                               locatedNode-&gt;get_startOfConstruct()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15762"><span class="lineNum">   15762 </span><span class="lineNoCov">          0 :                               locatedNode-&gt;get_endOfConstruct  ()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15763"><span class="lineNum">   15763 </span>            : </a>
<a name="15764"><span class="lineNum">   15764 </span>            : #if DEBUG_FIXUP</a>
<a name="15765"><span class="lineNum">   15765 </span>            :                               printf (&quot;locatedNode-&gt;get_startOfConstruct()-&gt;get_filename() = %s locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_filename() = %s \n&quot;,</a>
<a name="15766"><span class="lineNum">   15766 </span>            :                                    locatedNode-&gt;get_startOfConstruct()-&gt;get_filenameString().c_str(),locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_filename().c_str());</a>
<a name="15767"><span class="lineNum">   15767 </span>            :                               printf (&quot;locatedNode-&gt;get_startOfConstruct()-&gt;get_file_id() = %d locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,</a>
<a name="15768"><span class="lineNum">   15768 </span>            :                                    locatedNode-&gt;get_startOfConstruct()-&gt;get_file_id(),locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id());</a>
<a name="15769"><span class="lineNum">   15769 </span>            :                               printf (&quot;locatedNode-&gt;get_startOfConstruct()-&gt;isShared() = %s \n&quot;,locatedNode-&gt;get_startOfConstruct()-&gt;isShared() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15770"><span class="lineNum">   15770 </span>            : #endif</a>
<a name="15771"><span class="lineNum">   15771 </span>            :                             }</a>
<a name="15772"><span class="lineNum">   15772 </span>            :                            else</a>
<a name="15773"><span class="lineNum">   15773 </span>            :                             {</a>
<a name="15774"><span class="lineNum">   15774 </span>            : #if DEBUG_FIXUP</a>
<a name="15775"><span class="lineNum">   15775 </span>            :                               printf (&quot;NOT MATCHING: originalFileId = %d locatedNode-&gt;get_startOfConstruct()-&gt;get_file_id() = %d locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,</a>
<a name="15776"><span class="lineNum">   15776 </span>            :                                       originalFileId,locatedNode-&gt;get_startOfConstruct()-&gt;get_file_id(),locatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id());</a>
<a name="15777"><span class="lineNum">   15777 </span>            :                               printf (&quot; ------------ originalFileId = %d locatedNode-&gt;get_endOfConstruct()-&gt;get_file_id() = %d locatedNode-&gt;get_endOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,</a>
<a name="15778"><span class="lineNum">   15778 </span>            :                                       originalFileId,locatedNode-&gt;get_endOfConstruct()-&gt;get_file_id(),locatedNode-&gt;get_endOfConstruct()-&gt;get_physical_file_id());</a>
<a name="15779"><span class="lineNum">   15779 </span>            : #endif</a>
<a name="15780"><span class="lineNum">   15780 </span>            :                             }</a>
<a name="15781"><span class="lineNum">   15781 </span>            :                        }</a>
<a name="15782"><span class="lineNum">   15782 </span>            :                       else</a>
<a name="15783"><span class="lineNum">   15783 </span>            :                        {</a>
<a name="15784"><span class="lineNum">   15784 </span><span class="lineNoCov">          0 :                          SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="15785"><span class="lineNum">   15785 </span><span class="lineNoCov">          0 :                          if (initializedName != NULL)</span></a>
<a name="15786"><span class="lineNum">   15786 </span>            :                             {</a>
<a name="15787"><span class="lineNum">   15787 </span>            :                            // if (initializedName-&gt;get_startOfConstruct()-&gt;get_file_id() == originalFileId)</a>
<a name="15788"><span class="lineNum">   15788 </span><span class="lineNoCov">          0 :                               if (initializedName-&gt;get_startOfConstruct()-&gt;get_physical_file_id() == originalFileId)</span></a>
<a name="15789"><span class="lineNum">   15789 </span>            :                                  {</a>
<a name="15790"><span class="lineNum">   15790 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(initializedName-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="15791"><span class="lineNum">   15791 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(initializedName-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="15792"><span class="lineNum">   15792 </span>            : </a>
<a name="15793"><span class="lineNum">   15793 </span><span class="lineNoCov">          0 :                                    initializedName-&gt;get_startOfConstruct()-&gt;set_file_id(new_file_id);</span></a>
<a name="15794"><span class="lineNum">   15794 </span><span class="lineNoCov">          0 :                                    initializedName-&gt;get_endOfConstruct  ()-&gt;set_file_id(new_file_id);</span></a>
<a name="15795"><span class="lineNum">   15795 </span>            : </a>
<a name="15796"><span class="lineNum">   15796 </span><span class="lineNoCov">          0 :                                    initializedName-&gt;get_startOfConstruct()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15797"><span class="lineNum">   15797 </span><span class="lineNoCov">          0 :                                    initializedName-&gt;get_endOfConstruct  ()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15798"><span class="lineNum">   15798 </span>            :                                  }</a>
<a name="15799"><span class="lineNum">   15799 </span>            :                             }</a>
<a name="15800"><span class="lineNum">   15800 </span>            :                            else</a>
<a name="15801"><span class="lineNum">   15801 </span>            :                             {</a>
<a name="15802"><span class="lineNum">   15802 </span><span class="lineNoCov">          0 :                               SgSourceFile* sourceFile = isSgSourceFile(node);</span></a>
<a name="15803"><span class="lineNum">   15803 </span><span class="lineNoCov">          0 :                               if (sourceFile != NULL)</span></a>
<a name="15804"><span class="lineNum">   15804 </span>            :                                  {</a>
<a name="15805"><span class="lineNum">   15805 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(sourceFile-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="15806"><span class="lineNum">   15806 </span>            : #if 0</a>
<a name="15807"><span class="lineNum">   15807 </span>            :                                 // A SgSourceFile has no endOfConstruct.</a>
<a name="15808"><span class="lineNum">   15808 </span>            :                                    if (sourceFile-&gt;get_endOfConstruct() == NULL)</a>
<a name="15809"><span class="lineNum">   15809 </span>            :                                       {</a>
<a name="15810"><span class="lineNum">   15810 </span>            : #if 0</a>
<a name="15811"><span class="lineNum">   15811 </span>            :                                         printf (&quot;sourceFile-&gt;get_endOfConstruct() == NULL: fixup endOfConstruct \n&quot;);</a>
<a name="15812"><span class="lineNum">   15812 </span>            : #endif</a>
<a name="15813"><span class="lineNum">   15813 </span>            :                                         sourceFile-&gt;set_endOfConstruct(new Sg_File_Info());</a>
<a name="15814"><span class="lineNum">   15814 </span>            :                                         *(sourceFile-&gt;get_endOfConstruct()) = *(sourceFile-&gt;get_startOfConstruct());</a>
<a name="15815"><span class="lineNum">   15815 </span>            :                                       }</a>
<a name="15816"><span class="lineNum">   15816 </span>            :                                    ROSE_ASSERT(sourceFile-&gt;get_endOfConstruct() != NULL);</a>
<a name="15817"><span class="lineNum">   15817 </span>            : #endif</a>
<a name="15818"><span class="lineNum">   15818 </span>            :                                 // Need to test the physical_file_id because we already set the regular file_id (as part of seeding the process).</a>
<a name="15819"><span class="lineNum">   15819 </span>            :                                 // if (sourceFile-&gt;get_startOfConstruct()-&gt;get_file_id() == originalFileId)</a>
<a name="15820"><span class="lineNum">   15820 </span><span class="lineNoCov">          0 :                                    if (sourceFile-&gt;get_startOfConstruct()-&gt;get_physical_file_id() == originalFileId)</span></a>
<a name="15821"><span class="lineNum">   15821 </span>            :                                       {</a>
<a name="15822"><span class="lineNum">   15822 </span><span class="lineNoCov">          0 :                                         sourceFile-&gt;get_startOfConstruct()-&gt;set_file_id(new_file_id);</span></a>
<a name="15823"><span class="lineNum">   15823 </span><span class="lineNoCov">          0 :                                         sourceFile-&gt;get_startOfConstruct()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15824"><span class="lineNum">   15824 </span>            : #if DEBUG_FIXUP</a>
<a name="15825"><span class="lineNum">   15825 </span>            :                                         printf (&quot;sourceFile-&gt;get_startOfConstruct()-&gt;get_file_id()          = %d \n&quot;,sourceFile-&gt;get_startOfConstruct()-&gt;get_file_id());</a>
<a name="15826"><span class="lineNum">   15826 </span>            :                                         printf (&quot;sourceFile-&gt;get_startOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,sourceFile-&gt;get_startOfConstruct()-&gt;get_physical_file_id());</a>
<a name="15827"><span class="lineNum">   15827 </span>            : #endif</a>
<a name="15828"><span class="lineNum">   15828 </span>            :                                      // sourceFile-&gt;get_endOfConstruct  ()-&gt;set_file_id(new_file_id);</a>
<a name="15829"><span class="lineNum">   15829 </span>            :                                      // sourceFile-&gt;get_endOfConstruct  ()-&gt;set_physical_file_id(new_file_id);</a>
<a name="15830"><span class="lineNum">   15830 </span>            :                                       }</a>
<a name="15831"><span class="lineNum">   15831 </span>            :                                  }</a>
<a name="15832"><span class="lineNum">   15832 </span>            :                                 else</a>
<a name="15833"><span class="lineNum">   15833 </span>            :                                  {</a>
<a name="15834"><span class="lineNum">   15834 </span>            : #if DEBUG_FIXUP</a>
<a name="15835"><span class="lineNum">   15835 </span>            :                                    printf (&quot;Unhandled: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="15836"><span class="lineNum">   15836 </span>            : #endif</a>
<a name="15837"><span class="lineNum">   15837 </span>            :                                  }</a>
<a name="15838"><span class="lineNum">   15838 </span>            :                             }</a>
<a name="15839"><span class="lineNum">   15839 </span>            :                        }</a>
<a name="15840"><span class="lineNum">   15840 </span>            : </a>
<a name="15841"><span class="lineNum">   15841 </span><span class="lineNoCov">          0 :                     SgExpression* expression = isSgExpression(node);</span></a>
<a name="15842"><span class="lineNum">   15842 </span><span class="lineNoCov">          0 :                     if (expression != NULL)</span></a>
<a name="15843"><span class="lineNum">   15843 </span>            :                        {</a>
<a name="15844"><span class="lineNum">   15844 </span><span class="lineNoCov">          0 :                          if (expression-&gt;get_operatorPosition()-&gt;get_physical_file_id() == originalFileId)</span></a>
<a name="15845"><span class="lineNum">   15845 </span>            :                             {</a>
<a name="15846"><span class="lineNum">   15846 </span><span class="lineNoCov">          0 :                               expression-&gt;get_operatorPosition()-&gt;set_file_id(new_file_id);</span></a>
<a name="15847"><span class="lineNum">   15847 </span><span class="lineNoCov">          0 :                               expression-&gt;get_operatorPosition()-&gt;set_physical_file_id(new_file_id);</span></a>
<a name="15848"><span class="lineNum">   15848 </span>            :                             }</a>
<a name="15849"><span class="lineNum">   15849 </span>            :                        }</a>
<a name="15850"><span class="lineNum">   15850 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="15851"><span class="lineNum">   15851 </span>            : </a>
<a name="15852"><span class="lineNum">   15852 </span>            :              // Data members.</a>
<a name="15853"><span class="lineNum">   15853 </span>            :                int new_file_id;</a>
<a name="15854"><span class="lineNum">   15854 </span>            :                int originalFileId;</a>
<a name="15855"><span class="lineNum">   15855 </span>            :                string newFileName;</a>
<a name="15856"><span class="lineNum">   15856 </span>            :         };</a>
<a name="15857"><span class="lineNum">   15857 </span>            : </a>
<a name="15858"><span class="lineNum">   15858 </span>            : </a>
<a name="15859"><span class="lineNum">   15859 </span><span class="lineNoCov">          0 :      SgFile* file       = isSgFile(subtreeRoot);</span></a>
<a name="15860"><span class="lineNum">   15860 </span><span class="lineNoCov">          0 :      int new_file_id    = -1;</span></a>
<a name="15861"><span class="lineNum">   15861 </span><span class="lineNoCov">          0 :      int originalFileId = -1;</span></a>
<a name="15862"><span class="lineNum">   15862 </span>            : </a>
<a name="15863"><span class="lineNum">   15863 </span><span class="lineNoCov">          0 :      if (file != NULL)</span></a>
<a name="15864"><span class="lineNum">   15864 </span>            :         {</a>
<a name="15865"><span class="lineNum">   15865 </span>            :        // We need to set the filename in at least one Sg_File_Info object so that we can have</a>
<a name="15866"><span class="lineNum">   15866 </span>            :        // the file_id be computed ans saved into the file_id to filename maps.</a>
<a name="15867"><span class="lineNum">   15867 </span>            : </a>
<a name="15868"><span class="lineNum">   15868 </span><span class="lineNoCov">          0 :           originalFileId = file-&gt;get_startOfConstruct()-&gt;get_file_id();</span></a>
<a name="15869"><span class="lineNum">   15869 </span>            : #if DEBUG_FIXUP</a>
<a name="15870"><span class="lineNum">   15870 </span>            :           printf (&quot;originalFileId = %d \n&quot;,originalFileId);</a>
<a name="15871"><span class="lineNum">   15871 </span>            : #endif</a>
<a name="15872"><span class="lineNum">   15872 </span><span class="lineNoCov">          0 :           file-&gt;get_startOfConstruct()-&gt;set_filenameString(newFileName);</span></a>
<a name="15873"><span class="lineNum">   15873 </span><span class="lineNoCov">          0 :           new_file_id = Sg_File_Info::get_nametofileid_map()[newFileName];</span></a>
<a name="15874"><span class="lineNum">   15874 </span>            : </a>
<a name="15875"><span class="lineNum">   15875 </span>            : </a>
<a name="15876"><span class="lineNum">   15876 </span>            : #if 0</a>
<a name="15877"><span class="lineNum">   15877 </span>            :           file-&gt;get_endOfConstruct()-&gt;set_physical_file_id(new_file_id);</a>
<a name="15878"><span class="lineNum">   15878 </span>            : </a>
<a name="15879"><span class="lineNum">   15879 </span>            :           file-&gt;get_startOfConstruct()-&gt;set_physical_file_id(new_file_id);</a>
<a name="15880"><span class="lineNum">   15880 </span>            :           file-&gt;get_endOfConstruct()-&gt;set_physical_file_id(new_file_id);</a>
<a name="15881"><span class="lineNum">   15881 </span>            : </a>
<a name="15882"><span class="lineNum">   15882 </span>            :                                              // getFilenameFromID</a>
<a name="15883"><span class="lineNum">   15883 </span>            :           int new_file_id_2     = Sg_File_Info::getIDFromFilename(newFileName);</a>
<a name="15884"><span class="lineNum">   15884 </span>            : #if 0</a>
<a name="15885"><span class="lineNum">   15885 </span>            :           printf (&quot;new_file_id = %d new_file_id_2 = %d \n&quot;,new_file_id,new_file_id_2);</a>
<a name="15886"><span class="lineNum">   15886 </span>            : #endif</a>
<a name="15887"><span class="lineNum">   15887 </span>            :           ROSE_ASSERT(new_file_id == new_file_id_2);</a>
<a name="15888"><span class="lineNum">   15888 </span>            : </a>
<a name="15889"><span class="lineNum">   15889 </span>            :           string new_filename_2 = Sg_File_Info::getFilenameFromID(new_file_id);</a>
<a name="15890"><span class="lineNum">   15890 </span>            : #if 0</a>
<a name="15891"><span class="lineNum">   15891 </span>            :           printf (&quot;newFileName = %s new_filename_2 = %s \n&quot;,newFileName.c_str(),new_filename_2.c_str());</a>
<a name="15892"><span class="lineNum">   15892 </span>            : #endif</a>
<a name="15893"><span class="lineNum">   15893 </span>            :           ROSE_ASSERT(newFileName == new_filename_2);</a>
<a name="15894"><span class="lineNum">   15894 </span>            : #endif</a>
<a name="15895"><span class="lineNum">   15895 </span>            : </a>
<a name="15896"><span class="lineNum">   15896 </span>            : #if DEBUG_FIXUP</a>
<a name="15897"><span class="lineNum">   15897 </span>            :           printf (&quot;In SageBuilder::fixupSourcePositionFileSpecification(): file != NULL: newFileName = %s new_file_id = %d \n&quot;,newFileName.c_str(),new_file_id);</a>
<a name="15898"><span class="lineNum">   15898 </span>            : #endif</a>
<a name="15899"><span class="lineNum">   15899 </span>            :         }</a>
<a name="15900"><span class="lineNum">   15900 </span>            :        else</a>
<a name="15901"><span class="lineNum">   15901 </span>            :         {</a>
<a name="15902"><span class="lineNum">   15902 </span><span class="lineNoCov">          0 :           SgLocatedNode* subtreeLocatedNode = isSgLocatedNode(subtreeRoot);</span></a>
<a name="15903"><span class="lineNum">   15903 </span><span class="lineNoCov">          0 :           if (subtreeLocatedNode != NULL)</span></a>
<a name="15904"><span class="lineNum">   15904 </span>            :              {</a>
<a name="15905"><span class="lineNum">   15905 </span>            : #if DEBUG_FIXUP</a>
<a name="15906"><span class="lineNum">   15906 </span>            :                printf (&quot;subtreeLocatedNode-&gt;get_startOfConstruct()-&gt;get_file_id()          = %d \n&quot;,subtreeLocatedNode-&gt;get_startOfConstruct()-&gt;get_file_id());</a>
<a name="15907"><span class="lineNum">   15907 </span>            :                printf (&quot;subtreeLocatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,subtreeLocatedNode-&gt;get_startOfConstruct()-&gt;get_physical_file_id());</a>
<a name="15908"><span class="lineNum">   15908 </span>            : #endif</a>
<a name="15909"><span class="lineNum">   15909 </span><span class="lineNoCov">          0 :                originalFileId = subtreeLocatedNode-&gt;get_startOfConstruct()-&gt;get_file_id();</span></a>
<a name="15910"><span class="lineNum">   15910 </span><span class="lineNoCov">          0 :                new_file_id = Sg_File_Info::getIDFromFilename(newFileName);</span></a>
<a name="15911"><span class="lineNum">   15911 </span>            : #if DEBUG_FIXUP</a>
<a name="15912"><span class="lineNum">   15912 </span>            :                printf (&quot;originalFileId = %d \n&quot;,originalFileId);</a>
<a name="15913"><span class="lineNum">   15913 </span>            :                printf (&quot;new_file_id    = %d \n&quot;,new_file_id);</a>
<a name="15914"><span class="lineNum">   15914 </span>            : #endif</a>
<a name="15915"><span class="lineNum">   15915 </span>            : #if DEBUG_FIXUP</a>
<a name="15916"><span class="lineNum">   15916 </span>            :                printf (&quot;In SageBuilder::fixupSourcePositionFileSpecification(): subtreeLocatedNode = %s : originalFileId = %d newFileName = %s new_file_id = %d \n&quot;,</a>
<a name="15917"><span class="lineNum">   15917 </span>            :                     subtreeLocatedNode-&gt;class_name().c_str(),originalFileId,newFileName.c_str(),new_file_id);</a>
<a name="15918"><span class="lineNum">   15918 </span>            : #endif</a>
<a name="15919"><span class="lineNum">   15919 </span>            :              }</a>
<a name="15920"><span class="lineNum">   15920 </span>            :             else</a>
<a name="15921"><span class="lineNum">   15921 </span>            :              {</a>
<a name="15922"><span class="lineNum">   15922 </span><span class="lineNoCov">          0 :                printf (&quot;Error: In SageBuilder::fixupSourcePositionFileSpecification(): subtree should be a SgFile or SgLocatedNode: subtreeRoot = %p = %s \n&quot;,subtreeRoot,subtreeRoot-&gt;class_name().c_str());</span></a>
<a name="15923"><span class="lineNum">   15923 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15924"><span class="lineNum">   15924 </span>            :              }</a>
<a name="15925"><span class="lineNum">   15925 </span>            : </a>
<a name="15926"><span class="lineNum">   15926 </span>            : #if 0</a>
<a name="15927"><span class="lineNum">   15927 </span>            :           printf (&quot;Error: In SageBuilder::fixupSourcePositionFileSpecification(): subtree should be a SgFile: subtreeRoot = %p = %s \n&quot;,subtreeRoot,subtreeRoot-&gt;class_name().c_str());</a>
<a name="15928"><span class="lineNum">   15928 </span>            :           ROSE_ABORT();</a>
<a name="15929"><span class="lineNum">   15929 </span>            : #endif</a>
<a name="15930"><span class="lineNum">   15930 </span>            :         }</a>
<a name="15931"><span class="lineNum">   15931 </span>            : </a>
<a name="15932"><span class="lineNum">   15932 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(new_file_id &gt;= 0);</span></a>
<a name="15933"><span class="lineNum">   15933 </span>            : </a>
<a name="15934"><span class="lineNum">   15934 </span>            :   // Now build the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="15935"><span class="lineNum">   15935 </span><span class="lineNoCov">          0 :      Traversal traversal (newFileName,new_file_id,originalFileId);</span></a>
<a name="15936"><span class="lineNum">   15936 </span>            : </a>
<a name="15937"><span class="lineNum">   15937 </span>            :   // traversal.traverse(subtreeRoot, preorder);</a>
<a name="15938"><span class="lineNum">   15938 </span>            :   // traversal.traverseInputFiles(subtreeRoot, preorder);</a>
<a name="15939"><span class="lineNum">   15939 </span>            :   // traversal.traverseWithinFile(subtreeRoot, preorder);</a>
<a name="15940"><span class="lineNum">   15940 </span><span class="lineNoCov">          0 :      traversal.traverse(subtreeRoot, preorder);</span></a>
<a name="15941"><span class="lineNum">   15941 </span>            : </a>
<a name="15942"><span class="lineNum">   15942 </span>            : #if 0</a>
<a name="15943"><span class="lineNum">   15943 </span>            :      printf (&quot;Exiting as a test in SageBuilder::fixupSourcePositionFileSpecification() \n&quot;);</a>
<a name="15944"><span class="lineNum">   15944 </span>            :      ROSE_ABORT();</a>
<a name="15945"><span class="lineNum">   15945 </span>            : #endif</a>
<a name="15946"><span class="lineNum">   15946 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="15947"><span class="lineNum">   15947 </span>            : </a>
<a name="15948"><span class="lineNum">   15948 </span>            : </a>
<a name="15949"><span class="lineNum">   15949 </span>            : </a>
<a name="15950"><span class="lineNum">   15950 </span>            : </a>
<a name="15951"><span class="lineNum">   15951 </span>            : </a>
<a name="15952"><span class="lineNum">   15952 </span>            : </a>
<a name="15953"><span class="lineNum">   15953 </span>            : </a>
<a name="15954"><span class="lineNum">   15954 </span>            : </a>
<a name="15955"><span class="lineNum">   15955 </span>            : void</a>
<a name="15956"><span class="lineNum">   15956 </span><span class="lineNoCov">          0 : SageBuilder::fixupSharingSourcePosition(SgNode* subtreeRoot, int new_file_id)</span></a>
<a name="15957"><span class="lineNum">   15957 </span>            :    {</a>
<a name="15958"><span class="lineNum">   15958 </span>            :   // DQ (11/8/2019): This function changes the filename designation in all of the Sg_File_Info objects</a>
<a name="15959"><span class="lineNum">   15959 </span>            :   // associated with the designated AST subtree.</a>
<a name="15960"><span class="lineNum">   15960 </span>            : </a>
<a name="15961"><span class="lineNum">   15961 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(subtreeRoot != NULL);</span></a>
<a name="15962"><span class="lineNum">   15962 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(new_file_id &gt;= 0);</span></a>
<a name="15963"><span class="lineNum">   15963 </span>            : </a>
<a name="15964"><span class="lineNum">   15964 </span>            : #if 0</a>
<a name="15965"><span class="lineNum">   15965 </span>            :      printf (&quot;In SageBuilder::fixupSharingSourcePosition(): subtreeRoot = %p = %s \n&quot;,subtreeRoot,subtreeRoot-&gt;class_name().c_str());</a>
<a name="15966"><span class="lineNum">   15966 </span>            :      printf (&quot;In SageBuilder::fixupSharingSourcePosition(): new_file_id = %d \n&quot;,new_file_id);</a>
<a name="15967"><span class="lineNum">   15967 </span>            : #endif</a>
<a name="15968"><span class="lineNum">   15968 </span>            : </a>
<a name="15969"><span class="lineNum">   15969 </span><span class="lineNoCov">          0 :      class Traversal : public AstSimpleProcessing</span></a>
<a name="15970"><span class="lineNum">   15970 </span>            :         {</a>
<a name="15971"><span class="lineNum">   15971 </span>            :           public:</a>
<a name="15972"><span class="lineNum">   15972 </span>            : </a>
<a name="15973"><span class="lineNum">   15973 </span><span class="lineNoCov">          0 :                Traversal(int tmp_new_file_id)</span></a>
<a name="15974"><span class="lineNum">   15974 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="15975"><span class="lineNum">   15975 </span><span class="lineNoCov">          0 :                     new_file_id    = tmp_new_file_id;</span></a>
<a name="15976"><span class="lineNum">   15976 </span>            : #if 0</a>
<a name="15977"><span class="lineNum">   15977 </span>            :                     printf (&quot;In SageBuilder::fixupSharingSourcePosition(): new_file_id = %d \n&quot;,new_file_id);</a>
<a name="15978"><span class="lineNum">   15978 </span>            : #endif</a>
<a name="15979"><span class="lineNum">   15979 </span>            :                   }</a>
<a name="15980"><span class="lineNum">   15980 </span>            : </a>
<a name="15981"><span class="lineNum">   15981 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="15982"><span class="lineNum">   15982 </span>            :                   {</a>
<a name="15983"><span class="lineNum">   15983 </span>            : #if 0</a>
<a name="15984"><span class="lineNum">   15984 </span>            :                     printf (&quot;In fixupSharingSourcePosition visit(): node = %p = %s new_file_id = %d \n&quot;,node,node-&gt;class_name().c_str(),new_file_id);</a>
<a name="15985"><span class="lineNum">   15985 </span>            : #endif</a>
<a name="15986"><span class="lineNum">   15986 </span>            : </a>
<a name="15987"><span class="lineNum">   15987 </span><span class="lineNoCov">          0 :                     SgStatement* statement = isSgStatement(node);</span></a>
<a name="15988"><span class="lineNum">   15988 </span><span class="lineNoCov">          0 :                     if (statement != NULL)</span></a>
<a name="15989"><span class="lineNum">   15989 </span>            :                        {</a>
<a name="15990"><span class="lineNum">   15990 </span><span class="lineNoCov">          0 :                          Sg_File_Info* startOfConstruct = statement-&gt;get_startOfConstruct();</span></a>
<a name="15991"><span class="lineNum">   15991 </span><span class="lineNoCov">          0 :                          Sg_File_Info* endOfConstruct   = statement-&gt;get_endOfConstruct();</span></a>
<a name="15992"><span class="lineNum">   15992 </span>            : #if 0</a>
<a name="15993"><span class="lineNum">   15993 </span>            :                          printf (&quot;new_file_id = %d startOfConstruct-&gt;get_physical_file_id() = %d \n&quot;,new_file_id,startOfConstruct-&gt;get_physical_file_id());</a>
<a name="15994"><span class="lineNum">   15994 </span>            : #endif</a>
<a name="15995"><span class="lineNum">   15995 </span>            :                       // Only mark the files from the associated file (not statements in header files, for example).</a>
<a name="15996"><span class="lineNum">   15996 </span><span class="lineNoCov">          0 :                          if (startOfConstruct-&gt;get_physical_file_id() == new_file_id)</span></a>
<a name="15997"><span class="lineNum">   15997 </span>            :                             {</a>
<a name="15998"><span class="lineNum">   15998 </span>            :                            // Mark this IR node as being shared</a>
<a name="15999"><span class="lineNum">   15999 </span><span class="lineNoCov">          0 :                               startOfConstruct-&gt;setShared();</span></a>
<a name="16000"><span class="lineNum">   16000 </span><span class="lineNoCov">          0 :                               endOfConstruct-&gt;setShared();</span></a>
<a name="16001"><span class="lineNum">   16001 </span>            : </a>
<a name="16002"><span class="lineNum">   16002 </span>            :                            // Add this file_id to those file_id that will trigger this IR node to be unparsed.</a>
<a name="16003"><span class="lineNum">   16003 </span>            : #if 0</a>
<a name="16004"><span class="lineNum">   16004 </span>            :                               printf (&quot;  --- adding entries for file_id and line number to support sharing: new_file_id = %d line = %d end line = %d \n&quot;,</a>
<a name="16005"><span class="lineNum">   16005 </span>            :                                    new_file_id,startOfConstruct-&gt;get_line(),endOfConstruct-&gt;get_line());</a>
<a name="16006"><span class="lineNum">   16006 </span>            : #endif</a>
<a name="16007"><span class="lineNum">   16007 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(startOfConstruct-&gt;get_fileIDsToUnparse().size() == startOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16008"><span class="lineNum">   16008 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(endOfConstruct-&gt;get_fileIDsToUnparse().size()   == endOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16009"><span class="lineNum">   16009 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(startOfConstruct-&gt;get_fileIDsToUnparse().size() == endOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16010"><span class="lineNum">   16010 </span>            : </a>
<a name="16011"><span class="lineNum">   16011 </span>            :                            // Add this existing_fi-&gt;get_file_id() to the list of file id's that will permit the assocated language construct to be unparsed.</a>
<a name="16012"><span class="lineNum">   16012 </span><span class="lineNoCov">          0 :                               startOfConstruct-&gt;get_fileIDsToUnparse().push_back(new_file_id);</span></a>
<a name="16013"><span class="lineNum">   16013 </span><span class="lineNoCov">          0 :                               startOfConstruct-&gt;get_fileLineNumbersToUnparse().push_back(startOfConstruct-&gt;get_line());</span></a>
<a name="16014"><span class="lineNum">   16014 </span>            : </a>
<a name="16015"><span class="lineNum">   16015 </span><span class="lineNoCov">          0 :                               endOfConstruct-&gt;get_fileIDsToUnparse().push_back(new_file_id);</span></a>
<a name="16016"><span class="lineNum">   16016 </span><span class="lineNoCov">          0 :                               endOfConstruct-&gt;get_fileLineNumbersToUnparse().push_back(endOfConstruct-&gt;get_line());</span></a>
<a name="16017"><span class="lineNum">   16017 </span>            : </a>
<a name="16018"><span class="lineNum">   16018 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(startOfConstruct-&gt;get_fileIDsToUnparse().size() == startOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16019"><span class="lineNum">   16019 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(endOfConstruct-&gt;get_fileIDsToUnparse().size()   == endOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16020"><span class="lineNum">   16020 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(startOfConstruct-&gt;get_fileIDsToUnparse().size() == endOfConstruct-&gt;get_fileLineNumbersToUnparse().size());</span></a>
<a name="16021"><span class="lineNum">   16021 </span>            :                             }</a>
<a name="16022"><span class="lineNum">   16022 </span>            :                        }</a>
<a name="16023"><span class="lineNum">   16023 </span>            :                       else</a>
<a name="16024"><span class="lineNum">   16024 </span>            :                        {</a>
<a name="16025"><span class="lineNum">   16025 </span>            : #if 0</a>
<a name="16026"><span class="lineNum">   16026 </span>            :                          printf (&quot;Unhandled: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="16027"><span class="lineNum">   16027 </span>            : #endif</a>
<a name="16028"><span class="lineNum">   16028 </span>            :                        }</a>
<a name="16029"><span class="lineNum">   16029 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="16030"><span class="lineNum">   16030 </span>            : </a>
<a name="16031"><span class="lineNum">   16031 </span>            :             // Data members.</a>
<a name="16032"><span class="lineNum">   16032 </span>            :                int new_file_id;</a>
<a name="16033"><span class="lineNum">   16033 </span>            :         };</a>
<a name="16034"><span class="lineNum">   16034 </span>            : </a>
<a name="16035"><span class="lineNum">   16035 </span>            : </a>
<a name="16036"><span class="lineNum">   16036 </span><span class="lineNoCov">          0 :      SgStatement* statement = isSgStatement(subtreeRoot);</span></a>
<a name="16037"><span class="lineNum">   16037 </span><span class="lineNoCov">          0 :      if (statement != NULL)</span></a>
<a name="16038"><span class="lineNum">   16038 </span>            :         {</a>
<a name="16039"><span class="lineNum">   16039 </span>            : #if 0</a>
<a name="16040"><span class="lineNum">   16040 </span>            :           printf (&quot;statement-&gt;get_startOfConstruct()-&gt;get_file_id()          = %d \n&quot;,statement-&gt;get_startOfConstruct()-&gt;get_file_id());</a>
<a name="16041"><span class="lineNum">   16041 </span>            :           printf (&quot;statement-&gt;get_startOfConstruct()-&gt;get_physical_file_id() = %d \n&quot;,statement-&gt;get_startOfConstruct()-&gt;get_physical_file_id());</a>
<a name="16042"><span class="lineNum">   16042 </span>            : #endif</a>
<a name="16043"><span class="lineNum">   16043 </span>            : #if 0</a>
<a name="16044"><span class="lineNum">   16044 </span>            :           printf (&quot;new_file_id    = %d \n&quot;,new_file_id);</a>
<a name="16045"><span class="lineNum">   16045 </span>            : #endif</a>
<a name="16046"><span class="lineNum">   16046 </span>            : #if 0</a>
<a name="16047"><span class="lineNum">   16047 </span>            :           printf (&quot;In SageBuilder::fixupSharingSourcePosition(): statement = %s : new_file_id = %d \n&quot;,statement-&gt;class_name().c_str(),new_file_id);</a>
<a name="16048"><span class="lineNum">   16048 </span>            : #endif</a>
<a name="16049"><span class="lineNum">   16049 </span>            :         }</a>
<a name="16050"><span class="lineNum">   16050 </span>            :        else</a>
<a name="16051"><span class="lineNum">   16051 </span>            :         {</a>
<a name="16052"><span class="lineNum">   16052 </span><span class="lineNoCov">          0 :           printf (&quot;Error: In SageBuilder::fixupSharingSourcePosition(): subtree should be a SgFile or SgLocatedNode: subtreeRoot = %p = %s \n&quot;,subtreeRoot,subtreeRoot-&gt;class_name().c_str());</span></a>
<a name="16053"><span class="lineNum">   16053 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="16054"><span class="lineNum">   16054 </span>            :         }</a>
<a name="16055"><span class="lineNum">   16055 </span>            : </a>
<a name="16056"><span class="lineNum">   16056 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(new_file_id &gt;= 0);</span></a>
<a name="16057"><span class="lineNum">   16057 </span>            : </a>
<a name="16058"><span class="lineNum">   16058 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="16059"><span class="lineNum">   16059 </span><span class="lineNoCov">          0 :      Traversal traversal (new_file_id);</span></a>
<a name="16060"><span class="lineNum">   16060 </span>            : </a>
<a name="16061"><span class="lineNum">   16061 </span>            :   // traversal.traverse(subtreeRoot, preorder);</a>
<a name="16062"><span class="lineNum">   16062 </span>            :   // traversal.traverseInputFiles(subtreeRoot, preorder);</a>
<a name="16063"><span class="lineNum">   16063 </span>            :   // traversal.traverseWithinFile(subtreeRoot, preorder);</a>
<a name="16064"><span class="lineNum">   16064 </span><span class="lineNoCov">          0 :      traversal.traverse(subtreeRoot, preorder);</span></a>
<a name="16065"><span class="lineNum">   16065 </span>            : </a>
<a name="16066"><span class="lineNum">   16066 </span>            : #if 0</a>
<a name="16067"><span class="lineNum">   16067 </span>            :      printf (&quot;Exiting as a test in SageBuilder::fixupSharingSourcePosition() \n&quot;);</a>
<a name="16068"><span class="lineNum">   16068 </span>            :      ROSE_ABORT();</a>
<a name="16069"><span class="lineNum">   16069 </span>            : #endif</a>
<a name="16070"><span class="lineNum">   16070 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="16071"><span class="lineNum">   16071 </span>            : </a>
<a name="16072"><span class="lineNum">   16072 </span>            : </a>
<a name="16073"><span class="lineNum">   16073 </span>            : </a>
<a name="16074"><span class="lineNum">   16074 </span>            : </a>
<a name="16075"><span class="lineNum">   16075 </span>            : </a>
<a name="16076"><span class="lineNum">   16076 </span>            :   //! Build a SgFile node</a>
<a name="16077"><span class="lineNum">   16077 </span>            : SgFile*</a>
<a name="16078"><span class="lineNum">   16078 </span><span class="lineCov">          4 : SageBuilder::buildFile(const std::string&amp; inputFileName, const std::string&amp; outputFileName, SgProject* project/*=NULL*/, bool clear_globalScopeAcrossFiles /*=false*/)</span></a>
<a name="16079"><span class="lineNum">   16079 </span>            :    {</a>
<a name="16080"><span class="lineNum">   16080 </span>            : // Note that ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT defines a reduced set of ROSE to support front-end specific development.</a>
<a name="16081"><span class="lineNum">   16081 </span>            : // It is mostly used by quinlan to support laptop development where the smaller set of files permits one to do limited</a>
<a name="16082"><span class="lineNum">   16082 </span>            : // development work on a Mac (even with OSX's poor performance with large numbers of debug symbols).  This is an</a>
<a name="16083"><span class="lineNum">   16083 </span>            : // infrequently used option.</a>
<a name="16084"><span class="lineNum">   16084 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="16085"><span class="lineNum">   16085 </span>            : </a>
<a name="16086"><span class="lineNum">   16086 </span>            : #if 0</a>
<a name="16087"><span class="lineNum">   16087 </span>            :      printf (&quot;In SageBuilder::buildFile(inputFileName = %s, outputFileName = %s, project = %p) \n&quot;,inputFileName.c_str(),outputFileName.c_str(),project);</a>
<a name="16088"><span class="lineNum">   16088 </span>            :   // printf (&quot; --- fullname = %s \n&quot;,fullname.c_str());</a>
<a name="16089"><span class="lineNum">   16089 </span>            : #endif</a>
<a name="16090"><span class="lineNum">   16090 </span>            : </a>
<a name="16091"><span class="lineNum">   16091 </span><span class="lineCov">          4 :      ROSE_ASSERT(inputFileName.size() != 0); // empty file name is not allowed.</span></a>
<a name="16092"><span class="lineNum">   16092 </span>            : </a>
<a name="16093"><span class="lineNum">   16093 </span>            :   // DQ (9/18/2019): I am unclear what the use of fullname is below.</a>
<a name="16094"><span class="lineNum">   16094 </span>            :   // string sourceFilename = inputFileName, fullname;</a>
<a name="16095"><span class="lineNum">   16095 </span>            :   // string sourceFilename_fullname = inputFileName, fullname;</a>
<a name="16096"><span class="lineNum">   16096 </span><span class="lineCov">          4 :      string sourceFilename          = inputFileName;</span></a>
<a name="16097"><span class="lineNum">   16097 </span>            : </a>
<a name="16098"><span class="lineNum">   16098 </span>            : #if 0</a>
<a name="16099"><span class="lineNum">   16099 </span>            :   // printf (&quot;sourceFilename_fullname = %s \n&quot;,sourceFilename_fullname.c_str());</a>
<a name="16100"><span class="lineNum">   16100 </span>            :      printf (&quot;sourceFilename          = %s \n&quot;,sourceFilename.c_str());</a>
<a name="16101"><span class="lineNum">   16101 </span>            : #endif</a>
<a name="16102"><span class="lineNum">   16102 </span>            : </a>
<a name="16103"><span class="lineNum">   16103 </span>            : </a>
<a name="16104"><span class="lineNum">   16104 </span>            :   // DQ (11/5/2020): Experiment with clearing the global scope that is supporting multiple translation</a>
<a name="16105"><span class="lineNum">   16105 </span>            :   // units, since it is the cause of some problem when a tool is designed to read an input file twice.</a>
<a name="16106"><span class="lineNum">   16106 </span><span class="lineCov">          4 :      if (project != NULL)</span></a>
<a name="16107"><span class="lineNum">   16107 </span>            :         {</a>
<a name="16108"><span class="lineNum">   16108 </span><span class="lineCov">          2 :           SgGlobal* globalScopeAcrossFiles = project-&gt;get_globalScopeAcrossFiles();</span></a>
<a name="16109"><span class="lineNum">   16109 </span><span class="lineCov">          2 :           ROSE_ASSERT(globalScopeAcrossFiles != NULL);</span></a>
<a name="16110"><span class="lineNum">   16110 </span>            : </a>
<a name="16111"><span class="lineNum">   16111 </span><span class="lineCov">          2 :           ROSE_ASSERT(globalScopeAcrossFiles-&gt;get_symbol_table() != NULL);</span></a>
<a name="16112"><span class="lineNum">   16112 </span><span class="lineCov">          2 :           ROSE_ASSERT(globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table() != NULL);</span></a>
<a name="16113"><span class="lineNum">   16113 </span>            : </a>
<a name="16114"><span class="lineNum">   16114 </span>            : #if 0</a>
<a name="16115"><span class="lineNum">   16115 </span>            :           printf (&quot;In SageBuilder::buildFile(): globalScopeAcrossFiles                  = %p \n&quot;,globalScopeAcrossFiles);</a>
<a name="16116"><span class="lineNum">   16116 </span>            :           printf (&quot; --- globalScopeAcrossFiles-&gt;get_declarations().size()               = %zu \n&quot;,globalScopeAcrossFiles-&gt;get_declarations().size());</a>
<a name="16117"><span class="lineNum">   16117 </span>            :           printf (&quot; --- globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;size()              = %d \n&quot;,globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;size());</a>
<a name="16118"><span class="lineNum">   16118 </span>            :           printf (&quot; --- globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table()-&gt;size() = %d \n&quot;,globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table()-&gt;size());</a>
<a name="16119"><span class="lineNum">   16119 </span>            : #endif</a>
<a name="16120"><span class="lineNum">   16120 </span>            : #if 0</a>
<a name="16121"><span class="lineNum">   16121 </span>            :           printf (&quot;Removing all elements from the globalScopeAcrossFiles-&gt;get_symbol_table() \n&quot;);</a>
<a name="16122"><span class="lineNum">   16122 </span>            : #endif</a>
<a name="16123"><span class="lineNum">   16123 </span>            : </a>
<a name="16124"><span class="lineNum">   16124 </span>            :        // DQ (11/5/2020): Clear the symbol table used to support multifile handling.</a>
<a name="16125"><span class="lineNum">   16125 </span>            :        // This breaks only one of the test codes in the codeSegregation tool, but it is a name</a>
<a name="16126"><span class="lineNum">   16126 </span>            :        // qualification that should likely be handled better so I think this is a good fix.</a>
<a name="16127"><span class="lineNum">   16127 </span><span class="lineCov">          2 :           if (clear_globalScopeAcrossFiles == true)</span></a>
<a name="16128"><span class="lineNum">   16128 </span>            :              {</a>
<a name="16129"><span class="lineNum">   16129 </span><span class="lineNoCov">          0 :                globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table()-&gt;delete_elements();</span></a>
<a name="16130"><span class="lineNum">   16130 </span>            :              }</a>
<a name="16131"><span class="lineNum">   16131 </span>            : </a>
<a name="16132"><span class="lineNum">   16132 </span>            : #if 0</a>
<a name="16133"><span class="lineNum">   16133 </span>            :           printf (&quot;After removing all symbols (alias symbols): globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;size()              = %d \n&quot;,globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;size());</a>
<a name="16134"><span class="lineNum">   16134 </span>            :           printf (&quot;After removing all symbols (alias symbols): globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table()-&gt;size() = %d \n&quot;,globalScopeAcrossFiles-&gt;get_symbol_table()-&gt;get_table()-&gt;size());</a>
<a name="16135"><span class="lineNum">   16135 </span>            : #endif</a>
<a name="16136"><span class="lineNum">   16136 </span>            :         }</a>
<a name="16137"><span class="lineNum">   16137 </span>            : </a>
<a name="16138"><span class="lineNum">   16138 </span>            :   // DQ (9/18/2019): Test that the use of fullname has no effect.</a>
<a name="16139"><span class="lineNum">   16139 </span>            :   // ROSE_ASSERT(sourceFilename == sourceFilename_fullname);</a>
<a name="16140"><span class="lineNum">   16140 </span>            : </a>
<a name="16141"><span class="lineNum">   16141 </span><span class="lineCov">          8 :      Rose_STL_Container&lt;std::string&gt; arglist;</span></a>
<a name="16142"><span class="lineNum">   16142 </span><span class="lineCov">          4 :      int nextErrorCode = 0;</span></a>
<a name="16143"><span class="lineNum">   16143 </span>            : </a>
<a name="16144"><span class="lineNum">   16144 </span>            : #if 0</a>
<a name="16145"><span class="lineNum">   16145 </span>            :      bool set_header_file_unparsing_optimization = false;</a>
<a name="16146"><span class="lineNum">   16146 </span>            : #endif</a>
<a name="16147"><span class="lineNum">   16147 </span>            : </a>
<a name="16148"><span class="lineNum">   16148 </span>            :   // DQ (11/10/2019): Shared nodes between existing files that are copied need to be marked as shared.</a>
<a name="16149"><span class="lineNum">   16149 </span><span class="lineCov">          4 :      bool isCopyOfExistingFile_testForSharedNodes = false;</span></a>
<a name="16150"><span class="lineNum">   16150 </span><span class="lineCov">          4 :      SgFile* fileBeingCopied = NULL;</span></a>
<a name="16151"><span class="lineNum">   16151 </span>            : </a>
<a name="16152"><span class="lineNum">   16152 </span><span class="lineCov">          4 :      if (project == NULL)</span></a>
<a name="16153"><span class="lineNum">   16153 </span>            :       // SgProject is created on the fly</a>
<a name="16154"><span class="lineNum">   16154 </span>            :       // Make up an arglist in order to reuse the code inside SgFile::setupSourceFilename()</a>
<a name="16155"><span class="lineNum">   16155 </span>            :         {</a>
<a name="16156"><span class="lineNum">   16156 </span>            : #if 0</a>
<a name="16157"><span class="lineNum">   16157 </span>            :           printf (&quot;In SageBuilder::buildFile(): build the SgProject \n&quot;);</a>
<a name="16158"><span class="lineNum">   16158 </span>            : #endif</a>
<a name="16159"><span class="lineNum">   16159 </span><span class="lineCov">          2 :           project = new SgProject();</span></a>
<a name="16160"><span class="lineNum">   16160 </span><span class="lineCov">          2 :           ROSE_ASSERT(project);</span></a>
<a name="16161"><span class="lineNum">   16161 </span><span class="lineCov">          2 :           project-&gt;get_fileList().clear();</span></a>
<a name="16162"><span class="lineNum">   16162 </span>            : </a>
<a name="16163"><span class="lineNum">   16163 </span><span class="lineCov">          4 :           arglist.push_back(&quot;cc&quot;);</span></a>
<a name="16164"><span class="lineNum">   16164 </span><span class="lineCov">          4 :           arglist.push_back(&quot;-c&quot;);</span></a>
<a name="16165"><span class="lineNum">   16165 </span><span class="lineCov">          2 :           project-&gt;set_originalCommandLineArgumentList (arglist);</span></a>
<a name="16166"><span class="lineNum">   16166 </span>            :         }</a>
<a name="16167"><span class="lineNum">   16167 </span>            :        else</a>
<a name="16168"><span class="lineNum">   16168 </span>            :         {</a>
<a name="16169"><span class="lineNum">   16169 </span>            :        // If project exists, then find the original source file if it exists and check the header file optimization setting for consistancy.</a>
<a name="16170"><span class="lineNum">   16170 </span>            : </a>
<a name="16171"><span class="lineNum">   16171 </span>            :        // DQ (9/18/2019): Adding debugging support to header file optimization support.</a>
<a name="16172"><span class="lineNum">   16172 </span><span class="lineCov">          2 :           SgFilePtrList &amp; files = project-&gt;get_fileList();</span></a>
<a name="16173"><span class="lineNum">   16173 </span><span class="lineCov">          5 :           for (SgFilePtrList::iterator i = files.begin(); i != files.end(); i++)</span></a>
<a name="16174"><span class="lineNum">   16174 </span>            :              {</a>
<a name="16175"><span class="lineNum">   16175 </span><span class="lineCov">          3 :                SgFile* file = *i;</span></a>
<a name="16176"><span class="lineNum">   16176 </span>            : #if 0</a>
<a name="16177"><span class="lineNum">   16177 </span>            :                printf (&quot;file = %p = %s name = %s \n&quot;,file,file-&gt;class_name().c_str(), file-&gt;getFileName().c_str());</a>
<a name="16178"><span class="lineNum">   16178 </span>            : </a>
<a name="16179"><span class="lineNum">   16179 </span>            :                printf (&quot;file-&gt;get_header_file_unparsing_optimization() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16180"><span class="lineNum">   16180 </span>            :                printf (&quot;file-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16181"><span class="lineNum">   16181 </span>            :                printf (&quot;file-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,file-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16182"><span class="lineNum">   16182 </span>            : #endif</a>
<a name="16183"><span class="lineNum">   16183 </span><span class="lineCov">          6 :                if (sourceFilename == file-&gt;getFileName())</span></a>
<a name="16184"><span class="lineNum">   16184 </span>            :                   {</a>
<a name="16185"><span class="lineNum">   16185 </span>            : #if 0</a>
<a name="16186"><span class="lineNum">   16186 </span>            :                     printf (&quot;This is a copy of an existing file in the project: sourceFilename = %s \n&quot;,sourceFilename.c_str());</a>
<a name="16187"><span class="lineNum">   16187 </span>            : #endif</a>
<a name="16188"><span class="lineNum">   16188 </span>            :                  // DQ (11/10/2019): Shared nodes between existing files that are copied need to be marked as shared.</a>
<a name="16189"><span class="lineNum">   16189 </span><span class="lineNoCov">          0 :                     isCopyOfExistingFile_testForSharedNodes = true;</span></a>
<a name="16190"><span class="lineNum">   16190 </span><span class="lineNoCov">          0 :                     fileBeingCopied = file;</span></a>
<a name="16191"><span class="lineNum">   16191 </span>            : </a>
<a name="16192"><span class="lineNum">   16192 </span>            : #if 0</a>
<a name="16193"><span class="lineNum">   16193 </span>            :                  // DQ (4/24/2021): This data member header_file_unparsing_optimization is now static.</a>
<a name="16194"><span class="lineNum">   16194 </span>            :                  // We are building a second copy of an originally specified file (so we need to set the optimization setting similarly).</a>
<a name="16195"><span class="lineNum">   16195 </span>            :                     if (file-&gt;get_header_file_unparsing_optimization() == true)</a>
<a name="16196"><span class="lineNum">   16196 </span>            :                        {</a>
<a name="16197"><span class="lineNum">   16197 </span>            :                          set_header_file_unparsing_optimization = true;</a>
<a name="16198"><span class="lineNum">   16198 </span>            :                        }</a>
<a name="16199"><span class="lineNum">   16199 </span>            : #endif</a>
<a name="16200"><span class="lineNum">   16200 </span>            :                   }</a>
<a name="16201"><span class="lineNum">   16201 </span>            :              }</a>
<a name="16202"><span class="lineNum">   16202 </span>            : </a>
<a name="16203"><span class="lineNum">   16203 </span>            : #if 0</a>
<a name="16204"><span class="lineNum">   16204 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16205"><span class="lineNum">   16205 </span>            :           ROSE_ABORT();</a>
<a name="16206"><span class="lineNum">   16206 </span>            : #endif</a>
<a name="16207"><span class="lineNum">   16207 </span>            :         }</a>
<a name="16208"><span class="lineNum">   16208 </span>            : </a>
<a name="16209"><span class="lineNum">   16209 </span><span class="lineCov">          8 :      ifstream testfile(inputFileName.c_str());</span></a>
<a name="16210"><span class="lineNum">   16210 </span><span class="lineCov">          4 :      if (!testfile.is_open())</span></a>
<a name="16211"><span class="lineNum">   16211 </span>            :         {</a>
<a name="16212"><span class="lineNum">   16212 </span>            :        // create a temporary file if the file does not exist.</a>
<a name="16213"><span class="lineNum">   16213 </span>            :        // have to do this, otherwise StringUtility::getAbsolutePathFromRelativePath() complains</a>
<a name="16214"><span class="lineNum">   16214 </span>            :        // which is called by result-&gt;setupSourceFilename(arglist);</a>
<a name="16215"><span class="lineNum">   16215 </span><span class="lineCov">          2 :           testfile.close();</span></a>
<a name="16216"><span class="lineNum">   16216 </span><span class="lineCov">          4 :           ofstream outputfile(inputFileName.c_str(),ios::out);</span></a>
<a name="16217"><span class="lineNum">   16217 </span>            :        // DQ (2/6/2009): I think this comment is helpful to put into the file (helps explain why the file exists).</a>
<a name="16218"><span class="lineNum">   16218 </span><span class="lineCov">          2 :           outputfile&lt;&lt;&quot;// Output file generated so that StringUtility::getAbsolutePathFromRelativePath() will see a vaild file ... unparsed file will have rose_ prefix &quot;&lt;&lt;endl;</span></a>
<a name="16219"><span class="lineNum">   16219 </span><span class="lineCov">          2 :           outputfile.close();</span></a>
<a name="16220"><span class="lineNum">   16220 </span>            :         }</a>
<a name="16221"><span class="lineNum">   16221 </span>            :        else // file already exists , load and parse it</a>
<a name="16222"><span class="lineNum">   16222 </span>            :         {</a>
<a name="16223"><span class="lineNum">   16223 </span>            :        // should not reparse all files in case their ASTs have unsaved changes,</a>
<a name="16224"><span class="lineNum">   16224 </span>            :        // just parse the newly loaded file only.</a>
<a name="16225"><span class="lineNum">   16225 </span>            :        // use argv here, change non-existing input file later on</a>
<a name="16226"><span class="lineNum">   16226 </span>            :        // TODO add error code handling</a>
<a name="16227"><span class="lineNum">   16227 </span>            : </a>
<a name="16228"><span class="lineNum">   16228 </span>            :        // DQ (2/6/2009): Avoid closing this file twice (so put this here, instead of below).</a>
<a name="16229"><span class="lineNum">   16229 </span><span class="lineCov">          2 :           testfile.close();</span></a>
<a name="16230"><span class="lineNum">   16230 </span>            :           // should remove the old one here, Liao, 5/1/2009</a>
<a name="16231"><span class="lineNum">   16231 </span>            :         }</a>
<a name="16232"><span class="lineNum">   16232 </span>            : </a>
<a name="16233"><span class="lineNum">   16233 </span>            :   // DQ (2/6/2009): Avoid closing this file twice (moved to false branch above).</a>
<a name="16234"><span class="lineNum">   16234 </span>            :   // testfile.close();</a>
<a name="16235"><span class="lineNum">   16235 </span>            : </a>
<a name="16236"><span class="lineNum">   16236 </span>            :   // DQ (2/6/2009): Need to add the inputFileName to the source file list in the project,</a>
<a name="16237"><span class="lineNum">   16237 </span>            :   // because this list will be used to subtract off the source files as required to build</a>
<a name="16238"><span class="lineNum">   16238 </span>            :   // the commandline for the backend compiler.</a>
<a name="16239"><span class="lineNum">   16239 </span><span class="lineCov">          4 :      project-&gt;get_sourceFileNameList().push_back(inputFileName);</span></a>
<a name="16240"><span class="lineNum">   16240 </span>            : </a>
<a name="16241"><span class="lineNum">   16241 </span><span class="lineCov">          8 :      Rose_STL_Container&lt;string&gt; sourceFilenames = project-&gt;get_sourceFileNameList();</span></a>
<a name="16242"><span class="lineNum">   16242 </span>            :   // printf (&quot;In SageBuilder::buildFile(): sourceFilenames.size() = %&quot; PRIuPTR &quot; sourceFilenames = %s \n&quot;,sourceFilenames.size(),StringUtility::listToString(sourceFilenames).c_str());</a>
<a name="16243"><span class="lineNum">   16243 </span>            : </a>
<a name="16244"><span class="lineNum">   16244 </span><span class="lineCov">          8 :      arglist = project-&gt;get_originalCommandLineArgumentList();</span></a>
<a name="16245"><span class="lineNum">   16245 </span>            : </a>
<a name="16246"><span class="lineNum">   16246 </span>            :   // DQ (2/6/2009): We will be compiling the source code generated in the</a>
<a name="16247"><span class="lineNum">   16247 </span>            :   // &quot;rose_&lt;inputFileName&gt;&quot; file, so we don't want this on the argument stack.</a>
<a name="16248"><span class="lineNum">   16248 </span>            :   // TV (09/19/2018): only add if not already present</a>
<a name="16249"><span class="lineNum">   16249 </span><span class="lineCov">          4 :      if (std::find(arglist.begin(), arglist.end(), sourceFilename) == arglist.end())</span></a>
<a name="16250"><span class="lineNum">   16250 </span>            :         {</a>
<a name="16251"><span class="lineNum">   16251 </span><span class="lineCov">          4 :           arglist.push_back(sourceFilename);</span></a>
<a name="16252"><span class="lineNum">   16252 </span>            :         }</a>
<a name="16253"><span class="lineNum">   16253 </span>            : </a>
<a name="16254"><span class="lineNum">   16254 </span>            :   // DQ (2/6/2009): Modified.</a>
<a name="16255"><span class="lineNum">   16255 </span>            :   // There is output file name specified for rose translators</a>
<a name="16256"><span class="lineNum">   16256 </span><span class="lineCov">          4 :      if (outputFileName.empty() == false)</span></a>
<a name="16257"><span class="lineNum">   16257 </span>            :         {</a>
<a name="16258"><span class="lineNum">   16258 </span><span class="lineCov">          8 :           arglist.push_back(&quot;-rose:o&quot;);</span></a>
<a name="16259"><span class="lineNum">   16259 </span>            :        // arglist.push_back(&quot;-o&quot;);</a>
<a name="16260"><span class="lineNum">   16260 </span><span class="lineCov">          4 :           arglist.push_back(outputFileName);</span></a>
<a name="16261"><span class="lineNum">   16261 </span>            :         }</a>
<a name="16262"><span class="lineNum">   16262 </span>            : </a>
<a name="16263"><span class="lineNum">   16263 </span>            :   // DQ (4/15/2010): Turn on verbose mode</a>
<a name="16264"><span class="lineNum">   16264 </span>            :   // arglist.push_back(&quot;-rose:verbose 2&quot;);</a>
<a name="16265"><span class="lineNum">   16265 </span>            : </a>
<a name="16266"><span class="lineNum">   16266 </span>            :   // This handles the case where the original command line may have referenced multiple files.</a>
<a name="16267"><span class="lineNum">   16267 </span><span class="lineCov">          4 :      Rose_STL_Container&lt;string&gt; fileList = CommandlineProcessing::generateSourceFilenames(arglist,/* binaryMode = */ false);</span></a>
<a name="16268"><span class="lineNum">   16268 </span><span class="lineCov">          8 :      CommandlineProcessing::removeAllFileNamesExcept(arglist,fileList,sourceFilename);</span></a>
<a name="16269"><span class="lineNum">   16269 </span>            : </a>
<a name="16270"><span class="lineNum">   16270 </span>            :   // DQ (9/3/2008): Added support for SgSourceFile IR node</a>
<a name="16271"><span class="lineNum">   16271 </span>            :   // SgFile* result = new SgFile (arglist, nextErrorCode, 0, project);</a>
<a name="16272"><span class="lineNum">   16272 </span>            :   // AS(10/04/08) Because of refactoring we require the determineFileType function to be called</a>
<a name="16273"><span class="lineNum">   16273 </span>            :   // to construct the node.</a>
<a name="16274"><span class="lineNum">   16274 </span>            :   // SgSourceFile* result = new SgSourceFile (arglist, nextErrorCode, 0, project);</a>
<a name="16275"><span class="lineNum">   16275 </span>            :   // SgSourceFile* result = isSgSourceFile(determineFileType(arglist, nextErrorCode, project));</a>
<a name="16276"><span class="lineNum">   16276 </span>            :   // TH (2009-07-15): changed to more generig isSgFile, this also supports SgBinaryComposite</a>
<a name="16277"><span class="lineNum">   16277 </span><span class="lineCov">          4 :      SgFile* result = determineFileType(arglist, nextErrorCode, project);</span></a>
<a name="16278"><span class="lineNum">   16278 </span><span class="lineCov">          4 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="16279"><span class="lineNum">   16279 </span>            : </a>
<a name="16280"><span class="lineNum">   16280 </span>            : #if 0</a>
<a name="16281"><span class="lineNum">   16281 </span>            :      printf (&quot;In SageBuilder::buildFile(): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16282"><span class="lineNum">   16282 </span>            : #endif</a>
<a name="16283"><span class="lineNum">   16283 </span>            : </a>
<a name="16284"><span class="lineNum">   16284 </span>            : #if 0</a>
<a name="16285"><span class="lineNum">   16285 </span>            :      printf (&quot;Calling outputFileIds() \n&quot;);</a>
<a name="16286"><span class="lineNum">   16286 </span>            : </a>
<a name="16287"><span class="lineNum">   16287 </span>            :      SageInterface::outputFileIds(result);</a>
<a name="16288"><span class="lineNum">   16288 </span>            : </a>
<a name="16289"><span class="lineNum">   16289 </span>            :      printf (&quot;DONE: Calling outputFileIds() \n&quot;);</a>
<a name="16290"><span class="lineNum">   16290 </span>            : #endif</a>
<a name="16291"><span class="lineNum">   16291 </span>            : </a>
<a name="16292"><span class="lineNum">   16292 </span>            : #if 0</a>
<a name="16293"><span class="lineNum">   16293 </span>            :   // DQ (9/18/2019): Adding debugging support.</a>
<a name="16294"><span class="lineNum">   16294 </span>            :      printf (&quot;In SageBuilder::buildFile(): file = %p = %s result-&gt;get_header_file_unparsing_optimization() = %s \n&quot;,</a>
<a name="16295"><span class="lineNum">   16295 </span>            :           result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16296"><span class="lineNum">   16296 </span>            :      printf (&quot;In SageBuilder::buildFile(): file = %p = %s result-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,</a>
<a name="16297"><span class="lineNum">   16297 </span>            :           result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16298"><span class="lineNum">   16298 </span>            :      printf (&quot;In SageBuilder::buildFile(): file = %p = %s result-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,</a>
<a name="16299"><span class="lineNum">   16299 </span>            :           result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16300"><span class="lineNum">   16300 </span>            : #endif</a>
<a name="16301"><span class="lineNum">   16301 </span>            : </a>
<a name="16302"><span class="lineNum">   16302 </span>            :   // DQ (9/18/2019): Adding debugging support.</a>
<a name="16303"><span class="lineNum">   16303 </span><span class="lineCov">          4 :      ROSE_ASSERT(result-&gt;get_header_file_unparsing_optimization() == false);</span></a>
<a name="16304"><span class="lineNum">   16304 </span><span class="lineCov">          4 :      ROSE_ASSERT(result-&gt;get_header_file_unparsing_optimization_source_file() == false);</span></a>
<a name="16305"><span class="lineNum">   16305 </span><span class="lineCov">          4 :      ROSE_ASSERT(result-&gt;get_header_file_unparsing_optimization_header_file() == false);</span></a>
<a name="16306"><span class="lineNum">   16306 </span>            : </a>
<a name="16307"><span class="lineNum">   16307 </span>            :   // ROSE_ASSERT(result-&gt;get_header_file_unparsing_optimization() == true);</a>
<a name="16308"><span class="lineNum">   16308 </span>            : </a>
<a name="16309"><span class="lineNum">   16309 </span>            : #if 0</a>
<a name="16310"><span class="lineNum">   16310 </span>            :   // DQ (4/24/2021): This data member header_file_unparsing_optimization is now static (so we don't need this code).</a>
<a name="16311"><span class="lineNum">   16311 </span>            :      if (set_header_file_unparsing_optimization == true)</a>
<a name="16312"><span class="lineNum">   16312 </span>            :         {</a>
<a name="16313"><span class="lineNum">   16313 </span>            :           result-&gt;set_header_file_unparsing_optimization(true);</a>
<a name="16314"><span class="lineNum">   16314 </span>            : </a>
<a name="16315"><span class="lineNum">   16315 </span>            :        // DQ (9/18/2019): Also set the values for the source file and header files.</a>
<a name="16316"><span class="lineNum">   16316 </span>            :        // I think we only want to set the source file version to true and the header file version to false.</a>
<a name="16317"><span class="lineNum">   16317 </span>            :        // This is enforced in the attachPreprocessingInfo() function.</a>
<a name="16318"><span class="lineNum">   16318 </span>            : </a>
<a name="16319"><span class="lineNum">   16319 </span>            :        // DQ (4/24/2021): Debugging header file optimization.</a>
<a name="16320"><span class="lineNum">   16320 </span>            :        // result-&gt;set_header_file_unparsing_optimization_source_file(true);</a>
<a name="16321"><span class="lineNum">   16321 </span>            : </a>
<a name="16322"><span class="lineNum">   16322 </span>            :        // result-&gt;set_header_file_unparsing_optimization_header_file(true);</a>
<a name="16323"><span class="lineNum">   16323 </span>            :           result-&gt;set_header_file_unparsing_optimization_header_file(false);</a>
<a name="16324"><span class="lineNum">   16324 </span>            : </a>
<a name="16325"><span class="lineNum">   16325 </span>            : #if 0</a>
<a name="16326"><span class="lineNum">   16326 </span>            :           printf (&quot;In SageBuilder::buildFile(): set_header_file_unparsing_optimization == true: file = %p = %s result-&gt;get_header_file_unparsing_optimization() = %s \n&quot;,</a>
<a name="16327"><span class="lineNum">   16327 </span>            :                result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16328"><span class="lineNum">   16328 </span>            :           printf (&quot;In SageBuilder::buildFile(): set_header_file_unparsing_optimization == true: file = %p = %s result-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,</a>
<a name="16329"><span class="lineNum">   16329 </span>            :                result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16330"><span class="lineNum">   16330 </span>            :           printf (&quot;In SageBuilder::buildFile(): set_header_file_unparsing_optimization == true: file = %p = %s result-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,</a>
<a name="16331"><span class="lineNum">   16331 </span>            :                result,result-&gt;class_name().c_str(),result-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16332"><span class="lineNum">   16332 </span>            : #endif</a>
<a name="16333"><span class="lineNum">   16333 </span>            :         }</a>
<a name="16334"><span class="lineNum">   16334 </span>            : #endif</a>
<a name="16335"><span class="lineNum">   16335 </span>            : </a>
<a name="16336"><span class="lineNum">   16336 </span>            : #if 0</a>
<a name="16337"><span class="lineNum">   16337 </span>            :   // DQ (3/4/2014): This fix is only for Java and for C will cause a second SgFile to be redundently added to the file list.</a>
<a name="16338"><span class="lineNum">   16338 </span>            :   // For now I will provide a temporary fix and check is this is for a Java project so that we can continue. But the longer</a>
<a name="16339"><span class="lineNum">   16339 </span>            :   // term fix would be to make the semantics for Java the same as that of C/C++ (or the other way around, whatever is the</a>
<a name="16340"><span class="lineNum">   16340 </span>            :   // cleaner semantics.</a>
<a name="16341"><span class="lineNum">   16341 </span>            :   // This just adds the new file to the list of files stored internally (note: this sets the parent of the newFile).</a>
<a name="16342"><span class="lineNum">   16342 </span>            :   // TOO1 (2/28/2014): This is definitely required for Java (ECJ frontend), though C passes without it (I think only</a>
<a name="16343"><span class="lineNum">   16343 </span>            :   //                   by luck :-).</a>
<a name="16344"><span class="lineNum">   16344 </span>            :   //                   The ECJ frontend uses the SgProject internally (via a global SgProject*). Therefore, the</a>
<a name="16345"><span class="lineNum">   16345 </span>            :   //                   SgProject must contain this newly created SgFile, otherwise ECJ won't be able to find it.</a>
<a name="16346"><span class="lineNum">   16346 </span>            :   // project-&gt;set_file ( *result );</a>
<a name="16347"><span class="lineNum">   16347 </span>            :      if (project-&gt;get_Java_only() == true)</a>
<a name="16348"><span class="lineNum">   16348 </span>            :         {</a>
<a name="16349"><span class="lineNum">   16349 </span>            :        // DQ (3/4/2014): For now we want to output a message and clean this up afterward (likely in the Java language support).</a>
<a name="16350"><span class="lineNum">   16350 </span>            :           printf (&quot;WARNING: Java specific action to add new file to SgProject (using set_file()) (more uniform language handling symantics would avoid this problem) \n&quot;);</a>
<a name="16351"><span class="lineNum">   16351 </span>            :           project-&gt;set_file ( *result );</a>
<a name="16352"><span class="lineNum">   16352 </span>            :         }</a>
<a name="16353"><span class="lineNum">   16353 </span>            : #else</a>
<a name="16354"><span class="lineNum">   16354 </span>            :   // DQ (3/6/2014): The code below adresses the specific bug faced in the use of the outliner (so we use it directly).</a>
<a name="16355"><span class="lineNum">   16355 </span>            :   // This code was moved ahead of the call to &quot;result-&gt;runFrontend(nextErrorCode);&quot; because in the case of Java</a>
<a name="16356"><span class="lineNum">   16356 </span>            :   // the file must be set to be a part of the SgProject before calling the runFrontend() function.</a>
<a name="16357"><span class="lineNum">   16357 </span>            :   // project-&gt;set_file ( *result );</a>
<a name="16358"><span class="lineNum">   16358 </span>            : </a>
<a name="16359"><span class="lineNum">   16359 </span><span class="lineCov">          4 :      result-&gt;set_parent(project);</span></a>
<a name="16360"><span class="lineNum">   16360 </span>            : </a>
<a name="16361"><span class="lineNum">   16361 </span>            : #if 0</a>
<a name="16362"><span class="lineNum">   16362 </span>            :      printf (&quot;In SageBuilder::buildFile(): Outliner::use_dlopen = %s \n&quot;,Outliner::use_dlopen ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16363"><span class="lineNum">   16363 </span>            : #endif</a>
<a name="16364"><span class="lineNum">   16364 </span>            : </a>
<a name="16365"><span class="lineNum">   16365 </span>            :   // DQ (3/5/2014): I need to check with Liao to understand this part of the code better.</a>
<a name="16366"><span class="lineNum">   16366 </span>            :   // I think that the default value for Outliner::use_dlopen is false, so that when the</a>
<a name="16367"><span class="lineNum">   16367 </span>            :   // Java support is used the true branch is taken.  However, if might be the we need</a>
<a name="16368"><span class="lineNum">   16368 </span>            :   // to support the outliner using the code below and so this would be a bug for the</a>
<a name="16369"><span class="lineNum">   16369 </span>            :   // outliner.</a>
<a name="16370"><span class="lineNum">   16370 </span><span class="lineCov">          4 :      if (!Outliner::use_dlopen)</span></a>
<a name="16371"><span class="lineNum">   16371 </span>            :         {</a>
<a name="16372"><span class="lineNum">   16372 </span>            : #if 0</a>
<a name="16373"><span class="lineNum">   16373 </span>            :           printf (&quot;In SageBuilder::buildFile(): (after test for (!Outliner::use_dlopen) == true: project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16374"><span class="lineNum">   16374 </span>            : #endif</a>
<a name="16375"><span class="lineNum">   16375 </span>            :        // DQ (3/5/2014): If we added the file above, then don't add it here since it is redundant.</a>
<a name="16376"><span class="lineNum">   16376 </span><span class="lineCov">          4 :           project-&gt;set_file(*result);  // equal to push_back()</span></a>
<a name="16377"><span class="lineNum">   16377 </span>            : #if 0</a>
<a name="16378"><span class="lineNum">   16378 </span>            :           printf (&quot;In SageBuilder::buildFile(): (after 2nd project-&gt;set_file()): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16379"><span class="lineNum">   16379 </span>            : #endif</a>
<a name="16380"><span class="lineNum">   16380 </span>            :         }</a>
<a name="16381"><span class="lineNum">   16381 </span>            :        else</a>
<a name="16382"><span class="lineNum">   16382 </span>            :         {</a>
<a name="16383"><span class="lineNum">   16383 </span>            : #if 0</a>
<a name="16384"><span class="lineNum">   16384 </span>            :           printf (&quot;In SageBuilder::buildFile(): (after test for (!Outliner::use_dlopen) == false: project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16385"><span class="lineNum">   16385 </span>            : #endif</a>
<a name="16386"><span class="lineNum">   16386 </span>            : </a>
<a name="16387"><span class="lineNum">   16387 </span>            :        // Liao, 5/1/2009,</a>
<a name="16388"><span class="lineNum">   16388 </span>            :        // if the original command line is: gcc -c -o my.o my.c and we want to</a>
<a name="16389"><span class="lineNum">   16389 </span>            :        // add a new file(mynew.c), the command line for the new file would become &quot;gcc -c -o my.o mynew.c &quot;</a>
<a name="16390"><span class="lineNum">   16390 </span>            :        // which overwrites the object file my.o from my.c and causes linking error.</a>
<a name="16391"><span class="lineNum">   16391 </span>            :        // To avoid this problem, I insert the file at the beginning and let the right object file to be the last generated one</a>
<a name="16392"><span class="lineNum">   16392 </span>            :        //</a>
<a name="16393"><span class="lineNum">   16393 </span>            :        // TODO This is not an elegant fix and it causes some strange assertion failure in addAssociatedNodes(): default case node</a>
<a name="16394"><span class="lineNum">   16394 </span>            :        // So we only turn this on if Outliner:: use_dlopen is used for now</a>
<a name="16395"><span class="lineNum">   16395 </span>            :        // The semantics of adding a new source file can cause changes to linking phase (new object files etc.)</a>
<a name="16396"><span class="lineNum">   16396 </span>            :        // But ROSE has a long-time bug in handling combined compiling and linking command like &quot;translator -o a.out a.c b.c&quot;</a>
<a name="16397"><span class="lineNum">   16397 </span>            :        // It will generated two command line: &quot;translator -o a.out a.c&quot; and &quot;translator -o a.out b.c&quot;, which are totally wrong.</a>
<a name="16398"><span class="lineNum">   16398 </span>            :        // This problem is very relevant to the bug.</a>
<a name="16399"><span class="lineNum">   16399 </span><span class="lineNoCov">          0 :           SgFilePtrList&amp; flist = project-&gt;get_fileList();</span></a>
<a name="16400"><span class="lineNum">   16400 </span><span class="lineNoCov">          0 :           flist.insert(flist.begin(),result);</span></a>
<a name="16401"><span class="lineNum">   16401 </span>            : #if 0</a>
<a name="16402"><span class="lineNum">   16402 </span>            :           printf (&quot;In SageBuilder::buildFile(): (after flist.insert(flist.begin(),result)): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16403"><span class="lineNum">   16403 </span>            : #endif</a>
<a name="16404"><span class="lineNum">   16404 </span>            :         }</a>
<a name="16405"><span class="lineNum">   16405 </span>            : #endif</a>
<a name="16406"><span class="lineNum">   16406 </span>            : </a>
<a name="16407"><span class="lineNum">   16407 </span>            :   // DQ (6/3/2019): The case of outlining to a seperate file will have transformations</a>
<a name="16408"><span class="lineNum">   16408 </span>            :   // that this checking will fail on because it is for the typical case of checking the</a>
<a name="16409"><span class="lineNum">   16409 </span>            :   // AST for transformations after construction of the AST from an typical input file.</a>
<a name="16410"><span class="lineNum">   16410 </span><span class="lineCov">          4 :      EDG_ROSE_Translation::suppress_detection_of_transformations = true;</span></a>
<a name="16411"><span class="lineNum">   16411 </span>            : </a>
<a name="16412"><span class="lineNum">   16412 </span>            : #if 0</a>
<a name="16413"><span class="lineNum">   16413 </span>            :      printf (&quot;In SageBuilder::buildFile(): EDG_ROSE_Translation::suppress_detection_of_transformations = %s \n&quot;,EDG_ROSE_Translation::suppress_detection_of_transformations ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16414"><span class="lineNum">   16414 </span>            : #endif</a>
<a name="16415"><span class="lineNum">   16415 </span>            : </a>
<a name="16416"><span class="lineNum">   16416 </span>            : #if 0</a>
<a name="16417"><span class="lineNum">   16417 </span>            :      printf (&quot;In SageBuilder::buildFile(): (after project-&gt;set_file()): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16418"><span class="lineNum">   16418 </span>            : #endif</a>
<a name="16419"><span class="lineNum">   16419 </span>            : </a>
<a name="16420"><span class="lineNum">   16420 </span>            : </a>
<a name="16421"><span class="lineNum">   16421 </span>            :   // DQ (6/5/2019): Record what is marked as isModified() and then reset these IR nodes to be isModified after the new file has been processed.</a>
<a name="16422"><span class="lineNum">   16422 </span>            :   // This is required because the modified IR nodes will be reset in this AST associated with the new file, and IR nodes that are common</a>
<a name="16423"><span class="lineNum">   16423 </span>            :   // across the two AST's will be reset (shared IR nodes, which are also not marked as shared).  The solution is to compute the list of IR nodes</a>
<a name="16424"><span class="lineNum">   16424 </span>            :   // which are marked as isModified, and then build the new file (which will reset them for the new file's AST (plus any shared nodes visited in</a>
<a name="16425"><span class="lineNum">   16425 </span>            :   // the traversal) and then afterward reset the set of isModified IR nodes to isModified.  By isolating the fix in this function we can eliminate</a>
<a name="16426"><span class="lineNum">   16426 </span>            :   // the complexity of it being seen from the outside (outside of this abstraction).  Note that the function:</a>
<a name="16427"><span class="lineNum">   16427 </span>            :   // SageInterface::collectModifiedLocatedNodes() has previously been implemented and used for debugging.</a>
<a name="16428"><span class="lineNum">   16428 </span><span class="lineCov">          8 :      std::set&lt;SgLocatedNode*&gt; modifiedNodeSet = collectModifiedLocatedNodes(project);</span></a>
<a name="16429"><span class="lineNum">   16429 </span>            : </a>
<a name="16430"><span class="lineNum">   16430 </span>            :   // DQ (3/6/2014): For Java, this function can only be called AFTER the SgFile has been added to the file list in the SgProject.</a>
<a name="16431"><span class="lineNum">   16431 </span>            :   // For C/C++ it does not appear to matter if the call is made before the SgFile has been added to the file list in the SgProject.</a>
<a name="16432"><span class="lineNum">   16432 </span>            :   // DQ (6/14/2013): Since we seperated the construction of the SgFile IR nodes from the invocation of the frontend, we have to call the frontend explicitly.</a>
<a name="16433"><span class="lineNum">   16433 </span><span class="lineCov">          4 :      result-&gt;runFrontend(nextErrorCode);</span></a>
<a name="16434"><span class="lineNum">   16434 </span>            : </a>
<a name="16435"><span class="lineNum">   16435 </span>            : #if 0</a>
<a name="16436"><span class="lineNum">   16436 </span>            :      printf (&quot;In SageBuilder::buildFile(): (after result-&gt;runFrontend()): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16437"><span class="lineNum">   16437 </span>            : #endif</a>
<a name="16438"><span class="lineNum">   16438 </span>            : </a>
<a name="16439"><span class="lineNum">   16439 </span>            : #if 0</a>
<a name="16440"><span class="lineNum">   16440 </span>            :      printf (&quot;After result-&gt;runFrontend(): calling outputFileIds() \n&quot;);</a>
<a name="16441"><span class="lineNum">   16441 </span>            : </a>
<a name="16442"><span class="lineNum">   16442 </span>            :      SageInterface::outputFileIds(result);</a>
<a name="16443"><span class="lineNum">   16443 </span>            : </a>
<a name="16444"><span class="lineNum">   16444 </span>            :      printf (&quot;DONE: After result-&gt;runFrontend(): calling outputFileIds() \n&quot;);</a>
<a name="16445"><span class="lineNum">   16445 </span>            : #endif</a>
<a name="16446"><span class="lineNum">   16446 </span>            : </a>
<a name="16447"><span class="lineNum">   16447 </span>            : #if 0</a>
<a name="16448"><span class="lineNum">   16448 </span>            :   // Output an optional graph of the AST (just the tree, when active)</a>
<a name="16449"><span class="lineNum">   16449 </span>            :      printf (&quot;Generating a dot file... (SgFile only) \n&quot;);</a>
<a name="16450"><span class="lineNum">   16450 </span>            :      generateDOT ( *project );</a>
<a name="16451"><span class="lineNum">   16451 </span>            :   // generateAstGraph(project, 2000);</a>
<a name="16452"><span class="lineNum">   16452 </span>            : #endif</a>
<a name="16453"><span class="lineNum">   16453 </span>            : </a>
<a name="16454"><span class="lineNum">   16454 </span>            : #if 0</a>
<a name="16455"><span class="lineNum">   16455 </span>            :      printf (&quot;In SageBuilder::buildFile(): Generate the dot output for multiple files (ROSE AST) \n&quot;);</a>
<a name="16456"><span class="lineNum">   16456 </span>            :   // generateDOT ( *project );</a>
<a name="16457"><span class="lineNum">   16457 </span>            :      generateDOTforMultipleFile ( *project );</a>
<a name="16458"><span class="lineNum">   16458 </span>            :      printf (&quot;DONE: Generate the dot output of the SAGE III AST \n&quot;);</a>
<a name="16459"><span class="lineNum">   16459 </span>            : #endif</a>
<a name="16460"><span class="lineNum">   16460 </span>            : </a>
<a name="16461"><span class="lineNum">   16461 </span>            : #if 0</a>
<a name="16462"><span class="lineNum">   16462 </span>            :   // DQ (7/18/2019): Output a graph of the AST for debugging.</a>
<a name="16463"><span class="lineNum">   16463 </span>            :   // Output an optional graph of the AST (the whole graph, of bounded complexity, when active)</a>
<a name="16464"><span class="lineNum">   16464 </span>            :      const int MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH = 8000;</a>
<a name="16465"><span class="lineNum">   16465 </span>            :      generateAstGraph(project,MAX_NUMBER_OF_IR_NODES_TO_GRAPH_FOR_WHOLE_GRAPH);</a>
<a name="16466"><span class="lineNum">   16466 </span>            : #endif</a>
<a name="16467"><span class="lineNum">   16467 </span>            : </a>
<a name="16468"><span class="lineNum">   16468 </span>            :   // DQ (7/14/2019): I think we need to call the astPostProcessing at this point.</a>
<a name="16469"><span class="lineNum">   16469 </span>            : #if 0</a>
<a name="16470"><span class="lineNum">   16470 </span>            :      printf (&quot;In SageBuilder::buildFile(): calling astPostProcessing() \n&quot;);</a>
<a name="16471"><span class="lineNum">   16471 </span>            : #endif</a>
<a name="16472"><span class="lineNum">   16472 </span>            : </a>
<a name="16473"><span class="lineNum">   16473 </span><span class="lineCov">          4 :      AstPostProcessing(result);</span></a>
<a name="16474"><span class="lineNum">   16474 </span>            : </a>
<a name="16475"><span class="lineNum">   16475 </span>            : #if 0</a>
<a name="16476"><span class="lineNum">   16476 </span>            :      printf (&quot;In SageBuilder::buildFile(): DONE: calling astPostProcessing() \n&quot;);</a>
<a name="16477"><span class="lineNum">   16477 </span>            : #endif</a>
<a name="16478"><span class="lineNum">   16478 </span>            : </a>
<a name="16479"><span class="lineNum">   16479 </span>            : #if 0</a>
<a name="16480"><span class="lineNum">   16480 </span>            :      result-&gt;display(&quot;SageBuilder::buildFile()&quot;);</a>
<a name="16481"><span class="lineNum">   16481 </span>            : #endif</a>
<a name="16482"><span class="lineNum">   16482 </span>            : </a>
<a name="16483"><span class="lineNum">   16483 </span><span class="lineCov">          4 :      ROSE_ASSERT(project != NULL);</span></a>
<a name="16484"><span class="lineNum">   16484 </span><span class="lineCov">          4 :      project-&gt;set_frontendErrorCode(max(project-&gt;get_frontendErrorCode(), nextErrorCode));</span></a>
<a name="16485"><span class="lineNum">   16485 </span>            : </a>
<a name="16486"><span class="lineNum">   16486 </span>            :   // Not sure why a warning shows up from astPostProcessing.C</a>
<a name="16487"><span class="lineNum">   16487 </span>            :   // SgNode::get_globalMangledNameMap().size() != 0 size = %&quot; PRIuPTR &quot; (clearing mangled name cache)</a>
<a name="16488"><span class="lineNum">   16488 </span><span class="lineCov">          4 :      if (result-&gt;get_globalMangledNameMap().size() != 0)</span></a>
<a name="16489"><span class="lineNum">   16489 </span>            :         {</a>
<a name="16490"><span class="lineNum">   16490 </span><span class="lineNoCov">          0 :           result-&gt;clearGlobalMangledNameMap();</span></a>
<a name="16491"><span class="lineNum">   16491 </span>            :         }</a>
<a name="16492"><span class="lineNum">   16492 </span>            : </a>
<a name="16493"><span class="lineNum">   16493 </span>            :   // DQ (6/5/2019): Use the previously constructed set (above) to reset the IR nodes to be marked as isModified.</a>
<a name="16494"><span class="lineNum">   16494 </span>            :   // std::set&lt;SgLocatedNode*&gt; modifiedNodeSet = collectModifiedLocatedNodes(project);</a>
<a name="16495"><span class="lineNum">   16495 </span>            :   // void resetModifiedLocatedNodes(const std::set&lt;SgLocatedNode*&gt; &amp; modifiedNodeSet);</a>
<a name="16496"><span class="lineNum">   16496 </span><span class="lineCov">          4 :      resetModifiedLocatedNodes(modifiedNodeSet);</span></a>
<a name="16497"><span class="lineNum">   16497 </span>            : </a>
<a name="16498"><span class="lineNum">   16498 </span>            : #if 0</a>
<a name="16499"><span class="lineNum">   16499 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16500"><span class="lineNum">   16500 </span>            :      ROSE_ABORT();</a>
<a name="16501"><span class="lineNum">   16501 </span>            : #endif</a>
<a name="16502"><span class="lineNum">   16502 </span>            : </a>
<a name="16503"><span class="lineNum">   16503 </span>            :   // DQ (11/10/2019): Shared nodes between existing files that are copied need to be marked as shared.</a>
<a name="16504"><span class="lineNum">   16504 </span><span class="lineCov">          4 :      if (isCopyOfExistingFile_testForSharedNodes == true)</span></a>
<a name="16505"><span class="lineNum">   16505 </span>            :         {</a>
<a name="16506"><span class="lineNum">   16506 </span>            :        // Sharing of IR nodes happens in the AST when the same file is read twice.</a>
<a name="16507"><span class="lineNum">   16507 </span>            :        // Also in the case where two declarations in the global scope match in two different ASTs (typically in header files of different translation units).</a>
<a name="16508"><span class="lineNum">   16508 </span>            : </a>
<a name="16509"><span class="lineNum">   16509 </span>            : #if 0</a>
<a name="16510"><span class="lineNum">   16510 </span>            :           printf (&quot;Found isCopyOfExistingFile_testForSharedNodes == true \n&quot;);</a>
<a name="16511"><span class="lineNum">   16511 </span>            :           printf (&quot;fileBeingCopied = %p = %s \n&quot;,fileBeingCopied,fileBeingCopied-&gt;getFileName().c_str());</a>
<a name="16512"><span class="lineNum">   16512 </span>            : #endif</a>
<a name="16513"><span class="lineNum">   16513 </span>            : </a>
<a name="16514"><span class="lineNum">   16514 </span><span class="lineNoCov">          0 :           SgSourceFile* sourceFileBeingCopied = isSgSourceFile(fileBeingCopied);</span></a>
<a name="16515"><span class="lineNum">   16515 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(sourceFileBeingCopied != NULL);</span></a>
<a name="16516"><span class="lineNum">   16516 </span>            : </a>
<a name="16517"><span class="lineNum">   16517 </span><span class="lineNoCov">          0 :           SgSourceFile* sourceResult = isSgSourceFile(result);</span></a>
<a name="16518"><span class="lineNum">   16518 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(sourceResult != NULL);</span></a>
<a name="16519"><span class="lineNum">   16519 </span>            : </a>
<a name="16520"><span class="lineNum">   16520 </span><span class="lineNoCov">          0 :           SgGlobal* fileBeingCopied_globalScope = sourceFileBeingCopied-&gt;get_globalScope();</span></a>
<a name="16521"><span class="lineNum">   16521 </span><span class="lineNoCov">          0 :           SgGlobal* result_globalScope          = sourceResult-&gt;get_globalScope();</span></a>
<a name="16522"><span class="lineNum">   16522 </span>            : #if 0</a>
<a name="16523"><span class="lineNum">   16523 </span>            :           printf (&quot;fileBeingCopied_globalScope = %p \n&quot;,fileBeingCopied_globalScope);</a>
<a name="16524"><span class="lineNum">   16524 </span>            :           printf (&quot;result_globalScope          = %p \n&quot;,result_globalScope);</a>
<a name="16525"><span class="lineNum">   16525 </span>            : #endif</a>
<a name="16526"><span class="lineNum">   16526 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(fileBeingCopied_globalScope != NULL);</span></a>
<a name="16527"><span class="lineNum">   16527 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(result_globalScope != NULL);</span></a>
<a name="16528"><span class="lineNum">   16528 </span>            : </a>
<a name="16529"><span class="lineNum">   16529 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList fileBeingCopied_declarationList = fileBeingCopied_globalScope-&gt;get_declarations();</span></a>
<a name="16530"><span class="lineNum">   16530 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList result_declarationList          = result_globalScope-&gt;get_declarations();</span></a>
<a name="16531"><span class="lineNum">   16531 </span>            : </a>
<a name="16532"><span class="lineNum">   16532 </span>            : #if 1</a>
<a name="16533"><span class="lineNum">   16533 </span>            :        // DQ (11/22/2019): Use set intersection to compute the list to make be shared (this is a better implementation).</a>
<a name="16534"><span class="lineNum">   16534 </span>            :        // This implementation is insensitive to transforamtions in the original AST for the file.</a>
<a name="16535"><span class="lineNum">   16535 </span><span class="lineNoCov">          0 :           vector&lt;SgDeclarationStatement*&gt;::iterator it;</span></a>
<a name="16536"><span class="lineNum">   16536 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList v(fileBeingCopied_declarationList.size());</span></a>
<a name="16537"><span class="lineNum">   16537 </span>            : </a>
<a name="16538"><span class="lineNum">   16538 </span>            :        // This is n log n in complexity, but likely OK.</a>
<a name="16539"><span class="lineNum">   16539 </span><span class="lineNoCov">          0 :           std::sort(fileBeingCopied_declarationList.begin(),fileBeingCopied_declarationList.end());</span></a>
<a name="16540"><span class="lineNum">   16540 </span><span class="lineNoCov">          0 :           std::sort(result_declarationList.begin(),result_declarationList.end());</span></a>
<a name="16541"><span class="lineNum">   16541 </span>            : </a>
<a name="16542"><span class="lineNum">   16542 </span>            :        // printf (&quot;v.size() = %zu \n&quot;,v.size());</a>
<a name="16543"><span class="lineNum">   16543 </span>            : </a>
<a name="16544"><span class="lineNum">   16544 </span><span class="lineNoCov">          0 :           it = std::set_intersection(fileBeingCopied_declarationList.begin(),fileBeingCopied_declarationList.end(),result_declarationList.begin(),result_declarationList.end(),v.begin());</span></a>
<a name="16545"><span class="lineNum">   16545 </span>            : </a>
<a name="16546"><span class="lineNum">   16546 </span><span class="lineNoCov">          0 :           v.resize(it-v.begin());</span></a>
<a name="16547"><span class="lineNum">   16547 </span>            : </a>
<a name="16548"><span class="lineNum">   16548 </span><span class="lineNoCov">          0 :           int fileBeingCopied_file_id = fileBeingCopied-&gt;get_startOfConstruct()-&gt;get_physical_file_id();</span></a>
<a name="16549"><span class="lineNum">   16549 </span>            : </a>
<a name="16550"><span class="lineNum">   16550 </span>            :        // printf (&quot;v.size() = %zu \n&quot;,v.size());</a>
<a name="16551"><span class="lineNum">   16551 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; v.size(); i++)</span></a>
<a name="16552"><span class="lineNum">   16552 </span>            :              {</a>
<a name="16553"><span class="lineNum">   16553 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* intersection_element = v[i];</span></a>
<a name="16554"><span class="lineNum">   16554 </span>            :             // printf (&quot;intersection_element = %p = %s \n&quot;,intersection_element,intersection_element-&gt;class_name().c_str());</a>
<a name="16555"><span class="lineNum">   16555 </span>            : #if 0</a>
<a name="16556"><span class="lineNum">   16556 </span>            :                printf (&quot;  --- SageBuilder::buildFile() is sharing this node: %p %s \n&quot;,intersection_element,intersection_element-&gt;class_name().c_str());</a>
<a name="16557"><span class="lineNum">   16557 </span>            : #endif</a>
<a name="16558"><span class="lineNum">   16558 </span>            :             // DQ (11/10/2019): Need to recursively mark this as shared so that the unparser will be able to test each line?</a>
<a name="16559"><span class="lineNum">   16559 </span>            : </a>
<a name="16560"><span class="lineNum">   16560 </span><span class="lineNoCov">          0 :                fixupSharingSourcePosition(intersection_element,fileBeingCopied_file_id);</span></a>
<a name="16561"><span class="lineNum">   16561 </span>            : #if 0</a>
<a name="16562"><span class="lineNum">   16562 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16563"><span class="lineNum">   16563 </span>            :                ROSE_ABORT();</a>
<a name="16564"><span class="lineNum">   16564 </span>            : #endif</a>
<a name="16565"><span class="lineNum">   16565 </span>            :              }</a>
<a name="16566"><span class="lineNum">   16566 </span>            : #else</a>
<a name="16567"><span class="lineNum">   16567 </span>            : </a>
<a name="16568"><span class="lineNum">   16568 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16569"><span class="lineNum">   16569 </span>            : </a>
<a name="16570"><span class="lineNum">   16570 </span>            :        // This is the older implementation that is sensitive to transforamtions in the original AST from the file.</a>
<a name="16571"><span class="lineNum">   16571 </span>            :        // DQ (11/21/2019): Remove elements in the vector that are SgEmptyDeclarations which</a>
<a name="16572"><span class="lineNum">   16572 </span>            :        // are associated with some transformations (include header, for example).</a>
<a name="16573"><span class="lineNum">   16573 </span>            :           std::vector&lt;SgDeclarationStatementPtrList::iterator&gt; removeList;</a>
<a name="16574"><span class="lineNum">   16574 </span>            :           SgDeclarationStatementPtrList::iterator i = fileBeingCopied_declarationList.begin();</a>
<a name="16575"><span class="lineNum">   16575 </span>            :           while (i != fileBeingCopied_declarationList.end())</a>
<a name="16576"><span class="lineNum">   16576 </span>            :              {</a>
<a name="16577"><span class="lineNum">   16577 </span>            :                SgEmptyDeclaration* emptyDeclaration = isSgEmptyDeclaration(*i);</a>
<a name="16578"><span class="lineNum">   16578 </span>            :                if (emptyDeclaration != NULL)</a>
<a name="16579"><span class="lineNum">   16579 </span>            :                   {</a>
<a name="16580"><span class="lineNum">   16580 </span>            :                     removeList.push_back(i);</a>
<a name="16581"><span class="lineNum">   16581 </span>            :                   }</a>
<a name="16582"><span class="lineNum">   16582 </span>            : </a>
<a name="16583"><span class="lineNum">   16583 </span>            :                i++;</a>
<a name="16584"><span class="lineNum">   16584 </span>            :              }</a>
<a name="16585"><span class="lineNum">   16585 </span>            : </a>
<a name="16586"><span class="lineNum">   16586 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16587"><span class="lineNum">   16587 </span>            : </a>
<a name="16588"><span class="lineNum">   16588 </span>            :        // Need seperate list to avoid iterator invalidation.</a>
<a name="16589"><span class="lineNum">   16589 </span>            :        // for (SgDeclarationStatementPtrList::iterator i = removeList.begin(); i != removeList.end(); i++)</a>
<a name="16590"><span class="lineNum">   16590 </span>            :           for (std::vector&lt;SgDeclarationStatementPtrList::iterator&gt;::iterator i = removeList.begin(); i != removeList.end(); i++)</a>
<a name="16591"><span class="lineNum">   16591 </span>            :              {</a>
<a name="16592"><span class="lineNum">   16592 </span>            :                fileBeingCopied_declarationList.erase(*i);</a>
<a name="16593"><span class="lineNum">   16593 </span>            :              }</a>
<a name="16594"><span class="lineNum">   16594 </span>            : </a>
<a name="16595"><span class="lineNum">   16595 </span>            :        // DQ (11/21/2019): These might be a different size if for example the file being</a>
<a name="16596"><span class="lineNum">   16596 </span>            :        // copied is being copied after some transformations to the AST from the original file.</a>
<a name="16597"><span class="lineNum">   16597 </span>            :           if (fileBeingCopied_declarationList.size() != result_declarationList.size())</a>
<a name="16598"><span class="lineNum">   16598 </span>            :              {</a>
<a name="16599"><span class="lineNum">   16599 </span>            :                printf (&quot;fileBeingCopied_declarationList.size() = %zu \n&quot;,fileBeingCopied_declarationList.size());</a>
<a name="16600"><span class="lineNum">   16600 </span>            :                printf (&quot;result_declarationList.size() = %zu \n&quot;,result_declarationList.size());</a>
<a name="16601"><span class="lineNum">   16601 </span>            :              }</a>
<a name="16602"><span class="lineNum">   16602 </span>            :           ROSE_ASSERT(fileBeingCopied_declarationList.size() == result_declarationList.size());</a>
<a name="16603"><span class="lineNum">   16603 </span>            : </a>
<a name="16604"><span class="lineNum">   16604 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16605"><span class="lineNum">   16605 </span>            : </a>
<a name="16606"><span class="lineNum">   16606 </span>            : #if 0</a>
<a name="16607"><span class="lineNum">   16607 </span>            :           printf (&quot;Statements from global scope (size = %zu): \n&quot;,fileBeingCopied_declarationList.size());</a>
<a name="16608"><span class="lineNum">   16608 </span>            : #endif</a>
<a name="16609"><span class="lineNum">   16609 </span>            :           for (size_t i = 0; i &lt; fileBeingCopied_declarationList.size(); i++)</a>
<a name="16610"><span class="lineNum">   16610 </span>            :              {</a>
<a name="16611"><span class="lineNum">   16611 </span>            :                SgDeclarationStatement* fileBeingCopied_decl = fileBeingCopied_declarationList[i];</a>
<a name="16612"><span class="lineNum">   16612 </span>            :                SgDeclarationStatement* result_decl          = result_declarationList[i];</a>
<a name="16613"><span class="lineNum">   16613 </span>            : #if 0</a>
<a name="16614"><span class="lineNum">   16614 </span>            :                printf (&quot;  #%zu global scope entry: fileBeingCopied: %p %s result %p %s \n&quot;,i,fileBeingCopied_decl,fileBeingCopied_decl-&gt;class_name().c_str(),result_decl,result_decl-&gt;class_name().c_str());</a>
<a name="16615"><span class="lineNum">   16615 </span>            : #endif</a>
<a name="16616"><span class="lineNum">   16616 </span>            :                if (fileBeingCopied_decl == result_decl)</a>
<a name="16617"><span class="lineNum">   16617 </span>            :                   {</a>
<a name="16618"><span class="lineNum">   16618 </span>            : #if 0</a>
<a name="16619"><span class="lineNum">   16619 </span>            :                     printf (&quot;  --- SageBuilder::buildFile() is sharing this node: %p %s \n&quot;,fileBeingCopied_decl,fileBeingCopied_decl-&gt;class_name().c_str());</a>
<a name="16620"><span class="lineNum">   16620 </span>            : #endif</a>
<a name="16621"><span class="lineNum">   16621 </span>            :                  // DQ (11/10/2019): Need to recursively mark this as shared so that the unparser will be able to test each line?</a>
<a name="16622"><span class="lineNum">   16622 </span>            : </a>
<a name="16623"><span class="lineNum">   16623 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16624"><span class="lineNum">   16624 </span>            : </a>
<a name="16625"><span class="lineNum">   16625 </span>            :                     int fileBeingCopied_file_id = fileBeingCopied-&gt;get_startOfConstruct()-&gt;get_physical_file_id();</a>
<a name="16626"><span class="lineNum">   16626 </span>            :                     fixupSharingSourcePosition(fileBeingCopied_decl,fileBeingCopied_file_id);</a>
<a name="16627"><span class="lineNum">   16627 </span>            : #if 0</a>
<a name="16628"><span class="lineNum">   16628 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16629"><span class="lineNum">   16629 </span>            :                     ROSE_ABORT();</a>
<a name="16630"><span class="lineNum">   16630 </span>            : #endif</a>
<a name="16631"><span class="lineNum">   16631 </span>            :                   }</a>
<a name="16632"><span class="lineNum">   16632 </span>            :              }</a>
<a name="16633"><span class="lineNum">   16633 </span>            : </a>
<a name="16634"><span class="lineNum">   16634 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16635"><span class="lineNum">   16635 </span>            : </a>
<a name="16636"><span class="lineNum">   16636 </span>            : #endif</a>
<a name="16637"><span class="lineNum">   16637 </span>            : </a>
<a name="16638"><span class="lineNum">   16638 </span>            : #if 0</a>
<a name="16639"><span class="lineNum">   16639 </span>            :           printf (&quot;exiting as a test! \n&quot;);</a>
<a name="16640"><span class="lineNum">   16640 </span>            :           ROSE_ABORT();</a>
<a name="16641"><span class="lineNum">   16641 </span>            : #endif</a>
<a name="16642"><span class="lineNum">   16642 </span>            :         }</a>
<a name="16643"><span class="lineNum">   16643 </span>            : </a>
<a name="16644"><span class="lineNum">   16644 </span>            : #if 0</a>
<a name="16645"><span class="lineNum">   16645 </span>            :      reportModifiedStatements(&quot;Leaving SageBuilder::buildFile(): calling reportModifiedStatements()&quot;,project);</a>
<a name="16646"><span class="lineNum">   16646 </span>            : #endif</a>
<a name="16647"><span class="lineNum">   16647 </span>            : </a>
<a name="16648"><span class="lineNum">   16648 </span>            : #if 0</a>
<a name="16649"><span class="lineNum">   16649 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="16650"><span class="lineNum">   16650 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="16651"><span class="lineNum">   16651 </span>            :      printf (&quot;Leaving SageBuilder::buildFile(): (after result-&gt;runFrontend()): project = %p project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="16652"><span class="lineNum">   16652 </span>            :           project,project-&gt;get_fileList_ptr()-&gt;get_listOfFiles().size());</a>
<a name="16653"><span class="lineNum">   16653 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="16654"><span class="lineNum">   16654 </span>            :      printf (&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n&quot;);</a>
<a name="16655"><span class="lineNum">   16655 </span>            : #endif</a>
<a name="16656"><span class="lineNum">   16656 </span>            : </a>
<a name="16657"><span class="lineNum">   16657 </span>            : #if 0</a>
<a name="16658"><span class="lineNum">   16658 </span>            :   // DQ (11/8/2019): This is not working and breaks the current work at present.</a>
<a name="16659"><span class="lineNum">   16659 </span>            :   // DQ (11/8/2019): Support function to change the name in each of the IR node's source position info objects.</a>
<a name="16660"><span class="lineNum">   16660 </span>            :      fixupSourcePositionFileSpecification(result,outputFileName);</a>
<a name="16661"><span class="lineNum">   16661 </span>            : #endif</a>
<a name="16662"><span class="lineNum">   16662 </span>            : </a>
<a name="16663"><span class="lineNum">   16663 </span>            :   // DQ (7/2/2020): Added assertion (fails for snippet tests).</a>
<a name="16664"><span class="lineNum">   16664 </span><span class="lineCov">          4 :      ROSE_ASSERT(result-&gt;get_preprocessorDirectivesAndCommentsList() != NULL);</span></a>
<a name="16665"><span class="lineNum">   16665 </span>            : </a>
<a name="16666"><span class="lineNum">   16666 </span><span class="lineCov">          8 :      return result;</span></a>
<a name="16667"><span class="lineNum">   16667 </span>            : #else</a>
<a name="16668"><span class="lineNum">   16668 </span>            : </a>
<a name="16669"><span class="lineNum">   16669 </span>            :   // false branch of #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT (at top of function.</a>
<a name="16670"><span class="lineNum">   16670 </span>            : </a>
<a name="16671"><span class="lineNum">   16671 </span>            :      return NULL;</a>
<a name="16672"><span class="lineNum">   16672 </span>            : #endif</a>
<a name="16673"><span class="lineNum">   16673 </span>            :    }</a>
<a name="16674"><span class="lineNum">   16674 </span>            : </a>
<a name="16675"><span class="lineNum">   16675 </span>            : </a>
<a name="16676"><span class="lineNum">   16676 </span>            : //! Build a SgFile node</a>
<a name="16677"><span class="lineNum">   16677 </span>            : SgSourceFile*</a>
<a name="16678"><span class="lineNum">   16678 </span><span class="lineNoCov">          0 : SageBuilder::buildSourceFile(const std::string&amp; outputFileName, SgProject* project, bool clear_globalScopeAcrossFiles /*=false*/)</span></a>
<a name="16679"><span class="lineNum">   16679 </span>            :    {</a>
<a name="16680"><span class="lineNum">   16680 </span>            :   // DQ (2/9/2013): Adding support to build a SgSourceFile with an empty global scope.</a>
<a name="16681"><span class="lineNum">   16681 </span>            :   // This function calls the buildFile(string,string,SgProject*) function and provides</a>
<a name="16682"><span class="lineNum">   16682 </span>            :   // a simple API where one wants to create a new SgSourceFile that will then have</a>
<a name="16683"><span class="lineNum">   16683 </span>            :   // statements added to it and then unparsed.</a>
<a name="16684"><span class="lineNum">   16684 </span>            : </a>
<a name="16685"><span class="lineNum">   16685 </span>            :   // This function needs a way to specify the associated language for the generated file.</a>
<a name="16686"><span class="lineNum">   16686 </span>            :   // Currently this is taken from the input file (generated from a prefix on the output filename.</a>
<a name="16687"><span class="lineNum">   16687 </span>            : </a>
<a name="16688"><span class="lineNum">   16688 </span>            : #if 0</a>
<a name="16689"><span class="lineNum">   16689 </span>            :      printf (&quot;In SageBuilder::buildSourceFile(outputFileName = %s, project = %p) \n&quot;,outputFileName.c_str(),project);</a>
<a name="16690"><span class="lineNum">   16690 </span>            : #endif</a>
<a name="16691"><span class="lineNum">   16691 </span>            : </a>
<a name="16692"><span class="lineNum">   16692 </span>            :   // Call the supporting function to build a file.</a>
<a name="16693"><span class="lineNum">   16693 </span><span class="lineNoCov">          0 :      string inputFilePrefix = &quot;temp_dummy_file_&quot;;</span></a>
<a name="16694"><span class="lineNum">   16694 </span>            : </a>
<a name="16695"><span class="lineNum">   16695 </span>            : #if 0</a>
<a name="16696"><span class="lineNum">   16696 </span>            :      printf (&quot;In SageBuilder::buildSourceFile(const std::string&amp; outputFileName, SgProject* project): calling buildFile() \n&quot;);</a>
<a name="16697"><span class="lineNum">   16697 </span>            : #endif</a>
<a name="16698"><span class="lineNum">   16698 </span>            : </a>
<a name="16699"><span class="lineNum">   16699 </span><span class="lineNoCov">          0 :      SgFile* file = buildFile(inputFilePrefix+outputFileName,outputFileName,project,clear_globalScopeAcrossFiles);</span></a>
<a name="16700"><span class="lineNum">   16700 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(file != NULL);</span></a>
<a name="16701"><span class="lineNum">   16701 </span>            : </a>
<a name="16702"><span class="lineNum">   16702 </span>            : #if 0</a>
<a name="16703"><span class="lineNum">   16703 </span>            :      printf (&quot;DONE: In SageBuilder::buildSourceFile(): calling buildFile() \n&quot;);</a>
<a name="16704"><span class="lineNum">   16704 </span>            : #endif</a>
<a name="16705"><span class="lineNum">   16705 </span>            : </a>
<a name="16706"><span class="lineNum">   16706 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = isSgSourceFile(file);</span></a>
<a name="16707"><span class="lineNum">   16707 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFile != NULL);</span></a>
<a name="16708"><span class="lineNum">   16708 </span>            : </a>
<a name="16709"><span class="lineNum">   16709 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFile-&gt;get_globalScope() != NULL);</span></a>
<a name="16710"><span class="lineNum">   16710 </span>            : </a>
<a name="16711"><span class="lineNum">   16711 </span>            : #if 0</a>
<a name="16712"><span class="lineNum">   16712 </span>            :      printf (&quot;call the unparser on the just built file \n&quot;);</a>
<a name="16713"><span class="lineNum">   16713 </span>            : #endif</a>
<a name="16714"><span class="lineNum">   16714 </span>            : </a>
<a name="16715"><span class="lineNum">   16715 </span>            : #if 0</a>
<a name="16716"><span class="lineNum">   16716 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16717"><span class="lineNum">   16717 </span>            :      ROSE_ABORT();</a>
<a name="16718"><span class="lineNum">   16718 </span>            : #endif</a>
<a name="16719"><span class="lineNum">   16719 </span>            : </a>
<a name="16720"><span class="lineNum">   16720 </span><span class="lineNoCov">          0 :      return sourceFile;</span></a>
<a name="16721"><span class="lineNum">   16721 </span>            : </a>
<a name="16722"><span class="lineNum">   16722 </span>            :    }</a>
<a name="16723"><span class="lineNum">   16723 </span>            : </a>
<a name="16724"><span class="lineNum">   16724 </span><span class="lineNoCov">          0 : SgSourceFile* SageBuilder::buildSourceFile(const std::string&amp; inputFileName,const std::string&amp; outputFileName, SgProject* project, bool clear_globalScopeAcrossFiles /*=false*/)</span></a>
<a name="16725"><span class="lineNum">   16725 </span>            :    {</a>
<a name="16726"><span class="lineNum">   16726 </span>            : #if 0</a>
<a name="16727"><span class="lineNum">   16727 </span>            :      printf (&quot;In SageBuilder::buildSourceFile(const std::string&amp; inputFileName,const std::string&amp; outputFileName, SgProject* project): calling buildFile() \n&quot;);</a>
<a name="16728"><span class="lineNum">   16728 </span>            :   // printf (&quot; --- inputFileName  = %s outputFileName = %s \n&quot;,inputFileName.c_str(),outputFileName.c_str());</a>
<a name="16729"><span class="lineNum">   16729 </span>            :      printf (&quot; --- inputFileName  = %s \n&quot;,inputFileName.c_str());</a>
<a name="16730"><span class="lineNum">   16730 </span>            :      printf (&quot; --- outputFileName = %s \n&quot;,outputFileName.c_str());</a>
<a name="16731"><span class="lineNum">   16731 </span>            : #endif</a>
<a name="16732"><span class="lineNum">   16732 </span>            : </a>
<a name="16733"><span class="lineNum">   16733 </span><span class="lineNoCov">          0 :      SgFile* file = buildFile(inputFileName, outputFileName,project,clear_globalScopeAcrossFiles);</span></a>
<a name="16734"><span class="lineNum">   16734 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(file != NULL);</span></a>
<a name="16735"><span class="lineNum">   16735 </span>            : </a>
<a name="16736"><span class="lineNum">   16736 </span>            : #if 0</a>
<a name="16737"><span class="lineNum">   16737 </span>            :      printf (&quot;DONE: In SageBuilder::buildSourceFile(): calling buildFile() \n&quot;);</a>
<a name="16738"><span class="lineNum">   16738 </span>            : #endif</a>
<a name="16739"><span class="lineNum">   16739 </span>            : </a>
<a name="16740"><span class="lineNum">   16740 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = isSgSourceFile(file);</span></a>
<a name="16741"><span class="lineNum">   16741 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFile != NULL);</span></a>
<a name="16742"><span class="lineNum">   16742 </span>            : </a>
<a name="16743"><span class="lineNum">   16743 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFile-&gt;get_globalScope() != NULL);</span></a>
<a name="16744"><span class="lineNum">   16744 </span>            : </a>
<a name="16745"><span class="lineNum">   16745 </span>            : #if 0</a>
<a name="16746"><span class="lineNum">   16746 </span>            :   // DQ (9/18/2019): Adding support for debugging the header file optimization.</a>
<a name="16747"><span class="lineNum">   16747 </span>            :      printf (&quot;Debugging the unparsing header file optimization \n&quot;);</a>
<a name="16748"><span class="lineNum">   16748 </span>            : </a>
<a name="16749"><span class="lineNum">   16749 </span>            :      printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization()             = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16750"><span class="lineNum">   16750 </span>            :      printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16751"><span class="lineNum">   16751 </span>            :      printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16752"><span class="lineNum">   16752 </span>            : #endif</a>
<a name="16753"><span class="lineNum">   16753 </span>            : </a>
<a name="16754"><span class="lineNum">   16754 </span>            : #if 0</a>
<a name="16755"><span class="lineNum">   16755 </span>            :   // ROSE_ASSERT(sourceFile-&gt;get_header_file_unparsing_optimization_header_file() == false);</a>
<a name="16756"><span class="lineNum">   16756 </span>            : </a>
<a name="16757"><span class="lineNum">   16757 </span>            :   // DQ (9/18/2019): These are now set to true when the inputFileName matches a previously read file for which the optimizaton was turned on.</a>
<a name="16758"><span class="lineNum">   16758 </span>            :      ROSE_ASSERT(sourceFile-&gt;get_header_file_unparsing_optimization() == true);</a>
<a name="16759"><span class="lineNum">   16759 </span>            :      ROSE_ASSERT(sourceFile-&gt;get_header_file_unparsing_optimization_source_file() == true);</a>
<a name="16760"><span class="lineNum">   16760 </span>            :   // ROSE_ASSERT(sourceFile-&gt;get_header_file_unparsing_optimization_header_file() == true);</a>
<a name="16761"><span class="lineNum">   16761 </span>            :      ROSE_ASSERT(sourceFile-&gt;get_header_file_unparsing_optimization_header_file() == false);</a>
<a name="16762"><span class="lineNum">   16762 </span>            : #endif</a>
<a name="16763"><span class="lineNum">   16763 </span>            : </a>
<a name="16764"><span class="lineNum">   16764 </span>            :   // DQ (9/18/2019): Adding support for the header file optimization.</a>
<a name="16765"><span class="lineNum">   16765 </span>            :   // Check is this file matches an existing file and if so avoid regathering the CPP directives and comments (if posible).</a>
<a name="16766"><span class="lineNum">   16766 </span>            :   // If the original file was specified as being optimized for unparsing header files, then make this one similarly.</a>
<a name="16767"><span class="lineNum">   16767 </span><span class="lineNoCov">          0 :      SgFilePtrList &amp; fileList = project-&gt;get_fileList();</span></a>
<a name="16768"><span class="lineNum">   16768 </span>            : </a>
<a name="16769"><span class="lineNum">   16769 </span>            : #if 0</a>
<a name="16770"><span class="lineNum">   16770 </span>            :      printf (&quot;Looking for file = %s \n&quot;,inputFileName.c_str());</a>
<a name="16771"><span class="lineNum">   16771 </span>            : #endif</a>
<a name="16772"><span class="lineNum">   16772 </span>            : </a>
<a name="16773"><span class="lineNum">   16773 </span><span class="lineNoCov">          0 :      for (SgFilePtrList::iterator i = fileList.begin(); i != fileList.end(); i++)</span></a>
<a name="16774"><span class="lineNum">   16774 </span>            :         {</a>
<a name="16775"><span class="lineNum">   16775 </span><span class="lineNoCov">          0 :           SgFile* temp_file = *i;</span></a>
<a name="16776"><span class="lineNum">   16776 </span>            : #if 0</a>
<a name="16777"><span class="lineNum">   16777 </span>            :           printf (&quot;temp_file = %p = %s name = %s \n&quot;,temp_file,temp_file-&gt;class_name().c_str(),temp_file-&gt;getFileName().c_str());</a>
<a name="16778"><span class="lineNum">   16778 </span>            : #endif</a>
<a name="16779"><span class="lineNum">   16779 </span><span class="lineNoCov">          0 :           if (temp_file != file)</span></a>
<a name="16780"><span class="lineNum">   16780 </span>            :              {</a>
<a name="16781"><span class="lineNum">   16781 </span><span class="lineNoCov">          0 :                if (temp_file-&gt;getFileName() == file-&gt;getFileName())</span></a>
<a name="16782"><span class="lineNum">   16782 </span>            :                   {</a>
<a name="16783"><span class="lineNum">   16783 </span>            :                  // Then the temp_file is the original version of the file we are building for a second time</a>
<a name="16784"><span class="lineNum">   16784 </span>            :                  // (usually as a part of the outlining to a seperate file).  and we need to mark at least the</a>
<a name="16785"><span class="lineNum">   16785 </span>            :                  // unparsing headr file optimizations to be the same across thje two file.</a>
<a name="16786"><span class="lineNum">   16786 </span>            : </a>
<a name="16787"><span class="lineNum">   16787 </span><span class="lineNoCov">          0 :                     temp_file-&gt;set_header_file_unparsing_optimization(sourceFile-&gt;get_header_file_unparsing_optimization());</span></a>
<a name="16788"><span class="lineNum">   16788 </span><span class="lineNoCov">          0 :                     temp_file-&gt;set_header_file_unparsing_optimization_source_file(sourceFile-&gt;get_header_file_unparsing_optimization_source_file());</span></a>
<a name="16789"><span class="lineNum">   16789 </span><span class="lineNoCov">          0 :                     temp_file-&gt;set_header_file_unparsing_optimization_header_file(sourceFile-&gt;get_header_file_unparsing_optimization_header_file());</span></a>
<a name="16790"><span class="lineNum">   16790 </span>            : #if 0</a>
<a name="16791"><span class="lineNum">   16791 </span>            :                     printf (&quot;sourceFile = %p = %s \n&quot;,sourceFile,sourceFile-&gt;class_name().c_str());</a>
<a name="16792"><span class="lineNum">   16792 </span>            :                     printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization()             = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16793"><span class="lineNum">   16793 </span>            :                     printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16794"><span class="lineNum">   16794 </span>            :                     printf (&quot;sourceFile-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,sourceFile-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16795"><span class="lineNum">   16795 </span>            : </a>
<a name="16796"><span class="lineNum">   16796 </span>            :                     printf (&quot;temp_file = %p = %s \n&quot;,temp_file,temp_file-&gt;class_name().c_str());</a>
<a name="16797"><span class="lineNum">   16797 </span>            :                     printf (&quot;temp_file-&gt;get_header_file_unparsing_optimization()             = %s \n&quot;,temp_file-&gt;get_header_file_unparsing_optimization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16798"><span class="lineNum">   16798 </span>            :                     printf (&quot;temp_file-&gt;get_header_file_unparsing_optimization_source_file() = %s \n&quot;,temp_file-&gt;get_header_file_unparsing_optimization_source_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16799"><span class="lineNum">   16799 </span>            :                     printf (&quot;temp_file-&gt;get_header_file_unparsing_optimization_header_file() = %s \n&quot;,temp_file-&gt;get_header_file_unparsing_optimization_header_file() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16800"><span class="lineNum">   16800 </span>            : #endif</a>
<a name="16801"><span class="lineNum">   16801 </span>            :                   }</a>
<a name="16802"><span class="lineNum">   16802 </span>            :                  else</a>
<a name="16803"><span class="lineNum">   16803 </span>            :                   {</a>
<a name="16804"><span class="lineNum">   16804 </span>            :                  // This is a different file.</a>
<a name="16805"><span class="lineNum">   16805 </span>            :                   }</a>
<a name="16806"><span class="lineNum">   16806 </span>            :              }</a>
<a name="16807"><span class="lineNum">   16807 </span>            :           else</a>
<a name="16808"><span class="lineNum">   16808 </span>            :             {</a>
<a name="16809"><span class="lineNum">   16809 </span>            :            // This is the same file, already added to the SgProject file list (as it should be).</a>
<a name="16810"><span class="lineNum">   16810 </span>            :             }</a>
<a name="16811"><span class="lineNum">   16811 </span>            :         }</a>
<a name="16812"><span class="lineNum">   16812 </span>            : </a>
<a name="16813"><span class="lineNum">   16813 </span>            : </a>
<a name="16814"><span class="lineNum">   16814 </span>            : #if 0</a>
<a name="16815"><span class="lineNum">   16815 </span>            :      printf (&quot;sourceFile-&gt;get_file_info()-&gt;get_filename() = %s \n&quot;,sourceFile-&gt;get_file_info()-&gt;get_filename());</a>
<a name="16816"><span class="lineNum">   16816 </span>            :      int filename_id          = Sg_File_Info::get_nametofileid_map()[sourceFile-&gt;get_file_info()-&gt;get_filename()];</a>
<a name="16817"><span class="lineNum">   16817 </span>            :      int filename_physical_id = Sg_File_Info::get_nametofileid_map()[sourceFile-&gt;get_file_info()-&gt;get_filename()];</a>
<a name="16818"><span class="lineNum">   16818 </span>            :      printf (&quot;Sg_File_Info::get_nametofileid_map()[sourceFile-&gt;get_file_info()-&gt;get_filename()] = %d \n&quot;,filename_id);</a>
<a name="16819"><span class="lineNum">   16819 </span>            :      printf (&quot;Sg_File_Info::get_nametofileid_map()[sourceFile-&gt;get_file_info()-&gt;get_filename()] = %d \n&quot;,filename_physical_id);</a>
<a name="16820"><span class="lineNum">   16820 </span>            :      sourceFile-&gt;get_file_info()-&gt;set_physical_file_id(filename_physical_id);</a>
<a name="16821"><span class="lineNum">   16821 </span>            : </a>
<a name="16822"><span class="lineNum">   16822 </span>            :      printf (&quot;sourceFile-&gt;get_file_info()-&gt;get_physical_filename() = %s \n&quot;,sourceFile-&gt;get_file_info()-&gt;get_physical_filename().c_str());</a>
<a name="16823"><span class="lineNum">   16823 </span>            :      printf (&quot;sourceFile-&gt;get_file_info()-&gt;get_physical_file_id()  = %d \n&quot;,sourceFile-&gt;get_file_info()-&gt;get_physical_file_id());</a>
<a name="16824"><span class="lineNum">   16824 </span>            : #endif</a>
<a name="16825"><span class="lineNum">   16825 </span>            : </a>
<a name="16826"><span class="lineNum">   16826 </span>            : #if 0</a>
<a name="16827"><span class="lineNum">   16827 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16828"><span class="lineNum">   16828 </span>            :      ROSE_ABORT();</a>
<a name="16829"><span class="lineNum">   16829 </span>            : #endif</a>
<a name="16830"><span class="lineNum">   16830 </span>            : </a>
<a name="16831"><span class="lineNum">   16831 </span>            :   // DQ (1/11/2021): I think we should be calling secondaryPassOverSourceFile() instead of attachPreprocessingInfo() because we need to support the token-based unparsing.</a>
<a name="16832"><span class="lineNum">   16832 </span>            : #if 0</a>
<a name="16833"><span class="lineNum">   16833 </span>            : </a>
<a name="16834"><span class="lineNum">   16834 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16835"><span class="lineNum">   16835 </span>            : </a>
<a name="16836"><span class="lineNum">   16836 </span>            : #if 1</a>
<a name="16837"><span class="lineNum">   16837 </span>            :   // DQ (11/4/2019): I need to add this when I went back to testing tool_G.</a>
<a name="16838"><span class="lineNum">   16838 </span>            :   // It is required in the functions to attach CPP directives and comments.</a>
<a name="16839"><span class="lineNum">   16839 </span>            :      if (sourceFile-&gt;get_preprocessorDirectivesAndCommentsList() == NULL)</a>
<a name="16840"><span class="lineNum">   16840 </span>            :         {</a>
<a name="16841"><span class="lineNum">   16841 </span>            : #if 1</a>
<a name="16842"><span class="lineNum">   16842 </span>            :           printf (&quot;Initialize NULL p_preprocessorDirectivesAndCommentsList to empty ROSEAttributesListContainer \n&quot;);</a>
<a name="16843"><span class="lineNum">   16843 </span>            : #endif</a>
<a name="16844"><span class="lineNum">   16844 </span>            :           ROSEAttributesListContainer* tmp_preprocessorDirectivesAndCommentsList = new ROSEAttributesListContainer();</a>
<a name="16845"><span class="lineNum">   16845 </span>            :           sourceFile-&gt;set_preprocessorDirectivesAndCommentsList(tmp_preprocessorDirectivesAndCommentsList);</a>
<a name="16846"><span class="lineNum">   16846 </span>            :         }</a>
<a name="16847"><span class="lineNum">   16847 </span>            :        else</a>
<a name="16848"><span class="lineNum">   16848 </span>            :         {</a>
<a name="16849"><span class="lineNum">   16849 </span>            : #if 1</a>
<a name="16850"><span class="lineNum">   16850 </span>            :           printf (&quot;NOTE: p_preprocessorDirectivesAndCommentsList is already defined! \n&quot;);</a>
<a name="16851"><span class="lineNum">   16851 </span>            :           printf (&quot; --- inputFileName  = %s \n&quot;,inputFileName.c_str());</a>
<a name="16852"><span class="lineNum">   16852 </span>            :           printf (&quot; --- outputFileName = %s \n&quot;,outputFileName.c_str());</a>
<a name="16853"><span class="lineNum">   16853 </span>            :           printf (&quot; --- sourceFile-&gt;get_preprocessorDirectivesAndCommentsList()-&gt;getList().size() = %zu \n&quot;,sourceFile-&gt;get_preprocessorDirectivesAndCommentsList()-&gt;getList().size());</a>
<a name="16854"><span class="lineNum">   16854 </span>            : #endif</a>
<a name="16855"><span class="lineNum">   16855 </span>            :         }</a>
<a name="16856"><span class="lineNum">   16856 </span>            :      ROSE_ASSERT (sourceFile-&gt;get_preprocessorDirectivesAndCommentsList() != NULL);</a>
<a name="16857"><span class="lineNum">   16857 </span>            : </a>
<a name="16858"><span class="lineNum">   16858 </span>            : #if 0</a>
<a name="16859"><span class="lineNum">   16859 </span>            :   // DQ (5/22/2020): If this is processing a previously processed file, then this</a>
<a name="16860"><span class="lineNum">   16860 </span>            :   // will cause comments and CPP directives to be collected twice. This happens</a>
<a name="16861"><span class="lineNum">   16861 </span>            :   // in the case where we build a copy of the source file to support construction</a>
<a name="16862"><span class="lineNum">   16862 </span>            :   // of a dynamic library.</a>
<a name="16863"><span class="lineNum">   16863 </span>            :      printf (&quot;NOTE: SageBuilder::buildSourceFile(): If this is processing a previously processed source file then this will cause the source file comments and CPP directives to be collected redundently \n&quot;);</a>
<a name="16864"><span class="lineNum">   16864 </span>            : #endif</a>
<a name="16865"><span class="lineNum">   16865 </span>            : </a>
<a name="16866"><span class="lineNum">   16866 </span>            :   // DQ (11/4/2019): This is a test that is use in attaching CPP directives and comments to the AST.</a>
<a name="16867"><span class="lineNum">   16867 </span>            :      ROSEAttributesListContainerPtr filePreprocInfo = sourceFile-&gt;get_preprocessorDirectivesAndCommentsList();</a>
<a name="16868"><span class="lineNum">   16868 </span>            :      ROSE_ASSERT(filePreprocInfo != NULL);</a>
<a name="16869"><span class="lineNum">   16869 </span>            : #endif</a>
<a name="16870"><span class="lineNum">   16870 </span>            : </a>
<a name="16871"><span class="lineNum">   16871 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16872"><span class="lineNum">   16872 </span>            : </a>
<a name="16873"><span class="lineNum">   16873 </span>            : #if 0</a>
<a name="16874"><span class="lineNum">   16874 </span>            :      printf (&quot;In SageBuilder::buildSourceFile(const std::string&amp; inputFileName,const std::string&amp; outputFileName, SgProject* project): calling attachPreprocessingInfo() \n&quot;);</a>
<a name="16875"><span class="lineNum">   16875 </span>            :      printf (&quot; --- sourceFile-&gt;get_preprocessorDirectivesAndCommentsList()-&gt;getList().size() = %zu \n&quot;,sourceFile-&gt;get_preprocessorDirectivesAndCommentsList()-&gt;getList().size());</a>
<a name="16876"><span class="lineNum">   16876 </span>            : #endif</a>
<a name="16877"><span class="lineNum">   16877 </span>            : </a>
<a name="16878"><span class="lineNum">   16878 </span>            : #if 0</a>
<a name="16879"><span class="lineNum">   16879 </span>            :   // DQ (12/3/2020): This is the root of the problem, the comments are built for the outputFileName, but the comments are marked with the inputFileName.</a>
<a name="16880"><span class="lineNum">   16880 </span>            :      printf (&quot;We read the comments in filename inputFileName, and build outputFileName, and this is a problem since the comments are marked with the inputFileName \n&quot;);</a>
<a name="16881"><span class="lineNum">   16881 </span>            :      printf (&quot; --- inputFileName  = %s \n&quot;,inputFileName.c_str());</a>
<a name="16882"><span class="lineNum">   16882 </span>            :      printf (&quot; --- outputFileName = %s \n&quot;,outputFileName.c_str());</a>
<a name="16883"><span class="lineNum">   16883 </span>            :      printf (&quot;sourceFile                                   = %p \n&quot;,sourceFile);</a>
<a name="16884"><span class="lineNum">   16884 </span>            :      printf (&quot;sourceFile-&gt;get_token_list.size()            = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="16885"><span class="lineNum">   16885 </span>            :      printf (&quot;sourceFile-&gt;get_tokenSubsequenceMap().size() = %zu \n&quot;,sourceFile-&gt;get_tokenSubsequenceMap().size());</a>
<a name="16886"><span class="lineNum">   16886 </span>            : #endif</a>
<a name="16887"><span class="lineNum">   16887 </span>            : </a>
<a name="16888"><span class="lineNum">   16888 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="16889"><span class="lineNum">   16889 </span>            : </a>
<a name="16890"><span class="lineNum">   16890 </span>            :   // DQ (1/4/2020): Adding support to permit comments and CPP directives and token stream to be defined using the outputFileName.</a>
<a name="16891"><span class="lineNum">   16891 </span>            :   // Liao, 2019, 1/31: We often need the preprocessing info. (e.g. #include ..) attached to make the new file compilable.</a>
<a name="16892"><span class="lineNum">   16892 </span>            :   // attachPreprocessingInfo (sourceFile);</a>
<a name="16893"><span class="lineNum">   16893 </span>            :      attachPreprocessingInfo (sourceFile,outputFileName);</a>
<a name="16894"><span class="lineNum">   16894 </span>            : #else</a>
<a name="16895"><span class="lineNum">   16895 </span>            :   // DQ (1/11/2021): Call the secondaryPassOverSourceFile() instead of attachPreprocessingInfo() because we need to support the token-based unparsing.</a>
<a name="16896"><span class="lineNum">   16896 </span>            :      //file-&gt;secondaryPassOverSourceFile();</a>
<a name="16897"><span class="lineNum">   16897 </span><span class="lineNoCov">          0 :      attachPreprocessingInfo (sourceFile);</span></a>
<a name="16898"><span class="lineNum">   16898 </span>            : #endif</a>
<a name="16899"><span class="lineNum">   16899 </span>            : </a>
<a name="16900"><span class="lineNum">   16900 </span>            : #if 0</a>
<a name="16901"><span class="lineNum">   16901 </span>            :      printf (&quot;Exiting after test! processed first phase of collecting comments and CPP directives for source file) \n&quot;);</a>
<a name="16902"><span class="lineNum">   16902 </span>            :      ROSE_ASSERT(false);</a>
<a name="16903"><span class="lineNum">   16903 </span>            : #endif</a>
<a name="16904"><span class="lineNum">   16904 </span>            : </a>
<a name="16905"><span class="lineNum">   16905 </span>            : #if 0</a>
<a name="16906"><span class="lineNum">   16906 </span>            :      printf (&quot;DONE: In SageBuilder::buildSourceFile(const std::string&amp; inputFileName,const std::string&amp; outputFileName, SgProject* project): calling attachPreprocessingInfo() \n&quot;);</a>
<a name="16907"><span class="lineNum">   16907 </span>            : #endif</a>
<a name="16908"><span class="lineNum">   16908 </span>            : </a>
<a name="16909"><span class="lineNum">   16909 </span>            : #if 0</a>
<a name="16910"><span class="lineNum">   16910 </span>            :      printf (&quot;call the unparser on the just built file \n&quot;);</a>
<a name="16911"><span class="lineNum">   16911 </span>            : #endif</a>
<a name="16912"><span class="lineNum">   16912 </span>            : </a>
<a name="16913"><span class="lineNum">   16913 </span>            : #if 0</a>
<a name="16914"><span class="lineNum">   16914 </span>            :      printf (&quot;In buildSourceFile(): AS A TEST: calling unparseFile(): filename = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</a>
<a name="16915"><span class="lineNum">   16915 </span>            :      backend(project);</a>
<a name="16916"><span class="lineNum">   16916 </span>            : #endif</a>
<a name="16917"><span class="lineNum">   16917 </span>            : </a>
<a name="16918"><span class="lineNum">   16918 </span>            : #if 1</a>
<a name="16919"><span class="lineNum">   16919 </span>            :   // DQ (11/8/2019): This is not working and breaks the current work at present.</a>
<a name="16920"><span class="lineNum">   16920 </span>            :   // DQ (11/8/2019): Support function to change the name in each of the IR node's source position info objects.</a>
<a name="16921"><span class="lineNum">   16921 </span><span class="lineNoCov">          0 :      fixupSourcePositionFileSpecification(sourceFile,outputFileName);</span></a>
<a name="16922"><span class="lineNum">   16922 </span>            : #endif</a>
<a name="16923"><span class="lineNum">   16923 </span>            : </a>
<a name="16924"><span class="lineNum">   16924 </span>            :   // DQ (1/8/2021): Set the filename used in the generated SgSourceFile to be the output file.</a>
<a name="16925"><span class="lineNum">   16925 </span>            :   // This appears to be important so that we can get either key correct for the comments and CPP</a>
<a name="16926"><span class="lineNum">   16926 </span>            :   // directives and or the comments and CPP directives to be consistant as well as the token stream,</a>
<a name="16927"><span class="lineNum">   16927 </span>            :   // I think this might be less about the comments and CPP directives than the key for the token stream.</a>
<a name="16928"><span class="lineNum">   16928 </span>            :   // Either that or I need to have an extra field for the SgSourceFile name when it is read from one</a>
<a name="16929"><span class="lineNum">   16929 </span>            :   // file, but trying to be another file.</a>
<a name="16930"><span class="lineNum">   16930 </span>            :   // sourceFile-&gt;setFileName(outputFileName);</a>
<a name="16931"><span class="lineNum">   16931 </span>            : </a>
<a name="16932"><span class="lineNum">   16932 </span>            : #if 0</a>
<a name="16933"><span class="lineNum">   16933 </span>            :      printf (&quot;In SageBuilder::buildSourceFile(): changing the name of the file represented in sourceFile: \n&quot;);</a>
<a name="16934"><span class="lineNum">   16934 </span>            :      printf (&quot;inputFileName   = %s \n&quot;,inputFileName.c_str());</a>
<a name="16935"><span class="lineNum">   16935 </span>            :      printf (&quot;outputFileName  = %s \n&quot;,outputFileName.c_str());</a>
<a name="16936"><span class="lineNum">   16936 </span>            :      printf (&quot;sourceFile-&gt;getFileName() = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</a>
<a name="16937"><span class="lineNum">   16937 </span>            : #endif</a>
<a name="16938"><span class="lineNum">   16938 </span>            : </a>
<a name="16939"><span class="lineNum">   16939 </span>            : #if 0</a>
<a name="16940"><span class="lineNum">   16940 </span>            :      printf (&quot;Leaving SageBuilder::buildSourceFile() sourceFile = %p globalScope = %p \n&quot;,sourceFile,sourceFile-&gt;get_globalScope());</a>
<a name="16941"><span class="lineNum">   16941 </span>            :      printf (&quot;sourceFile-&gt;get_file_info()-&gt;get_file_id()          = %d \n&quot;,sourceFile-&gt;get_file_info()-&gt;get_file_id());</a>
<a name="16942"><span class="lineNum">   16942 </span>            :      printf (&quot;sourceFile-&gt;get_file_info()-&gt;get_physical_file_id() = %d \n&quot;,sourceFile-&gt;get_file_info()-&gt;get_physical_file_id());</a>
<a name="16943"><span class="lineNum">   16943 </span>            :      printf (&quot;sourceFile-&gt;get_token_list.size()                   = %zu \n&quot;,sourceFile-&gt;get_token_list().size());</a>
<a name="16944"><span class="lineNum">   16944 </span>            :      printf (&quot;sourceFile-&gt;get_tokenSubsequenceMap().size()        = %zu \n&quot;,sourceFile-&gt;get_tokenSubsequenceMap().size());</a>
<a name="16945"><span class="lineNum">   16945 </span>            : #endif</a>
<a name="16946"><span class="lineNum">   16946 </span>            : </a>
<a name="16947"><span class="lineNum">   16947 </span>            : #if 0</a>
<a name="16948"><span class="lineNum">   16948 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16949"><span class="lineNum">   16949 </span>            :      ROSE_ABORT();</a>
<a name="16950"><span class="lineNum">   16950 </span>            : #endif</a>
<a name="16951"><span class="lineNum">   16951 </span>            : </a>
<a name="16952"><span class="lineNum">   16952 </span><span class="lineNoCov">          0 :      return sourceFile;</span></a>
<a name="16953"><span class="lineNum">   16953 </span>            :    }</a>
<a name="16954"><span class="lineNum">   16954 </span>            : </a>
<a name="16955"><span class="lineNum">   16955 </span>            : </a>
<a name="16956"><span class="lineNum">   16956 </span><span class="lineNoCov">          0 : PreprocessingInfo* SageBuilder::buildComment(SgLocatedNode* target, const std::string &amp; content,PreprocessingInfo::RelativePositionType position/*=PreprocessingInfo::before*/,PreprocessingInfo::DirectiveType dtype/* = PreprocessingInfo::CpreprocessorUnknownDeclaration*/)</span></a>
<a name="16957"><span class="lineNum">   16957 </span>            :    {</a>
<a name="16958"><span class="lineNum">   16958 </span><span class="lineNoCov">          0 :      return SageInterface::attachComment(target,content, position, dtype);</span></a>
<a name="16959"><span class="lineNum">   16959 </span>            :    }</a>
<a name="16960"><span class="lineNum">   16960 </span>            : </a>
<a name="16961"><span class="lineNum">   16961 </span>            : //! Build a dangling #include &quot;x.h&quot; header,  insertHeader() is needed to actually insert it</a>
<a name="16962"><span class="lineNum">   16962 </span><span class="lineNoCov">          0 : PreprocessingInfo* SageBuilder::buildHeader(const std::string&amp; header_filename,</span></a>
<a name="16963"><span class="lineNum">   16963 </span>            :                PreprocessingInfo::RelativePositionType position/*=PreprocessingInfo::before*/,</a>
<a name="16964"><span class="lineNum">   16964 </span>            :                               bool isSystemHeader/* =false*/)</a>
<a name="16965"><span class="lineNum">   16965 </span>            : {</a>
<a name="16966"><span class="lineNum">   16966 </span><span class="lineNoCov">          0 :   std::string content;</span></a>
<a name="16967"><span class="lineNum">   16967 </span><span class="lineNoCov">          0 :   if (isSystemHeader)</span></a>
<a name="16968"><span class="lineNum">   16968 </span><span class="lineNoCov">          0 :     content = &quot;#include &lt;&quot; + header_filename + &quot;&gt; \n&quot;;</span></a>
<a name="16969"><span class="lineNum">   16969 </span>            :   else</a>
<a name="16970"><span class="lineNum">   16970 </span><span class="lineNoCov">          0 :     content = &quot;#include \&quot;&quot; + header_filename + &quot;\&quot; \n&quot;;</span></a>
<a name="16971"><span class="lineNum">   16971 </span><span class="lineNoCov">          0 :   PreprocessingInfo* result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration,</span></a>
<a name="16972"><span class="lineNum">   16972 </span><span class="lineNoCov">          0 :       content, &quot;Transformation generated&quot;,0, 0, 0, position);</span></a>
<a name="16973"><span class="lineNum">   16973 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="16974"><span class="lineNum">   16974 </span>            : </a>
<a name="16975"><span class="lineNum">   16975 </span><span class="lineNoCov">          0 :   result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="16976"><span class="lineNum">   16976 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="16977"><span class="lineNum">   16977 </span>            : }</a>
<a name="16978"><span class="lineNum">   16978 </span>            : </a>
<a name="16979"><span class="lineNum">   16979 </span>            : //! #define xxx yyy</a>
<a name="16980"><span class="lineNum">   16980 </span><span class="lineCov">          1 : PreprocessingInfo* SageBuilder::buildCpreprocessorDefineDeclaration(SgLocatedNode* target,const std::string &amp; content,PreprocessingInfo::RelativePositionType position /* =PreprocessingInfo::before*/)</span></a>
<a name="16981"><span class="lineNum">   16981 </span>            :   {</a>
<a name="16982"><span class="lineNum">   16982 </span><span class="lineCov">          1 :     ROSE_ASSERT(target != NULL); //dangling #define xxx is not allowed in the ROSE AST</span></a>
<a name="16983"><span class="lineNum">   16983 </span>            :     // simple input verification</a>
<a name="16984"><span class="lineNum">   16984 </span><span class="lineCov">          1 :     std::string content2 = content;</span></a>
<a name="16985"><span class="lineNum">   16985 </span><span class="lineCov">          1 :     boost::algorithm::trim(content2);</span></a>
<a name="16986"><span class="lineNum">   16986 </span><span class="lineCov">          2 :     string prefix = &quot;#define&quot;;</span></a>
<a name="16987"><span class="lineNum">   16987 </span><span class="lineCov">          1 :     string::size_type pos = content2.find(prefix, 0);</span></a>
<a name="16988"><span class="lineNum">   16988 </span><span class="lineCov">          1 :     ROSE_ASSERT (pos == 0);</span></a>
<a name="16989"><span class="lineNum">   16989 </span>            : </a>
<a name="16990"><span class="lineNum">   16990 </span><span class="lineCov">          1 :     PreprocessingInfo* result = NULL;</span></a>
<a name="16991"><span class="lineNum">   16991 </span>            : </a>
<a name="16992"><span class="lineNum">   16992 </span><span class="lineCov">          1 :     PreprocessingInfo::DirectiveType mytype = PreprocessingInfo::CpreprocessorDefineDeclaration;</span></a>
<a name="16993"><span class="lineNum">   16993 </span>            : </a>
<a name="16994"><span class="lineNum">   16994 </span>            :  // DQ (7/19/2008): Modified interface to PreprocessingInfo</a>
<a name="16995"><span class="lineNum">   16995 </span>            :  // result = new PreprocessingInfo (mytype,content, &quot;transformation-generated&quot;, 0, 0, 0, position, false, true);</a>
<a name="16996"><span class="lineNum">   16996 </span><span class="lineCov">          1 :     result = new PreprocessingInfo (mytype,content, &quot;transformation-generated&quot;, 0, 0, 0, position);</span></a>
<a name="16997"><span class="lineNum">   16997 </span><span class="lineCov">          1 :     ROSE_ASSERT(result);</span></a>
<a name="16998"><span class="lineNum">   16998 </span><span class="lineCov">          1 :     target-&gt;addToAttachedPreprocessingInfo(result);</span></a>
<a name="16999"><span class="lineNum">   16999 </span><span class="lineCov">          2 :     return result;</span></a>
<a name="17000"><span class="lineNum">   17000 </span>            : </a>
<a name="17001"><span class="lineNum">   17001 </span>            :   }</a>
<a name="17002"><span class="lineNum">   17002 </span>            : </a>
<a name="17003"><span class="lineNum">   17003 </span>            : </a>
<a name="17004"><span class="lineNum">   17004 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="17005"><span class="lineNum">   17005 </span>            : //! Build an abstract handle from a SgNode</a>
<a name="17006"><span class="lineNum">   17006 </span><span class="lineCov">         30 : AbstractHandle::abstract_handle * SageBuilder::buildAbstractHandle(SgNode* n)</span></a>
<a name="17007"><span class="lineNum">   17007 </span>            : {</a>
<a name="17008"><span class="lineNum">   17008 </span>            :   // avoid duplicated creation</a>
<a name="17009"><span class="lineNum">   17009 </span><span class="lineCov">         30 :   static std::map&lt;SgNode*, AbstractHandle::abstract_handle *&gt; handleMap;</span></a>
<a name="17010"><span class="lineNum">   17010 </span>            : </a>
<a name="17011"><span class="lineNum">   17011 </span><span class="lineCov">         30 :   ROSE_ASSERT(n != NULL);</span></a>
<a name="17012"><span class="lineNum">   17012 </span><span class="lineCov">         30 :   AbstractHandle::abstract_handle * ahandle =handleMap[n];</span></a>
<a name="17013"><span class="lineNum">   17013 </span><span class="lineCov">         30 :   if (ahandle==NULL)</span></a>
<a name="17014"><span class="lineNum">   17014 </span>            :   {</a>
<a name="17015"><span class="lineNum">   17015 </span><span class="lineCov">         30 :     AbstractHandle::abstract_node* anode = AbstractHandle::buildroseNode(n);</span></a>
<a name="17016"><span class="lineNum">   17016 </span><span class="lineCov">         30 :     ROSE_ASSERT(anode !=NULL );</span></a>
<a name="17017"><span class="lineNum">   17017 </span><span class="lineCov">         30 :     ahandle = new AbstractHandle::abstract_handle(anode);</span></a>
<a name="17018"><span class="lineNum">   17018 </span>            :     //TODO do we allow NULL handle to be returned?</a>
<a name="17019"><span class="lineNum">   17019 </span><span class="lineCov">         30 :     ROSE_ASSERT(ahandle != NULL);</span></a>
<a name="17020"><span class="lineNum">   17020 </span>            :   }</a>
<a name="17021"><span class="lineNum">   17021 </span><span class="lineCov">         30 :   return ahandle;</span></a>
<a name="17022"><span class="lineNum">   17022 </span>            : }</a>
<a name="17023"><span class="lineNum">   17023 </span>            : #endif</a>
<a name="17024"><span class="lineNum">   17024 </span>            : </a>
<a name="17025"><span class="lineNum">   17025 </span>            : SgEquivalenceStatement*</a>
<a name="17026"><span class="lineNum">   17026 </span><span class="lineNoCov">          0 : SageBuilder::buildEquivalenceStatement(SgExpression* exp1,SgExpression* exp2)</span></a>
<a name="17027"><span class="lineNum">   17027 </span>            : {</a>
<a name="17028"><span class="lineNum">   17028 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(exp1 != NULL);</span></a>
<a name="17029"><span class="lineNum">   17029 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(exp2 != NULL);</span></a>
<a name="17030"><span class="lineNum">   17030 </span>            : </a>
<a name="17031"><span class="lineNum">   17031 </span><span class="lineNoCov">          0 :   SgExprListExp* tuple = buildExprListExp(exp1,exp2);</span></a>
<a name="17032"><span class="lineNum">   17032 </span><span class="lineNoCov">          0 :   SgExprListExp* setList = buildExprListExp(tuple);</span></a>
<a name="17033"><span class="lineNum">   17033 </span><span class="lineNoCov">          0 :   SgEquivalenceStatement* equivalenceStatement = new SgEquivalenceStatement();</span></a>
<a name="17034"><span class="lineNum">   17034 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(equivalenceStatement-&gt;get_equivalence_set_list() == NULL);</span></a>
<a name="17035"><span class="lineNum">   17035 </span><span class="lineNoCov">          0 :   equivalenceStatement-&gt;set_equivalence_set_list(setList);</span></a>
<a name="17036"><span class="lineNum">   17036 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(equivalenceStatement-&gt;get_equivalence_set_list() != NULL);</span></a>
<a name="17037"><span class="lineNum">   17037 </span><span class="lineNoCov">          0 :   equivalenceStatement-&gt;set_firstNondefiningDeclaration(equivalenceStatement);</span></a>
<a name="17038"><span class="lineNum">   17038 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(equivalenceStatement);</span></a>
<a name="17039"><span class="lineNum">   17039 </span><span class="lineNoCov">          0 :   return equivalenceStatement;</span></a>
<a name="17040"><span class="lineNum">   17040 </span>            : }</a>
<a name="17041"><span class="lineNum">   17041 </span>            : </a>
<a name="17042"><span class="lineNum">   17042 </span>            : SgSymbol*</a>
<a name="17043"><span class="lineNum">   17043 </span><span class="lineNoCov">          0 : SageBuilder::findAssociatedSymbolInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope)</span></a>
<a name="17044"><span class="lineNum">   17044 </span>            :    {</a>
<a name="17045"><span class="lineNum">   17045 </span>            :   // Starting at the snippet_declaration, record the associated scope list to the global scope.</a>
<a name="17046"><span class="lineNum">   17046 </span>            :   // The do a reverse traversal on the list starting with the global scope of the target AST.</a>
<a name="17047"><span class="lineNum">   17047 </span>            :   // Lookup each declaration as we proceed deeper into the target AST to find the associated</a>
<a name="17048"><span class="lineNum">   17048 </span>            :   // symbol in the target AST (associated with the input declaration from the snippet AST).</a>
<a name="17049"><span class="lineNum">   17049 </span>            : </a>
<a name="17050"><span class="lineNum">   17050 </span><span class="lineNoCov">          0 :      SgSymbol* returnSymbol = NULL;</span></a>
<a name="17051"><span class="lineNum">   17051 </span>            : </a>
<a name="17052"><span class="lineNum">   17052 </span><span class="lineNoCov">          0 :      typedef Rose_STL_Container&lt;SgScopeStatement*&gt;  SgScopeStatementPtrList;</span></a>
<a name="17053"><span class="lineNum">   17053 </span><span class="lineNoCov">          0 :      SgScopeStatementPtrList snippet_scope_list;</span></a>
<a name="17054"><span class="lineNum">   17054 </span>            : </a>
<a name="17055"><span class="lineNum">   17055 </span>            :   // Starting at the snippet_declaration, record the associated scope list to the global scope.</a>
<a name="17056"><span class="lineNum">   17056 </span>            :   // SgScopeStatement* snippet_scope = snippet_declaration-&gt;get_scope();</a>
<a name="17057"><span class="lineNum">   17057 </span><span class="lineNoCov">          0 :      SgScopeStatement* snippet_scope = snippet_declaration-&gt;get_scope();</span></a>
<a name="17058"><span class="lineNum">   17058 </span>            : #if 1</a>
<a name="17059"><span class="lineNum">   17059 </span><span class="lineNoCov">          0 :      printf (&quot;First scope = %p = %s \n&quot;,snippet_scope,snippet_scope-&gt;class_name().c_str());</span></a>
<a name="17060"><span class="lineNum">   17060 </span><span class="lineNoCov">          0 :      SgClassDefinition* temp_classDefinition = isSgClassDefinition(snippet_scope);</span></a>
<a name="17061"><span class="lineNum">   17061 </span><span class="lineNoCov">          0 :      if (temp_classDefinition != NULL)</span></a>
<a name="17062"><span class="lineNum">   17062 </span>            :         {</a>
<a name="17063"><span class="lineNum">   17063 </span><span class="lineNoCov">          0 :           SgClassDeclaration* temp_classDeclaration = temp_classDefinition-&gt;get_declaration();</span></a>
<a name="17064"><span class="lineNum">   17064 </span><span class="lineNoCov">          0 :           SgName className = temp_classDeclaration-&gt;get_name();</span></a>
<a name="17065"><span class="lineNum">   17065 </span>            : #if 1</a>
<a name="17066"><span class="lineNum">   17066 </span><span class="lineNoCov">          0 :           printf (&quot;Input snippet declaration's class name = %s \n&quot;,className.str());</span></a>
<a name="17067"><span class="lineNum">   17067 </span>            : #endif</a>
<a name="17068"><span class="lineNum">   17068 </span>            :         }</a>
<a name="17069"><span class="lineNum">   17069 </span><span class="lineNoCov">          0 :      SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(snippet_scope);</span></a>
<a name="17070"><span class="lineNum">   17070 </span><span class="lineNoCov">          0 :      if (namespaceDefinitionStatement != NULL)</span></a>
<a name="17071"><span class="lineNum">   17071 </span>            :         {</a>
<a name="17072"><span class="lineNum">   17072 </span>            : </a>
<a name="17073"><span class="lineNum">   17073 </span>            :         }</a>
<a name="17074"><span class="lineNum">   17074 </span>            : #endif</a>
<a name="17075"><span class="lineNum">   17075 </span><span class="lineNoCov">          0 :      snippet_scope_list.push_back(snippet_scope);</span></a>
<a name="17076"><span class="lineNum">   17076 </span><span class="lineNoCov">          0 :      while (snippet_scope != NULL &amp;&amp; isSgGlobal(snippet_scope) == NULL)</span></a>
<a name="17077"><span class="lineNum">   17077 </span>            :         {</a>
<a name="17078"><span class="lineNum">   17078 </span>            :        // The scopes between the snippet declaration and the global scope should be named scopes,</a>
<a name="17079"><span class="lineNum">   17079 </span>            :        // else we will not be able to identify the associated scope in the target AST.</a>
<a name="17080"><span class="lineNum">   17080 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(snippet_scope-&gt;isNamedScope() == true);</span></a>
<a name="17081"><span class="lineNum">   17081 </span>            : </a>
<a name="17082"><span class="lineNum">   17082 </span><span class="lineNoCov">          0 :           snippet_scope = snippet_scope-&gt;get_scope();</span></a>
<a name="17083"><span class="lineNum">   17083 </span>            : #if 1</a>
<a name="17084"><span class="lineNum">   17084 </span><span class="lineNoCov">          0 :           printf (&quot;snippet_scope = %p = %s \n&quot;,snippet_scope,snippet_scope-&gt;class_name().c_str());</span></a>
<a name="17085"><span class="lineNum">   17085 </span>            : #endif</a>
<a name="17086"><span class="lineNum">   17086 </span><span class="lineNoCov">          0 :           snippet_scope_list.push_back(snippet_scope);</span></a>
<a name="17087"><span class="lineNum">   17087 </span>            :         }</a>
<a name="17088"><span class="lineNum">   17088 </span>            : </a>
<a name="17089"><span class="lineNum">   17089 </span>            : #if 1</a>
<a name="17090"><span class="lineNum">   17090 </span><span class="lineNoCov">          0 :      printf (&quot;snippet_scope_list.size() = %&quot; PRIuPTR &quot; \n&quot;,snippet_scope_list.size());</span></a>
<a name="17091"><span class="lineNum">   17091 </span>            : #endif</a>
<a name="17092"><span class="lineNum">   17092 </span>            : </a>
<a name="17093"><span class="lineNum">   17093 </span><span class="lineNoCov">          0 :      SgGlobal* global_scope_in_target_ast = TransformationSupport::getGlobalScope(targetScope);</span></a>
<a name="17094"><span class="lineNum">   17094 </span><span class="lineNoCov">          0 :      SgScopeStatementPtrList::reverse_iterator i = snippet_scope_list.rbegin();</span></a>
<a name="17095"><span class="lineNum">   17095 </span>            : </a>
<a name="17096"><span class="lineNum">   17096 </span><span class="lineNoCov">          0 :      SgScopeStatement* target_AST_scope  = global_scope_in_target_ast;</span></a>
<a name="17097"><span class="lineNum">   17097 </span><span class="lineNoCov">          0 :      SgScopeStatement* snippet_AST_scope = *i;</span></a>
<a name="17098"><span class="lineNum">   17098 </span>            : </a>
<a name="17099"><span class="lineNum">   17099 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isSgGlobal(snippet_AST_scope) != NULL);</span></a>
<a name="17100"><span class="lineNum">   17100 </span>            :   // Iterate past the global scope</a>
<a name="17101"><span class="lineNum">   17101 </span><span class="lineNoCov">          0 :      i++;</span></a>
<a name="17102"><span class="lineNum">   17102 </span>            : </a>
<a name="17103"><span class="lineNum">   17103 </span>            :   // Traverse the snippet scopes in the reverse order from global scope to the associated scope in the target AST.</a>
<a name="17104"><span class="lineNum">   17104 </span><span class="lineNoCov">          0 :      while (i != snippet_scope_list.rend())</span></a>
<a name="17105"><span class="lineNum">   17105 </span>            :         {</a>
<a name="17106"><span class="lineNum">   17106 </span>            :        // This loop has to handle different types of names scopes (for C this only means structs, I think).</a>
<a name="17107"><span class="lineNum">   17107 </span>            : #if 1</a>
<a name="17108"><span class="lineNum">   17108 </span><span class="lineNoCov">          0 :           printf (&quot;snippet_AST_scope list *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</span></a>
<a name="17109"><span class="lineNum">   17109 </span>            : #endif</a>
<a name="17110"><span class="lineNum">   17110 </span>            :        // printf (&quot;target_AST_scope = %p = %s \n&quot;,target_AST_scope,target_AST_scope -&gt;class_name().c_str());</a>
<a name="17111"><span class="lineNum">   17111 </span>            :        // printf (&quot;snippet_AST_scope = %p = %s \n&quot;,snippet_AST_scope,snippet_AST_scope -&gt;class_name().c_str());</a>
<a name="17112"><span class="lineNum">   17112 </span>            : </a>
<a name="17113"><span class="lineNum">   17113 </span>            :        // DQ (12/5/2020): I think this should be a switch statement.</a>
<a name="17114"><span class="lineNum">   17114 </span><span class="lineNoCov">          0 :           SgClassDefinition* classDefinition = isSgClassDefinition(*i);</span></a>
<a name="17115"><span class="lineNum">   17115 </span><span class="lineNoCov">          0 :           if (classDefinition != NULL)</span></a>
<a name="17116"><span class="lineNum">   17116 </span>            :              {</a>
<a name="17117"><span class="lineNum">   17117 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="17118"><span class="lineNum">   17118 </span><span class="lineNoCov">          0 :                SgName className = classDeclaration-&gt;get_name();</span></a>
<a name="17119"><span class="lineNum">   17119 </span>            : #if 1</a>
<a name="17120"><span class="lineNum">   17120 </span><span class="lineNoCov">          0 :                printf (&quot;Found snippet class name = %s \n&quot;,className.str());</span></a>
<a name="17121"><span class="lineNum">   17121 </span>            : #endif</a>
<a name="17122"><span class="lineNum">   17122 </span><span class="lineNoCov">          0 :                SgClassSymbol* classSymbol = target_AST_scope-&gt;lookup_class_symbol(className);</span></a>
<a name="17123"><span class="lineNum">   17123 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="17124"><span class="lineNum">   17124 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="17125"><span class="lineNum">   17125 </span>            : #if 1</a>
<a name="17126"><span class="lineNum">   17126 </span><span class="lineNoCov">          0 :                printf (&quot;Associated symbol in taget AST: declaration = %p name = %s \n&quot;,classSymbol-&gt;get_declaration(),classSymbol-&gt;get_declaration()-&gt;get_name().str());</span></a>
<a name="17127"><span class="lineNum">   17127 </span>            : #endif</a>
<a name="17128"><span class="lineNum">   17128 </span>            :             // Set the return value as we go so that it will be properly set at the end of the reverse iteration over the scopes.</a>
<a name="17129"><span class="lineNum">   17129 </span><span class="lineNoCov">          0 :                returnSymbol = classSymbol;</span></a>
<a name="17130"><span class="lineNum">   17130 </span>            : </a>
<a name="17131"><span class="lineNum">   17131 </span>            :             // Reset the target AST scope (as we traverse down the AST to the associated declaration in the target AST).</a>
<a name="17132"><span class="lineNum">   17132 </span><span class="lineNoCov">          0 :                target_AST_scope = classDefinition;</span></a>
<a name="17133"><span class="lineNum">   17133 </span>            :              }</a>
<a name="17134"><span class="lineNum">   17134 </span>            : </a>
<a name="17135"><span class="lineNum">   17135 </span>            :        // Not clear if we can have this case for C or C++.</a>
<a name="17136"><span class="lineNum">   17136 </span><span class="lineNoCov">          0 :           SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(*i);</span></a>
<a name="17137"><span class="lineNum">   17137 </span><span class="lineNoCov">          0 :           if (functionDefinition != NULL)</span></a>
<a name="17138"><span class="lineNum">   17138 </span>            :              {</a>
<a name="17139"><span class="lineNum">   17139 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: Found an unusual case of SgFunctionDefinition in list of scopes holding a declaration for a type \n&quot;);</span></a>
<a name="17140"><span class="lineNum">   17140 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17141"><span class="lineNum">   17141 </span>            :              }</a>
<a name="17142"><span class="lineNum">   17142 </span>            : </a>
<a name="17143"><span class="lineNum">   17143 </span><span class="lineNoCov">          0 :           SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(*i);</span></a>
<a name="17144"><span class="lineNum">   17144 </span><span class="lineNoCov">          0 :           if (namespaceDefinition != NULL)</span></a>
<a name="17145"><span class="lineNum">   17145 </span>            :              {</a>
<a name="17146"><span class="lineNum">   17146 </span><span class="lineNoCov">          0 :                SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="17147"><span class="lineNum">   17147 </span><span class="lineNoCov">          0 :                SgName namespaceName = namespaceDeclaration-&gt;get_name();</span></a>
<a name="17148"><span class="lineNum">   17148 </span>            : #if 1</a>
<a name="17149"><span class="lineNum">   17149 </span><span class="lineNoCov">          0 :                printf (&quot;Found snippet namespace name = %s \n&quot;,namespaceName.str());</span></a>
<a name="17150"><span class="lineNum">   17150 </span>            : #endif</a>
<a name="17151"><span class="lineNum">   17151 </span><span class="lineNoCov">          0 :                SgNamespaceSymbol* namespaceSymbol = target_AST_scope-&gt;lookup_namespace_symbol(namespaceName);</span></a>
<a name="17152"><span class="lineNum">   17152 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceSymbol != NULL);</span></a>
<a name="17153"><span class="lineNum">   17153 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="17154"><span class="lineNum">   17154 </span>            : #if 1</a>
<a name="17155"><span class="lineNum">   17155 </span><span class="lineNoCov">          0 :                printf (&quot;Associated symbol in taget AST: declaration = %p name = %s \n&quot;,namespaceSymbol-&gt;get_declaration(),namespaceSymbol-&gt;get_declaration()-&gt;get_name().str());</span></a>
<a name="17156"><span class="lineNum">   17156 </span>            : #endif</a>
<a name="17157"><span class="lineNum">   17157 </span>            :             // Set the return value as we go so that it will be properly set at the end of the reverse iteration over the scopes.</a>
<a name="17158"><span class="lineNum">   17158 </span><span class="lineNoCov">          0 :                returnSymbol = namespaceSymbol;</span></a>
<a name="17159"><span class="lineNum">   17159 </span>            : </a>
<a name="17160"><span class="lineNum">   17160 </span>            :             // Reset the target AST scope (as we traverse down the AST to the associated declaration in the target AST).</a>
<a name="17161"><span class="lineNum">   17161 </span><span class="lineNoCov">          0 :                target_AST_scope = namespaceDefinition;</span></a>
<a name="17162"><span class="lineNum">   17162 </span>            :              }</a>
<a name="17163"><span class="lineNum">   17163 </span>            : </a>
<a name="17164"><span class="lineNum">   17164 </span>            :        // Increment the reverse iterator.</a>
<a name="17165"><span class="lineNum">   17165 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="17166"><span class="lineNum">   17166 </span>            :         }</a>
<a name="17167"><span class="lineNum">   17167 </span>            : </a>
<a name="17168"><span class="lineNum">   17168 </span>            :   // Handle the different cases using a switch (there are only a few cases).</a>
<a name="17169"><span class="lineNum">   17169 </span><span class="lineNoCov">          0 :      switch (snippet_declaration-&gt;variantT())</span></a>
<a name="17170"><span class="lineNum">   17170 </span>            :         {</a>
<a name="17171"><span class="lineNum">   17171 </span><span class="lineNoCov">          0 :           case V_SgClassDeclaration:</span></a>
<a name="17172"><span class="lineNum">   17172 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17173"><span class="lineNum">   17173 </span><span class="lineNoCov">          0 :                SgClassDeclaration* snippet_classDeclaration = isSgClassDeclaration(snippet_declaration);</span></a>
<a name="17174"><span class="lineNum">   17174 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_classDeclaration != NULL);</span></a>
<a name="17175"><span class="lineNum">   17175 </span>            : </a>
<a name="17176"><span class="lineNum">   17176 </span><span class="lineNoCov">          0 :                SgName snippet_className = snippet_classDeclaration-&gt;get_name();</span></a>
<a name="17177"><span class="lineNum">   17177 </span>            : #if 0</a>
<a name="17178"><span class="lineNum">   17178 </span>            :                printf (&quot;snippet snippet declaration's class name = %s \n&quot;,snippet_className.str());</a>
<a name="17179"><span class="lineNum">   17179 </span>            : #endif</a>
<a name="17180"><span class="lineNum">   17180 </span><span class="lineNoCov">          0 :                SgClassSymbol* target_symbol = target_AST_scope-&gt;lookup_class_symbol(snippet_className);</span></a>
<a name="17181"><span class="lineNum">   17181 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17182"><span class="lineNum">   17182 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17183"><span class="lineNum">   17183 </span>            : </a>
<a name="17184"><span class="lineNum">   17184 </span><span class="lineNoCov">          0 :                SgClassSymbol* classSymbolInTargetAST = isSgClassSymbol(returnSymbol);</span></a>
<a name="17185"><span class="lineNum">   17185 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbolInTargetAST != NULL);</span></a>
<a name="17186"><span class="lineNum">   17186 </span><span class="lineNoCov">          0 :                SgClassDeclaration* target_classDeclaration = isSgClassDeclaration(classSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17187"><span class="lineNum">   17187 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_classDeclaration != NULL);</span></a>
<a name="17188"><span class="lineNum">   17188 </span>            : #if 0</a>
<a name="17189"><span class="lineNum">   17189 </span>            :                printf (&quot;snippet: classDeclaration = %p = %s \n&quot;,snippet_classDeclaration,snippet_classDeclaration-&gt;get_name().str());</a>
<a name="17190"><span class="lineNum">   17190 </span>            :                printf (&quot;target: classDeclaration  = %p = %s \n&quot;,target_classDeclaration,target_classDeclaration-&gt;get_name().str());</a>
<a name="17191"><span class="lineNum">   17191 </span>            : #endif</a>
<a name="17192"><span class="lineNum">   17192 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_classDeclaration-&gt;get_name() == target_classDeclaration-&gt;get_name());</span></a>
<a name="17193"><span class="lineNum">   17193 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17194"><span class="lineNum">   17194 </span>            :              }</a>
<a name="17195"><span class="lineNum">   17195 </span>            : </a>
<a name="17196"><span class="lineNum">   17196 </span><span class="lineNoCov">          0 :           case V_SgTypedefDeclaration:</span></a>
<a name="17197"><span class="lineNum">   17197 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17198"><span class="lineNum">   17198 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* snippet_typedefDeclaration = isSgTypedefDeclaration(snippet_declaration);</span></a>
<a name="17199"><span class="lineNum">   17199 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_typedefDeclaration != NULL);</span></a>
<a name="17200"><span class="lineNum">   17200 </span>            : </a>
<a name="17201"><span class="lineNum">   17201 </span><span class="lineNoCov">          0 :                SgName snippet_typedefName = snippet_typedefDeclaration-&gt;get_name();</span></a>
<a name="17202"><span class="lineNum">   17202 </span>            : #if 0</a>
<a name="17203"><span class="lineNum">   17203 </span>            :                printf (&quot;snippet snippet declaration's typedef name = %s \n&quot;,snippet_typedefName.str());</a>
<a name="17204"><span class="lineNum">   17204 </span>            : #endif</a>
<a name="17205"><span class="lineNum">   17205 </span><span class="lineNoCov">          0 :                SgTypedefSymbol* target_symbol = target_AST_scope-&gt;lookup_typedef_symbol(snippet_typedefName);</span></a>
<a name="17206"><span class="lineNum">   17206 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17207"><span class="lineNum">   17207 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17208"><span class="lineNum">   17208 </span>            : </a>
<a name="17209"><span class="lineNum">   17209 </span><span class="lineNoCov">          0 :                SgTypedefSymbol* typedefSymbolInTargetAST = isSgTypedefSymbol(returnSymbol);</span></a>
<a name="17210"><span class="lineNum">   17210 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</span></a>
<a name="17211"><span class="lineNum">   17211 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* target_typedefDeclaration = isSgTypedefDeclaration(typedefSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17212"><span class="lineNum">   17212 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_typedefDeclaration != NULL);</span></a>
<a name="17213"><span class="lineNum">   17213 </span>            : #if 0</a>
<a name="17214"><span class="lineNum">   17214 </span>            :                printf (&quot;snippet: typedefDeclaration = %p = %s \n&quot;,snippet_typedefDeclaration,snippet_typedefDeclaration-&gt;get_name().str());</a>
<a name="17215"><span class="lineNum">   17215 </span>            :                printf (&quot;target: typedefDeclaration  = %p = %s \n&quot;,target_typedefDeclaration,target_typedefDeclaration-&gt;get_name().str());</a>
<a name="17216"><span class="lineNum">   17216 </span>            : #endif</a>
<a name="17217"><span class="lineNum">   17217 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_typedefDeclaration-&gt;get_name() == target_typedefDeclaration-&gt;get_name());</span></a>
<a name="17218"><span class="lineNum">   17218 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17219"><span class="lineNum">   17219 </span>            :              }</a>
<a name="17220"><span class="lineNum">   17220 </span>            : </a>
<a name="17221"><span class="lineNum">   17221 </span><span class="lineNoCov">          0 :           case V_SgEnumDeclaration:</span></a>
<a name="17222"><span class="lineNum">   17222 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17223"><span class="lineNum">   17223 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* snippet_enumDeclaration = isSgEnumDeclaration(snippet_declaration);</span></a>
<a name="17224"><span class="lineNum">   17224 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_enumDeclaration != NULL);</span></a>
<a name="17225"><span class="lineNum">   17225 </span>            : </a>
<a name="17226"><span class="lineNum">   17226 </span><span class="lineNoCov">          0 :                SgName snippet_enumName = snippet_enumDeclaration-&gt;get_name();</span></a>
<a name="17227"><span class="lineNum">   17227 </span>            : #if 0</a>
<a name="17228"><span class="lineNum">   17228 </span>            :                printf (&quot;snippet snippet declaration's enum name = %s \n&quot;,snippet_enumName.str());</a>
<a name="17229"><span class="lineNum">   17229 </span>            : #endif</a>
<a name="17230"><span class="lineNum">   17230 </span>            :             // DQ (4/13/2014): check if this is an un-named enum beclaration.</a>
<a name="17231"><span class="lineNum">   17231 </span><span class="lineNoCov">          0 :                bool isUnNamed = snippet_enumDeclaration-&gt;get_isUnNamed();</span></a>
<a name="17232"><span class="lineNum">   17232 </span><span class="lineNoCov">          0 :                if (isUnNamed == false)</span></a>
<a name="17233"><span class="lineNum">   17233 </span>            :                   {</a>
<a name="17234"><span class="lineNum">   17234 </span>            :                  // SgEnumSymbol* target_symbol = target_AST_scope-&gt;lookup_enum_symbol(snippet_enumName);</a>
<a name="17235"><span class="lineNum">   17235 </span><span class="lineNoCov">          0 :                     SgEnumSymbol* target_symbol = lookupEnumSymbolInParentScopes(snippet_enumName,target_AST_scope);</span></a>
<a name="17236"><span class="lineNum">   17236 </span><span class="lineNoCov">          0 :                     if (target_symbol == NULL)</span></a>
<a name="17237"><span class="lineNum">   17237 </span>            :                        {</a>
<a name="17238"><span class="lineNum">   17238 </span>            :                       // Debug this case.</a>
<a name="17239"><span class="lineNum">   17239 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = snippet_enumDeclaration-&gt;get_scope();</span></a>
<a name="17240"><span class="lineNum">   17240 </span><span class="lineNoCov">          0 :                          printf (&quot;scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="17241"><span class="lineNum">   17241 </span><span class="lineNoCov">          0 :                          scope-&gt;get_file_info()-&gt;display(&quot;case V_SgEnumDeclaration: target_symbol == NULL: scope: debug&quot;);</span></a>
<a name="17242"><span class="lineNum">   17242 </span>            :                        }</a>
<a name="17243"><span class="lineNum">   17243 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17244"><span class="lineNum">   17244 </span><span class="lineNoCov">          0 :                     returnSymbol = target_symbol;</span></a>
<a name="17245"><span class="lineNum">   17245 </span>            : </a>
<a name="17246"><span class="lineNum">   17246 </span><span class="lineNoCov">          0 :                     SgEnumSymbol* enumSymbolInTargetAST = isSgEnumSymbol(returnSymbol);</span></a>
<a name="17247"><span class="lineNum">   17247 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(enumSymbolInTargetAST != NULL);</span></a>
<a name="17248"><span class="lineNum">   17248 </span><span class="lineNoCov">          0 :                     SgEnumDeclaration* target_enumDeclaration = isSgEnumDeclaration(enumSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17249"><span class="lineNum">   17249 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(target_enumDeclaration != NULL);</span></a>
<a name="17250"><span class="lineNum">   17250 </span>            : #if 0</a>
<a name="17251"><span class="lineNum">   17251 </span>            :                     printf (&quot;snippet: enumDeclaration = %p = %s \n&quot;,snippet_enumDeclaration,snippet_enumDeclaration-&gt;get_name().str());</a>
<a name="17252"><span class="lineNum">   17252 </span>            :                     printf (&quot;target: enumDeclaration  = %p = %s \n&quot;,target_enumDeclaration,target_enumDeclaration-&gt;get_name().str());</a>
<a name="17253"><span class="lineNum">   17253 </span>            : #endif</a>
<a name="17254"><span class="lineNum">   17254 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippet_enumDeclaration-&gt;get_name() == target_enumDeclaration-&gt;get_name());</span></a>
<a name="17255"><span class="lineNum">   17255 </span>            :                   }</a>
<a name="17256"><span class="lineNum">   17256 </span>            :                  else</a>
<a name="17257"><span class="lineNum">   17257 </span>            :                   {</a>
<a name="17258"><span class="lineNum">   17258 </span>            :                  // DQ (4/13/2014): I think we all agreed these would not have to be handled.</a>
<a name="17259"><span class="lineNum">   17259 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: can't handle unnamed enum declarations \n&quot;);</span></a>
<a name="17260"><span class="lineNum">   17260 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(returnSymbol == NULL);</span></a>
<a name="17261"><span class="lineNum">   17261 </span>            :                   }</a>
<a name="17262"><span class="lineNum">   17262 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17263"><span class="lineNum">   17263 </span>            :              }</a>
<a name="17264"><span class="lineNum">   17264 </span>            : </a>
<a name="17265"><span class="lineNum">   17265 </span>            :        // DQ (12/5/2020): Adding support for codeSegregation tool.</a>
<a name="17266"><span class="lineNum">   17266 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="17267"><span class="lineNum">   17267 </span><span class="lineNoCov">          0 :           case V_SgFunctionDeclaration:</span></a>
<a name="17268"><span class="lineNum">   17268 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17269"><span class="lineNum">   17269 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* snippet_functionDeclaration = isSgFunctionDeclaration(snippet_declaration);</span></a>
<a name="17270"><span class="lineNum">   17270 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_functionDeclaration != NULL);</span></a>
<a name="17271"><span class="lineNum">   17271 </span>            : #if 1</a>
<a name="17272"><span class="lineNum">   17272 </span><span class="lineNoCov">          0 :                printf (&quot;snippet_declaration = %p = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str());</span></a>
<a name="17273"><span class="lineNum">   17273 </span>            : #endif</a>
<a name="17274"><span class="lineNum">   17274 </span><span class="lineNoCov">          0 :                SgName snippet_functionName = snippet_functionDeclaration-&gt;get_name();</span></a>
<a name="17275"><span class="lineNum">   17275 </span>            : #if 1</a>
<a name="17276"><span class="lineNum">   17276 </span><span class="lineNoCov">          0 :                printf (&quot;snippet snippet declaration's function name = %s \n&quot;,snippet_functionName.str());</span></a>
<a name="17277"><span class="lineNum">   17277 </span><span class="lineNoCov">          0 :                printf (&quot; --- target_AST_scope = %p = %s \n&quot;,target_AST_scope,target_AST_scope-&gt;class_name().c_str());</span></a>
<a name="17278"><span class="lineNum">   17278 </span>            : #endif</a>
<a name="17279"><span class="lineNum">   17279 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* target_symbol = target_AST_scope-&gt;lookup_function_symbol(snippet_functionName);</span></a>
<a name="17280"><span class="lineNum">   17280 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17281"><span class="lineNum">   17281 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17282"><span class="lineNum">   17282 </span>            : </a>
<a name="17283"><span class="lineNum">   17283 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* functionSymbolInTargetAST = isSgFunctionSymbol(returnSymbol);</span></a>
<a name="17284"><span class="lineNum">   17284 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="17285"><span class="lineNum">   17285 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* target_functionDeclaration = isSgFunctionDeclaration(functionSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17286"><span class="lineNum">   17286 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_functionDeclaration != NULL);</span></a>
<a name="17287"><span class="lineNum">   17287 </span>            : #if 1</a>
<a name="17288"><span class="lineNum">   17288 </span><span class="lineNoCov">          0 :                printf (&quot;snippet: functionDeclaration = %p = %s \n&quot;,snippet_functionDeclaration,snippet_functionDeclaration-&gt;get_name().str());</span></a>
<a name="17289"><span class="lineNum">   17289 </span><span class="lineNoCov">          0 :                printf (&quot;target: functionDeclaration  = %p = %s \n&quot;,target_functionDeclaration,target_functionDeclaration-&gt;get_name().str());</span></a>
<a name="17290"><span class="lineNum">   17290 </span>            : #endif</a>
<a name="17291"><span class="lineNum">   17291 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_functionDeclaration-&gt;get_name() == target_functionDeclaration-&gt;get_name());</span></a>
<a name="17292"><span class="lineNum">   17292 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17293"><span class="lineNum">   17293 </span>            :              }</a>
<a name="17294"><span class="lineNum">   17294 </span>            : </a>
<a name="17295"><span class="lineNum">   17295 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="17296"><span class="lineNum">   17296 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17297"><span class="lineNum">   17297 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached in switch: snippet_declaration = %p = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str());</span></a>
<a name="17298"><span class="lineNum">   17298 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17299"><span class="lineNum">   17299 </span>            :              }</a>
<a name="17300"><span class="lineNum">   17300 </span>            :         }</a>
<a name="17301"><span class="lineNum">   17301 </span>            : </a>
<a name="17302"><span class="lineNum">   17302 </span>            :   // return the last found symbol.</a>
<a name="17303"><span class="lineNum">   17303 </span><span class="lineNoCov">          0 :      return returnSymbol;</span></a>
<a name="17304"><span class="lineNum">   17304 </span>            :    }</a>
<a name="17305"><span class="lineNum">   17305 </span>            : </a>
<a name="17306"><span class="lineNum">   17306 </span>            : </a>
<a name="17307"><span class="lineNum">   17307 </span>            : SgDeclarationStatement*</a>
<a name="17308"><span class="lineNum">   17308 </span><span class="lineNoCov">          0 : SageBuilder::findAssociatedDeclarationInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope)</span></a>
<a name="17309"><span class="lineNum">   17309 </span>            :    {</a>
<a name="17310"><span class="lineNum">   17310 </span>            :   // DQ (12/6/2020): This is a similar function to findAssociatedSymbolInTargetAST() but since</a>
<a name="17311"><span class="lineNum">   17311 </span>            :   // I need to modify it to support the requirements of the codeSegregation, it was useful to not</a>
<a name="17312"><span class="lineNum">   17312 </span>            :   // modify the existing findAssociatedSymbolInTargetAST() function too much so as to avoid</a>
<a name="17313"><span class="lineNum">   17313 </span>            :   // compromizing the snippet transformation support.</a>
<a name="17314"><span class="lineNum">   17314 </span>            : </a>
<a name="17315"><span class="lineNum">   17315 </span>            : #define DEBUG_FIND_ASSOCIATED_DECLARATION 0</a>
<a name="17316"><span class="lineNum">   17316 </span>            : </a>
<a name="17317"><span class="lineNum">   17317 </span><span class="lineNoCov">          0 :      SgSymbol* returnSymbol = NULL;</span></a>
<a name="17318"><span class="lineNum">   17318 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* returnDeclaration = NULL;</span></a>
<a name="17319"><span class="lineNum">   17319 </span>            : </a>
<a name="17320"><span class="lineNum">   17320 </span><span class="lineNoCov">          0 :      bool isDefiningDeclaration = (snippet_declaration == snippet_declaration-&gt;get_definingDeclaration());</span></a>
<a name="17321"><span class="lineNum">   17321 </span>            : </a>
<a name="17322"><span class="lineNum">   17322 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17323"><span class="lineNum">   17323 </span>            :      printf (&quot;isDefiningDeclaration = %s \n&quot;,isDefiningDeclaration ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17324"><span class="lineNum">   17324 </span>            : #endif</a>
<a name="17325"><span class="lineNum">   17325 </span>            : </a>
<a name="17326"><span class="lineNum">   17326 </span>            :   // DQ (12/7/2020): This should be true.</a>
<a name="17327"><span class="lineNum">   17327 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,targetScope) == false);</span></a>
<a name="17328"><span class="lineNum">   17328 </span>            : </a>
<a name="17329"><span class="lineNum">   17329 </span><span class="lineNoCov">          0 :      typedef Rose_STL_Container&lt;SgScopeStatement*&gt;  SgScopeStatementPtrList;</span></a>
<a name="17330"><span class="lineNum">   17330 </span><span class="lineNoCov">          0 :      SgScopeStatementPtrList snippet_scope_list;</span></a>
<a name="17331"><span class="lineNum">   17331 </span>            : </a>
<a name="17332"><span class="lineNum">   17332 </span>            :   // Starting at the snippet_declaration, record the associated scope list to the global scope.</a>
<a name="17333"><span class="lineNum">   17333 </span>            :   // SgScopeStatement* snippet_scope = snippet_declaration-&gt;get_scope();</a>
<a name="17334"><span class="lineNum">   17334 </span><span class="lineNoCov">          0 :      SgScopeStatement* snippet_scope = snippet_declaration-&gt;get_scope();</span></a>
<a name="17335"><span class="lineNum">   17335 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17336"><span class="lineNum">   17336 </span>            :      printf (&quot;First scope = %p = %s \n&quot;,snippet_scope,snippet_scope-&gt;class_name().c_str());</a>
<a name="17337"><span class="lineNum">   17337 </span>            :      SgClassDefinition* temp_classDefinition = isSgClassDefinition(snippet_scope);</a>
<a name="17338"><span class="lineNum">   17338 </span>            :      if (temp_classDefinition != NULL)</a>
<a name="17339"><span class="lineNum">   17339 </span>            :         {</a>
<a name="17340"><span class="lineNum">   17340 </span>            :           SgClassDeclaration* temp_classDeclaration = temp_classDefinition-&gt;get_declaration();</a>
<a name="17341"><span class="lineNum">   17341 </span>            :           SgName className = temp_classDeclaration-&gt;get_name();</a>
<a name="17342"><span class="lineNum">   17342 </span>            :           printf (&quot;Input declaration's class name = %s \n&quot;,className.str());</a>
<a name="17343"><span class="lineNum">   17343 </span>            :         }</a>
<a name="17344"><span class="lineNum">   17344 </span>            : </a>
<a name="17345"><span class="lineNum">   17345 </span>            :      SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(snippet_scope);</a>
<a name="17346"><span class="lineNum">   17346 </span>            :      if (namespaceDefinitionStatement != NULL)</a>
<a name="17347"><span class="lineNum">   17347 </span>            :         {</a>
<a name="17348"><span class="lineNum">   17348 </span>            :           SgNamespaceDeclarationStatement* temp_namespaceDeclaration = namespaceDefinitionStatement-&gt;get_namespaceDeclaration();</a>
<a name="17349"><span class="lineNum">   17349 </span>            :           SgName namespaceName = temp_namespaceDeclaration-&gt;get_name();</a>
<a name="17350"><span class="lineNum">   17350 </span>            :           printf (&quot;Input declaration's namespace name = %s \n&quot;,namespaceName.str());</a>
<a name="17351"><span class="lineNum">   17351 </span>            :         }</a>
<a name="17352"><span class="lineNum">   17352 </span>            : #endif</a>
<a name="17353"><span class="lineNum">   17353 </span>            : </a>
<a name="17354"><span class="lineNum">   17354 </span><span class="lineNoCov">          0 :      snippet_scope_list.push_back(snippet_scope);</span></a>
<a name="17355"><span class="lineNum">   17355 </span><span class="lineNoCov">          0 :      while (snippet_scope != NULL &amp;&amp; isSgGlobal(snippet_scope) == NULL)</span></a>
<a name="17356"><span class="lineNum">   17356 </span>            :         {</a>
<a name="17357"><span class="lineNum">   17357 </span>            :        // The scopes between the snippet declaration and the global scope should be named scopes,</a>
<a name="17358"><span class="lineNum">   17358 </span>            :        // else we will not be able to identify the associated scope in the target AST.</a>
<a name="17359"><span class="lineNum">   17359 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(snippet_scope-&gt;isNamedScope() == true);</span></a>
<a name="17360"><span class="lineNum">   17360 </span>            : </a>
<a name="17361"><span class="lineNum">   17361 </span><span class="lineNoCov">          0 :           snippet_scope = snippet_scope-&gt;get_scope();</span></a>
<a name="17362"><span class="lineNum">   17362 </span>            : </a>
<a name="17363"><span class="lineNum">   17363 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17364"><span class="lineNum">   17364 </span>            :           printf (&quot;snippet_scope = %p = %s \n&quot;,snippet_scope,snippet_scope-&gt;class_name().c_str());</a>
<a name="17365"><span class="lineNum">   17365 </span>            : #endif</a>
<a name="17366"><span class="lineNum">   17366 </span><span class="lineNoCov">          0 :           snippet_scope_list.push_back(snippet_scope);</span></a>
<a name="17367"><span class="lineNum">   17367 </span>            : </a>
<a name="17368"><span class="lineNum">   17368 </span>            :        // DQ (12/7/2020): At this point the scopes that we are traversing to the global scope should</a>
<a name="17369"><span class="lineNum">   17369 </span>            :        // have the same global scope as the input declaration.</a>
<a name="17370"><span class="lineNum">   17370 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,snippet_scope) == true);</span></a>
<a name="17371"><span class="lineNum">   17371 </span>            :         }</a>
<a name="17372"><span class="lineNum">   17372 </span>            : </a>
<a name="17373"><span class="lineNum">   17373 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17374"><span class="lineNum">   17374 </span>            :      printf (&quot;snippet_scope_list.size() = %&quot; PRIuPTR &quot; \n&quot;,snippet_scope_list.size());</a>
<a name="17375"><span class="lineNum">   17375 </span>            :      for (SgScopeStatementPtrList::iterator i = snippet_scope_list.begin(); i != snippet_scope_list.end(); i++)</a>
<a name="17376"><span class="lineNum">   17376 </span>            :         {</a>
<a name="17377"><span class="lineNum">   17377 </span>            :           SgScopeStatement* scope = *i;</a>
<a name="17378"><span class="lineNum">   17378 </span>            :           printf (&quot; --- *i = %p = %s name = %s \n&quot;,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="17379"><span class="lineNum">   17379 </span>            :           SgGlobal* global_scope_from_declarations_scope = TransformationSupport::getGlobalScope(scope);</a>
<a name="17380"><span class="lineNum">   17380 </span>            :           printf (&quot; --- --- global_scope_from_declarations_scope = %p \n&quot;,global_scope_from_declarations_scope);</a>
<a name="17381"><span class="lineNum">   17381 </span>            :         }</a>
<a name="17382"><span class="lineNum">   17382 </span>            : #endif</a>
<a name="17383"><span class="lineNum">   17383 </span>            : </a>
<a name="17384"><span class="lineNum">   17384 </span>            :   // DQ (12/7/2020): At this point the scopes that we are traversing to the global scope should</a>
<a name="17385"><span class="lineNum">   17385 </span>            :   // have the same global scope as the input declaration.</a>
<a name="17386"><span class="lineNum">   17386 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,snippet_scope) == true);</span></a>
<a name="17387"><span class="lineNum">   17387 </span>            : </a>
<a name="17388"><span class="lineNum">   17388 </span><span class="lineNoCov">          0 :      SgGlobal* global_scope_in_target_ast = TransformationSupport::getGlobalScope(targetScope);</span></a>
<a name="17389"><span class="lineNum">   17389 </span><span class="lineNoCov">          0 :      SgScopeStatementPtrList::reverse_iterator i = snippet_scope_list.rbegin();</span></a>
<a name="17390"><span class="lineNum">   17390 </span>            : </a>
<a name="17391"><span class="lineNum">   17391 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17392"><span class="lineNum">   17392 </span>            :      printf (&quot;global_scope_in_target_ast = %p = %s \n&quot;,global_scope_in_target_ast,global_scope_in_target_ast-&gt;class_name().c_str());</a>
<a name="17393"><span class="lineNum">   17393 </span>            : #endif</a>
<a name="17394"><span class="lineNum">   17394 </span>            : </a>
<a name="17395"><span class="lineNum">   17395 </span><span class="lineNoCov">          0 :      SgScopeStatement* target_AST_scope  = global_scope_in_target_ast;</span></a>
<a name="17396"><span class="lineNum">   17396 </span><span class="lineNoCov">          0 :      SgScopeStatement* snippet_AST_scope = *i;</span></a>
<a name="17397"><span class="lineNum">   17397 </span>            : </a>
<a name="17398"><span class="lineNum">   17398 </span>            :   // DQ (12/7/2020): This should be true.</a>
<a name="17399"><span class="lineNum">   17399 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,snippet_AST_scope) == true);</span></a>
<a name="17400"><span class="lineNum">   17400 </span>            : </a>
<a name="17401"><span class="lineNum">   17401 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isSgGlobal(snippet_AST_scope) != NULL);</span></a>
<a name="17402"><span class="lineNum">   17402 </span>            :   // Iterate past the global scope</a>
<a name="17403"><span class="lineNum">   17403 </span><span class="lineNoCov">          0 :      i++;</span></a>
<a name="17404"><span class="lineNum">   17404 </span>            : </a>
<a name="17405"><span class="lineNum">   17405 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17406"><span class="lineNum">   17406 </span>            :      string otherASTnameFromGlobalScope = global_scope_in_target_ast-&gt;get_file_info()-&gt;get_filenameString();</a>
<a name="17407"><span class="lineNum">   17407 </span>            :      SgSourceFile* otherSourceFile      = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(targetScope,true);</a>
<a name="17408"><span class="lineNum">   17408 </span>            :      string otherASTnameFromSourceFile  = otherSourceFile-&gt;getFileName();</a>
<a name="17409"><span class="lineNum">   17409 </span>            :      printf (&quot;Now traverse the list of scopes in reverse to find the declaration in the other AST: \n&quot;);</a>
<a name="17410"><span class="lineNum">   17410 </span>            :      printf (&quot;otherASTnameFromGlobalScope = %s \n&quot;,otherASTnameFromGlobalScope.c_str());</a>
<a name="17411"><span class="lineNum">   17411 </span>            :      printf (&quot;otherASTnameFromSourceFile  = %s \n&quot;,otherASTnameFromSourceFile.c_str());</a>
<a name="17412"><span class="lineNum">   17412 </span>            : #endif</a>
<a name="17413"><span class="lineNum">   17413 </span>            : </a>
<a name="17414"><span class="lineNum">   17414 </span>            :   // DQ (12/7/2020): This should be true.</a>
<a name="17415"><span class="lineNum">   17415 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17416"><span class="lineNum">   17416 </span>            : </a>
<a name="17417"><span class="lineNum">   17417 </span>            :   // Traverse the snippet scopes in the reverse order from global scope to the associated scope in the target AST.</a>
<a name="17418"><span class="lineNum">   17418 </span><span class="lineNoCov">          0 :      while (i != snippet_scope_list.rend())</span></a>
<a name="17419"><span class="lineNum">   17419 </span>            :         {</a>
<a name="17420"><span class="lineNum">   17420 </span>            :        // This loop has to handle different types of names scopes (for C this only means structs, I think).</a>
<a name="17421"><span class="lineNum">   17421 </span>            : </a>
<a name="17422"><span class="lineNum">   17422 </span><span class="lineNoCov">          0 :           SgScopeStatement* scope = *i;</span></a>
<a name="17423"><span class="lineNum">   17423 </span>            : </a>
<a name="17424"><span class="lineNum">   17424 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17425"><span class="lineNum">   17425 </span>            :           printf (&quot;snippet_AST_scope list *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="17426"><span class="lineNum">   17426 </span>            :           printf (&quot; --- *i = %p = %s name = %s \n&quot;,scope,scope-&gt;class_name().c_str(),SageInterface::get_name(scope).c_str());</a>
<a name="17427"><span class="lineNum">   17427 </span>            :           printf (&quot; --- target_AST_scope = %p = %s \n&quot;,target_AST_scope,target_AST_scope -&gt;class_name().c_str());</a>
<a name="17428"><span class="lineNum">   17428 </span>            :        // printf (&quot;snippet_AST_scope = %p = %s \n&quot;,snippet_AST_scope,snippet_AST_scope -&gt;class_name().c_str());</a>
<a name="17429"><span class="lineNum">   17429 </span>            : #endif</a>
<a name="17430"><span class="lineNum">   17430 </span>            : </a>
<a name="17431"><span class="lineNum">   17431 </span>            :        // DQ (12/7/2020): This should still be true.</a>
<a name="17432"><span class="lineNum">   17432 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,scope) == true);</span></a>
<a name="17433"><span class="lineNum">   17433 </span>            : </a>
<a name="17434"><span class="lineNum">   17434 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17435"><span class="lineNum">   17435 </span>            :           SgSourceFile* otherSourceFile      = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(targetScope,true);</a>
<a name="17436"><span class="lineNum">   17436 </span>            :           string otherASTnameFromSourceFile  = otherSourceFile-&gt;getFileName();</a>
<a name="17437"><span class="lineNum">   17437 </span>            :           printf (&quot; --- otherASTnameFromSourceFile  = %s \n&quot;,otherASTnameFromSourceFile.c_str());</a>
<a name="17438"><span class="lineNum">   17438 </span>            : #endif</a>
<a name="17439"><span class="lineNum">   17439 </span>            : </a>
<a name="17440"><span class="lineNum">   17440 </span>            :        // DQ (12/5/2020): I think this should be a switch statement.</a>
<a name="17441"><span class="lineNum">   17441 </span><span class="lineNoCov">          0 :           SgClassDefinition* classDefinition = isSgClassDefinition(*i);</span></a>
<a name="17442"><span class="lineNum">   17442 </span><span class="lineNoCov">          0 :           if (classDefinition != NULL)</span></a>
<a name="17443"><span class="lineNum">   17443 </span>            :              {</a>
<a name="17444"><span class="lineNum">   17444 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration = classDefinition-&gt;get_declaration();</span></a>
<a name="17445"><span class="lineNum">   17445 </span><span class="lineNoCov">          0 :                SgName className = classDeclaration-&gt;get_name();</span></a>
<a name="17446"><span class="lineNum">   17446 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17447"><span class="lineNum">   17447 </span>            :                printf (&quot; --- Found snippet class name = %s \n&quot;,className.str());</a>
<a name="17448"><span class="lineNum">   17448 </span>            : #endif</a>
<a name="17449"><span class="lineNum">   17449 </span><span class="lineNoCov">          0 :                SgClassSymbol* classSymbol = target_AST_scope-&gt;lookup_class_symbol(className);</span></a>
<a name="17450"><span class="lineNum">   17450 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="17451"><span class="lineNum">   17451 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="17452"><span class="lineNum">   17452 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17453"><span class="lineNum">   17453 </span>            :                printf (&quot; --- Associated symbol in taget AST: declaration = %p name = %s \n&quot;,classSymbol-&gt;get_declaration(),classSymbol-&gt;get_declaration()-&gt;get_name().str());</a>
<a name="17454"><span class="lineNum">   17454 </span>            : #endif</a>
<a name="17455"><span class="lineNum">   17455 </span>            :             // Set the return value as we go so that it will be properly set at the end of the reverse iteration over the scopes.</a>
<a name="17456"><span class="lineNum">   17456 </span><span class="lineNoCov">          0 :                returnSymbol = classSymbol;</span></a>
<a name="17457"><span class="lineNum">   17457 </span>            : </a>
<a name="17458"><span class="lineNum">   17458 </span>            :             // DQ (12/8/2020): Need to get the associated class definition from the symbol in the target scope.</a>
<a name="17459"><span class="lineNum">   17459 </span><span class="lineNoCov">          0 :                SgClassDeclaration* temp_classDeclaration_in_target_ast = classSymbol-&gt;get_declaration();</span></a>
<a name="17460"><span class="lineNum">   17460 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(temp_classDeclaration_in_target_ast != NULL);</span></a>
<a name="17461"><span class="lineNum">   17461 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration_in_target_ast = isSgClassDeclaration(temp_classDeclaration_in_target_ast-&gt;get_definingDeclaration());</span></a>
<a name="17462"><span class="lineNum">   17462 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classDeclaration_in_target_ast != NULL);</span></a>
<a name="17463"><span class="lineNum">   17463 </span><span class="lineNoCov">          0 :                SgClassDefinition* classDefinition_in_target_ast = classDeclaration_in_target_ast-&gt;get_definition();</span></a>
<a name="17464"><span class="lineNum">   17464 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classDefinition_in_target_ast != NULL);</span></a>
<a name="17465"><span class="lineNum">   17465 </span>            : </a>
<a name="17466"><span class="lineNum">   17466 </span>            :             // DQ (12/7/2020): This should be true.</a>
<a name="17467"><span class="lineNum">   17467 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17468"><span class="lineNum">   17468 </span>            : </a>
<a name="17469"><span class="lineNum">   17469 </span>            :             // Reset the target AST scope (as we traverse down the AST to the associated declaration in the target AST).</a>
<a name="17470"><span class="lineNum">   17470 </span>            :             // target_AST_scope = classDefinition;</a>
<a name="17471"><span class="lineNum">   17471 </span><span class="lineNoCov">          0 :                target_AST_scope = classDefinition_in_target_ast;</span></a>
<a name="17472"><span class="lineNum">   17472 </span>            : </a>
<a name="17473"><span class="lineNum">   17473 </span>            :             // DQ (12/7/2020): This should be true.</a>
<a name="17474"><span class="lineNum">   17474 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17475"><span class="lineNum">   17475 </span>            :              }</a>
<a name="17476"><span class="lineNum">   17476 </span>            : </a>
<a name="17477"><span class="lineNum">   17477 </span>            :        // Not clear if we can have this case for C or C++.</a>
<a name="17478"><span class="lineNum">   17478 </span><span class="lineNoCov">          0 :           SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(*i);</span></a>
<a name="17479"><span class="lineNum">   17479 </span><span class="lineNoCov">          0 :           if (functionDefinition != NULL)</span></a>
<a name="17480"><span class="lineNum">   17480 </span>            :              {</a>
<a name="17481"><span class="lineNum">   17481 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: Found an unusual case of SgFunctionDefinition in list of scopes holding a declaration for a type \n&quot;);</span></a>
<a name="17482"><span class="lineNum">   17482 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17483"><span class="lineNum">   17483 </span>            :              }</a>
<a name="17484"><span class="lineNum">   17484 </span>            : </a>
<a name="17485"><span class="lineNum">   17485 </span><span class="lineNoCov">          0 :           SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(*i);</span></a>
<a name="17486"><span class="lineNum">   17486 </span><span class="lineNoCov">          0 :           if (namespaceDefinition != NULL)</span></a>
<a name="17487"><span class="lineNum">   17487 </span>            :              {</a>
<a name="17488"><span class="lineNum">   17488 </span><span class="lineNoCov">          0 :                SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="17489"><span class="lineNum">   17489 </span><span class="lineNoCov">          0 :                SgName namespaceName = namespaceDeclaration-&gt;get_name();</span></a>
<a name="17490"><span class="lineNum">   17490 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17491"><span class="lineNum">   17491 </span>            :                printf (&quot; --- Found snippet namespace name = %s \n&quot;,namespaceName.str());</a>
<a name="17492"><span class="lineNum">   17492 </span>            : #endif</a>
<a name="17493"><span class="lineNum">   17493 </span><span class="lineNoCov">          0 :                SgNamespaceSymbol* namespaceSymbol = target_AST_scope-&gt;lookup_namespace_symbol(namespaceName);</span></a>
<a name="17494"><span class="lineNum">   17494 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceSymbol != NULL);</span></a>
<a name="17495"><span class="lineNum">   17495 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="17496"><span class="lineNum">   17496 </span><span class="lineNoCov">          0 :                SgNamespaceDeclarationStatement* otherASTnamespaceDeclaration = namespaceSymbol-&gt;get_declaration();</span></a>
<a name="17497"><span class="lineNum">   17497 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17498"><span class="lineNum">   17498 </span>            :                printf (&quot; --- Associated symbol in taget AST: declaration = %p name = %s \n&quot;,namespaceSymbol-&gt;get_declaration(),namespaceSymbol-&gt;get_declaration()-&gt;get_name().str());</a>
<a name="17499"><span class="lineNum">   17499 </span>            : #endif</a>
<a name="17500"><span class="lineNum">   17500 </span>            :             // Set the return value as we go so that it will be properly set at the end of the reverse iteration over the scopes.</a>
<a name="17501"><span class="lineNum">   17501 </span><span class="lineNoCov">          0 :                returnSymbol = namespaceSymbol;</span></a>
<a name="17502"><span class="lineNum">   17502 </span>            : </a>
<a name="17503"><span class="lineNum">   17503 </span>            :             // DQ (12/7/2020): This should be true.</a>
<a name="17504"><span class="lineNum">   17504 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17505"><span class="lineNum">   17505 </span>            : </a>
<a name="17506"><span class="lineNum">   17506 </span>            :             // Reset the target AST scope (as we traverse down the AST to the associated declaration in the target AST).</a>
<a name="17507"><span class="lineNum">   17507 </span>            :             // target_AST_scope = namespaceDefinition;</a>
<a name="17508"><span class="lineNum">   17508 </span><span class="lineNoCov">          0 :                target_AST_scope = otherASTnamespaceDeclaration-&gt;get_definition();</span></a>
<a name="17509"><span class="lineNum">   17509 </span>            : </a>
<a name="17510"><span class="lineNum">   17510 </span>            :             // DQ (12/7/2020): This should be true.</a>
<a name="17511"><span class="lineNum">   17511 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17512"><span class="lineNum">   17512 </span>            :              }</a>
<a name="17513"><span class="lineNum">   17513 </span>            : </a>
<a name="17514"><span class="lineNum">   17514 </span>            :        // DQ (12/7/2020): This should be true.</a>
<a name="17515"><span class="lineNum">   17515 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17516"><span class="lineNum">   17516 </span>            : </a>
<a name="17517"><span class="lineNum">   17517 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17518"><span class="lineNum">   17518 </span>            :           printf (&quot; --- At base of loop of the list of scopes in top to bottom: target_AST_scope = %p = %s \n&quot;,target_AST_scope,target_AST_scope-&gt;class_name().c_str());</a>
<a name="17519"><span class="lineNum">   17519 </span>            : </a>
<a name="17520"><span class="lineNum">   17520 </span>            :              {</a>
<a name="17521"><span class="lineNum">   17521 </span>            :                SgSourceFile* otherSourceFile      = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(target_AST_scope,true);</a>
<a name="17522"><span class="lineNum">   17522 </span>            :                string otherASTnameFromSourceFile  = otherSourceFile-&gt;getFileName();</a>
<a name="17523"><span class="lineNum">   17523 </span>            :                printf (&quot; --- At base of loop: otherASTnameFromSourceFile  = %s \n&quot;,otherASTnameFromSourceFile.c_str());</a>
<a name="17524"><span class="lineNum">   17524 </span>            :              }</a>
<a name="17525"><span class="lineNum">   17525 </span>            : #endif</a>
<a name="17526"><span class="lineNum">   17526 </span>            :        // Increment the reverse iterator.</a>
<a name="17527"><span class="lineNum">   17527 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="17528"><span class="lineNum">   17528 </span>            :         }</a>
<a name="17529"><span class="lineNum">   17529 </span>            : </a>
<a name="17530"><span class="lineNum">   17530 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17531"><span class="lineNum">   17531 </span>            :      printf (&quot;##### Now based on the kind of declaration, search for that same named declaration in the target_AST_scope = %p = %s \n&quot;,</a>
<a name="17532"><span class="lineNum">   17532 </span>            :           target_AST_scope,target_AST_scope-&gt;class_name().c_str());</a>
<a name="17533"><span class="lineNum">   17533 </span>            : #endif</a>
<a name="17534"><span class="lineNum">   17534 </span>            : </a>
<a name="17535"><span class="lineNum">   17535 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,target_AST_scope) == false);</span></a>
<a name="17536"><span class="lineNum">   17536 </span>            : </a>
<a name="17537"><span class="lineNum">   17537 </span>            :   // Handle the different cases using a switch (there are only a few cases).</a>
<a name="17538"><span class="lineNum">   17538 </span><span class="lineNoCov">          0 :      switch (snippet_declaration-&gt;variantT())</span></a>
<a name="17539"><span class="lineNum">   17539 </span>            :         {</a>
<a name="17540"><span class="lineNum">   17540 </span><span class="lineNoCov">          0 :           case V_SgClassDeclaration:</span></a>
<a name="17541"><span class="lineNum">   17541 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17542"><span class="lineNum">   17542 </span><span class="lineNoCov">          0 :                SgClassDeclaration* snippet_classDeclaration = isSgClassDeclaration(snippet_declaration);</span></a>
<a name="17543"><span class="lineNum">   17543 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_classDeclaration != NULL);</span></a>
<a name="17544"><span class="lineNum">   17544 </span>            : </a>
<a name="17545"><span class="lineNum">   17545 </span><span class="lineNoCov">          0 :                SgName snippet_className = snippet_classDeclaration-&gt;get_name();</span></a>
<a name="17546"><span class="lineNum">   17546 </span>            : </a>
<a name="17547"><span class="lineNum">   17547 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17548"><span class="lineNum">   17548 </span>            :                printf (&quot;snippet snippet declaration's class name = %s \n&quot;,snippet_className.str());</a>
<a name="17549"><span class="lineNum">   17549 </span>            : #endif</a>
<a name="17550"><span class="lineNum">   17550 </span><span class="lineNoCov">          0 :                SgClassSymbol* target_symbol = target_AST_scope-&gt;lookup_class_symbol(snippet_className);</span></a>
<a name="17551"><span class="lineNum">   17551 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17552"><span class="lineNum">   17552 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17553"><span class="lineNum">   17553 </span>            : </a>
<a name="17554"><span class="lineNum">   17554 </span><span class="lineNoCov">          0 :                SgClassSymbol* classSymbolInTargetAST = isSgClassSymbol(returnSymbol);</span></a>
<a name="17555"><span class="lineNum">   17555 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbolInTargetAST != NULL);</span></a>
<a name="17556"><span class="lineNum">   17556 </span><span class="lineNoCov">          0 :                SgClassDeclaration* target_classDeclaration = isSgClassDeclaration(classSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17557"><span class="lineNum">   17557 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_classDeclaration != NULL);</span></a>
<a name="17558"><span class="lineNum">   17558 </span>            : </a>
<a name="17559"><span class="lineNum">   17559 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17560"><span class="lineNum">   17560 </span>            :                printf (&quot;snippet: classDeclaration = %p = %s \n&quot;,snippet_classDeclaration,snippet_classDeclaration-&gt;get_name().str());</a>
<a name="17561"><span class="lineNum">   17561 </span>            :                printf (&quot;target: classDeclaration  = %p = %s \n&quot;,target_classDeclaration,target_classDeclaration-&gt;get_name().str());</a>
<a name="17562"><span class="lineNum">   17562 </span>            : #endif</a>
<a name="17563"><span class="lineNum">   17563 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_classDeclaration-&gt;get_name() == target_classDeclaration-&gt;get_name());</span></a>
<a name="17564"><span class="lineNum">   17564 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17565"><span class="lineNum">   17565 </span>            :              }</a>
<a name="17566"><span class="lineNum">   17566 </span>            : </a>
<a name="17567"><span class="lineNum">   17567 </span><span class="lineNoCov">          0 :           case V_SgTypedefDeclaration:</span></a>
<a name="17568"><span class="lineNum">   17568 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17569"><span class="lineNum">   17569 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* snippet_typedefDeclaration = isSgTypedefDeclaration(snippet_declaration);</span></a>
<a name="17570"><span class="lineNum">   17570 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_typedefDeclaration != NULL);</span></a>
<a name="17571"><span class="lineNum">   17571 </span>            : </a>
<a name="17572"><span class="lineNum">   17572 </span><span class="lineNoCov">          0 :                SgName snippet_typedefName = snippet_typedefDeclaration-&gt;get_name();</span></a>
<a name="17573"><span class="lineNum">   17573 </span>            : </a>
<a name="17574"><span class="lineNum">   17574 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17575"><span class="lineNum">   17575 </span>            :                printf (&quot;snippet snippet declaration's typedef name = %s \n&quot;,snippet_typedefName.str());</a>
<a name="17576"><span class="lineNum">   17576 </span>            : #endif</a>
<a name="17577"><span class="lineNum">   17577 </span><span class="lineNoCov">          0 :                SgTypedefSymbol* target_symbol = target_AST_scope-&gt;lookup_typedef_symbol(snippet_typedefName);</span></a>
<a name="17578"><span class="lineNum">   17578 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17579"><span class="lineNum">   17579 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17580"><span class="lineNum">   17580 </span>            : </a>
<a name="17581"><span class="lineNum">   17581 </span><span class="lineNoCov">          0 :                SgTypedefSymbol* typedefSymbolInTargetAST = isSgTypedefSymbol(returnSymbol);</span></a>
<a name="17582"><span class="lineNum">   17582 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</span></a>
<a name="17583"><span class="lineNum">   17583 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* target_typedefDeclaration = isSgTypedefDeclaration(typedefSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17584"><span class="lineNum">   17584 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_typedefDeclaration != NULL);</span></a>
<a name="17585"><span class="lineNum">   17585 </span>            : </a>
<a name="17586"><span class="lineNum">   17586 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17587"><span class="lineNum">   17587 </span>            :                printf (&quot;snippet: typedefDeclaration = %p = %s \n&quot;,snippet_typedefDeclaration,snippet_typedefDeclaration-&gt;get_name().str());</a>
<a name="17588"><span class="lineNum">   17588 </span>            :                printf (&quot;target: typedefDeclaration  = %p = %s \n&quot;,target_typedefDeclaration,target_typedefDeclaration-&gt;get_name().str());</a>
<a name="17589"><span class="lineNum">   17589 </span>            : #endif</a>
<a name="17590"><span class="lineNum">   17590 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_typedefDeclaration-&gt;get_name() == target_typedefDeclaration-&gt;get_name());</span></a>
<a name="17591"><span class="lineNum">   17591 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17592"><span class="lineNum">   17592 </span>            :              }</a>
<a name="17593"><span class="lineNum">   17593 </span>            : </a>
<a name="17594"><span class="lineNum">   17594 </span><span class="lineNoCov">          0 :           case V_SgEnumDeclaration:</span></a>
<a name="17595"><span class="lineNum">   17595 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17596"><span class="lineNum">   17596 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* snippet_enumDeclaration = isSgEnumDeclaration(snippet_declaration);</span></a>
<a name="17597"><span class="lineNum">   17597 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_enumDeclaration != NULL);</span></a>
<a name="17598"><span class="lineNum">   17598 </span>            : </a>
<a name="17599"><span class="lineNum">   17599 </span><span class="lineNoCov">          0 :                SgName snippet_enumName = snippet_enumDeclaration-&gt;get_name();</span></a>
<a name="17600"><span class="lineNum">   17600 </span>            : </a>
<a name="17601"><span class="lineNum">   17601 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17602"><span class="lineNum">   17602 </span>            :                printf (&quot;snippet snippet declaration's enum name = %s \n&quot;,snippet_enumName.str());</a>
<a name="17603"><span class="lineNum">   17603 </span>            : #endif</a>
<a name="17604"><span class="lineNum">   17604 </span>            :             // DQ (4/13/2014): check if this is an un-named enum beclaration.</a>
<a name="17605"><span class="lineNum">   17605 </span><span class="lineNoCov">          0 :                bool isUnNamed = snippet_enumDeclaration-&gt;get_isUnNamed();</span></a>
<a name="17606"><span class="lineNum">   17606 </span><span class="lineNoCov">          0 :                if (isUnNamed == false)</span></a>
<a name="17607"><span class="lineNum">   17607 </span>            :                   {</a>
<a name="17608"><span class="lineNum">   17608 </span>            :                  // SgEnumSymbol* target_symbol = target_AST_scope-&gt;lookup_enum_symbol(snippet_enumName);</a>
<a name="17609"><span class="lineNum">   17609 </span><span class="lineNoCov">          0 :                     SgEnumSymbol* target_symbol = lookupEnumSymbolInParentScopes(snippet_enumName,target_AST_scope);</span></a>
<a name="17610"><span class="lineNum">   17610 </span><span class="lineNoCov">          0 :                     if (target_symbol == NULL)</span></a>
<a name="17611"><span class="lineNum">   17611 </span>            :                        {</a>
<a name="17612"><span class="lineNum">   17612 </span>            :                       // Debug this case.</a>
<a name="17613"><span class="lineNum">   17613 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = snippet_enumDeclaration-&gt;get_scope();</span></a>
<a name="17614"><span class="lineNum">   17614 </span><span class="lineNoCov">          0 :                          printf (&quot;scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="17615"><span class="lineNum">   17615 </span><span class="lineNoCov">          0 :                          scope-&gt;get_file_info()-&gt;display(&quot;case V_SgEnumDeclaration: target_symbol == NULL: scope: debug&quot;);</span></a>
<a name="17616"><span class="lineNum">   17616 </span>            :                        }</a>
<a name="17617"><span class="lineNum">   17617 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17618"><span class="lineNum">   17618 </span><span class="lineNoCov">          0 :                     returnSymbol = target_symbol;</span></a>
<a name="17619"><span class="lineNum">   17619 </span>            : </a>
<a name="17620"><span class="lineNum">   17620 </span><span class="lineNoCov">          0 :                     SgEnumSymbol* enumSymbolInTargetAST = isSgEnumSymbol(returnSymbol);</span></a>
<a name="17621"><span class="lineNum">   17621 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(enumSymbolInTargetAST != NULL);</span></a>
<a name="17622"><span class="lineNum">   17622 </span><span class="lineNoCov">          0 :                     SgEnumDeclaration* target_enumDeclaration = isSgEnumDeclaration(enumSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17623"><span class="lineNum">   17623 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(target_enumDeclaration != NULL);</span></a>
<a name="17624"><span class="lineNum">   17624 </span>            : </a>
<a name="17625"><span class="lineNum">   17625 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17626"><span class="lineNum">   17626 </span>            :                     printf (&quot;snippet: enumDeclaration = %p = %s \n&quot;,snippet_enumDeclaration,snippet_enumDeclaration-&gt;get_name().str());</a>
<a name="17627"><span class="lineNum">   17627 </span>            :                     printf (&quot;target: enumDeclaration  = %p = %s \n&quot;,target_enumDeclaration,target_enumDeclaration-&gt;get_name().str());</a>
<a name="17628"><span class="lineNum">   17628 </span>            : #endif</a>
<a name="17629"><span class="lineNum">   17629 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippet_enumDeclaration-&gt;get_name() == target_enumDeclaration-&gt;get_name());</span></a>
<a name="17630"><span class="lineNum">   17630 </span>            :                   }</a>
<a name="17631"><span class="lineNum">   17631 </span>            :                  else</a>
<a name="17632"><span class="lineNum">   17632 </span>            :                   {</a>
<a name="17633"><span class="lineNum">   17633 </span>            :                  // DQ (4/13/2014): I think we all agreed these would not have to be handled.</a>
<a name="17634"><span class="lineNum">   17634 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: can't handle unnamed enum declarations \n&quot;);</span></a>
<a name="17635"><span class="lineNum">   17635 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(returnSymbol == NULL);</span></a>
<a name="17636"><span class="lineNum">   17636 </span>            :                   }</a>
<a name="17637"><span class="lineNum">   17637 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17638"><span class="lineNum">   17638 </span>            :              }</a>
<a name="17639"><span class="lineNum">   17639 </span>            : </a>
<a name="17640"><span class="lineNum">   17640 </span>            :        // DQ (12/11/2020): Adding support for codeSegregation tool.</a>
<a name="17641"><span class="lineNum">   17641 </span><span class="lineNoCov">          0 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="17642"><span class="lineNum">   17642 </span>            :        // DQ (12/8/2020): Adding support for codeSegregation tool.</a>
<a name="17643"><span class="lineNum">   17643 </span><span class="lineNoCov">          0 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="17644"><span class="lineNum">   17644 </span>            :        // DQ (12/5/2020): Adding support for codeSegregation tool.</a>
<a name="17645"><span class="lineNum">   17645 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="17646"><span class="lineNum">   17646 </span><span class="lineNoCov">          0 :           case V_SgFunctionDeclaration:</span></a>
<a name="17647"><span class="lineNum">   17647 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17648"><span class="lineNum">   17648 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* snippet_functionDeclaration = isSgFunctionDeclaration(snippet_declaration);</span></a>
<a name="17649"><span class="lineNum">   17649 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_functionDeclaration != NULL);</span></a>
<a name="17650"><span class="lineNum">   17650 </span>            : </a>
<a name="17651"><span class="lineNum">   17651 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17652"><span class="lineNum">   17652 </span>            :                printf (&quot;snippet_declaration = %p = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str());</a>
<a name="17653"><span class="lineNum">   17653 </span>            : #endif</a>
<a name="17654"><span class="lineNum">   17654 </span><span class="lineNoCov">          0 :                SgName snippet_functionName = snippet_functionDeclaration-&gt;get_name();</span></a>
<a name="17655"><span class="lineNum">   17655 </span>            : </a>
<a name="17656"><span class="lineNum">   17656 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17657"><span class="lineNum">   17657 </span>            :                printf (&quot;snippet snippet declaration's function name = %s \n&quot;,snippet_functionName.str());</a>
<a name="17658"><span class="lineNum">   17658 </span>            :                printf (&quot; --- target_AST_scope = %p = %s \n&quot;,target_AST_scope,target_AST_scope-&gt;class_name().c_str());</a>
<a name="17659"><span class="lineNum">   17659 </span>            : #endif</a>
<a name="17660"><span class="lineNum">   17660 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* target_symbol = target_AST_scope-&gt;lookup_function_symbol(snippet_functionName);</span></a>
<a name="17661"><span class="lineNum">   17661 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_symbol != NULL);</span></a>
<a name="17662"><span class="lineNum">   17662 </span><span class="lineNoCov">          0 :                returnSymbol = target_symbol;</span></a>
<a name="17663"><span class="lineNum">   17663 </span>            : </a>
<a name="17664"><span class="lineNum">   17664 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* functionSymbolInTargetAST = isSgFunctionSymbol(returnSymbol);</span></a>
<a name="17665"><span class="lineNum">   17665 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="17666"><span class="lineNum">   17666 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* target_functionDeclaration = isSgFunctionDeclaration(functionSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17667"><span class="lineNum">   17667 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(target_functionDeclaration != NULL);</span></a>
<a name="17668"><span class="lineNum">   17668 </span>            : </a>
<a name="17669"><span class="lineNum">   17669 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17670"><span class="lineNum">   17670 </span>            :                printf (&quot;snippet: functionDeclaration = %p = %s \n&quot;,snippet_functionDeclaration,snippet_functionDeclaration-&gt;get_name().str());</a>
<a name="17671"><span class="lineNum">   17671 </span>            :                printf (&quot;target: functionDeclaration  = %p = %s \n&quot;,target_functionDeclaration,target_functionDeclaration-&gt;get_name().str());</a>
<a name="17672"><span class="lineNum">   17672 </span>            :                printf (&quot;isDefiningDeclaration        = %s \n&quot;,isDefiningDeclaration ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17673"><span class="lineNum">   17673 </span>            : #endif</a>
<a name="17674"><span class="lineNum">   17674 </span><span class="lineNoCov">          0 :                if (isDefiningDeclaration == true)</span></a>
<a name="17675"><span class="lineNum">   17675 </span>            :                   {</a>
<a name="17676"><span class="lineNum">   17676 </span>            : #if DEBUG_FIND_ASSOCIATED_DECLARATION</a>
<a name="17677"><span class="lineNum">   17677 </span>            :                     printf (&quot;get the defining declaration instead of the firstNondefining declaration from the function symbol \n&quot;);</a>
<a name="17678"><span class="lineNum">   17678 </span>            : #endif</a>
<a name="17679"><span class="lineNum">   17679 </span><span class="lineNoCov">          0 :                     returnDeclaration = target_functionDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="17680"><span class="lineNum">   17680 </span>            :                   }</a>
<a name="17681"><span class="lineNum">   17681 </span>            : </a>
<a name="17682"><span class="lineNum">   17682 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippet_functionDeclaration-&gt;get_name() == target_functionDeclaration-&gt;get_name());</span></a>
<a name="17683"><span class="lineNum">   17683 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="17684"><span class="lineNum">   17684 </span>            :              }</a>
<a name="17685"><span class="lineNum">   17685 </span>            : </a>
<a name="17686"><span class="lineNum">   17686 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="17687"><span class="lineNum">   17687 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17688"><span class="lineNum">   17688 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached in switch: snippet_declaration = %p = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str());</span></a>
<a name="17689"><span class="lineNum">   17689 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="17690"><span class="lineNum">   17690 </span>            :              }</a>
<a name="17691"><span class="lineNum">   17691 </span>            :         }</a>
<a name="17692"><span class="lineNum">   17692 </span>            : </a>
<a name="17693"><span class="lineNum">   17693 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(returnDeclaration != NULL);</span></a>
<a name="17694"><span class="lineNum">   17694 </span>            : </a>
<a name="17695"><span class="lineNum">   17695 </span>            :   // These should have different global scopes, because they are from different ASTs.</a>
<a name="17696"><span class="lineNum">   17696 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(SageInterface::hasSameGlobalScope(snippet_declaration,returnDeclaration) == false);</span></a>
<a name="17697"><span class="lineNum">   17697 </span>            : </a>
<a name="17698"><span class="lineNum">   17698 </span>            :   // return the last found symbol.</a>
<a name="17699"><span class="lineNum">   17699 </span>            :   // return returnSymbol;</a>
<a name="17700"><span class="lineNum">   17700 </span><span class="lineNoCov">          0 :      return returnDeclaration;</span></a>
<a name="17701"><span class="lineNum">   17701 </span>            :    }</a>
<a name="17702"><span class="lineNum">   17702 </span>            : </a>
<a name="17703"><span class="lineNum">   17703 </span>            : </a>
<a name="17704"><span class="lineNum">   17704 </span>            : SgType*</a>
<a name="17705"><span class="lineNum">   17705 </span><span class="lineNoCov">          0 : SageBuilder::getTargetFileTypeSupport(SgType* snippet_type, SgScopeStatement* targetScope)</span></a>
<a name="17706"><span class="lineNum">   17706 </span>            :    {</a>
<a name="17707"><span class="lineNum">   17707 </span>            :   // This is the inner function to getTargetFileType()</a>
<a name="17708"><span class="lineNum">   17708 </span><span class="lineNoCov">          0 :      SgType* returnType = NULL;</span></a>
<a name="17709"><span class="lineNum">   17709 </span>            : </a>
<a name="17710"><span class="lineNum">   17710 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(snippet_type != NULL);</span></a>
<a name="17711"><span class="lineNum">   17711 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(targetScope != NULL);</span></a>
<a name="17712"><span class="lineNum">   17712 </span>            : </a>
<a name="17713"><span class="lineNum">   17713 </span>            :   // DQ (3/17/2014): Refactored code.</a>
<a name="17714"><span class="lineNum">   17714 </span>            :   // See if the type might be asociated with the snippet file.</a>
<a name="17715"><span class="lineNum">   17715 </span>            :   // DQ (7/25/2014): Remove warning from GNU 4.8 compiler.</a>
<a name="17716"><span class="lineNum">   17716 </span>            :   // SgType* type_copy     = snippet_type;</a>
<a name="17717"><span class="lineNum">   17717 </span>            : </a>
<a name="17718"><span class="lineNum">   17718 </span>            : #if 0</a>
<a name="17719"><span class="lineNum">   17719 </span>            :      SgType* type_copy     = snippet_type;</a>
<a name="17720"><span class="lineNum">   17720 </span>            :      printf (&quot;(before type_copy-&gt;getInternalTypes()): type_copy = %p = %s \n&quot;,type_copy,type_copy-&gt;class_name().c_str());</a>
<a name="17721"><span class="lineNum">   17721 </span>            : #endif</a>
<a name="17722"><span class="lineNum">   17722 </span>            : </a>
<a name="17723"><span class="lineNum">   17723 </span><span class="lineNoCov">          0 :      SgNamedType* namedType = isSgNamedType(snippet_type);</span></a>
<a name="17724"><span class="lineNum">   17724 </span><span class="lineNoCov">          0 :      if (namedType != NULL)</span></a>
<a name="17725"><span class="lineNum">   17725 </span>            :         {</a>
<a name="17726"><span class="lineNum">   17726 </span>            :        // Find the associated declaration and it's corresponding declaration in the target AST.</a>
<a name="17727"><span class="lineNum">   17727 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* snippet_declaration = namedType-&gt;get_declaration();</span></a>
<a name="17728"><span class="lineNum">   17728 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(snippet_declaration != NULL);</span></a>
<a name="17729"><span class="lineNum">   17729 </span>            : #if 0</a>
<a name="17730"><span class="lineNum">   17730 </span>            :           printf (&quot;Need to find the declaration in the target AST that is associated with the snippet_declaration in the snippet AST \n&quot;);</a>
<a name="17731"><span class="lineNum">   17731 </span>            :           printf (&quot;   --- snippet_declaration = %p = %s = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str(),SageInterface::get_name(snippet_declaration).c_str());</a>
<a name="17732"><span class="lineNum">   17732 </span>            : #endif</a>
<a name="17733"><span class="lineNum">   17733 </span>            :        // There are only a few cases here!</a>
<a name="17734"><span class="lineNum">   17734 </span><span class="lineNoCov">          0 :           switch (namedType-&gt;variantT())</span></a>
<a name="17735"><span class="lineNum">   17735 </span>            :              {</a>
<a name="17736"><span class="lineNum">   17736 </span><span class="lineNoCov">          0 :                case V_SgClassType:</span></a>
<a name="17737"><span class="lineNum">   17737 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17738"><span class="lineNum">   17738 </span><span class="lineNoCov">          0 :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(snippet_declaration);</span></a>
<a name="17739"><span class="lineNum">   17739 </span><span class="lineNoCov">          0 :                     if (classDeclaration != NULL)</span></a>
<a name="17740"><span class="lineNum">   17740 </span>            :                        {</a>
<a name="17741"><span class="lineNum">   17741 </span><span class="lineNoCov">          0 :                          SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(classDeclaration-&gt;get_name(),targetScope);</span></a>
<a name="17742"><span class="lineNum">   17742 </span><span class="lineNoCov">          0 :                          if (classSymbolInTargetAST == NULL)</span></a>
<a name="17743"><span class="lineNum">   17743 </span>            :                             {</a>
<a name="17744"><span class="lineNum">   17744 </span>            :                            // For Java or C++ this could be a name qualified type and so we need a better mechanism</a>
<a name="17745"><span class="lineNum">   17745 </span>            :                            // to identify it thorugh it's parent scopes. Build a list of parent scope back to the</a>
<a name="17746"><span class="lineNum">   17746 </span>            :                            // global scope and then traverse the list backwards to identify each scope in the target</a>
<a name="17747"><span class="lineNum">   17747 </span>            :                            // AST's global scope until we each the associated declaration in the target AST.</a>
<a name="17748"><span class="lineNum">   17748 </span>            : #if 0</a>
<a name="17749"><span class="lineNum">   17749 </span>            :                               printf (&quot;This is likely a name qualified scope (which can't be seen in a simple traversal of the parent scope (case of C++ or Java) \n&quot;);</a>
<a name="17750"><span class="lineNum">   17750 </span>            :                               printf (&quot;   --- Looking for target AST match for class name = %s \n&quot;,classDeclaration-&gt;get_name().str());</a>
<a name="17751"><span class="lineNum">   17751 </span>            : #endif</a>
<a name="17752"><span class="lineNum">   17752 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = findAssociatedSymbolInTargetAST(classDeclaration,targetScope);</span></a>
<a name="17753"><span class="lineNum">   17753 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="17754"><span class="lineNum">   17754 </span>            : </a>
<a name="17755"><span class="lineNum">   17755 </span><span class="lineNoCov">          0 :                               classSymbolInTargetAST = isSgClassSymbol(symbol);</span></a>
<a name="17756"><span class="lineNum">   17756 </span>            :                             }</a>
<a name="17757"><span class="lineNum">   17757 </span>            : </a>
<a name="17758"><span class="lineNum">   17758 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classSymbolInTargetAST != NULL);</span></a>
<a name="17759"><span class="lineNum">   17759 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* target_classDeclaration = isSgClassDeclaration(classSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17760"><span class="lineNum">   17760 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(target_classDeclaration != NULL);</span></a>
<a name="17761"><span class="lineNum">   17761 </span>            : #if 0</a>
<a name="17762"><span class="lineNum">   17762 </span>            :                          printf (&quot;snippet: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;get_name().str());</a>
<a name="17763"><span class="lineNum">   17763 </span>            :                          printf (&quot;target: classDeclaration = %p = %s \n&quot;,target_classDeclaration,target_classDeclaration-&gt;get_name().str());</a>
<a name="17764"><span class="lineNum">   17764 </span>            : #endif</a>
<a name="17765"><span class="lineNum">   17765 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classDeclaration-&gt;get_name() == target_classDeclaration-&gt;get_name());</span></a>
<a name="17766"><span class="lineNum">   17766 </span>            : </a>
<a name="17767"><span class="lineNum">   17767 </span><span class="lineNoCov">          0 :                          returnType = classSymbolInTargetAST-&gt;get_type();</span></a>
<a name="17768"><span class="lineNum">   17768 </span>            :                        }</a>
<a name="17769"><span class="lineNum">   17769 </span>            :                     break;</a>
<a name="17770"><span class="lineNum">   17770 </span>            :                   }</a>
<a name="17771"><span class="lineNum">   17771 </span>            : </a>
<a name="17772"><span class="lineNum">   17772 </span><span class="lineNoCov">          0 :                case V_SgTypedefType:</span></a>
<a name="17773"><span class="lineNum">   17773 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17774"><span class="lineNum">   17774 </span><span class="lineNoCov">          0 :                     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(snippet_declaration);</span></a>
<a name="17775"><span class="lineNum">   17775 </span><span class="lineNoCov">          0 :                     if (typedefDeclaration != NULL)</span></a>
<a name="17776"><span class="lineNum">   17776 </span>            :                        {</a>
<a name="17777"><span class="lineNum">   17777 </span><span class="lineNoCov">          0 :                          SgTypedefSymbol* typedefSymbolInTargetAST = lookupTypedefSymbolInParentScopes(typedefDeclaration-&gt;get_name(),targetScope);</span></a>
<a name="17778"><span class="lineNum">   17778 </span>            : </a>
<a name="17779"><span class="lineNum">   17779 </span>            :                       // Not clear if we have to handle a more general case here.</a>
<a name="17780"><span class="lineNum">   17780 </span>            :                       // ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</a>
<a name="17781"><span class="lineNum">   17781 </span>            :                       // returnType = typedefSymbolInTargetAST-&gt;get_type();</a>
<a name="17782"><span class="lineNum">   17782 </span><span class="lineNoCov">          0 :                          if (typedefSymbolInTargetAST == NULL)</span></a>
<a name="17783"><span class="lineNum">   17783 </span>            :                             {</a>
<a name="17784"><span class="lineNum">   17784 </span>            : #if 0</a>
<a name="17785"><span class="lineNum">   17785 </span>            :                               printf (&quot;Error: It is an error to not have a typedef type defined in the target AST (this is an old rule, we have to support more general rules now)! \n&quot;);</a>
<a name="17786"><span class="lineNum">   17786 </span>            :                               printf (&quot;   --- The target AST must have a valid typedef type (and associated declaration) to support resetting the SgTypedefType: %p \n&quot;,typedefDeclaration-&gt;get_type());</a>
<a name="17787"><span class="lineNum">   17787 </span>            : #endif</a>
<a name="17788"><span class="lineNum">   17788 </span>            :                            // DQ (3/16/2014): Find the associated typedef declaration (from the target AST)</a>
<a name="17789"><span class="lineNum">   17789 </span>            :                            // for the input type associated with its declaration in the snippet AST.</a>
<a name="17790"><span class="lineNum">   17790 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = findAssociatedSymbolInTargetAST(typedefDeclaration,targetScope);</span></a>
<a name="17791"><span class="lineNum">   17791 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="17792"><span class="lineNum">   17792 </span>            : </a>
<a name="17793"><span class="lineNum">   17793 </span><span class="lineNoCov">          0 :                               typedefSymbolInTargetAST = isSgTypedefSymbol(symbol);</span></a>
<a name="17794"><span class="lineNum">   17794 </span>            : </a>
<a name="17795"><span class="lineNum">   17795 </span>            :                            // Note that test5d demonstrates this problem.</a>
<a name="17796"><span class="lineNum">   17796 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="17797"><span class="lineNum">   17797 </span>            :                             }</a>
<a name="17798"><span class="lineNum">   17798 </span>            : </a>
<a name="17799"><span class="lineNum">   17799 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</span></a>
<a name="17800"><span class="lineNum">   17800 </span><span class="lineNoCov">          0 :                          SgTypedefDeclaration* target_typedefDeclaration = isSgTypedefDeclaration(typedefSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="17801"><span class="lineNum">   17801 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(target_typedefDeclaration != NULL);</span></a>
<a name="17802"><span class="lineNum">   17802 </span>            : #if 0</a>
<a name="17803"><span class="lineNum">   17803 </span>            :                          printf (&quot;snippet: typedefDeclaration = %p = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="17804"><span class="lineNum">   17804 </span>            :                          printf (&quot;target:  typedefDeclaration = %p = %s \n&quot;,target_typedefDeclaration,target_typedefDeclaration-&gt;get_name().str());</a>
<a name="17805"><span class="lineNum">   17805 </span>            : #endif</a>
<a name="17806"><span class="lineNum">   17806 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration-&gt;get_name() == target_typedefDeclaration-&gt;get_name());</span></a>
<a name="17807"><span class="lineNum">   17807 </span>            : </a>
<a name="17808"><span class="lineNum">   17808 </span><span class="lineNoCov">          0 :                          returnType = typedefSymbolInTargetAST-&gt;get_type();</span></a>
<a name="17809"><span class="lineNum">   17809 </span>            :                        }</a>
<a name="17810"><span class="lineNum">   17810 </span>            :                     break;</a>
<a name="17811"><span class="lineNum">   17811 </span>            :                   }</a>
<a name="17812"><span class="lineNum">   17812 </span>            : </a>
<a name="17813"><span class="lineNum">   17813 </span><span class="lineNoCov">          0 :                case V_SgEnumType:</span></a>
<a name="17814"><span class="lineNum">   17814 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17815"><span class="lineNum">   17815 </span><span class="lineNoCov">          0 :                     SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(snippet_declaration);</span></a>
<a name="17816"><span class="lineNum">   17816 </span><span class="lineNoCov">          0 :                     if (enumDeclaration != NULL)</span></a>
<a name="17817"><span class="lineNum">   17817 </span>            :                        {</a>
<a name="17818"><span class="lineNum">   17818 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumDeclaration-&gt;get_name().is_null() == false);</span></a>
<a name="17819"><span class="lineNum">   17819 </span><span class="lineNoCov">          0 :                          SgEnumSymbol* enumSymbolInTargetAST = lookupEnumSymbolInParentScopes(enumDeclaration-&gt;get_name(),targetScope);</span></a>
<a name="17820"><span class="lineNum">   17820 </span>            : </a>
<a name="17821"><span class="lineNum">   17821 </span>            :                       // Not clear if we have to handle a more general case here.</a>
<a name="17822"><span class="lineNum">   17822 </span>            :                       // ROSE_ASSERT(enumSymbolInTargetAST != NULL);</a>
<a name="17823"><span class="lineNum">   17823 </span>            :                       // returnType = enumSymbolInTargetAST-&gt;get_type();</a>
<a name="17824"><span class="lineNum">   17824 </span><span class="lineNoCov">          0 :                          if (enumSymbolInTargetAST == NULL)</span></a>
<a name="17825"><span class="lineNum">   17825 </span>            :                             {</a>
<a name="17826"><span class="lineNum">   17826 </span><span class="lineNoCov">          0 :                               printf (&quot;Error: It is an error to not have a enum type defined in the target AST! \n&quot;);</span></a>
<a name="17827"><span class="lineNum">   17827 </span><span class="lineNoCov">          0 :                               printf (&quot;   --- The target AST must have a valid enum type (and associated declaration) to support resetting the SgEnumType: %p \n&quot;,enumDeclaration-&gt;get_type());</span></a>
<a name="17828"><span class="lineNum">   17828 </span>            : </a>
<a name="17829"><span class="lineNum">   17829 </span>            :                            // We will allow this to pass for now, since it is a violation of the target AST, and not the snippet mechanism (I think).</a>
<a name="17830"><span class="lineNum">   17830 </span><span class="lineNoCov">          0 :                               returnType = snippet_type;</span></a>
<a name="17831"><span class="lineNum">   17831 </span>            : </a>
<a name="17832"><span class="lineNum">   17832 </span>            :                            // Note that test5d demonstrates this problem.</a>
<a name="17833"><span class="lineNum">   17833 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="17834"><span class="lineNum">   17834 </span>            :                             }</a>
<a name="17835"><span class="lineNum">   17835 </span>            :                            else</a>
<a name="17836"><span class="lineNum">   17836 </span>            :                             {</a>
<a name="17837"><span class="lineNum">   17837 </span><span class="lineNoCov">          0 :                               returnType = enumSymbolInTargetAST-&gt;get_type();</span></a>
<a name="17838"><span class="lineNum">   17838 </span>            :                             }</a>
<a name="17839"><span class="lineNum">   17839 </span>            :                        }</a>
<a name="17840"><span class="lineNum">   17840 </span>            : </a>
<a name="17841"><span class="lineNum">   17841 </span>            :                     break;</a>
<a name="17842"><span class="lineNum">   17842 </span>            :                   }</a>
<a name="17843"><span class="lineNum">   17843 </span>            : </a>
<a name="17844"><span class="lineNum">   17844 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="17845"><span class="lineNum">   17845 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="17846"><span class="lineNum">   17846 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: In getTargetFileTypeSupport(): default reached in switch: namedType = %p = %s \n&quot;,namedType,namedType-&gt;class_name().c_str());</span></a>
<a name="17847"><span class="lineNum">   17847 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="17848"><span class="lineNum">   17848 </span>            :                   }</a>
<a name="17849"><span class="lineNum">   17849 </span>            :              }</a>
<a name="17850"><span class="lineNum">   17850 </span>            : </a>
<a name="17851"><span class="lineNum">   17851 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(returnType != NULL);</span></a>
<a name="17852"><span class="lineNum">   17852 </span>            : #if 0</a>
<a name="17853"><span class="lineNum">   17853 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="17854"><span class="lineNum">   17854 </span>            :           ROSE_ABORT();</a>
<a name="17855"><span class="lineNum">   17855 </span>            : #endif</a>
<a name="17856"><span class="lineNum">   17856 </span>            :         }</a>
<a name="17857"><span class="lineNum">   17857 </span>            :        else</a>
<a name="17858"><span class="lineNum">   17858 </span>            :         {</a>
<a name="17859"><span class="lineNum">   17859 </span>            :        // Non-named types are shared, so we need not reset them.</a>
<a name="17860"><span class="lineNum">   17860 </span>            : </a>
<a name="17861"><span class="lineNum">   17861 </span>            :        // If this was not a named type then return NULL (which is checked at the</a>
<a name="17862"><span class="lineNum">   17862 </span>            :        // calling point, so that the type will not be reset).</a>
<a name="17863"><span class="lineNum">   17863 </span>            :         }</a>
<a name="17864"><span class="lineNum">   17864 </span>            : </a>
<a name="17865"><span class="lineNum">   17865 </span><span class="lineNoCov">          0 :      return returnType;</span></a>
<a name="17866"><span class="lineNum">   17866 </span>            :    }</a>
<a name="17867"><span class="lineNum">   17867 </span>            : </a>
<a name="17868"><span class="lineNum">   17868 </span>            : </a>
<a name="17869"><span class="lineNum">   17869 </span>            : SgType*</a>
<a name="17870"><span class="lineNum">   17870 </span><span class="lineNoCov">          0 : SageBuilder::getTargetFileType(SgType* snippet_type, SgScopeStatement* targetScope)</span></a>
<a name="17871"><span class="lineNum">   17871 </span>            :    {</a>
<a name="17872"><span class="lineNum">   17872 </span><span class="lineNoCov">          0 :      SgType* returnType = NULL;</span></a>
<a name="17873"><span class="lineNum">   17873 </span>            : </a>
<a name="17874"><span class="lineNum">   17874 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(snippet_type != NULL);</span></a>
<a name="17875"><span class="lineNum">   17875 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(targetScope != NULL);</span></a>
<a name="17876"><span class="lineNum">   17876 </span>            : </a>
<a name="17877"><span class="lineNum">   17877 </span>            :   // DQ (3/17/2014): Refactored code.</a>
<a name="17878"><span class="lineNum">   17878 </span>            :   // See if the type might be asociated with the snippet file.</a>
<a name="17879"><span class="lineNum">   17879 </span><span class="lineNoCov">          0 :      SgType* type_copy     = snippet_type;</span></a>
<a name="17880"><span class="lineNum">   17880 </span>            : </a>
<a name="17881"><span class="lineNum">   17881 </span>            : #if 0</a>
<a name="17882"><span class="lineNum">   17882 </span>            :      printf (&quot;(before type_copy-&gt;getInternalTypes()): type_copy = %p = %s \n&quot;,type_copy,type_copy-&gt;class_name().c_str());</a>
<a name="17883"><span class="lineNum">   17883 </span>            : #endif</a>
<a name="17884"><span class="lineNum">   17884 </span>            : </a>
<a name="17885"><span class="lineNum">   17885 </span>            :   // We need to be able to reproduce the pointer types to class types, etc.</a>
<a name="17886"><span class="lineNum">   17886 </span><span class="lineNoCov">          0 :      Rose_STL_Container&lt;SgType*&gt; typeList = type_copy-&gt;getInternalTypes();</span></a>
<a name="17887"><span class="lineNum">   17887 </span>            : </a>
<a name="17888"><span class="lineNum">   17888 </span>            : #if 0</a>
<a name="17889"><span class="lineNum">   17889 </span>            :      for (size_t i = 0; i &lt; typeList.size(); i++)</a>
<a name="17890"><span class="lineNum">   17890 </span>            :         {</a>
<a name="17891"><span class="lineNum">   17891 </span>            :           printf (&quot;Input type: typeList[i=%&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="17892"><span class="lineNum">   17892 </span>            :         }</a>
<a name="17893"><span class="lineNum">   17893 </span>            : #endif</a>
<a name="17894"><span class="lineNum">   17894 </span>            : </a>
<a name="17895"><span class="lineNum">   17895 </span>            : #if 1</a>
<a name="17896"><span class="lineNum">   17896 </span>            :   // This is the unwrapped version of the getTargetFileType() function.</a>
<a name="17897"><span class="lineNum">   17897 </span><span class="lineNoCov">          0 :      returnType = getTargetFileTypeSupport(snippet_type,targetScope);</span></a>
<a name="17898"><span class="lineNum">   17898 </span>            : #else</a>
<a name="17899"><span class="lineNum">   17899 </span>            :      SgNamedType* namedType = isSgNamedType(snippet_type);</a>
<a name="17900"><span class="lineNum">   17900 </span>            : </a>
<a name="17901"><span class="lineNum">   17901 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="17902"><span class="lineNum">   17902 </span>            : </a>
<a name="17903"><span class="lineNum">   17903 </span>            :      if (namedType != NULL)</a>
<a name="17904"><span class="lineNum">   17904 </span>            :         {</a>
<a name="17905"><span class="lineNum">   17905 </span>            :        // Find the associated declaration and it's corresponding declaration in the target AST.</a>
<a name="17906"><span class="lineNum">   17906 </span>            :           SgDeclarationStatement* snippet_declaration = namedType-&gt;get_declaration();</a>
<a name="17907"><span class="lineNum">   17907 </span>            :           ROSE_ASSERT(snippet_declaration != NULL);</a>
<a name="17908"><span class="lineNum">   17908 </span>            : #if 0</a>
<a name="17909"><span class="lineNum">   17909 </span>            :           printf (&quot;Need to find the declaration in the target AST that is associated with the snippet_declaration in the snippet AST \n&quot;);</a>
<a name="17910"><span class="lineNum">   17910 </span>            :           printf (&quot;   --- snippet_declaration = %p = %s = %s \n&quot;,snippet_declaration,snippet_declaration-&gt;class_name().c_str(),SageInterface::get_name(snippet_declaration).c_str());</a>
<a name="17911"><span class="lineNum">   17911 </span>            : #endif</a>
<a name="17912"><span class="lineNum">   17912 </span>            :        // There are only a few cases here!</a>
<a name="17913"><span class="lineNum">   17913 </span>            :           switch (namedType-&gt;variantT())</a>
<a name="17914"><span class="lineNum">   17914 </span>            :              {</a>
<a name="17915"><span class="lineNum">   17915 </span>            :                case V_SgClassType:</a>
<a name="17916"><span class="lineNum">   17916 </span>            :                   {</a>
<a name="17917"><span class="lineNum">   17917 </span>            :                     SgClassDeclaration* classDeclaration = isSgClassDeclaration(snippet_declaration);</a>
<a name="17918"><span class="lineNum">   17918 </span>            :                     if (classDeclaration != NULL)</a>
<a name="17919"><span class="lineNum">   17919 </span>            :                        {</a>
<a name="17920"><span class="lineNum">   17920 </span>            :                          SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(classDeclaration-&gt;get_name(),targetScope);</a>
<a name="17921"><span class="lineNum">   17921 </span>            :                          if (classSymbolInTargetAST == NULL)</a>
<a name="17922"><span class="lineNum">   17922 </span>            :                             {</a>
<a name="17923"><span class="lineNum">   17923 </span>            :                            // For Java or C++ this could be a name qualified type and so we need a better mechanism</a>
<a name="17924"><span class="lineNum">   17924 </span>            :                            // to identify it thorugh it's parent scopes. Build a list of parent scope back to the</a>
<a name="17925"><span class="lineNum">   17925 </span>            :                            // global scope and then traverse the list backwards to identify each scope in the target</a>
<a name="17926"><span class="lineNum">   17926 </span>            :                            // AST's global scope until we each the associated declaration in the target AST.</a>
<a name="17927"><span class="lineNum">   17927 </span>            : #if 0</a>
<a name="17928"><span class="lineNum">   17928 </span>            :                               printf (&quot;This is likely a name qualified scope (which can't be seen in a simple traversal of the parent scope (case of C++ or Java) \n&quot;);</a>
<a name="17929"><span class="lineNum">   17929 </span>            :                               printf (&quot;   --- Looking for target AST match for class name = %s \n&quot;,classDeclaration-&gt;get_name().str());</a>
<a name="17930"><span class="lineNum">   17930 </span>            : #endif</a>
<a name="17931"><span class="lineNum">   17931 </span>            :                               SgSymbol* symbol = findAssociatedSymbolInTargetAST(classDeclaration,targetScope);</a>
<a name="17932"><span class="lineNum">   17932 </span>            :                               ROSE_ASSERT(symbol != NULL);</a>
<a name="17933"><span class="lineNum">   17933 </span>            : </a>
<a name="17934"><span class="lineNum">   17934 </span>            :                               classSymbolInTargetAST = isSgClassSymbol(symbol);</a>
<a name="17935"><span class="lineNum">   17935 </span>            :                             }</a>
<a name="17936"><span class="lineNum">   17936 </span>            : </a>
<a name="17937"><span class="lineNum">   17937 </span>            :                          ROSE_ASSERT(classSymbolInTargetAST != NULL);</a>
<a name="17938"><span class="lineNum">   17938 </span>            :                          SgClassDeclaration* target_classDeclaration = isSgClassDeclaration(classSymbolInTargetAST-&gt;get_declaration());</a>
<a name="17939"><span class="lineNum">   17939 </span>            :                          ROSE_ASSERT(target_classDeclaration != NULL);</a>
<a name="17940"><span class="lineNum">   17940 </span>            : #if 0</a>
<a name="17941"><span class="lineNum">   17941 </span>            :                          printf (&quot;snippet: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;get_name().str());</a>
<a name="17942"><span class="lineNum">   17942 </span>            :                          printf (&quot;target: classDeclaration = %p = %s \n&quot;,target_classDeclaration,target_classDeclaration-&gt;get_name().str());</a>
<a name="17943"><span class="lineNum">   17943 </span>            : #endif</a>
<a name="17944"><span class="lineNum">   17944 </span>            :                          ROSE_ASSERT(classDeclaration-&gt;get_name() == target_classDeclaration-&gt;get_name());</a>
<a name="17945"><span class="lineNum">   17945 </span>            : </a>
<a name="17946"><span class="lineNum">   17946 </span>            :                          returnType = classSymbolInTargetAST-&gt;get_type();</a>
<a name="17947"><span class="lineNum">   17947 </span>            :                        }</a>
<a name="17948"><span class="lineNum">   17948 </span>            :                     break;</a>
<a name="17949"><span class="lineNum">   17949 </span>            :                   }</a>
<a name="17950"><span class="lineNum">   17950 </span>            : </a>
<a name="17951"><span class="lineNum">   17951 </span>            :                case V_SgTypedefType:</a>
<a name="17952"><span class="lineNum">   17952 </span>            :                   {</a>
<a name="17953"><span class="lineNum">   17953 </span>            :                     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(snippet_declaration);</a>
<a name="17954"><span class="lineNum">   17954 </span>            :                     if (typedefDeclaration != NULL)</a>
<a name="17955"><span class="lineNum">   17955 </span>            :                        {</a>
<a name="17956"><span class="lineNum">   17956 </span>            :                          SgTypedefSymbol* typedefSymbolInTargetAST = lookupTypedefSymbolInParentScopes(typedefDeclaration-&gt;get_name(),targetScope);</a>
<a name="17957"><span class="lineNum">   17957 </span>            : </a>
<a name="17958"><span class="lineNum">   17958 </span>            :                       // Not clear if we have to handle a more general case here.</a>
<a name="17959"><span class="lineNum">   17959 </span>            :                       // ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</a>
<a name="17960"><span class="lineNum">   17960 </span>            :                       // returnType = typedefSymbolInTargetAST-&gt;get_type();</a>
<a name="17961"><span class="lineNum">   17961 </span>            :                          if (typedefSymbolInTargetAST == NULL)</a>
<a name="17962"><span class="lineNum">   17962 </span>            :                             {</a>
<a name="17963"><span class="lineNum">   17963 </span>            : #if 0</a>
<a name="17964"><span class="lineNum">   17964 </span>            :                               printf (&quot;Error: It is an error to not have a typedef type defined in the target AST (this is an old rule, we have to support more general rules now)! \n&quot;);</a>
<a name="17965"><span class="lineNum">   17965 </span>            :                               printf (&quot;   --- The target AST must have a valid typedef type (and associated declaration) to support resetting the SgTypedefType: %p \n&quot;,typedefDeclaration-&gt;get_type());</a>
<a name="17966"><span class="lineNum">   17966 </span>            : #endif</a>
<a name="17967"><span class="lineNum">   17967 </span>            :                            // DQ (3/16/2014): Find the associated typedef declaration (from the target AST)</a>
<a name="17968"><span class="lineNum">   17968 </span>            :                            // for the input type associated with its declaration in the snippet AST.</a>
<a name="17969"><span class="lineNum">   17969 </span>            :                               SgSymbol* symbol = findAssociatedSymbolInTargetAST(typedefDeclaration,targetScope);</a>
<a name="17970"><span class="lineNum">   17970 </span>            :                               ROSE_ASSERT(symbol != NULL);</a>
<a name="17971"><span class="lineNum">   17971 </span>            : </a>
<a name="17972"><span class="lineNum">   17972 </span>            :                               typedefSymbolInTargetAST = isSgTypedefSymbol(symbol);</a>
<a name="17973"><span class="lineNum">   17973 </span>            : </a>
<a name="17974"><span class="lineNum">   17974 </span>            :                            // Note that test5d demonstrates this problem.</a>
<a name="17975"><span class="lineNum">   17975 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="17976"><span class="lineNum">   17976 </span>            :                             }</a>
<a name="17977"><span class="lineNum">   17977 </span>            : </a>
<a name="17978"><span class="lineNum">   17978 </span>            :                          ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</a>
<a name="17979"><span class="lineNum">   17979 </span>            :                          SgTypedefDeclaration* target_typedefDeclaration = isSgTypedefDeclaration(typedefSymbolInTargetAST-&gt;get_declaration());</a>
<a name="17980"><span class="lineNum">   17980 </span>            :                          ROSE_ASSERT(target_typedefDeclaration != NULL);</a>
<a name="17981"><span class="lineNum">   17981 </span>            : #if 0</a>
<a name="17982"><span class="lineNum">   17982 </span>            :                          printf (&quot;snippet: typedefDeclaration = %p = %s \n&quot;,typedefDeclaration,typedefDeclaration-&gt;get_name().str());</a>
<a name="17983"><span class="lineNum">   17983 </span>            :                          printf (&quot;target:  typedefDeclaration = %p = %s \n&quot;,target_typedefDeclaration,target_typedefDeclaration-&gt;get_name().str());</a>
<a name="17984"><span class="lineNum">   17984 </span>            : #endif</a>
<a name="17985"><span class="lineNum">   17985 </span>            :                          ROSE_ASSERT(typedefDeclaration-&gt;get_name() == target_typedefDeclaration-&gt;get_name());</a>
<a name="17986"><span class="lineNum">   17986 </span>            : </a>
<a name="17987"><span class="lineNum">   17987 </span>            :                          returnType = typedefSymbolInTargetAST-&gt;get_type();</a>
<a name="17988"><span class="lineNum">   17988 </span>            :                        }</a>
<a name="17989"><span class="lineNum">   17989 </span>            :                     break;</a>
<a name="17990"><span class="lineNum">   17990 </span>            :                   }</a>
<a name="17991"><span class="lineNum">   17991 </span>            : </a>
<a name="17992"><span class="lineNum">   17992 </span>            :                case V_SgEnumType:</a>
<a name="17993"><span class="lineNum">   17993 </span>            :                   {</a>
<a name="17994"><span class="lineNum">   17994 </span>            :                     SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(snippet_declaration);</a>
<a name="17995"><span class="lineNum">   17995 </span>            :                     if (enumDeclaration != NULL)</a>
<a name="17996"><span class="lineNum">   17996 </span>            :                        {</a>
<a name="17997"><span class="lineNum">   17997 </span>            :                          ROSE_ASSERT(enumDeclaration-&gt;get_name().is_null() == false);</a>
<a name="17998"><span class="lineNum">   17998 </span>            :                          SgEnumSymbol* enumSymbolInTargetAST = lookupEnumSymbolInParentScopes(enumDeclaration-&gt;get_name(),targetScope);</a>
<a name="17999"><span class="lineNum">   17999 </span>            : </a>
<a name="18000"><span class="lineNum">   18000 </span>            :                       // Not clear if we have to handle a more general case here.</a>
<a name="18001"><span class="lineNum">   18001 </span>            :                       // ROSE_ASSERT(enumSymbolInTargetAST != NULL);</a>
<a name="18002"><span class="lineNum">   18002 </span>            :                       // returnType = enumSymbolInTargetAST-&gt;get_type();</a>
<a name="18003"><span class="lineNum">   18003 </span>            :                          if (enumSymbolInTargetAST == NULL)</a>
<a name="18004"><span class="lineNum">   18004 </span>            :                             {</a>
<a name="18005"><span class="lineNum">   18005 </span>            :                               printf (&quot;Error: It is an error to not have a enum type defined in the target AST! \n&quot;);</a>
<a name="18006"><span class="lineNum">   18006 </span>            :                               printf (&quot;   --- The target AST must have a valid enum type (and associated declaration) to support resetting the SgEnumType: %p \n&quot;,enumDeclaration-&gt;get_type());</a>
<a name="18007"><span class="lineNum">   18007 </span>            : </a>
<a name="18008"><span class="lineNum">   18008 </span>            :                            // We will allow this to pass for now, since it is a violation of the target AST, and not the snippet mechanism (I think).</a>
<a name="18009"><span class="lineNum">   18009 </span>            :                               returnType = snippet_type;</a>
<a name="18010"><span class="lineNum">   18010 </span>            : </a>
<a name="18011"><span class="lineNum">   18011 </span>            :                            // Note that test5d demonstrates this problem.</a>
<a name="18012"><span class="lineNum">   18012 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="18013"><span class="lineNum">   18013 </span>            :                             }</a>
<a name="18014"><span class="lineNum">   18014 </span>            :                            else</a>
<a name="18015"><span class="lineNum">   18015 </span>            :                             {</a>
<a name="18016"><span class="lineNum">   18016 </span>            :                               returnType = enumSymbolInTargetAST-&gt;get_type();</a>
<a name="18017"><span class="lineNum">   18017 </span>            :                             }</a>
<a name="18018"><span class="lineNum">   18018 </span>            :                        }</a>
<a name="18019"><span class="lineNum">   18019 </span>            : </a>
<a name="18020"><span class="lineNum">   18020 </span>            :                     break;</a>
<a name="18021"><span class="lineNum">   18021 </span>            :                   }</a>
<a name="18022"><span class="lineNum">   18022 </span>            : </a>
<a name="18023"><span class="lineNum">   18023 </span>            :                default:</a>
<a name="18024"><span class="lineNum">   18024 </span>            :                   {</a>
<a name="18025"><span class="lineNum">   18025 </span>            :                     printf (&quot;Error: In getTargetFileType(): default reached in switch: namedType = %p = %s \n&quot;,namedType,namedType-&gt;class_name().c_str());</a>
<a name="18026"><span class="lineNum">   18026 </span>            :                     ROSE_ABORT();</a>
<a name="18027"><span class="lineNum">   18027 </span>            :                   }</a>
<a name="18028"><span class="lineNum">   18028 </span>            :              }</a>
<a name="18029"><span class="lineNum">   18029 </span>            : </a>
<a name="18030"><span class="lineNum">   18030 </span>            :           ROSE_ASSERT(returnType != NULL);</a>
<a name="18031"><span class="lineNum">   18031 </span>            : #if 0</a>
<a name="18032"><span class="lineNum">   18032 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="18033"><span class="lineNum">   18033 </span>            :           ROSE_ABORT();</a>
<a name="18034"><span class="lineNum">   18034 </span>            : #endif</a>
<a name="18035"><span class="lineNum">   18035 </span>            :         }</a>
<a name="18036"><span class="lineNum">   18036 </span>            :        else</a>
<a name="18037"><span class="lineNum">   18037 </span>            :         {</a>
<a name="18038"><span class="lineNum">   18038 </span>            :        // Non-named types are shared, so we need not reset them.</a>
<a name="18039"><span class="lineNum">   18039 </span>            : </a>
<a name="18040"><span class="lineNum">   18040 </span>            :        // If this was not a named type then return NULL (which is checked at the</a>
<a name="18041"><span class="lineNum">   18041 </span>            :        // calling point, so that the type will not be reset).</a>
<a name="18042"><span class="lineNum">   18042 </span>            :         }</a>
<a name="18043"><span class="lineNum">   18043 </span>            : #endif</a>
<a name="18044"><span class="lineNum">   18044 </span>            : </a>
<a name="18045"><span class="lineNum">   18045 </span><span class="lineNoCov">          0 :      SgType* new_type = returnType;</span></a>
<a name="18046"><span class="lineNum">   18046 </span>            : </a>
<a name="18047"><span class="lineNum">   18047 </span>            :   // DQ (3/17/2014): Refactored code.</a>
<a name="18048"><span class="lineNum">   18048 </span>            :   // Now rebuild the type_copy as required to represent associated modifiers, typedef wrappers, pointers and references.</a>
<a name="18049"><span class="lineNum">   18049 </span><span class="lineNoCov">          0 :      if (new_type != NULL &amp;&amp; typeList.size() &gt; 1)</span></a>
<a name="18050"><span class="lineNum">   18050 </span>            :         {</a>
<a name="18051"><span class="lineNum">   18051 </span><span class="lineNoCov">          0 :           int size = (int)typeList.size();</span></a>
<a name="18052"><span class="lineNum">   18052 </span><span class="lineNoCov">          0 :           for (int i = size - 2; i &gt;= 0; i--)</span></a>
<a name="18053"><span class="lineNum">   18053 </span>            :              {</a>
<a name="18054"><span class="lineNum">   18054 </span>            : #if 0</a>
<a name="18055"><span class="lineNum">   18055 </span>            :                printf (&quot;Rebuild type: typeList[i=%d] = %p = %s \n&quot;,i,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="18056"><span class="lineNum">   18056 </span>            : #endif</a>
<a name="18057"><span class="lineNum">   18057 </span>            :             // SgModifierType* SgModifierType::createType(SgType* base_type, unsigned int f, SgExpression* optional_fortran_type_kind )</a>
<a name="18058"><span class="lineNum">   18058 </span><span class="lineNoCov">          0 :                switch(typeList[i]-&gt;variantT())</span></a>
<a name="18059"><span class="lineNum">   18059 </span>            :                   {</a>
<a name="18060"><span class="lineNum">   18060 </span><span class="lineNoCov">          0 :                     case V_SgModifierType:</span></a>
<a name="18061"><span class="lineNum">   18061 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="18062"><span class="lineNum">   18062 </span><span class="lineNoCov">          0 :                          SgModifierType* modifierType = isSgModifierType(typeList[i]);</span></a>
<a name="18063"><span class="lineNum">   18063 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(modifierType != NULL);</span></a>
<a name="18064"><span class="lineNum">   18064 </span><span class="lineNoCov">          0 :                          if (modifierType-&gt;get_typeModifier().get_constVolatileModifier().isConst() == true)</span></a>
<a name="18065"><span class="lineNum">   18065 </span>            :                             {</a>
<a name="18066"><span class="lineNum">   18066 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(new_type != NULL);</span></a>
<a name="18067"><span class="lineNum">   18067 </span>            : #if 0</a>
<a name="18068"><span class="lineNum">   18068 </span>            :                               printf (&quot;Building a SgModifierType: calling buildConstType(): new_type = %p = %s \n&quot;,new_type,new_type-&gt;class_name().c_str());</a>
<a name="18069"><span class="lineNum">   18069 </span>            : #endif</a>
<a name="18070"><span class="lineNum">   18070 </span><span class="lineNoCov">          0 :                               new_type = buildConstType(new_type);</span></a>
<a name="18071"><span class="lineNum">   18071 </span>            :                             }</a>
<a name="18072"><span class="lineNum">   18072 </span>            :                            else</a>
<a name="18073"><span class="lineNum">   18073 </span>            :                             {</a>
<a name="18074"><span class="lineNum">   18074 </span>            :                            // Flag any additional modifiers that we might require (make anything not supported an error).</a>
<a name="18075"><span class="lineNum">   18075 </span><span class="lineNoCov">          0 :                               printf (&quot;Modifier kind not handled (not implemented) check what sort of modifier this is: \n&quot;);</span></a>
<a name="18076"><span class="lineNum">   18076 </span><span class="lineNoCov">          0 :                               modifierType-&gt;get_typeModifier().display(&quot;Modifier kind not handled&quot;);</span></a>
<a name="18077"><span class="lineNum">   18077 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="18078"><span class="lineNum">   18078 </span>            :                             }</a>
<a name="18079"><span class="lineNum">   18079 </span>            :                          break;</a>
<a name="18080"><span class="lineNum">   18080 </span>            :                        }</a>
<a name="18081"><span class="lineNum">   18081 </span>            : </a>
<a name="18082"><span class="lineNum">   18082 </span><span class="lineNoCov">          0 :                     case V_SgTypedefType:</span></a>
<a name="18083"><span class="lineNum">   18083 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="18084"><span class="lineNum">   18084 </span><span class="lineNoCov">          0 :                          SgTypedefType* typedefType = isSgTypedefType(typeList[i]);</span></a>
<a name="18085"><span class="lineNum">   18085 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefType != NULL);</span></a>
<a name="18086"><span class="lineNum">   18086 </span>            : </a>
<a name="18087"><span class="lineNum">   18087 </span>            :                       // DQ (3/17/2014): Call the associated support function instead.</a>
<a name="18088"><span class="lineNum">   18088 </span>            :                       // SgType* SageBuilder::getTargetFileType(SgType* snippet_type, SgScopeStatement* targetScope)</a>
<a name="18089"><span class="lineNum">   18089 </span>            :                       // SgType* new_typedefType = getTargetFileType(typedefType,targetScope);</a>
<a name="18090"><span class="lineNum">   18090 </span><span class="lineNoCov">          0 :                          SgType* new_typedefType = getTargetFileTypeSupport(typedefType,targetScope);</span></a>
<a name="18091"><span class="lineNum">   18091 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_typedefType != NULL);</span></a>
<a name="18092"><span class="lineNum">   18092 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(isSgTypedefType(new_typedefType) != NULL);</span></a>
<a name="18093"><span class="lineNum">   18093 </span>            : </a>
<a name="18094"><span class="lineNum">   18094 </span><span class="lineNoCov">          0 :                          new_type = new_typedefType;</span></a>
<a name="18095"><span class="lineNum">   18095 </span>            : #if 0</a>
<a name="18096"><span class="lineNum">   18096 </span>            :                          printf (&quot;ERROSE: SgTypedefType kind not handled (not implemented) \n&quot;);</a>
<a name="18097"><span class="lineNum">   18097 </span>            :                          ROSE_ABORT();</a>
<a name="18098"><span class="lineNum">   18098 </span>            : #endif</a>
<a name="18099"><span class="lineNum">   18099 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="18100"><span class="lineNum">   18100 </span>            :                        }</a>
<a name="18101"><span class="lineNum">   18101 </span>            : </a>
<a name="18102"><span class="lineNum">   18102 </span><span class="lineNoCov">          0 :                     case V_SgPointerType:</span></a>
<a name="18103"><span class="lineNum">   18103 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="18104"><span class="lineNum">   18104 </span><span class="lineNoCov">          0 :                          SgPointerType* pointerType = isSgPointerType(typeList[i]);</span></a>
<a name="18105"><span class="lineNum">   18105 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(pointerType != NULL);</span></a>
<a name="18106"><span class="lineNum">   18106 </span>            : #if 0</a>
<a name="18107"><span class="lineNum">   18107 </span>            :                          printf (&quot;Building a SgPointerType: calling buildPointerType(): new_type = %p = %s \n&quot;,new_type,new_type-&gt;class_name().c_str());</a>
<a name="18108"><span class="lineNum">   18108 </span>            : #endif</a>
<a name="18109"><span class="lineNum">   18109 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_type != NULL);</span></a>
<a name="18110"><span class="lineNum">   18110 </span><span class="lineNoCov">          0 :                          new_type = buildPointerType(new_type);</span></a>
<a name="18111"><span class="lineNum">   18111 </span>            : #if 0</a>
<a name="18112"><span class="lineNum">   18112 </span>            :                          printf (&quot;ERROSE: SgPointerType kind not handled (not implemented) \n&quot;);</a>
<a name="18113"><span class="lineNum">   18113 </span>            :                          ROSE_ABORT();</a>
<a name="18114"><span class="lineNum">   18114 </span>            : #endif</a>
<a name="18115"><span class="lineNum">   18115 </span>            :                          break;</a>
<a name="18116"><span class="lineNum">   18116 </span>            :                        }</a>
<a name="18117"><span class="lineNum">   18117 </span>            : </a>
<a name="18118"><span class="lineNum">   18118 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="18119"><span class="lineNum">   18119 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="18120"><span class="lineNum">   18120 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached in evaluation of typelist: typeList[i] = %p = %s \n&quot;,typeList[i],typeList[i]-&gt;class_name().c_str());</span></a>
<a name="18121"><span class="lineNum">   18121 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="18122"><span class="lineNum">   18122 </span>            :                        }</a>
<a name="18123"><span class="lineNum">   18123 </span>            :                   }</a>
<a name="18124"><span class="lineNum">   18124 </span>            :              }</a>
<a name="18125"><span class="lineNum">   18125 </span>            : </a>
<a name="18126"><span class="lineNum">   18126 </span>            :           returnType = new_type;</a>
<a name="18127"><span class="lineNum">   18127 </span>            :         }</a>
<a name="18128"><span class="lineNum">   18128 </span>            : </a>
<a name="18129"><span class="lineNum">   18129 </span>            : #if 0</a>
<a name="18130"><span class="lineNum">   18130 </span>            :      if (typeList.size() &gt; 1)</a>
<a name="18131"><span class="lineNum">   18131 </span>            :         {</a>
<a name="18132"><span class="lineNum">   18132 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="18133"><span class="lineNum">   18133 </span>            :           ROSE_ABORT();</a>
<a name="18134"><span class="lineNum">   18134 </span>            :         }</a>
<a name="18135"><span class="lineNum">   18135 </span>            : #endif</a>
<a name="18136"><span class="lineNum">   18136 </span>            : </a>
<a name="18137"><span class="lineNum">   18137 </span>            : </a>
<a name="18138"><span class="lineNum">   18138 </span><span class="lineNoCov">          0 :      return returnType;</span></a>
<a name="18139"><span class="lineNum">   18139 </span>            :    }</a>
<a name="18140"><span class="lineNum">   18140 </span>            : </a>
<a name="18141"><span class="lineNum">   18141 </span>            : </a>
<a name="18142"><span class="lineNum">   18142 </span>            : </a>
<a name="18143"><span class="lineNum">   18143 </span>            : void</a>
<a name="18144"><span class="lineNum">   18144 </span><span class="lineNoCov">          0 : SageBuilder::errorCheckingTargetAST (SgNode* node_copy, SgNode* node_original, SgFile* targetFile, bool failOnWarning )</span></a>
<a name="18145"><span class="lineNum">   18145 </span>            :    {</a>
<a name="18146"><span class="lineNum">   18146 </span>            : #if 0</a>
<a name="18147"><span class="lineNum">   18147 </span>            :      printf (&quot;In errorCheckingTargetAST(): node_copy = %p = %s node_original = %p = %s \n&quot;,node_copy,node_copy-&gt;class_name().c_str(),node_original,node_original-&gt;class_name().c_str());</a>
<a name="18148"><span class="lineNum">   18148 </span>            : #endif</a>
<a name="18149"><span class="lineNum">   18149 </span>            : </a>
<a name="18150"><span class="lineNum">   18150 </span>            :   // Handle what is the same about all statements before getting to the switch.</a>
<a name="18151"><span class="lineNum">   18151 </span><span class="lineNoCov">          0 :      SgStatement* statement_copy     = isSgStatement(node_copy);</span></a>
<a name="18152"><span class="lineNum">   18152 </span><span class="lineNoCov">          0 :      SgStatement* statement_original = isSgStatement(node_original);</span></a>
<a name="18153"><span class="lineNum">   18153 </span><span class="lineNoCov">          0 :      if (statement_copy != NULL)</span></a>
<a name="18154"><span class="lineNum">   18154 </span>            :         {</a>
<a name="18155"><span class="lineNum">   18155 </span>            :        // Check the scope if it is stored explicitly.</a>
<a name="18156"><span class="lineNum">   18156 </span><span class="lineNoCov">          0 :           if (statement_copy-&gt;hasExplicitScope() == true)</span></a>
<a name="18157"><span class="lineNum">   18157 </span>            :              {</a>
<a name="18158"><span class="lineNum">   18158 </span>            :             // Handle the scope for all statements.</a>
<a name="18159"><span class="lineNum">   18159 </span><span class="lineNoCov">          0 :                SgScopeStatement* scope_copy     = statement_copy-&gt;get_scope();</span></a>
<a name="18160"><span class="lineNum">   18160 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement_original != NULL);</span></a>
<a name="18161"><span class="lineNum">   18161 </span><span class="lineNoCov">          0 :                SgScopeStatement* scope_original = statement_original-&gt;get_scope();</span></a>
<a name="18162"><span class="lineNum">   18162 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope_copy     != NULL);</span></a>
<a name="18163"><span class="lineNum">   18163 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope_original != NULL);</span></a>
<a name="18164"><span class="lineNum">   18164 </span>            : </a>
<a name="18165"><span class="lineNum">   18165 </span>            :             // if (TransformationSupport::getFile(scope_original) != targetFile)</a>
<a name="18166"><span class="lineNum">   18166 </span>            :             // if (getEnclosingFileNode(scope_original) != targetFile)</a>
<a name="18167"><span class="lineNum">   18167 </span><span class="lineNoCov">          0 :                if (getEnclosingFileNode(scope_copy) != targetFile)</span></a>
<a name="18168"><span class="lineNum">   18168 </span>            :                   {</a>
<a name="18169"><span class="lineNum">   18169 </span>            : #if 0</a>
<a name="18170"><span class="lineNum">   18170 </span>            :                     printf (&quot;Warning: SgStatement: scope = %p = %s \n&quot;,scope_original,scope_original-&gt;class_name().c_str());</a>
<a name="18171"><span class="lineNum">   18171 </span>            : #endif</a>
<a name="18172"><span class="lineNum">   18172 </span>            :                  // SgFile* snippetFile = TransformationSupport::getFile(scope_original);</a>
<a name="18173"><span class="lineNum">   18173 </span>            :                  // SgFile* snippetFile = getEnclosingFileNode(scope_original);</a>
<a name="18174"><span class="lineNum">   18174 </span><span class="lineNoCov">          0 :                     SgFile* snippetFile = getEnclosingFileNode(scope_copy);</span></a>
<a name="18175"><span class="lineNum">   18175 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippetFile != NULL);</span></a>
<a name="18176"><span class="lineNum">   18176 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippetFile-&gt;get_sourceFileNameWithPath().empty() == false);</span></a>
<a name="18177"><span class="lineNum">   18177 </span>            : #if 1</a>
<a name="18178"><span class="lineNum">   18178 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n&quot;,snippetFile,snippetFile-&gt;get_sourceFileNameWithPath().c_str());</span></a>
<a name="18179"><span class="lineNum">   18179 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18180"><span class="lineNum">   18180 </span>            : #endif</a>
<a name="18181"><span class="lineNum">   18181 </span><span class="lineNoCov">          0 :                     if (failOnWarning == true)</span></a>
<a name="18182"><span class="lineNum">   18182 </span>            :                        {</a>
<a name="18183"><span class="lineNum">   18183 </span><span class="lineNoCov">          0 :                          printf (&quot;Exit on warning! \n&quot;);</span></a>
<a name="18184"><span class="lineNum">   18184 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="18185"><span class="lineNum">   18185 </span>            :                        }</a>
<a name="18186"><span class="lineNum">   18186 </span>            :                   }</a>
<a name="18187"><span class="lineNum">   18187 </span>            : #if 0</a>
<a name="18188"><span class="lineNum">   18188 </span>            :                SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</a>
<a name="18189"><span class="lineNum">   18189 </span>            :                printf (&quot;insertionPointIsScope = %s insertionPointScope = %p = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="18190"><span class="lineNum">   18190 </span>            : </a>
<a name="18191"><span class="lineNum">   18191 </span>            :             // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</a>
<a name="18192"><span class="lineNum">   18192 </span>            :             // ROSE_ASSERT(targetScope != NULL);</a>
<a name="18193"><span class="lineNum">   18193 </span>            : </a>
<a name="18194"><span class="lineNum">   18194 </span>            :             // SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18195"><span class="lineNum">   18195 </span>            :             // SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18196"><span class="lineNum">   18196 </span>            :             // SgVariableSymbol* variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol-&gt;get_name(),targetScope);</a>
<a name="18197"><span class="lineNum">   18197 </span>            :             // ROSE_ASSERT(variableSymbolInTargetAST != NULL);</a>
<a name="18198"><span class="lineNum">   18198 </span>            : </a>
<a name="18199"><span class="lineNum">   18199 </span>            :             // Unless we know that this is a declaration we can't set the scope here using the information about this being a definng declaration.</a>
<a name="18200"><span class="lineNum">   18200 </span>            :             // If this is a defining declaration then we want to set it's scope to targetScope, else we want to lookup</a>
<a name="18201"><span class="lineNum">   18201 </span>            :             // the symbol through the parent scope and set the scope using the symbol's first non-defining declaration.</a>
<a name="18202"><span class="lineNum">   18202 </span>            :             // statement_copy-&gt;set_scope(targetScope);</a>
<a name="18203"><span class="lineNum">   18203 </span>            : </a>
<a name="18204"><span class="lineNum">   18204 </span>            :             // SgSymbol* symbol = statement_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18205"><span class="lineNum">   18205 </span>            :             // ROSE_ASSERT(symbol != NULL);</a>
<a name="18206"><span class="lineNum">   18206 </span>            : #endif</a>
<a name="18207"><span class="lineNum">   18207 </span>            : #if 0</a>
<a name="18208"><span class="lineNum">   18208 </span>            :                printf (&quot;SgClassDeclaration: Exiting as a test! \n&quot;);</a>
<a name="18209"><span class="lineNum">   18209 </span>            :                ROSE_ABORT();</a>
<a name="18210"><span class="lineNum">   18210 </span>            : #endif</a>
<a name="18211"><span class="lineNum">   18211 </span>            : #if 0</a>
<a name="18212"><span class="lineNum">   18212 </span>            :                if (TransformationSupport::getFile(scope) != targetFile)</a>
<a name="18213"><span class="lineNum">   18213 </span>            :                   {</a>
<a name="18214"><span class="lineNum">   18214 </span>            :                     printf (&quot;Warning: SgStatement: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="18215"><span class="lineNum">   18215 </span>            :                     SgFile* snippetFile = TransformationSupport::getFile(scope);</a>
<a name="18216"><span class="lineNum">   18216 </span>            :                     ROSE_ASSERT(snippetFile != NULL);</a>
<a name="18217"><span class="lineNum">   18217 </span>            :                     ROSE_ASSERT(snippetFile-&gt;get_sourceFileNameWithPath().empty() == false);</a>
<a name="18218"><span class="lineNum">   18218 </span>            : </a>
<a name="18219"><span class="lineNum">   18219 </span>            :                     printf (&quot;Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n&quot;,snippetFile,snippetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="18220"><span class="lineNum">   18220 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18221"><span class="lineNum">   18221 </span>            :                   }</a>
<a name="18222"><span class="lineNum">   18222 </span>            : #endif</a>
<a name="18223"><span class="lineNum">   18223 </span>            :              }</a>
<a name="18224"><span class="lineNum">   18224 </span>            :         }</a>
<a name="18225"><span class="lineNum">   18225 </span>            : </a>
<a name="18226"><span class="lineNum">   18226 </span>            :   // Handle what is the same about all declaration before getting to the switch.</a>
<a name="18227"><span class="lineNum">   18227 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* declarationStatement_copy     = isSgDeclarationStatement(node_copy);</span></a>
<a name="18228"><span class="lineNum">   18228 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* declarationStatement_original = isSgDeclarationStatement(node_original);</span></a>
<a name="18229"><span class="lineNum">   18229 </span><span class="lineNoCov">          0 :      if (declarationStatement_copy != NULL)</span></a>
<a name="18230"><span class="lineNum">   18230 </span>            :         {</a>
<a name="18231"><span class="lineNum">   18231 </span>            :        // Check the firstnondefiningDeclaration and definingDeclaration</a>
<a name="18232"><span class="lineNum">   18232 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* firstNondefiningDeclaration_copy     = declarationStatement_copy-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="18233"><span class="lineNum">   18233 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* firstNondefiningDeclaration_original = declarationStatement_original-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="18234"><span class="lineNum">   18234 </span>            : </a>
<a name="18235"><span class="lineNum">   18235 </span>            :        // DQ (3/17/2014): Bugfix, we want to use the firstNondefiningDeclaration_copy instead of firstNondefiningDeclaration_original.</a>
<a name="18236"><span class="lineNum">   18236 </span>            :        // DQ (3/10/2014): We want to allow for NULL return values from getEnclosingFileNode() for Java classes that are in java.lang (for example).</a>
<a name="18237"><span class="lineNum">   18237 </span>            :        // SgFile* snippetFile = getEnclosingFileNode(firstNondefiningDeclaration_original);</a>
<a name="18238"><span class="lineNum">   18238 </span><span class="lineNoCov">          0 :           SgFile* snippetFile = getEnclosingFileNode(firstNondefiningDeclaration_copy);</span></a>
<a name="18239"><span class="lineNum">   18239 </span><span class="lineNoCov">          0 :           if (snippetFile != NULL &amp;&amp; snippetFile != targetFile)</span></a>
<a name="18240"><span class="lineNum">   18240 </span>            :              {</a>
<a name="18241"><span class="lineNum">   18241 </span>            :             // I think we want to allow this because it is a common occurence in any merged AST.</a>
<a name="18242"><span class="lineNum">   18242 </span>            :             // However, if might be worth fixing for other reasons.  This needs to be discussed.</a>
<a name="18243"><span class="lineNum">   18243 </span>            : #if 0</a>
<a name="18244"><span class="lineNum">   18244 </span>            :                printf (&quot;Note: SgDeclarationStatement: firstNondefiningDeclaration_original is not in target file (allowed for merged ASTs) \n&quot;);</a>
<a name="18245"><span class="lineNum">   18245 </span>            : #endif</a>
<a name="18246"><span class="lineNum">   18246 </span>            :             // ROSE_ASSERT(false);</a>
<a name="18247"><span class="lineNum">   18247 </span><span class="lineNoCov">          0 :                if (failOnWarning == true)</span></a>
<a name="18248"><span class="lineNum">   18248 </span>            :                   {</a>
<a name="18249"><span class="lineNum">   18249 </span><span class="lineNoCov">          0 :                     printf (&quot;Exit on warning! \n&quot;);</span></a>
<a name="18250"><span class="lineNum">   18250 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="18251"><span class="lineNum">   18251 </span>            :                   }</a>
<a name="18252"><span class="lineNum">   18252 </span>            :              }</a>
<a name="18253"><span class="lineNum">   18253 </span>            :             else</a>
<a name="18254"><span class="lineNum">   18254 </span>            :              {</a>
<a name="18255"><span class="lineNum">   18255 </span>            :             // Warn about this if snippetFile == NULL.</a>
<a name="18256"><span class="lineNum">   18256 </span><span class="lineNoCov">          0 :                if (snippetFile == NULL)</span></a>
<a name="18257"><span class="lineNum">   18257 </span>            :                   {</a>
<a name="18258"><span class="lineNum">   18258 </span><span class="lineNoCov">          0 :                     printf (&quot;Note: firstNondefiningDeclaration_original = %p getEnclosingFileNode() returned NULL \n&quot;,firstNondefiningDeclaration_original);</span></a>
<a name="18259"><span class="lineNum">   18259 </span>            : </a>
<a name="18260"><span class="lineNum">   18260 </span><span class="lineNoCov">          0 :                     if (failOnWarning == true)</span></a>
<a name="18261"><span class="lineNum">   18261 </span>            :                        {</a>
<a name="18262"><span class="lineNum">   18262 </span><span class="lineNoCov">          0 :                          printf (&quot;Exit on warning! \n&quot;);</span></a>
<a name="18263"><span class="lineNum">   18263 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="18264"><span class="lineNum">   18264 </span>            :                        }</a>
<a name="18265"><span class="lineNum">   18265 </span>            :                   }</a>
<a name="18266"><span class="lineNum">   18266 </span>            :              }</a>
<a name="18267"><span class="lineNum">   18267 </span>            : </a>
<a name="18268"><span class="lineNum">   18268 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* definingDeclaration_copy     = declarationStatement_copy-&gt;get_definingDeclaration();</span></a>
<a name="18269"><span class="lineNum">   18269 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* definingDeclaration_original = declarationStatement_original-&gt;get_definingDeclaration();</span></a>
<a name="18270"><span class="lineNum">   18270 </span><span class="lineNoCov">          0 :           if (definingDeclaration_original != NULL)</span></a>
<a name="18271"><span class="lineNum">   18271 </span>            :              {</a>
<a name="18272"><span class="lineNum">   18272 </span>            :             // DQ (3/17/2014): Bugfix, we want to use the definingDeclaration_copy instead of definingDeclaration_original.</a>
<a name="18273"><span class="lineNum">   18273 </span>            :             // if (TransformationSupport::getFile(definingDeclaration_original) != targetFile)</a>
<a name="18274"><span class="lineNum">   18274 </span>            :             // if (getEnclosingFileNode(definingDeclaration_original) != targetFile)</a>
<a name="18275"><span class="lineNum">   18275 </span>            :             // SgFile* snippetFile = getEnclosingFileNode(definingDeclaration_original);</a>
<a name="18276"><span class="lineNum">   18276 </span><span class="lineNoCov">          0 :                SgFile* snippetFile = getEnclosingFileNode(definingDeclaration_copy);</span></a>
<a name="18277"><span class="lineNum">   18277 </span><span class="lineNoCov">          0 :                if (snippetFile != NULL &amp;&amp; snippetFile != targetFile)</span></a>
<a name="18278"><span class="lineNum">   18278 </span>            :                   {</a>
<a name="18279"><span class="lineNum">   18279 </span>            : #if 1</a>
<a name="18280"><span class="lineNum">   18280 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: SgDeclarationStatement: definingDeclaration is not in target file \n&quot;);</span></a>
<a name="18281"><span class="lineNum">   18281 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18282"><span class="lineNum">   18282 </span>            : #endif</a>
<a name="18283"><span class="lineNum">   18283 </span><span class="lineNoCov">          0 :                     if (failOnWarning == true)</span></a>
<a name="18284"><span class="lineNum">   18284 </span>            :                        {</a>
<a name="18285"><span class="lineNum">   18285 </span><span class="lineNoCov">          0 :                          printf (&quot;Exit on warning! \n&quot;);</span></a>
<a name="18286"><span class="lineNum">   18286 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="18287"><span class="lineNum">   18287 </span>            :                        }</a>
<a name="18288"><span class="lineNum">   18288 </span>            : </a>
<a name="18289"><span class="lineNum">   18289 </span>            :                     if (declarationStatement_original == definingDeclaration_original)</a>
<a name="18290"><span class="lineNum">   18290 </span>            :                        {</a>
<a name="18291"><span class="lineNum">   18291 </span>            :                       // This is a defining declaration, so we can set the scope (or can we?)</a>
<a name="18292"><span class="lineNum">   18292 </span>            :                       // I guess we could if the translation map were complete, but it is not complete yet.</a>
<a name="18293"><span class="lineNum">   18293 </span>            :                        }</a>
<a name="18294"><span class="lineNum">   18294 </span>            :                   }</a>
<a name="18295"><span class="lineNum">   18295 </span>            :                  else</a>
<a name="18296"><span class="lineNum">   18296 </span>            :                   {</a>
<a name="18297"><span class="lineNum">   18297 </span>            :                  // Warn about this if snippetFile == NULL.</a>
<a name="18298"><span class="lineNum">   18298 </span><span class="lineNoCov">          0 :                     if (snippetFile == NULL)</span></a>
<a name="18299"><span class="lineNum">   18299 </span>            :                        {</a>
<a name="18300"><span class="lineNum">   18300 </span><span class="lineNoCov">          0 :                          printf (&quot;Note: definingDeclaration_original = %p getEnclosingFileNode() returned NULL \n&quot;,definingDeclaration_original);</span></a>
<a name="18301"><span class="lineNum">   18301 </span>            : </a>
<a name="18302"><span class="lineNum">   18302 </span><span class="lineNoCov">          0 :                          if (failOnWarning == true)</span></a>
<a name="18303"><span class="lineNum">   18303 </span>            :                             {</a>
<a name="18304"><span class="lineNum">   18304 </span><span class="lineNoCov">          0 :                               printf (&quot;Exit on warning! \n&quot;);</span></a>
<a name="18305"><span class="lineNum">   18305 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="18306"><span class="lineNum">   18306 </span>            :                             }</a>
<a name="18307"><span class="lineNum">   18307 </span>            :                        }</a>
<a name="18308"><span class="lineNum">   18308 </span>            :                   }</a>
<a name="18309"><span class="lineNum">   18309 </span>            :              }</a>
<a name="18310"><span class="lineNum">   18310 </span>            :         }</a>
<a name="18311"><span class="lineNum">   18311 </span>            : </a>
<a name="18312"><span class="lineNum">   18312 </span>            :   // Handle what is the same about all expressions before getting to the switch.</a>
<a name="18313"><span class="lineNum">   18313 </span><span class="lineNoCov">          0 :      SgExpression* expression = isSgExpression(node_copy);</span></a>
<a name="18314"><span class="lineNum">   18314 </span><span class="lineNoCov">          0 :      if (expression != NULL)</span></a>
<a name="18315"><span class="lineNum">   18315 </span>            :         {</a>
<a name="18316"><span class="lineNum">   18316 </span>            :        // Check the scope if it is stored explicitly.</a>
<a name="18317"><span class="lineNum">   18317 </span>            : </a>
<a name="18318"><span class="lineNum">   18318 </span>            :        // printf (&quot;WARNING: Need to check if the type is explicitly stored in this expression! \n&quot;);</a>
<a name="18319"><span class="lineNum">   18319 </span>            : </a>
<a name="18320"><span class="lineNum">   18320 </span><span class="lineNoCov">          0 :           if (expression-&gt;hasExplicitType() == true)</span></a>
<a name="18321"><span class="lineNum">   18321 </span>            :              {</a>
<a name="18322"><span class="lineNum">   18322 </span>            :             // Handle the type for all expressions.</a>
<a name="18323"><span class="lineNum">   18323 </span><span class="lineNoCov">          0 :                SgType* type = expression-&gt;get_type();</span></a>
<a name="18324"><span class="lineNum">   18324 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(type != NULL);</span></a>
<a name="18325"><span class="lineNum">   18325 </span>            :              }</a>
<a name="18326"><span class="lineNum">   18326 </span>            :         }</a>
<a name="18327"><span class="lineNum">   18327 </span>            : </a>
<a name="18328"><span class="lineNum">   18328 </span>            : #if 0</a>
<a name="18329"><span class="lineNum">   18329 </span>            :      printf (&quot;Leaving errorCheckingTargetAST() \n&quot;);</a>
<a name="18330"><span class="lineNum">   18330 </span>            : #endif</a>
<a name="18331"><span class="lineNum">   18331 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18332"><span class="lineNum">   18332 </span>            : </a>
<a name="18333"><span class="lineNum">   18333 </span>            : </a>
<a name="18334"><span class="lineNum">   18334 </span>            : template &lt;class T&gt;</a>
<a name="18335"><span class="lineNum">   18335 </span>            : void</a>
<a name="18336"><span class="lineNum">   18336 </span><span class="lineNoCov">          0 : SageBuilder::resetDeclaration(T* classDeclaration_copy, T* classDeclaration_original, SgScopeStatement* targetScope)</span></a>
<a name="18337"><span class="lineNum">   18337 </span>            :    {</a>
<a name="18338"><span class="lineNum">   18338 </span>            :   // I'm not sure if this function is a good idea since we can't call set_scope() easily from any</a>
<a name="18339"><span class="lineNum">   18339 </span>            :   // SgDeclarationStatement and I don't want to make set_scope() a virtual function because it would</a>
<a name="18340"><span class="lineNum">   18340 </span>            :   // not make sense everywhere.</a>
<a name="18341"><span class="lineNum">   18341 </span>            : </a>
<a name="18342"><span class="lineNum">   18342 </span>            :   // DQ (3/17/2014): This code is similar to the case for SgEnumDeclaration (later we can refactor this if this works well).</a>
<a name="18343"><span class="lineNum">   18343 </span><span class="lineNoCov">          0 :      T* classDeclaration_copy_defining        = dynamic_cast&lt;T*&gt;(classDeclaration_copy-&gt;get_definingDeclaration());</span></a>
<a name="18344"><span class="lineNum">   18344 </span><span class="lineNoCov">          0 :      T* classDeclaration_copy_nondefining     = dynamic_cast&lt;T*&gt;(classDeclaration_copy-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="18345"><span class="lineNum">   18345 </span><span class="lineNoCov">          0 :      T* classDeclaration_original_defining    = dynamic_cast&lt;T*&gt;(classDeclaration_original-&gt;get_definingDeclaration());</span></a>
<a name="18346"><span class="lineNum">   18346 </span><span class="lineNoCov">          0 :      T* classDeclaration_original_nondefining = dynamic_cast&lt;T*&gt;(classDeclaration_original-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="18347"><span class="lineNum">   18347 </span>            : </a>
<a name="18348"><span class="lineNum">   18348 </span>            :   // Set the scope if it is still set to the scope of the snippet AST.</a>
<a name="18349"><span class="lineNum">   18349 </span><span class="lineNoCov">          0 :      if (classDeclaration_copy_defining != NULL &amp;&amp; classDeclaration_copy_defining-&gt;get_scope() == classDeclaration_original_defining-&gt;get_scope())</span></a>
<a name="18350"><span class="lineNum">   18350 </span>            :         {</a>
<a name="18351"><span class="lineNum">   18351 </span>            : #if 0</a>
<a name="18352"><span class="lineNum">   18352 </span>            :           printf (&quot;reset the scope of classDeclaration_copy_defining \n&quot;);</a>
<a name="18353"><span class="lineNum">   18353 </span>            : #endif</a>
<a name="18354"><span class="lineNum">   18354 </span><span class="lineNoCov">          0 :           classDeclaration_copy_defining-&gt;set_scope(targetScope);</span></a>
<a name="18355"><span class="lineNum">   18355 </span>            :         }</a>
<a name="18356"><span class="lineNum">   18356 </span>            : </a>
<a name="18357"><span class="lineNum">   18357 </span>            :   // Set the scope if it is still set to the scope of the snippet AST.</a>
<a name="18358"><span class="lineNum">   18358 </span><span class="lineNoCov">          0 :      if (classDeclaration_copy_nondefining != NULL &amp;&amp; classDeclaration_copy_nondefining-&gt;get_scope() == classDeclaration_original_nondefining-&gt;get_scope())</span></a>
<a name="18359"><span class="lineNum">   18359 </span>            :         {</a>
<a name="18360"><span class="lineNum">   18360 </span>            : #if 0</a>
<a name="18361"><span class="lineNum">   18361 </span>            :           printf (&quot;reset the scope of classDeclaration_copy_nondefining \n&quot;);</a>
<a name="18362"><span class="lineNum">   18362 </span>            : #endif</a>
<a name="18363"><span class="lineNum">   18363 </span><span class="lineNoCov">          0 :           classDeclaration_copy_nondefining-&gt;set_scope(targetScope);</span></a>
<a name="18364"><span class="lineNum">   18364 </span>            :         }</a>
<a name="18365"><span class="lineNum">   18365 </span>            : </a>
<a name="18366"><span class="lineNum">   18366 </span>            :   // Set the parent if it is still set to a node of the snippet AST.</a>
<a name="18367"><span class="lineNum">   18367 </span><span class="lineNoCov">          0 :      if (classDeclaration_copy_nondefining != NULL &amp;&amp; classDeclaration_copy_nondefining-&gt;get_parent() == classDeclaration_original_nondefining-&gt;get_parent())</span></a>
<a name="18368"><span class="lineNum">   18368 </span>            :         {</a>
<a name="18369"><span class="lineNum">   18369 </span>            : #if 0</a>
<a name="18370"><span class="lineNum">   18370 </span>            :           printf (&quot;reset the parent of classDeclaration_copy_nondefining \n&quot;);</a>
<a name="18371"><span class="lineNum">   18371 </span>            : #endif</a>
<a name="18372"><span class="lineNum">   18372 </span><span class="lineNoCov">          0 :           classDeclaration_copy_nondefining-&gt;set_parent(classDeclaration_copy-&gt;get_parent());</span></a>
<a name="18373"><span class="lineNum">   18373 </span>            :         }</a>
<a name="18374"><span class="lineNum">   18374 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18375"><span class="lineNum">   18375 </span>            : </a>
<a name="18376"><span class="lineNum">   18376 </span>            : </a>
<a name="18377"><span class="lineNum">   18377 </span>            : void</a>
<a name="18378"><span class="lineNum">   18378 </span><span class="lineNoCov">          0 : SageBuilder::fixupCopyOfNodeFromSeparateFileInNewTargetAst(SgStatement* insertionPoint, bool insertionPointIsScope,</span></a>
<a name="18379"><span class="lineNum">   18379 </span>            :                                                            SgNode* node_copy, SgNode* node_original)</a>
<a name="18380"><span class="lineNum">   18380 </span>            :    {</a>
<a name="18381"><span class="lineNum">   18381 </span>            :   // This function fixes up invidual IR nodes to be consistant in the context of the target AST</a>
<a name="18382"><span class="lineNum">   18382 </span>            :   // where the node is inserted and at the point specified by insertionPoint.  In this function,</a>
<a name="18383"><span class="lineNum">   18383 </span>            :   // node_copy is the copy that was made of node_original by the AST copy function.  The node_original</a>
<a name="18384"><span class="lineNum">   18384 </span>            :   // is assumed to be the node that is in the AST snippet (it is still connected in the snippet's</a>
<a name="18385"><span class="lineNum">   18385 </span>            :   // AST (from compilation of the snippet file).</a>
<a name="18386"><span class="lineNum">   18386 </span>            : </a>
<a name="18387"><span class="lineNum">   18387 </span>            :   // This function hides the details of handling each different type of IR node.</a>
<a name="18388"><span class="lineNum">   18388 </span>            :   // It is assume that the node_copy is from an AST sub-tree generated by the AST copy mechanism,</a>
<a name="18389"><span class="lineNum">   18389 </span>            :   // and that the insertionPoint is a location in the target AST where the snippet AST has already</a>
<a name="18390"><span class="lineNum">   18390 </span>            :   // been inserted, this function makes each IR node internally consistant with the target AST.</a>
<a name="18391"><span class="lineNum">   18391 </span>            : </a>
<a name="18392"><span class="lineNum">   18392 </span>            :   // BTW, the translationMap should only be required to support references to things that are name</a>
<a name="18393"><span class="lineNum">   18393 </span>            :   // qualified (which are C++ specific). These are a performance option to simplify tacking back</a>
<a name="18394"><span class="lineNum">   18394 </span>            :   // through scopes with code similarly complex as to what is supported in the name qualification</a>
<a name="18395"><span class="lineNum">   18395 </span>            :   // support.</a>
<a name="18396"><span class="lineNum">   18396 </span>            : #if 0</a>
<a name="18397"><span class="lineNum">   18397 </span>            :      printf (&quot;In fixupCopyOfNodeFromSeperateFileInNewTargetAst: node_copy = %p = %s \n&quot;,node_copy,node_copy-&gt;class_name().c_str());</a>
<a name="18398"><span class="lineNum">   18398 </span>            : #endif</a>
<a name="18399"><span class="lineNum">   18399 </span>            : </a>
<a name="18400"><span class="lineNum">   18400 </span>            : #if 0</a>
<a name="18401"><span class="lineNum">   18401 </span>            :      printf (&quot;Disabled fixupCopyOfNodeFromSeperateFileInNewTargetAst() \n&quot;);</a>
<a name="18402"><span class="lineNum">   18402 </span>            :      return;</a>
<a name="18403"><span class="lineNum">   18403 </span>            : #endif</a>
<a name="18404"><span class="lineNum">   18404 </span>            : </a>
<a name="18405"><span class="lineNum">   18405 </span>            :   // SgFile* targetFile = TransformationSupport::getFile(insertionPoint);</a>
<a name="18406"><span class="lineNum">   18406 </span><span class="lineNoCov">          0 :      SgFile* targetFile = getEnclosingFileNode(insertionPoint);</span></a>
<a name="18407"><span class="lineNum">   18407 </span>            : </a>
<a name="18408"><span class="lineNum">   18408 </span>            : #if 0</a>
<a name="18409"><span class="lineNum">   18409 </span>            :      printf (&quot;   --- targetFile            = %p = %s \n&quot;,targetFile,targetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="18410"><span class="lineNum">   18410 </span>            :      printf (&quot;   --- insertionPointIsScope = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="18411"><span class="lineNum">   18411 </span>            : #endif</a>
<a name="18412"><span class="lineNum">   18412 </span>            : </a>
<a name="18413"><span class="lineNum">   18413 </span>            :   // DQ (3/4/2014): As I recall there is a reason why we can't setup the scope here.</a>
<a name="18414"><span class="lineNum">   18414 </span>            : </a>
<a name="18415"><span class="lineNum">   18415 </span>            :   // We also need to handle the symbol (move it from the body (SgBaicBlock) that was</a>
<a name="18416"><span class="lineNum">   18416 </span>            :   // a copy to the scope in the target AST where the SgInitializedName was inserted).</a>
<a name="18417"><span class="lineNum">   18417 </span><span class="lineNoCov">          0 :      SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</span></a>
<a name="18418"><span class="lineNum">   18418 </span>            : #if 0</a>
<a name="18419"><span class="lineNum">   18419 </span>            :      printf (&quot;insertionPointScope = %p = %s \n&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="18420"><span class="lineNum">   18420 </span>            : #endif</a>
<a name="18421"><span class="lineNum">   18421 </span><span class="lineNoCov">          0 :      SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</span></a>
<a name="18422"><span class="lineNum">   18422 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(targetScope != NULL);</span></a>
<a name="18423"><span class="lineNum">   18423 </span>            : </a>
<a name="18424"><span class="lineNum">   18424 </span>            : #if 1</a>
<a name="18425"><span class="lineNum">   18425 </span>            :   // Refactored code (error checking done after AST fixup).</a>
<a name="18426"><span class="lineNum">   18426 </span>            : #if 0</a>
<a name="18427"><span class="lineNum">   18427 </span>            :      errorCheckingTargetAST(node_copy,node_original,targetFile, false);</a>
<a name="18428"><span class="lineNum">   18428 </span>            : #endif</a>
<a name="18429"><span class="lineNum">   18429 </span>            : #else</a>
<a name="18430"><span class="lineNum">   18430 </span>            : </a>
<a name="18431"><span class="lineNum">   18431 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18432"><span class="lineNum">   18432 </span>            : </a>
<a name="18433"><span class="lineNum">   18433 </span>            :   // Handle what is the same about all statements before getting to the switch.</a>
<a name="18434"><span class="lineNum">   18434 </span>            :      SgStatement* statement_copy     = isSgStatement(node_copy);</a>
<a name="18435"><span class="lineNum">   18435 </span>            :      SgStatement* statement_original = isSgStatement(node_original);</a>
<a name="18436"><span class="lineNum">   18436 </span>            :      if (statement_copy != NULL)</a>
<a name="18437"><span class="lineNum">   18437 </span>            :         {</a>
<a name="18438"><span class="lineNum">   18438 </span>            :        // Check the scope if it is stored explicitly.</a>
<a name="18439"><span class="lineNum">   18439 </span>            :           if (statement_copy-&gt;hasExplicitScope() == true)</a>
<a name="18440"><span class="lineNum">   18440 </span>            :              {</a>
<a name="18441"><span class="lineNum">   18441 </span>            :             // Handle the scope for all statements.</a>
<a name="18442"><span class="lineNum">   18442 </span>            :                SgScopeStatement* scope_copy     = statement_copy-&gt;get_scope();</a>
<a name="18443"><span class="lineNum">   18443 </span>            :                SgScopeStatement* scope_original = statement_original-&gt;get_scope();</a>
<a name="18444"><span class="lineNum">   18444 </span>            :                ROSE_ASSERT(scope_copy     != NULL);</a>
<a name="18445"><span class="lineNum">   18445 </span>            :                ROSE_ASSERT(scope_original != NULL);</a>
<a name="18446"><span class="lineNum">   18446 </span>            : </a>
<a name="18447"><span class="lineNum">   18447 </span>            :             // if (TransformationSupport::getFile(scope_original) != targetFile)</a>
<a name="18448"><span class="lineNum">   18448 </span>            :                if (getEnclosingFileNode(scope_original) != targetFile)</a>
<a name="18449"><span class="lineNum">   18449 </span>            :                   {</a>
<a name="18450"><span class="lineNum">   18450 </span>            : #if 0</a>
<a name="18451"><span class="lineNum">   18451 </span>            :                     printf (&quot;Warning: SgStatement: scope = %p = %s \n&quot;,scope_original,scope_original-&gt;class_name().c_str());</a>
<a name="18452"><span class="lineNum">   18452 </span>            : #endif</a>
<a name="18453"><span class="lineNum">   18453 </span>            :                  // SgFile* snippetFile = TransformationSupport::getFile(scope_original);</a>
<a name="18454"><span class="lineNum">   18454 </span>            :                     SgFile* snippetFile = getEnclosingFileNode(scope_original);</a>
<a name="18455"><span class="lineNum">   18455 </span>            :                     ROSE_ASSERT(snippetFile != NULL);</a>
<a name="18456"><span class="lineNum">   18456 </span>            :                     ROSE_ASSERT(snippetFile-&gt;get_sourceFileNameWithPath().empty() == false);</a>
<a name="18457"><span class="lineNum">   18457 </span>            : #if 0</a>
<a name="18458"><span class="lineNum">   18458 </span>            :                     printf (&quot;Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n&quot;,snippetFile,snippetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="18459"><span class="lineNum">   18459 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18460"><span class="lineNum">   18460 </span>            : #endif</a>
<a name="18461"><span class="lineNum">   18461 </span>            :                   }</a>
<a name="18462"><span class="lineNum">   18462 </span>            : #if 0</a>
<a name="18463"><span class="lineNum">   18463 </span>            :                SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</a>
<a name="18464"><span class="lineNum">   18464 </span>            :                printf (&quot;insertionPointIsScope = %s insertionPointScope = %p = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="18465"><span class="lineNum">   18465 </span>            : </a>
<a name="18466"><span class="lineNum">   18466 </span>            :             // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</a>
<a name="18467"><span class="lineNum">   18467 </span>            :             // ROSE_ASSERT(targetScope != NULL);</a>
<a name="18468"><span class="lineNum">   18468 </span>            : </a>
<a name="18469"><span class="lineNum">   18469 </span>            :             // SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18470"><span class="lineNum">   18470 </span>            :             // SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18471"><span class="lineNum">   18471 </span>            :             // SgVariableSymbol* variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol-&gt;get_name(),targetScope);</a>
<a name="18472"><span class="lineNum">   18472 </span>            :             // ROSE_ASSERT(variableSymbolInTargetAST != NULL);</a>
<a name="18473"><span class="lineNum">   18473 </span>            : </a>
<a name="18474"><span class="lineNum">   18474 </span>            :             // Unless we know that this is a declaration we can't set the scope here using the information about this being a definng declaration.</a>
<a name="18475"><span class="lineNum">   18475 </span>            :             // If this is a defining declaration then we want to set it's scope to targetScope, else we want to lookup</a>
<a name="18476"><span class="lineNum">   18476 </span>            :             // the symbol through the parent scope and set the scope using the symbol's first non-defining declaration.</a>
<a name="18477"><span class="lineNum">   18477 </span>            :             // statement_copy-&gt;set_scope(targetScope);</a>
<a name="18478"><span class="lineNum">   18478 </span>            : </a>
<a name="18479"><span class="lineNum">   18479 </span>            :             // SgSymbol* symbol = statement_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18480"><span class="lineNum">   18480 </span>            :             // ROSE_ASSERT(symbol != NULL);</a>
<a name="18481"><span class="lineNum">   18481 </span>            : #endif</a>
<a name="18482"><span class="lineNum">   18482 </span>            : #if 0</a>
<a name="18483"><span class="lineNum">   18483 </span>            :                printf (&quot;SgClassDeclaration: Exiting as a test! \n&quot;);</a>
<a name="18484"><span class="lineNum">   18484 </span>            :                ROSE_ABORT();</a>
<a name="18485"><span class="lineNum">   18485 </span>            : #endif</a>
<a name="18486"><span class="lineNum">   18486 </span>            : #if 0</a>
<a name="18487"><span class="lineNum">   18487 </span>            :                if (TransformationSupport::getFile(scope) != targetFile)</a>
<a name="18488"><span class="lineNum">   18488 </span>            :                   {</a>
<a name="18489"><span class="lineNum">   18489 </span>            :                     printf (&quot;Warning: SgStatement: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="18490"><span class="lineNum">   18490 </span>            :                     SgFile* snippetFile = TransformationSupport::getFile(scope);</a>
<a name="18491"><span class="lineNum">   18491 </span>            :                     ROSE_ASSERT(snippetFile != NULL);</a>
<a name="18492"><span class="lineNum">   18492 </span>            :                     ROSE_ASSERT(snippetFile-&gt;get_sourceFileNameWithPath().empty() == false);</a>
<a name="18493"><span class="lineNum">   18493 </span>            : </a>
<a name="18494"><span class="lineNum">   18494 </span>            :                     printf (&quot;Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n&quot;,snippetFile,snippetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="18495"><span class="lineNum">   18495 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18496"><span class="lineNum">   18496 </span>            :                   }</a>
<a name="18497"><span class="lineNum">   18497 </span>            : #endif</a>
<a name="18498"><span class="lineNum">   18498 </span>            :              }</a>
<a name="18499"><span class="lineNum">   18499 </span>            :         }</a>
<a name="18500"><span class="lineNum">   18500 </span>            : </a>
<a name="18501"><span class="lineNum">   18501 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18502"><span class="lineNum">   18502 </span>            : </a>
<a name="18503"><span class="lineNum">   18503 </span>            :   // Handle what is the same about all declaration before getting to the switch.</a>
<a name="18504"><span class="lineNum">   18504 </span>            :      SgDeclarationStatement* declarationStatement_copy     = isSgDeclarationStatement(node_copy);</a>
<a name="18505"><span class="lineNum">   18505 </span>            :      SgDeclarationStatement* declarationStatement_original = isSgDeclarationStatement(node_original);</a>
<a name="18506"><span class="lineNum">   18506 </span>            :      if (declarationStatement_copy != NULL)</a>
<a name="18507"><span class="lineNum">   18507 </span>            :         {</a>
<a name="18508"><span class="lineNum">   18508 </span>            :        // Check the firstnondefiningDeclaration and definingDeclaration</a>
<a name="18509"><span class="lineNum">   18509 </span>            :           SgDeclarationStatement* firstNondefiningDeclaration_original = declarationStatement_original-&gt;get_firstNondefiningDeclaration();</a>
<a name="18510"><span class="lineNum">   18510 </span>            : </a>
<a name="18511"><span class="lineNum">   18511 </span>            :        // DQ (3/10/2014): We want to allow for NULL return values from getEnclosingFileNode() for Java classes that are in java.lang (for example).</a>
<a name="18512"><span class="lineNum">   18512 </span>            :           SgFile* snippetFile = getEnclosingFileNode(firstNondefiningDeclaration_original);</a>
<a name="18513"><span class="lineNum">   18513 </span>            :           if (snippetFile != NULL &amp;&amp; snippetFile != targetFile)</a>
<a name="18514"><span class="lineNum">   18514 </span>            :              {</a>
<a name="18515"><span class="lineNum">   18515 </span>            :             // I think we want to allow this because it is a common occurence in any merged AST.</a>
<a name="18516"><span class="lineNum">   18516 </span>            :             // However, if might be worth fixing for other reasons.  This needs to be discussed.</a>
<a name="18517"><span class="lineNum">   18517 </span>            : #if 0</a>
<a name="18518"><span class="lineNum">   18518 </span>            :                printf (&quot;Note: SgDeclarationStatement: firstNondefiningDeclaration_original is not in target file (allowed for merged ASTs) \n&quot;);</a>
<a name="18519"><span class="lineNum">   18519 </span>            : #endif</a>
<a name="18520"><span class="lineNum">   18520 </span>            :             // ROSE_ASSERT(false);</a>
<a name="18521"><span class="lineNum">   18521 </span>            :              }</a>
<a name="18522"><span class="lineNum">   18522 </span>            :             else</a>
<a name="18523"><span class="lineNum">   18523 </span>            :              {</a>
<a name="18524"><span class="lineNum">   18524 </span>            :             // Warn about this if snippetFile == NULL.</a>
<a name="18525"><span class="lineNum">   18525 </span>            :                if (snippetFile == NULL)</a>
<a name="18526"><span class="lineNum">   18526 </span>            :                   {</a>
<a name="18527"><span class="lineNum">   18527 </span>            :                     printf (&quot;Note: firstNondefiningDeclaration_original = %p getEnclosingFileNode() returned NULL \n&quot;,firstNondefiningDeclaration_original);</a>
<a name="18528"><span class="lineNum">   18528 </span>            :                   }</a>
<a name="18529"><span class="lineNum">   18529 </span>            :              }</a>
<a name="18530"><span class="lineNum">   18530 </span>            : </a>
<a name="18531"><span class="lineNum">   18531 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18532"><span class="lineNum">   18532 </span>            : </a>
<a name="18533"><span class="lineNum">   18533 </span>            :           SgDeclarationStatement* definingDeclaration_original = declarationStatement_original-&gt;get_definingDeclaration();</a>
<a name="18534"><span class="lineNum">   18534 </span>            :           if (definingDeclaration_original != NULL)</a>
<a name="18535"><span class="lineNum">   18535 </span>            :              {</a>
<a name="18536"><span class="lineNum">   18536 </span>            :             // if (TransformationSupport::getFile(definingDeclaration_original) != targetFile)</a>
<a name="18537"><span class="lineNum">   18537 </span>            :             // if (getEnclosingFileNode(definingDeclaration_original) != targetFile)</a>
<a name="18538"><span class="lineNum">   18538 </span>            :                SgFile* snippetFile = getEnclosingFileNode(definingDeclaration_original);</a>
<a name="18539"><span class="lineNum">   18539 </span>            :                if (snippetFile != NULL &amp;&amp; snippetFile != targetFile)</a>
<a name="18540"><span class="lineNum">   18540 </span>            :                   {</a>
<a name="18541"><span class="lineNum">   18541 </span>            : #if 0</a>
<a name="18542"><span class="lineNum">   18542 </span>            :                     printf (&quot;Warning: SgDeclarationStatement: definingDeclaration is not in target file \n&quot;);</a>
<a name="18543"><span class="lineNum">   18543 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18544"><span class="lineNum">   18544 </span>            : #endif</a>
<a name="18545"><span class="lineNum">   18545 </span>            :                     if (declarationStatement_original == definingDeclaration_original)</a>
<a name="18546"><span class="lineNum">   18546 </span>            :                        {</a>
<a name="18547"><span class="lineNum">   18547 </span>            :                       // This is a defining declaration, so we can set the scope (or can we?)</a>
<a name="18548"><span class="lineNum">   18548 </span>            :                       // I guess we could if the translation map were complete, but it is not complete yet.</a>
<a name="18549"><span class="lineNum">   18549 </span>            :                        }</a>
<a name="18550"><span class="lineNum">   18550 </span>            :                   }</a>
<a name="18551"><span class="lineNum">   18551 </span>            :                  else</a>
<a name="18552"><span class="lineNum">   18552 </span>            :                   {</a>
<a name="18553"><span class="lineNum">   18553 </span>            :                  // Warn about this if snippetFile == NULL.</a>
<a name="18554"><span class="lineNum">   18554 </span>            :                     if (snippetFile == NULL)</a>
<a name="18555"><span class="lineNum">   18555 </span>            :                        {</a>
<a name="18556"><span class="lineNum">   18556 </span>            :                          printf (&quot;Note: definingDeclaration_original = %p getEnclosingFileNode() returned NULL \n&quot;,definingDeclaration_original);</a>
<a name="18557"><span class="lineNum">   18557 </span>            :                        }</a>
<a name="18558"><span class="lineNum">   18558 </span>            :                   }</a>
<a name="18559"><span class="lineNum">   18559 </span>            :              }</a>
<a name="18560"><span class="lineNum">   18560 </span>            :         }</a>
<a name="18561"><span class="lineNum">   18561 </span>            : </a>
<a name="18562"><span class="lineNum">   18562 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18563"><span class="lineNum">   18563 </span>            : </a>
<a name="18564"><span class="lineNum">   18564 </span>            : #endif</a>
<a name="18565"><span class="lineNum">   18565 </span>            : </a>
<a name="18566"><span class="lineNum">   18566 </span>            :   // Handle what is the same about all expressions before getting to the switch.</a>
<a name="18567"><span class="lineNum">   18567 </span><span class="lineNoCov">          0 :      SgExpression* expression = isSgExpression(node_copy);</span></a>
<a name="18568"><span class="lineNum">   18568 </span><span class="lineNoCov">          0 :      if (expression != NULL)</span></a>
<a name="18569"><span class="lineNum">   18569 </span>            :         {</a>
<a name="18570"><span class="lineNum">   18570 </span>            :        // Check the scope if it is stored explicitly.</a>
<a name="18571"><span class="lineNum">   18571 </span>            : </a>
<a name="18572"><span class="lineNum">   18572 </span>            :        // printf (&quot;WARNING: Need to check if the type is explicitly stored in this expression! \n&quot;);</a>
<a name="18573"><span class="lineNum">   18573 </span>            : </a>
<a name="18574"><span class="lineNum">   18574 </span><span class="lineNoCov">          0 :           if (expression-&gt;hasExplicitType() == true)</span></a>
<a name="18575"><span class="lineNum">   18575 </span>            :              {</a>
<a name="18576"><span class="lineNum">   18576 </span>            :             // Handle the type for all expressions.</a>
<a name="18577"><span class="lineNum">   18577 </span><span class="lineNoCov">          0 :                SgType* type = expression-&gt;get_type();</span></a>
<a name="18578"><span class="lineNum">   18578 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(type != NULL);</span></a>
<a name="18579"><span class="lineNum">   18579 </span>            : </a>
<a name="18580"><span class="lineNum">   18580 </span>            :             // DQ (3/17/2014): Avoid calling stripType with the newly refactored getTargetFileType() function.</a>
<a name="18581"><span class="lineNum">   18581 </span>            :             // SgType* new_type = getTargetFileType(type-&gt;stripType(),targetScope);</a>
<a name="18582"><span class="lineNum">   18582 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(type,targetScope);</span></a>
<a name="18583"><span class="lineNum">   18583 </span><span class="lineNoCov">          0 :                if (new_type != NULL)</span></a>
<a name="18584"><span class="lineNum">   18584 </span>            :                   {</a>
<a name="18585"><span class="lineNum">   18585 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="18586"><span class="lineNum">   18586 </span><span class="lineNoCov">          0 :                     expression-&gt;set_explicitly_stored_type(new_type);</span></a>
<a name="18587"><span class="lineNum">   18587 </span>            :                   }</a>
<a name="18588"><span class="lineNum">   18588 </span>            :              }</a>
<a name="18589"><span class="lineNum">   18589 </span>            :         }</a>
<a name="18590"><span class="lineNum">   18590 </span>            : </a>
<a name="18591"><span class="lineNum">   18591 </span><span class="lineNoCov">          0 :      switch (node_copy-&gt;variantT())</span></a>
<a name="18592"><span class="lineNum">   18592 </span>            :         {</a>
<a name="18593"><span class="lineNum">   18593 </span><span class="lineNoCov">          0 :           case V_SgInitializedName:</span></a>
<a name="18594"><span class="lineNum">   18594 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="18595"><span class="lineNum">   18595 </span><span class="lineNoCov">          0 :                SgInitializedName* initializedName_copy     = isSgInitializedName(node_copy);</span></a>
<a name="18596"><span class="lineNum">   18596 </span><span class="lineNoCov">          0 :                SgInitializedName* initializedName_original = isSgInitializedName(node_original);</span></a>
<a name="18597"><span class="lineNum">   18597 </span>            : </a>
<a name="18598"><span class="lineNum">   18598 </span>            :             // See if the scope might be associated with the snippet file.</a>
<a name="18599"><span class="lineNum">   18599 </span>            : </a>
<a name="18600"><span class="lineNum">   18600 </span>            :             // Since we don't want the scope that is stored in the SgInitializedName we</a>
<a name="18601"><span class="lineNum">   18601 </span>            :             // have to get the associated statement and the scope of that statement.</a>
<a name="18602"><span class="lineNum">   18602 </span>            :             // SgScopeStatement* scope_copy     = initializedName_copy-&gt;get_scope();</a>
<a name="18603"><span class="lineNum">   18603 </span><span class="lineNoCov">          0 :                SgStatement* enclosingStatement_copy = TransformationSupport::getStatement(initializedName_copy);</span></a>
<a name="18604"><span class="lineNum">   18604 </span>            : #if 0</a>
<a name="18605"><span class="lineNum">   18605 </span>            :                printf (&quot;enclosingStatement_copy = %p = %s \n&quot;,enclosingStatement_copy,enclosingStatement_copy-&gt;class_name().c_str());</a>
<a name="18606"><span class="lineNum">   18606 </span>            : #endif</a>
<a name="18607"><span class="lineNum">   18607 </span><span class="lineNoCov">          0 :                SgScopeStatement* scope_copy     = enclosingStatement_copy-&gt;get_scope();</span></a>
<a name="18608"><span class="lineNum">   18608 </span>            : </a>
<a name="18609"><span class="lineNum">   18609 </span><span class="lineNoCov">          0 :                SgScopeStatement* scope_original = initializedName_original-&gt;get_scope();</span></a>
<a name="18610"><span class="lineNum">   18610 </span>            : </a>
<a name="18611"><span class="lineNum">   18611 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope_copy != NULL);</span></a>
<a name="18612"><span class="lineNum">   18612 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope_original != NULL);</span></a>
<a name="18613"><span class="lineNum">   18613 </span>            : </a>
<a name="18614"><span class="lineNum">   18614 </span>            :             // if (TransformationSupport::getFile(scope_original) != targetFile)</a>
<a name="18615"><span class="lineNum">   18615 </span><span class="lineNoCov">          0 :                if (getEnclosingFileNode(scope_original) != targetFile)</span></a>
<a name="18616"><span class="lineNum">   18616 </span>            :                   {</a>
<a name="18617"><span class="lineNum">   18617 </span>            : #if 0</a>
<a name="18618"><span class="lineNum">   18618 </span>            :                     ROSE_ASSERT(initializedName_copy != NULL);</a>
<a name="18619"><span class="lineNum">   18619 </span>            :                     printf (&quot;initializedName_copy = %p = %s \n&quot;,initializedName_copy,initializedName_copy-&gt;get_name().str());</a>
<a name="18620"><span class="lineNum">   18620 </span>            :                     ROSE_ASSERT(initializedName_original != NULL);</a>
<a name="18621"><span class="lineNum">   18621 </span>            :                     printf (&quot;initializedName_original = %p = %s \n&quot;,initializedName_original,initializedName_original-&gt;get_name().str());</a>
<a name="18622"><span class="lineNum">   18622 </span>            :                     SgType* initializedName_original_type = initializedName_original-&gt;get_type();</a>
<a name="18623"><span class="lineNum">   18623 </span>            :                     printf (&quot;initializedName_original_type = %p = %s \n&quot;,initializedName_original_type,initializedName_original_type-&gt;class_name().c_str());</a>
<a name="18624"><span class="lineNum">   18624 </span>            :                     SgClassType* classType = isSgClassType(initializedName_original_type);</a>
<a name="18625"><span class="lineNum">   18625 </span>            :                  // ROSE_ASSERT(classType != NULL);</a>
<a name="18626"><span class="lineNum">   18626 </span>            :                     if (classType != NULL)</a>
<a name="18627"><span class="lineNum">   18627 </span>            :                        {</a>
<a name="18628"><span class="lineNum">   18628 </span>            :                          SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</a>
<a name="18629"><span class="lineNum">   18629 </span>            :                          ROSE_ASSERT(classDeclaration != NULL);</a>
<a name="18630"><span class="lineNum">   18630 </span>            :                          printf (&quot;classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;get_name().str());</a>
<a name="18631"><span class="lineNum">   18631 </span>            :                        }</a>
<a name="18632"><span class="lineNum">   18632 </span>            : #endif</a>
<a name="18633"><span class="lineNum">   18633 </span>            : #if 0</a>
<a name="18634"><span class="lineNum">   18634 </span>            :                     printf (&quot;Warning: case V_SgInitializedName: scope_copy     = %p = %s \n&quot;,scope_copy,scope_copy-&gt;class_name().c_str());</a>
<a name="18635"><span class="lineNum">   18635 </span>            :                     printf (&quot;Warning: case V_SgInitializedName: scope_original = %p = %s \n&quot;,scope_original,scope_original-&gt;class_name().c_str());</a>
<a name="18636"><span class="lineNum">   18636 </span>            : </a>
<a name="18637"><span class="lineNum">   18637 </span>            :                     printf (&quot;Warning: case V_SgInitializedName: initializedName_copy-&gt;get_parent()     = %p \n&quot;,initializedName_copy-&gt;get_parent());</a>
<a name="18638"><span class="lineNum">   18638 </span>            :                     printf (&quot;Warning: case V_SgInitializedName: initializedName_original-&gt;get_parent() = %p \n&quot;,initializedName_original-&gt;get_parent());</a>
<a name="18639"><span class="lineNum">   18639 </span>            : #endif</a>
<a name="18640"><span class="lineNum">   18640 </span>            :                  // SgFile* snippetFile = TransformationSupport::getFile(scope_original);</a>
<a name="18641"><span class="lineNum">   18641 </span><span class="lineNoCov">          0 :                     SgFile* snippetFile = getEnclosingFileNode(scope_original);</span></a>
<a name="18642"><span class="lineNum">   18642 </span>            : </a>
<a name="18643"><span class="lineNum">   18643 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippetFile != NULL);</span></a>
<a name="18644"><span class="lineNum">   18644 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(snippetFile-&gt;get_sourceFileNameWithPath().empty() == false);</span></a>
<a name="18645"><span class="lineNum">   18645 </span>            : #if 0</a>
<a name="18646"><span class="lineNum">   18646 </span>            :                     printf (&quot;Warning: case V_SgInitializedName: scope not in target file (snippetFile = %p = %s) \n&quot;,snippetFile,snippetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="18647"><span class="lineNum">   18647 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="18648"><span class="lineNum">   18648 </span>            : #endif</a>
<a name="18649"><span class="lineNum">   18649 </span>            :                   }</a>
<a name="18650"><span class="lineNum">   18650 </span>            : </a>
<a name="18651"><span class="lineNum">   18651 </span>            :             // See if the type might be asociated with the snippet file.</a>
<a name="18652"><span class="lineNum">   18652 </span><span class="lineNoCov">          0 :                SgType* type_copy     = initializedName_copy-&gt;get_type();</span></a>
<a name="18653"><span class="lineNum">   18653 </span>            : #if 0</a>
<a name="18654"><span class="lineNum">   18654 </span>            :                printf (&quot;(before type_copy-&gt;getInternalTypes()): type_copy = %p = %s \n&quot;,type_copy,type_copy-&gt;class_name().c_str());</a>
<a name="18655"><span class="lineNum">   18655 </span>            : #endif</a>
<a name="18656"><span class="lineNum">   18656 </span>            : </a>
<a name="18657"><span class="lineNum">   18657 </span>            : #if 0</a>
<a name="18658"><span class="lineNum">   18658 </span>            : </a>
<a name="18659"><span class="lineNum">   18659 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18660"><span class="lineNum">   18660 </span>            : </a>
<a name="18661"><span class="lineNum">   18661 </span>            :             // We need to be able to reproduce the pointer types to class types, etc.</a>
<a name="18662"><span class="lineNum">   18662 </span>            :                Rose_STL_Container&lt;SgType*&gt; typeList = type_copy-&gt;getInternalTypes();</a>
<a name="18663"><span class="lineNum">   18663 </span>            : #if 0</a>
<a name="18664"><span class="lineNum">   18664 </span>            :                for (size_t i = 0; i &lt; typeList.size(); i++)</a>
<a name="18665"><span class="lineNum">   18665 </span>            :                   {</a>
<a name="18666"><span class="lineNum">   18666 </span>            :                     printf (&quot;Input type: typeList[i=%&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="18667"><span class="lineNum">   18667 </span>            :                   }</a>
<a name="18668"><span class="lineNum">   18668 </span>            : #endif</a>
<a name="18669"><span class="lineNum">   18669 </span>            :             // Note that the semantics of this function is that it can return a NULL pointer (e.g. for primative types).</a>
<a name="18670"><span class="lineNum">   18670 </span>            :                SgType* new_type = getTargetFileType(type_copy-&gt;stripType(),targetScope);</a>
<a name="18671"><span class="lineNum">   18671 </span>            : </a>
<a name="18672"><span class="lineNum">   18672 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18673"><span class="lineNum">   18673 </span>            : </a>
<a name="18674"><span class="lineNum">   18674 </span>            :             // Now rebuild the type_copy as required to represent associated modifiers, typedef wrappers, pointers and references.</a>
<a name="18675"><span class="lineNum">   18675 </span>            :                if (new_type != NULL &amp;&amp; typeList.size() &gt; 1)</a>
<a name="18676"><span class="lineNum">   18676 </span>            :                   {</a>
<a name="18677"><span class="lineNum">   18677 </span>            :                     int size = (int)typeList.size();</a>
<a name="18678"><span class="lineNum">   18678 </span>            :                     for (int i = size - 2; i &gt;= 0; i--)</a>
<a name="18679"><span class="lineNum">   18679 </span>            :                        {</a>
<a name="18680"><span class="lineNum">   18680 </span>            : #if 0</a>
<a name="18681"><span class="lineNum">   18681 </span>            :                          printf (&quot;Rebuild type: typeList[i=%d] = %p = %s \n&quot;,i,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="18682"><span class="lineNum">   18682 </span>            : #endif</a>
<a name="18683"><span class="lineNum">   18683 </span>            :                       // SgModifierType* SgModifierType::createType(SgType* base_type, unsigned int f, SgExpression* optional_fortran_type_kind )</a>
<a name="18684"><span class="lineNum">   18684 </span>            :                          switch(typeList[i]-&gt;variantT())</a>
<a name="18685"><span class="lineNum">   18685 </span>            :                             {</a>
<a name="18686"><span class="lineNum">   18686 </span>            :                               case V_SgModifierType:</a>
<a name="18687"><span class="lineNum">   18687 </span>            :                                  {</a>
<a name="18688"><span class="lineNum">   18688 </span>            :                                    SgModifierType* modifierType = isSgModifierType(typeList[i]);</a>
<a name="18689"><span class="lineNum">   18689 </span>            :                                    ROSE_ASSERT(modifierType != NULL);</a>
<a name="18690"><span class="lineNum">   18690 </span>            :                                    if (modifierType-&gt;get_typeModifier().get_constVolatileModifier().isConst() == true)</a>
<a name="18691"><span class="lineNum">   18691 </span>            :                                       {</a>
<a name="18692"><span class="lineNum">   18692 </span>            :                                         ROSE_ASSERT(new_type != NULL);</a>
<a name="18693"><span class="lineNum">   18693 </span>            : #if 0</a>
<a name="18694"><span class="lineNum">   18694 </span>            :                                         printf (&quot;Building a SgModifierType: calling buildConstType(): new_type = %p = %s \n&quot;,new_type,new_type-&gt;class_name().c_str());</a>
<a name="18695"><span class="lineNum">   18695 </span>            : #endif</a>
<a name="18696"><span class="lineNum">   18696 </span>            :                                         new_type = buildConstType(new_type);</a>
<a name="18697"><span class="lineNum">   18697 </span>            :                                       }</a>
<a name="18698"><span class="lineNum">   18698 </span>            :                                      else</a>
<a name="18699"><span class="lineNum">   18699 </span>            :                                       {</a>
<a name="18700"><span class="lineNum">   18700 </span>            :                                      // Flag any additional modifiers that we might require (make anything not supported an error).</a>
<a name="18701"><span class="lineNum">   18701 </span>            :                                         printf (&quot;Modifier kind not handled (not implemented) check what sort of modifier this is: \n&quot;);</a>
<a name="18702"><span class="lineNum">   18702 </span>            :                                         modifierType-&gt;get_typeModifier().display(&quot;Modifier kind not handled&quot;);</a>
<a name="18703"><span class="lineNum">   18703 </span>            :                                         ROSE_ABORT();</a>
<a name="18704"><span class="lineNum">   18704 </span>            :                                       }</a>
<a name="18705"><span class="lineNum">   18705 </span>            :                                    break;</a>
<a name="18706"><span class="lineNum">   18706 </span>            :                                  }</a>
<a name="18707"><span class="lineNum">   18707 </span>            : </a>
<a name="18708"><span class="lineNum">   18708 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18709"><span class="lineNum">   18709 </span>            : </a>
<a name="18710"><span class="lineNum">   18710 </span>            :                               case V_SgTypedefType:</a>
<a name="18711"><span class="lineNum">   18711 </span>            :                                  {</a>
<a name="18712"><span class="lineNum">   18712 </span>            :                                    SgTypedefType* typedefType = isSgTypedefType(typeList[i]);</a>
<a name="18713"><span class="lineNum">   18713 </span>            :                                    ROSE_ASSERT(typedefType != NULL);</a>
<a name="18714"><span class="lineNum">   18714 </span>            : </a>
<a name="18715"><span class="lineNum">   18715 </span>            :                                 // SgType* SageBuilder::getTargetFileType(SgType* snippet_type, SgScopeStatement* targetScope)</a>
<a name="18716"><span class="lineNum">   18716 </span>            :                                    SgType* new_typedefType = getTargetFileType(typedefType,targetScope);</a>
<a name="18717"><span class="lineNum">   18717 </span>            :                                    ROSE_ASSERT(new_typedefType != NULL);</a>
<a name="18718"><span class="lineNum">   18718 </span>            :                                    ROSE_ASSERT(isSgTypedefType(new_typedefType) != NULL);</a>
<a name="18719"><span class="lineNum">   18719 </span>            : </a>
<a name="18720"><span class="lineNum">   18720 </span>            :                                    new_type = new_typedefType;</a>
<a name="18721"><span class="lineNum">   18721 </span>            : #if 0</a>
<a name="18722"><span class="lineNum">   18722 </span>            :                                    printf (&quot;ERROSE: SgTypedefType kind not handled (not implemented) \n&quot;);</a>
<a name="18723"><span class="lineNum">   18723 </span>            :                                    ROSE_ABORT();</a>
<a name="18724"><span class="lineNum">   18724 </span>            : #endif</a>
<a name="18725"><span class="lineNum">   18725 </span>            :                                    break;</a>
<a name="18726"><span class="lineNum">   18726 </span>            :                                  }</a>
<a name="18727"><span class="lineNum">   18727 </span>            : </a>
<a name="18728"><span class="lineNum">   18728 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18729"><span class="lineNum">   18729 </span>            : </a>
<a name="18730"><span class="lineNum">   18730 </span>            :                               case V_SgPointerType:</a>
<a name="18731"><span class="lineNum">   18731 </span>            :                                  {</a>
<a name="18732"><span class="lineNum">   18732 </span>            :                                    SgPointerType* pointerType = isSgPointerType(typeList[i]);</a>
<a name="18733"><span class="lineNum">   18733 </span>            :                                    ROSE_ASSERT(pointerType != NULL);</a>
<a name="18734"><span class="lineNum">   18734 </span>            : #if 0</a>
<a name="18735"><span class="lineNum">   18735 </span>            :                                    printf (&quot;Building a SgPointerType: calling buildPointerType(): new_type = %p = %s \n&quot;,new_type,new_type-&gt;class_name().c_str());</a>
<a name="18736"><span class="lineNum">   18736 </span>            : #endif</a>
<a name="18737"><span class="lineNum">   18737 </span>            :                                    ROSE_ASSERT(new_type != NULL);</a>
<a name="18738"><span class="lineNum">   18738 </span>            :                                    new_type = buildPointerType(new_type);</a>
<a name="18739"><span class="lineNum">   18739 </span>            : #if 0</a>
<a name="18740"><span class="lineNum">   18740 </span>            :                                    printf (&quot;ERROSE: SgPointerType kind not handled (not implemented) \n&quot;);</a>
<a name="18741"><span class="lineNum">   18741 </span>            :                                    ROSE_ABORT();</a>
<a name="18742"><span class="lineNum">   18742 </span>            : #endif</a>
<a name="18743"><span class="lineNum">   18743 </span>            :                                    break;</a>
<a name="18744"><span class="lineNum">   18744 </span>            :                                  }</a>
<a name="18745"><span class="lineNum">   18745 </span>            : </a>
<a name="18746"><span class="lineNum">   18746 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18747"><span class="lineNum">   18747 </span>            : </a>
<a name="18748"><span class="lineNum">   18748 </span>            :                               default:</a>
<a name="18749"><span class="lineNum">   18749 </span>            :                                  {</a>
<a name="18750"><span class="lineNum">   18750 </span>            :                                    printf (&quot;Error: default reached in evaluation of typelist: typeList[i] = %p = %s \n&quot;,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="18751"><span class="lineNum">   18751 </span>            :                                    ROSE_ABORT();</a>
<a name="18752"><span class="lineNum">   18752 </span>            :                                  }</a>
<a name="18753"><span class="lineNum">   18753 </span>            :                             }</a>
<a name="18754"><span class="lineNum">   18754 </span>            :                        }</a>
<a name="18755"><span class="lineNum">   18755 </span>            :                   }</a>
<a name="18756"><span class="lineNum">   18756 </span>            : #if 0</a>
<a name="18757"><span class="lineNum">   18757 </span>            :                if (typeList.size() &gt; 1)</a>
<a name="18758"><span class="lineNum">   18758 </span>            :                   {</a>
<a name="18759"><span class="lineNum">   18759 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="18760"><span class="lineNum">   18760 </span>            :                     ROSE_ABORT();</a>
<a name="18761"><span class="lineNum">   18761 </span>            :                   }</a>
<a name="18762"><span class="lineNum">   18762 </span>            : #endif</a>
<a name="18763"><span class="lineNum">   18763 </span>            : </a>
<a name="18764"><span class="lineNum">   18764 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="18765"><span class="lineNum">   18765 </span>            : </a>
<a name="18766"><span class="lineNum">   18766 </span>            : #else</a>
<a name="18767"><span class="lineNum">   18767 </span>            :             // Refactored the above code to be a part of getTargetFileType() function.</a>
<a name="18768"><span class="lineNum">   18768 </span>            :             // Note that the semantics of this function is that it can return a NULL pointer (e.g. for primative types).</a>
<a name="18769"><span class="lineNum">   18769 </span>            :             // SgType* new_type = getTargetFileType(type_copy-&gt;stripType(),targetScope);</a>
<a name="18770"><span class="lineNum">   18770 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(type_copy,targetScope);</span></a>
<a name="18771"><span class="lineNum">   18771 </span>            : #endif</a>
<a name="18772"><span class="lineNum">   18772 </span>            : #if 0</a>
<a name="18773"><span class="lineNum">   18773 </span>            :                printf (&quot;new_type = %p \n&quot;,new_type);</a>
<a name="18774"><span class="lineNum">   18774 </span>            : #endif</a>
<a name="18775"><span class="lineNum">   18775 </span><span class="lineNoCov">          0 :                if (new_type != NULL)</span></a>
<a name="18776"><span class="lineNum">   18776 </span>            :                   {</a>
<a name="18777"><span class="lineNum">   18777 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="18778"><span class="lineNum">   18778 </span>            : #if 0</a>
<a name="18779"><span class="lineNum">   18779 </span>            :                     printf (&quot;Reset type for initializedName_copy = %p from type = %p to type = %p \n&quot;,initializedName_copy,initializedName_copy-&gt;get_type(),new_type);</a>
<a name="18780"><span class="lineNum">   18780 </span>            : #endif</a>
<a name="18781"><span class="lineNum">   18781 </span><span class="lineNoCov">          0 :                     SgType* original_type = initializedName_copy-&gt;get_type();</span></a>
<a name="18782"><span class="lineNum">   18782 </span><span class="lineNoCov">          0 :                     SgNamedType* original_named_type = isSgNamedType(original_type);</span></a>
<a name="18783"><span class="lineNum">   18783 </span><span class="lineNoCov">          0 :                     SgNamedType* new_named_type = isSgNamedType(new_type);</span></a>
<a name="18784"><span class="lineNum">   18784 </span><span class="lineNoCov">          0 :                     if (original_named_type != NULL)</span></a>
<a name="18785"><span class="lineNum">   18785 </span>            :                        {</a>
<a name="18786"><span class="lineNum">   18786 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_named_type != NULL);</span></a>
<a name="18787"><span class="lineNum">   18787 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* original_classDeclaration = isSgClassDeclaration(original_named_type-&gt;get_declaration());</span></a>
<a name="18788"><span class="lineNum">   18788 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* new_classDeclaration      = isSgClassDeclaration(new_named_type-&gt;get_declaration());</span></a>
<a name="18789"><span class="lineNum">   18789 </span><span class="lineNoCov">          0 :                          if (original_classDeclaration != NULL)</span></a>
<a name="18790"><span class="lineNum">   18790 </span>            :                             {</a>
<a name="18791"><span class="lineNum">   18791 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(new_classDeclaration != NULL);</span></a>
<a name="18792"><span class="lineNum">   18792 </span>            : #if 0</a>
<a name="18793"><span class="lineNum">   18793 </span>            :                               printf (&quot;original_classDeclaration = %p = %s \n&quot;,original_classDeclaration,original_classDeclaration-&gt;get_name().str());</a>
<a name="18794"><span class="lineNum">   18794 </span>            :                               printf (&quot;new_classDeclaration      = %p = %s \n&quot;,new_classDeclaration,new_classDeclaration-&gt;get_name().str());</a>
<a name="18795"><span class="lineNum">   18795 </span>            : #endif</a>
<a name="18796"><span class="lineNum">   18796 </span>            :                            // Make sure that the type names are the same.</a>
<a name="18797"><span class="lineNum">   18797 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(new_classDeclaration-&gt;get_name() == original_classDeclaration-&gt;get_name());</span></a>
<a name="18798"><span class="lineNum">   18798 </span>            :                             }</a>
<a name="18799"><span class="lineNum">   18799 </span>            :                        }</a>
<a name="18800"><span class="lineNum">   18800 </span>            : #if 0</a>
<a name="18801"><span class="lineNum">   18801 </span>            :                     SgType* old_type = initializedName_copy-&gt;get_type();</a>
<a name="18802"><span class="lineNum">   18802 </span>            :                     printf (&quot;Reset the type: initializedName_copy-&gt;set_type(new_type): old type = %p = %s new_type = %p = %s \n&quot;,old_type,old_type-&gt;class_name().c_str(),new_type,new_type-&gt;class_name().c_str());</a>
<a name="18803"><span class="lineNum">   18803 </span>            : #endif</a>
<a name="18804"><span class="lineNum">   18804 </span><span class="lineNoCov">          0 :                     initializedName_copy-&gt;set_type(new_type);</span></a>
<a name="18805"><span class="lineNum">   18805 </span>            :                   }</a>
<a name="18806"><span class="lineNum">   18806 </span>            : #if 0</a>
<a name="18807"><span class="lineNum">   18807 </span>            :                printf (&quot;enclosingStatement_copy = %p = %s \n&quot;,enclosingStatement_copy,enclosingStatement_copy-&gt;class_name().c_str());</a>
<a name="18808"><span class="lineNum">   18808 </span>            : #endif</a>
<a name="18809"><span class="lineNum">   18809 </span><span class="lineNoCov">          0 :                SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(enclosingStatement_copy);</span></a>
<a name="18810"><span class="lineNum">   18810 </span><span class="lineNoCov">          0 :                if (functionParameterList != NULL)</span></a>
<a name="18811"><span class="lineNum">   18811 </span>            :                   {</a>
<a name="18812"><span class="lineNum">   18812 </span>            :                  // The use of SgInitializedName in function parametes is handled differently then in other</a>
<a name="18813"><span class="lineNum">   18813 </span>            :                  // locations in the AST (e.g. how the scope is set).</a>
<a name="18814"><span class="lineNum">   18814 </span>            :                  // This is a function parameter and the scope is set to the SgFunctionDefinition if</a>
<a name="18815"><span class="lineNum">   18815 </span>            :                  // this is for a defining function and the SgGlobal if it is a function prototype.</a>
<a name="18816"><span class="lineNum">   18816 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(functionParameterList-&gt;get_parent());</span></a>
<a name="18817"><span class="lineNum">   18817 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="18818"><span class="lineNum">   18818 </span><span class="lineNoCov">          0 :                     SgFunctionDefinition* functionDefinition = functionDeclaration-&gt;get_definition();</span></a>
<a name="18819"><span class="lineNum">   18819 </span><span class="lineNoCov">          0 :                     if (functionDefinition != NULL)</span></a>
<a name="18820"><span class="lineNum">   18820 </span>            :                        {</a>
<a name="18821"><span class="lineNum">   18821 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(initializedName_copy-&gt;get_scope() == functionDefinition);</span></a>
<a name="18822"><span class="lineNum">   18822 </span>            :                       // initializedName_copy-&gt;set_scope(functionDefinition);</a>
<a name="18823"><span class="lineNum">   18823 </span>            :                        }</a>
<a name="18824"><span class="lineNum">   18824 </span>            :                       else</a>
<a name="18825"><span class="lineNum">   18825 </span>            :                        {</a>
<a name="18826"><span class="lineNum">   18826 </span><span class="lineNoCov">          0 :                          SgGlobal* globalScope = isSgGlobal(functionDeclaration-&gt;get_scope());</span></a>
<a name="18827"><span class="lineNum">   18827 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="18828"><span class="lineNum">   18828 </span><span class="lineNoCov">          0 :                          if (initializedName_copy-&gt;get_scope() != globalScope)</span></a>
<a name="18829"><span class="lineNum">   18829 </span>            :                             {</a>
<a name="18830"><span class="lineNum">   18830 </span>            : #if 0</a>
<a name="18831"><span class="lineNum">   18831 </span>            :                               printf (&quot;Reset scope for initializedName_copy = %p = %s \n&quot;,initializedName_copy,initializedName_copy-&gt;get_name().str());</a>
<a name="18832"><span class="lineNum">   18832 </span>            : #endif</a>
<a name="18833"><span class="lineNum">   18833 </span><span class="lineNoCov">          0 :                               initializedName_copy-&gt;set_scope(globalScope);</span></a>
<a name="18834"><span class="lineNum">   18834 </span>            :                             }</a>
<a name="18835"><span class="lineNum">   18835 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(initializedName_copy-&gt;get_scope() == globalScope);</span></a>
<a name="18836"><span class="lineNum">   18836 </span>            :                        }</a>
<a name="18837"><span class="lineNum">   18837 </span>            :                   }</a>
<a name="18838"><span class="lineNum">   18838 </span>            :                  else</a>
<a name="18839"><span class="lineNum">   18839 </span>            :                   {</a>
<a name="18840"><span class="lineNum">   18840 </span>            : #if 0</a>
<a name="18841"><span class="lineNum">   18841 </span>            :                     printf (&quot;initializedName_copy-&gt;get_scope() = %p = %s \n&quot;,initializedName_copy-&gt;get_scope(),initializedName_copy-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="18842"><span class="lineNum">   18842 </span>            : #endif</a>
<a name="18843"><span class="lineNum">   18843 </span><span class="lineNoCov">          0 :                     SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(enclosingStatement_copy);</span></a>
<a name="18844"><span class="lineNum">   18844 </span><span class="lineNoCov">          0 :                     if (enumDeclaration != NULL)</span></a>
<a name="18845"><span class="lineNum">   18845 </span>            :                        {</a>
<a name="18846"><span class="lineNum">   18846 </span>            :                       // The case of enum declarations is special because the associated SgInitializedName IR nodes has a scope</a>
<a name="18847"><span class="lineNum">   18847 </span>            :                       // that is external to the SgEnumDeclaration (in the scope of the SgEnumDeclaration).  The typical case in C</a>
<a name="18848"><span class="lineNum">   18848 </span>            :                       // is that the enum declaration is in global scope and then the enum fields (represented by SgInitializedName</a>
<a name="18849"><span class="lineNum">   18849 </span>            :                       // objects) are have their associated symbol in the global scope.</a>
<a name="18850"><span class="lineNum">   18850 </span>            : </a>
<a name="18851"><span class="lineNum">   18851 </span>            :                       // We have to use the name to search for the symbol instead of the pointer value of the initializedName_copy</a>
<a name="18852"><span class="lineNum">   18852 </span>            :                       // (since the original symbol was associated with initializedName_original).</a>
<a name="18853"><span class="lineNum">   18853 </span>            :                       // SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="18854"><span class="lineNum">   18854 </span><span class="lineNoCov">          0 :                          SgName name = initializedName_copy-&gt;get_name();</span></a>
<a name="18855"><span class="lineNum">   18855 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = initializedName_copy-&gt;get_scope()-&gt;lookup_enum_field_symbol(name);</span></a>
<a name="18856"><span class="lineNum">   18856 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="18857"><span class="lineNum">   18857 </span>            : </a>
<a name="18858"><span class="lineNum">   18858 </span><span class="lineNoCov">          0 :                          SgEnumFieldSymbol* enumFieldSymbol = isSgEnumFieldSymbol(symbol);</span></a>
<a name="18859"><span class="lineNum">   18859 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumFieldSymbol != NULL);</span></a>
<a name="18860"><span class="lineNum">   18860 </span>            : </a>
<a name="18861"><span class="lineNum">   18861 </span>            :                       // DQ (3/17/2014): Build a new sysmbol to for the initializedName_copy instead of reusing the existing symbol</a>
<a name="18862"><span class="lineNum">   18862 </span>            :                       // from the snippet AST.</a>
<a name="18863"><span class="lineNum">   18863 </span><span class="lineNoCov">          0 :                          SgEnumFieldSymbol* new_enumFieldSymbol = new SgEnumFieldSymbol(initializedName_copy);</span></a>
<a name="18864"><span class="lineNum">   18864 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_enumFieldSymbol != NULL);</span></a>
<a name="18865"><span class="lineNum">   18865 </span>            : </a>
<a name="18866"><span class="lineNum">   18866 </span>            :                       // targetScope-&gt;insert_symbol(name,enumFieldSymbol);</a>
<a name="18867"><span class="lineNum">   18867 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(name,new_enumFieldSymbol);</span></a>
<a name="18868"><span class="lineNum">   18868 </span>            : </a>
<a name="18869"><span class="lineNum">   18869 </span>            :                       // DQ (3/6/2014): Set the scope of the SgInitializedName IR node.</a>
<a name="18870"><span class="lineNum">   18870 </span><span class="lineNoCov">          0 :                          initializedName_copy-&gt;set_scope(targetScope);</span></a>
<a name="18871"><span class="lineNum">   18871 </span>            : #if 0</a>
<a name="18872"><span class="lineNum">   18872 </span>            :                          printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="18873"><span class="lineNum">   18873 </span>            :                          ROSE_ABORT();</a>
<a name="18874"><span class="lineNum">   18874 </span>            : #endif</a>
<a name="18875"><span class="lineNum">   18875 </span>            :                        }</a>
<a name="18876"><span class="lineNum">   18876 </span>            :                       else</a>
<a name="18877"><span class="lineNum">   18877 </span>            :                        {</a>
<a name="18878"><span class="lineNum">   18878 </span>            : #if 0</a>
<a name="18879"><span class="lineNum">   18879 </span>            :                          printf (&quot;enclosingStatement_copy = %p = %s \n&quot;,enclosingStatement_copy,enclosingStatement_copy-&gt;class_name().c_str());</a>
<a name="18880"><span class="lineNum">   18880 </span>            : #endif</a>
<a name="18881"><span class="lineNum">   18881 </span><span class="lineNoCov">          0 :                          SgCatchOptionStmt* catchOptionStatement = isSgCatchOptionStmt(enclosingStatement_copy-&gt;get_parent());</span></a>
<a name="18882"><span class="lineNum">   18882 </span><span class="lineNoCov">          0 :                          if (catchOptionStatement != NULL)</span></a>
<a name="18883"><span class="lineNum">   18883 </span>            :                             {</a>
<a name="18884"><span class="lineNum">   18884 </span><span class="lineNoCov">          0 :                               SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(enclosingStatement_copy);</span></a>
<a name="18885"><span class="lineNum">   18885 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="18886"><span class="lineNum">   18886 </span>            : </a>
<a name="18887"><span class="lineNum">   18887 </span>            :                            // SgSymbol* symbol = targetScope-&gt;lookup_variable_symbol(initializedName_copy-&gt;get_name());</a>
<a name="18888"><span class="lineNum">   18888 </span><span class="lineNoCov">          0 :                               SgStatement* enclosingStatement_original = TransformationSupport::getStatement(initializedName_original);</span></a>
<a name="18889"><span class="lineNum">   18889 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(enclosingStatement_original != NULL);</span></a>
<a name="18890"><span class="lineNum">   18890 </span><span class="lineNoCov">          0 :                               SgCatchOptionStmt* catchOptionStatement_original = isSgCatchOptionStmt(enclosingStatement_original-&gt;get_parent());</span></a>
<a name="18891"><span class="lineNum">   18891 </span>            : </a>
<a name="18892"><span class="lineNum">   18892 </span>            :                            // SgSymbol* symbol = lookupVariableSymbolInParentScopes(initializedName_copy-&gt;get_name(),targetScope);</a>
<a name="18893"><span class="lineNum">   18893 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = lookupVariableSymbolInParentScopes(initializedName_copy-&gt;get_name(),catchOptionStatement_original);</span></a>
<a name="18894"><span class="lineNum">   18894 </span><span class="lineNoCov">          0 :                               if (symbol == NULL)</span></a>
<a name="18895"><span class="lineNum">   18895 </span>            :                                  {</a>
<a name="18896"><span class="lineNum">   18896 </span><span class="lineNoCov">          0 :                                    printf (&quot;ERROR: (symbol == NULL): initializedName_copy-&gt;get_name() = %s \n&quot;,initializedName_copy-&gt;get_name().str());</span></a>
<a name="18897"><span class="lineNum">   18897 </span>            :                                 // initializedName_original-&gt;get_file_info()-&gt;display(&quot;ERROR: (symbol == NULL): debug&quot;);</a>
<a name="18898"><span class="lineNum">   18898 </span>            :                                  }</a>
<a name="18899"><span class="lineNum">   18899 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="18900"><span class="lineNum">   18900 </span>            : </a>
<a name="18901"><span class="lineNum">   18901 </span><span class="lineNoCov">          0 :                               initializedName_copy-&gt;set_scope(targetScope);</span></a>
<a name="18902"><span class="lineNum">   18902 </span>            : </a>
<a name="18903"><span class="lineNum">   18903 </span><span class="lineNoCov">          0 :                               SgVariableSymbol* new_variableSymbol = new SgVariableSymbol(initializedName_copy);</span></a>
<a name="18904"><span class="lineNum">   18904 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(new_variableSymbol != NULL);</span></a>
<a name="18905"><span class="lineNum">   18905 </span>            : </a>
<a name="18906"><span class="lineNum">   18906 </span>            :                            // DQ (3/19/2014): I am not certain this is the correct location to insert this symbol.</a>
<a name="18907"><span class="lineNum">   18907 </span><span class="lineNoCov">          0 :                               targetScope-&gt;insert_symbol(initializedName_copy-&gt;get_name(),new_variableSymbol);</span></a>
<a name="18908"><span class="lineNum">   18908 </span>            :                             }</a>
<a name="18909"><span class="lineNum">   18909 </span>            :                            else</a>
<a name="18910"><span class="lineNum">   18910 </span>            :                             {</a>
<a name="18911"><span class="lineNum">   18911 </span>            :                            // Case of non-SgFunctionParameterList and non-SgEnumDeclaration use of SgInitializedName in AST.</a>
<a name="18912"><span class="lineNum">   18912 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = initializedName_copy-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="18913"><span class="lineNum">   18913 </span><span class="lineNoCov">          0 :                               if (symbol == NULL)</span></a>
<a name="18914"><span class="lineNum">   18914 </span>            :                                  {</a>
<a name="18915"><span class="lineNum">   18915 </span><span class="lineNoCov">          0 :                                    printf (&quot;ERROR: enclosingStatement_copy = %p = %s \n&quot;,enclosingStatement_copy,enclosingStatement_copy-&gt;class_name().c_str());</span></a>
<a name="18916"><span class="lineNum">   18916 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(enclosingStatement_copy-&gt;get_parent() != NULL);</span></a>
<a name="18917"><span class="lineNum">   18917 </span><span class="lineNoCov">          0 :                                    printf (&quot;ERROR: enclosingStatement_copy-&gt;get_parent() = %p = %s \n&quot;,enclosingStatement_copy-&gt;get_parent(),enclosingStatement_copy-&gt;get_parent()-&gt;class_name().c_str());</span></a>
<a name="18918"><span class="lineNum">   18918 </span><span class="lineNoCov">          0 :                                    printf (&quot;ERROR: (symbol == NULL): initializedName_copy-&gt;get_name() = %s \n&quot;,initializedName_copy-&gt;get_name().str());</span></a>
<a name="18919"><span class="lineNum">   18919 </span><span class="lineNoCov">          0 :                                    initializedName_original-&gt;get_file_info()-&gt;display(&quot;ERROR: (symbol == NULL): debug&quot;);</span></a>
<a name="18920"><span class="lineNum">   18920 </span>            : </a>
<a name="18921"><span class="lineNum">   18921 </span>            :                                 // DQ (3/30/2014): Add this appraoch to find the symbol.</a>
<a name="18922"><span class="lineNum">   18922 </span><span class="lineNoCov">          0 :                                    SgScopeStatement* initializedName_copy_scope = isSgScopeStatement(initializedName_copy-&gt;get_scope());</span></a>
<a name="18923"><span class="lineNum">   18923 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(initializedName_copy_scope != NULL);</span></a>
<a name="18924"><span class="lineNum">   18924 </span><span class="lineNoCov">          0 :                                    SgVariableSymbol* variableSymbol = initializedName_copy_scope-&gt;lookup_variable_symbol(initializedName_copy-&gt;get_name());</span></a>
<a name="18925"><span class="lineNum">   18925 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="18926"><span class="lineNum">   18926 </span>            : </a>
<a name="18927"><span class="lineNum">   18927 </span><span class="lineNoCov">          0 :                                    symbol = variableSymbol;</span></a>
<a name="18928"><span class="lineNum">   18928 </span>            :                                  }</a>
<a name="18929"><span class="lineNum">   18929 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="18930"><span class="lineNum">   18930 </span>            : </a>
<a name="18931"><span class="lineNum">   18931 </span><span class="lineNoCov">          0 :                               SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="18932"><span class="lineNum">   18932 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="18933"><span class="lineNum">   18933 </span>            : #if 0</a>
<a name="18934"><span class="lineNum">   18934 </span>            :                               printf (&quot;Insert symbol = %p for initializedName_copy = %p = %s into targetScope = %p = %s \n&quot;,variableSymbol,initializedName_copy,initializedName_copy-&gt;get_name().str(),targetScope,targetScope-&gt;class_name().c_str());</a>
<a name="18935"><span class="lineNum">   18935 </span>            : #endif</a>
<a name="18936"><span class="lineNum">   18936 </span>            :                            // DQ (3/17/2014): Build a new sysmbol to for the initializedName_copy instead of reusing the existing symbol</a>
<a name="18937"><span class="lineNum">   18937 </span>            :                            // from the snippet AST.</a>
<a name="18938"><span class="lineNum">   18938 </span><span class="lineNoCov">          0 :                               SgVariableSymbol* new_variableSymbol = new SgVariableSymbol(initializedName_copy);</span></a>
<a name="18939"><span class="lineNum">   18939 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(new_variableSymbol != NULL);</span></a>
<a name="18940"><span class="lineNum">   18940 </span>            : </a>
<a name="18941"><span class="lineNum">   18941 </span>            :                            // targetScope-&gt;insert_symbol(initializedName_copy-&gt;get_name(),variableSymbol);</a>
<a name="18942"><span class="lineNum">   18942 </span><span class="lineNoCov">          0 :                               targetScope-&gt;insert_symbol(initializedName_copy-&gt;get_name(),new_variableSymbol);</span></a>
<a name="18943"><span class="lineNum">   18943 </span>            : </a>
<a name="18944"><span class="lineNum">   18944 </span>            :                            // DQ (3/6/2014): Set the scope of the SgInitializedName IR node.</a>
<a name="18945"><span class="lineNum">   18945 </span><span class="lineNoCov">          0 :                               initializedName_copy-&gt;set_scope(targetScope);</span></a>
<a name="18946"><span class="lineNum">   18946 </span>            : </a>
<a name="18947"><span class="lineNum">   18947 </span><span class="lineNoCov">          0 :                               SgName mangledName = variableSymbol-&gt;get_mangled_name();</span></a>
<a name="18948"><span class="lineNum">   18948 </span>            : #if 0</a>
<a name="18949"><span class="lineNum">   18949 </span>            :                               printf (&quot;initializedName_copy: mangledName = %s \n&quot;,mangledName.str());</a>
<a name="18950"><span class="lineNum">   18950 </span>            : #endif</a>
<a name="18951"><span class="lineNum">   18951 </span>            :                            // DQ (3/2/2014): Make sure this is true (I think it should be, but I don't see that it was explicitly set).</a>
<a name="18952"><span class="lineNum">   18952 </span>            :                            // ROSE_ASSERT(initializedName_copy-&gt;get_scope() == targetScope);</a>
<a name="18953"><span class="lineNum">   18953 </span><span class="lineNoCov">          0 :                               if (initializedName_copy-&gt;get_scope() != targetScope)</span></a>
<a name="18954"><span class="lineNum">   18954 </span>            :                                  {</a>
<a name="18955"><span class="lineNum">   18955 </span><span class="lineNoCov">          0 :                                    printf (&quot;WARNING: initializedName_copy-&gt;get_scope() != targetScope: initializedName_copy-&gt;get_scope() = %p = %s \n&quot;,initializedName_copy-&gt;get_scope(),initializedName_copy-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="18956"><span class="lineNum">   18956 </span>            : </a>
<a name="18957"><span class="lineNum">   18957 </span><span class="lineNoCov">          0 :                                    printf (&quot;I think this should be an error! \n&quot;);</span></a>
<a name="18958"><span class="lineNum">   18958 </span><span class="lineNoCov">          0 :                                    ROSE_ABORT();</span></a>
<a name="18959"><span class="lineNum">   18959 </span>            :                                  }</a>
<a name="18960"><span class="lineNum">   18960 </span>            :                             }</a>
<a name="18961"><span class="lineNum">   18961 </span>            :                        }</a>
<a name="18962"><span class="lineNum">   18962 </span>            :                   }</a>
<a name="18963"><span class="lineNum">   18963 </span>            : </a>
<a name="18964"><span class="lineNum">   18964 </span>            :                break;</a>
<a name="18965"><span class="lineNum">   18965 </span>            :              }</a>
<a name="18966"><span class="lineNum">   18966 </span>            : </a>
<a name="18967"><span class="lineNum">   18967 </span><span class="lineNoCov">          0 :           case V_SgVariableDeclaration:</span></a>
<a name="18968"><span class="lineNum">   18968 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="18969"><span class="lineNum">   18969 </span>            :             // I think there is nothing to handle for this case (there is no type accessbile here</a>
<a name="18970"><span class="lineNum">   18970 </span>            :             // since they are in the SgInitializedName IR nodes).</a>
<a name="18971"><span class="lineNum">   18971 </span><span class="lineNoCov">          0 :                SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(node_copy);</span></a>
<a name="18972"><span class="lineNum">   18972 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="18973"><span class="lineNum">   18973 </span>            : </a>
<a name="18974"><span class="lineNum">   18974 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="18975"><span class="lineNum">   18975 </span>            :              }</a>
<a name="18976"><span class="lineNum">   18976 </span>            : </a>
<a name="18977"><span class="lineNum">   18977 </span>            : #define DEBUG_FUNCTION_DECLARATION 0</a>
<a name="18978"><span class="lineNum">   18978 </span>            : </a>
<a name="18979"><span class="lineNum">   18979 </span><span class="lineNoCov">          0 :           case V_SgFunctionDeclaration:</span></a>
<a name="18980"><span class="lineNum">   18980 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="18981"><span class="lineNum">   18981 </span>            :             // SgFunctionDeclaration is handled directly in the snippet support (insertRelatedThingsForC() function).</a>
<a name="18982"><span class="lineNum">   18982 </span>            : </a>
<a name="18983"><span class="lineNum">   18983 </span>            :             // Note that function types are stored in global type tables so they need not be fixed up.</a>
<a name="18984"><span class="lineNum">   18984 </span>            : </a>
<a name="18985"><span class="lineNum">   18985 </span>            :             // DQ (3/13/2014): As of today, this assumption is no longer true, we need to be able to insert</a>
<a name="18986"><span class="lineNum">   18986 </span>            :             // any function declaration in insertRelatedThingsForC() and use this function to fixup the AST.</a>
<a name="18987"><span class="lineNum">   18987 </span>            :             // The target AST should have a prototype (non-defining declaration) of the function defined</a>
<a name="18988"><span class="lineNum">   18988 </span>            :             // so that all internal types of the SgFunctionType are defined in the target AST.</a>
<a name="18989"><span class="lineNum">   18989 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* functionDeclaration_copy     = isSgFunctionDeclaration(node_copy);</span></a>
<a name="18990"><span class="lineNum">   18990 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* functionDeclaration_original = isSgFunctionDeclaration(node_original);</span></a>
<a name="18991"><span class="lineNum">   18991 </span><span class="lineNoCov">          0 :                SgFunctionType* functionType_copy     = functionDeclaration_copy-&gt;get_type();</span></a>
<a name="18992"><span class="lineNum">   18992 </span><span class="lineNoCov">          0 :                SgFunctionType* functionType_original = functionDeclaration_original-&gt;get_type();</span></a>
<a name="18993"><span class="lineNum">   18993 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionType_copy != NULL);</span></a>
<a name="18994"><span class="lineNum">   18994 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionType_original != NULL);</span></a>
<a name="18995"><span class="lineNum">   18995 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionType_copy == functionType_original);</span></a>
<a name="18996"><span class="lineNum">   18996 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="18997"><span class="lineNum">   18997 </span>            :                printf (&quot;case SgFunctionDeclaration: part 1: Calling functionDeclaration_copy-&gt;search_for_symbol_from_symbol_table() \n&quot;);</a>
<a name="18998"><span class="lineNum">   18998 </span>            : #endif</a>
<a name="18999"><span class="lineNum">   18999 </span>            :             // SgSymbol* symbol_copy = functionDeclaration_copy-&gt;search_for_symbol_from_symbol_table();</a>
<a name="19000"><span class="lineNum">   19000 </span><span class="lineNoCov">          0 :                SgSymbol* symbol_original = functionDeclaration_original-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="19001"><span class="lineNum">   19001 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(symbol_original != NULL);</span></a>
<a name="19002"><span class="lineNum">   19002 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* functionSymbol_original = isSgFunctionSymbol(symbol_original);</span></a>
<a name="19003"><span class="lineNum">   19003 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbol_original != NULL);</span></a>
<a name="19004"><span class="lineNum">   19004 </span>            : </a>
<a name="19005"><span class="lineNum">   19005 </span><span class="lineNoCov">          0 :                SgFile* snippetFile = getEnclosingFileNode(functionSymbol_original);</span></a>
<a name="19006"><span class="lineNum">   19006 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(snippetFile != NULL);</span></a>
<a name="19007"><span class="lineNum">   19007 </span><span class="lineNoCov">          0 :                if (snippetFile != targetFile)</span></a>
<a name="19008"><span class="lineNum">   19008 </span>            :                   {</a>
<a name="19009"><span class="lineNum">   19009 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19010"><span class="lineNum">   19010 </span>            :                     printf (&quot;Warning: case V_SgFunctionDeclaration: functionSymbol_original not in target file \n&quot;);</a>
<a name="19011"><span class="lineNum">   19011 </span>            : #endif</a>
<a name="19012"><span class="lineNum">   19012 </span>            :                  // DQ (3/13/2014): Handle the case of a member function seperately (I think this can't appear in Java, only in C++).</a>
<a name="19013"><span class="lineNum">   19013 </span>            :                  // ROSE_ASSERT(isSgMemberFunctionSymbol(symbol_copy) == NULL);</a>
<a name="19014"><span class="lineNum">   19014 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(isSgMemberFunctionSymbol(symbol_original) == NULL);</span></a>
<a name="19015"><span class="lineNum">   19015 </span>            : </a>
<a name="19016"><span class="lineNum">   19016 </span>            :                  // printf (&quot;case SgFunctionDeclaration: part 2: Calling functionDeclaration_copy-&gt;search_for_symbol_from_symbol_table() \n&quot;);</a>
<a name="19017"><span class="lineNum">   19017 </span>            :                  // SgFunctionSymbol* functionSymbol_copy = isSgFunctionSymbol(functionDeclaration_copy-&gt;search_for_symbol_from_symbol_table());</a>
<a name="19018"><span class="lineNum">   19018 </span>            :                  // ROSE_ASSERT(functionSymbol_copy != NULL);</a>
<a name="19019"><span class="lineNum">   19019 </span>            : </a>
<a name="19020"><span class="lineNum">   19020 </span><span class="lineNoCov">          0 :                     SgName name = functionDeclaration_copy-&gt;get_name();</span></a>
<a name="19021"><span class="lineNum">   19021 </span><span class="lineNoCov">          0 :                     SgType* functionType = functionDeclaration_copy-&gt;get_type();</span></a>
<a name="19022"><span class="lineNum">   19022 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionType != NULL);</span></a>
<a name="19023"><span class="lineNum">   19023 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19024"><span class="lineNum">   19024 </span>            :                     printf (&quot;case V_SgFunctionDeclaration: name                  = %s \n&quot;,name.str());</a>
<a name="19025"><span class="lineNum">   19025 </span>            :                     printf (&quot;case V_SgFunctionDeclaration: functionType          = %p \n&quot;,functionType);</a>
<a name="19026"><span class="lineNum">   19026 </span>            :                     printf (&quot;case V_SgFunctionDeclaration: functionType_original = %p \n&quot;,functionType_original);</a>
<a name="19027"><span class="lineNum">   19027 </span>            :                     printf (&quot;case V_SgFunctionDeclaration: functionType_copy     = %p \n&quot;,functionType_copy);</a>
<a name="19028"><span class="lineNum">   19028 </span>            : #endif</a>
<a name="19029"><span class="lineNum">   19029 </span><span class="lineNoCov">          0 :                     SgFunctionSymbol* functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(name,functionType,targetScope);</span></a>
<a name="19030"><span class="lineNum">   19030 </span>            : </a>
<a name="19031"><span class="lineNum">   19031 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(targetScope != NULL);</span></a>
<a name="19032"><span class="lineNum">   19032 </span><span class="lineNoCov">          0 :                     functionDeclaration_copy-&gt;set_scope(targetScope);</span></a>
<a name="19033"><span class="lineNum">   19033 </span>            : </a>
<a name="19034"><span class="lineNum">   19034 </span>            :                  // Set the scope of the non-defining declaration.</a>
<a name="19035"><span class="lineNum">   19035 </span><span class="lineNoCov">          0 :                     functionDeclaration_copy-&gt;get_firstNondefiningDeclaration()-&gt;set_scope(targetScope);</span></a>
<a name="19036"><span class="lineNum">   19036 </span>            : </a>
<a name="19037"><span class="lineNum">   19037 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration_copy_firstNondefining = NULL;</span></a>
<a name="19038"><span class="lineNum">   19038 </span>            : </a>
<a name="19039"><span class="lineNum">   19039 </span><span class="lineNoCov">          0 :                     if (functionSymbolInTargetAST == NULL)</span></a>
<a name="19040"><span class="lineNum">   19040 </span>            :                        {</a>
<a name="19041"><span class="lineNum">   19041 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19042"><span class="lineNum">   19042 </span>            :                          printf (&quot;functionSymbolInTargetAST not found in targetScope = %p = %s \n&quot;,targetScope,targetScope-&gt;class_name().c_str());</a>
<a name="19043"><span class="lineNum">   19043 </span>            : #endif</a>
<a name="19044"><span class="lineNum">   19044 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19045"><span class="lineNum">   19045 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope = isSgScopeStatement(functionDeclaration_original-&gt;get_parent());</span></a>
<a name="19046"><span class="lineNum">   19046 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope != NULL);</span></a>
<a name="19047"><span class="lineNum">   19047 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19048"><span class="lineNum">   19048 </span>            :                          printf (&quot;case V_SgFunctionDeclaration: otherPossibleScope = %p = %s \n&quot;,otherPossibleScope,otherPossibleScope-&gt;class_name().c_str());</a>
<a name="19049"><span class="lineNum">   19049 </span>            : #endif</a>
<a name="19050"><span class="lineNum">   19050 </span>            :                       // We want to out serch the additional other scope and not it's parent scope.</a>
<a name="19051"><span class="lineNum">   19051 </span>            :                       // functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(name,functionType,otherPossibleScope);</a>
<a name="19052"><span class="lineNum">   19052 </span><span class="lineNoCov">          0 :                          functionSymbolInTargetAST = otherPossibleScope-&gt;lookup_function_symbol(name,functionType);</span></a>
<a name="19053"><span class="lineNum">   19053 </span>            : </a>
<a name="19054"><span class="lineNum">   19054 </span><span class="lineNoCov">          0 :                          if (functionSymbolInTargetAST == NULL)</span></a>
<a name="19055"><span class="lineNum">   19055 </span>            :                             {</a>
<a name="19056"><span class="lineNum">   19056 </span><span class="lineNoCov">          0 :                               printf (&quot;function symbol not found in otherPossibleScope = %p = %s \n&quot;,otherPossibleScope,otherPossibleScope-&gt;class_name().c_str());</span></a>
<a name="19057"><span class="lineNum">   19057 </span>            :                             }</a>
<a name="19058"><span class="lineNum">   19058 </span>            : </a>
<a name="19059"><span class="lineNum">   19059 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="19060"><span class="lineNum">   19060 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19061"><span class="lineNum">   19061 </span>            :                          printf (&quot;(building a new SgFunctionSymbol): functionSymbolInTargetAST-&gt;get_declaration() = %p \n&quot;,functionSymbolInTargetAST-&gt;get_declaration());</a>
<a name="19062"><span class="lineNum">   19062 </span>            : #endif</a>
<a name="19063"><span class="lineNum">   19063 </span>            :                       // DQ (3/15/2014): We need to insert a new symbol into the targetScope instead of reusing</a>
<a name="19064"><span class="lineNum">   19064 </span>            :                       // the existing symbol (because it points to the declaration in the snippet file).</a>
<a name="19065"><span class="lineNum">   19065 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19066"><span class="lineNum">   19066 </span>            :                       // targetScope-&gt;insert_symbol(name,functionSymbolInTargetAST);</a>
<a name="19067"><span class="lineNum">   19067 </span><span class="lineNoCov">          0 :                          functionDeclaration_copy_firstNondefining     = isSgFunctionDeclaration(functionDeclaration_copy-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19068"><span class="lineNum">   19068 </span><span class="lineNoCov">          0 :                          SgFunctionSymbol* new_symbol = new SgFunctionSymbol(functionDeclaration_copy_firstNondefining);</span></a>
<a name="19069"><span class="lineNum">   19069 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_symbol != NULL);</span></a>
<a name="19070"><span class="lineNum">   19070 </span>            : </a>
<a name="19071"><span class="lineNum">   19071 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(name,new_symbol);</span></a>
<a name="19072"><span class="lineNum">   19072 </span>            : </a>
<a name="19073"><span class="lineNum">   19073 </span><span class="lineNoCov">          0 :                          functionSymbolInTargetAST = new_symbol;</span></a>
<a name="19074"><span class="lineNum">   19074 </span>            : </a>
<a name="19075"><span class="lineNum">   19075 </span>            :                       // DQ (3/26/2014): Added assertion.</a>
<a name="19076"><span class="lineNum">   19076 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(lookupFunctionSymbolInParentScopes(name,functionType,targetScope) != NULL);</span></a>
<a name="19077"><span class="lineNum">   19077 </span>            :                        }</a>
<a name="19078"><span class="lineNum">   19078 </span>            :                       else</a>
<a name="19079"><span class="lineNum">   19079 </span>            :                        {</a>
<a name="19080"><span class="lineNum">   19080 </span>            :                       // If we happend to find an associated symbol in the target scope then we nave to use it and</a>
<a name="19081"><span class="lineNum">   19081 </span>            :                       // set the first nondefining declaration pointer to the symbol's associate declaration.</a>
<a name="19082"><span class="lineNum">   19082 </span>            :                       // This is the case of the test3a test code (because the snippet functions declaration is</a>
<a name="19083"><span class="lineNum">   19083 </span>            :                       // in the target AST file (likely a mistake, but we should handle it properly).</a>
<a name="19084"><span class="lineNum">   19084 </span>            : #if DEBUG_FUNCTION_DECLARATION</a>
<a name="19085"><span class="lineNum">   19085 </span>            :                          printf (&quot;(using existing symbol found in target scope): functionSymbolInTargetAST-&gt;get_declaration() = %p \n&quot;,functionSymbolInTargetAST-&gt;get_declaration());</a>
<a name="19086"><span class="lineNum">   19086 </span>            : #endif</a>
<a name="19087"><span class="lineNum">   19087 </span><span class="lineNoCov">          0 :                          functionDeclaration_copy_firstNondefining = isSgFunctionDeclaration(functionSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="19088"><span class="lineNum">   19088 </span>            :                        }</a>
<a name="19089"><span class="lineNum">   19089 </span>            : </a>
<a name="19090"><span class="lineNum">   19090 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="19091"><span class="lineNum">   19091 </span>            : </a>
<a name="19092"><span class="lineNum">   19092 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration_copy-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19093"><span class="lineNum">   19093 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration_copy_firstNondefining != NULL);</span></a>
<a name="19094"><span class="lineNum">   19094 </span>            : </a>
<a name="19095"><span class="lineNum">   19095 </span>            :                  // SgFunctionDeclaration* functionDeclaration_copy_firstNondefining     = isSgFunctionDeclaration(functionDeclaration_copy-&gt;get_firstNondefiningDeclaration());</a>
<a name="19096"><span class="lineNum">   19096 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration_original_firstNondefining = isSgFunctionDeclaration(functionDeclaration_original-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19097"><span class="lineNum">   19097 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration_copy_defining     = isSgFunctionDeclaration(functionDeclaration_copy-&gt;get_definingDeclaration());</span></a>
<a name="19098"><span class="lineNum">   19098 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration_original_defining = isSgFunctionDeclaration(functionDeclaration_original-&gt;get_definingDeclaration());</span></a>
<a name="19099"><span class="lineNum">   19099 </span><span class="lineNoCov">          0 :                     if (functionDeclaration_copy_firstNondefining-&gt;get_symbol_from_symbol_table() == NULL)</span></a>
<a name="19100"><span class="lineNum">   19100 </span>            :                        {</a>
<a name="19101"><span class="lineNum">   19101 </span>            :                       // Check what might be wrong here!</a>
<a name="19102"><span class="lineNum">   19102 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionDeclaration_original_firstNondefining != NULL);</span></a>
<a name="19103"><span class="lineNum">   19103 </span><span class="lineNoCov">          0 :                          printf (&quot;functionSymbolInTargetAST-&gt;get_declaration()  = %p \n&quot;,functionSymbolInTargetAST-&gt;get_declaration());</span></a>
<a name="19104"><span class="lineNum">   19104 </span>            : </a>
<a name="19105"><span class="lineNum">   19105 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original = %p = %s \n&quot;,functionDeclaration_original,functionDeclaration_original-&gt;class_name().c_str());</span></a>
<a name="19106"><span class="lineNum">   19106 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy     = %p = %s \n&quot;,functionDeclaration_copy,functionDeclaration_copy-&gt;class_name().c_str());</span></a>
<a name="19107"><span class="lineNum">   19107 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original_firstNondefining = %p \n&quot;,functionDeclaration_original_firstNondefining);</span></a>
<a name="19108"><span class="lineNum">   19108 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy_firstNondefining     = %p \n&quot;,functionDeclaration_copy_firstNondefining);</span></a>
<a name="19109"><span class="lineNum">   19109 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original_defining         = %p \n&quot;,functionDeclaration_original_defining);</span></a>
<a name="19110"><span class="lineNum">   19110 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy_defining             = %p \n&quot;,functionDeclaration_copy_defining);</span></a>
<a name="19111"><span class="lineNum">   19111 </span>            : </a>
<a name="19112"><span class="lineNum">   19112 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original-&gt;get_scope()                  = %p = %s \n&quot;,functionDeclaration_original-&gt;get_scope(),functionDeclaration_original-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19113"><span class="lineNum">   19113 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy-&gt;get_scope()                      = %p = %s \n&quot;,functionDeclaration_copy-&gt;get_scope(),functionDeclaration_copy-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19114"><span class="lineNum">   19114 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original_firstNondefining-&gt;get_scope() = %p = %s \n&quot;,functionDeclaration_original_firstNondefining-&gt;get_scope(),functionDeclaration_original_firstNondefining-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19115"><span class="lineNum">   19115 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy_firstNondefining-&gt;get_scope()     = %p = %s \n&quot;,functionDeclaration_copy_firstNondefining-&gt;get_scope(),functionDeclaration_copy_firstNondefining-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19116"><span class="lineNum">   19116 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_original_defining-&gt;get_scope()         = %p = %s \n&quot;,functionDeclaration_original_defining-&gt;get_scope(),functionDeclaration_original_defining-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19117"><span class="lineNum">   19117 </span><span class="lineNoCov">          0 :                          printf (&quot;functionDeclaration_copy_defining-&gt;get_scope()             = %p = %s \n&quot;,functionDeclaration_copy_defining-&gt;get_scope(),functionDeclaration_copy_defining-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="19118"><span class="lineNum">   19118 </span><span class="lineNoCov">          0 :                          printf (&quot;functionSymbolInTargetAST = %p = %s \n&quot;,functionSymbolInTargetAST,functionSymbolInTargetAST-&gt;class_name().c_str());</span></a>
<a name="19119"><span class="lineNum">   19119 </span>            :                        }</a>
<a name="19120"><span class="lineNum">   19120 </span>            : </a>
<a name="19121"><span class="lineNum">   19121 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(targetScope-&gt;lookup_function_symbol(name,functionType) != NULL);</span></a>
<a name="19122"><span class="lineNum">   19122 </span>            : </a>
<a name="19123"><span class="lineNum">   19123 </span>            :                  // TV (10/22/2014): Might not be the case as we now have a project wide global scope</a>
<a name="19124"><span class="lineNum">   19124 </span>            :                  // ROSE_ASSERT(functionDeclaration_copy_firstNondefining-&gt;get_scope() == targetScope);</a>
<a name="19125"><span class="lineNum">   19125 </span>            : </a>
<a name="19126"><span class="lineNum">   19126 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration_copy_firstNondefining == functionDeclaration_copy_firstNondefining-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19127"><span class="lineNum">   19127 </span>            : </a>
<a name="19128"><span class="lineNum">   19128 </span>            :                  // This is what is called internal to the get_symbol_from_symbol_table() function below.</a>
<a name="19129"><span class="lineNum">   19129 </span>            :                  // Use this function, SgFunctionDeclaration::get_symbol_from_symbol_table(), but not the template function: find_symbol_from_declaration().</a>
<a name="19130"><span class="lineNum">   19130 </span>            :                  // ROSE_ASSERT(targetScope-&gt;find_symbol_from_declaration(functionDeclaration_copy_firstNondefining) != NULL);</a>
<a name="19131"><span class="lineNum">   19131 </span>            : </a>
<a name="19132"><span class="lineNum">   19132 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionDeclaration_copy_firstNondefining-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="19133"><span class="lineNum">   19133 </span>            : </a>
<a name="19134"><span class="lineNum">   19134 </span>            : #if 0</a>
<a name="19135"><span class="lineNum">   19135 </span>            :                     bool isDefiningDeclaration (functionDeclaration_original-&gt;get_declaration() != NULL);</a>
<a name="19136"><span class="lineNum">   19136 </span>            :                     if (isDefiningDeclaration == true)</a>
<a name="19137"><span class="lineNum">   19137 </span>            :                        {</a>
<a name="19138"><span class="lineNum">   19138 </span>            :                       // We may have to build a non-defining declaration.</a>
<a name="19139"><span class="lineNum">   19139 </span>            :                          SgFunctionDeclaration* nondefiningFunctionDeclaration_original = functionDeclaration_original-&gt;get_firstNondefiningDeclaration();</a>
<a name="19140"><span class="lineNum">   19140 </span>            :                          SgFile* nondefiningDeclarationFile = getEnclosingFileNode(functionSymbol_original);</a>
<a name="19141"><span class="lineNum">   19141 </span>            :                          ROSE_ASSERT(nondefiningDeclarationFile != NULL);</a>
<a name="19142"><span class="lineNum">   19142 </span>            :                          if (nondefiningDeclarationFile == targetFile)</a>
<a name="19143"><span class="lineNum">   19143 </span>            :                             {</a>
<a name="19144"><span class="lineNum">   19144 </span>            :                            // Use this nondefining declaration.</a>
<a name="19145"><span class="lineNum">   19145 </span>            :                             }</a>
<a name="19146"><span class="lineNum">   19146 </span>            :                            else</a>
<a name="19147"><span class="lineNum">   19147 </span>            :                             {</a>
<a name="19148"><span class="lineNum">   19148 </span>            :                            // Make a copy of the non-defining declaration for use in the symbol.</a>
<a name="19149"><span class="lineNum">   19149 </span>            :                             }</a>
<a name="19150"><span class="lineNum">   19150 </span>            : </a>
<a name="19151"><span class="lineNum">   19151 </span>            :                        }</a>
<a name="19152"><span class="lineNum">   19152 </span>            :                       else</a>
<a name="19153"><span class="lineNum">   19153 </span>            :                        {</a>
<a name="19154"><span class="lineNum">   19154 </span>            :                       // Use this as non-defining declaration.</a>
<a name="19155"><span class="lineNum">   19155 </span>            :                        }</a>
<a name="19156"><span class="lineNum">   19156 </span>            : </a>
<a name="19157"><span class="lineNum">   19157 </span>            :                     SgFile* snippetFile = getEnclosingFileNode(functionSymbol_original);</a>
<a name="19158"><span class="lineNum">   19158 </span>            :                     SgFunctionSymbol* new_function_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(func));</a>
<a name="19159"><span class="lineNum">   19159 </span>            :                          ROSE_ASSERT(func_symbol-&gt;get_symbol_basis() != NULL);</a>
<a name="19160"><span class="lineNum">   19160 </span>            :                     targetScope-&gt;insert_symbol(name,symbol_original);</a>
<a name="19161"><span class="lineNum">   19161 </span>            : </a>
<a name="19162"><span class="lineNum">   19162 </span>            :                     ROSE_ABORT();</a>
<a name="19163"><span class="lineNum">   19163 </span>            : #endif</a>
<a name="19164"><span class="lineNum">   19164 </span>            :                   }</a>
<a name="19165"><span class="lineNum">   19165 </span>            : </a>
<a name="19166"><span class="lineNum">   19166 </span>            :             // DQ (3/17/2014): Refactored code to support resetting the scopes in the SgDeclarationStatement IR nodes.</a>
<a name="19167"><span class="lineNum">   19167 </span><span class="lineNoCov">          0 :                resetDeclaration(functionDeclaration_copy,functionDeclaration_original,targetScope);</span></a>
<a name="19168"><span class="lineNum">   19168 </span>            : #if 0</a>
<a name="19169"><span class="lineNum">   19169 </span>            :                printf (&quot;SageBuilder::fixupCopyOfNodeFromSeperateFileInNewTargetAst(): Need to be able to fixup the SgFunctionDeclaration \n&quot;);</a>
<a name="19170"><span class="lineNum">   19170 </span>            :                ROSE_ABORT();</a>
<a name="19171"><span class="lineNum">   19171 </span>            : #endif</a>
<a name="19172"><span class="lineNum">   19172 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="19173"><span class="lineNum">   19173 </span>            :              }</a>
<a name="19174"><span class="lineNum">   19174 </span>            : </a>
<a name="19175"><span class="lineNum">   19175 </span><span class="lineNoCov">          0 :           case V_SgClassDeclaration:</span></a>
<a name="19176"><span class="lineNum">   19176 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19177"><span class="lineNum">   19177 </span>            :             // Need to handle the referenced types</a>
<a name="19178"><span class="lineNum">   19178 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration_copy     = isSgClassDeclaration(node_copy);</span></a>
<a name="19179"><span class="lineNum">   19179 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration_original = isSgClassDeclaration(node_original);</span></a>
<a name="19180"><span class="lineNum">   19180 </span><span class="lineNoCov">          0 :                SgClassType*        classType                 = classDeclaration_copy-&gt;get_type();</span></a>
<a name="19181"><span class="lineNum">   19181 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classType != NULL);</span></a>
<a name="19182"><span class="lineNum">   19182 </span>            : #if 0</a>
<a name="19183"><span class="lineNum">   19183 </span>            :                printf (&quot;Need to handle named types from class declarations \n&quot;);</a>
<a name="19184"><span class="lineNum">   19184 </span>            : #endif</a>
<a name="19185"><span class="lineNum">   19185 </span>            :             // SgClassSymbol* classSymbol_copy = isSgClassSymbol(classDeclaration_copy-&gt;search_for_symbol_from_symbol_table());</a>
<a name="19186"><span class="lineNum">   19186 </span>            :             // ROSE_ASSERT(classSymbol_copy != NULL);</a>
<a name="19187"><span class="lineNum">   19187 </span>            : </a>
<a name="19188"><span class="lineNum">   19188 </span>            :             // if (TransformationSupport::getFile(classSymbol_copy) != targetFile)</a>
<a name="19189"><span class="lineNum">   19189 </span>            :             // if (getEnclosingFileNode(classSymbol_copy) != targetFile)</a>
<a name="19190"><span class="lineNum">   19190 </span>            :             // if (getEnclosingFileNode(classDeclaration_copy) != targetFile)</a>
<a name="19191"><span class="lineNum">   19191 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="19192"><span class="lineNum">   19192 </span>            :                  // printf (&quot;Warning: case V_SgClassDeclaration: classSymbol_copy not in target file \n&quot;);</a>
<a name="19193"><span class="lineNum">   19193 </span>            : #if 0</a>
<a name="19194"><span class="lineNum">   19194 </span>            :                     printf (&quot;Warning: case V_SgClassDeclaration: assume getEnclosingFileNode(classDeclaration_copy) != targetFile \n&quot;);</a>
<a name="19195"><span class="lineNum">   19195 </span>            : #endif</a>
<a name="19196"><span class="lineNum">   19196 </span>            :                  // Find the symbol in the target scope.</a>
<a name="19197"><span class="lineNum">   19197 </span>            :                  // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</a>
<a name="19198"><span class="lineNum">   19198 </span>            : #if 0</a>
<a name="19199"><span class="lineNum">   19199 </span>            :                  // printf (&quot;insertionPointIsScope = %s insertionPointScope = %p = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="19200"><span class="lineNum">   19200 </span>            : #endif</a>
<a name="19201"><span class="lineNum">   19201 </span>            :                  // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).</a>
<a name="19202"><span class="lineNum">   19202 </span>            : </a>
<a name="19203"><span class="lineNum">   19203 </span>            :                  // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</a>
<a name="19204"><span class="lineNum">   19204 </span>            :                  // ROSE_ASSERT(targetScope != NULL);</a>
<a name="19205"><span class="lineNum">   19205 </span>            : </a>
<a name="19206"><span class="lineNum">   19206 </span><span class="lineNoCov">          0 :                     SgName name = classDeclaration_copy-&gt;get_name();</span></a>
<a name="19207"><span class="lineNum">   19207 </span>            : #if 0</a>
<a name="19208"><span class="lineNum">   19208 </span>            :                  // If we randomize the names then we need to handle this case...</a>
<a name="19209"><span class="lineNum">   19209 </span>            :                     printf (&quot;case V_SgClassDeclaration: targetScope = %p classSymbol_copy-&gt;get_name() = %s \n&quot;,targetScope,classSymbol_copy-&gt;get_name().str());</a>
<a name="19210"><span class="lineNum">   19210 </span>            : #endif</a>
<a name="19211"><span class="lineNum">   19211 </span>            :                  // SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(classSymbol_copy-&gt;get_name(),targetScope);</a>
<a name="19212"><span class="lineNum">   19212 </span><span class="lineNoCov">          0 :                     SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(name,targetScope);</span></a>
<a name="19213"><span class="lineNum">   19213 </span>            : </a>
<a name="19214"><span class="lineNum">   19214 </span><span class="lineNoCov">          0 :                     if (classSymbolInTargetAST == NULL)</span></a>
<a name="19215"><span class="lineNum">   19215 </span>            :                        {</a>
<a name="19216"><span class="lineNum">   19216 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19217"><span class="lineNum">   19217 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope = isSgScopeStatement(classDeclaration_original-&gt;get_parent());</span></a>
<a name="19218"><span class="lineNum">   19218 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope != NULL);</span></a>
<a name="19219"><span class="lineNum">   19219 </span>            : #if 0</a>
<a name="19220"><span class="lineNum">   19220 </span>            :                          printf (&quot;case V_SgClassDeclaration: otherPossibleScope = %p \n&quot;,otherPossibleScope);</a>
<a name="19221"><span class="lineNum">   19221 </span>            : #endif</a>
<a name="19222"><span class="lineNum">   19222 </span>            :                       // classSymbolInTargetAST = lookupClassSymbolInParentScopes(classSymbol_copy-&gt;get_name(),otherPossibleScope);</a>
<a name="19223"><span class="lineNum">   19223 </span><span class="lineNoCov">          0 :                          classSymbolInTargetAST = lookupClassSymbolInParentScopes(name,otherPossibleScope);</span></a>
<a name="19224"><span class="lineNum">   19224 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classSymbolInTargetAST != NULL);</span></a>
<a name="19225"><span class="lineNum">   19225 </span>            : #if 0</a>
<a name="19226"><span class="lineNum">   19226 </span>            :                       // I think this is the wrong code.</a>
<a name="19227"><span class="lineNum">   19227 </span>            :                          SgClassDeclaration* classDeclaration = classSymbolInTargetAST-&gt;get_declaration();</a>
<a name="19228"><span class="lineNum">   19228 </span>            :                          ROSE_ASSERT(classDeclaration != NULL);</a>
<a name="19229"><span class="lineNum">   19229 </span>            :                          SgScopeStatement* scope = classDeclaration-&gt;get_scope();</a>
<a name="19230"><span class="lineNum">   19230 </span>            :                          ROSE_ASSERT(scope != NULL);</a>
<a name="19231"><span class="lineNum">   19231 </span>            :                          classDeclaration_copy-&gt;set_scope(scope);</a>
<a name="19232"><span class="lineNum">   19232 </span>            : #else</a>
<a name="19233"><span class="lineNum">   19233 </span>            :                       // DQ (3/17/2014): The scope must be set to be the targetScope (at least for C, but maybe not C++).</a>
<a name="19234"><span class="lineNum">   19234 </span><span class="lineNoCov">          0 :                          classDeclaration_copy-&gt;set_scope(targetScope);</span></a>
<a name="19235"><span class="lineNum">   19235 </span>            : #endif</a>
<a name="19236"><span class="lineNum">   19236 </span>            :                       // DQ (3/17/2014): Build a new SgClassSymbol using the classDeclaration_copy.</a>
<a name="19237"><span class="lineNum">   19237 </span><span class="lineNoCov">          0 :                          SgClassSymbol* classSymbol = new SgClassSymbol(classDeclaration_copy);</span></a>
<a name="19238"><span class="lineNum">   19238 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="19239"><span class="lineNum">   19239 </span><span class="lineNoCov">          0 :                          classSymbolInTargetAST = classSymbol;</span></a>
<a name="19240"><span class="lineNum">   19240 </span>            : </a>
<a name="19241"><span class="lineNum">   19241 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19242"><span class="lineNum">   19242 </span>            :                       // targetScope-&gt;insert_symbol(classSymbol_copy-&gt;get_name(),classSymbolInTargetAST);</a>
<a name="19243"><span class="lineNum">   19243 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(name,classSymbolInTargetAST);</span></a>
<a name="19244"><span class="lineNum">   19244 </span>            :                        }</a>
<a name="19245"><span class="lineNum">   19245 </span>            :                       else</a>
<a name="19246"><span class="lineNum">   19246 </span>            :                        {</a>
<a name="19247"><span class="lineNum">   19247 </span>            :                       // In this case the symbol is in a parent scope already (find the scope and set the scope of the classDeclaration_copy.</a>
<a name="19248"><span class="lineNum">   19248 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* classDeclaration = classSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19249"><span class="lineNum">   19249 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="19250"><span class="lineNum">   19250 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = classDeclaration-&gt;get_scope();</span></a>
<a name="19251"><span class="lineNum">   19251 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="19252"><span class="lineNum">   19252 </span><span class="lineNoCov">          0 :                          classDeclaration_copy-&gt;set_scope(scope);</span></a>
<a name="19253"><span class="lineNum">   19253 </span>            :                        }</a>
<a name="19254"><span class="lineNum">   19254 </span>            : </a>
<a name="19255"><span class="lineNum">   19255 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(classSymbolInTargetAST != NULL);</span></a>
<a name="19256"><span class="lineNum">   19256 </span>            :                   }</a>
<a name="19257"><span class="lineNum">   19257 </span>            : </a>
<a name="19258"><span class="lineNum">   19258 </span>            :             // DQ (3/17/2014): Avoid calling strip type now that we have refactored the getTargetFileType() function.</a>
<a name="19259"><span class="lineNum">   19259 </span>            :             // DQ (3/10/2014): Added remaining type for this case.</a>
<a name="19260"><span class="lineNum">   19260 </span>            :             // SgType* new_type = getTargetFileType(classType-&gt;stripType(),targetScope);</a>
<a name="19261"><span class="lineNum">   19261 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(classType,targetScope);</span></a>
<a name="19262"><span class="lineNum">   19262 </span><span class="lineNoCov">          0 :                SgClassType* new_class_type = isSgClassType(new_type);</span></a>
<a name="19263"><span class="lineNum">   19263 </span><span class="lineNoCov">          0 :                if (new_class_type != NULL)</span></a>
<a name="19264"><span class="lineNum">   19264 </span>            :                   {</a>
<a name="19265"><span class="lineNum">   19265 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="19266"><span class="lineNum">   19266 </span><span class="lineNoCov">          0 :                     classDeclaration_copy-&gt;set_type(new_class_type);</span></a>
<a name="19267"><span class="lineNum">   19267 </span>            : #if 0</a>
<a name="19268"><span class="lineNum">   19268 </span>            :                     printf (&quot;case V_SgClassDeclaration: built class type: part 1: classDeclaration_copy-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="19269"><span class="lineNum">   19269 </span>            :                          classDeclaration_copy-&gt;get_type(),classDeclaration_copy-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="19270"><span class="lineNum">   19270 </span>            : #endif</a>
<a name="19271"><span class="lineNum">   19271 </span>            :                   }</a>
<a name="19272"><span class="lineNum">   19272 </span>            : </a>
<a name="19273"><span class="lineNum">   19273 </span><span class="lineNoCov">          0 :                resetDeclaration(classDeclaration_copy,classDeclaration_original,targetScope);</span></a>
<a name="19274"><span class="lineNum">   19274 </span>            : #if 0</a>
<a name="19275"><span class="lineNum">   19275 </span>            :                printf (&quot;SgClassDeclaration: Exiting as a test! \n&quot;);</a>
<a name="19276"><span class="lineNum">   19276 </span>            :                ROSE_ABORT();</a>
<a name="19277"><span class="lineNum">   19277 </span>            : #endif</a>
<a name="19278"><span class="lineNum">   19278 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="19279"><span class="lineNum">   19279 </span>            :              }</a>
<a name="19280"><span class="lineNum">   19280 </span>            : </a>
<a name="19281"><span class="lineNum">   19281 </span><span class="lineNoCov">          0 :           case V_SgEnumDeclaration:</span></a>
<a name="19282"><span class="lineNum">   19282 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19283"><span class="lineNum">   19283 </span>            :             // Need to handle the referenced types</a>
<a name="19284"><span class="lineNum">   19284 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* enumDeclaration_copy     = isSgEnumDeclaration(node_copy);</span></a>
<a name="19285"><span class="lineNum">   19285 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* enumDeclaration_original = isSgEnumDeclaration(node_original);</span></a>
<a name="19286"><span class="lineNum">   19286 </span>            : </a>
<a name="19287"><span class="lineNum">   19287 </span>            :             // SgEnumType* enumType = enumDeclaration_copy-&gt;get_type();</a>
<a name="19288"><span class="lineNum">   19288 </span>            :             // ROSE_ASSERT(enumType != NULL);</a>
<a name="19289"><span class="lineNum">   19289 </span>            : </a>
<a name="19290"><span class="lineNum">   19290 </span>            :             // I don't think we have to test for this being a part of the snippet file.</a>
<a name="19291"><span class="lineNum">   19291 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="19292"><span class="lineNum">   19292 </span><span class="lineNoCov">          0 :                     SgName name = enumDeclaration_copy-&gt;get_name();</span></a>
<a name="19293"><span class="lineNum">   19293 </span>            : #if 0</a>
<a name="19294"><span class="lineNum">   19294 </span>            :                  // If we randomize the names then we need to handle this case...</a>
<a name="19295"><span class="lineNum">   19295 </span>            :                     printf (&quot;case V_SgEnumDeclaration: targetScope = %p enumSymbol_copy-&gt;get_name() = %s \n&quot;,targetScope,name.str());</a>
<a name="19296"><span class="lineNum">   19296 </span>            : #endif</a>
<a name="19297"><span class="lineNum">   19297 </span><span class="lineNoCov">          0 :                     SgEnumSymbol* enumSymbolInTargetAST = lookupEnumSymbolInParentScopes(name,targetScope);</span></a>
<a name="19298"><span class="lineNum">   19298 </span>            : </a>
<a name="19299"><span class="lineNum">   19299 </span><span class="lineNoCov">          0 :                     if (enumSymbolInTargetAST == NULL)</span></a>
<a name="19300"><span class="lineNum">   19300 </span>            :                        {</a>
<a name="19301"><span class="lineNum">   19301 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19302"><span class="lineNum">   19302 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope = isSgScopeStatement(enumDeclaration_original-&gt;get_parent());</span></a>
<a name="19303"><span class="lineNum">   19303 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope != NULL);</span></a>
<a name="19304"><span class="lineNum">   19304 </span>            : #if 0</a>
<a name="19305"><span class="lineNum">   19305 </span>            :                          printf (&quot;case V_SgEnumDeclaration: otherPossibleScope = %p \n&quot;,otherPossibleScope);</a>
<a name="19306"><span class="lineNum">   19306 </span>            : #endif</a>
<a name="19307"><span class="lineNum">   19307 </span>            :                       // I think we are not looking in the correct scope! Or else we need to also look in the target global scope.</a>
<a name="19308"><span class="lineNum">   19308 </span>            : #if 0</a>
<a name="19309"><span class="lineNum">   19309 </span>            :                          printf (&quot;Since the symbol has not been inserted yet, what symbol are we looking for? \n&quot;);</a>
<a name="19310"><span class="lineNum">   19310 </span>            : #endif</a>
<a name="19311"><span class="lineNum">   19311 </span><span class="lineNoCov">          0 :                          enumSymbolInTargetAST = lookupEnumSymbolInParentScopes(name,otherPossibleScope);</span></a>
<a name="19312"><span class="lineNum">   19312 </span>            : </a>
<a name="19313"><span class="lineNum">   19313 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumSymbolInTargetAST != NULL);</span></a>
<a name="19314"><span class="lineNum">   19314 </span><span class="lineNoCov">          0 :                          SgEnumDeclaration* enumDeclaration = enumSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19315"><span class="lineNum">   19315 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumDeclaration != NULL);</span></a>
<a name="19316"><span class="lineNum">   19316 </span>            : </a>
<a name="19317"><span class="lineNum">   19317 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumDeclaration != enumDeclaration_original);</span></a>
<a name="19318"><span class="lineNum">   19318 </span>            : </a>
<a name="19319"><span class="lineNum">   19319 </span>            :                       // This is true, so we need to build a new sysmbol.</a>
<a name="19320"><span class="lineNum">   19320 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumSymbolInTargetAST-&gt;get_declaration() == enumDeclaration_original-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19321"><span class="lineNum">   19321 </span>            : </a>
<a name="19322"><span class="lineNum">   19322 </span>            :                       // Build a new SgEnumSymbol using the enumDeclaration_copy.</a>
<a name="19323"><span class="lineNum">   19323 </span><span class="lineNoCov">          0 :                          SgEnumSymbol* enumSymbol = new SgEnumSymbol(enumDeclaration_copy);</span></a>
<a name="19324"><span class="lineNum">   19324 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumSymbol != NULL);</span></a>
<a name="19325"><span class="lineNum">   19325 </span><span class="lineNoCov">          0 :                          enumSymbolInTargetAST = enumSymbol;</span></a>
<a name="19326"><span class="lineNum">   19326 </span>            : </a>
<a name="19327"><span class="lineNum">   19327 </span>            :                       // If this is false then we need to build a new SgEnumSymbol rather than reusing the existing one.</a>
<a name="19328"><span class="lineNum">   19328 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumSymbolInTargetAST-&gt;get_declaration() != enumDeclaration_original-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19329"><span class="lineNum">   19329 </span>            : </a>
<a name="19330"><span class="lineNum">   19330 </span>            :                       // SgScopeStatement* scope = enumDeclaration-&gt;get_scope();</a>
<a name="19331"><span class="lineNum">   19331 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = targetScope;</span></a>
<a name="19332"><span class="lineNum">   19332 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="19333"><span class="lineNum">   19333 </span><span class="lineNoCov">          0 :                          enumDeclaration_copy-&gt;set_scope(scope);</span></a>
<a name="19334"><span class="lineNum">   19334 </span>            : #if 0</a>
<a name="19335"><span class="lineNum">   19335 </span>            :                          printf (&quot;case V_SgEnumDeclaration: insert_symbol(): name = %s enumSymbolInTargetAST = %p \n&quot;,name.str(),enumSymbolInTargetAST);</a>
<a name="19336"><span class="lineNum">   19336 </span>            : #endif</a>
<a name="19337"><span class="lineNum">   19337 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19338"><span class="lineNum">   19338 </span>            :                       // targetScope-&gt;insert_symbol(classSymbol_copy-&gt;get_name(),classSymbolInTargetAST);</a>
<a name="19339"><span class="lineNum">   19339 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(name,enumSymbolInTargetAST);</span></a>
<a name="19340"><span class="lineNum">   19340 </span>            :                        }</a>
<a name="19341"><span class="lineNum">   19341 </span>            :                       else</a>
<a name="19342"><span class="lineNum">   19342 </span>            :                        {</a>
<a name="19343"><span class="lineNum">   19343 </span>            : #if 0</a>
<a name="19344"><span class="lineNum">   19344 </span>            :                          printf (&quot;Found an existing enum declaration: name = %s enumSymbolInTargetAST = %p \n&quot;,name.str(),enumSymbolInTargetAST);</a>
<a name="19345"><span class="lineNum">   19345 </span>            : #endif</a>
<a name="19346"><span class="lineNum">   19346 </span>            :                       // In this case the symbol is in a parent scope already (find the scope and set the scope of the classDeclaration_copy.</a>
<a name="19347"><span class="lineNum">   19347 </span><span class="lineNoCov">          0 :                          SgEnumDeclaration* enumDeclaration = enumSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19348"><span class="lineNum">   19348 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumDeclaration != NULL);</span></a>
<a name="19349"><span class="lineNum">   19349 </span>            : #if 0</a>
<a name="19350"><span class="lineNum">   19350 </span>            :                          SgScopeStatement* scope = enumDeclaration-&gt;get_scope();</a>
<a name="19351"><span class="lineNum">   19351 </span>            :                          ROSE_ASSERT(scope != NULL);</a>
<a name="19352"><span class="lineNum">   19352 </span>            :                          ROSE_ASSERT(scope == targetScope);</a>
<a name="19353"><span class="lineNum">   19353 </span>            :                       // enumDeclaration_copy-&gt;set_scope(scope);</a>
<a name="19354"><span class="lineNum">   19354 </span>            : #else</a>
<a name="19355"><span class="lineNum">   19355 </span>            :                       // TV (10/22/2014): Might not be the case as we now have a project wide global scope</a>
<a name="19356"><span class="lineNum">   19356 </span>            :                       // ROSE_ASSERT(enumDeclaration-&gt;get_scope() == targetScope);</a>
<a name="19357"><span class="lineNum">   19357 </span>            : #endif</a>
<a name="19358"><span class="lineNum">   19358 </span>            :                        }</a>
<a name="19359"><span class="lineNum">   19359 </span>            : </a>
<a name="19360"><span class="lineNum">   19360 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(enumSymbolInTargetAST != NULL);</span></a>
<a name="19361"><span class="lineNum">   19361 </span>            :                   }</a>
<a name="19362"><span class="lineNum">   19362 </span>            : #if 0</a>
<a name="19363"><span class="lineNum">   19363 </span>            :                printf (&quot;Exiting as a test 1! \n&quot;);</a>
<a name="19364"><span class="lineNum">   19364 </span>            :                ROSE_ABORT();</a>
<a name="19365"><span class="lineNum">   19365 </span>            : #endif</a>
<a name="19366"><span class="lineNum">   19366 </span><span class="lineNoCov">          0 :                SgEnumType* enumType = enumDeclaration_copy-&gt;get_type();</span></a>
<a name="19367"><span class="lineNum">   19367 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(enumType != NULL);</span></a>
<a name="19368"><span class="lineNum">   19368 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(enumType,targetScope);</span></a>
<a name="19369"><span class="lineNum">   19369 </span>            : #if 0</a>
<a name="19370"><span class="lineNum">   19370 </span>            :                printf (&quot;Return type from getTargetFileType(): original enumType = %p new_type = %p \n&quot;,enumType,new_type);</a>
<a name="19371"><span class="lineNum">   19371 </span>            : #endif</a>
<a name="19372"><span class="lineNum">   19372 </span><span class="lineNoCov">          0 :                SgEnumType* new_enum_type = isSgEnumType(new_type);</span></a>
<a name="19373"><span class="lineNum">   19373 </span><span class="lineNoCov">          0 :                if (new_enum_type != NULL)</span></a>
<a name="19374"><span class="lineNum">   19374 </span>            :                   {</a>
<a name="19375"><span class="lineNum">   19375 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="19376"><span class="lineNum">   19376 </span>            : #if 0</a>
<a name="19377"><span class="lineNum">   19377 </span>            :                     printf (&quot;reset the type using the new enum type from the target AST \n&quot;);</a>
<a name="19378"><span class="lineNum">   19378 </span>            : #endif</a>
<a name="19379"><span class="lineNum">   19379 </span><span class="lineNoCov">          0 :                     enumDeclaration_copy-&gt;set_type(new_enum_type);</span></a>
<a name="19380"><span class="lineNum">   19380 </span>            :                   }</a>
<a name="19381"><span class="lineNum">   19381 </span>            : #if 0</a>
<a name="19382"><span class="lineNum">   19382 </span>            :                printf (&quot;Exiting as a test 2! \n&quot;);</a>
<a name="19383"><span class="lineNum">   19383 </span>            :                ROSE_ABORT();</a>
<a name="19384"><span class="lineNum">   19384 </span>            : #endif</a>
<a name="19385"><span class="lineNum">   19385 </span>            : </a>
<a name="19386"><span class="lineNum">   19386 </span><span class="lineNoCov">          0 :                resetDeclaration(enumDeclaration_copy,enumDeclaration_original,targetScope);</span></a>
<a name="19387"><span class="lineNum">   19387 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="19388"><span class="lineNum">   19388 </span>            :              }</a>
<a name="19389"><span class="lineNum">   19389 </span>            : </a>
<a name="19390"><span class="lineNum">   19390 </span>            :        // This is not a required declaration of C.</a>
<a name="19391"><span class="lineNum">   19391 </span><span class="lineNoCov">          0 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="19392"><span class="lineNum">   19392 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19393"><span class="lineNum">   19393 </span>            :             // Need to handle the referenced types</a>
<a name="19394"><span class="lineNum">   19394 </span><span class="lineNoCov">          0 :                SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(node_copy);</span></a>
<a name="19395"><span class="lineNum">   19395 </span><span class="lineNoCov">          0 :                SgClassType* templateClassType = templateClassDeclaration-&gt;get_type();</span></a>
<a name="19396"><span class="lineNum">   19396 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateClassType != NULL);</span></a>
<a name="19397"><span class="lineNum">   19397 </span>            : </a>
<a name="19398"><span class="lineNum">   19398 </span>            :             // DQ (3/10/2014): Added support for enum types.</a>
<a name="19399"><span class="lineNum">   19399 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(templateClassType,targetScope);</span></a>
<a name="19400"><span class="lineNum">   19400 </span><span class="lineNoCov">          0 :                SgClassType* new_templateClass_type = isSgClassType(new_type);</span></a>
<a name="19401"><span class="lineNum">   19401 </span><span class="lineNoCov">          0 :                if (new_templateClass_type != NULL)</span></a>
<a name="19402"><span class="lineNum">   19402 </span>            :                   {</a>
<a name="19403"><span class="lineNum">   19403 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="19404"><span class="lineNum">   19404 </span><span class="lineNoCov">          0 :                     templateClassDeclaration-&gt;set_type(new_templateClass_type);</span></a>
<a name="19405"><span class="lineNum">   19405 </span>            : #if 0</a>
<a name="19406"><span class="lineNum">   19406 </span>            :                     printf (&quot;case V_SgTemplateClassDeclaration: built class type: part 1: templateClassDeclaration-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="19407"><span class="lineNum">   19407 </span>            :                          templateClassDeclaration-&gt;get_type(),templateClassDeclaration-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="19408"><span class="lineNum">   19408 </span>            : #endif</a>
<a name="19409"><span class="lineNum">   19409 </span>            :                   }</a>
<a name="19410"><span class="lineNum">   19410 </span>            : </a>
<a name="19411"><span class="lineNum">   19411 </span>            :                break;</a>
<a name="19412"><span class="lineNum">   19412 </span>            :              }</a>
<a name="19413"><span class="lineNum">   19413 </span>            : </a>
<a name="19414"><span class="lineNum">   19414 </span><span class="lineNoCov">          0 :           case V_SgTypedefDeclaration:</span></a>
<a name="19415"><span class="lineNum">   19415 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19416"><span class="lineNum">   19416 </span>            :             // Need to handle the referenced types (there are two for the case of a SgTypedefDeclaration).</a>
<a name="19417"><span class="lineNum">   19417 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* typedefDeclaration_copy     = isSgTypedefDeclaration(node_copy);</span></a>
<a name="19418"><span class="lineNum">   19418 </span><span class="lineNoCov">          0 :                SgTypedefDeclaration* typedefDeclaration_original = isSgTypedefDeclaration(node_original);</span></a>
<a name="19419"><span class="lineNum">   19419 </span>            : </a>
<a name="19420"><span class="lineNum">   19420 </span><span class="lineNoCov">          0 :                SgType* base_type = typedefDeclaration_copy-&gt;get_base_type();</span></a>
<a name="19421"><span class="lineNum">   19421 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(base_type != NULL);</span></a>
<a name="19422"><span class="lineNum">   19422 </span><span class="lineNoCov">          0 :                SgType* new_base_type = getTargetFileType(base_type,targetScope);</span></a>
<a name="19423"><span class="lineNum">   19423 </span><span class="lineNoCov">          0 :                if (new_base_type != NULL)</span></a>
<a name="19424"><span class="lineNum">   19424 </span>            :                   {</a>
<a name="19425"><span class="lineNum">   19425 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="19426"><span class="lineNum">   19426 </span><span class="lineNoCov">          0 :                     typedefDeclaration_copy-&gt;set_base_type(new_base_type);</span></a>
<a name="19427"><span class="lineNum">   19427 </span>            :                   }</a>
<a name="19428"><span class="lineNum">   19428 </span>            : </a>
<a name="19429"><span class="lineNum">   19429 </span>            :             // I don't think we have to test for this being a part of the snippet file.</a>
<a name="19430"><span class="lineNum">   19430 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="19431"><span class="lineNum">   19431 </span><span class="lineNoCov">          0 :                     SgName name = typedefDeclaration_copy-&gt;get_name();</span></a>
<a name="19432"><span class="lineNum">   19432 </span>            : #if 0</a>
<a name="19433"><span class="lineNum">   19433 </span>            :                  // If we randomize the names then we need to handle this case...</a>
<a name="19434"><span class="lineNum">   19434 </span>            :                     printf (&quot;case V_SgTypedefDeclaration: targetScope = %p typedefSymbol_copy-&gt;get_name() = %s \n&quot;,targetScope,name.str());</a>
<a name="19435"><span class="lineNum">   19435 </span>            : #endif</a>
<a name="19436"><span class="lineNum">   19436 </span><span class="lineNoCov">          0 :                     SgTypedefSymbol* typedefSymbolInTargetAST = lookupTypedefSymbolInParentScopes(name,targetScope);</span></a>
<a name="19437"><span class="lineNum">   19437 </span>            : </a>
<a name="19438"><span class="lineNum">   19438 </span><span class="lineNoCov">          0 :                     if (typedefSymbolInTargetAST == NULL)</span></a>
<a name="19439"><span class="lineNum">   19439 </span>            :                        {</a>
<a name="19440"><span class="lineNum">   19440 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19441"><span class="lineNum">   19441 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope = isSgScopeStatement(typedefDeclaration_original-&gt;get_parent());</span></a>
<a name="19442"><span class="lineNum">   19442 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope != NULL);</span></a>
<a name="19443"><span class="lineNum">   19443 </span>            : #if 0</a>
<a name="19444"><span class="lineNum">   19444 </span>            :                          printf (&quot;case V_SgTypedefDeclaration: otherPossibleScope = %p \n&quot;,otherPossibleScope);</a>
<a name="19445"><span class="lineNum">   19445 </span>            : #endif</a>
<a name="19446"><span class="lineNum">   19446 </span><span class="lineNoCov">          0 :                          typedefSymbolInTargetAST = lookupTypedefSymbolInParentScopes(name,otherPossibleScope);</span></a>
<a name="19447"><span class="lineNum">   19447 </span>            : </a>
<a name="19448"><span class="lineNum">   19448 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</span></a>
<a name="19449"><span class="lineNum">   19449 </span><span class="lineNoCov">          0 :                          SgTypedefDeclaration* typedefDeclaration = typedefSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19450"><span class="lineNum">   19450 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration != NULL);</span></a>
<a name="19451"><span class="lineNum">   19451 </span>            :                       // SgScopeStatement* scope = typedefDeclaration-&gt;get_scope();</a>
<a name="19452"><span class="lineNum">   19452 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = targetScope;</span></a>
<a name="19453"><span class="lineNum">   19453 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="19454"><span class="lineNum">   19454 </span><span class="lineNoCov">          0 :                          typedefDeclaration_copy-&gt;set_scope(scope);</span></a>
<a name="19455"><span class="lineNum">   19455 </span>            : </a>
<a name="19456"><span class="lineNum">   19456 </span>            :                       // DQ (3/17/2014): Build a new SgTypedefSymbol using the typedefDeclaration_copy.</a>
<a name="19457"><span class="lineNum">   19457 </span><span class="lineNoCov">          0 :                          SgTypedefSymbol* typedefSymbol = new SgTypedefSymbol(typedefDeclaration_copy);</span></a>
<a name="19458"><span class="lineNum">   19458 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefSymbol != NULL);</span></a>
<a name="19459"><span class="lineNum">   19459 </span><span class="lineNoCov">          0 :                          typedefSymbolInTargetAST = typedefSymbol;</span></a>
<a name="19460"><span class="lineNum">   19460 </span>            : #if 0</a>
<a name="19461"><span class="lineNum">   19461 </span>            :                          printf (&quot;case V_SgTypedefDeclaration: insert_symbol(): name = %s typedefSymbolInTargetAST = %p \n&quot;,name.str(),typedefSymbolInTargetAST);</a>
<a name="19462"><span class="lineNum">   19462 </span>            : #endif</a>
<a name="19463"><span class="lineNum">   19463 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19464"><span class="lineNum">   19464 </span>            :                       // targetScope-&gt;insert_symbol(classSymbol_copy-&gt;get_name(),classSymbolInTargetAST);</a>
<a name="19465"><span class="lineNum">   19465 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(name,typedefSymbolInTargetAST);</span></a>
<a name="19466"><span class="lineNum">   19466 </span>            :                        }</a>
<a name="19467"><span class="lineNum">   19467 </span>            :                       else</a>
<a name="19468"><span class="lineNum">   19468 </span>            :                        {</a>
<a name="19469"><span class="lineNum">   19469 </span>            : #if 0</a>
<a name="19470"><span class="lineNum">   19470 </span>            :                          printf (&quot;Found an existing typedef declaration: name = %s typedefSymbolInTargetAST = %p \n&quot;,name.str(),typedefSymbolInTargetAST);</a>
<a name="19471"><span class="lineNum">   19471 </span>            : #endif</a>
<a name="19472"><span class="lineNum">   19472 </span>            :                       // In this case the symbol is in a parent scope already (find the scope and set the scope of the classDeclaration_copy.</a>
<a name="19473"><span class="lineNum">   19473 </span><span class="lineNoCov">          0 :                          SgTypedefDeclaration* typedefDeclaration = typedefSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19474"><span class="lineNum">   19474 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(typedefDeclaration != NULL);</span></a>
<a name="19475"><span class="lineNum">   19475 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = typedefDeclaration-&gt;get_scope();</span></a>
<a name="19476"><span class="lineNum">   19476 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="19477"><span class="lineNum">   19477 </span><span class="lineNoCov">          0 :                          typedefDeclaration_copy-&gt;set_scope(scope);</span></a>
<a name="19478"><span class="lineNum">   19478 </span>            :                        }</a>
<a name="19479"><span class="lineNum">   19479 </span>            : </a>
<a name="19480"><span class="lineNum">   19480 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(typedefSymbolInTargetAST != NULL);</span></a>
<a name="19481"><span class="lineNum">   19481 </span>            :                   }</a>
<a name="19482"><span class="lineNum">   19482 </span>            : #if 0</a>
<a name="19483"><span class="lineNum">   19483 </span>            :                printf (&quot;Exiting as a test 1! \n&quot;);</a>
<a name="19484"><span class="lineNum">   19484 </span>            :                ROSE_ABORT();</a>
<a name="19485"><span class="lineNum">   19485 </span>            : #endif</a>
<a name="19486"><span class="lineNum">   19486 </span><span class="lineNoCov">          0 :                SgTypedefType* typedefType = typedefDeclaration_copy-&gt;get_type();</span></a>
<a name="19487"><span class="lineNum">   19487 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(typedefType != NULL);</span></a>
<a name="19488"><span class="lineNum">   19488 </span><span class="lineNoCov">          0 :                SgType* new_type = getTargetFileType(typedefType,targetScope);</span></a>
<a name="19489"><span class="lineNum">   19489 </span><span class="lineNoCov">          0 :                SgTypedefType* new_typedef_type = isSgTypedefType(new_type);</span></a>
<a name="19490"><span class="lineNum">   19490 </span><span class="lineNoCov">          0 :                if (new_typedef_type != NULL)</span></a>
<a name="19491"><span class="lineNum">   19491 </span>            :                   {</a>
<a name="19492"><span class="lineNum">   19492 </span>            :                  // Reset the base type to be the one associated with the target file.</a>
<a name="19493"><span class="lineNum">   19493 </span>            : #if 0</a>
<a name="19494"><span class="lineNum">   19494 </span>            :                     printf (&quot;reset the type using the new typedef type from the target AST \n&quot;);</a>
<a name="19495"><span class="lineNum">   19495 </span>            : #endif</a>
<a name="19496"><span class="lineNum">   19496 </span><span class="lineNoCov">          0 :                     typedefDeclaration_copy-&gt;set_type(new_typedef_type);</span></a>
<a name="19497"><span class="lineNum">   19497 </span>            : #if 0</a>
<a name="19498"><span class="lineNum">   19498 </span>            :                     printf (&quot;case V_SgTypedefDeclaration: built class type: part 1: typedefDeclaration_copy-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="19499"><span class="lineNum">   19499 </span>            :                          typedefDeclaration_copy-&gt;get_type(),typedefDeclaration_copy-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="19500"><span class="lineNum">   19500 </span>            : #endif</a>
<a name="19501"><span class="lineNum">   19501 </span>            :                   }</a>
<a name="19502"><span class="lineNum">   19502 </span>            : </a>
<a name="19503"><span class="lineNum">   19503 </span><span class="lineNoCov">          0 :                resetDeclaration(typedefDeclaration_copy,typedefDeclaration_original,targetScope);</span></a>
<a name="19504"><span class="lineNum">   19504 </span>            : #if 0</a>
<a name="19505"><span class="lineNum">   19505 </span>            :                printf (&quot;Exiting as a test 2! \n&quot;);</a>
<a name="19506"><span class="lineNum">   19506 </span>            :                ROSE_ABORT();</a>
<a name="19507"><span class="lineNum">   19507 </span>            : #endif</a>
<a name="19508"><span class="lineNum">   19508 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="19509"><span class="lineNum">   19509 </span>            :              }</a>
<a name="19510"><span class="lineNum">   19510 </span>            : </a>
<a name="19511"><span class="lineNum">   19511 </span><span class="lineNoCov">          0 :           case V_SgVarRefExp:</span></a>
<a name="19512"><span class="lineNum">   19512 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19513"><span class="lineNum">   19513 </span>            :             // Need to handle the referenced symbol.</a>
<a name="19514"><span class="lineNum">   19514 </span>            :             // but if we have handle this in the declaration for the variable (case V_SgInitializedName)</a>
<a name="19515"><span class="lineNum">   19515 </span>            :             // then we don't have to do anything here.  However, we have only handled this variable</a>
<a name="19516"><span class="lineNum">   19516 </span>            :             // declaration if the variable declaration was a part of the snippet.  If the variable</a>
<a name="19517"><span class="lineNum">   19517 </span>            :             // declaration is not a part of the original snippet (the copy of the snippet's AST that</a>
<a name="19518"><span class="lineNum">   19518 </span>            :             // we are inserting (not the snippet program where it would have to be defined for the</a>
<a name="19519"><span class="lineNum">   19519 </span>            :             // snippet to compile) then we have to find the associated variable sysmbol in the target</a>
<a name="19520"><span class="lineNum">   19520 </span>            :             // AST and reset the SgVarRefExp to use that symbol.</a>
<a name="19521"><span class="lineNum">   19521 </span>            : </a>
<a name="19522"><span class="lineNum">   19522 </span><span class="lineNoCov">          0 :                SgVarRefExp* varRefExp_copy     = isSgVarRefExp(node_copy);</span></a>
<a name="19523"><span class="lineNum">   19523 </span><span class="lineNoCov">          0 :                SgVarRefExp* varRefExp_original = isSgVarRefExp(node_original);</span></a>
<a name="19524"><span class="lineNum">   19524 </span><span class="lineNoCov">          0 :                SgVariableSymbol* variableSymbol_copy = isSgVariableSymbol(varRefExp_copy-&gt;get_symbol());</span></a>
<a name="19525"><span class="lineNum">   19525 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(variableSymbol_copy != NULL);</span></a>
<a name="19526"><span class="lineNum">   19526 </span>            :             // if (TransformationSupport::getFile(variableSymbol_copy) != targetFile)</a>
<a name="19527"><span class="lineNum">   19527 </span><span class="lineNoCov">          0 :                if (getEnclosingFileNode(variableSymbol_copy) != targetFile)</span></a>
<a name="19528"><span class="lineNum">   19528 </span>            :                   {</a>
<a name="19529"><span class="lineNum">   19529 </span>            : #if 0</a>
<a name="19530"><span class="lineNum">   19530 </span>            :                     printf (&quot;Warning: case V_SgVarRefExp: variableSymbol not in target file: name = %s \n&quot;,variableSymbol_copy-&gt;get_name().str());</a>
<a name="19531"><span class="lineNum">   19531 </span>            : #endif</a>
<a name="19532"><span class="lineNum">   19532 </span>            : #if 0</a>
<a name="19533"><span class="lineNum">   19533 </span>            :                     printf (&quot;insertionPoint = %p = %s \n&quot;,insertionPoint,insertionPoint-&gt;class_name().c_str());</a>
<a name="19534"><span class="lineNum">   19534 </span>            : #endif</a>
<a name="19535"><span class="lineNum">   19535 </span>            :                  // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</a>
<a name="19536"><span class="lineNum">   19536 </span>            : #if 0</a>
<a name="19537"><span class="lineNum">   19537 </span>            :                  // printf (&quot;insertionPointIsScope = %s insertionPointScope = %p = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="19538"><span class="lineNum">   19538 </span>            : #endif</a>
<a name="19539"><span class="lineNum">   19539 </span>            :                  // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).</a>
<a name="19540"><span class="lineNum">   19540 </span>            : </a>
<a name="19541"><span class="lineNum">   19541 </span>            :                  // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</a>
<a name="19542"><span class="lineNum">   19542 </span>            :                  // ROSE_ASSERT(targetScope != NULL);</a>
<a name="19543"><span class="lineNum">   19543 </span>            : </a>
<a name="19544"><span class="lineNum">   19544 </span><span class="lineNoCov">          0 :                     SgVariableSymbol* variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy-&gt;get_name(),targetScope);</span></a>
<a name="19545"><span class="lineNum">   19545 </span>            : </a>
<a name="19546"><span class="lineNum">   19546 </span><span class="lineNoCov">          0 :                     if (variableSymbolInTargetAST == NULL)</span></a>
<a name="19547"><span class="lineNum">   19547 </span>            :                        {</a>
<a name="19548"><span class="lineNum">   19548 </span>            :                       // This is a violation of the policy that the a variable with the same name will be found in the target AST.</a>
<a name="19549"><span class="lineNum">   19549 </span>            :                       // Note that if the variable could not be found then it should have been added as part of the snippet, or a</a>
<a name="19550"><span class="lineNum">   19550 </span>            :                       // previously added snippet.</a>
<a name="19551"><span class="lineNum">   19551 </span>            : #if 0</a>
<a name="19552"><span class="lineNum">   19552 </span>            :                          printf (&quot;Error: The associated variable = %s should have been found in a parent scope of the target AST \n&quot;,variableSymbol_copy-&gt;get_name().str());</a>
<a name="19553"><span class="lineNum">   19553 </span>            : #endif</a>
<a name="19554"><span class="lineNum">   19554 </span>            :                       // We need to look into the scope of the block used to define the statments as seperate snippets (same issue as for functions).</a>
<a name="19555"><span class="lineNum">   19555 </span>            : </a>
<a name="19556"><span class="lineNum">   19556 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19557"><span class="lineNum">   19557 </span><span class="lineNoCov">          0 :                          SgStatement* enclosingStatement_original = TransformationSupport::getStatement(varRefExp_original);</span></a>
<a name="19558"><span class="lineNum">   19558 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enclosingStatement_original != NULL);</span></a>
<a name="19559"><span class="lineNum">   19559 </span>            : #if 0</a>
<a name="19560"><span class="lineNum">   19560 </span>            :                          printf (&quot;case V_SgVarRefExp: enclosingStatement_original = %p = %s \n&quot;,enclosingStatement_original,enclosingStatement_original-&gt;class_name().c_str());</a>
<a name="19561"><span class="lineNum">   19561 </span>            : #endif</a>
<a name="19562"><span class="lineNum">   19562 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope_original = isSgScopeStatement(enclosingStatement_original-&gt;get_parent());</span></a>
<a name="19563"><span class="lineNum">   19563 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope_original != NULL);</span></a>
<a name="19564"><span class="lineNum">   19564 </span>            :                       // SgFile* file = TransformationSupport::getFile(enclosingStatement_original);</a>
<a name="19565"><span class="lineNum">   19565 </span><span class="lineNoCov">          0 :                          SgFile* file = getEnclosingFileNode(enclosingStatement_original);</span></a>
<a name="19566"><span class="lineNum">   19566 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(file != NULL);</span></a>
<a name="19567"><span class="lineNum">   19567 </span>            : #if 0</a>
<a name="19568"><span class="lineNum">   19568 </span>            :                          printf (&quot;enclosingStatement_original: associated file name = %s \n&quot;,file-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19569"><span class="lineNum">   19569 </span>            :                       // printf (&quot;   --- targetFile            = %p = %s \n&quot;,targetFile,targetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19570"><span class="lineNum">   19570 </span>            : </a>
<a name="19571"><span class="lineNum">   19571 </span>            :                          printf (&quot;case V_SgClassDeclaration: otherPossibleScope = %p = %s \n&quot;,otherPossibleScope_original,otherPossibleScope_original-&gt;class_name().c_str());</a>
<a name="19572"><span class="lineNum">   19572 </span>            :                          printf (&quot;case V_SgClassDeclaration: variableSymbol_copy-&gt;get_name() = %s \n&quot;,variableSymbol_copy-&gt;get_name().str());</a>
<a name="19573"><span class="lineNum">   19573 </span>            : #endif</a>
<a name="19574"><span class="lineNum">   19574 </span><span class="lineNoCov">          0 :                          variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy-&gt;get_name(),otherPossibleScope_original);</span></a>
<a name="19575"><span class="lineNum">   19575 </span><span class="lineNoCov">          0 :                          if (variableSymbolInTargetAST == NULL)</span></a>
<a name="19576"><span class="lineNum">   19576 </span>            :                             {</a>
<a name="19577"><span class="lineNum">   19577 </span>            : #if 0</a>
<a name="19578"><span class="lineNum">   19578 </span>            :                               targetScope-&gt;get_symbol_table()-&gt;print(&quot;targetScope: symbol table&quot;);</a>
<a name="19579"><span class="lineNum">   19579 </span>            :                               otherPossibleScope_original-&gt;get_symbol_table()-&gt;print(&quot;otherPossibleScope_original: symbol table&quot;);</a>
<a name="19580"><span class="lineNum">   19580 </span>            : #endif</a>
<a name="19581"><span class="lineNum">   19581 </span>            : </a>
<a name="19582"><span class="lineNum">   19582 </span>            :                            // Check for the case of a record reference (member of data structure).</a>
<a name="19583"><span class="lineNum">   19583 </span><span class="lineNoCov">          0 :                               SgExpression* parentExpression = isSgExpression(varRefExp_copy-&gt;get_parent());</span></a>
<a name="19584"><span class="lineNum">   19584 </span><span class="lineNoCov">          0 :                               SgBinaryOp*   parentBinaryOp   = isSgBinaryOp(parentExpression);</span></a>
<a name="19585"><span class="lineNum">   19585 </span><span class="lineNoCov">          0 :                               SgDotExp*     parentDotExp     = isSgDotExp(parentExpression);</span></a>
<a name="19586"><span class="lineNum">   19586 </span><span class="lineNoCov">          0 :                               SgArrowExp*   parentArrowExp   = isSgArrowExp(parentExpression);</span></a>
<a name="19587"><span class="lineNum">   19587 </span><span class="lineNoCov">          0 :                               if (parentDotExp != NULL || parentArrowExp != NULL)</span></a>
<a name="19588"><span class="lineNum">   19588 </span>            :                                  {</a>
<a name="19589"><span class="lineNum">   19589 </span>            :                                 // This is a data member reference, so it's scope is the associated data structure.</a>
<a name="19590"><span class="lineNum">   19590 </span><span class="lineNoCov">          0 :                                    SgExpression* lhs = parentBinaryOp-&gt;get_lhs_operand();</span></a>
<a name="19591"><span class="lineNum">   19591 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(lhs != NULL);</span></a>
<a name="19592"><span class="lineNum">   19592 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(parentBinaryOp-&gt;get_rhs_operand() == varRefExp_copy);</span></a>
<a name="19593"><span class="lineNum">   19593 </span>            : </a>
<a name="19594"><span class="lineNum">   19594 </span><span class="lineNoCov">          0 :                                    SgType* type = lhs-&gt;get_type();</span></a>
<a name="19595"><span class="lineNum">   19595 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(type != NULL);</span></a>
<a name="19596"><span class="lineNum">   19596 </span>            : #if 0</a>
<a name="19597"><span class="lineNum">   19597 </span>            :                                    printf (&quot;type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="19598"><span class="lineNum">   19598 </span>            : #endif</a>
<a name="19599"><span class="lineNum">   19599 </span><span class="lineNoCov">          0 :                                    SgNamedType* namedType = isSgNamedType(type);</span></a>
<a name="19600"><span class="lineNum">   19600 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(namedType != NULL);</span></a>
<a name="19601"><span class="lineNum">   19601 </span><span class="lineNoCov">          0 :                                    SgDeclarationStatement* declaration = namedType-&gt;get_declaration();</span></a>
<a name="19602"><span class="lineNum">   19602 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(declaration != NULL);</span></a>
<a name="19603"><span class="lineNum">   19603 </span><span class="lineNoCov">          0 :                                    SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);</span></a>
<a name="19604"><span class="lineNum">   19604 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="19605"><span class="lineNum">   19605 </span><span class="lineNoCov">          0 :                                    SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(declaration-&gt;get_definingDeclaration());</span></a>
<a name="19606"><span class="lineNum">   19606 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="19607"><span class="lineNum">   19607 </span><span class="lineNoCov">          0 :                                    SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="19608"><span class="lineNum">   19608 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="19609"><span class="lineNum">   19609 </span>            : #if 0</a>
<a name="19610"><span class="lineNum">   19610 </span>            :                                    printf (&quot;case V_SgClassDeclaration: classDefinition = %p = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str());</a>
<a name="19611"><span class="lineNum">   19611 </span>            : #endif</a>
<a name="19612"><span class="lineNum">   19612 </span>            :                                 // I think we want the copy.</a>
<a name="19613"><span class="lineNum">   19613 </span><span class="lineNoCov">          0 :                                    otherPossibleScope_original = classDefinition;</span></a>
<a name="19614"><span class="lineNum">   19614 </span>            : </a>
<a name="19615"><span class="lineNum">   19615 </span><span class="lineNoCov">          0 :                                    variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy-&gt;get_name(),otherPossibleScope_original);</span></a>
<a name="19616"><span class="lineNum">   19616 </span>            :                                  }</a>
<a name="19617"><span class="lineNum">   19617 </span>            : </a>
<a name="19618"><span class="lineNum">   19618 </span>            :                             }</a>
<a name="19619"><span class="lineNum">   19619 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(variableSymbolInTargetAST != NULL);</span></a>
<a name="19620"><span class="lineNum">   19620 </span><span class="lineNoCov">          0 :                          SgInitializedName* initializedName = variableSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19621"><span class="lineNum">   19621 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="19622"><span class="lineNum">   19622 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = initializedName-&gt;get_scope();</span></a>
<a name="19623"><span class="lineNum">   19623 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="19624"><span class="lineNum">   19624 </span>            : </a>
<a name="19625"><span class="lineNum">   19625 </span>            :                       // Is this the correct scope?</a>
<a name="19626"><span class="lineNum">   19626 </span><span class="lineNoCov">          0 :                          initializedName-&gt;set_scope(scope);</span></a>
<a name="19627"><span class="lineNum">   19627 </span>            : </a>
<a name="19628"><span class="lineNum">   19628 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19629"><span class="lineNum">   19629 </span><span class="lineNoCov">          0 :                          targetScope-&gt;insert_symbol(variableSymbol_copy-&gt;get_name(),variableSymbolInTargetAST);</span></a>
<a name="19630"><span class="lineNum">   19630 </span>            :                        }</a>
<a name="19631"><span class="lineNum">   19631 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(variableSymbolInTargetAST != NULL);</span></a>
<a name="19632"><span class="lineNum">   19632 </span>            : </a>
<a name="19633"><span class="lineNum">   19633 </span>            :                  // Reset the symbol associated with this variable reference.</a>
<a name="19634"><span class="lineNum">   19634 </span><span class="lineNoCov">          0 :                     varRefExp_copy-&gt;set_symbol(variableSymbolInTargetAST);</span></a>
<a name="19635"><span class="lineNum">   19635 </span>            : </a>
<a name="19636"><span class="lineNum">   19636 </span>            :                  // printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="19637"><span class="lineNum">   19637 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="19638"><span class="lineNum">   19638 </span>            :                   }</a>
<a name="19639"><span class="lineNum">   19639 </span>            : </a>
<a name="19640"><span class="lineNum">   19640 </span>            :                break;</a>
<a name="19641"><span class="lineNum">   19641 </span>            :              }</a>
<a name="19642"><span class="lineNum">   19642 </span>            : </a>
<a name="19643"><span class="lineNum">   19643 </span><span class="lineNoCov">          0 :           case V_SgFunctionRefExp:</span></a>
<a name="19644"><span class="lineNum">   19644 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19645"><span class="lineNum">   19645 </span>            :             // Need to handle the referenced symbol</a>
<a name="19646"><span class="lineNum">   19646 </span><span class="lineNoCov">          0 :                SgFunctionRefExp* functionRefExp_copy     = isSgFunctionRefExp(node_copy);</span></a>
<a name="19647"><span class="lineNum">   19647 </span>            :             // SgFunctionRefExp* functionRefExp_original = isSgFunctionRefExp(node_original);</a>
<a name="19648"><span class="lineNum">   19648 </span><span class="lineNoCov">          0 :                SgFunctionSymbol* functionSymbol_copy = isSgFunctionSymbol(functionRefExp_copy-&gt;get_symbol());</span></a>
<a name="19649"><span class="lineNum">   19649 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbol_copy != NULL);</span></a>
<a name="19650"><span class="lineNum">   19650 </span>            :             // if (TransformationSupport::getFile(functionSymbol) != targetFile)</a>
<a name="19651"><span class="lineNum">   19651 </span><span class="lineNoCov">          0 :                if (getEnclosingFileNode(functionSymbol_copy) != targetFile)</span></a>
<a name="19652"><span class="lineNum">   19652 </span>            :                   {</a>
<a name="19653"><span class="lineNum">   19653 </span>            : #if 0</a>
<a name="19654"><span class="lineNum">   19654 </span>            :                     printf (&quot;Warning: case V_SgFunctionRefExp: functionSymbol_copy not in target file (find function = %s) \n&quot;,functionSymbol_copy-&gt;get_name().str());</a>
<a name="19655"><span class="lineNum">   19655 </span>            : #endif</a>
<a name="19656"><span class="lineNum">   19656 </span>            :                  // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint-&gt;get_parent();</a>
<a name="19657"><span class="lineNum">   19657 </span>            : #if 0</a>
<a name="19658"><span class="lineNum">   19658 </span>            :                     printf (&quot;insertionPointIsScope = %s insertionPointScope = %p = %s \n&quot;,insertionPointIsScope ? &quot;true&quot; : &quot;false&quot;,insertionPointScope,insertionPointScope-&gt;class_name().c_str());</a>
<a name="19659"><span class="lineNum">   19659 </span>            : #endif</a>
<a name="19660"><span class="lineNum">   19660 </span>            :                  // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).</a>
<a name="19661"><span class="lineNum">   19661 </span>            : </a>
<a name="19662"><span class="lineNum">   19662 </span>            :                  // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);</a>
<a name="19663"><span class="lineNum">   19663 </span>            :                  // ROSE_ASSERT(targetScope != NULL);</a>
<a name="19664"><span class="lineNum">   19664 </span>            : </a>
<a name="19665"><span class="lineNum">   19665 </span><span class="lineNoCov">          0 :                     SgName name = functionSymbol_copy-&gt;get_name();</span></a>
<a name="19666"><span class="lineNum">   19666 </span>            : </a>
<a name="19667"><span class="lineNum">   19667 </span>            :                  // I think we need the function's mangled name to support this lookup.</a>
<a name="19668"><span class="lineNum">   19668 </span><span class="lineNoCov">          0 :                     SgFunctionSymbol* functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(name,targetScope);</span></a>
<a name="19669"><span class="lineNum">   19669 </span>            : </a>
<a name="19670"><span class="lineNum">   19670 </span><span class="lineNoCov">          0 :                     if (functionSymbolInTargetAST == NULL)</span></a>
<a name="19671"><span class="lineNum">   19671 </span>            :                        {</a>
<a name="19672"><span class="lineNum">   19672 </span>            :                       // DQ (3/17/2014): Revised as of further discussion about how the snippet mechanism will copy required</a>
<a name="19673"><span class="lineNum">   19673 </span>            :                       // declaration from the snippet file to the target AST.</a>
<a name="19674"><span class="lineNum">   19674 </span>            :                       // This is a violation of the policy that the a variable with the same name will be found in the target AST.</a>
<a name="19675"><span class="lineNum">   19675 </span>            :                       // Note that if the variable could not be found then it should have been added as part of the snippet, or a</a>
<a name="19676"><span class="lineNum">   19676 </span>            :                       // previously added snippet.</a>
<a name="19677"><span class="lineNum">   19677 </span>            :                       // DQ (3/17/2014): After some revision of the specification for the snippet injection, this is still</a>
<a name="19678"><span class="lineNum">   19678 </span>            :                       // an error since this is the case where a declaration should have been visible from having already been</a>
<a name="19679"><span class="lineNum">   19679 </span>            :                       // inserted into the target AST and this visible from this injection point in the target AST.</a>
<a name="19680"><span class="lineNum">   19680 </span>            : </a>
<a name="19681"><span class="lineNum">   19681 </span><span class="lineNoCov">          0 :                          fprintf (stderr, &quot;Error: The associated function = \&quot;%s\&quot; should have been found in a parent scope&quot;</span></a>
<a name="19682"><span class="lineNum">   19682 </span>            :                                   &quot; of the target AST\n&quot;, name.str());</a>
<a name="19683"><span class="lineNum">   19683 </span>            : </a>
<a name="19684"><span class="lineNum">   19684 </span><span class="lineNoCov">          0 :                          fprintf (stderr, &quot;  targetScope = %p = %s \n&quot;,targetScope,targetScope-&gt;class_name().c_str());</span></a>
<a name="19685"><span class="lineNum">   19685 </span><span class="lineNoCov">          0 :                          SgGlobal* globalScope = TransformationSupport::getGlobalScope(targetScope);</span></a>
<a name="19686"><span class="lineNum">   19686 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="19687"><span class="lineNum">   19687 </span><span class="lineNoCov">          0 :                          fprintf (stderr, &quot;  globalScope = %p = %s \n&quot;,globalScope,globalScope-&gt;class_name().c_str());</span></a>
<a name="19688"><span class="lineNum">   19688 </span>            : #if 0</a>
<a name="19689"><span class="lineNum">   19689 </span>            :                          targetScope-&gt;get_file_info()-&gt;display(&quot;case V_SgFunctionRefExp: targetScope: debug&quot;);</a>
<a name="19690"><span class="lineNum">   19690 </span>            :                          node_original-&gt;get_file_info()-&gt;display(&quot;case V_SgFunctionRefExp: node_original: debug&quot;);</a>
<a name="19691"><span class="lineNum">   19691 </span>            : #endif</a>
<a name="19692"><span class="lineNum">   19692 </span>            : #if 0</a>
<a name="19693"><span class="lineNum">   19693 </span>            :                       // DQ (3/10/2014): This might be important for friend functions in C++ (but we can ignore it for now).</a>
<a name="19694"><span class="lineNum">   19694 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="19695"><span class="lineNum">   19695 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19696"><span class="lineNum">   19696 </span>            :                          SgStatement* enclosingStatement_original = TransformationSupport::getStatement(functionRefExp_original);</a>
<a name="19697"><span class="lineNum">   19697 </span>            :                          ROSE_ASSERT(enclosingStatement_original != NULL);</a>
<a name="19698"><span class="lineNum">   19698 </span>            : #if 0</a>
<a name="19699"><span class="lineNum">   19699 </span>            :                          printf (&quot;case V_SgFunctionRefExp: enclosingStatement_original = %p = %s \n&quot;,enclosingStatement_original,enclosingStatement_original-&gt;class_name().c_str());</a>
<a name="19700"><span class="lineNum">   19700 </span>            : #endif</a>
<a name="19701"><span class="lineNum">   19701 </span>            :                          SgScopeStatement* otherPossibleScope_original = isSgScopeStatement(enclosingStatement_original-&gt;get_parent());</a>
<a name="19702"><span class="lineNum">   19702 </span>            :                          ROSE_ASSERT(otherPossibleScope_original != NULL);</a>
<a name="19703"><span class="lineNum">   19703 </span>            :                       // SgFile* file = TransformationSupport::getFile(enclosingStatement_original);</a>
<a name="19704"><span class="lineNum">   19704 </span>            :                          SgFile* file = getEnclosingFileNode(enclosingStatement_original);</a>
<a name="19705"><span class="lineNum">   19705 </span>            :                          ROSE_ASSERT(file != NULL);</a>
<a name="19706"><span class="lineNum">   19706 </span>            : #if 0</a>
<a name="19707"><span class="lineNum">   19707 </span>            :                          printf (&quot;enclosingStatement_original: associated file name = %s \n&quot;,file-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19708"><span class="lineNum">   19708 </span>            :                       // printf (&quot;   --- targetFile            = %p = %s \n&quot;,targetFile,targetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19709"><span class="lineNum">   19709 </span>            : </a>
<a name="19710"><span class="lineNum">   19710 </span>            :                          printf (&quot;case V_SgClassDeclaration: otherPossibleScope = %p = %s \n&quot;,otherPossibleScope_original,otherPossibleScope_original-&gt;class_name().c_str());</a>
<a name="19711"><span class="lineNum">   19711 </span>            :                          printf (&quot;case V_SgClassDeclaration: functionSymbol_copy-&gt;get_name() = %s \n&quot;,functionSymbol_copy-&gt;get_name().str());</a>
<a name="19712"><span class="lineNum">   19712 </span>            : #endif</a>
<a name="19713"><span class="lineNum">   19713 </span>            :                          functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(functionSymbol_copy-&gt;get_name(),otherPossibleScope_original);</a>
<a name="19714"><span class="lineNum">   19714 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="19715"><span class="lineNum">   19715 </span>            :                          if (functionSymbolInTargetAST == NULL)</a>
<a name="19716"><span class="lineNum">   19716 </span>            :                             {</a>
<a name="19717"><span class="lineNum">   19717 </span>            :                            // Check for the case of a record reference (member function of class declaration).</a>
<a name="19718"><span class="lineNum">   19718 </span>            :                               SgExpression* parentExpression = isSgExpression(functionRefExp_copy-&gt;get_parent());</a>
<a name="19719"><span class="lineNum">   19719 </span>            :                               SgBinaryOp*   parentBinaryOp   = isSgBinaryOp(parentExpression);</a>
<a name="19720"><span class="lineNum">   19720 </span>            :                               SgDotExp*     parentDotExp     = isSgDotExp(parentExpression);</a>
<a name="19721"><span class="lineNum">   19721 </span>            :                               SgArrowExp*   parentArrowExp   = isSgArrowExp(parentExpression);</a>
<a name="19722"><span class="lineNum">   19722 </span>            :                               if (parentDotExp != NULL || parentArrowExp != NULL)</a>
<a name="19723"><span class="lineNum">   19723 </span>            :                                  {</a>
<a name="19724"><span class="lineNum">   19724 </span>            :                                 // This is a data member reference, so it's scope is the associated data structure.</a>
<a name="19725"><span class="lineNum">   19725 </span>            :                                    SgExpression* lhs = parentBinaryOp-&gt;get_lhs_operand();</a>
<a name="19726"><span class="lineNum">   19726 </span>            :                                    ROSE_ASSERT(lhs != NULL);</a>
<a name="19727"><span class="lineNum">   19727 </span>            :                                    ROSE_ASSERT(parentBinaryOp-&gt;get_rhs_operand() == functionRefExp_copy);</a>
<a name="19728"><span class="lineNum">   19728 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="19729"><span class="lineNum">   19729 </span>            :                                    SgType* type = lhs-&gt;get_type();</a>
<a name="19730"><span class="lineNum">   19730 </span>            :                                    ROSE_ASSERT(type != NULL);</a>
<a name="19731"><span class="lineNum">   19731 </span>            : #if 0</a>
<a name="19732"><span class="lineNum">   19732 </span>            :                                    printf (&quot;type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="19733"><span class="lineNum">   19733 </span>            : #endif</a>
<a name="19734"><span class="lineNum">   19734 </span>            :                                    SgNamedType* namedType = isSgNamedType(type);</a>
<a name="19735"><span class="lineNum">   19735 </span>            :                                    ROSE_ASSERT(namedType != NULL);</a>
<a name="19736"><span class="lineNum">   19736 </span>            :                                    SgDeclarationStatement* declaration = namedType-&gt;get_declaration();</a>
<a name="19737"><span class="lineNum">   19737 </span>            :                                    ROSE_ASSERT(declaration != NULL);</a>
<a name="19738"><span class="lineNum">   19738 </span>            :                                    SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);</a>
<a name="19739"><span class="lineNum">   19739 </span>            :                                    ROSE_ASSERT(classDeclaration != NULL);</a>
<a name="19740"><span class="lineNum">   19740 </span>            :                                    SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(declaration-&gt;get_definingDeclaration());</a>
<a name="19741"><span class="lineNum">   19741 </span>            :                                    ROSE_ASSERT(definingClassDeclaration != NULL);</a>
<a name="19742"><span class="lineNum">   19742 </span>            :                                    SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</a>
<a name="19743"><span class="lineNum">   19743 </span>            :                                    ROSE_ASSERT(classDefinition != NULL);</a>
<a name="19744"><span class="lineNum">   19744 </span>            : #if 0</a>
<a name="19745"><span class="lineNum">   19745 </span>            :                                    printf (&quot;case V_SgClassDeclaration: classDefinition = %p = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str());</a>
<a name="19746"><span class="lineNum">   19746 </span>            : #endif</a>
<a name="19747"><span class="lineNum">   19747 </span>            :                                 // I think we want the copy.</a>
<a name="19748"><span class="lineNum">   19748 </span>            :                                    otherPossibleScope_original = classDefinition;</a>
<a name="19749"><span class="lineNum">   19749 </span>            : </a>
<a name="19750"><span class="lineNum">   19750 </span>            :                                    functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(functionSymbol_copy-&gt;get_name(),otherPossibleScope_original);</a>
<a name="19751"><span class="lineNum">   19751 </span>            :                                  }</a>
<a name="19752"><span class="lineNum">   19752 </span>            :                             }</a>
<a name="19753"><span class="lineNum">   19753 </span>            : </a>
<a name="19754"><span class="lineNum">   19754 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="19755"><span class="lineNum">   19755 </span>            :                          ROSE_ASSERT(functionSymbolInTargetAST != NULL);</a>
<a name="19756"><span class="lineNum">   19756 </span>            :                          SgFunctionDeclaration* functionDeclaration = functionSymbolInTargetAST-&gt;get_declaration();</a>
<a name="19757"><span class="lineNum">   19757 </span>            :                          ROSE_ASSERT(functionDeclaration != NULL);</a>
<a name="19758"><span class="lineNum">   19758 </span>            :                          SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</a>
<a name="19759"><span class="lineNum">   19759 </span>            :                          ROSE_ASSERT(scope != NULL);</a>
<a name="19760"><span class="lineNum">   19760 </span>            : </a>
<a name="19761"><span class="lineNum">   19761 </span>            :                       // Is this the correct scope?</a>
<a name="19762"><span class="lineNum">   19762 </span>            :                          functionDeclaration-&gt;set_scope(scope);</a>
<a name="19763"><span class="lineNum">   19763 </span>            : #endif</a>
<a name="19764"><span class="lineNum">   19764 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="19765"><span class="lineNum">   19765 </span>            : </a>
<a name="19766"><span class="lineNum">   19766 </span>            :                       // Insert the symbol into the targetScope.</a>
<a name="19767"><span class="lineNum">   19767 </span>            :                          targetScope-&gt;insert_symbol(functionSymbol_copy-&gt;get_name(),functionSymbolInTargetAST);</a>
<a name="19768"><span class="lineNum">   19768 </span>            :                        }</a>
<a name="19769"><span class="lineNum">   19769 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionSymbolInTargetAST != NULL);</span></a>
<a name="19770"><span class="lineNum">   19770 </span>            : </a>
<a name="19771"><span class="lineNum">   19771 </span>            :                  // Reset the symbol associated with this function reference.</a>
<a name="19772"><span class="lineNum">   19772 </span><span class="lineNoCov">          0 :                     functionRefExp_copy-&gt;set_symbol(functionSymbolInTargetAST);</span></a>
<a name="19773"><span class="lineNum">   19773 </span>            : #if 0</a>
<a name="19774"><span class="lineNum">   19774 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="19775"><span class="lineNum">   19775 </span>            :                     ROSE_ABORT();</a>
<a name="19776"><span class="lineNum">   19776 </span>            : #endif</a>
<a name="19777"><span class="lineNum">   19777 </span>            :                   }</a>
<a name="19778"><span class="lineNum">   19778 </span>            : </a>
<a name="19779"><span class="lineNum">   19779 </span>            :                break;</a>
<a name="19780"><span class="lineNum">   19780 </span>            :              }</a>
<a name="19781"><span class="lineNum">   19781 </span>            : </a>
<a name="19782"><span class="lineNum">   19782 </span>            : #define DEBUG_MEMBER_FUNCTION_REF_EXP 0</a>
<a name="19783"><span class="lineNum">   19783 </span>            : </a>
<a name="19784"><span class="lineNum">   19784 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionRefExp:</span></a>
<a name="19785"><span class="lineNum">   19785 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="19786"><span class="lineNum">   19786 </span>            :             // Need to handle the referenced symbol</a>
<a name="19787"><span class="lineNum">   19787 </span><span class="lineNoCov">          0 :                SgMemberFunctionRefExp* memberFunctionRefExp_copy = isSgMemberFunctionRefExp(node_copy);</span></a>
<a name="19788"><span class="lineNum">   19788 </span><span class="lineNoCov">          0 :                SgMemberFunctionRefExp* memberFunctionRefExp_original = isSgMemberFunctionRefExp(node_original);</span></a>
<a name="19789"><span class="lineNum">   19789 </span><span class="lineNoCov">          0 :                SgMemberFunctionSymbol* memberFunctionSymbol_copy = isSgMemberFunctionSymbol(memberFunctionRefExp_copy-&gt;get_symbol());</span></a>
<a name="19790"><span class="lineNum">   19790 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(memberFunctionSymbol_copy != NULL);</span></a>
<a name="19791"><span class="lineNum">   19791 </span>            :             // if (TransformationSupport::getFile(memberFunctionSymbol) != targetFile)</a>
<a name="19792"><span class="lineNum">   19792 </span><span class="lineNoCov">          0 :                if (getEnclosingFileNode(memberFunctionSymbol_copy) != targetFile)</span></a>
<a name="19793"><span class="lineNum">   19793 </span>            :                   {</a>
<a name="19794"><span class="lineNum">   19794 </span>            :                  // Not implemented (initial work is focused on C, then Java, then C++.</a>
<a name="19795"><span class="lineNum">   19795 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19796"><span class="lineNum">   19796 </span>            :                     printf (&quot;Warning: case V_SgMemberFunctionRefExp: memberFunctionSymbol_copy not in target file (find member function = %s) \n&quot;,memberFunctionSymbol_copy-&gt;get_name().str());</a>
<a name="19797"><span class="lineNum">   19797 </span>            : #endif</a>
<a name="19798"><span class="lineNum">   19798 </span><span class="lineNoCov">          0 :                     SgMemberFunctionSymbol* memberFunctionSymbolInTargetAST = isSgMemberFunctionSymbol(lookupFunctionSymbolInParentScopes(memberFunctionSymbol_copy-&gt;get_name(),targetScope));</span></a>
<a name="19799"><span class="lineNum">   19799 </span>            : </a>
<a name="19800"><span class="lineNum">   19800 </span><span class="lineNoCov">          0 :                     if (memberFunctionSymbolInTargetAST == NULL)</span></a>
<a name="19801"><span class="lineNum">   19801 </span>            :                        {</a>
<a name="19802"><span class="lineNum">   19802 </span>            :                       // This is a violation of the policy that the a variable with the same name will be found in the target AST.</a>
<a name="19803"><span class="lineNum">   19803 </span>            :                       // Note that if the variable could not be found then it should have been added as part of the snippet, or a</a>
<a name="19804"><span class="lineNum">   19804 </span>            :                       // previously added snippet.</a>
<a name="19805"><span class="lineNum">   19805 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19806"><span class="lineNum">   19806 </span>            :                          printf (&quot;Error: The associated memberFunction_copy = %s should have been found in a parent scope of the target AST \n&quot;,memberFunctionSymbol_copy-&gt;get_name().str());</a>
<a name="19807"><span class="lineNum">   19807 </span>            : #endif</a>
<a name="19808"><span class="lineNum">   19808 </span>            :                       // DQ (3/10/2014): This is important for member functions in Java and C++.</a>
<a name="19809"><span class="lineNum">   19809 </span>            : </a>
<a name="19810"><span class="lineNum">   19810 </span>            :                       // If could be that the symbol is in the local scope of the snippet AST.</a>
<a name="19811"><span class="lineNum">   19811 </span><span class="lineNoCov">          0 :                          SgStatement* enclosingStatement_original = TransformationSupport::getStatement(memberFunctionRefExp_original);</span></a>
<a name="19812"><span class="lineNum">   19812 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enclosingStatement_original != NULL);</span></a>
<a name="19813"><span class="lineNum">   19813 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19814"><span class="lineNum">   19814 </span>            :                          printf (&quot;case V_SgMemberFunctionRefExp: enclosingStatement_original = %p = %s \n&quot;,enclosingStatement_original,enclosingStatement_original-&gt;class_name().c_str());</a>
<a name="19815"><span class="lineNum">   19815 </span>            : #endif</a>
<a name="19816"><span class="lineNum">   19816 </span><span class="lineNoCov">          0 :                          SgScopeStatement* otherPossibleScope_original = isSgScopeStatement(enclosingStatement_original-&gt;get_parent());</span></a>
<a name="19817"><span class="lineNum">   19817 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(otherPossibleScope_original != NULL);</span></a>
<a name="19818"><span class="lineNum">   19818 </span>            :                       // SgFile* file = TransformationSupport::getFile(enclosingStatement_original);</a>
<a name="19819"><span class="lineNum">   19819 </span><span class="lineNoCov">          0 :                          SgFile* file = getEnclosingFileNode(enclosingStatement_original);</span></a>
<a name="19820"><span class="lineNum">   19820 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(file != NULL);</span></a>
<a name="19821"><span class="lineNum">   19821 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19822"><span class="lineNum">   19822 </span>            :                          printf (&quot;enclosingStatement_original: associated file name = %s \n&quot;,file-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19823"><span class="lineNum">   19823 </span>            :                       // printf (&quot;   --- targetFile            = %p = %s \n&quot;,targetFile,targetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="19824"><span class="lineNum">   19824 </span>            : </a>
<a name="19825"><span class="lineNum">   19825 </span>            :                          printf (&quot;case V_SgClassDeclaration: otherPossibleScope = %p = %s \n&quot;,otherPossibleScope_original,otherPossibleScope_original-&gt;class_name().c_str());</a>
<a name="19826"><span class="lineNum">   19826 </span>            :                          printf (&quot;case V_SgClassDeclaration: memberFunctionSymbol_copy-&gt;get_name() = %s \n&quot;,memberFunctionSymbol_copy-&gt;get_name().str());</a>
<a name="19827"><span class="lineNum">   19827 </span>            : #endif</a>
<a name="19828"><span class="lineNum">   19828 </span><span class="lineNoCov">          0 :                          memberFunctionSymbolInTargetAST = isSgMemberFunctionSymbol(lookupFunctionSymbolInParentScopes(memberFunctionSymbol_copy-&gt;get_name(),otherPossibleScope_original));</span></a>
<a name="19829"><span class="lineNum">   19829 </span><span class="lineNoCov">          0 :                          if (memberFunctionSymbolInTargetAST == NULL)</span></a>
<a name="19830"><span class="lineNum">   19830 </span>            :                             {</a>
<a name="19831"><span class="lineNum">   19831 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19832"><span class="lineNum">   19832 </span>            :                               printf (&quot;Backup and look for the associated class and then look for the member function in the class (assume non-friend function or Java member function) \n&quot;);</a>
<a name="19833"><span class="lineNum">   19833 </span>            : #endif</a>
<a name="19834"><span class="lineNum">   19834 </span>            :                            // Check for the case of a record reference (member function of class declaration).</a>
<a name="19835"><span class="lineNum">   19835 </span><span class="lineNoCov">          0 :                               SgExpression* parentExpression = isSgExpression(memberFunctionRefExp_copy-&gt;get_parent());</span></a>
<a name="19836"><span class="lineNum">   19836 </span>            : </a>
<a name="19837"><span class="lineNum">   19837 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(parentExpression != NULL);</span></a>
<a name="19838"><span class="lineNum">   19838 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19839"><span class="lineNum">   19839 </span>            :                               printf (&quot;parentExpression = %p = %s \n&quot;,parentExpression,parentExpression-&gt;class_name().c_str());</a>
<a name="19840"><span class="lineNum">   19840 </span>            : #endif</a>
<a name="19841"><span class="lineNum">   19841 </span><span class="lineNoCov">          0 :                               bool handle_as_java = false;</span></a>
<a name="19842"><span class="lineNum">   19842 </span><span class="lineNoCov">          0 :                               SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(parentExpression);</span></a>
<a name="19843"><span class="lineNum">   19843 </span><span class="lineNoCov">          0 :                               if (functionCallExp != NULL)</span></a>
<a name="19844"><span class="lineNum">   19844 </span>            :                                  {</a>
<a name="19845"><span class="lineNum">   19845 </span>            :                                 // Note that this is a Java specific organization of the SgMemberFunctionRefExp and the SgFunctionCallExp.</a>
<a name="19846"><span class="lineNum">   19846 </span>            :                                 // We might want to make this more uniform between C++ and Java later.</a>
<a name="19847"><span class="lineNum">   19847 </span><span class="lineNoCov">          0 :                                    handle_as_java = true;</span></a>
<a name="19848"><span class="lineNum">   19848 </span>            : </a>
<a name="19849"><span class="lineNum">   19849 </span><span class="lineNoCov">          0 :                                    SgExpression* parentOfFunctionCallExpression = isSgExpression(functionCallExp-&gt;get_parent());</span></a>
<a name="19850"><span class="lineNum">   19850 </span>            : </a>
<a name="19851"><span class="lineNum">   19851 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(parentOfFunctionCallExpression != NULL);</span></a>
<a name="19852"><span class="lineNum">   19852 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19853"><span class="lineNum">   19853 </span>            :                                    printf (&quot;parentOfFunctionCallExpression = %p = %s \n&quot;,parentOfFunctionCallExpression,parentOfFunctionCallExpression-&gt;class_name().c_str());</a>
<a name="19854"><span class="lineNum">   19854 </span>            : #endif</a>
<a name="19855"><span class="lineNum">   19855 </span><span class="lineNoCov">          0 :                                    parentExpression = parentOfFunctionCallExpression;</span></a>
<a name="19856"><span class="lineNum">   19856 </span>            :                                  }</a>
<a name="19857"><span class="lineNum">   19857 </span>            : </a>
<a name="19858"><span class="lineNum">   19858 </span><span class="lineNoCov">          0 :                               SgBinaryOp*   parentBinaryOp   = isSgBinaryOp(parentExpression);</span></a>
<a name="19859"><span class="lineNum">   19859 </span><span class="lineNoCov">          0 :                               SgDotExp*     parentDotExp     = isSgDotExp(parentExpression);</span></a>
<a name="19860"><span class="lineNum">   19860 </span><span class="lineNoCov">          0 :                               SgArrowExp*   parentArrowExp   = isSgArrowExp(parentExpression);</span></a>
<a name="19861"><span class="lineNum">   19861 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19862"><span class="lineNum">   19862 </span>            :                               printf (&quot;parentBinaryOp = %p \n&quot;,parentBinaryOp);</a>
<a name="19863"><span class="lineNum">   19863 </span>            :                               printf (&quot;parentDotExp   = %p \n&quot;,parentDotExp);</a>
<a name="19864"><span class="lineNum">   19864 </span>            :                               printf (&quot;parentArrowExp = %p \n&quot;,parentArrowExp);</a>
<a name="19865"><span class="lineNum">   19865 </span>            : #endif</a>
<a name="19866"><span class="lineNum">   19866 </span><span class="lineNoCov">          0 :                               if (parentDotExp != NULL || parentArrowExp != NULL)</span></a>
<a name="19867"><span class="lineNum">   19867 </span>            :                                  {</a>
<a name="19868"><span class="lineNum">   19868 </span>            :                                 // This is a data member reference, so it's scope is the associated data structure.</a>
<a name="19869"><span class="lineNum">   19869 </span><span class="lineNoCov">          0 :                                    SgExpression* lhs = parentBinaryOp-&gt;get_lhs_operand();</span></a>
<a name="19870"><span class="lineNum">   19870 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(lhs != NULL);</span></a>
<a name="19871"><span class="lineNum">   19871 </span>            : </a>
<a name="19872"><span class="lineNum">   19872 </span>            :                                 // This will be true for C++, but not Java (a little odd).</a>
<a name="19873"><span class="lineNum">   19873 </span><span class="lineNoCov">          0 :                                    if (handle_as_java == true)</span></a>
<a name="19874"><span class="lineNum">   19874 </span>            :                                       {</a>
<a name="19875"><span class="lineNum">   19875 </span>            :                                      // The rhs is the SgFunctionCallExp for Java.</a>
<a name="19876"><span class="lineNum">   19876 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(parentBinaryOp-&gt;get_rhs_operand() == functionCallExp);</span></a>
<a name="19877"><span class="lineNum">   19877 </span>            :                                       }</a>
<a name="19878"><span class="lineNum">   19878 </span>            :                                      else</a>
<a name="19879"><span class="lineNum">   19879 </span>            :                                       {</a>
<a name="19880"><span class="lineNum">   19880 </span>            :                                      // This is what we expect to be true for C++.</a>
<a name="19881"><span class="lineNum">   19881 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(parentBinaryOp-&gt;get_rhs_operand() == memberFunctionRefExp_copy);</span></a>
<a name="19882"><span class="lineNum">   19882 </span>            :                                       }</a>
<a name="19883"><span class="lineNum">   19883 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19884"><span class="lineNum">   19884 </span>            :                                    printf (&quot;lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="19885"><span class="lineNum">   19885 </span>            : #endif</a>
<a name="19886"><span class="lineNum">   19886 </span><span class="lineNoCov">          0 :                                    SgVarRefExp* varRefExp = isSgVarRefExp(lhs);</span></a>
<a name="19887"><span class="lineNum">   19887 </span>            : </a>
<a name="19888"><span class="lineNum">   19888 </span>            :                                 // DQ (3/15/2014): This can be a SgJavaTypeExpression (see testJava3a).</a>
<a name="19889"><span class="lineNum">   19889 </span>            :                                 // ROSE_ASSERT(varRefExp != NULL);</a>
<a name="19890"><span class="lineNum">   19890 </span><span class="lineNoCov">          0 :                                    if (varRefExp != NULL)</span></a>
<a name="19891"><span class="lineNum">   19891 </span>            :                                       {</a>
<a name="19892"><span class="lineNum">   19892 </span><span class="lineNoCov">          0 :                                         SgVariableSymbol* variableSymbol = isSgVariableSymbol(varRefExp-&gt;get_symbol());</span></a>
<a name="19893"><span class="lineNum">   19893 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="19894"><span class="lineNum">   19894 </span><span class="lineNoCov">          0 :                                         SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="19895"><span class="lineNum">   19895 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="19896"><span class="lineNum">   19896 </span>            : </a>
<a name="19897"><span class="lineNum">   19897 </span><span class="lineNoCov">          0 :                                         SgType* initializedName_type = initializedName-&gt;get_type();</span></a>
<a name="19898"><span class="lineNum">   19898 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19899"><span class="lineNum">   19899 </span>            :                                         printf (&quot;initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="19900"><span class="lineNum">   19900 </span>            :                                         printf (&quot;initializedName_type = %p \n&quot;,initializedName_type);</a>
<a name="19901"><span class="lineNum">   19901 </span>            : #endif</a>
<a name="19902"><span class="lineNum">   19902 </span><span class="lineNoCov">          0 :                                         SgClassType* classType = isSgClassType(initializedName_type);</span></a>
<a name="19903"><span class="lineNum">   19903 </span><span class="lineNoCov">          0 :                                         if (classType != NULL)</span></a>
<a name="19904"><span class="lineNum">   19904 </span>            :                                            {</a>
<a name="19905"><span class="lineNum">   19905 </span><span class="lineNoCov">          0 :                                              SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="19906"><span class="lineNum">   19906 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="19907"><span class="lineNum">   19907 </span><span class="lineNoCov">          0 :                                              SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="19908"><span class="lineNum">   19908 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="19909"><span class="lineNum">   19909 </span><span class="lineNoCov">          0 :                                              printf (&quot;definingClassDeclaration-&gt;get_name() = %s \n&quot;,definingClassDeclaration-&gt;get_name().str());</span></a>
<a name="19910"><span class="lineNum">   19910 </span>            : </a>
<a name="19911"><span class="lineNum">   19911 </span><span class="lineNoCov">          0 :                                              SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="19912"><span class="lineNum">   19912 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="19913"><span class="lineNum">   19913 </span><span class="lineNoCov">          0 :                                              SgType* memberFunctionType = memberFunctionSymbol_copy-&gt;get_type();</span></a>
<a name="19914"><span class="lineNum">   19914 </span><span class="lineNoCov">          0 :                                              SgName memberFunctionName  = memberFunctionSymbol_copy-&gt;get_name();</span></a>
<a name="19915"><span class="lineNum">   19915 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(memberFunctionType != NULL);</span></a>
<a name="19916"><span class="lineNum">   19916 </span><span class="lineNoCov">          0 :                                              SgFunctionSymbol *functionSymbol = classDefinition-&gt;lookup_function_symbol(memberFunctionName,memberFunctionType);</span></a>
<a name="19917"><span class="lineNum">   19917 </span><span class="lineNoCov">          0 :                                              if (functionSymbol == NULL)</span></a>
<a name="19918"><span class="lineNum">   19918 </span>            :                                                 {</a>
<a name="19919"><span class="lineNum">   19919 </span><span class="lineNoCov">          0 :                                                   printf (&quot;Symbol not found: output symbol table (size = %d): \n&quot;,classDefinition-&gt;get_symbol_table()-&gt;size());</span></a>
<a name="19920"><span class="lineNum">   19920 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19921"><span class="lineNum">   19921 </span>            :                                                   classDefinition-&gt;get_symbol_table()-&gt;print(&quot;Symbol not found: output symbol table: SgClassDefinition&quot;);</a>
<a name="19922"><span class="lineNum">   19922 </span>            : #endif</a>
<a name="19923"><span class="lineNum">   19923 </span>            :                                                // DQ (3/30/2014): If functionSymbol is not found then I think it is because the class was not availalbe</a>
<a name="19924"><span class="lineNum">   19924 </span>            :                                                // in the target where the snippet is being copied.  This is an error in the constrains for how the target</a>
<a name="19925"><span class="lineNum">   19925 </span>            :                                                // must be prepared for the snippet to be copied into it.</a>
<a name="19926"><span class="lineNum">   19926 </span><span class="lineNoCov">          0 :                                                   printf (&quot;\n*************************************************************** \n&quot;);</span></a>
<a name="19927"><span class="lineNum">   19927 </span><span class="lineNoCov">          0 :                                                   printf (&quot;ERROR: target has not be properly setup to receive the snippet. \n&quot;);</span></a>
<a name="19928"><span class="lineNum">   19928 </span><span class="lineNoCov">          0 :                                                   printf (&quot;*************************************************************** \n&quot;);</span></a>
<a name="19929"><span class="lineNum">   19929 </span>            :                                                 }</a>
<a name="19930"><span class="lineNum">   19930 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="19931"><span class="lineNum">   19931 </span><span class="lineNoCov">          0 :                                              SgMemberFunctionSymbol *memberFunctionSymbol = isSgMemberFunctionSymbol(functionSymbol);</span></a>
<a name="19932"><span class="lineNum">   19932 </span><span class="lineNoCov">          0 :                                              ROSE_ASSERT(memberFunctionSymbol != NULL);</span></a>
<a name="19933"><span class="lineNum">   19933 </span>            : </a>
<a name="19934"><span class="lineNum">   19934 </span><span class="lineNoCov">          0 :                                              memberFunctionSymbolInTargetAST = memberFunctionSymbol;</span></a>
<a name="19935"><span class="lineNum">   19935 </span>            : #if 0</a>
<a name="19936"><span class="lineNum">   19936 </span>            :                                              printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="19937"><span class="lineNum">   19937 </span>            :                                              ROSE_ABORT();</a>
<a name="19938"><span class="lineNum">   19938 </span>            : #endif</a>
<a name="19939"><span class="lineNum">   19939 </span>            :                                            }</a>
<a name="19940"><span class="lineNum">   19940 </span>            :                                       }</a>
<a name="19941"><span class="lineNum">   19941 </span>            : </a>
<a name="19942"><span class="lineNum">   19942 </span>            :                                 // DQ (3/30/2014): If this is a value expression then calling the member function uses a shared</a>
<a name="19943"><span class="lineNum">   19943 </span>            :                                 // symbol from the global scope (or a type defined deep in the global scope, but common to the</a>
<a name="19944"><span class="lineNum">   19944 </span>            :                                 // snippet AST and the target AST).</a>
<a name="19945"><span class="lineNum">   19945 </span><span class="lineNoCov">          0 :                                    SgValueExp* valueExp = isSgValueExp(lhs);</span></a>
<a name="19946"><span class="lineNum">   19946 </span><span class="lineNoCov">          0 :                                    if (valueExp != NULL)</span></a>
<a name="19947"><span class="lineNum">   19947 </span>            :                                       {</a>
<a name="19948"><span class="lineNum">   19948 </span><span class="lineNoCov">          0 :                                         memberFunctionSymbolInTargetAST = memberFunctionSymbol_copy;</span></a>
<a name="19949"><span class="lineNum">   19949 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);</span></a>
<a name="19950"><span class="lineNum">   19950 </span>            :                                       }</a>
<a name="19951"><span class="lineNum">   19951 </span>            : </a>
<a name="19952"><span class="lineNum">   19952 </span><span class="lineNoCov">          0 :                                    if (memberFunctionSymbolInTargetAST == NULL)</span></a>
<a name="19953"><span class="lineNum">   19953 </span>            :                                       {</a>
<a name="19954"><span class="lineNum">   19954 </span>            : #if 1</a>
<a name="19955"><span class="lineNum">   19955 </span><span class="lineNoCov">          0 :                                         SgType* type = lhs-&gt;get_type();</span></a>
<a name="19956"><span class="lineNum">   19956 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(type != NULL);</span></a>
<a name="19957"><span class="lineNum">   19957 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19958"><span class="lineNum">   19958 </span>            :                                         printf (&quot;type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="19959"><span class="lineNum">   19959 </span>            : #endif</a>
<a name="19960"><span class="lineNum">   19960 </span><span class="lineNoCov">          0 :                                         SgNamedType* namedType = isSgNamedType(type);</span></a>
<a name="19961"><span class="lineNum">   19961 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(namedType != NULL);</span></a>
<a name="19962"><span class="lineNum">   19962 </span><span class="lineNoCov">          0 :                                         SgDeclarationStatement* declaration = namedType-&gt;get_declaration();</span></a>
<a name="19963"><span class="lineNum">   19963 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(declaration != NULL);</span></a>
<a name="19964"><span class="lineNum">   19964 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);</span></a>
<a name="19965"><span class="lineNum">   19965 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="19966"><span class="lineNum">   19966 </span><span class="lineNoCov">          0 :                                         SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(declaration-&gt;get_definingDeclaration());</span></a>
<a name="19967"><span class="lineNum">   19967 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="19968"><span class="lineNum">   19968 </span><span class="lineNoCov">          0 :                                         SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="19969"><span class="lineNum">   19969 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="19970"><span class="lineNum">   19970 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19971"><span class="lineNum">   19971 </span>            :                                         printf (&quot;case V_SgClassDeclaration: classDefinition = %p = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str());</a>
<a name="19972"><span class="lineNum">   19972 </span>            : #endif</a>
<a name="19973"><span class="lineNum">   19973 </span>            :                                      // I think we want the copy.</a>
<a name="19974"><span class="lineNum">   19974 </span><span class="lineNoCov">          0 :                                         otherPossibleScope_original = classDefinition;</span></a>
<a name="19975"><span class="lineNum">   19975 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19976"><span class="lineNum">   19976 </span>            :                                         classDefinition-&gt;get_symbol_table()-&gt;print(&quot;Java classDefinition&quot;);</a>
<a name="19977"><span class="lineNum">   19977 </span>            : #endif</a>
<a name="19978"><span class="lineNum">   19978 </span>            : #if DEBUG_MEMBER_FUNCTION_REF_EXP</a>
<a name="19979"><span class="lineNum">   19979 </span>            :                                         SgClassDeclaration* associated_classDeclaration = classDefinition-&gt;get_declaration();</a>
<a name="19980"><span class="lineNum">   19980 </span>            :                                         SgFunctionSymbol* functionSymbol = lookupFunctionSymbolInParentScopes(memberFunctionSymbol_copy-&gt;get_name(),otherPossibleScope_original);</a>
<a name="19981"><span class="lineNum">   19981 </span>            :                                         printf (&quot;associated_classDeclaration = %p name = %s \n&quot;,associated_classDeclaration,associated_classDeclaration-&gt;get_name().str());</a>
<a name="19982"><span class="lineNum">   19982 </span>            :                                         printf (&quot;functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="19983"><span class="lineNum">   19983 </span>            : #endif</a>
<a name="19984"><span class="lineNum">   19984 </span><span class="lineNoCov">          0 :                                         memberFunctionSymbolInTargetAST = isSgMemberFunctionSymbol(lookupFunctionSymbolInParentScopes(memberFunctionSymbol_copy-&gt;get_name(),otherPossibleScope_original));</span></a>
<a name="19985"><span class="lineNum">   19985 </span><span class="lineNoCov">          0 :                                         if (memberFunctionSymbolInTargetAST == NULL)</span></a>
<a name="19986"><span class="lineNum">   19986 </span>            :                                            {</a>
<a name="19987"><span class="lineNum">   19987 </span>            :                                           // Output debugging info (16 of the CWE injection test codes fail here: see test_results.txt file for details).</a>
<a name="19988"><span class="lineNum">   19988 </span><span class="lineNoCov">          0 :                                              printf (&quot;Error: (memberFunctionSymbolInTargetAST == NULL): memberFunctionSymbol_copy-&gt;get_name() = %s \n&quot;,memberFunctionSymbol_copy-&gt;get_name().str());</span></a>
<a name="19989"><span class="lineNum">   19989 </span>            :                                            }</a>
<a name="19990"><span class="lineNum">   19990 </span>            : #endif</a>
<a name="19991"><span class="lineNum">   19991 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);</span></a>
<a name="19992"><span class="lineNum">   19992 </span>            :                                       }</a>
<a name="19993"><span class="lineNum">   19993 </span><span class="lineNoCov">          0 :                                     ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);</span></a>
<a name="19994"><span class="lineNum">   19994 </span>            :                                  }</a>
<a name="19995"><span class="lineNum">   19995 </span>            :                             }</a>
<a name="19996"><span class="lineNum">   19996 </span>            : </a>
<a name="19997"><span class="lineNum">   19997 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);</span></a>
<a name="19998"><span class="lineNum">   19998 </span><span class="lineNoCov">          0 :                          SgFunctionDeclaration* functionDeclaration = memberFunctionSymbolInTargetAST-&gt;get_declaration();</span></a>
<a name="19999"><span class="lineNum">   19999 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="20000"><span class="lineNum">   20000 </span><span class="lineNoCov">          0 :                          SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</span></a>
<a name="20001"><span class="lineNum">   20001 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(scope != NULL);</span></a>
<a name="20002"><span class="lineNum">   20002 </span>            : </a>
<a name="20003"><span class="lineNum">   20003 </span>            :                       // Is this the correct scope?</a>
<a name="20004"><span class="lineNum">   20004 </span><span class="lineNoCov">          0 :                          functionDeclaration-&gt;set_scope(scope);</span></a>
<a name="20005"><span class="lineNum">   20005 </span>            :                        }</a>
<a name="20006"><span class="lineNum">   20006 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);</span></a>
<a name="20007"><span class="lineNum">   20007 </span>            : </a>
<a name="20008"><span class="lineNum">   20008 </span>            :                  // Reset the symbol associated with this function reference.</a>
<a name="20009"><span class="lineNum">   20009 </span><span class="lineNoCov">          0 :                     memberFunctionRefExp_copy-&gt;set_symbol(memberFunctionSymbolInTargetAST);</span></a>
<a name="20010"><span class="lineNum">   20010 </span>            :                   }</a>
<a name="20011"><span class="lineNum">   20011 </span>            : </a>
<a name="20012"><span class="lineNum">   20012 </span>            :                break;</a>
<a name="20013"><span class="lineNum">   20013 </span>            :              }</a>
<a name="20014"><span class="lineNum">   20014 </span>            : </a>
<a name="20015"><span class="lineNum">   20015 </span>            :        // DQ (3/21/2014): I think we need this.</a>
<a name="20016"><span class="lineNum">   20016 </span>            :           case V_SgTryStmt:</a>
<a name="20017"><span class="lineNum">   20017 </span>            :              {</a>
<a name="20018"><span class="lineNum">   20018 </span>            : #if 0</a>
<a name="20019"><span class="lineNum">   20019 </span>            :                printf (&quot;Exiting as a test! (SgTryStmt) \n&quot;);</a>
<a name="20020"><span class="lineNum">   20020 </span>            :                ROSE_ABORT();</a>
<a name="20021"><span class="lineNum">   20021 </span>            : #endif</a>
<a name="20022"><span class="lineNum">   20022 </span>            :                break;</a>
<a name="20023"><span class="lineNum">   20023 </span>            :              }</a>
<a name="20024"><span class="lineNum">   20024 </span>            : </a>
<a name="20025"><span class="lineNum">   20025 </span>            :        // DQ (3/19/2014): Just found this case in a few of the CWE Java snippet tests.</a>
<a name="20026"><span class="lineNum">   20026 </span>            :           case V_SgCatchStatementSeq:</a>
<a name="20027"><span class="lineNum">   20027 </span>            :              {</a>
<a name="20028"><span class="lineNum">   20028 </span>            :             // DQ (3/19/2014): Note sure that we need to handle this specific case.</a>
<a name="20029"><span class="lineNum">   20029 </span>            : </a>
<a name="20030"><span class="lineNum">   20030 </span>            : #if 0</a>
<a name="20031"><span class="lineNum">   20031 </span>            :                printf (&quot;Exiting as a test! (SgCatchStatementSeq) \n&quot;);</a>
<a name="20032"><span class="lineNum">   20032 </span>            :                ROSE_ABORT();</a>
<a name="20033"><span class="lineNum">   20033 </span>            : #endif</a>
<a name="20034"><span class="lineNum">   20034 </span>            :                break;</a>
<a name="20035"><span class="lineNum">   20035 </span>            :              }</a>
<a name="20036"><span class="lineNum">   20036 </span>            : </a>
<a name="20037"><span class="lineNum">   20037 </span>            :        // DQ (3/19/2014): Just found this case in a few of the CWE Java snippet tests.</a>
<a name="20038"><span class="lineNum">   20038 </span><span class="lineNoCov">          0 :           case V_SgCatchOptionStmt:</span></a>
<a name="20039"><span class="lineNum">   20039 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="20040"><span class="lineNum">   20040 </span>            :             // DQ (3/19/2014): Note sure that we need to handle this specific case.</a>
<a name="20041"><span class="lineNum">   20041 </span>            :             // Decide if we need to implement this newly identified case tomorrow (note that this is a SgScopeStatement).</a>
<a name="20042"><span class="lineNum">   20042 </span><span class="lineNoCov">          0 :                SgCatchOptionStmt* catchOptionStatement_copy     = isSgCatchOptionStmt(node_copy);</span></a>
<a name="20043"><span class="lineNum">   20043 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(catchOptionStatement_copy);</span></a>
<a name="20044"><span class="lineNum">   20044 </span>            : </a>
<a name="20045"><span class="lineNum">   20045 </span><span class="lineNoCov">          0 :                printf (&quot;Need to check the symbol table of the SgCatchOptionStmt (which is a SgScopeStatement) \n&quot;);</span></a>
<a name="20046"><span class="lineNum">   20046 </span>            : </a>
<a name="20047"><span class="lineNum">   20047 </span>            : #if 0</a>
<a name="20048"><span class="lineNum">   20048 </span>            :                printf (&quot;Exiting as a test! (SgCatchOptionStmt) \n&quot;);</a>
<a name="20049"><span class="lineNum">   20049 </span>            :                ROSE_ABORT();</a>
<a name="20050"><span class="lineNum">   20050 </span>            : #endif</a>
<a name="20051"><span class="lineNum">   20051 </span>            :                break;</a>
<a name="20052"><span class="lineNum">   20052 </span>            :              }</a>
<a name="20053"><span class="lineNum">   20053 </span>            : </a>
<a name="20054"><span class="lineNum">   20054 </span><span class="lineNoCov">          0 :           case V_SgEnumVal:</span></a>
<a name="20055"><span class="lineNum">   20055 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="20056"><span class="lineNum">   20056 </span>            :             // SgEnumVal expressions contain a reference to the associated SgEnumDeclaration, so this may have to be updated.</a>
<a name="20057"><span class="lineNum">   20057 </span>            : #if 0</a>
<a name="20058"><span class="lineNum">   20058 </span>            :                printf (&quot;enum values contain a reference to the associated SgEnumDeclaration \n&quot;);</a>
<a name="20059"><span class="lineNum">   20059 </span>            : #endif</a>
<a name="20060"><span class="lineNum">   20060 </span><span class="lineNoCov">          0 :                SgEnumVal* enumVal_copy     = isSgEnumVal(node_copy);</span></a>
<a name="20061"><span class="lineNum">   20061 </span><span class="lineNoCov">          0 :                SgEnumVal* enumVal_original = isSgEnumVal(node_original);</span></a>
<a name="20062"><span class="lineNum">   20062 </span>            : #if 0</a>
<a name="20063"><span class="lineNum">   20063 </span>            :                printf (&quot;   --- enumVal_original = %p = %d name = %s \n&quot;,enumVal_original,enumVal_original-&gt;get_value(),enumVal_original-&gt;get_name().str());</a>
<a name="20064"><span class="lineNum">   20064 </span>            : #endif</a>
<a name="20065"><span class="lineNum">   20065 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* associatedEnumDeclaration_copy     = isSgEnumDeclaration(enumVal_copy-&gt;get_declaration());</span></a>
<a name="20066"><span class="lineNum">   20066 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* associatedEnumDeclaration_original = isSgEnumDeclaration(enumVal_original-&gt;get_declaration());</span></a>
<a name="20067"><span class="lineNum">   20067 </span>            : </a>
<a name="20068"><span class="lineNum">   20068 </span>            :             // DQ (4/13/2014): check if this is an un-named enum beclaration.</a>
<a name="20069"><span class="lineNum">   20069 </span><span class="lineNoCov">          0 :                bool isUnNamed = associatedEnumDeclaration_original-&gt;get_isUnNamed();</span></a>
<a name="20070"><span class="lineNum">   20070 </span><span class="lineNoCov">          0 :                if (isUnNamed == false)</span></a>
<a name="20071"><span class="lineNum">   20071 </span>            :                   {</a>
<a name="20072"><span class="lineNum">   20072 </span><span class="lineNoCov">          0 :                     if (associatedEnumDeclaration_copy == associatedEnumDeclaration_original)</span></a>
<a name="20073"><span class="lineNum">   20073 </span>            :                        {</a>
<a name="20074"><span class="lineNum">   20074 </span>            : #if 0</a>
<a name="20075"><span class="lineNum">   20075 </span>            :                          printf (&quot;   --- The stored reference to the enum declaration in the SgEnumVal must be reset \n&quot;);</a>
<a name="20076"><span class="lineNum">   20076 </span>            : #endif</a>
<a name="20077"><span class="lineNum">   20077 </span>            :                       // SgSymbol* SageBuilder::findAssociatedSymbolInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope)</a>
<a name="20078"><span class="lineNum">   20078 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = findAssociatedSymbolInTargetAST(associatedEnumDeclaration_original,targetScope);</span></a>
<a name="20079"><span class="lineNum">   20079 </span><span class="lineNoCov">          0 :                          if (symbol == NULL)</span></a>
<a name="20080"><span class="lineNum">   20080 </span>            :                             {</a>
<a name="20081"><span class="lineNum">   20081 </span>            :                            // debug this case.</a>
<a name="20082"><span class="lineNum">   20082 </span><span class="lineNoCov">          0 :                               enumVal_original-&gt;get_file_info()-&gt;display(&quot;case V_SgEnumVal: symbol == NULL: debug&quot;);</span></a>
<a name="20083"><span class="lineNum">   20083 </span>            :                             }</a>
<a name="20084"><span class="lineNum">   20084 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="20085"><span class="lineNum">   20085 </span><span class="lineNoCov">          0 :                          SgEnumSymbol* enumSymbol = isSgEnumSymbol(symbol);</span></a>
<a name="20086"><span class="lineNum">   20086 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(enumSymbol != NULL);</span></a>
<a name="20087"><span class="lineNum">   20087 </span><span class="lineNoCov">          0 :                          SgEnumDeclaration* new_associatedEnumDeclaration_copy = enumSymbol-&gt;get_declaration();</span></a>
<a name="20088"><span class="lineNum">   20088 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_associatedEnumDeclaration_copy != NULL);</span></a>
<a name="20089"><span class="lineNum">   20089 </span>            : </a>
<a name="20090"><span class="lineNum">   20090 </span>            :                       // If this is false then in means that we should have built a new SgEnumSymbol instead of reusing the existing one from the snippet.</a>
<a name="20091"><span class="lineNum">   20091 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_associatedEnumDeclaration_copy != associatedEnumDeclaration_original);// TV (10/22/2014): with project wide global scope this will always be false because 'symbol' is resolve to the first-non-defn-decl in original scope</span></a>
<a name="20092"><span class="lineNum">   20092 </span>            :                       // ROSE_ASSERT(new_associatedEnumDeclaration_copy != associatedEnumDeclaration_original-&gt;get_firstNondefiningDeclaration());</a>
<a name="20093"><span class="lineNum">   20093 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(new_associatedEnumDeclaration_copy != associatedEnumDeclaration_original-&gt;get_definingDeclaration());</span></a>
<a name="20094"><span class="lineNum">   20094 </span>            : </a>
<a name="20095"><span class="lineNum">   20095 </span><span class="lineNoCov">          0 :                          enumVal_copy-&gt;set_declaration(new_associatedEnumDeclaration_copy);</span></a>
<a name="20096"><span class="lineNum">   20096 </span>            : #if 0</a>
<a name="20097"><span class="lineNum">   20097 </span>            :                          printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="20098"><span class="lineNum">   20098 </span>            :                          ROSE_ABORT();</a>
<a name="20099"><span class="lineNum">   20099 </span>            : #endif</a>
<a name="20100"><span class="lineNum">   20100 </span>            :                        }</a>
<a name="20101"><span class="lineNum">   20101 </span>            :                   }</a>
<a name="20102"><span class="lineNum">   20102 </span>            :                  else</a>
<a name="20103"><span class="lineNum">   20103 </span>            :                   {</a>
<a name="20104"><span class="lineNum">   20104 </span>            :                  // DQ (4/13/2014): I think we all agreed these would not have to be handled, so issue a warning.</a>
<a name="20105"><span class="lineNum">   20105 </span>            :                  // It still is likely that I can allow this, but permit this intermediate fix.</a>
<a name="20106"><span class="lineNum">   20106 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: can't handle enum values from unnamed enum declarations \n&quot;);</span></a>
<a name="20107"><span class="lineNum">   20107 </span><span class="lineNoCov">          0 :                     printf (&quot;   --- enumVal_original = %p = %lld name = %s \n&quot;,enumVal_original,enumVal_original-&gt;get_value(),enumVal_original-&gt;get_name().str());</span></a>
<a name="20108"><span class="lineNum">   20108 </span>            :                   }</a>
<a name="20109"><span class="lineNum">   20109 </span>            : </a>
<a name="20110"><span class="lineNum">   20110 </span>            :                break;</a>
<a name="20111"><span class="lineNum">   20111 </span>            :              }</a>
<a name="20112"><span class="lineNum">   20112 </span>            : </a>
<a name="20113"><span class="lineNum">   20113 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="20114"><span class="lineNum">   20114 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="20115"><span class="lineNum">   20115 </span>            :             // Most IR nodes do not require specialized fixup (are not processed).</a>
<a name="20116"><span class="lineNum">   20116 </span>            :              }</a>
<a name="20117"><span class="lineNum">   20117 </span>            :         }</a>
<a name="20118"><span class="lineNum">   20118 </span>            : </a>
<a name="20119"><span class="lineNum">   20119 </span>            : #if 1</a>
<a name="20120"><span class="lineNum">   20120 </span>            :   // DQ (3/17/2014): Cause failure on warnings about any constructs referencing the snippet AST.</a>
<a name="20121"><span class="lineNum">   20121 </span>            : #if 0</a>
<a name="20122"><span class="lineNum">   20122 </span>            :   // Assert fail on warnings.</a>
<a name="20123"><span class="lineNum">   20123 </span>            :      errorCheckingTargetAST(node_copy,node_original,targetFile, true);</a>
<a name="20124"><span class="lineNum">   20124 </span>            : #else</a>
<a name="20125"><span class="lineNum">   20125 </span>            :   // Cause only warnings.</a>
<a name="20126"><span class="lineNum">   20126 </span><span class="lineNoCov">          0 :      errorCheckingTargetAST(node_copy,node_original,targetFile, false);</span></a>
<a name="20127"><span class="lineNum">   20127 </span>            : #endif</a>
<a name="20128"><span class="lineNum">   20128 </span>            : #endif</a>
<a name="20129"><span class="lineNum">   20129 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="20130"><span class="lineNum">   20130 </span>            : </a>
<a name="20131"><span class="lineNum">   20131 </span>            : </a>
<a name="20132"><span class="lineNum">   20132 </span>            : void</a>
<a name="20133"><span class="lineNum">   20133 </span><span class="lineNoCov">          0 : SageBuilder::fixupCopyOfAstFromSeparateFileInNewTargetAst(SgStatement *insertionPoint, bool insertionPointIsScope,</span></a>
<a name="20134"><span class="lineNum">   20134 </span>            :                                                           SgStatement *toInsert, SgStatement* original_before_copy)</a>
<a name="20135"><span class="lineNum">   20135 </span>            :    {</a>
<a name="20136"><span class="lineNum">   20136 </span>            :   // The semantics of the copy is that it will have been disconnected from the snippet AST in a few ways,</a>
<a name="20137"><span class="lineNum">   20137 </span>            :   // Namely the root of the copy of the snippet's AST will have been set with a NULL parent, and then</a>
<a name="20138"><span class="lineNum">   20138 </span>            :   // the parent would have been reset when the copy of the snippet was inserted into the target AST.</a>
<a name="20139"><span class="lineNum">   20139 </span>            :   // So a simple traversal of parents back to the SgFile will return the target AST's SgFile (confirmed below).</a>
<a name="20140"><span class="lineNum">   20140 </span>            : </a>
<a name="20141"><span class="lineNum">   20141 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(insertionPoint != NULL);</span></a>
<a name="20142"><span class="lineNum">   20142 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(toInsert != NULL);</span></a>
<a name="20143"><span class="lineNum">   20143 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(original_before_copy != NULL);</span></a>
<a name="20144"><span class="lineNum">   20144 </span>            : </a>
<a name="20145"><span class="lineNum">   20145 </span>            :   // DQ (3/30/2014): Turn this on to support finding symbols in base classes (in Java).</a>
<a name="20146"><span class="lineNum">   20146 </span>            :   // Will be turned off at the base of this function (since we only only want to use it for the AST fixup, currently).</a>
<a name="20147"><span class="lineNum">   20147 </span><span class="lineNoCov">          0 :      SgSymbolTable::set_force_search_of_base_classes(true);</span></a>
<a name="20148"><span class="lineNum">   20148 </span>            : </a>
<a name="20149"><span class="lineNum">   20149 </span>            :   // DQ (3/4/2014): Switch to using the SageInterface function.</a>
<a name="20150"><span class="lineNum">   20150 </span>            :   // SgFile* targetFile = TransformationSupport::getFile(insertionPoint);</a>
<a name="20151"><span class="lineNum">   20151 </span><span class="lineNoCov">          0 :      SgFile* targetFile = getEnclosingFileNode(insertionPoint);</span></a>
<a name="20152"><span class="lineNum">   20152 </span>            : </a>
<a name="20153"><span class="lineNum">   20153 </span>            :   // For Java support this might be NULL, if the insertion point was in global scope.</a>
<a name="20154"><span class="lineNum">   20154 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(targetFile != NULL);</span></a>
<a name="20155"><span class="lineNum">   20155 </span>            : </a>
<a name="20156"><span class="lineNum">   20156 </span>            :   // SgFile* snippetFile_of_copy = TransformationSupport::getFile(toInsert);</a>
<a name="20157"><span class="lineNum">   20157 </span><span class="lineNoCov">          0 :      SgFile* snippetFile_of_copy = getEnclosingFileNode(toInsert);</span></a>
<a name="20158"><span class="lineNum">   20158 </span>            : </a>
<a name="20159"><span class="lineNum">   20159 </span>            :   // At this point the parent pointers are set so that the same SgFile is found via a traversal back to the SgProject.</a>
<a name="20160"><span class="lineNum">   20160 </span>            :   // Confirm that the SgFile found by a traversal of parents in the copy of rthe snippet's AST will return that of the</a>
<a name="20161"><span class="lineNum">   20161 </span>            :   // SgFile for the target AST.  This also confirms that the copy of the snippet has already been inserted into the</a>
<a name="20162"><span class="lineNum">   20162 </span>            :   // target AST.</a>
<a name="20163"><span class="lineNum">   20163 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(snippetFile_of_copy == targetFile);</span></a>
<a name="20164"><span class="lineNum">   20164 </span>            : </a>
<a name="20165"><span class="lineNum">   20165 </span>            :   // SgFile* snippetFile_of_original = TransformationSupport::getFile(original_before_copy);</a>
<a name="20166"><span class="lineNum">   20166 </span><span class="lineNoCov">          0 :      SgFile* snippetFile_of_original = getEnclosingFileNode(original_before_copy);</span></a>
<a name="20167"><span class="lineNum">   20167 </span>            : </a>
<a name="20168"><span class="lineNum">   20168 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(snippetFile_of_original != targetFile);</span></a>
<a name="20169"><span class="lineNum">   20169 </span>            : </a>
<a name="20170"><span class="lineNum">   20170 </span>            : #if 0</a>
<a name="20171"><span class="lineNum">   20171 </span>            :      printf (&quot;   --- targetFile              = %p = %s \n&quot;,targetFile,targetFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="20172"><span class="lineNum">   20172 </span>            :      printf (&quot;   --- snippetFile_of_copy     = %p = %s \n&quot;,snippetFile_of_copy,snippetFile_of_copy-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="20173"><span class="lineNum">   20173 </span>            :      printf (&quot;   --- snippetFile_of_original = %p = %s \n&quot;,snippetFile_of_original,snippetFile_of_original-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="20174"><span class="lineNum">   20174 </span>            : #endif</a>
<a name="20175"><span class="lineNum">   20175 </span>            : </a>
<a name="20176"><span class="lineNum">   20176 </span>            :   // Any node that has entries not referenced in the target file needs to be fixed up.</a>
<a name="20177"><span class="lineNum">   20177 </span>            :   // We can assume that any referenced variable or function that is referenced in the</a>
<a name="20178"><span class="lineNum">   20178 </span>            :   // snippet will exist in either the snippet or the target file.</a>
<a name="20179"><span class="lineNum">   20179 </span>            : </a>
<a name="20180"><span class="lineNum">   20180 </span>            :   // DQ (3/4/2014): This is a test of the structural equality of the original snippet and it's copy.</a>
<a name="20181"><span class="lineNum">   20181 </span>            :   // If they are different then we can't support fixing up the AST.  Transformations on the snippet</a>
<a name="20182"><span class="lineNum">   20182 </span>            :   // should have been made after insertion into the AST.  The complexity of this test is a traversal</a>
<a name="20183"><span class="lineNum">   20183 </span>            :   // of the copy of the snippet to be inserted (typically very small compared to the target application).</a>
<a name="20184"><span class="lineNum">   20184 </span><span class="lineNoCov">          0 :      bool isStructurallyEquivalent = isStructurallyEquivalentAST(toInsert,original_before_copy);</span></a>
<a name="20185"><span class="lineNum">   20185 </span><span class="lineNoCov">          0 :      if (isStructurallyEquivalent == false)</span></a>
<a name="20186"><span class="lineNum">   20186 </span>            :         {</a>
<a name="20187"><span class="lineNum">   20187 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: The copy of the snippet is a different size than the original snippet (don't do transformations on the copy before inserting into the target AST). \n&quot;);</span></a>
<a name="20188"><span class="lineNum">   20188 </span><span class="lineNoCov">          0 :           return;</span></a>
<a name="20189"><span class="lineNum">   20189 </span>            :         }</a>
<a name="20190"><span class="lineNum">   20190 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isStructurallyEquivalent == true);</span></a>
<a name="20191"><span class="lineNum">   20191 </span>            : </a>
<a name="20192"><span class="lineNum">   20192 </span>            : #ifndef USE_CMAKEx</a>
<a name="20193"><span class="lineNum">   20193 </span>            :   // DQ (3/8/2014): Make this conditionally compiled based on when CMake is not used because the libraries are not configured yet.</a>
<a name="20194"><span class="lineNum">   20194 </span>            : </a>
<a name="20195"><span class="lineNum">   20195 </span>            :   // This is AST container for the ROSE AST that will provide an iterator.</a>
<a name="20196"><span class="lineNum">   20196 </span>            :   // We want two iterators (one for the copy of the snippet and one for the</a>
<a name="20197"><span class="lineNum">   20197 </span>            :   // original snippet so that we can query the original snippet's AST</a>
<a name="20198"><span class="lineNum">   20198 </span>            :   // as we process each IR node of the AST for the copy of the snippet.</a>
<a name="20199"><span class="lineNum">   20199 </span>            :   // Only the copy of the snippet is inserted into the target AST.</a>
<a name="20200"><span class="lineNum">   20200 </span><span class="lineNoCov">          0 :      RoseAst ast_of_copy(toInsert);</span></a>
<a name="20201"><span class="lineNum">   20201 </span><span class="lineNoCov">          0 :      RoseAst ast_of_original(original_before_copy);</span></a>
<a name="20202"><span class="lineNum">   20202 </span>            : </a>
<a name="20203"><span class="lineNum">   20203 </span>            :   // printf (&quot;ast_of_copy.size() = %&quot; PRIuPTR &quot; \n&quot;,ast_of_copy.size());</a>
<a name="20204"><span class="lineNum">   20204 </span>            : </a>
<a name="20205"><span class="lineNum">   20205 </span>            :   // Build the iterators so that we can increment thorugh both ASTs one IR node at a time.</a>
<a name="20206"><span class="lineNum">   20206 </span><span class="lineNoCov">          0 :      RoseAst::iterator i_copy     = ast_of_copy.begin();</span></a>
<a name="20207"><span class="lineNum">   20207 </span><span class="lineNoCov">          0 :      RoseAst::iterator i_original = ast_of_original.begin();</span></a>
<a name="20208"><span class="lineNum">   20208 </span>            : </a>
<a name="20209"><span class="lineNum">   20209 </span>            :   // Iterate of the copy of the snippet's AST.</a>
<a name="20210"><span class="lineNum">   20210 </span><span class="lineNoCov">          0 :      while (i_copy != ast_of_copy.end())</span></a>
<a name="20211"><span class="lineNum">   20211 </span>            :         {</a>
<a name="20212"><span class="lineNum">   20212 </span>            :        // DQ (2/28/2014): This is a problem for some of the test codes (TEST   store/load heap string [test7a] and [test7a])</a>
<a name="20213"><span class="lineNum">   20213 </span>            :        // ROSE_ASSERT((*i_copy)-&gt;variantT() == (*i_original)-&gt;variantT());</a>
<a name="20214"><span class="lineNum">   20214 </span><span class="lineNoCov">          0 :           if ((*i_copy)-&gt;variantT() != (*i_original)-&gt;variantT())</span></a>
<a name="20215"><span class="lineNum">   20215 </span>            :              {</a>
<a name="20216"><span class="lineNum">   20216 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: return from fixupCopyOfAstFromSeparateFileInNewTargetAst(): &quot;</span></a>
<a name="20217"><span class="lineNum">   20217 </span>            :                        &quot;(*i_copy)-&gt;variantT() != (*i_original)-&gt;variantT() \n&quot;);</a>
<a name="20218"><span class="lineNum">   20218 </span>            : #if 1</a>
<a name="20219"><span class="lineNum">   20219 </span><span class="lineNoCov">          0 :                printf (&quot;Making this an error! \n&quot;);</span></a>
<a name="20220"><span class="lineNum">   20220 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="20221"><span class="lineNum">   20221 </span>            : #endif</a>
<a name="20222"><span class="lineNum">   20222 </span>            :                return;</a>
<a name="20223"><span class="lineNum">   20223 </span>            :              }</a>
<a name="20224"><span class="lineNum">   20224 </span>            : </a>
<a name="20225"><span class="lineNum">   20225 </span>            :        // Operate on individual IR nodes.</a>
<a name="20226"><span class="lineNum">   20226 </span><span class="lineNoCov">          0 :           fixupCopyOfNodeFromSeparateFileInNewTargetAst(insertionPoint, insertionPointIsScope, *i_copy, *i_original);</span></a>
<a name="20227"><span class="lineNum">   20227 </span>            : </a>
<a name="20228"><span class="lineNum">   20228 </span><span class="lineNoCov">          0 :           i_copy++;</span></a>
<a name="20229"><span class="lineNum">   20229 </span>            : </a>
<a name="20230"><span class="lineNum">   20230 </span>            :        // Verify that we have not reached the end of the ast for the original (both the</a>
<a name="20231"><span class="lineNum">   20231 </span>            :        // copy and the original are the same structurally, and thus the same size).</a>
<a name="20232"><span class="lineNum">   20232 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(i_original != ast_of_original.end());</span></a>
<a name="20233"><span class="lineNum">   20233 </span><span class="lineNoCov">          0 :           i_original++;</span></a>
<a name="20234"><span class="lineNum">   20234 </span>            :         }</a>
<a name="20235"><span class="lineNum">   20235 </span>            : </a>
<a name="20236"><span class="lineNum">   20236 </span>            :   // We have reached the end of both ASTs.</a>
<a name="20237"><span class="lineNum">   20237 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(i_copy == ast_of_copy.end() &amp;&amp; i_original == ast_of_original.end());</span></a>
<a name="20238"><span class="lineNum">   20238 </span>            : </a>
<a name="20239"><span class="lineNum">   20239 </span>            :   // DQ (3/8/2014): ENDIF: Make this conditionally compiled based on when CMake is not used because the libraries are not configured yet.</a>
<a name="20240"><span class="lineNum">   20240 </span>            : #endif</a>
<a name="20241"><span class="lineNum">   20241 </span>            : </a>
<a name="20242"><span class="lineNum">   20242 </span>            : #if 0</a>
<a name="20243"><span class="lineNum">   20243 </span>            :      if (functionDeclaration != NULL)</a>
<a name="20244"><span class="lineNum">   20244 </span>            :         {</a>
<a name="20245"><span class="lineNum">   20245 </span>            :           printf (&quot;functionDeclaration = %s \n&quot;,functionDeclaration-&gt;get_name().str());</a>
<a name="20246"><span class="lineNum">   20246 </span>            : #if 0</a>
<a name="20247"><span class="lineNum">   20247 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="20248"><span class="lineNum">   20248 </span>            :           ROSE_ABORT();</a>
<a name="20249"><span class="lineNum">   20249 </span>            : #endif</a>
<a name="20250"><span class="lineNum">   20250 </span>            :         }</a>
<a name="20251"><span class="lineNum">   20251 </span>            : #endif</a>
<a name="20252"><span class="lineNum">   20252 </span>            : </a>
<a name="20253"><span class="lineNum">   20253 </span>            :   // DQ (3/30/2014): Turn this off (since we only only want to use it for the AST fixup, currently).</a>
<a name="20254"><span class="lineNum">   20254 </span><span class="lineNoCov">          0 :      SgSymbolTable::set_force_search_of_base_classes(false);</span></a>
<a name="20255"><span class="lineNum">   20255 </span>            :    }</a>
<a name="20256"><span class="lineNum">   20256 </span>            : </a>
<a name="20257"><span class="lineNum">   20257 </span>            : // Liao 9/18/2015</a>
<a name="20258"><span class="lineNum">   20258 </span>            : // The parser is implemented in</a>
<a name="20259"><span class="lineNum">   20259 </span>            : // src/frontend/SageIII/astFromString/AstFromString.h .C</a>
<a name="20260"><span class="lineNum">   20260 </span><span class="lineCov">         14 : SgStatement* SageBuilder::buildStatementFromString(const std::string&amp; s, SgScopeStatement * scope)</span></a>
<a name="20261"><span class="lineNum">   20261 </span>            : {</a>
<a name="20262"><span class="lineNum">   20262 </span>            : </a>
<a name="20263"><span class="lineNum">   20263 </span><span class="lineCov">         14 :   SgStatement* result = NULL;</span></a>
<a name="20264"><span class="lineNum">   20264 </span><span class="lineCov">         14 :   ROSE_ASSERT (scope != NULL);</span></a>
<a name="20265"><span class="lineNum">   20265 </span>            :   // set input and context for the parser</a>
<a name="20266"><span class="lineNum">   20266 </span><span class="lineCov">         14 :   AstFromString::c_char = s.c_str();</span></a>
<a name="20267"><span class="lineNum">   20267 </span><span class="lineCov">         14 :   assert (AstFromString::c_char== s.c_str());</span></a>
<a name="20268"><span class="lineNum">   20268 </span><span class="lineCov">         14 :   AstFromString::c_sgnode = scope;</span></a>
<a name="20269"><span class="lineNum">   20269 </span><span class="lineCov">         14 :   AstFromString::c_parsed_node = NULL;</span></a>
<a name="20270"><span class="lineNum">   20270 </span>            : </a>
<a name="20271"><span class="lineNum">   20271 </span><span class="lineCov">         14 :   if (AstFromString::afs_match_statement())</span></a>
<a name="20272"><span class="lineNum">   20272 </span>            :   {</a>
<a name="20273"><span class="lineNum">   20273 </span><span class="lineCov">         14 :     result = isSgStatement(AstFromString::c_parsed_node); // grab the result</span></a>
<a name="20274"><span class="lineNum">   20274 </span><span class="lineCov">         14 :     assert (result != NULL);</span></a>
<a name="20275"><span class="lineNum">   20275 </span>            :   }</a>
<a name="20276"><span class="lineNum">   20276 </span>            :   else</a>
<a name="20277"><span class="lineNum">   20277 </span>            :   {</a>
<a name="20278"><span class="lineNum">   20278 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error. buildStatementFromString() cannot parse the input string:&quot;&lt;&lt;s</span></a>
<a name="20279"><span class="lineNum">   20279 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;\n\t within the given scope:&quot;&lt;&lt;scope-&gt;class_name() &lt;&lt;endl;</span></a>
<a name="20280"><span class="lineNum">   20280 </span><span class="lineNoCov">          0 :     ROSE_ABORT();</span></a>
<a name="20281"><span class="lineNum">   20281 </span>            :   }</a>
<a name="20282"><span class="lineNum">   20282 </span><span class="lineCov">         14 :   return result;</span></a>
<a name="20283"><span class="lineNum">   20283 </span>            : }</a>
<a name="20284"><span class="lineNum">   20284 </span>            : </a>
<a name="20285"><span class="lineNum">   20285 </span><span class="lineNoCov">          0 : SgUsingDirectiveStatement* SageBuilder::buildUsingDirectiveStatement(SgNamespaceDeclarationStatement * ns_decl)</span></a>
<a name="20286"><span class="lineNum">   20286 </span>            : {</a>
<a name="20287"><span class="lineNum">   20287 </span><span class="lineNoCov">          0 :   SgUsingDirectiveStatement* res = new SgUsingDirectiveStatement(ns_decl);</span></a>
<a name="20288"><span class="lineNum">   20288 </span><span class="lineNoCov">          0 :   res-&gt;set_definingDeclaration(res);</span></a>
<a name="20289"><span class="lineNum">   20289 </span><span class="lineNoCov">          0 :   res-&gt;set_firstNondefiningDeclaration(res);</span></a>
<a name="20290"><span class="lineNum">   20290 </span>            : </a>
<a name="20291"><span class="lineNum">   20291 </span><span class="lineNoCov">          0 :   setOneSourcePositionForTransformation(res);</span></a>
<a name="20292"><span class="lineNum">   20292 </span><span class="lineNoCov">          0 :   return res; </span></a>
<a name="20293"><span class="lineNum">   20293 </span>            : }</a>
<a name="20294"><span class="lineNum">   20294 </span>            : </a>
<a name="20295"><span class="lineNum">   20295 </span>            : //</a>
<a name="20296"><span class="lineNum">   20296 </span>            : // pp (07/16/16)</a>
<a name="20297"><span class="lineNum">   20297 </span>            : // initial support for creating template instantiations</a>
<a name="20298"><span class="lineNum">   20298 </span>            : // from template declarations</a>
<a name="20299"><span class="lineNum">   20299 </span>            : </a>
<a name="20300"><span class="lineNum">   20300 </span>            : namespace {</a>
<a name="20301"><span class="lineNum">   20301 </span>            :   // internal functions</a>
<a name="20302"><span class="lineNum">   20302 </span>            : </a>
<a name="20303"><span class="lineNum">   20303 </span>            :   template &lt;class SgAstNode&gt;</a>
<a name="20304"><span class="lineNum">   20304 </span>            :   SgTemplateArgument* createTemplateArg_(SgAstNode&amp; n)</a>
<a name="20305"><span class="lineNum">   20305 </span>            :   {</a>
<a name="20306"><span class="lineNum">   20306 </span>            :     static const bool explicitlySpecified = true;</a>
<a name="20307"><span class="lineNum">   20307 </span>            : </a>
<a name="20308"><span class="lineNum">   20308 </span>            :     return new SgTemplateArgument(&amp;n, explicitlySpecified);</a>
<a name="20309"><span class="lineNum">   20309 </span>            :   }</a>
<a name="20310"><span class="lineNum">   20310 </span>            : </a>
<a name="20311"><span class="lineNum">   20311 </span>            :   SgTemplateArgument* createTemplateArg_(SgExpression&amp; n)</a>
<a name="20312"><span class="lineNum">   20312 </span>            :   {</a>
<a name="20313"><span class="lineNum">   20313 </span>            :     SgTemplateArgument* res = createTemplateArg_&lt;SgExpression&gt;(n);</a>
<a name="20314"><span class="lineNum">   20314 </span>            : </a>
<a name="20315"><span class="lineNum">   20315 </span>            :     n.set_parent(res);</a>
<a name="20316"><span class="lineNum">   20316 </span>            :     return res;</a>
<a name="20317"><span class="lineNum">   20317 </span>            :   }</a>
<a name="20318"><span class="lineNum">   20318 </span>            : </a>
<a name="20319"><span class="lineNum">   20319 </span>            :   SgTemplateArgument* createTemplateArg(SgNode&amp; n)</a>
<a name="20320"><span class="lineNum">   20320 </span>            :   {</a>
<a name="20321"><span class="lineNum">   20321 </span>            :     SgTemplateArgument* res = NULL;</a>
<a name="20322"><span class="lineNum">   20322 </span>            : </a>
<a name="20323"><span class="lineNum">   20323 </span>            :     if (isSgType(&amp;n))</a>
<a name="20324"><span class="lineNum">   20324 </span>            :       res = createTemplateArg_(*isSgType(&amp;n));</a>
<a name="20325"><span class="lineNum">   20325 </span>            :     else if (isSgExpression(&amp;n))</a>
<a name="20326"><span class="lineNum">   20326 </span>            :       res = createTemplateArg_(*isSgExpression(&amp;n));</a>
<a name="20327"><span class="lineNum">   20327 </span>            :     else</a>
<a name="20328"><span class="lineNum">   20328 </span>            :     {</a>
<a name="20329"><span class="lineNum">   20329 </span>            :       ROSE_ASSERT(isSgTemplateDeclaration(&amp;n));</a>
<a name="20330"><span class="lineNum">   20330 </span>            :       res = createTemplateArg_(*isSgTemplateDeclaration(&amp;n));</a>
<a name="20331"><span class="lineNum">   20331 </span>            :     }</a>
<a name="20332"><span class="lineNum">   20332 </span>            : </a>
<a name="20333"><span class="lineNum">   20333 </span>            :     ROSE_ASSERT(res);</a>
<a name="20334"><span class="lineNum">   20334 </span>            :     return res;</a>
<a name="20335"><span class="lineNum">   20335 </span>            :   }</a>
<a name="20336"><span class="lineNum">   20336 </span>            : #if 0</a>
<a name="20337"><span class="lineNum">   20337 </span>            :   SgName genTemplateName(SgName base, Rose_STL_Container&lt;SgNode*&gt;&amp; targs)</a>
<a name="20338"><span class="lineNum">   20338 </span>            :   {</a>
<a name="20339"><span class="lineNum">   20339 </span>            :     Rose_STL_Container&lt;SgNode*&gt;::iterator aa = targs.begin();</a>
<a name="20340"><span class="lineNum">   20340 </span>            :     Rose_STL_Container&lt;SgNode*&gt;::iterator zz = targs.begin();</a>
<a name="20341"><span class="lineNum">   20341 </span>            :     std::string                           name(base.getString());</a>
<a name="20342"><span class="lineNum">   20342 </span>            : </a>
<a name="20343"><span class="lineNum">   20343 </span>            :     name.append(&quot;&lt;&quot;);</a>
<a name="20344"><span class="lineNum">   20344 </span>            :     for ( ; aa != zz; ++aa) name.append((*aa)-&gt;unparseToString());</a>
<a name="20345"><span class="lineNum">   20345 </span>            :     name.append(&quot;&gt;&quot;);</a>
<a name="20346"><span class="lineNum">   20346 </span>            : </a>
<a name="20347"><span class="lineNum">   20347 </span>            :     return SgName(name);</a>
<a name="20348"><span class="lineNum">   20348 </span>            :   }</a>
<a name="20349"><span class="lineNum">   20349 </span>            : #endif</a>
<a name="20350"><span class="lineNum">   20350 </span><span class="lineNoCov">          0 :   SgTemplateArgumentPtrList genTemplateArgumentList(Rose_STL_Container&lt;SgNode*&gt;&amp; targs)</span></a>
<a name="20351"><span class="lineNum">   20351 </span>            :   {</a>
<a name="20352"><span class="lineNum">   20352 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt;::iterator aa = targs.begin();</span></a>
<a name="20353"><span class="lineNum">   20353 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt;::iterator zz = targs.begin();</span></a>
<a name="20354"><span class="lineNum">   20354 </span><span class="lineNoCov">          0 :     SgTemplateArgumentPtrList             lst;</span></a>
<a name="20355"><span class="lineNum">   20355 </span>            : </a>
<a name="20356"><span class="lineNum">   20356 </span><span class="lineNoCov">          0 :     for ( ; aa != zz; ++aa)</span></a>
<a name="20357"><span class="lineNum">   20357 </span>            :     {</a>
<a name="20358"><span class="lineNum">   20358 </span>            :       lst.push_back(createTemplateArg(**aa));</a>
<a name="20359"><span class="lineNum">   20359 </span>            :     }</a>
<a name="20360"><span class="lineNum">   20360 </span>            : </a>
<a name="20361"><span class="lineNum">   20361 </span><span class="lineNoCov">          0 :     return lst;</span></a>
<a name="20362"><span class="lineNum">   20362 </span>            :   }</a>
<a name="20363"><span class="lineNum">   20363 </span>            : </a>
<a name="20364"><span class="lineNum">   20364 </span><span class="lineNoCov">          0 :   SgTemplateClassDeclaration* getCanonicalTemplateDecl(SgTemplateClassDeclaration* main_decl)</span></a>
<a name="20365"><span class="lineNum">   20365 </span>            :   {</a>
<a name="20366"><span class="lineNum">   20366 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(main_decl);</span></a>
<a name="20367"><span class="lineNum">   20367 </span><span class="lineNoCov">          0 :     SgClassType*                ct    = main_decl-&gt;get_type();</span></a>
<a name="20368"><span class="lineNum">   20368 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(ct);</span></a>
<a name="20369"><span class="lineNum">   20369 </span><span class="lineNoCov">          0 :     SgDeclarationStatement*     decl  = ct-&gt;get_declaration();</span></a>
<a name="20370"><span class="lineNum">   20370 </span><span class="lineNoCov">          0 :     SgTemplateClassDeclaration* tdecl = isSgTemplateClassDeclaration(decl);</span></a>
<a name="20371"><span class="lineNum">   20371 </span>            : </a>
<a name="20372"><span class="lineNum">   20372 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(tdecl);</span></a>
<a name="20373"><span class="lineNum">   20373 </span><span class="lineNoCov">          0 :     return tdecl;</span></a>
<a name="20374"><span class="lineNum">   20374 </span>            :   }</a>
<a name="20375"><span class="lineNum">   20375 </span>            : </a>
<a name="20376"><span class="lineNum">   20376 </span><span class="lineNoCov">          0 :   SgTemplateInstantiationDecl* genTemplateInstantiationDecl(SgName tname, SgTemplateClassDeclaration* tclassdecl, SgTemplateArgumentPtrList targs)</span></a>
<a name="20377"><span class="lineNum">   20377 </span>            :   {</a>
<a name="20378"><span class="lineNum">   20378 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(tclassdecl);</span></a>
<a name="20379"><span class="lineNum">   20379 </span>            : </a>
<a name="20380"><span class="lineNum">   20380 </span><span class="lineNoCov">          0 :     SgTemplateInstantiationDecl* res = NULL;</span></a>
<a name="20381"><span class="lineNum">   20381 </span>            : </a>
<a name="20382"><span class="lineNum">   20382 </span><span class="lineNoCov">          0 :     res = new SgTemplateInstantiationDecl( tname,</span></a>
<a name="20383"><span class="lineNum">   20383 </span>            :                                            SgClassDeclaration::e_class,</a>
<a name="20384"><span class="lineNum">   20384 </span>            :                                            NULL /* SgClassType* type -- to be set later */,</a>
<a name="20385"><span class="lineNum">   20385 </span>            :                                            NULL /* SgClassDefinition* def -- to be set later */,</a>
<a name="20386"><span class="lineNum">   20386 </span>            :                                            tclassdecl,</a>
<a name="20387"><span class="lineNum">   20387 </span>            :                                            targs</a>
<a name="20388"><span class="lineNum">   20388 </span><span class="lineNoCov">          0 :                                          );</span></a>
<a name="20389"><span class="lineNum">   20389 </span>            : </a>
<a name="20390"><span class="lineNum">   20390 </span><span class="lineNoCov">          0 :     res-&gt;set_scope(tclassdecl-&gt;get_scope());</span></a>
<a name="20391"><span class="lineNum">   20391 </span><span class="lineNoCov">          0 :     res-&gt;set_templateName(tname); // \todo \pp create mangled name from tname</span></a>
<a name="20392"><span class="lineNum">   20392 </span><span class="lineNoCov">          0 :     res-&gt;set_firstNondefiningDeclaration(res);</span></a>
<a name="20393"><span class="lineNum">   20393 </span><span class="lineNoCov">          0 :     res-&gt;setForward(); // \pp set forward, since this is not a proper declaration</span></a>
<a name="20394"><span class="lineNum">   20394 </span><span class="lineNoCov">          0 :     return res;</span></a>
<a name="20395"><span class="lineNum">   20395 </span>            :   }</a>
<a name="20396"><span class="lineNum">   20396 </span>            : </a>
<a name="20397"><span class="lineNum">   20397 </span><span class="lineNoCov">          0 :   SgClassType* genTemplateClass(SgTemplateInstantiationDecl* tdecl)</span></a>
<a name="20398"><span class="lineNum">   20398 </span>            :   {</a>
<a name="20399"><span class="lineNum">   20399 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(tdecl);</span></a>
<a name="20400"><span class="lineNum">   20400 </span>            : </a>
<a name="20401"><span class="lineNum">   20401 </span><span class="lineNoCov">          0 :     return SgClassType::createType(tdecl);</span></a>
<a name="20402"><span class="lineNum">   20402 </span>            :   }</a>
<a name="20403"><span class="lineNum">   20403 </span>            : </a>
<a name="20404"><span class="lineNum">   20404 </span>            :   struct TemplateArgumentParentSetter</a>
<a name="20405"><span class="lineNum">   20405 </span>            :   {</a>
<a name="20406"><span class="lineNum">   20406 </span>            :     SgTemplateInstantiationDecl* parent;</a>
<a name="20407"><span class="lineNum">   20407 </span>            : </a>
<a name="20408"><span class="lineNum">   20408 </span><span class="lineNoCov">          0 :     TemplateArgumentParentSetter(SgTemplateInstantiationDecl* p)</span></a>
<a name="20409"><span class="lineNum">   20409 </span>            :     : parent(p)</a>
<a name="20410"><span class="lineNum">   20410 </span>            :     {}</a>
<a name="20411"><span class="lineNum">   20411 </span>            : </a>
<a name="20412"><span class="lineNum">   20412 </span><span class="lineNoCov">          0 :     void operator()(SgTemplateArgument* targ)</span></a>
<a name="20413"><span class="lineNum">   20413 </span>            :     {</a>
<a name="20414"><span class="lineNum">   20414 </span><span class="lineNoCov">          0 :       targ-&gt;set_parent(parent);</span></a>
<a name="20415"><span class="lineNum">   20415 </span>            :     }</a>
<a name="20416"><span class="lineNum">   20416 </span>            :   };</a>
<a name="20417"><span class="lineNum">   20417 </span>            : } /* anonymous namespace */</a>
<a name="20418"><span class="lineNum">   20418 </span>            : </a>
<a name="20419"><span class="lineNum">   20419 </span>            : </a>
<a name="20420"><span class="lineNum">   20420 </span>            : SgClassType*</a>
<a name="20421"><span class="lineNum">   20421 </span><span class="lineNoCov">          0 : SageBuilder::buildTemplateClassType(SgTemplateClassDeclaration* template_decl,</span></a>
<a name="20422"><span class="lineNum">   20422 </span>            : Rose_STL_Container&lt;SgNode *&gt;&amp; template_args)</a>
<a name="20423"><span class="lineNum">   20423 </span>            : {</a>
<a name="20424"><span class="lineNum">   20424 </span><span class="lineNoCov">          0 :    return buildClassTemplateType (template_decl,template_args);</span></a>
<a name="20425"><span class="lineNum">   20425 </span>            : }</a>
<a name="20426"><span class="lineNum">   20426 </span>            : </a>
<a name="20427"><span class="lineNum">   20427 </span>            : SgClassType*</a>
<a name="20428"><span class="lineNum">   20428 </span><span class="lineNoCov">          0 : SageBuilder::buildClassTemplateType(SgTemplateClassDeclaration* template_decl,</span></a>
<a name="20429"><span class="lineNum">   20429 </span>            : Rose_STL_Container&lt;SgNode *&gt;&amp; template_args)</a>
<a name="20430"><span class="lineNum">   20430 </span>            : {</a>
<a name="20431"><span class="lineNum">   20431 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(template_decl);</span></a>
<a name="20432"><span class="lineNum">   20432 </span>            : </a>
<a name="20433"><span class="lineNum">   20433 </span>            :   // create a template instantiation decl</a>
<a name="20434"><span class="lineNum">   20434 </span><span class="lineNoCov">          0 :   SgName                       name  = template_decl-&gt;get_name();</span></a>
<a name="20435"><span class="lineNum">   20435 </span>            :   // SgName                       tname  = genTemplateName(, template_args);</a>
<a name="20436"><span class="lineNum">   20436 </span><span class="lineNoCov">          0 :   SgTemplateArgumentPtrList    targs = genTemplateArgumentList(template_args);</span></a>
<a name="20437"><span class="lineNum">   20437 </span><span class="lineNoCov">          0 :   SgTemplateClassDeclaration*  tdecl = getCanonicalTemplateDecl(template_decl);</span></a>
<a name="20438"><span class="lineNum">   20438 </span><span class="lineNoCov">          0 :   SgTemplateInstantiationDecl* tinst = genTemplateInstantiationDecl(name, tdecl, targs);</span></a>
<a name="20439"><span class="lineNum">   20439 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tinst);</span></a>
<a name="20440"><span class="lineNum">   20440 </span>            : </a>
<a name="20441"><span class="lineNum">   20441 </span>            :   // create class type</a>
<a name="20442"><span class="lineNum">   20442 </span><span class="lineNoCov">          0 :   SgClassType*                 tclass = genTemplateClass(tinst);</span></a>
<a name="20443"><span class="lineNum">   20443 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(tclass);</span></a>
<a name="20444"><span class="lineNum">   20444 </span>            : </a>
<a name="20445"><span class="lineNum">   20445 </span>            :   // set remaining fields in the template instantiation decl</a>
<a name="20446"><span class="lineNum">   20446 </span><span class="lineNoCov">          0 :   tinst-&gt;set_type(tclass);</span></a>
<a name="20447"><span class="lineNum">   20447 </span><span class="lineNoCov">          0 :   tinst-&gt;set_definition(static_cast&lt;SgTemplateInstantiationDefn*&gt;(0)); /* \pp not sure what to set this to .. */</span></a>
<a name="20448"><span class="lineNum">   20448 </span>            : </a>
<a name="20449"><span class="lineNum">   20449 </span>            :   // set parent of template arguments</a>
<a name="20450"><span class="lineNum">   20450 </span><span class="lineNoCov">          0 :   std::for_each(targs.begin(), targs.end(), TemplateArgumentParentSetter(tinst)); //</span></a>
<a name="20451"><span class="lineNum">   20451 </span>            : </a>
<a name="20452"><span class="lineNum">   20452 </span><span class="lineNoCov">          0 :   return tclass;</span></a>
<a name="20453"><span class="lineNum">   20453 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
