<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_to_str.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/CxxFrontend/EDG/EDG_5.0/src</a> - il_to_str.c<span style="font-size: 80%;"> (source / <a href="il_to_str.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">517</td>
            <td class="headerCovTableEntry">2236</td>
            <td class="headerCovTableEntryLo">23.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntryLo">37.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /******************************************************************************</a>
<a name="2"><span class="lineNum">       2 </span>            : *                                                             \  ___  /       *</a>
<a name="3"><span class="lineNum">       3 </span>            : *                                                               /   \         *</a>
<a name="4"><span class="lineNum">       4 </span>            : * Edison Design Group C++/C Front End                        - | \^/ | -      *</a>
<a name="5"><span class="lineNum">       5 </span>            : *                                                               \   /         *</a>
<a name="6"><span class="lineNum">       6 </span>            : * Proprietary information of Edison Design Group Inc.         /  | |  \       *</a>
<a name="7"><span class="lineNum">       7 </span>            : * Copyright 1988-2018 Edison Design Group Inc.                   [_]          *</a>
<a name="8"><span class="lineNum">       8 </span>            : *                                                                             *</a>
<a name="9"><span class="lineNum">       9 </span>            : ******************************************************************************/</a>
<a name="10"><span class="lineNum">      10 </span>            : /*</a>
<a name="11"><span class="lineNum">      11 </span>            : </a>
<a name="12"><span class="lineNum">      12 </span>            : il_to_str.c -- Produce an external string-form representation for various</a>
<a name="13"><span class="lineNum">      13 </span>            :                IL entries.</a>
<a name="14"><span class="lineNum">      14 </span>            : </a>
<a name="15"><span class="lineNum">      15 </span>            : */</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : /* Header files common to all files. */</a>
<a name="18"><span class="lineNum">      18 </span>            : #include &quot;fe_common.h&quot;</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : #ifdef PCH_PRAGMA_GUARD</a>
<a name="21"><span class="lineNum">      21 </span>            : /* Mark the end of the sequence of headers subject to precompiled header</a>
<a name="22"><span class="lineNum">      22 </span>            :    processing. */</a>
<a name="23"><span class="lineNum">      23 </span>            : #pragma hdrstop</a>
<a name="24"><span class="lineNum">      24 </span>            : #endif /* ifdef PCH_PRAGMA_GUARD */</a>
<a name="25"><span class="lineNum">      25 </span>            : </a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : /* Macro that returns TRUE if the Microsoft form of output should</a>
<a name="28"><span class="lineNum">      28 </span>            :    be used for certain features. */</a>
<a name="29"><span class="lineNum">      29 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="30"><span class="lineNum">      30 </span>            : #define use_microsoft_form() (octl-&gt;gen_compilable_code ? \</a>
<a name="31"><span class="lineNum">      31 </span>            :                                       msvc_is_generated_code_target : \</a>
<a name="32"><span class="lineNum">      32 </span>            :                                       microsoft_mode)</a>
<a name="33"><span class="lineNum">      33 </span>            : #else /* !(BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) */</a>
<a name="34"><span class="lineNum">      34 </span>            : #define use_microsoft_form() microsoft_mode</a>
<a name="35"><span class="lineNum">      35 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="36"><span class="lineNum">      36 </span>            : /*lint -esym(750,use_microsoft_form)*/</a>
<a name="37"><span class="lineNum">      37 </span>            : </a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : /* Macro that returns TRUE if the GNU form of output should</a>
<a name="40"><span class="lineNum">      40 </span>            :    be used for certain features. */</a>
<a name="41"><span class="lineNum">      41 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="42"><span class="lineNum">      42 </span>            : #define use_gnu_form() (octl-&gt;gen_compilable_code ? \</a>
<a name="43"><span class="lineNum">      43 </span>            :                                 gcc_or_clang_is_generated_code_target : \</a>
<a name="44"><span class="lineNum">      44 </span>            :                                 gnu_mode)</a>
<a name="45"><span class="lineNum">      45 </span>            : #else /* !(BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) */</a>
<a name="46"><span class="lineNum">      46 </span>            : #define use_gnu_form() gnu_mode</a>
<a name="47"><span class="lineNum">      47 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="48"><span class="lineNum">      48 </span>            : /*lint -esym(750,use_gnu_form)*/</a>
<a name="49"><span class="lineNum">      49 </span>            : </a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : /* Macro that returns TRUE if the Sun form of output should</a>
<a name="52"><span class="lineNum">      52 </span>            :    be used for certain features. */</a>
<a name="53"><span class="lineNum">      53 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="54"><span class="lineNum">      54 </span>            : #define use_sun_form() (octl-&gt;gen_compilable_code ? \</a>
<a name="55"><span class="lineNum">      55 </span>            :                                 sun_is_generated_code_target : \</a>
<a name="56"><span class="lineNum">      56 </span>            :                                 sun_mode)</a>
<a name="57"><span class="lineNum">      57 </span>            : #else /* !(BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) */</a>
<a name="58"><span class="lineNum">      58 </span>            : #define use_sun_form() sun_mode</a>
<a name="59"><span class="lineNum">      59 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="60"><span class="lineNum">      60 </span>            : /*lint -esym(750,use_sun_form)*/</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            : /* Forward declarations. */</a>
<a name="64"><span class="lineNum">      64 </span>            : static void form_qualifier(a_scope_ptr                            scope,</a>
<a name="65"><span class="lineNum">      65 </span>            :                            an_il_to_str_output_control_block_ptr  octl);</a>
<a name="66"><span class="lineNum">      66 </span>            : static void form_expression(an_expr_node_ptr                      expr,</a>
<a name="67"><span class="lineNum">      67 </span>            :                             an_il_to_str_output_control_block_ptr octl);</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span><span class="lineCov">       4846 : void clear_il_to_str_output_control_block(</span></a>
<a name="71"><span class="lineNum">      71 </span>            :                                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="72"><span class="lineNum">      72 </span>            : /*</a>
<a name="73"><span class="lineNum">      73 </span>            : Clear an output control block to default values.</a>
<a name="74"><span class="lineNum">      74 </span>            : */</a>
<a name="75"><span class="lineNum">      75 </span>            : {</a>
<a name="76"><span class="lineNum">      76 </span><span class="lineCov">       4846 :   octl-&gt;output_str                = NULL;</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">       4846 :   octl-&gt;output_partial_token_str  = NULL;</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">       4846 :   octl-&gt;text_buffer               = NULL;</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">       4846 :   octl-&gt;output_name               = NULL;</span></a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">       4846 :   octl-&gt;output_template_name      = NULL;</span></a>
<a name="81"><span class="lineNum">      81 </span><span class="lineCov">       4846 :   octl-&gt;output_class_qualifier    = NULL;</span></a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">       4846 :   octl-&gt;output_enum_qualifier     = NULL;</span></a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">       4846 :   octl-&gt;output_temp_name          = NULL;</span></a>
<a name="84"><span class="lineNum">      84 </span><span class="lineCov">       4846 :   octl-&gt;output_func_declarator    = NULL;</span></a>
<a name="85"><span class="lineNum">      85 </span><span class="lineCov">       4846 :   octl-&gt;output_expression         = NULL;</span></a>
<a name="86"><span class="lineNum">      86 </span><span class="lineCov">       4846 :   octl-&gt;output_name_reference     = NULL;</span></a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">       4846 :   octl-&gt;output_attributes         = NULL;</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">       4846 :   octl-&gt;is_typedef_invisible      = NULL;</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">       4846 :   octl-&gt;has_unprotected_gt_or_comma_operation = NULL;</span></a>
<a name="90"><span class="lineNum">      90 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">       4846 :   octl-&gt;func_prototype_stack      = NULL;</span></a>
<a name="92"><span class="lineNum">      92 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="93"><span class="lineNum">      93 </span><span class="lineCov">       4846 :   octl-&gt;gen_compilable_code       = FALSE;</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">       4846 :   octl-&gt;gen_pcc_code              = FALSE;</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">       4846 :   octl-&gt;suppress_typedefs         = FALSE;</span></a>
<a name="96"><span class="lineNum">      96 </span><span class="lineCov">       4846 :   octl-&gt;suppress_local_typedefs   = FALSE;</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">       4846 :   octl-&gt;render_c99_bool           = FALSE;</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">       4846 :   octl-&gt;c_generating_back_end     = FALSE;</span></a>
<a name="99"><span class="lineNum">      99 </span>            : #if DEBUG</a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">       4846 :   octl-&gt;debug_output              = FALSE;</span></a>
<a name="101"><span class="lineNum">     101 </span>            : #endif /* DEBUG */</a>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">       4846 :   octl-&gt;force_qualified_name      = FALSE;</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineCov">       4846 :   octl-&gt;gen_vla_array_as_asterisk_bound_array = FALSE;</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineCov">       4846 :   octl-&gt;gen_raw_tab_in_literals   = FALSE;</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineCov">       4846 :   octl-&gt;remove_template_typedefs  = FALSE;</span></a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">       4846 :   octl-&gt;suppress_line_breaking    = FALSE;</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">       4846 :   octl-&gt;suppress_cast_on_short_integral_const = FALSE;</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">       4846 :   octl-&gt;suppress_name_in_template_cast_enum_const = FALSE;</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">       4846 :   octl-&gt;render_auto_deduction_typerefs = FALSE;</span></a>
<a name="110"><span class="lineNum">     110 </span>            : #if GNU_VECTOR_TYPES_ALLOWED</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">       4846 :   octl-&gt;defer_vector_attribute    = FALSE;</span></a>
<a name="112"><span class="lineNum">     112 </span>            : #endif /* GNU_VECTOR_TYPES_ALLOWED */</a>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">       4846 :   octl-&gt;suppress_template_args    = FALSE;</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">       4846 :   octl-&gt;suppress_ptr_to_data_member_parens = FALSE;</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineCov">       4846 :   octl-&gt;suppress_compiler_generated_parameters = FALSE;</span></a>
<a name="116"><span class="lineNum">     116 </span><span class="lineCov">       4846 :   octl-&gt;processing_nontype_template_argument = FALSE;</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineCov">       4846 :   octl-&gt;part_of_ud_literal        = FALSE;</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">       4846 :   octl-&gt;pending_right_paren       = FALSE;</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">       4846 : }  /* clear_il_to_str_output_control_block */</span></a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span>            : /*</a>
<a name="123"><span class="lineNum">     123 </span>            : Macro that is TRUE if debug output is being generated.</a>
<a name="124"><span class="lineNum">     124 </span>            : */</a>
<a name="125"><span class="lineNum">     125 </span>            : #if DEBUG</a>
<a name="126"><span class="lineNum">     126 </span>            : #define generating_debug_output(octl) ((octl)-&gt;debug_output)</a>
<a name="127"><span class="lineNum">     127 </span>            : #else /* !DEBUG */</a>
<a name="128"><span class="lineNum">     128 </span>            : #define generating_debug_output(octl) (FALSE) /*lint --e(506)*/</a>
<a name="129"><span class="lineNum">     129 </span>            : #endif /* DEBUG */</a>
<a name="130"><span class="lineNum">     130 </span>            : </a>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<a name="132"><span class="lineNum">     132 </span><span class="lineCov">      20207 : static void output_partial_token_str(</span></a>
<a name="133"><span class="lineNum">     133 </span>            :                                     a_const_char                          *str,</a>
<a name="134"><span class="lineNum">     134 </span>            :                                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="135"><span class="lineNum">     135 </span>            : /*</a>
<a name="136"><span class="lineNum">     136 </span>            : Output the null-terminated string str in the way indicated by octl.</a>
<a name="137"><span class="lineNum">     137 </span>            : The string may be only part of a token.</a>
<a name="138"><span class="lineNum">     138 </span>            : */</a>
<a name="139"><span class="lineNum">     139 </span>            : {</a>
<a name="140"><span class="lineNum">     140 </span><span class="lineCov">      20207 :   an_output_str_function_ptr rout;</span></a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            :   /* See if there's a special routine for partial token output.  If so, use</a>
<a name="143"><span class="lineNum">     143 </span>            :      it.  If not, use the output_str routine. */</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineCov">      20207 :   rout = octl-&gt;output_partial_token_str;</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">      20207 :   if (rout == NULL) rout = octl-&gt;output_str;</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineCov">      19686 :   rout(str, octl);</span></a>
<a name="147"><span class="lineNum">     147 </span><span class="lineCov">        543 : }  /* output_partial_token_str */</span></a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="150"><span class="lineNum">     150 </span>            : </a>
<a name="151"><span class="lineNum">     151 </span>            : static void output_temp_name(char                                  *entry,</a>
<a name="152"><span class="lineNum">     152 </span>            :                              an_il_to_str_output_control_block_ptr octl)</a>
<a name="153"><span class="lineNum">     153 </span>            : /*</a>
<a name="154"><span class="lineNum">     154 </span>            : Output a compiler-generated temporary name based on &quot;entry&quot;.  Do this by</a>
<a name="155"><span class="lineNum">     155 </span>            : using a callback routine provided for this purpose.  Do the output as</a>
<a name="156"><span class="lineNum">     156 </span>            : indicated by octl.</a>
<a name="157"><span class="lineNum">     157 </span>            : */</a>
<a name="158"><span class="lineNum">     158 </span>            : {</a>
<a name="159"><span class="lineNum">     159 </span>            :   an_output_temp_name_function_ptr rout;</a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            :   rout = octl-&gt;output_temp_name;</a>
<a name="162"><span class="lineNum">     162 </span>            :   check_assertion_str(rout != NULL, &quot;output_temp_name: no routine provided&quot;);</a>
<a name="163"><span class="lineNum">     163 </span>            :   rout(entry);</a>
<a name="164"><span class="lineNum">     164 </span>            : }  /* output_temp_name */</a>
<a name="165"><span class="lineNum">     165 </span>            : </a>
<a name="166"><span class="lineNum">     166 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 : static void form_num(a_host_large_integer                  num,</span></a>
<a name="169"><span class="lineNum">     169 </span>            :                      an_il_to_str_output_control_block_ptr octl)</a>
<a name="170"><span class="lineNum">     170 </span>            : /*</a>
<a name="171"><span class="lineNum">     171 </span>            : Output a signed number as indicated by octl.</a>
<a name="172"><span class="lineNum">     172 </span>            : */</a>
<a name="173"><span class="lineNum">     173 </span>            : {</a>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :   char buffer[50];</span></a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :   (void)signed_to_string_buf(num, buffer);</span></a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(buffer, octl);</span></a>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 : }  /* form_num */</span></a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            : </a>
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 : static void form_unsigned_num(a_host_large_unsigned                 num,</span></a>
<a name="182"><span class="lineNum">     182 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="183"><span class="lineNum">     183 </span>            : /*</a>
<a name="184"><span class="lineNum">     184 </span>            : Output an unsigned number as indicated by octl.</a>
<a name="185"><span class="lineNum">     185 </span>            : */</a>
<a name="186"><span class="lineNum">     186 </span>            : {</a>
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :   char buffer[50];</span></a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span><span class="lineNoCov">          0 :   (void)unsigned_to_string_buf(num, buffer);</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(buffer, octl);</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 : }  /* form_unsigned_num */</span></a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span>            : #if DEBUG</a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 : static void form_unsigned_hex(unsigned long                         num,</span></a>
<a name="196"><span class="lineNum">     196 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="197"><span class="lineNum">     197 </span>            : /*</a>
<a name="198"><span class="lineNum">     198 </span>            : Output an unsigned number in hexadecimal form, as indicated by octl.</a>
<a name="199"><span class="lineNum">     199 </span>            : */</a>
<a name="200"><span class="lineNum">     200 </span>            : {</a>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :   char buffer[50];</span></a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 :   (void)sprintf(buffer, &quot;%lx&quot;, num);</span></a>
<a name="204"><span class="lineNum">     204 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(buffer, octl);</span></a>
<a name="205"><span class="lineNum">     205 </span><span class="lineNoCov">          0 : }  /* form_unsigned_hex */</span></a>
<a name="206"><span class="lineNum">     206 </span>            : </a>
<a name="207"><span class="lineNum">     207 </span>            : #endif /* DEBUG */</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            : #if !GNU_EXTENSIONS_ALLOWED</a>
<a name="210"><span class="lineNum">     210 </span>            : /*ARGSUSED*/ /* type, octl used only for GNU attributes. */</a>
<a name="211"><span class="lineNum">     211 </span>            : #endif /* !GNU_EXTENSIONS_ALLOWED */</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineNoCov">          0 : static void form_attributes_for_type(</span></a>
<a name="213"><span class="lineNum">     213 </span>            :                                    a_type_ptr                            type,</a>
<a name="214"><span class="lineNum">     214 </span>            :                                    an_il_to_str_output_control_block_ptr octl)</a>
<a name="215"><span class="lineNum">     215 </span>            : /*</a>
<a name="216"><span class="lineNum">     216 </span>            : Render type attributes associated with the given type, unless they are</a>
<a name="217"><span class="lineNum">     217 </span>            : rendered elsewhere.  Do the output in the way described by octl.</a>
<a name="218"><span class="lineNum">     218 </span>            : */</a>
<a name="219"><span class="lineNum">     219 </span>            : {</a>
<a name="220"><span class="lineNum">     220 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="221"><span class="lineNum">     221 </span>            :   /* Currently, only the GNU may_alias attribute is rendered here. */</a>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 :   if (type-&gt;may_alias) {</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot; __attribute((__may_alias__))&quot;, octl);</span></a>
<a name="224"><span class="lineNum">     224 </span>            :   }  /* if */</a>
<a name="225"><span class="lineNum">     225 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="226"><span class="lineNum">     226 </span>            : }  /* form_attributes_for_type */</a>
<a name="227"><span class="lineNum">     227 </span>            : </a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span><span class="lineNoCov">          0 : static void output_type_attributes(</span></a>
<a name="230"><span class="lineNum">     230 </span>            :                          a_type_ptr                            type,</a>
<a name="231"><span class="lineNum">     231 </span>            :                          a_type_ptr                            stop_type,</a>
<a name="232"><span class="lineNum">     232 </span>            :                          an_il_to_str_output_control_block_ptr octl)</a>
<a name="233"><span class="lineNum">     233 </span>            : /*</a>
<a name="234"><span class="lineNum">     234 </span>            : The given type may contain typerefs that carry attributes: Render those</a>
<a name="235"><span class="lineNum">     235 </span>            : attributes.  If octl-&gt;output_attributes is non-NULL, use that routine to</a>
<a name="236"><span class="lineNum">     236 </span>            : output the attributes.  Otherwise, only output type attributes that are not</a>
<a name="237"><span class="lineNum">     237 </span>            : handled elsewhere.  stop_type is a type along the typeref chain (or</a>
<a name="238"><span class="lineNum">     238 </span>            : stop_type == type if there are no typerefs): Do not render attributes</a>
<a name="239"><span class="lineNum">     239 </span>            : associated with that type entry or entries under it, except that if stop_type</a>
<a name="240"><span class="lineNum">     240 </span>            : is a tk_routine entry, attributes on that routine type entry are rendered.</a>
<a name="241"><span class="lineNum">     241 </span>            : */</a>
<a name="242"><span class="lineNum">     242 </span>            : {</a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :   while (type != stop_type) {</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :     check_assertion(type-&gt;kind == (a_type_kind)tk_typeref);</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (type-&gt;variant.typeref.for_type_attributes) {</span></a>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 :       check_assertion(type-&gt;source_corresp.attributes != NULL);</span></a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :       if (octl-&gt;output_attributes != NULL) {</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :         octl-&gt;output_attributes(type-&gt;source_corresp.attributes,</span></a>
<a name="249"><span class="lineNum">     249 </span>            :                                 al_explicit, /*primary_only=*/FALSE);</a>
<a name="250"><span class="lineNum">     250 </span>            :       } else {</a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :         form_attributes_for_type(type, octl);</span></a>
<a name="252"><span class="lineNum">     252 </span>            :       }  /* if */</a>
<a name="253"><span class="lineNum">     253 </span>            :     }  /* if */</a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :     type = type-&gt;variant.typeref.type;</span></a>
<a name="255"><span class="lineNum">     255 </span>            :   }  /* while */</a>
<a name="256"><span class="lineNum">     256 </span><span class="lineNoCov">          0 :   if (type-&gt;kind == (a_type_kind)tk_routine &amp;&amp;</span></a>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :       type-&gt;source_corresp.attributes != NULL) {</span></a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :     if (octl-&gt;output_attributes != NULL) {</span></a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :       octl-&gt;output_attributes(type-&gt;source_corresp.attributes,</span></a>
<a name="260"><span class="lineNum">     260 </span>            :                               al_explicit, /*primary_only=*/FALSE);</a>
<a name="261"><span class="lineNum">     261 </span>            :     } else {</a>
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 :       form_attributes_for_type(type, octl);</span></a>
<a name="263"><span class="lineNum">     263 </span>            :     }  /* if */</a>
<a name="264"><span class="lineNum">     264 </span>            :   }  /* if */</a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 : }  /* output_type_attributes */</span></a>
<a name="266"><span class="lineNum">     266 </span>            : </a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span><span class="lineNoCov">          0 : static void output_predeclarator_attributes(</span></a>
<a name="269"><span class="lineNum">     269 </span>            :                                    a_type_ptr                            type,</a>
<a name="270"><span class="lineNum">     270 </span>            :                                    an_il_to_str_output_control_block_ptr octl)</a>
<a name="271"><span class="lineNum">     271 </span>            : /*</a>
<a name="272"><span class="lineNum">     272 </span>            : Render any &quot;predeclarator&quot; attributes (a GNU feature) for the given type.</a>
<a name="273"><span class="lineNum">     273 </span>            : Do the output in the way described by octl.</a>
<a name="274"><span class="lineNum">     274 </span>            : */</a>
<a name="275"><span class="lineNum">     275 </span>            : {</a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :   if (octl-&gt;output_attributes != NULL) {</span></a>
<a name="277"><span class="lineNum">     277 </span><span class="lineNoCov">          0 :     octl-&gt;output_attributes(type-&gt;source_corresp.attributes,</span></a>
<a name="278"><span class="lineNum">     278 </span>            :                             al_predeclarator, /*primary_only=*/FALSE);</a>
<a name="279"><span class="lineNum">     279 </span>            :   }  /* if */</a>
<a name="280"><span class="lineNum">     280 </span>            : }  /* output_predeclarator_attributes */</a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            : </a>
<a name="283"><span class="lineNum">     283 </span><span class="lineCov">         92 : static a_boolean has_predeclarator_attribute(a_type_ptr  type)</span></a>
<a name="284"><span class="lineNum">     284 </span>            : /*</a>
<a name="285"><span class="lineNum">     285 </span>            : Return TRUE if the given type has a &quot;predeclarator&quot; attribute attached to it.</a>
<a name="286"><span class="lineNum">     286 </span>            : */</a>
<a name="287"><span class="lineNum">     287 </span>            : {</a>
<a name="288"><span class="lineNum">     288 </span><span class="lineCov">         92 :   a_boolean         result = FALSE;</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineCov">         92 :   an_attribute_ptr  ap = type-&gt;source_corresp.attributes;</span></a>
<a name="290"><span class="lineNum">     290 </span>            : </a>
<a name="291"><span class="lineNum">     291 </span><span class="lineCov">         92 :   for (; ap != NULL; ap = ap-&gt;next) {</span></a>
<a name="292"><span class="lineNum">     292 </span><span class="lineNoCov">          0 :     if (ap-&gt;syntactic_location ==</span></a>
<a name="293"><span class="lineNum">     293 </span>            :                                 (a_byte_attribute_location)al_predeclarator) {</a>
<a name="294"><span class="lineNum">     294 </span>            :       result = TRUE;</a>
<a name="295"><span class="lineNum">     295 </span>            :       break;</a>
<a name="296"><span class="lineNum">     296 </span>            :     }  /* if */</a>
<a name="297"><span class="lineNum">     297 </span>            :   }  /* for */</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineCov">         92 :   return result;</span></a>
<a name="299"><span class="lineNum">     299 </span>            : }  /* has_predeclarator_attribute */</a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<a name="302"><span class="lineNum">     302 </span>            : #if !PROTOTYPE_INSTANTIATIONS_IN_IL</a>
<a name="303"><span class="lineNum">     303 </span>            : static a_source_correspondence_ptr source_corresp_for_template_param(</a>
<a name="304"><span class="lineNum">     304 </span>            :                                         a_template_param_coordinate_ptr coord);</a>
<a name="305"><span class="lineNum">     305 </span>            : #endif /* !PROTOTYPE_INSTANTIATIONS_IN_IL */</a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 : static void form_template(a_template_ptr        tp,</span></a>
<a name="308"><span class="lineNum">     308 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="309"><span class="lineNum">     309 </span>            : </a>
<a name="310"><span class="lineNum">     310 </span>            : /*</a>
<a name="311"><span class="lineNum">     311 </span>            : Output a string for a template name.  Do the output in the way described</a>
<a name="312"><span class="lineNum">     312 </span>            : by octl.</a>
<a name="313"><span class="lineNum">     313 </span>            : */</a>
<a name="314"><span class="lineNum">     314 </span>            : {</a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :   a_source_correspondence_ptr scp = &amp;tp-&gt;source_corresp;</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :   an_il_entry_kind            kind = iek_template;</span></a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span>            :   /* See whether the template parameter name is remapped in the current</a>
<a name="319"><span class="lineNum">     319 </span>            :      context. */</a>
<a name="320"><span class="lineNum">     320 </span><span class="lineNoCov">          0 :   { a_source_correspondence_ptr new_scp;</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineNoCov">          0 :     new_scp = source_corresp_for_template_param(&amp;tp-&gt;coordinates);</span></a>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 :     if (new_scp != NULL) {</span></a>
<a name="323"><span class="lineNum">     323 </span><span class="lineNoCov">          0 :       scp = new_scp;</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :       kind = iek_template_parameter;</span></a>
<a name="325"><span class="lineNum">     325 </span>            :     }  /* if */</a>
<a name="326"><span class="lineNum">     326 </span>            :   }</a>
<a name="327"><span class="lineNum">     327 </span>            :   /* If there is a special output routine for template names, use that.</a>
<a name="328"><span class="lineNum">     328 </span>            :      Otherwise go through the normal processing. */</a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :   if (octl-&gt;output_template_name != NULL) {</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineNoCov">          0 :     octl-&gt;output_template_name((char *)scp, kind);</span></a>
<a name="331"><span class="lineNum">     331 </span>            :   } else {</a>
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 :     form_name(scp, kind, octl);</span></a>
<a name="333"><span class="lineNum">     333 </span>            :   }  /* if */</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineNoCov">          0 : }  /* form_template */</span></a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span>            : </a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 : void form_a_template_arg(a_template_arg_ptr                    tap,</span></a>
<a name="338"><span class="lineNum">     338 </span>            :                          an_il_to_str_output_control_block_ptr octl)</a>
<a name="339"><span class="lineNum">     339 </span>            : /*</a>
<a name="340"><span class="lineNum">     340 </span>            : Output the indicated template argument in the way described by octl.</a>
<a name="341"><span class="lineNum">     341 </span>            : */</a>
<a name="342"><span class="lineNum">     342 </span>            : {</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineNoCov">          0 :   switch (tap-&gt;kind) {</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 :     case tak_type:</span></a>
<a name="345"><span class="lineNum">     345 </span>            :       /* Type argument. */</a>
<a name="346"><span class="lineNum">     346 </span><span class="lineNoCov">          0 :       form_type(tap-&gt;variant.type, octl);</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineNoCov">          0 :     case tak_nontype:</span></a>
<a name="349"><span class="lineNum">     349 </span>            :       /* Nontype argument. */</a>
<a name="350"><span class="lineNum">     350 </span><span class="lineNoCov">          0 :       octl-&gt;processing_nontype_template_argument = TRUE;</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :       if (tap-&gt;is_array_bound_of_unknown_type) {</span></a>
<a name="352"><span class="lineNum">     352 </span>            :         /* The template argument is a deduced array bound whose type is not</a>
<a name="353"><span class="lineNum">     353 </span>            :            yet known (we know its value, but we don't yet know its type). */</a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :         check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;array-bound=&quot;, octl);</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineNoCov">          0 :         form_unsigned_num((a_host_large_unsigned)tap-&gt;variant.integer_value,</span></a>
<a name="357"><span class="lineNum">     357 </span>            :                           octl);</a>
<a name="358"><span class="lineNum">     358 </span>            :       } else {</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :         a_constant_ptr con = tap-&gt;variant.constant;</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :         if (tap-&gt;arg_operand != NULL &amp;&amp; con == NULL) {</span></a>
<a name="361"><span class="lineNum">     361 </span>            :           /* The template argument is given by an expression operand (front</a>
<a name="362"><span class="lineNum">     362 </span>            :              end only). */</a>
<a name="363"><span class="lineNum">     363 </span><span class="lineNoCov">          0 :           check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="365"><span class="lineNum">     365 </span>            :         } else {</a>
<a name="366"><span class="lineNum">     366 </span><span class="lineNoCov">          0 :           a_boolean        need_parens;</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :           an_expr_node_ptr expr;</span></a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :           check_assertion(con != NULL);</span></a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 :           expr = con-&gt;expr;</span></a>
<a name="370"><span class="lineNum">     370 </span><span class="lineNoCov">          0 :           if (expr == NULL &amp;&amp;</span></a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :               con-&gt;kind == (a_constant_repr_kind)ck_template_param &amp;&amp;</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :               con-&gt;variant.template_param.kind ==</span></a>
<a name="373"><span class="lineNum">     373 </span>            :                              (a_template_param_constant_kind)tpck_expression) {</a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :             expr = expr_node_from_tpck_expression(con);</span></a>
<a name="375"><span class="lineNum">     375 </span>            :           }  /* if */</a>
<a name="376"><span class="lineNum">     376 </span>            :           /* See whether we need parentheses around the argument to prevent</a>
<a name="377"><span class="lineNum">     377 </span>            :              a &quot;&gt;&quot; operator from being interpreted as the end of the</a>
<a name="378"><span class="lineNum">     378 </span>            :              argument list or to ensure that an ellipsis applies to the</a>
<a name="379"><span class="lineNum">     379 </span>            :              entire expression.  (enk_temp_init nodes are exempted because</a>
<a name="380"><span class="lineNum">     380 </span>            :              parentheses are not needed and because older versions of g++</a>
<a name="381"><span class="lineNum">     381 </span>            :              have a bug that causes errors compiling the resulting code if</a>
<a name="382"><span class="lineNum">     382 </span>            :              parentheses are used in that context.) */</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :           need_parens = octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :                         (octl-&gt;has_unprotected_gt_or_comma_operation == NULL ||</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineNoCov">          0 :                          octl-&gt;has_unprotected_gt_or_comma_operation(con) ||</span></a>
<a name="386"><span class="lineNum">     386 </span><span class="lineNoCov">          0 :                          (tap-&gt;is_pack &amp;&amp;</span></a>
<a name="387"><span class="lineNum">     387 </span><span class="lineNoCov">          0 :                           (expr == NULL ||</span></a>
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 :                            expr-&gt;kind != (an_expr_node_kind)enk_temp_init)));</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineNoCov">          0 :           if (is_any_reference_type(con-&gt;type)) {</span></a>
<a name="390"><span class="lineNum">     390 </span>            :             /* A reference parameter.  Display specially -- one level of</a>
<a name="391"><span class="lineNum">     391 </span>            :                indirection must be removed. */</a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :             form_lvalue_address_constant(con, need_parens, octl);</span></a>
<a name="393"><span class="lineNum">     393 </span>            :           } else {</a>
<a name="394"><span class="lineNum">     394 </span>            :             /* Normal (non-reference) case. */</a>
<a name="395"><span class="lineNum">     395 </span><span class="lineNoCov">          0 :             a_boolean saved_implicit_cast = con-&gt;implicit_cast;</span></a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :             if (con-&gt;kind == (a_constant_repr_kind)ck_ptr_to_member &amp;&amp;</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 !pm_constant_is_null(con)) {</span></a>
<a name="398"><span class="lineNum">     398 </span>            :               /* Except in a null pointer-to-member constant, a cast is not</a>
<a name="399"><span class="lineNum">     399 </span>            :                  permitted in a pointer-to-member template argument; ensure</a>
<a name="400"><span class="lineNum">     400 </span>            :                  that form_pm_constant does not add one to represent an</a>
<a name="401"><span class="lineNum">     401 </span>            :                  implicit conversion. */</a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :               con-&gt;implicit_cast = FALSE;</span></a>
<a name="403"><span class="lineNum">     403 </span>            :             }  /* if */</a>
<a name="404"><span class="lineNum">     404 </span><span class="lineNoCov">          0 :             form_constant(con, need_parens, octl);</span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :             con-&gt;implicit_cast = saved_implicit_cast;</span></a>
<a name="406"><span class="lineNum">     406 </span>            :           }  /* if */</a>
<a name="407"><span class="lineNum">     407 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :           if (octl-&gt;gen_compilable_code) {</span></a>
<a name="409"><span class="lineNum">     409 </span>            :             /* We only want to generate an expression, rather than a</a>
<a name="410"><span class="lineNum">     410 </span>            :                constant value, for the first reference to a given template</a>
<a name="411"><span class="lineNum">     411 </span>            :                instance, because the expression might use names that will</a>
<a name="412"><span class="lineNum">     412 </span>            :                not be in scope in later references to the instance. */</a>
<a name="413"><span class="lineNum">     413 </span><span class="lineNoCov">          0 :             con-&gt;expr = NULL;</span></a>
<a name="414"><span class="lineNum">     414 </span>            :           }  /* if */</a>
<a name="415"><span class="lineNum">     415 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="416"><span class="lineNum">     416 </span>            :         }  /* if */</a>
<a name="417"><span class="lineNum">     417 </span>            :       }</a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :       octl-&gt;processing_nontype_template_argument = FALSE;</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineNoCov">          0 :     case tak_template:</span></a>
<a name="421"><span class="lineNum">     421 </span>            :       /* A template template argument. */</a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :       form_template(tap-&gt;variant.templ.ptr, octl);</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="424"><span class="lineNum">     424 </span>            :     case tak_start_of_pack_expansion:</a>
<a name="425"><span class="lineNum">     425 </span>            :       break;</a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :       unexpected_condition();</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="429"><span class="lineNum">     429 </span>            :   }  /* switch */</a>
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :   if (tap-&gt;is_pack || tap-&gt;has_pack_ellipsis) octl-&gt;output_str(&quot;...&quot;, octl);</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 : }  /* form_a_template_arg */</span></a>
<a name="432"><span class="lineNum">     432 </span>            : </a>
<a name="433"><span class="lineNum">     433 </span>            : </a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 : void form_template_args(a_template_arg_ptr                    tap,</span></a>
<a name="435"><span class="lineNum">     435 </span>            :                         an_il_to_str_output_control_block_ptr octl)</a>
<a name="436"><span class="lineNum">     436 </span>            : /*</a>
<a name="437"><span class="lineNum">     437 </span>            : Output the indicated template arguments list (e.g., something like</a>
<a name="438"><span class="lineNum">     438 </span>            : &lt;int, float&gt;) in the way described by octl.  If tap is NULL, nothing</a>
<a name="439"><span class="lineNum">     439 </span>            : is put out.</a>
<a name="440"><span class="lineNum">     440 </span>            : */</a>
<a name="441"><span class="lineNum">     441 </span>            : {</a>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 :   if (tap != NULL) {</span></a>
<a name="443"><span class="lineNum">     443 </span><span class="lineNoCov">          0 :     a_boolean saved_nontype_tpl_arg =</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :                                     octl-&gt;processing_nontype_template_argument;</span></a>
<a name="445"><span class="lineNum">     445 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :     an_output_name_reference_function_ptr saved_output_name_reference =</span></a>
<a name="447"><span class="lineNum">     447 </span>            :                                                    octl-&gt;output_name_reference;</a>
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code) {</span></a>
<a name="449"><span class="lineNum">     449 </span>            :       /* Name references in template arguments are captured from the first</a>
<a name="450"><span class="lineNum">     450 </span>            :          use of the instance.  If that use was nested inside a class or</a>
<a name="451"><span class="lineNum">     451 </span>            :          namespace, the names may have been unqualified or partially</a>
<a name="452"><span class="lineNum">     452 </span>            :          qualified references to members of that class or namespace or its</a>
<a name="453"><span class="lineNum">     453 </span>            :          parents.  However, the instance can be used outside that context,</a>
<a name="454"><span class="lineNum">     454 </span>            :          in which case the names in template arguments would need to be</a>
<a name="455"><span class="lineNum">     455 </span>            :          fully qualified -- the form captured in the name reference won't</a>
<a name="456"><span class="lineNum">     456 </span>            :          work.  For safety's sake, we effectively turn off the name</a>
<a name="457"><span class="lineNum">     457 </span>            :          reference facility for the duration of the template argument</a>
<a name="458"><span class="lineNum">     458 </span>            :          list. */</a>
<a name="459"><span class="lineNum">     459 </span><span class="lineNoCov">          0 :       octl-&gt;output_name_reference = NULL;</span></a>
<a name="460"><span class="lineNum">     460 </span>            :     }  /* if */</a>
<a name="461"><span class="lineNum">     461 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 :     octl-&gt;processing_nontype_template_argument = FALSE;</span></a>
<a name="463"><span class="lineNum">     463 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&lt;&quot;, octl);</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code) {</span></a>
<a name="465"><span class="lineNum">     465 </span>            :       /* When generating compilable code, put out a space after the</a>
<a name="466"><span class="lineNum">     466 </span>            :          opening &quot;&lt;&quot; to avoid an accidental digraph if the first</a>
<a name="467"><span class="lineNum">     467 </span>            :          argument begins with a &quot;::&quot; global qualifier. */</a>
<a name="468"><span class="lineNum">     468 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="469"><span class="lineNum">     469 </span>            :     }  /* if */</a>
<a name="470"><span class="lineNum">     470 </span><span class="lineNoCov">          0 :     begin_template_arg_list_traversal_simple(tap, &amp;tap);</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineNoCov">          0 :     if (tap != NULL) {</span></a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :       for (;;) {</span></a>
<a name="473"><span class="lineNum">     473 </span><span class="lineNoCov">          0 :         form_a_template_arg(tap, octl);</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineNoCov">          0 :         advance_to_next_template_arg_simple(&amp;tap);</span></a>
<a name="475"><span class="lineNum">     475 </span>            :         /* Stop after the last argument. */</a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :         if (tap == NULL) break;</span></a>
<a name="477"><span class="lineNum">     477 </span>            :         /* Put a comma between arguments. */</a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="479"><span class="lineNum">     479 </span>            :       }  /* for */</a>
<a name="480"><span class="lineNum">     480 </span>            :     }  /* if */</a>
<a name="481"><span class="lineNum">     481 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&gt;&quot;, octl);</span></a>
<a name="482"><span class="lineNum">     482 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code) {</span></a>
<a name="483"><span class="lineNum">     483 </span>            :       /* When generating compilable code, put out a space after the</a>
<a name="484"><span class="lineNum">     484 </span>            :          final &quot;&gt;&quot; avoid the possibility of getting &quot;&gt;&gt;&quot; with nested</a>
<a name="485"><span class="lineNum">     485 </span>            :          template references or with a nontype expression that ends</a>
<a name="486"><span class="lineNum">     486 </span>            :          with &quot;&gt;&quot;. */</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="488"><span class="lineNum">     488 </span>            :     }  /* if */</a>
<a name="489"><span class="lineNum">     489 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :     octl-&gt;output_name_reference = saved_output_name_reference;</span></a>
<a name="491"><span class="lineNum">     491 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineNoCov">          0 :     octl-&gt;processing_nontype_template_argument = saved_nontype_tpl_arg;</span></a>
<a name="493"><span class="lineNum">     493 </span>            :   }  /* if */</a>
<a name="494"><span class="lineNum">     494 </span><span class="lineNoCov">          0 : }  /* form_template_args */</span></a>
<a name="495"><span class="lineNum">     495 </span>            : </a>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<a name="497"><span class="lineNum">     497 </span>            : static void form_conversion_function_name(</a>
<a name="498"><span class="lineNum">     498 </span>            :                                     a_routine_ptr                         rout,</a>
<a name="499"><span class="lineNum">     499 </span>            :                                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="500"><span class="lineNum">     500 </span>            : /*</a>
<a name="501"><span class="lineNum">     501 </span>            : Generate the name of the indicated conversion function.  This is done</a>
<a name="502"><span class="lineNum">     502 </span>            : by generating &quot;operator&quot; followed by the result type.  This may</a>
<a name="503"><span class="lineNum">     503 </span>            : differ from the name as it appears in the source_corresp.name field</a>
<a name="504"><span class="lineNum">     504 </span>            : in that it includes typedef names as they appeared in the original</a>
<a name="505"><span class="lineNum">     505 </span>            : source.</a>
<a name="506"><span class="lineNum">     506 </span>            : */</a>
<a name="507"><span class="lineNum">     507 </span>            : {</a>
<a name="508"><span class="lineNum">     508 </span>            :   a_type_ptr type = rout-&gt;type;</a>
<a name="509"><span class="lineNum">     509 </span>            :   a_boolean  saved_render_auto_deduction_typerefs =</a>
<a name="510"><span class="lineNum">     510 </span>            :                                          octl-&gt;render_auto_deduction_typerefs;</a>
<a name="511"><span class="lineNum">     511 </span>            : </a>
<a name="512"><span class="lineNum">     512 </span>            :   octl-&gt;output_str(&quot;operator &quot;, octl);</a>
<a name="513"><span class="lineNum">     513 </span>            :   type = skip_typerefs(type);</a>
<a name="514"><span class="lineNum">     514 </span>            :   octl-&gt;render_auto_deduction_typerefs = TRUE;</a>
<a name="515"><span class="lineNum">     515 </span>            :   type = type-&gt;variant.routine.return_type;</a>
<a name="516"><span class="lineNum">     516 </span>            :   octl-&gt;render_auto_deduction_typerefs = saved_render_auto_deduction_typerefs;</a>
<a name="517"><span class="lineNum">     517 </span>            :   form_type(type, octl);</a>
<a name="518"><span class="lineNum">     518 </span>            : }  /* form_conversion_function_name */</a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            : </a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">       4517 : static a_boolean scp_is_lambda_closure_class(</span></a>
<a name="522"><span class="lineNum">     522 </span>            :                               a_source_correspondence               *scp,</a>
<a name="523"><span class="lineNum">     523 </span>            :                               an_il_entry_kind                      entry_kind)</a>
<a name="524"><span class="lineNum">     524 </span>            : /*</a>
<a name="525"><span class="lineNum">     525 </span>            : Return TRUE if the IL entry specified by scp and entry_kind is a class type</a>
<a name="526"><span class="lineNum">     526 </span>            : for a lambda closure class.</a>
<a name="527"><span class="lineNum">     527 </span>            : */</a>
<a name="528"><span class="lineNum">     528 </span>            : {</a>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">       4517 :   a_boolean     result = FALSE;</span></a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">       4517 :   if (entry_kind == iek_type) {</span></a>
<a name="532"><span class="lineNum">     532 </span><span class="lineCov">       4511 :     a_type_ptr  type = (a_type_ptr)scp;</span></a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">       4511 :     if (is_immediate_class_type(type) &amp;&amp;</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">       4483 :         class_type_supp(type)-&gt;is_lambda_closure_class) {</span></a>
<a name="535"><span class="lineNum">     535 </span>            :       result = TRUE;</a>
<a name="536"><span class="lineNum">     536 </span>            :     }  /* if */</a>
<a name="537"><span class="lineNum">     537 </span>            :   }  /* if */</a>
<a name="538"><span class="lineNum">     538 </span>            :   return result;</a>
<a name="539"><span class="lineNum">     539 </span>            : }  /* scp_is_lambda_closure_class */</a>
<a name="540"><span class="lineNum">     540 </span>            : </a>
<a name="541"><span class="lineNum">     541 </span>            : </a>
<a name="542"><span class="lineNum">     542 </span>            : static</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 : a_boolean form_name_if_lambda(a_source_correspondence               *scp,</span></a>
<a name="544"><span class="lineNum">     544 </span>            :                               an_il_entry_kind                      entry_kind,</a>
<a name="545"><span class="lineNum">     545 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="546"><span class="lineNum">     546 </span>            : /*</a>
<a name="547"><span class="lineNum">     547 </span>            : Determine whether the entity is the closure class for a lambda, and if so,</a>
<a name="548"><span class="lineNum">     548 </span>            : generate a name for it and return TRUE (FALSE otherwise).</a>
<a name="549"><span class="lineNum">     549 </span>            : */</a>
<a name="550"><span class="lineNum">     550 </span>            : {</a>
<a name="551"><span class="lineNum">     551 </span><span class="lineNoCov">          0 :   a_boolean  result = FALSE;</span></a>
<a name="552"><span class="lineNum">     552 </span>            : </a>
<a name="553"><span class="lineNum">     553 </span><span class="lineNoCov">          0 :   if (entry_kind == iek_type &amp;&amp; !generating_debug_output(octl)) {</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :     a_type_ptr  type = (a_type_ptr)scp;</span></a>
<a name="555"><span class="lineNum">     555 </span><span class="lineNoCov">          0 :     if (is_immediate_class_type(type) &amp;&amp;</span></a>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 :         class_type_supp(type)-&gt;is_lambda_closure_class) {</span></a>
<a name="557"><span class="lineNum">     557 </span><span class="lineNoCov">          0 :       a_boolean  gen_signature = FALSE;</span></a>
<a name="558"><span class="lineNum">     558 </span>            : #if !STANDALONE_UTILITY_PROGRAM</a>
<a name="559"><span class="lineNum">     559 </span><span class="lineNoCov">          0 :       gen_signature = in_front_end;</span></a>
<a name="560"><span class="lineNum">     560 </span>            : #endif /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="561"><span class="lineNum">     561 </span><span class="lineNoCov">          0 :       result = TRUE;</span></a>
<a name="562"><span class="lineNum">     562 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;lambda []&quot;, octl);</span></a>
<a name="563"><span class="lineNum">     563 </span><span class="lineNoCov">          0 :       if (!gen_signature) {</span></a>
<a name="564"><span class="lineNum">     564 </span>            :         /* Generating the signature requires the front end's symbol table.</a>
<a name="565"><span class="lineNum">     565 </span>            :            In back ends and stand-alone utilities we therefore do not render</a>
<a name="566"><span class="lineNum">     566 </span>            :            the signature and instead identify the lambda through the source</a>
<a name="567"><span class="lineNum">     567 </span>            :            position. */</a>
<a name="568"><span class="lineNum">     568 </span><span class="lineNoCov">          0 :         a_source_position  *pos = &amp;type-&gt;source_corresp.decl_position;</span></a>
<a name="569"><span class="lineNum">     569 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; type at line &quot;, octl);</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :         form_unsigned_num((a_host_large_unsigned)pos-&gt;seq, octl);</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;, col. &quot;, octl);</span></a>
<a name="572"><span class="lineNum">     572 </span><span class="lineNoCov">          0 :         form_unsigned_num((a_host_large_unsigned)pos-&gt;column, octl);</span></a>
<a name="573"><span class="lineNum">     573 </span>            :       } else {</a>
<a name="574"><span class="lineNum">     574 </span>            : #if STANDALONE_UTILITY_PROGRAM</a>
<a name="575"><span class="lineNum">     575 </span>            :         unexpected_condition();</a>
<a name="576"><span class="lineNum">     576 </span>            : #else /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="577"><span class="lineNum">     577 </span>            :         /* Get the routine entry for the lambda body. */</a>
<a name="578"><span class="lineNum">     578 </span><span class="lineNoCov">          0 :         a_routine_ptr  rp = lambda_body_for_closure(type);</span></a>
<a name="579"><span class="lineNum">     579 </span>            :         /* Add the routine type of the lambda routine to the output.  The</a>
<a name="580"><span class="lineNum">     580 </span>            :            routine pointer for the lambda body can be NULL if this routine is</a>
<a name="581"><span class="lineNum">     581 </span>            :            called after the closure class has been created but before the</a>
<a name="582"><span class="lineNum">     582 </span>            :            complete lambda parameter list and return type have been scanned. */</a>
<a name="583"><span class="lineNum">     583 </span><span class="lineNoCov">          0 :         if (rp != NULL) {</span></a>
<a name="584"><span class="lineNum">     584 </span>            :           /* Avoid parameters added by lowering such as &quot;this&quot; and a pointer</a>
<a name="585"><span class="lineNum">     585 </span>            :              to the return value.  This both causes the result to look more</a>
<a name="586"><span class="lineNum">     586 </span>            :              like it would before lowering and also avoids a potential</a>
<a name="587"><span class="lineNum">     587 </span>            :              infinite recursion on the &quot;this&quot; parameter: since &quot;this&quot; is a</a>
<a name="588"><span class="lineNum">     588 </span>            :              pointer to the closure class, displaying its type would invoke</a>
<a name="589"><span class="lineNum">     589 </span>            :              this code again. */</a>
<a name="590"><span class="lineNum">     590 </span><span class="lineNoCov">          0 :           a_boolean saved_suppress_flag =</span></a>
<a name="591"><span class="lineNum">     591 </span><span class="lineNoCov">          0 :                                   octl-&gt;suppress_compiler_generated_parameters;</span></a>
<a name="592"><span class="lineNum">     592 </span><span class="lineNoCov">          0 :           octl-&gt;suppress_compiler_generated_parameters = TRUE;</span></a>
<a name="593"><span class="lineNum">     593 </span><span class="lineNoCov">          0 :           form_type(rp-&gt;type, octl);</span></a>
<a name="594"><span class="lineNum">     594 </span><span class="lineNoCov">          0 :           octl-&gt;suppress_compiler_generated_parameters = saved_suppress_flag;</span></a>
<a name="595"><span class="lineNum">     595 </span>            :         }  /* if */</a>
<a name="596"><span class="lineNum">     596 </span>            : #endif /* STANDALONE_UTILITY_PROGRAM */</a>
<a name="597"><span class="lineNum">     597 </span>            :       }  /* if */</a>
<a name="598"><span class="lineNum">     598 </span>            :     }  /* if */</a>
<a name="599"><span class="lineNum">     599 </span>            :   }  /* if */</a>
<a name="600"><span class="lineNum">     600 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="601"><span class="lineNum">     601 </span>            : }  /* form_name_if_lambda */</a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span>            : </a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">       9142 : void form_unqualified_name(a_source_correspondence               *scp,</span></a>
<a name="605"><span class="lineNum">     605 </span>            :                            an_il_entry_kind                      entry_kind,</a>
<a name="606"><span class="lineNum">     606 </span>            :                            an_il_to_str_output_control_block_ptr octl)</a>
<a name="607"><span class="lineNum">     607 </span>            : /*</a>
<a name="608"><span class="lineNum">     608 </span>            : Output the (unqualified) name of the IL entity whose source correspondence</a>
<a name="609"><span class="lineNum">     609 </span>            : entry is pointed to by scp.  The IL entry is of the indicated kind.</a>
<a name="610"><span class="lineNum">     610 </span>            : The output includes template arguments on template classes.</a>
<a name="611"><span class="lineNum">     611 </span>            : */</a>
<a name="612"><span class="lineNum">     612 </span>            : {</a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">       9142 :   a_const_char *name = unmangled_name_of(scp);</span></a>
<a name="614"><span class="lineNum">     614 </span>            : </a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">       9142 :   if (name == NULL) {</span></a>
<a name="616"><span class="lineNum">     616 </span><span class="lineNoCov">          0 :     if (form_name_if_lambda(scp, entry_kind, octl)) {</span></a>
<a name="617"><span class="lineNum">     617 </span>            :       /* For a lambda, the name will be emitted by form_name_if_lambda. */</a>
<a name="618"><span class="lineNum">     618 </span>            :     } else {</a>
<a name="619"><span class="lineNum">     619 </span>            :       /* For entities without names, use &lt;unnamed&gt;. */</a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;unnamed&quot;, octl);</span></a>
<a name="622"><span class="lineNum">     622 </span>            : #if DEBUG</a>
<a name="623"><span class="lineNum">     623 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;@&quot;, octl);</span></a>
<a name="625"><span class="lineNum">     625 </span><span class="lineNoCov">          0 :         form_unsigned_hex(possible_lossy_cast_from_pointer(scp), octl);</span></a>
<a name="626"><span class="lineNum">     626 </span>            :       }  /* if */</a>
<a name="627"><span class="lineNum">     627 </span>            : #endif /* DEBUG */</a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&gt;&quot;, octl);</span></a>
<a name="629"><span class="lineNum">     629 </span>            :     }  /* if */</a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">       9142 :   } else if (entry_kind == iek_routine &amp;&amp;</span></a>
<a name="631"><span class="lineNum">     631 </span><span class="lineCov">          6 :              ((a_routine_ptr)scp)-&gt;special_kind ==</span></a>
<a name="632"><span class="lineNum">     632 </span>            :                                      (a_special_function_kind)sfk_conversion) {</a>
<a name="633"><span class="lineNum">     633 </span>            :     /* For conversion functions, generate the routine name from the type</a>
<a name="634"><span class="lineNum">     634 </span>            :        name, to get original typedefs. */</a>
<a name="635"><span class="lineNum">     635 </span><span class="lineNoCov">          0 :     form_conversion_function_name((a_routine_ptr)scp, octl);</span></a>
<a name="636"><span class="lineNum">     636 </span>            :   } else {</a>
<a name="637"><span class="lineNum">     637 </span>            :     /* Output the base name. */</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">       9142 :     octl-&gt;output_str(name, octl);</span></a>
<a name="639"><span class="lineNum">     639 </span>            :   }  /* if */</a>
<a name="640"><span class="lineNum">     640 </span>            :   /* Check for template arguments on a class name. */</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">       9142 :   if (il_header.source_language == sl_Cplusplus &amp;&amp; entry_kind == iek_type &amp;&amp;</span></a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">       4656 :       !octl-&gt;suppress_template_args) {</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">         31 :     a_type_ptr          type = (a_type_ptr)scp;</span></a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">         31 :     a_template_arg_ptr  tap = NULL;</span></a>
<a name="645"><span class="lineNum">     645 </span>            :     /* Ignore template parameters and classes whose bodies have been</a>
<a name="646"><span class="lineNum">     646 </span>            :        eliminated. */</a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">         31 :     if (is_immediate_class_type(type) &amp;&amp;</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">          3 :         type-&gt;variant.class_struct_union.extra_info != NULL) {</span></a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">          3 :       tap = type-&gt;variant.class_struct_union.extra_info-&gt;template_arg_list;</span></a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">         28 :     } else if (type-&gt;kind == (a_type_kind)tk_typeref) {</span></a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">         18 :       tap = type-&gt;variant.typeref.extra_info-&gt;orig_template_arg_list;</span></a>
<a name="652"><span class="lineNum">     652 </span>            :     }  /* if */</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">         21 :     if (tap != NULL) {</span></a>
<a name="654"><span class="lineNum">     654 </span>            :       /* This is a template class name or template alias name.  Put out the</a>
<a name="655"><span class="lineNum">     655 </span>            :          template argument list, e.g., &quot;&lt;int, float&gt;&quot;. */</a>
<a name="656"><span class="lineNum">     656 </span><span class="lineNoCov">          0 :       form_template_args(tap, octl);</span></a>
<a name="657"><span class="lineNum">     657 </span>            :     }  /* if */</a>
<a name="658"><span class="lineNum">     658 </span>            :   }  /* if */</a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">       9142 : }  /* form_unqualified_name */</span></a>
<a name="660"><span class="lineNum">     660 </span>            : </a>
<a name="661"><span class="lineNum">     661 </span>            : </a>
<a name="662"><span class="lineNum">     662 </span><span class="lineCov">       4480 : static void form_namespace_qualifier(</span></a>
<a name="663"><span class="lineNum">     663 </span>            :                                     a_namespace_ptr                       nsp,</a>
<a name="664"><span class="lineNum">     664 </span>            :                                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="665"><span class="lineNum">     665 </span>            : /*</a>
<a name="666"><span class="lineNum">     666 </span>            : Output a namespace qualifier (e.g., &quot;N::&quot;) that identifies the indicated</a>
<a name="667"><span class="lineNum">     667 </span>            : namespace.  Do the output in the way described by octl.  Note that the</a>
<a name="668"><span class="lineNum">     668 </span>            : output_name routine in the control block (if there is one) will not be used</a>
<a name="669"><span class="lineNum">     669 </span>            : to output any part of the name.  Called only for C++.</a>
<a name="670"><span class="lineNum">     670 </span>            : */</a>
<a name="671"><span class="lineNum">     671 </span>            : {</a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">       4480 :   if (!nsp-&gt;is_namespace_alias &amp;&amp; is_namespace_member(nsp)) {</span></a>
<a name="673"><span class="lineNum">     673 </span>            :     /* Use recursion to handle nested namespaces. */</a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">         90 :     form_namespace_qualifier(parent_namespace_of(nsp), octl);</span></a>
<a name="675"><span class="lineNum">     675 </span>            :   }  /* if */</a>
<a name="676"><span class="lineNum">     676 </span>            :   /* Do the last level. */</a>
<a name="677"><span class="lineNum">     677 </span><span class="lineCov">       4480 :   form_unqualified_name(&amp;nsp-&gt;source_corresp, iek_namespace, octl);</span></a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">       4480 :   octl-&gt;output_str(&quot;::&quot;, octl);</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">       4480 : }  /* form_namespace_qualifier */</span></a>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">        145 : static void form_class_qualifier(</span></a>
<a name="683"><span class="lineNum">     683 </span>            :                   a_type_ptr                            class_type,</a>
<a name="684"><span class="lineNum">     684 </span>            :                   a_boolean                             for_ptr_to_data_member,</a>
<a name="685"><span class="lineNum">     685 </span>            :                   an_il_to_str_output_control_block_ptr octl)</a>
<a name="686"><span class="lineNum">     686 </span>            : /*</a>
<a name="687"><span class="lineNum">     687 </span>            : Output a class qualifier (e.g., &quot;A::B::&quot;) that identifies the indicated</a>
<a name="688"><span class="lineNum">     688 </span>            : class type.  If for_ptr_to_data_member is TRUE, class_type is the qualifier</a>
<a name="689"><span class="lineNum">     689 </span>            : in a pointer to data member type.  Do the output in the way described by</a>
<a name="690"><span class="lineNum">     690 </span>            : octl.  Called only for C++.  */</a>
<a name="691"><span class="lineNum">     691 </span>            : {</a>
<a name="692"><span class="lineNum">     692 </span>            :   /* Use the special routine if there is one. */</a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">        145 :   if (octl-&gt;output_class_qualifier != NULL) {</span></a>
<a name="694"><span class="lineNum">     694 </span><span class="lineNoCov">          0 :     octl-&gt;output_class_qualifier(class_type, for_ptr_to_data_member);</span></a>
<a name="695"><span class="lineNum">     695 </span>            :   } else {</a>
<a name="696"><span class="lineNum">     696 </span>            :     /* Default processing. */</a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">        145 :     a_source_correspondence     *scp = &amp;class_type-&gt;source_corresp;</span></a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">        145 :     a_class_type_supplement_ptr ctsp;</span></a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">        145 :     a_boolean                   output_base_name = TRUE;</span></a>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<a name="701"><span class="lineNum">     701 </span>            :     /* Use recursion to handle multiple levels of nesting. */</a>
<a name="702"><span class="lineNum">     702 </span><span class="lineCov">        145 :     form_qualifier(scp-&gt;parent_scope, octl);</span></a>
<a name="703"><span class="lineNum">     703 </span>            :     /* Do the last level. */</a>
<a name="704"><span class="lineNum">     704 </span>            :     /* Ignore anonymous unions. */</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">        145 :     ctsp = class_type-&gt;variant.class_struct_union.extra_info;</span></a>
<a name="706"><span class="lineNum">     706 </span>            : #if CHECKING || DEBUG</a>
<a name="707"><span class="lineNum">     707 </span><span class="lineCov">        145 :     if (ctsp == NULL) {</span></a>
<a name="708"><span class="lineNum">     708 </span>            :       /* Avoid abort on error case where parent has no supplement, so</a>
<a name="709"><span class="lineNum">     709 </span>            :          debug output will still come out okay. */</a>
<a name="710"><span class="lineNum">     710 </span>            : #if DEBUG</a>
<a name="711"><span class="lineNum">     711 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="712"><span class="lineNum">     712 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&lt;parent with missing IL supplement&gt;&quot;, octl);</span></a>
<a name="713"><span class="lineNum">     713 </span>            :       } else</a>
<a name="714"><span class="lineNum">     714 </span>            : #endif /* DEBUG */</a>
<a name="715"><span class="lineNum">     715 </span>            :       {</a>
<a name="716"><span class="lineNum">     716 </span><span class="lineNoCov">          0 :         unexpected_condition_str(&quot;form_class_qualifier: missing supplement&quot;);</span></a>
<a name="717"><span class="lineNum">     717 </span>            :       }  /* if */</a>
<a name="718"><span class="lineNum">     718 </span>            :     } else</a>
<a name="719"><span class="lineNum">     719 </span>            : #endif /* CHECKING || DEBUG */</a>
<a name="720"><span class="lineNum">     720 </span>            :     /* Do not insert code here. */</a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">        145 :     if (ctsp-&gt;anonymous_union_kind != (an_anonymous_union_kind)auk_none) {</span></a>
<a name="722"><span class="lineNum">     722 </span>            :       output_base_name = FALSE;</a>
<a name="723"><span class="lineNum">     723 </span>            :     }  /* if */</a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :     if (output_base_name) {</span></a>
<a name="725"><span class="lineNum">     725 </span><span class="lineCov">        145 :       form_unqualified_name(scp, iek_type, octl);</span></a>
<a name="726"><span class="lineNum">     726 </span><span class="lineCov">        145 :       octl-&gt;output_str(&quot;::&quot;, octl);</span></a>
<a name="727"><span class="lineNum">     727 </span>            :     }  /* if */</a>
<a name="728"><span class="lineNum">     728 </span>            :   }  /* if */</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">        145 : }  /* form_class_qualifier */</span></a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span><span class="lineNoCov">          0 : static void form_enum_qualifier(</span></a>
<a name="733"><span class="lineNum">     733 </span>            :                                a_type_ptr                            enum_type,</a>
<a name="734"><span class="lineNum">     734 </span>            :                                an_il_to_str_output_control_block_ptr octl)</a>
<a name="735"><span class="lineNum">     735 </span>            : /*</a>
<a name="736"><span class="lineNum">     736 </span>            : Output an enum qualifier (e.g., &quot;A::B::&quot;) that identifies the indicated</a>
<a name="737"><span class="lineNum">     737 </span>            : enum type.  Do the output in the way described by octl.  Called only for</a>
<a name="738"><span class="lineNum">     738 </span>            : C++.</a>
<a name="739"><span class="lineNum">     739 </span>            : */</a>
<a name="740"><span class="lineNum">     740 </span>            : {</a>
<a name="741"><span class="lineNum">     741 </span>            :   /* Use the special routine if there is one. */</a>
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 :   if (octl-&gt;output_enum_qualifier != NULL) {</span></a>
<a name="743"><span class="lineNum">     743 </span><span class="lineNoCov">          0 :     octl-&gt;output_enum_qualifier(enum_type);</span></a>
<a name="744"><span class="lineNum">     744 </span>            :   } else {</a>
<a name="745"><span class="lineNum">     745 </span>            :     /* Default processing. */</a>
<a name="746"><span class="lineNum">     746 </span><span class="lineNoCov">          0 :     a_source_correspondence *scp = &amp;enum_type-&gt;source_corresp;</span></a>
<a name="747"><span class="lineNum">     747 </span>            : </a>
<a name="748"><span class="lineNum">     748 </span>            :     /* Use recursion to handle multiple levels of nesting. */</a>
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :     form_qualifier(scp-&gt;parent_scope, octl);</span></a>
<a name="750"><span class="lineNum">     750 </span>            :     /* Do the last level. */</a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :     form_unqualified_name(scp, iek_type, octl);</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;::&quot;, octl);</span></a>
<a name="753"><span class="lineNum">     753 </span>            :   }  /* if */</a>
<a name="754"><span class="lineNum">     754 </span><span class="lineNoCov">          0 : }  /* form_enum_qualifier */</span></a>
<a name="755"><span class="lineNum">     755 </span>            : </a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span><span class="lineCov">       4662 : static void form_qualifier(a_scope_ptr                            scope,</span></a>
<a name="758"><span class="lineNum">     758 </span>            :                            an_il_to_str_output_control_block_ptr  octl)</a>
<a name="759"><span class="lineNum">     759 </span>            : /*</a>
<a name="760"><span class="lineNum">     760 </span>            : Output a qualifier for an entity declared in the given scope (e.g., the &quot;X::&quot;</a>
<a name="761"><span class="lineNum">     761 </span>            : in &quot;X::f()&quot;).  If scope is NULL or the file scope, no qualifier is emitted.</a>
<a name="762"><span class="lineNum">     762 </span>            : Note that the output_name routine in the control block (if there is one) will</a>
<a name="763"><span class="lineNum">     763 </span>            : not be used to output all of the name.  Called only for C++.</a>
<a name="764"><span class="lineNum">     764 </span>            : */</a>
<a name="765"><span class="lineNum">     765 </span>            : {</a>
<a name="766"><span class="lineNum">     766 </span><span class="lineCov">       4662 :   if (scope != NULL) {</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">       4662 :     switch (scope-&gt;kind) {</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">       4390 :       case sck_namespace:</span></a>
<a name="769"><span class="lineNum">     769 </span><span class="lineCov">       4390 :         form_namespace_qualifier(scope-&gt;variant.assoc_namespace, octl);</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineCov">       4390 :         break;</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">        145 :       case sck_class_struct_union:</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineCov">        145 :         form_class_qualifier(scope-&gt;variant.assoc_type,</span></a>
<a name="773"><span class="lineNum">     773 </span>            :                              /*for_ptr_to_data_member=*/FALSE, octl);</a>
<a name="774"><span class="lineNum">     774 </span><span class="lineCov">        145 :         break;</span></a>
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 :       case sck_enum:</span></a>
<a name="776"><span class="lineNum">     776 </span><span class="lineNoCov">          0 :         form_enum_qualifier(scope-&gt;variant.assoc_type, octl);</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="778"><span class="lineNum">     778 </span>            :       default:</a>
<a name="779"><span class="lineNum">     779 </span>            :         /* Nothing to be done. */</a>
<a name="780"><span class="lineNum">     780 </span>            :         break;</a>
<a name="781"><span class="lineNum">     781 </span>            :     }  /* switch */</a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 :   }  /* if */</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">       4662 : }  /* form_qualifier */</span></a>
<a name="784"><span class="lineNum">     784 </span>            : </a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span><span class="lineNoCov">          0 : void form_class_or_namespace_qualifier(</span></a>
<a name="787"><span class="lineNum">     787 </span>            :                          a_boolean                             is_class_member,</a>
<a name="788"><span class="lineNum">     788 </span>            :                          a_parent_class_or_namespace           parent,</a>
<a name="789"><span class="lineNum">     789 </span>            :                          an_il_to_str_output_control_block_ptr octl)</a>
<a name="790"><span class="lineNum">     790 </span>            : /*</a>
<a name="791"><span class="lineNum">     791 </span>            : Output a class or namespace qualifier for an entity, if necessary.</a>
<a name="792"><span class="lineNum">     792 </span>            : is_class_member and parent give the class/namespace membership information</a>
<a name="793"><span class="lineNum">     793 </span>            : for the entity: if is_class_member is TRUE, the entity is a member of the</a>
<a name="794"><span class="lineNum">     794 </span>            : class indicated by parent.class_type.  If is_class_member is FALSE, and</a>
<a name="795"><span class="lineNum">     795 </span>            : parent.namespace_ptr is non-NULL, the entity is a member of a namespace,</a>
<a name="796"><span class="lineNum">     796 </span>            : and parent.namespace_ptr points to the namespace.  Note that the</a>
<a name="797"><span class="lineNum">     797 </span>            : output_name routine in the control block (if there is one) will not</a>
<a name="798"><span class="lineNum">     798 </span>            : be used to output all of the name.  Called only for C++.</a>
<a name="799"><span class="lineNum">     799 </span>            : */</a>
<a name="800"><span class="lineNum">     800 </span>            : {</a>
<a name="801"><span class="lineNum">     801 </span><span class="lineNoCov">          0 :   if (is_class_member) {</span></a>
<a name="802"><span class="lineNum">     802 </span><span class="lineNoCov">          0 :     form_class_qualifier(parent.class_type, /*for_ptr_to_data_member=*/FALSE,</span></a>
<a name="803"><span class="lineNum">     803 </span>            :                          octl);</a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :   } else if (parent.namespace_ptr != NULL) {</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :     form_namespace_qualifier(parent.namespace_ptr, octl);</span></a>
<a name="806"><span class="lineNum">     806 </span>            :   }  /* if */</a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 : }  /* form_class_or_namespace_qualifier */</span></a>
<a name="808"><span class="lineNum">     808 </span>            : </a>
<a name="809"><span class="lineNum">     809 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<a name="811"><span class="lineNum">     811 </span>            : void form_property_or_event_name_as_qualifier_if_needed(</a>
<a name="812"><span class="lineNum">     812 </span>            :                               a_source_correspondence               *scp,</a>
<a name="813"><span class="lineNum">     813 </span>            :                               an_il_entry_kind                      entry_kind,</a>
<a name="814"><span class="lineNum">     814 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="815"><span class="lineNum">     815 </span>            : /*</a>
<a name="816"><span class="lineNum">     816 </span>            : If the indicated entity is a C++/CLI accessor, output the property or</a>
<a name="817"><span class="lineNum">     817 </span>            : event name as a qualifier.</a>
<a name="818"><span class="lineNum">     818 </span>            : */</a>
<a name="819"><span class="lineNum">     819 </span>            : {</a>
<a name="820"><span class="lineNum">     820 </span>            :   a_property_or_event_descr_ptr pedp = NULL;</a>
<a name="821"><span class="lineNum">     821 </span>            : </a>
<a name="822"><span class="lineNum">     822 </span>            :   if (entry_kind == iek_routine) {</a>
<a name="823"><span class="lineNum">     823 </span>            :     a_routine_ptr rp = (a_routine_ptr)scp;</a>
<a name="824"><span class="lineNum">     824 </span>            :     if (rout_is_cli_accessor(rp)) {</a>
<a name="825"><span class="lineNum">     825 </span>            :       pedp = rp-&gt;variant.property_or_event_descr;</a>
<a name="826"><span class="lineNum">     826 </span>            :     }  /* if */</a>
<a name="827"><span class="lineNum">     827 </span>            :   } else if (entry_kind == iek_constant) {</a>
<a name="828"><span class="lineNum">     828 </span>            :     a_constant_ptr con = (a_constant_ptr)scp;</a>
<a name="829"><span class="lineNum">     829 </span>            :     if (is_unknown_function_constant(con)) {</a>
<a name="830"><span class="lineNum">     830 </span>            :       pedp = con-&gt;variant.template_param.variant</a>
<a name="831"><span class="lineNum">     831 </span>            :                                      .unknown_function.property_or_event_descr;</a>
<a name="832"><span class="lineNum">     832 </span>            :     }  /* if */</a>
<a name="833"><span class="lineNum">     833 </span>            :   }  /* if */</a>
<a name="834"><span class="lineNum">     834 </span>            :   /* If the entity has an associated property, output a qualifier for the</a>
<a name="835"><span class="lineNum">     835 </span>            :      property name. */</a>
<a name="836"><span class="lineNum">     836 </span>            :   if (pedp != NULL) {</a>
<a name="837"><span class="lineNum">     837 </span>            :     if (pedp-&gt;is_static) {</a>
<a name="838"><span class="lineNum">     838 </span>            :       form_unqualified_name(&amp;pedp-&gt;variant.variable-&gt;source_corresp,</a>
<a name="839"><span class="lineNum">     839 </span>            :                             iek_variable, octl);</a>
<a name="840"><span class="lineNum">     840 </span>            :     } else {</a>
<a name="841"><span class="lineNum">     841 </span>            :       form_unqualified_name(&amp;pedp-&gt;variant.field-&gt;source_corresp,</a>
<a name="842"><span class="lineNum">     842 </span>            :                             iek_field, octl);</a>
<a name="843"><span class="lineNum">     843 </span>            :     }  /* if */</a>
<a name="844"><span class="lineNum">     844 </span>            :     octl-&gt;output_str(&quot;::&quot;, octl);</a>
<a name="845"><span class="lineNum">     845 </span>            :   }  /* if */</a>
<a name="846"><span class="lineNum">     846 </span>            : }  /* form_property_or_event_name_as_qualifier_if_needed */</a>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<a name="848"><span class="lineNum">     848 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineCov">       4517 : void form_name(a_source_correspondence               *scp,</span></a>
<a name="851"><span class="lineNum">     851 </span>            :                an_il_entry_kind                      kind,</a>
<a name="852"><span class="lineNum">     852 </span>            :                an_il_to_str_output_control_block_ptr octl)</a>
<a name="853"><span class="lineNum">     853 </span>            : /*</a>
<a name="854"><span class="lineNum">     854 </span>            : Output the name of the IL entity whose source correspondence</a>
<a name="855"><span class="lineNum">     855 </span>            : entry is pointed to by scp.  The IL entry is of the indicated kind.</a>
<a name="856"><span class="lineNum">     856 </span>            : If the entity is a class member, generate a qualified name.  Do the</a>
<a name="857"><span class="lineNum">     857 </span>            : output in the way described by octl.</a>
<a name="858"><span class="lineNum">     858 </span>            : */</a>
<a name="859"><span class="lineNum">     859 </span>            : {</a>
<a name="860"><span class="lineNum">     860 </span>            :   /* See if there is a routine to do specialized name output. */</a>
<a name="861"><span class="lineNum">     861 </span><span class="lineCov">       4517 :   if (octl-&gt;output_name != NULL) {</span></a>
<a name="862"><span class="lineNum">     862 </span>            :     /* Use the specialized routine. */</a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :     octl-&gt;output_name((char *)scp, kind);</span></a>
<a name="864"><span class="lineNum">     864 </span>            :   } else {</a>
<a name="865"><span class="lineNum">     865 </span>            :     /* Default handling. */</a>
<a name="866"><span class="lineNum">     866 </span>            :     /* This code isn't suitable for generating compilable output. */</a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">       4517 :     check_assertion_str(!octl-&gt;gen_compilable_code,</span></a>
<a name="868"><span class="lineNum">     868 </span><span class="lineCov">       4517 :                         &quot;form_name: doesn't handle compilable output&quot;);</span></a>
<a name="869"><span class="lineNum">     869 </span>            :     /* If the name is a member of a class or namespace in C++, output the</a>
<a name="870"><span class="lineNum">     870 </span>            :        qualifier. */</a>
<a name="871"><span class="lineNum">     871 </span><span class="lineCov">       4517 :     if (il_header.source_language == sl_Cplusplus &amp;&amp;</span></a>
<a name="872"><span class="lineNum">     872 </span><span class="lineCov">       9034 :         !scp_is_lambda_closure_class(scp, kind)) {</span></a>
<a name="873"><span class="lineNum">     873 </span>            :       /* Suppress the qualifier for lambda closure classes. */</a>
<a name="874"><span class="lineNum">     874 </span><span class="lineCov">       4517 :       form_qualifier(scp-&gt;parent_scope, octl);</span></a>
<a name="875"><span class="lineNum">     875 </span>            :     }  /* if */</a>
<a name="876"><span class="lineNum">     876 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="877"><span class="lineNum">     877 </span>            :     form_property_or_event_name_as_qualifier_if_needed(scp, kind, octl);</a>
<a name="878"><span class="lineNum">     878 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="879"><span class="lineNum">     879 </span>            :     /* Output the base name. */</a>
<a name="880"><span class="lineNum">     880 </span><span class="lineCov">       4517 :     form_unqualified_name(scp, kind, octl);</span></a>
<a name="881"><span class="lineNum">     881 </span>            :   }  /* if */</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineCov">       4517 : }  /* form_name */</span></a>
<a name="883"><span class="lineNum">     883 </span>            : </a>
<a name="884"><span class="lineNum">     884 </span>            : </a>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 : static void form_tag_kind(a_type_kind                           kind,</span></a>
<a name="886"><span class="lineNum">     886 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="887"><span class="lineNum">     887 </span>            : /*</a>
<a name="888"><span class="lineNum">     888 </span>            : Output a string that describes the tag kind for the indicated type, i.e.,</a>
<a name="889"><span class="lineNum">     889 </span>            : &quot;class&quot; or &quot;enum&quot;.  Do the output in the way described by octl.</a>
<a name="890"><span class="lineNum">     890 </span>            : */</a>
<a name="891"><span class="lineNum">     891 </span>            : {</a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :   a_const_char *str = NULL;</span></a>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<a name="894"><span class="lineNum">     894 </span><span class="lineNoCov">          0 :   switch (kind) {</span></a>
<a name="895"><span class="lineNum">     895 </span>            :     case tk_enum:   str = &quot;enum&quot;;   break;</a>
<a name="896"><span class="lineNum">     896 </span><span class="lineNoCov">          0 :     case tk_class:  str = &quot;class&quot;;  break;</span></a>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 :     case tk_struct: str = &quot;struct&quot;; break;</span></a>
<a name="898"><span class="lineNum">     898 </span><span class="lineNoCov">          0 :     case tk_union:  str = &quot;union&quot;;  break;</span></a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="900"><span class="lineNum">     900 </span>            : #if DEBUG</a>
<a name="901"><span class="lineNum">     901 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="902"><span class="lineNum">     902 </span>            :         str = &quot;**BAD-TAG-KIND**&quot;;</a>
<a name="903"><span class="lineNum">     903 </span>            :         break;</a>
<a name="904"><span class="lineNum">     904 </span>            :       }  /* if */</a>
<a name="905"><span class="lineNum">     905 </span>            : #endif /* DEBUG */</a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :       unexpected_condition_str(&quot;form_tag_kind: bad type kind&quot;);</span></a>
<a name="907"><span class="lineNum">     907 </span>            :   }  /* switch */</a>
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(str, octl);</span></a>
<a name="909"><span class="lineNum">     909 </span><span class="lineNoCov">          0 : }  /* form_tag_kind */</span></a>
<a name="910"><span class="lineNum">     910 </span>            : </a>
<a name="911"><span class="lineNum">     911 </span>            : </a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">          1 : static void form_tag_reference(a_type_ptr                            type,</span></a>
<a name="913"><span class="lineNum">     913 </span>            :                                an_il_to_str_output_control_block_ptr octl)</a>
<a name="914"><span class="lineNum">     914 </span>            : /*</a>
<a name="915"><span class="lineNum">     915 </span>            : Output a reference to a tag, doing output in the way described by octl.</a>
<a name="916"><span class="lineNum">     916 </span>            : */</a>
<a name="917"><span class="lineNum">     917 </span>            : {</a>
<a name="918"><span class="lineNum">     918 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="919"><span class="lineNum">     919 </span>            :   if (is_immediate_class_type(type) &amp;&amp;</a>
<a name="920"><span class="lineNum">     920 </span>            :       class_type_supp(type)-&gt;corresponding_basic_type != NULL &amp;&amp;</a>
<a name="921"><span class="lineNum">     921 </span>            :       is_immediate_enum_type(</a>
<a name="922"><span class="lineNum">     922 </span>            :                            class_type_supp(type)-&gt;corresponding_basic_type)) {</a>
<a name="923"><span class="lineNum">     923 </span>            :     /* The given type represents a boxed enum type in C++/CLI mode.  The type</a>
<a name="924"><span class="lineNum">     924 </span>            :        cannot be written explicitly in source form.  Use the unboxed type</a>
<a name="925"><span class="lineNum">     925 </span>            :        instead. */</a>
<a name="926"><span class="lineNum">     926 </span>            :     type = class_type_supp(type)-&gt;corresponding_basic_type;</a>
<a name="927"><span class="lineNum">     927 </span>            :   }  /* if */</a>
<a name="928"><span class="lineNum">     928 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="929"><span class="lineNum">     929 </span>            :   /* See if there is a routine to do specialized name output. */</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineCov">          1 :   if (octl-&gt;output_name != NULL) {</span></a>
<a name="931"><span class="lineNum">     931 </span>            :     /* Use the specialized routine. */</a>
<a name="932"><span class="lineNum">     932 </span><span class="lineNoCov">          0 :     octl-&gt;output_name((char *)type, iek_type);</span></a>
<a name="933"><span class="lineNum">     933 </span>            :   } else {</a>
<a name="934"><span class="lineNum">     934 </span>            :     /* Default handling. */</a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">          1 :     if (il_header.source_language == sl_C ||</span></a>
<a name="936"><span class="lineNum">     936 </span><span class="lineCov">          1 :         (type_is_unnamed(type) &amp;&amp; !type_is_lambda_closure(type))) {</span></a>
<a name="937"><span class="lineNum">     937 </span>            :       /* In C, put &quot;struct&quot;, &quot;union&quot;, or &quot;enum&quot; on tags.  In C++, do it</a>
<a name="938"><span class="lineNum">     938 </span>            :          only for unnamed tags (but not lambda closure classes). */</a>
<a name="939"><span class="lineNum">     939 </span><span class="lineNoCov">          0 :       form_tag_kind(type-&gt;kind, octl);</span></a>
<a name="940"><span class="lineNum">     940 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="941"><span class="lineNum">     941 </span>            :     }  /* if */</a>
<a name="942"><span class="lineNum">     942 </span><span class="lineCov">          1 :     form_name(&amp;type-&gt;source_corresp, iek_type, octl);</span></a>
<a name="943"><span class="lineNum">     943 </span>            :   }  /* if */</a>
<a name="944"><span class="lineNum">     944 </span><span class="lineCov">          1 : }  /* form_tag_reference */</span></a>
<a name="945"><span class="lineNum">     945 </span>            : </a>
<a name="946"><span class="lineNum">     946 </span>            : </a>
<a name="947"><span class="lineNum">     947 </span>            : /*ARGSUSED*/ /* &lt;-- for_generated_code is not used in certain cases. */</a>
<a name="948"><span class="lineNum">     948 </span><span class="lineCov">       1286 : a_const_char *int_kind_name_full(an_integer_kind kind,</span></a>
<a name="949"><span class="lineNum">     949 </span>            :                                  a_boolean       for_generated_code)</a>
<a name="950"><span class="lineNum">     950 </span>            : /*</a>
<a name="951"><span class="lineNum">     951 </span>            : Return a string for the name of an integer kind.  Return a string beginning</a>
<a name="952"><span class="lineNum">     952 </span>            : with &quot;**BAD&quot; for a bad integer kind.  for_generated_code is TRUE if the</a>
<a name="953"><span class="lineNum">     953 </span>            : name is intended for use in code generated by the C-generating back end or</a>
<a name="954"><span class="lineNum">     954 </span>            : C++-generating back end.</a>
<a name="955"><span class="lineNum">     955 </span>            : */</a>
<a name="956"><span class="lineNum">     956 </span>            : {</a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">       1286 :   a_const_char *p;</span></a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            : #if !STANDALONE_UTILITY_PROGRAM</a>
<a name="960"><span class="lineNum">     960 </span>            :   /* In some modes, plain char is equivalent to signed char.  In such</a>
<a name="961"><span class="lineNum">     961 </span>            :      modes, output just &quot;char&quot; for the equivalent type. */</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">       1286 :   if (kind == plain_char_int_kind) kind = (an_integer_kind)ik_char;</span></a>
<a name="963"><span class="lineNum">     963 </span>            : #endif /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="964"><span class="lineNum">     964 </span><span class="lineCov">       1285 :   switch (kind) {</span></a>
<a name="965"><span class="lineNum">     965 </span>            :     case ik_char:               p = &quot;char&quot;;               break;</a>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 :     case ik_signed_char:        p = &quot;signed char&quot;;        break;</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineNoCov">          0 :     case ik_unsigned_char:      p = &quot;unsigned char&quot;;      break;</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineNoCov">          0 :     case ik_short:              p = &quot;short&quot;;              break;</span></a>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">        320 :     case ik_unsigned_short:     p = &quot;unsigned short&quot;;     break;</span></a>
<a name="970"><span class="lineNum">     970 </span><span class="lineCov">          5 :     case ik_int:                p = &quot;int&quot;;                break;</span></a>
<a name="971"><span class="lineNum">     971 </span><span class="lineCov">        320 :     case ik_unsigned_int:       p = &quot;unsigned int&quot;;       break;</span></a>
<a name="972"><span class="lineNum">     972 </span><span class="lineCov">        320 :     case ik_long:               p = &quot;long&quot;;               break;</span></a>
<a name="973"><span class="lineNum">     973 </span><span class="lineCov">        320 :     case ik_unsigned_long:      p = &quot;unsigned long&quot;;      break;</span></a>
<a name="974"><span class="lineNum">     974 </span>            : #if LONG_LONG_ALLOWED</a>
<a name="975"><span class="lineNum">     975 </span><span class="lineNoCov">          0 :     case ik_long_long:          p = &quot;long long&quot;;</span></a>
<a name="976"><span class="lineNum">     976 </span><span class="lineNoCov">          0 :                                 goto common_long_long_processing;</span></a>
<a name="977"><span class="lineNum">     977 </span>            :     case ik_unsigned_long_long: p = &quot;unsigned long long&quot;;</a>
<a name="978"><span class="lineNum">     978 </span><span class="lineNoCov">          0 : common_long_long_processing:</span></a>
<a name="979"><span class="lineNum">     979 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="980"><span class="lineNum">     980 </span>            :                                 /* When generating code for MSVC++,</a>
<a name="981"><span class="lineNum">     981 </span>            :                                    use &quot;__int64&quot; for &quot;long long&quot;. */</a>
<a name="982"><span class="lineNum">     982 </span><span class="lineNoCov">          0 :                                 if (for_generated_code &amp;&amp;</span></a>
<a name="983"><span class="lineNum">     983 </span>            :                                     msvc_is_generated_code_target) {</a>
<a name="984"><span class="lineNum">     984 </span><span class="lineNoCov">          0 :                                   if (kind == (an_integer_kind)ik_long_long) {</span></a>
<a name="985"><span class="lineNum">     985 </span>            :                                     p = &quot;__int64&quot;;</a>
<a name="986"><span class="lineNum">     986 </span>            :                                   } else {</a>
<a name="987"><span class="lineNum">     987 </span><span class="lineNoCov">          0 :                                     p = &quot;unsigned __int64&quot;;</span></a>
<a name="988"><span class="lineNum">     988 </span>            :                                   }  /* if */</a>
<a name="989"><span class="lineNum">     989 </span>            :                                 }  /* if */</a>
<a name="990"><span class="lineNum">     990 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="991"><span class="lineNum">     991 </span>            :                                 break;</a>
<a name="992"><span class="lineNum">     992 </span>            : #endif /* LONG_LONG_ALLOWED */</a>
<a name="993"><span class="lineNum">     993 </span>            : #if INT128_EXTENSIONS_ALLOWED</a>
<a name="994"><span class="lineNum">     994 </span>            :     /* Currently, we only accept 128-bit integer types in GNU modes, where</a>
<a name="995"><span class="lineNum">     995 </span>            :        such types can be denoted using the predeclared typedefs __int128_t and</a>
<a name="996"><span class="lineNum">     996 </span>            :        __uint128_t.  Other dialects are likely to use a different notation for</a>
<a name="997"><span class="lineNum">     997 </span>            :        these types (e.g., &quot;signed __int128&quot; and &quot;unsigned __int128): This code</a>
<a name="998"><span class="lineNum">     998 </span>            :        should be revised for such dialects. */ </a>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :     case ik_int128:</span></a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineNoCov">          0 :                                 if (gnu_mode) {</span></a>
<a name="1001"><span class="lineNum">    1001 </span>            : #if !STANDALONE_UTILITY_PROGRAM</a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineNoCov">          0 :                                   check_assertion(int128_extensions_enabled);</span></a>
<a name="1003"><span class="lineNum">    1003 </span>            : #endif /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="1004"><span class="lineNum">    1004 </span>            :                                   p = &quot;__int128_t&quot;;</a>
<a name="1005"><span class="lineNum">    1005 </span>            :                                 } else {</a>
<a name="1006"><span class="lineNum">    1006 </span>            :                                   p = &quot;**128-BIT SIGNED INTEGER**&quot;;</a>
<a name="1007"><span class="lineNum">    1007 </span>            :                                 }  /* if */</a>
<a name="1008"><span class="lineNum">    1008 </span>            :                                 break;</a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     case ik_unsigned_int128:</span></a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                                 if (gnu_mode) {</span></a>
<a name="1011"><span class="lineNum">    1011 </span>            : #if !STANDALONE_UTILITY_PROGRAM</a>
<a name="1012"><span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                                   check_assertion(int128_extensions_enabled);</span></a>
<a name="1013"><span class="lineNum">    1013 </span>            : #endif /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="1014"><span class="lineNum">    1014 </span>            :                                   p = &quot;__uint128_t&quot;;</a>
<a name="1015"><span class="lineNum">    1015 </span>            :                                 } else {</a>
<a name="1016"><span class="lineNum">    1016 </span>            :                                   p = &quot;**128-BIT UNSIGNED INTEGER**&quot;;</a>
<a name="1017"><span class="lineNum">    1017 </span>            :                                 }  /* if */</a>
<a name="1018"><span class="lineNum">    1018 </span>            :                                 break;</a>
<a name="1019"><span class="lineNum">    1019 </span>            : #endif /* INT128_EXTENSIONS_ALLOWED */</a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     default:                    p = &quot;**BAD-INT-KIND**&quot;;</span></a>
<a name="1021"><span class="lineNum">    1021 </span>            :   }  /* switch */</a>
<a name="1022"><span class="lineNum">    1022 </span><span class="lineCov">       1286 :   return p;</span></a>
<a name="1023"><span class="lineNum">    1023 </span>            : }  /* int_kind_name_full */</a>
<a name="1024"><span class="lineNum">    1024 </span>            : </a>
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<a name="1026"><span class="lineNum">    1026 </span><span class="lineCov">       1280 : a_const_char *int_kind_name(an_integer_kind kind)</span></a>
<a name="1027"><span class="lineNum">    1027 </span>            : /*</a>
<a name="1028"><span class="lineNum">    1028 </span>            : Return a string for the name of an integer kind.  This is an interface</a>
<a name="1029"><span class="lineNum">    1029 </span>            : to int_kind_name_full for the normal case, i.e., when the name is not</a>
<a name="1030"><span class="lineNum">    1030 </span>            : intended for use in code generated by the C-generating back end or</a>
<a name="1031"><span class="lineNum">    1031 </span>            : C++-generating back end (for that, see int_kind_name_full).</a>
<a name="1032"><span class="lineNum">    1032 </span>            : */</a>
<a name="1033"><span class="lineNum">    1033 </span>            : {</a>
<a name="1034"><span class="lineNum">    1034 </span><span class="lineCov">       1280 :   a_const_char *p = int_kind_name_full(kind, /*for_generated_code=*/FALSE);</span></a>
<a name="1035"><span class="lineNum">    1035 </span><span class="lineCov">       1280 :   return p;</span></a>
<a name="1036"><span class="lineNum">    1036 </span>            : }  /* int_kind_name */</a>
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<a name="1038"><span class="lineNum">    1038 </span>            : </a>
<a name="1039"><span class="lineNum">    1039 </span>            : static a_const_char *int_type_name_full(a_type_ptr type,</a>
<a name="1040"><span class="lineNum">    1040 </span>            :                                         a_boolean  for_generated_code)</a>
<a name="1041"><span class="lineNum">    1041 </span>            : /*</a>
<a name="1042"><span class="lineNum">    1042 </span>            : Return a string for the name of the given integer type.  The standard cases</a>
<a name="1043"><span class="lineNum">    1043 </span>            : are delegated to int_kind_name_full, but for intrinsic Microsoft __intN types</a>
<a name="1044"><span class="lineNum">    1044 </span>            : (Visual C++ 6.0) the work is done here.  for_generated_code is TRUE if the</a>
<a name="1045"><span class="lineNum">    1045 </span>            : name is intended for use in code generated by the C-generating back end or</a>
<a name="1046"><span class="lineNum">    1046 </span>            : C++-generating back end.</a>
<a name="1047"><span class="lineNum">    1047 </span>            : */</a>
<a name="1048"><span class="lineNum">    1048 </span>            : {</a>
<a name="1049"><span class="lineNum">    1049 </span>            :   a_const_char     *result;</a>
<a name="1050"><span class="lineNum">    1050 </span>            : </a>
<a name="1051"><span class="lineNum">    1051 </span>            :   check_assertion(type-&gt;kind == (a_type_kind)tk_integer);</a>
<a name="1052"><span class="lineNum">    1052 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="1053"><span class="lineNum">    1053 </span>            :   if (type-&gt;variant.integer.microsoft_sized_int_type) {</a>
<a name="1054"><span class="lineNum">    1054 </span>            :     an_integer_kind  kind = type-&gt;variant.integer.int_kind;</a>
<a name="1055"><span class="lineNum">    1055 </span>            : </a>
<a name="1056"><span class="lineNum">    1056 </span>            :     if (kind == targ_int8_int_kind) {</a>
<a name="1057"><span class="lineNum">    1057 </span>            :       result = &quot;__int8&quot;;</a>
<a name="1058"><span class="lineNum">    1058 </span>            :     } else if (kind == targ_unsigned_int8_int_kind) {</a>
<a name="1059"><span class="lineNum">    1059 </span>            :       result = &quot;unsigned __int8&quot;;</a>
<a name="1060"><span class="lineNum">    1060 </span>            :     } else if (kind == targ_int16_int_kind) {</a>
<a name="1061"><span class="lineNum">    1061 </span>            :       result = &quot;__int16&quot;;</a>
<a name="1062"><span class="lineNum">    1062 </span>            :     } else if (kind == targ_unsigned_int16_int_kind) {</a>
<a name="1063"><span class="lineNum">    1063 </span>            :       result = &quot;unsigned __int16&quot;;</a>
<a name="1064"><span class="lineNum">    1064 </span>            :     } else if (kind == targ_int32_int_kind) {</a>
<a name="1065"><span class="lineNum">    1065 </span>            :       result = &quot;__int32&quot;;</a>
<a name="1066"><span class="lineNum">    1066 </span>            :     } else if (kind == targ_unsigned_int32_int_kind) {</a>
<a name="1067"><span class="lineNum">    1067 </span>            :       result = &quot;unsigned __int32&quot;;</a>
<a name="1068"><span class="lineNum">    1068 </span>            :     } else if (kind == targ_int64_int_kind) {</a>
<a name="1069"><span class="lineNum">    1069 </span>            :       result = &quot;__int64&quot;;</a>
<a name="1070"><span class="lineNum">    1070 </span>            :     } else if (kind == targ_unsigned_int64_int_kind) {</a>
<a name="1071"><span class="lineNum">    1071 </span>            :       result = &quot;unsigned __int64&quot;;</a>
<a name="1072"><span class="lineNum">    1072 </span>            :     } else {</a>
<a name="1073"><span class="lineNum">    1073 </span>            :       result = &quot;**BAD-SIZED-INT-KIND**&quot;;</a>
<a name="1074"><span class="lineNum">    1074 </span>            :     }  /* if */</a>
<a name="1075"><span class="lineNum">    1075 </span>            :   } else</a>
<a name="1076"><span class="lineNum">    1076 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="1077"><span class="lineNum">    1077 </span>            :   /* Do not insert code here. */</a>
<a name="1078"><span class="lineNum">    1078 </span>            :   {</a>
<a name="1079"><span class="lineNum">    1079 </span>            :     result = int_kind_name_full(type-&gt;variant.integer.int_kind,</a>
<a name="1080"><span class="lineNum">    1080 </span>            :                                 for_generated_code);</a>
<a name="1081"><span class="lineNum">    1081 </span>            :   }  /* if */</a>
<a name="1082"><span class="lineNum">    1082 </span>            :   return result;</a>
<a name="1083"><span class="lineNum">    1083 </span>            : }  /* int_type_name_full */</a>
<a name="1084"><span class="lineNum">    1084 </span>            : </a>
<a name="1085"><span class="lineNum">    1085 </span>            : </a>
<a name="1086"><span class="lineNum">    1086 </span><span class="lineNoCov">          0 : a_const_char *int_type_name(a_type_ptr type)</span></a>
<a name="1087"><span class="lineNum">    1087 </span>            : /*</a>
<a name="1088"><span class="lineNum">    1088 </span>            : Return a string for the name of the given integer type.  This is an interface</a>
<a name="1089"><span class="lineNum">    1089 </span>            : to int_type_name_full for the normal case, i.e., when the name is not intended</a>
<a name="1090"><span class="lineNum">    1090 </span>            : for use in code generated by the C-generating back end or C++-generating</a>
<a name="1091"><span class="lineNum">    1091 </span>            : back end (for that, see int_type_name_full).</a>
<a name="1092"><span class="lineNum">    1092 </span>            : */</a>
<a name="1093"><span class="lineNum">    1093 </span>            : {</a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   a_const_char *result = int_type_name_full(type,</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            :                                             /*for_generated_code=*/FALSE);</a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="1097"><span class="lineNum">    1097 </span>            : }  /* int_type_name */</a>
<a name="1098"><span class="lineNum">    1098 </span>            : </a>
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<a name="1100"><span class="lineNum">    1100 </span><span class="lineCov">          6 : static void form_int_type_name(a_type_ptr                            type,</span></a>
<a name="1101"><span class="lineNum">    1101 </span>            :                                an_il_to_str_output_control_block_ptr octl)</a>
<a name="1102"><span class="lineNum">    1102 </span>            : /*</a>
<a name="1103"><span class="lineNum">    1103 </span>            : Output a string for the name of an integer kind, doing the output in the</a>
<a name="1104"><span class="lineNum">    1104 </span>            : way described by octl.</a>
<a name="1105"><span class="lineNum">    1105 </span>            : */</a>
<a name="1106"><span class="lineNum">    1106 </span>            : {</a>
<a name="1107"><span class="lineNum">    1107 </span><span class="lineCov">          6 :   a_const_char     *str = NULL;</span></a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineCov">          6 :   an_integer_kind  kind = type-&gt;variant.integer.int_kind;</span></a>
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineCov">          6 :   if (octl-&gt;gen_pcc_code) {</span></a>
<a name="1111"><span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     if (kind == (an_integer_kind)ik_signed_char) {</span></a>
<a name="1112"><span class="lineNum">    1112 </span>            :       /* In pcc mode, &quot;signed&quot; doesn't exist, so this must be a plain</a>
<a name="1113"><span class="lineNum">    1113 </span>            :          char. */</a>
<a name="1114"><span class="lineNum">    1114 </span>            :       str = &quot;char&quot;;</a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     } else if (kind == (an_integer_kind)ik_unsigned_char &amp;&amp;</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                !il_header.plain_chars_are_signed) {</span></a>
<a name="1117"><span class="lineNum">    1117 </span>            :       /* In pcc mode, &quot;char&quot; is turned into signed char or unsigned char.</a>
<a name="1118"><span class="lineNum">    1118 </span>            :          If unsigned char is the default, we don't have to say &quot;unsigned&quot;. */</a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       str = &quot;char&quot;;</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            :     }  /* if */</a>
<a name="1121"><span class="lineNum">    1121 </span>            :   }  /* if */</a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineCov">          6 :   if (kind == (an_integer_kind)ik_unsigned_int &amp;&amp; octl-&gt;gen_compilable_code</span></a>
<a name="1123"><span class="lineNum">    1123 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="1124"><span class="lineNum">    1124 </span>            :       &amp;&amp; !type-&gt;variant.integer.microsoft_sized_int_type</a>
<a name="1125"><span class="lineNum">    1125 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="1126"><span class="lineNum">    1126 </span>            :                                                         ) {</a>
<a name="1127"><span class="lineNum">    1127 </span>            :     /* When generating compilable code, use &quot;unsigned&quot; instead of</a>
<a name="1128"><span class="lineNum">    1128 </span>            :        &quot;unsigned int&quot;.  This is necessary when doing vacuous destructors. */</a>
<a name="1129"><span class="lineNum">    1129 </span>            :     str = &quot;unsigned&quot;;</a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineCov">          6 :   } else if (str == NULL) {</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineCov">          6 :     str = int_type_name_full(type, (a_boolean)octl-&gt;gen_compilable_code);</span></a>
<a name="1132"><span class="lineNum">    1132 </span>            :   }  /* if */</a>
<a name="1133"><span class="lineNum">    1133 </span>            : #if CHECKING</a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineCov">          6 :   if (*str == '*'</span></a>
<a name="1135"><span class="lineNum">    1135 </span>            : #if DEBUG</a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineNoCov">          0 :       &amp;&amp; !octl-&gt;debug_output</span></a>
<a name="1137"><span class="lineNum">    1137 </span>            : #endif /* DEBUG */</a>
<a name="1138"><span class="lineNum">    1138 </span>            :                             ) {</a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     internal_error(&quot;form_int_type_name: bad integer kind&quot;);</span></a>
<a name="1140"><span class="lineNum">    1140 </span>            :   }  /* if */</a>
<a name="1141"><span class="lineNum">    1141 </span>            : #endif /* CHECKING */</a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineCov">          6 :   octl-&gt;output_str(str, octl);</span></a>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineCov">          6 : }  /* form_int_type_name */</span></a>
<a name="1144"><span class="lineNum">    1144 </span>            : </a>
<a name="1145"><span class="lineNum">    1145 </span>            : </a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineNoCov">          0 : a_const_char *float_kind_name(a_float_kind kind)</span></a>
<a name="1147"><span class="lineNum">    1147 </span>            : /*</a>
<a name="1148"><span class="lineNum">    1148 </span>            : Return a string for the name of a float kind.  Return a string beginning</a>
<a name="1149"><span class="lineNum">    1149 </span>            : with &quot;**BAD&quot; for a bad float kind.</a>
<a name="1150"><span class="lineNum">    1150 </span>            : */</a>
<a name="1151"><span class="lineNum">    1151 </span>            : {</a>
<a name="1152"><span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   a_const_char *p;</span></a>
<a name="1153"><span class="lineNum">    1153 </span>            : </a>
<a name="1154"><span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   switch (kind) {</span></a>
<a name="1155"><span class="lineNum">    1155 </span>            :     case fk_float:       p = &quot;float&quot;;              break;</a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     case fk_double:      p = &quot;double&quot;;             break;</span></a>
<a name="1157"><span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     case fk_long_double: p = &quot;long double&quot;;        break;</span></a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     case fk_float80:     p = &quot;__float80&quot;;          break;</span></a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineNoCov">          0 :     case fk_float128:    p = &quot;__float128&quot;;         break;</span></a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineNoCov">          0 :     default:             p = &quot;**BAD-FLOAT-KIND**&quot;;</span></a>
<a name="1161"><span class="lineNum">    1161 </span>            :   }  /* switch */</a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineNoCov">          0 :   return p;</span></a>
<a name="1163"><span class="lineNum">    1163 </span>            : }  /* float_kind_name */</a>
<a name="1164"><span class="lineNum">    1164 </span>            : </a>
<a name="1165"><span class="lineNum">    1165 </span>            : </a>
<a name="1166"><span class="lineNum">    1166 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="1167"><span class="lineNum">    1167 </span>            : #if LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C</a>
<a name="1168"><span class="lineNum">    1168 </span>            : #if ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE</a>
<a name="1169"><span class="lineNum">    1169 </span>            : static a_boolean double_for_long_double_warning_issued;</a>
<a name="1170"><span class="lineNum">    1170 </span>            : #endif /* ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE */</a>
<a name="1171"><span class="lineNum">    1171 </span>            : #endif /* LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C */</a>
<a name="1172"><span class="lineNum">    1172 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="1173"><span class="lineNum">    1173 </span>            : </a>
<a name="1174"><span class="lineNum">    1174 </span>            : </a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 : static void form_float_kind_name(a_float_kind                          kind,</span></a>
<a name="1176"><span class="lineNum">    1176 </span>            :                                  an_il_to_str_output_control_block_ptr octl)</a>
<a name="1177"><span class="lineNum">    1177 </span>            : /*</a>
<a name="1178"><span class="lineNum">    1178 </span>            : Output a string for the name of a float kind, doing the output in the</a>
<a name="1179"><span class="lineNum">    1179 </span>            : way described by octl.</a>
<a name="1180"><span class="lineNum">    1180 </span>            : */</a>
<a name="1181"><span class="lineNum">    1181 </span>            : {</a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   a_const_char *str;</span></a>
<a name="1183"><span class="lineNum">    1183 </span>            : </a>
<a name="1184"><span class="lineNum">    1184 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="1185"><span class="lineNum">    1185 </span>            : #if LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C</a>
<a name="1186"><span class="lineNum">    1186 </span>            :   if (octl-&gt;c_generating_back_end) {</a>
<a name="1187"><span class="lineNum">    1187 </span>            :     if (kind == (a_float_kind)fk_long_double) {</a>
<a name="1188"><span class="lineNum">    1188 </span>            :       /* When generating K&amp;R C from the C-generating back end, put out</a>
<a name="1189"><span class="lineNum">    1189 </span>            :          &quot;double&quot; for &quot;long double&quot; and issue a one-time-only warning. */</a>
<a name="1190"><span class="lineNum">    1190 </span>            : #if ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE</a>
<a name="1191"><span class="lineNum">    1191 </span>            :       if (!double_for_long_double_warning_issued) {</a>
<a name="1192"><span class="lineNum">    1192 </span>            :         pos_warning(ec_double_for_long_double, &amp;null_source_position);</a>
<a name="1193"><span class="lineNum">    1193 </span>            :         double_for_long_double_warning_issued = TRUE;</a>
<a name="1194"><span class="lineNum">    1194 </span>            :       }  /* if */</a>
<a name="1195"><span class="lineNum">    1195 </span>            : #endif /* ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE */</a>
<a name="1196"><span class="lineNum">    1196 </span>            :       kind = (a_float_kind)fk_double;</a>
<a name="1197"><span class="lineNum">    1197 </span>            :     }  /* if */</a>
<a name="1198"><span class="lineNum">    1198 </span>            :   }  /* if */</a>
<a name="1199"><span class="lineNum">    1199 </span>            : #endif /* LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C */</a>
<a name="1200"><span class="lineNum">    1200 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="1201"><span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   str = float_kind_name(kind);</span></a>
<a name="1202"><span class="lineNum">    1202 </span>            : #if CHECKING</a>
<a name="1203"><span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   if (*str == '*'</span></a>
<a name="1204"><span class="lineNum">    1204 </span>            : #if DEBUG</a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineNoCov">          0 :       &amp;&amp; !octl-&gt;debug_output</span></a>
<a name="1206"><span class="lineNum">    1206 </span>            : #endif /* DEBUG */</a>
<a name="1207"><span class="lineNum">    1207 </span>            :                             ) {</a>
<a name="1208"><span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     internal_error(&quot;form_float_kind_name: bad float kind&quot;);</span></a>
<a name="1209"><span class="lineNum">    1209 </span>            :   }  /* if */</a>
<a name="1210"><span class="lineNum">    1210 </span>            : #endif /* CHECKING */</a>
<a name="1211"><span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(str, octl);</span></a>
<a name="1212"><span class="lineNum">    1212 </span><span class="lineNoCov">          0 : }  /* form_float_kind_name */</span></a>
<a name="1213"><span class="lineNum">    1213 </span>            : </a>
<a name="1214"><span class="lineNum">    1214 </span>            : </a>
<a name="1215"><span class="lineNum">    1215 </span>            : #if !UPC_EXTENSIONS_ALLOWED</a>
<a name="1216"><span class="lineNum">    1216 </span>            : /*ARGSUSED*/ /* upc_block_size is only used when UPC extensions are allowed. */</a>
<a name="1217"><span class="lineNum">    1217 </span>            : #endif /* !UPC_EXTENSIONS_ALLOWED */</a>
<a name="1218"><span class="lineNum">    1218 </span><span class="lineCov">          1 : void form_type_qualifier(</span></a>
<a name="1219"><span class="lineNum">    1219 </span>            :                      a_type_qualifier_set                  qualifiers,</a>
<a name="1220"><span class="lineNum">    1220 </span>            :                      a_upc_block_size                      upc_block_size,</a>
<a name="1221"><span class="lineNum">    1221 </span>            :                      a_boolean                             need_trailing_space,</a>
<a name="1222"><span class="lineNum">    1222 </span>            :                      an_il_to_str_output_control_block_ptr octl)</a>
<a name="1223"><span class="lineNum">    1223 </span>            : /*</a>
<a name="1224"><span class="lineNum">    1224 </span>            : Output a string for the type qualifiers in the given qualifier set.</a>
<a name="1225"><span class="lineNum">    1225 </span>            : If the qualifier set is empty, put out nothing.  If need_trailing_space</a>
<a name="1226"><span class="lineNum">    1226 </span>            : is TRUE, put out a space after the type qualifier (if one is put out).</a>
<a name="1227"><span class="lineNum">    1227 </span>            : Do the output in the way described by octl.</a>
<a name="1228"><span class="lineNum">    1228 </span>            : */</a>
<a name="1229"><span class="lineNum">    1229 </span>            : {</a>
<a name="1230"><span class="lineNum">    1230 </span><span class="lineCov">          1 :   a_boolean qualifier_put_out = FALSE;</span></a>
<a name="1231"><span class="lineNum">    1231 </span>            : #if NAMED_ADDRESS_SPACES_ALLOWED</a>
<a name="1232"><span class="lineNum">    1232 </span><span class="lineCov">          1 :   a_named_address_space_id</span></a>
<a name="1233"><span class="lineNum">    1233 </span><span class="lineCov">          1 :             nas_id = named_address_space_from_qualifier_set(qualifiers);</span></a>
<a name="1234"><span class="lineNum">    1234 </span>            : #endif /* NAMED_ADDRESS_SPACES_ALLOWED */</a>
<a name="1235"><span class="lineNum">    1235 </span>            : </a>
<a name="1236"><span class="lineNum">    1236 </span>            : /* Local macro that determines whether a given qualifier is present,</a>
<a name="1237"><span class="lineNum">    1237 </span>            :    and if so outputs the appropriate string. */</a>
<a name="1238"><span class="lineNum">    1238 </span>            : #define output_qualifier(flag, string)                                  \</a>
<a name="1239"><span class="lineNum">    1239 </span>            : {                                                                       \</a>
<a name="1240"><span class="lineNum">    1240 </span>            :   if ((qualifiers &amp; flag) != 0) {                                   \</a>
<a name="1241"><span class="lineNum">    1241 </span>            :     if (qualifier_put_out) octl-&gt;output_str(&quot; &quot;, octl);                    \</a>
<a name="1242"><span class="lineNum">    1242 </span>            :     qualifier_put_out = TRUE;                                           \</a>
<a name="1243"><span class="lineNum">    1243 </span>            :     octl-&gt;output_str(string, octl);                                  \</a>
<a name="1244"><span class="lineNum">    1244 </span>            :   }  /* if */                                                           \</a>
<a name="1245"><span class="lineNum">    1245 </span>            : }  /* output_qualifier */</a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span><span class="lineCov">          1 :   if (octl-&gt;gen_pcc_code) {</span></a>
<a name="1248"><span class="lineNum">    1248 </span>            :     /* Qualifiers are suppressed when generating K&amp;R C. */</a>
<a name="1249"><span class="lineNum">    1249 </span>            :   } else {</a>
<a name="1250"><span class="lineNum">    1250 </span>            : #if BACK_END_IS_C_GEN_BE &amp;&amp; SUPPRESS_CONST_IN_GENERATED_C</a>
<a name="1251"><span class="lineNum">    1251 </span>            :     /* Suppress &quot;const&quot; in the output of the C-generating back end. */</a>
<a name="1252"><span class="lineNum">    1252 </span>            :     if (octl-&gt;c_generating_back_end) qualifiers &amp;= ~TQ_CONST;</a>
<a name="1253"><span class="lineNum">    1253 </span>            : #endif /* BACK_END_IS_C_GEN_BE &amp;&amp; SUPPRESS_CONST_IN_GENERATED_C */</a>
<a name="1254"><span class="lineNum">    1254 </span><span class="lineCov">          1 :     output_qualifier(TQ_C11_ATOMIC, &quot;_Atomic&quot;);</span></a>
<a name="1255"><span class="lineNum">    1255 </span><span class="lineCov">          1 :     output_qualifier(TQ_CONST, &quot;const&quot;); /*lint !e774*/</span></a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineCov">          1 :     output_qualifier(TQ_VOLATILE, &quot;volatile&quot;);</span></a>
<a name="1257"><span class="lineNum">    1257 </span>            : #if SUPPRESS_RESTRICT_IN_GENERATED_CODE</a>
<a name="1258"><span class="lineNum">    1258 </span>            :     /* Suppress &quot;restrict&quot; in generated compilable code. */</a>
<a name="1259"><span class="lineNum">    1259 </span><span class="lineCov">          1 :     if (octl-&gt;gen_compilable_code) qualifiers &amp;= ~TQ_RESTRICT;</span></a>
<a name="1260"><span class="lineNum">    1260 </span>            : #endif /* SUPPRESS_RESTRICT_IN_GENERATED_CODE */</a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineCov">          1 :     output_qualifier(TQ_RESTRICT, (char *)(use_gnu_form() ? &quot;__restrict__&quot; :</span></a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineCov">          1 :                                                             &quot;restrict&quot;));</span></a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineCov">          1 :     { a_boolean  output_nullability = !octl-&gt;gen_compilable_code;</span></a>
<a name="1264"><span class="lineNum">    1264 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="1265"><span class="lineNum">    1265 </span>            :       /* Nullability qualifiers are only accepted by Clang and can safely be</a>
<a name="1266"><span class="lineNum">    1266 </span>            :          ignored.  So when generating compilable code, do not render them</a>
<a name="1267"><span class="lineNum">    1267 </span>            :          unless we are generating code for Clang. */</a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">          1 :       output_nullability |= clang_is_generated_code_target;</span></a>
<a name="1269"><span class="lineNum">    1269 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="1270"><span class="lineNum">    1270 </span><span class="lineCov">          1 :       if (output_nullability) {</span></a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineCov">          1 :         output_qualifier(TQ_NULLABLE, &quot;_Nullable&quot;);</span></a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineCov">          1 :         output_qualifier(TQ_NONNULL, &quot;_Nonnull&quot;);</span></a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineCov">          1 :         output_qualifier(TQ_NULL_UNSPECIFIED, &quot;_Null_unspecified&quot;);</span></a>
<a name="1274"><span class="lineNum">    1274 </span>            :       }  /* if */</a>
<a name="1275"><span class="lineNum">    1275 </span>            :     }</a>
<a name="1276"><span class="lineNum">    1276 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="1277"><span class="lineNum">    1277 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="1278"><span class="lineNum">    1278 </span>            :     if (octl-&gt;gen_compilable_code &amp;&amp;</a>
<a name="1279"><span class="lineNum">    1279 </span>            :         !microsoft_dialect_is_generated_code_target) {</a>
<a name="1280"><span class="lineNum">    1280 </span>            :       /* Suppress &quot;__unaligned&quot; in generated compilable code. */</a>
<a name="1281"><span class="lineNum">    1281 </span>            :       qualifiers &amp;= ~TQ_UNALIGNED;</a>
<a name="1282"><span class="lineNum">    1282 </span>            :     }  /* if */</a>
<a name="1283"><span class="lineNum">    1283 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="1284"><span class="lineNum">    1284 </span>            :     output_qualifier(TQ_UNALIGNED, &quot;__unaligned&quot;);</a>
<a name="1285"><span class="lineNum">    1285 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="1286"><span class="lineNum">    1286 </span>            : #if NEAR_AND_FAR_ALLOWED</a>
<a name="1287"><span class="lineNum">    1287 </span>            : #if SUPPRESS_NEAR_AND_FAR_IN_GENERATED_CODE</a>
<a name="1288"><span class="lineNum">    1288 </span>            :     if (octl-&gt;gen_compilable_code) {</a>
<a name="1289"><span class="lineNum">    1289 </span>            :       /* Suppress &quot;__near&quot; and &quot;__far&quot; in generated compilable code. */</a>
<a name="1290"><span class="lineNum">    1290 </span>            :       qualifiers &amp;= ~(TQ_NEAR | TQ_FAR);</a>
<a name="1291"><span class="lineNum">    1291 </span>            :     }  /* if */</a>
<a name="1292"><span class="lineNum">    1292 </span>            : #endif /* SUPPRESS_NEAR_AND_FAR_IN_GENERATED_CODE */</a>
<a name="1293"><span class="lineNum">    1293 </span>            :     output_qualifier(TQ_NEAR,</a>
<a name="1294"><span class="lineNum">    1294 </span>            :                      (char *)(use_microsoft_form() ? &quot;__near&quot; : &quot;near&quot;));</a>
<a name="1295"><span class="lineNum">    1295 </span>            :     output_qualifier(TQ_FAR,</a>
<a name="1296"><span class="lineNum">    1296 </span>            :                      (char *)(use_microsoft_form() ? &quot;__far&quot; : &quot;far&quot;));</a>
<a name="1297"><span class="lineNum">    1297 </span>            : #endif /* NEAR_AND_FAR_ALLOWED */</a>
<a name="1298"><span class="lineNum">    1298 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="1299"><span class="lineNum">    1299 </span><span class="lineCov">          1 :     output_qualifier(TQ_UPC_STRICT, &quot;strict&quot;);</span></a>
<a name="1300"><span class="lineNum">    1300 </span><span class="lineCov">          1 :     output_qualifier(TQ_UPC_RELAXED, &quot;relaxed&quot;);</span></a>
<a name="1301"><span class="lineNum">    1301 </span><span class="lineCov">          1 :     if (qualifiers &amp; TQ_UPC_SHARED) {</span></a>
<a name="1302"><span class="lineNum">    1302 </span><span class="lineNoCov">          0 :       output_qualifier(TQ_UPC_SHARED, &quot;shared&quot;);</span></a>
<a name="1303"><span class="lineNum">    1303 </span><span class="lineNoCov">          0 :       if (upc_block_size == UPC_BLOCK_SIZE_NONE) {</span></a>
<a name="1304"><span class="lineNum">    1304 </span>            :         /* Nothing to be done. */</a>
<a name="1305"><span class="lineNum">    1305 </span><span class="lineNoCov">          0 :       } else if (upc_block_size == UPC_BLOCK_SIZE_BLOCK) {</span></a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;[*]&quot;, octl);</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            :       } else {</a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;[&quot;, octl);</span></a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineNoCov">          0 :         form_unsigned_num((a_host_large_unsigned)upc_block_size, /*lint !e571*/</span></a>
<a name="1310"><span class="lineNum">    1310 </span>            :                           octl);</a>
<a name="1311"><span class="lineNum">    1311 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;]&quot;, octl);</span></a>
<a name="1312"><span class="lineNum">    1312 </span>            :       }  /* if */</a>
<a name="1313"><span class="lineNum">    1313 </span>            :     }  /* if */</a>
<a name="1314"><span class="lineNum">    1314 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="1315"><span class="lineNum">    1315 </span>            : #if NAMED_ADDRESS_SPACES_ALLOWED</a>
<a name="1316"><span class="lineNum">    1316 </span><span class="lineCov">          1 :     if (nas_id != 0) {</span></a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineNoCov">          0 :       if (qualifier_put_out) octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="1318"><span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(named_address_spaces[nas_id].name, octl);</span></a>
<a name="1319"><span class="lineNum">    1319 </span><span class="lineNoCov">          0 :       qualifier_put_out = TRUE;</span></a>
<a name="1320"><span class="lineNum">    1320 </span>            :     }  /* if */</a>
<a name="1321"><span class="lineNum">    1321 </span>            : #endif /* NAMED_ADDRESS_SPACES_ALLOWED */</a>
<a name="1322"><span class="lineNum">    1322 </span>            :     /* Put out a trailing space if required. */</a>
<a name="1323"><span class="lineNum">    1323 </span><span class="lineCov">          1 :     if (need_trailing_space &amp;&amp; qualifier_put_out) octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="1324"><span class="lineNum">    1324 </span>            :   }  /* if */</a>
<a name="1325"><span class="lineNum">    1325 </span>            : #undef output_qualifier</a>
<a name="1326"><span class="lineNum">    1326 </span><span class="lineCov">          1 : }  /* form_type_qualifier */</span></a>
<a name="1327"><span class="lineNum">    1327 </span>            : </a>
<a name="1328"><span class="lineNum">    1328 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="1329"><span class="lineNum">    1329 </span>            : </a>
<a name="1330"><span class="lineNum">    1330 </span>            : a_const_char *cli_managed_class_tag_keyword(a_type_ptr type)</a>
<a name="1331"><span class="lineNum">    1331 </span>            : /*</a>
<a name="1332"><span class="lineNum">    1332 </span>            : Return a string that describes the tag kind for the indicated CLI class type.</a>
<a name="1333"><span class="lineNum">    1333 </span>            : The caller should have already determined that type is a CLI class type.</a>
<a name="1334"><span class="lineNum">    1334 </span>            : */</a>
<a name="1335"><span class="lineNum">    1335 </span>            : {</a>
<a name="1336"><span class="lineNum">    1336 </span>            :   a_const_char                 *result = NULL;</a>
<a name="1337"><span class="lineNum">    1337 </span>            :   a_class_type_supplement_ptr  ctsp = class_type_supp(type);</a>
<a name="1338"><span class="lineNum">    1338 </span>            : </a>
<a name="1339"><span class="lineNum">    1339 </span>            :   switch (type-&gt;kind) {</a>
<a name="1340"><span class="lineNum">    1340 </span>            :     case tk_class:</a>
<a name="1341"><span class="lineNum">    1341 </span>            :       switch (ctsp-&gt;cli_class_type_kind) {</a>
<a name="1342"><span class="lineNum">    1342 </span>            :         case cctk_ref:       result = &quot;ref class&quot;;       break;</a>
<a name="1343"><span class="lineNum">    1343 </span>            :         case cctk_value:     result = &quot;value class&quot;;     break;</a>
<a name="1344"><span class="lineNum">    1344 </span>            :         case cctk_interface: result = &quot;interface class&quot;; break;</a>
<a name="1345"><span class="lineNum">    1345 </span>            :         default:             unexpected_condition();</a>
<a name="1346"><span class="lineNum">    1346 </span>            :       }  /* switch */</a>
<a name="1347"><span class="lineNum">    1347 </span>            :       break;</a>
<a name="1348"><span class="lineNum">    1348 </span>            :     case tk_struct:</a>
<a name="1349"><span class="lineNum">    1349 </span>            :       switch (ctsp-&gt;cli_class_type_kind) {</a>
<a name="1350"><span class="lineNum">    1350 </span>            :         case cctk_ref:       result = &quot;ref struct&quot;;        break;</a>
<a name="1351"><span class="lineNum">    1351 </span>            :         case cctk_value:     result = &quot;value struct&quot;;      break;</a>
<a name="1352"><span class="lineNum">    1352 </span>            :         case cctk_interface: result = &quot;interface struct&quot;;  break;</a>
<a name="1353"><span class="lineNum">    1353 </span>            :         default:             unexpected_condition();</a>
<a name="1354"><span class="lineNum">    1354 </span>            :       }  /* switch */</a>
<a name="1355"><span class="lineNum">    1355 </span>            :       break;</a>
<a name="1356"><span class="lineNum">    1356 </span>            :     default:</a>
<a name="1357"><span class="lineNum">    1357 </span>            :       unexpected_condition();</a>
<a name="1358"><span class="lineNum">    1358 </span>            :   }  /* switch */</a>
<a name="1359"><span class="lineNum">    1359 </span>            :   return result;</a>
<a name="1360"><span class="lineNum">    1360 </span>            : }  /* cli_managed_class_tag_keyword */</a>
<a name="1361"><span class="lineNum">    1361 </span>            : </a>
<a name="1362"><span class="lineNum">    1362 </span>            : </a>
<a name="1363"><span class="lineNum">    1363 </span>            : void form_pointer_modifiers(a_pointer_modifier_set                 modifiers,</a>
<a name="1364"><span class="lineNum">    1364 </span>            :                             an_il_to_str_output_control_block_ptr  octl)</a>
<a name="1365"><span class="lineNum">    1365 </span>            : /*</a>
<a name="1366"><span class="lineNum">    1366 </span>            : Output a string for the pointer modifiers in the given modifier set.  If the</a>
<a name="1367"><span class="lineNum">    1367 </span>            : set is empty, put out nothing.  No trailing space is added to the output.</a>
<a name="1368"><span class="lineNum">    1368 </span>            : Do the output in the way described by octl.</a>
<a name="1369"><span class="lineNum">    1369 </span>            : */</a>
<a name="1370"><span class="lineNum">    1370 </span>            : {</a>
<a name="1371"><span class="lineNum">    1371 </span>            :   if (modifiers != PM_NONE) {</a>
<a name="1372"><span class="lineNum">    1372 </span>            :     a_boolean  modifier_put_out = FALSE;</a>
<a name="1373"><span class="lineNum">    1373 </span>            : /* Local macro that determines whether a given qualifier is present,</a>
<a name="1374"><span class="lineNum">    1374 </span>            :    and if so outputs the appropriate string. */</a>
<a name="1375"><span class="lineNum">    1375 </span>            : #define output_modifier(flag, string)                                        \</a>
<a name="1376"><span class="lineNum">    1376 </span>            : {                                                                            \</a>
<a name="1377"><span class="lineNum">    1377 </span>            :   if ((modifiers &amp; flag) != 0) {                                             \</a>
<a name="1378"><span class="lineNum">    1378 </span>            :     if (modifier_put_out) octl-&gt;output_str(&quot; &quot;, octl);                       \</a>
<a name="1379"><span class="lineNum">    1379 </span>            :     modifier_put_out = TRUE;                                                 \</a>
<a name="1380"><span class="lineNum">    1380 </span>            :     octl-&gt;output_str(string, octl);                                          \</a>
<a name="1381"><span class="lineNum">    1381 </span>            :   }  /* if */                                                                \</a>
<a name="1382"><span class="lineNum">    1382 </span>            : }  /* output_qualifier */</a>
<a name="1383"><span class="lineNum">    1383 </span>            :     output_modifier(PM_PTR32, &quot;__ptr32&quot;);</a>
<a name="1384"><span class="lineNum">    1384 </span>            :     output_modifier(PM_PTR64, &quot;__ptr64&quot;);</a>
<a name="1385"><span class="lineNum">    1385 </span>            :     output_modifier(PM_SPTR, &quot;__sptr&quot;);</a>
<a name="1386"><span class="lineNum">    1386 </span>            :     output_modifier(PM_UPTR, &quot;__uptr&quot;);</a>
<a name="1387"><span class="lineNum">    1387 </span>            : #undef output_modifier</a>
<a name="1388"><span class="lineNum">    1388 </span>            :   }  /* if */</a>
<a name="1389"><span class="lineNum">    1389 </span>            : }  /* form_pointer_modifiers */</a>
<a name="1390"><span class="lineNum">    1390 </span>            : </a>
<a name="1391"><span class="lineNum">    1391 </span>            : </a>
<a name="1392"><span class="lineNum">    1392 </span>            : void form_calling_convention(</a>
<a name="1393"><span class="lineNum">    1393 </span>            :                      a_calling_convention                  calling_convention,</a>
<a name="1394"><span class="lineNum">    1394 </span>            :                      an_il_to_str_output_control_block_ptr octl)</a>
<a name="1395"><span class="lineNum">    1395 </span>            : /*</a>
<a name="1396"><span class="lineNum">    1396 </span>            : Output a string for a Microsoft-specific calling convention.</a>
<a name="1397"><span class="lineNum">    1397 </span>            : Put out a space after the calling convention (if one is put out).</a>
<a name="1398"><span class="lineNum">    1398 </span>            : Do the output in the way described by octl.  If GNU C code is generated,</a>
<a name="1399"><span class="lineNum">    1399 </span>            : nothing should be done here since the calling convention will be issued as</a>
<a name="1400"><span class="lineNum">    1400 </span>            : an attribute (in that case microsoft_dialect_is_generated_code_target should</a>
<a name="1401"><span class="lineNum">    1401 </span>            : be FALSE).</a>
<a name="1402"><span class="lineNum">    1402 </span>            : */</a>
<a name="1403"><span class="lineNum">    1403 </span>            : {</a>
<a name="1404"><span class="lineNum">    1404 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="1405"><span class="lineNum">    1405 </span>            :   if (octl-&gt;gen_compilable_code &amp;&amp;</a>
<a name="1406"><span class="lineNum">    1406 </span>            :       !microsoft_dialect_is_generated_code_target) {</a>
<a name="1407"><span class="lineNum">    1407 </span>            :     /* The Microsoft keywords should only be suppressed in compilable code.</a>
<a name="1408"><span class="lineNum">    1408 </span>            :        Not, for example, in diagnostics. */</a>
<a name="1409"><span class="lineNum">    1409 </span>            :   } else</a>
<a name="1410"><span class="lineNum">    1410 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="1411"><span class="lineNum">    1411 </span>            :   /* Do not insert code here. */</a>
<a name="1412"><span class="lineNum">    1412 </span>            :   if (calling_convention != (a_calling_convention)cc_default) {</a>
<a name="1413"><span class="lineNum">    1413 </span>            :     /* Put out nothing for the default calling convention. */</a>
<a name="1414"><span class="lineNum">    1414 </span>            :     octl-&gt;output_str(calling_convention_names[(int)calling_convention], octl);</a>
<a name="1415"><span class="lineNum">    1415 </span>            :     /* Put out a trailing space. */</a>
<a name="1416"><span class="lineNum">    1416 </span>            :     octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="1417"><span class="lineNum">    1417 </span>            :   }  /* if */</a>
<a name="1418"><span class="lineNum">    1418 </span>            : }  /* form_calling_convention */</a>
<a name="1419"><span class="lineNum">    1419 </span>            : </a>
<a name="1420"><span class="lineNum">    1420 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="1421"><span class="lineNum">    1421 </span>            : </a>
<a name="1422"><span class="lineNum">    1422 </span>            : /*</a>
<a name="1423"><span class="lineNum">    1423 </span>            : Template parameters are primarily characterized by their coordinates: the</a>
<a name="1424"><span class="lineNum">    1424 </span>            : template nesting depth at which they are introduced and the position in the</a>
<a name="1425"><span class="lineNum">    1425 </span>            : associated template declaration clause.  Such parameters are represented by</a>
<a name="1426"><span class="lineNum">    1426 </span>            : a_constant or a_type entries whose source_correspondence entry may not always</a>
<a name="1427"><span class="lineNum">    1427 </span>            : contain the correct name, since the name can vary for a given coordinate set.</a>
<a name="1428"><span class="lineNum">    1428 </span>            : For example:</a>
<a name="1429"><span class="lineNum">    1429 </span>            :    template&lt;int I&gt; struct A {};</a>
<a name="1430"><span class="lineNum">    1430 </span>            :    template&lt;int I&gt; struct B { A&lt;I&gt; *a; };  // (1)</a>
<a name="1431"><span class="lineNum">    1431 </span>            :    template&lt;int K&gt; struct C { A&lt;K&gt; *a; };  // (2)</a>
<a name="1432"><span class="lineNum">    1432 </span>            : Only one type entry represents the type A&lt;#1&gt; in (1) and (2).  The source</a>
<a name="1433"><span class="lineNum">    1433 </span>            : correspondence entry for the first argument &quot;#1&quot; will name &quot;I&quot; because that</a>
<a name="1434"><span class="lineNum">    1434 </span>            : was the name used at the first point of instantiation of A&lt;#1&gt;.  However,</a>
<a name="1435"><span class="lineNum">    1435 </span>            : the C++ generating back (for example) needs to produce a name that is valid in</a>
<a name="1436"><span class="lineNum">    1436 </span>            : the context of use.  To achieve this, we establish a mapping from coordinates</a>
<a name="1437"><span class="lineNum">    1437 </span>            : to source correspondence entries, and we consult the map prior to emitting</a>
<a name="1438"><span class="lineNum">    1438 </span>            : a_type or a_constant entries that stand for template parameters.</a>
<a name="1439"><span class="lineNum">    1439 </span>            : */</a>
<a name="1440"><span class="lineNum">    1440 </span>            : </a>
<a name="1441"><span class="lineNum">    1441 </span>            : typedef struct a_template_param_map_level *a_template_param_map_level_ptr;</a>
<a name="1442"><span class="lineNum">    1442 </span>            : typedef struct a_template_param_map_level {</a>
<a name="1443"><span class="lineNum">    1443 </span>            :   /* A growable structure mapping (for a certain template nesting depth) the</a>
<a name="1444"><span class="lineNum">    1444 </span>            :      position of a template parameter to its current name. */</a>
<a name="1445"><span class="lineNum">    1445 </span>            :   a_template_param_list_pos</a>
<a name="1446"><span class="lineNum">    1446 </span>            :                 max_position;</a>
<a name="1447"><span class="lineNum">    1447 </span>            :                         /* The largest position ordinal for which a mapping is</a>
<a name="1448"><span class="lineNum">    1448 </span>            :                            stored at this depth. */</a>
<a name="1449"><span class="lineNum">    1449 </span>            :   a_source_correspondence_ptr</a>
<a name="1450"><span class="lineNum">    1450 </span>            :                 *source_corresp;</a>
<a name="1451"><span class="lineNum">    1451 </span>            :                         /* Points to an array of max_position possibly NULL</a>
<a name="1452"><span class="lineNum">    1452 </span>            :                            pointers to source correspondence entries. */</a>
<a name="1453"><span class="lineNum">    1453 </span>            : } a_template_param_map_level;</a>
<a name="1454"><span class="lineNum">    1454 </span>            : </a>
<a name="1455"><span class="lineNum">    1455 </span>            : </a>
<a name="1456"><span class="lineNum">    1456 </span>            : static a_template_param_map_level_ptr template_param_map;</a>
<a name="1457"><span class="lineNum">    1457 </span>            :                         /* A pointer to the two-level lookup structure. */</a>
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<a name="1459"><span class="lineNum">    1459 </span>            : static a_template_nesting_depth template_param_map_max_level;</a>
<a name="1460"><span class="lineNum">    1460 </span>            :                         /* The size of the first level (i.e., the maximum</a>
<a name="1461"><span class="lineNum">    1461 </span>            :                            template nesting depth for which a parameter</a>
<a name="1462"><span class="lineNum">    1462 </span>            :                            coordinate has been mapped). */</a>
<a name="1463"><span class="lineNum">    1463 </span>            : </a>
<a name="1464"><span class="lineNum">    1464 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="1465"><span class="lineNum">    1465 </span>            : </a>
<a name="1466"><span class="lineNum">    1466 </span>            : /*</a>
<a name="1467"><span class="lineNum">    1467 </span>            : The following structure is used to record the previous mapping for a</a>
<a name="1468"><span class="lineNum">    1468 </span>            : template parameter name so it can be restored after being overwritten by a</a>
<a name="1469"><span class="lineNum">    1469 </span>            : friend declaration inside a class template.  This happens when the friend</a>
<a name="1470"><span class="lineNum">    1470 </span>            : declaration is matched to an existing template declaration: the coordinates</a>
<a name="1471"><span class="lineNum">    1471 </span>            : will be those of the original declaration of the friend, so the mappings</a>
<a name="1472"><span class="lineNum">    1472 </span>            : from the friend declaration overwrite those of the class template</a>
<a name="1473"><span class="lineNum">    1473 </span>            : containing the friend declaration, and they must be restored so that</a>
<a name="1474"><span class="lineNum">    1474 </span>            : subsequent references to the containing class template's parameters will</a>
<a name="1475"><span class="lineNum">    1475 </span>            : use the correct names.</a>
<a name="1476"><span class="lineNum">    1476 </span>            : */</a>
<a name="1477"><span class="lineNum">    1477 </span>            : typedef struct a_saved_template_param_mapping</a>
<a name="1478"><span class="lineNum">    1478 </span>            :                                            *a_saved_template_param_mapping_ptr;</a>
<a name="1479"><span class="lineNum">    1479 </span>            : typedef struct a_saved_template_param_mapping {</a>
<a name="1480"><span class="lineNum">    1480 </span>            :   a_saved_template_param_mapping_ptr</a>
<a name="1481"><span class="lineNum">    1481 </span>            :                 next;   /* Points to the next saved mapping, either on the</a>
<a name="1482"><span class="lineNum">    1482 </span>            :                            active or the free list. */</a>
<a name="1483"><span class="lineNum">    1483 </span>            :   a_template_param_coordinate</a>
<a name="1484"><span class="lineNum">    1484 </span>            :                 coord;  /* The coordinates of the mapped parameter. */</a>
<a name="1485"><span class="lineNum">    1485 </span>            :   a_source_correspondence_ptr</a>
<a name="1486"><span class="lineNum">    1486 </span>            :                 scp;    /* The source correspondence used for the mapped</a>
<a name="1487"><span class="lineNum">    1487 </span>            :                            parameter. */</a>
<a name="1488"><span class="lineNum">    1488 </span>            : } a_saved_template_param_mapping;</a>
<a name="1489"><span class="lineNum">    1489 </span>            : </a>
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<a name="1491"><span class="lineNum">    1491 </span>            : static a_saved_template_param_mapping_ptr</a>
<a name="1492"><span class="lineNum">    1492 </span>            :                 saved_template_param_mappings;</a>
<a name="1493"><span class="lineNum">    1493 </span>            :                         /* Template parameter mappings to be restored by</a>
<a name="1494"><span class="lineNum">    1494 </span>            :                            restore_template_param_mapping. */</a>
<a name="1495"><span class="lineNum">    1495 </span>            : </a>
<a name="1496"><span class="lineNum">    1496 </span>            : static a_saved_template_param_mapping_ptr</a>
<a name="1497"><span class="lineNum">    1497 </span>            :                 avail_template_param_mappings;</a>
<a name="1498"><span class="lineNum">    1498 </span>            :                         /* Free template parameter mappings that are</a>
<a name="1499"><span class="lineNum">    1499 </span>            :                            available for reuse. */</a>
<a name="1500"><span class="lineNum">    1500 </span>            : </a>
<a name="1501"><span class="lineNum">    1501 </span>            : static a_boolean</a>
<a name="1502"><span class="lineNum">    1502 </span>            :                 saving_template_param_mappings;</a>
<a name="1503"><span class="lineNum">    1503 </span>            :                         /* When TRUE, remap_template_param will save the</a>
<a name="1504"><span class="lineNum">    1504 </span>            :                            existing mapping before overwriting it with the</a>
<a name="1505"><span class="lineNum">    1505 </span>            :                            new mapping. */</a>
<a name="1506"><span class="lineNum">    1506 </span>            : </a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineNoCov">          0 : void save_template_param_mappings(void)</span></a>
<a name="1509"><span class="lineNum">    1509 </span>            : /*</a>
<a name="1510"><span class="lineNum">    1510 </span>            : Begin saving the existing template parameter mappings before overwriting</a>
<a name="1511"><span class="lineNum">    1511 </span>            : them in remap_template_param.</a>
<a name="1512"><span class="lineNum">    1512 </span>            : */</a>
<a name="1513"><span class="lineNum">    1513 </span>            : {</a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   check_assertion(!saving_template_param_mappings);</span></a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineNoCov">          0 :   saving_template_param_mappings = TRUE;</span></a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineNoCov">          0 : }  /* save_template_param_mappings */</span></a>
<a name="1517"><span class="lineNum">    1517 </span>            : </a>
<a name="1518"><span class="lineNum">    1518 </span>            : </a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineNoCov">          0 : void restore_template_param_mappings(void)</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            : /*</a>
<a name="1521"><span class="lineNum">    1521 </span>            : Restore template parameter mappings that were overwritten by</a>
<a name="1522"><span class="lineNum">    1522 </span>            : remap_template_param.</a>
<a name="1523"><span class="lineNum">    1523 </span>            : */</a>
<a name="1524"><span class="lineNum">    1524 </span>            : {</a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   a_template_param_map_level_ptr level;</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            : </a>
<a name="1527"><span class="lineNum">    1527 </span><span class="lineNoCov">          0 :   check_assertion(saving_template_param_mappings);</span></a>
<a name="1528"><span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   saving_template_param_mappings = FALSE;</span></a>
<a name="1529"><span class="lineNum">    1529 </span>            :   /* Loop through the active mappings and restore the table to its previous</a>
<a name="1530"><span class="lineNum">    1530 </span>            :      contents. */</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   while (saved_template_param_mappings != NULL) {</span></a>
<a name="1532"><span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     a_saved_template_param_mapping_ptr saved_mapping =</span></a>
<a name="1533"><span class="lineNum">    1533 </span>            :                                                  saved_template_param_mappings;</a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     saved_template_param_mappings = saved_mapping-&gt;next;</span></a>
<a name="1535"><span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     check_assertion(saved_mapping-&gt;coord.depth &lt;=</span></a>
<a name="1536"><span class="lineNum">    1536 </span>            :                                                  template_param_map_max_level);</a>
<a name="1537"><span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     level = &amp;template_param_map[saved_mapping-&gt;coord.depth-1];</span></a>
<a name="1538"><span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     check_assertion(saved_mapping-&gt;coord.position &lt;= level-&gt;max_position);</span></a>
<a name="1539"><span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     level-&gt;source_corresp[saved_mapping-&gt;coord.position-1] =</span></a>
<a name="1540"><span class="lineNum">    1540 </span><span class="lineNoCov">          0 :                                                             saved_mapping-&gt;scp;</span></a>
<a name="1541"><span class="lineNum">    1541 </span>            :     /* Put the entry on the free list for later reuse. */</a>
<a name="1542"><span class="lineNum">    1542 </span><span class="lineNoCov">          0 :     saved_mapping-&gt;next = avail_template_param_mappings;</span></a>
<a name="1543"><span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     avail_template_param_mappings = saved_mapping;</span></a>
<a name="1544"><span class="lineNum">    1544 </span>            :   }  /* while */</a>
<a name="1545"><span class="lineNum">    1545 </span><span class="lineNoCov">          0 : }  /* restore_template_param_mappings */</span></a>
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<a name="1547"><span class="lineNum">    1547 </span>            : </a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineNoCov">          0 : void remap_template_param(a_template_param_coordinate_ptr  coord,</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            :                           a_source_correspondence_ptr      scp)</a>
<a name="1550"><span class="lineNum">    1550 </span>            : /*</a>
<a name="1551"><span class="lineNum">    1551 </span>            : Associate the given template parameter coordinate with the given source</a>
<a name="1552"><span class="lineNum">    1552 </span>            : correspondence entry.</a>
<a name="1553"><span class="lineNum">    1553 </span>            : */</a>
<a name="1554"><span class="lineNum">    1554 </span>            : {</a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineNoCov">          0 :   a_template_param_map_level_ptr     level;</span></a>
<a name="1556"><span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   a_saved_template_param_mapping_ptr saved_mapping;</span></a>
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<a name="1558"><span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   if (coord-&gt;depth == 0) {</span></a>
<a name="1559"><span class="lineNum">    1559 </span>            :     /* A parameter of a template template parameter; no remapping needed. */</a>
<a name="1560"><span class="lineNum">    1560 </span>            :   } else {</a>
<a name="1561"><span class="lineNum">    1561 </span>            :     /* First find/create the appropriate depth/level: */</a>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     if (template_param_map == NULL) {</span></a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineNoCov">          0 :       template_param_map_max_level = (coord-&gt;depth &gt; 5) ? 2*coord-&gt;depth : 10;</span></a>
<a name="1564"><span class="lineNum">    1564 </span><span class="lineNoCov">          0 :       template_param_map = (a_template_param_map_level_ptr)</span></a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineNoCov">          0 :          alloc_resizable_buffer(</span></a>
<a name="1566"><span class="lineNum">    1566 </span>            :               sizeof(a_template_param_map_level)*template_param_map_max_level);</a>
<a name="1567"><span class="lineNum">    1567 </span><span class="lineNoCov">          0 :       memzero(template_param_map,</span></a>
<a name="1568"><span class="lineNum">    1568 </span>            :               sizeof(a_template_param_map_level)*template_param_map_max_level);</a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     } else if (coord-&gt;depth &gt; template_param_map_max_level) {</span></a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineNoCov">          0 :       a_template_nesting_depth new_max_level = 2*coord-&gt;depth;</span></a>
<a name="1571"><span class="lineNum">    1571 </span><span class="lineNoCov">          0 :       template_param_map =</span></a>
<a name="1572"><span class="lineNum">    1572 </span><span class="lineNoCov">          0 :           (a_template_param_map_level_ptr)realloc_buffer(</span></a>
<a name="1573"><span class="lineNum">    1573 </span>            :                (char*)template_param_map,</a>
<a name="1574"><span class="lineNum">    1574 </span>            :                sizeof(a_template_param_map_level)*template_param_map_max_level,</a>
<a name="1575"><span class="lineNum">    1575 </span>            :                sizeof(a_template_param_map_level)*new_max_level);</a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineNoCov">          0 :       memzero(&amp;template_param_map[template_param_map_max_level],</span></a>
<a name="1577"><span class="lineNum">    1577 </span>            :               sizeof(a_template_param_map_level)*new_max_level -</a>
<a name="1578"><span class="lineNum">    1578 </span>            :               sizeof(a_template_param_map_level)*template_param_map_max_level);</a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineNoCov">          0 :       template_param_map_max_level = new_max_level;</span></a>
<a name="1580"><span class="lineNum">    1580 </span>            :     }  /* if */</a>
<a name="1581"><span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     level = &amp;template_param_map[coord-&gt;depth-1];</span></a>
<a name="1582"><span class="lineNum">    1582 </span>            :     /* Then add the new mapping at the right position: */</a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     if (level-&gt;max_position == 0) {</span></a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineNoCov">          0 :       level-&gt;max_position = (coord-&gt;position &gt; 5) ? 2*coord-&gt;position : 10;</span></a>
<a name="1585"><span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       level-&gt;source_corresp = (a_source_correspondence_ptr*)</span></a>
<a name="1586"><span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                   alloc_resizable_buffer(</span></a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                       sizeof(a_source_correspondence_ptr)*level-&gt;max_position);</span></a>
<a name="1588"><span class="lineNum">    1588 </span><span class="lineNoCov">          0 :       memzero(level-&gt;source_corresp,</span></a>
<a name="1589"><span class="lineNum">    1589 </span>            :               sizeof(a_source_correspondence_ptr)*level-&gt;max_position);</a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineNoCov">          0 :     } else if (coord-&gt;position &gt; level-&gt;max_position) {</span></a>
<a name="1591"><span class="lineNum">    1591 </span><span class="lineNoCov">          0 :       a_template_param_list_pos new_max_pos = 2*coord-&gt;position;</span></a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineNoCov">          0 :       level-&gt;source_corresp = (a_source_correspondence_ptr*)realloc_buffer(</span></a>
<a name="1593"><span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                        (char*)level-&gt;source_corresp,</span></a>
<a name="1594"><span class="lineNum">    1594 </span><span class="lineNoCov">          0 :                        sizeof(a_source_correspondence_ptr)*level-&gt;max_position,</span></a>
<a name="1595"><span class="lineNum">    1595 </span>            :                        sizeof(a_source_correspondence_ptr)*new_max_pos);</a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       memzero(&amp;level-&gt;source_corresp[level-&gt;max_position],</span></a>
<a name="1597"><span class="lineNum">    1597 </span>            :               sizeof(a_source_correspondence_ptr)*new_max_pos -</a>
<a name="1598"><span class="lineNum">    1598 </span>            :                       sizeof(a_source_correspondence_ptr)*level-&gt;max_position);</a>
<a name="1599"><span class="lineNum">    1599 </span><span class="lineNoCov">          0 :       level-&gt;max_position = new_max_pos;</span></a>
<a name="1600"><span class="lineNum">    1600 </span>            :     }  /* if */</a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     if (saving_template_param_mappings) {</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :       /* Save the old mapping so it can be restored later. */</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineNoCov">          0 :       if (avail_template_param_mappings != NULL) {</span></a>
<a name="1604"><span class="lineNum">    1604 </span>            :         /* Reuse an existing entry. */</a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineNoCov">          0 :         saved_mapping = avail_template_param_mappings;</span></a>
<a name="1606"><span class="lineNum">    1606 </span><span class="lineNoCov">          0 :         avail_template_param_mappings = saved_mapping-&gt;next;</span></a>
<a name="1607"><span class="lineNum">    1607 </span>            :       } else {</a>
<a name="1608"><span class="lineNum">    1608 </span>            :         /* The free list is empty, so allocate a new entry. */</a>
<a name="1609"><span class="lineNum">    1609 </span><span class="lineNoCov">          0 :         saved_mapping = (a_saved_template_param_mapping_ptr)</span></a>
<a name="1610"><span class="lineNum">    1610 </span><span class="lineNoCov">          0 :                          alloc_general(sizeof(a_saved_template_param_mapping));</span></a>
<a name="1611"><span class="lineNum">    1611 </span>            :       }  /* if */</a>
<a name="1612"><span class="lineNum">    1612 </span>            :       /* Link the entry to the active list. */</a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineNoCov">          0 :       saved_mapping-&gt;next = saved_template_param_mappings;</span></a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineNoCov">          0 :       saved_template_param_mappings = saved_mapping;</span></a>
<a name="1615"><span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       saved_mapping-&gt;coord = *coord;</span></a>
<a name="1616"><span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       saved_mapping-&gt;scp = level-&gt;source_corresp[coord-&gt;position-1];</span></a>
<a name="1617"><span class="lineNum">    1617 </span>            :     }  /* if */</a>
<a name="1618"><span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     level-&gt;source_corresp[coord-&gt;position-1] = scp;</span></a>
<a name="1619"><span class="lineNum">    1619 </span>            :   }  /* if */</a>
<a name="1620"><span class="lineNum">    1620 </span><span class="lineNoCov">          0 : }  /* remap_template_param */</span></a>
<a name="1621"><span class="lineNum">    1621 </span>            : </a>
<a name="1622"><span class="lineNum">    1622 </span>            : </a>
<a name="1623"><span class="lineNum">    1623 </span><span class="lineNoCov">          0 : void unmap_template_param(a_template_param_coordinate_ptr  coord)</span></a>
<a name="1624"><span class="lineNum">    1624 </span>            : /*</a>
<a name="1625"><span class="lineNum">    1625 </span>            : Uninstall any mapping for the given template parameter coordinate.  Presumably</a>
<a name="1626"><span class="lineNum">    1626 </span>            : this will cause the source correspondence of the a_type or a_constant entry</a>
<a name="1627"><span class="lineNum">    1627 </span>            : for the template parameter to be used.</a>
<a name="1628"><span class="lineNum">    1628 </span>            : */</a>
<a name="1629"><span class="lineNum">    1629 </span>            : {</a>
<a name="1630"><span class="lineNum">    1630 </span><span class="lineNoCov">          0 :   remap_template_param(coord, (a_source_correspondence_ptr)NULL);</span></a>
<a name="1631"><span class="lineNum">    1631 </span><span class="lineNoCov">          0 : }  /* unmap_template_param */</span></a>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<a name="1633"><span class="lineNum">    1633 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="1634"><span class="lineNum">    1634 </span>            : </a>
<a name="1635"><span class="lineNum">    1635 </span>            : #if !PROTOTYPE_INSTANTIATIONS_IN_IL</a>
<a name="1636"><span class="lineNum">    1636 </span>            : /* This routine is used outside il_to_str.c only with prototype</a>
<a name="1637"><span class="lineNum">    1637 </span>            :    instantiations. */</a>
<a name="1638"><span class="lineNum">    1638 </span>            : static</a>
<a name="1639"><span class="lineNum">    1639 </span>            : #endif /* !PROTOTYPE_INSTANTIATIONS_IN_IL */</a>
<a name="1640"><span class="lineNum">    1640 </span><span class="lineCov">         10 : a_source_correspondence_ptr source_corresp_for_template_param(</span></a>
<a name="1641"><span class="lineNum">    1641 </span>            :                                         a_template_param_coordinate_ptr coord)</a>
<a name="1642"><span class="lineNum">    1642 </span>            : /*</a>
<a name="1643"><span class="lineNum">    1643 </span>            : Look up the given template parameter coordinates in the template parameter map</a>
<a name="1644"><span class="lineNum">    1644 </span>            : to find a source correspondence entry that will produce a meaningful name in</a>
<a name="1645"><span class="lineNum">    1645 </span>            : the current context.  Return NULL if the template parameter is not remapped</a>
<a name="1646"><span class="lineNum">    1646 </span>            : in the current context.</a>
<a name="1647"><span class="lineNum">    1647 </span>            : */</a>
<a name="1648"><span class="lineNum">    1648 </span>            : {</a>
<a name="1649"><span class="lineNum">    1649 </span><span class="lineCov">         10 :   a_source_correspondence_ptr     result;</span></a>
<a name="1650"><span class="lineNum">    1650 </span>            : </a>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineCov">         10 :   if (template_param_map == NULL ||</span></a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineNoCov">          0 :       coord-&gt;depth &gt; template_param_map_max_level ||</span></a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineNoCov">          0 :       coord-&gt;depth == 0 || /* Template template parameter. */</span></a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineNoCov">          0 :       coord-&gt;position &gt; template_param_map[coord-&gt;depth - 1].max_position) {</span></a>
<a name="1655"><span class="lineNum">    1655 </span>            :     result = NULL;</a>
<a name="1656"><span class="lineNum">    1656 </span>            :   } else {</a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineNoCov">          0 :     result = template_param_map[coord-&gt;depth - 1].</span></a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineNoCov">          0 :                                           source_corresp[coord-&gt;position - 1];</span></a>
<a name="1659"><span class="lineNum">    1659 </span>            :   }  /* if */</a>
<a name="1660"><span class="lineNum">    1660 </span><span class="lineCov">         10 :   return result;</span></a>
<a name="1661"><span class="lineNum">    1661 </span>            : }  /* source_corresp_for_template_param */</a>
<a name="1662"><span class="lineNum">    1662 </span>            : </a>
<a name="1663"><span class="lineNum">    1663 </span>            : </a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineCov">       2819 : an_expr_node_ptr decltype_arg(a_type_ptr  type)</span></a>
<a name="1665"><span class="lineNum">    1665 </span>            : /*</a>
<a name="1666"><span class="lineNum">    1666 </span>            : The given type represents a decltype, typeof, or other type construct.</a>
<a name="1667"><span class="lineNum">    1667 </span>            : Return its argument expression if available, or NULL otherwise.</a>
<a name="1668"><span class="lineNum">    1668 </span>            : */</a>
<a name="1669"><span class="lineNum">    1669 </span>            : {</a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">       2819 :   an_expr_node_ptr  expr = type-&gt;variant.typeref.extra_info-&gt;expr;</span></a>
<a name="1671"><span class="lineNum">    1671 </span>            : </a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineCov">       2819 :   if (type-&gt;variant.typeref.is_underlying_type ||</span></a>
<a name="1673"><span class="lineNum">    1673 </span>            :       type-&gt;variant.typeref.is_bases) {</a>
<a name="1674"><span class="lineNum">    1674 </span>            :     /* __underlying_type and __based constructs don't allow expression</a>
<a name="1675"><span class="lineNum">    1675 </span>            :         arguments. */</a>
<a name="1676"><span class="lineNum">    1676 </span><span class="lineCov">       2819 :   } else if (expr == NULL) {</span></a>
<a name="1677"><span class="lineNum">    1677 </span>            :     /* See if the expression can be found in a local function scope. */</a>
<a name="1678"><span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     a_local_expr_node_ref_kind  lerk = type-&gt;variant.typeref.is_decltype ?</span></a>
<a name="1679"><span class="lineNum">    1679 </span>            :                                    (a_local_expr_node_ref_kind)lerk_decltype :</a>
<a name="1680"><span class="lineNum">    1680 </span>            :                                    (a_local_expr_node_ref_kind)lerk_typeof;</a>
<a name="1681"><span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     a_scope_ptr scope;</span></a>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     if (type-&gt;source_corresp.enclosing_routine != NULL &amp;&amp;</span></a>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineNoCov">          0 :         type-&gt;source_corresp.enclosing_routine-&gt;function_def_number !=</span></a>
<a name="1684"><span class="lineNum">    1684 </span>            :                                                     NULL_function_def_number) {</a>
<a name="1685"><span class="lineNum">    1685 </span>            :       /* If the type is defined in a function or block scope, search in</a>
<a name="1686"><span class="lineNum">    1686 </span>            :          that routine's scope (if it has been defined and the memory region</a>
<a name="1687"><span class="lineNum">    1687 </span>            :          is available). */</a>
<a name="1688"><span class="lineNum">    1688 </span><span class="lineNoCov">          0 :       scope= scope_for_routine_or_null(type-&gt;source_corresp.enclosing_routine);</span></a>
<a name="1689"><span class="lineNum">    1689 </span>            :     } else {</a>
<a name="1690"><span class="lineNum">    1690 </span>            :       /* Assume we should use the current function. */</a>
<a name="1691"><span class="lineNum">    1691 </span><span class="lineNoCov">          0 :       scope = innermost_function_scope;</span></a>
<a name="1692"><span class="lineNum">    1692 </span>            :     }  /* if */</a>
<a name="1693"><span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     if (scope != NULL) {</span></a>
<a name="1694"><span class="lineNum">    1694 </span><span class="lineNoCov">          0 :       expr = find_local_expr_node_in_scope((char*)type, lerk, scope);</span></a>
<a name="1695"><span class="lineNum">    1695 </span>            :     }  /* if */</a>
<a name="1696"><span class="lineNum">    1696 </span>            :   }  /* if */</a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">       2819 :   return expr;</span></a>
<a name="1698"><span class="lineNum">    1698 </span>            : }  /* decltype_arg */</a>
<a name="1699"><span class="lineNum">    1699 </span>            : </a>
<a name="1700"><span class="lineNum">    1700 </span>            : #if GNU_EXTENSIONS_ALLOWED &amp;&amp; GNU_VECTOR_TYPES_ALLOWED</a>
<a name="1701"><span class="lineNum">    1701 </span>            : </a>
<a name="1702"><span class="lineNum">    1702 </span>            : #if !BACK_END_IS_C_GEN_BE</a>
<a name="1703"><span class="lineNum">    1703 </span>            : static</a>
<a name="1704"><span class="lineNum">    1704 </span>            : #endif /* !BACK_END_IS_C_GEN_BE */</a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineNoCov">          0 : void form_vector_type_attribute(</span></a>
<a name="1706"><span class="lineNum">    1706 </span>            :                      a_type_ptr                            type,</a>
<a name="1707"><span class="lineNum">    1707 </span>            :                      a_boolean                             *need_leading_space,</a>
<a name="1708"><span class="lineNum">    1708 </span>            :                      an_il_to_str_output_control_block_ptr octl)</a>
<a name="1709"><span class="lineNum">    1709 </span>            : /*</a>
<a name="1710"><span class="lineNum">    1710 </span>            : Output a GNU &quot;vector_size&quot; attribute as required by the specified type,</a>
<a name="1711"><span class="lineNum">    1711 </span>            : which must be a tk_vector, in the way described by octl.  If</a>
<a name="1712"><span class="lineNum">    1712 </span>            : *need_leading_space is TRUE, precede the attribute with a leading space.</a>
<a name="1713"><span class="lineNum">    1713 </span>            : *need_leading_space is set to TRUE to indicate that a space will be needed</a>
<a name="1714"><span class="lineNum">    1714 </span>            : after the attribute.</a>
<a name="1715"><span class="lineNum">    1715 </span>            : */</a>
<a name="1716"><span class="lineNum">    1716 </span>            : {</a>
<a name="1717"><span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   check_assertion(type-&gt;kind == (a_type_kind)tk_vector);</span></a>
<a name="1718"><span class="lineNum">    1718 </span><span class="lineNoCov">          0 :   if (*need_leading_space) {</span></a>
<a name="1719"><span class="lineNum">    1719 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="1720"><span class="lineNum">    1720 </span>            :   }  /* if */</a>
<a name="1721"><span class="lineNum">    1721 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;__attribute((vector_size(&quot;, octl);</span></a>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineNoCov">          0 :   if (type-&gt;variant.vector.size_constant != NULL) {</span></a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineNoCov">          0 :     form_constant(type-&gt;variant.vector.size_constant,</span></a>
<a name="1724"><span class="lineNum">    1724 </span>            :                   /*need_parens=*/FALSE, octl);</a>
<a name="1725"><span class="lineNum">    1725 </span>            :   } else {</a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineNoCov">          0 :     form_unsigned_num((a_host_large_unsigned)type-&gt;size, octl);</span></a>
<a name="1727"><span class="lineNum">    1727 </span>            :   }  /* if */</a>
<a name="1728"><span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;)))&quot;, octl);</span></a>
<a name="1729"><span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   *need_leading_space = TRUE;</span></a>
<a name="1730"><span class="lineNum">    1730 </span><span class="lineNoCov">          0 : }  /* form_vector_type_attribute */</span></a>
<a name="1731"><span class="lineNum">    1731 </span>            : </a>
<a name="1732"><span class="lineNum">    1732 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED &amp;&amp; GNU_VECTOR_TYPES_ALLOWED */</a>
<a name="1733"><span class="lineNum">    1733 </span>            : </a>
<a name="1734"><span class="lineNum">    1734 </span><span class="lineCov">         46 : static void form_type_specifier(a_type_ptr                            type,</span></a>
<a name="1735"><span class="lineNum">    1735 </span>            :                                 an_il_to_str_output_control_block_ptr octl)</a>
<a name="1736"><span class="lineNum">    1736 </span>            : /*</a>
<a name="1737"><span class="lineNum">    1737 </span>            : Output a string for a type specifier.  Do the output in the way described</a>
<a name="1738"><span class="lineNum">    1738 </span>            : by octl.</a>
<a name="1739"><span class="lineNum">    1739 </span>            : */</a>
<a name="1740"><span class="lineNum">    1740 </span>            : {</a>
<a name="1741"><span class="lineNum">    1741 </span><span class="lineCov">         46 :   switch (type-&gt;kind) {</span></a>
<a name="1742"><span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     case tk_error:</span></a>
<a name="1743"><span class="lineNum">    1743 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="1744"><span class="lineNum">    1744 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;error-type&gt;&quot;, octl);</span></a>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="1746"><span class="lineNum">    1746 </span><span class="lineCov">          1 :     case tk_void:</span></a>
<a name="1747"><span class="lineNum">    1747 </span><span class="lineCov">          1 :       octl-&gt;output_str(&quot;void&quot;, octl);</span></a>
<a name="1748"><span class="lineNum">    1748 </span><span class="lineCov">          1 :       break;</span></a>
<a name="1749"><span class="lineNum">    1749 </span><span class="lineCov">         16 :     case tk_integer:</span></a>
<a name="1750"><span class="lineNum">    1750 </span>            :       /* Enum types are often handled specially. */</a>
<a name="1751"><span class="lineNum">    1751 </span><span class="lineCov">         16 :       if (type-&gt;variant.integer.enum_type &amp;&amp;</span></a>
<a name="1752"><span class="lineNum">    1752 </span>            :           /* Some enumeration types cannot be rendered in the C-generating</a>
<a name="1753"><span class="lineNum">    1753 </span>            :              back end.  Specifically:</a>
<a name="1754"><span class="lineNum">    1754 </span>            :                - don't generate enums when generating pcc mode</a>
<a name="1755"><span class="lineNum">    1755 </span>            :                - don't generate enums with an explicit underlying type</a>
<a name="1756"><span class="lineNum">    1756 </span>            :                - don't generate empty enums (valid in C++, but not in C)</a>
<a name="1757"><span class="lineNum">    1757 </span>            :              In these cases, the underlying integer type is used instead. */</a>
<a name="1758"><span class="lineNum">    1758 </span><span class="lineNoCov">          0 :           !(octl-&gt;c_generating_back_end &amp;&amp; </span></a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineNoCov">          0 :             (octl-&gt;gen_pcc_code ||</span></a>
<a name="1760"><span class="lineNum">    1760 </span><span class="lineNoCov">          0 :              type-&gt;variant.integer.has_explicit_enum_base ||</span></a>
<a name="1761"><span class="lineNum">    1761 </span><span class="lineNoCov">          0 :              enum_constants(type) == NULL))) {</span></a>
<a name="1762"><span class="lineNum">    1762 </span>            :         /* Output a reference to the enum type. */</a>
<a name="1763"><span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         form_tag_reference(type, octl);</span></a>
<a name="1764"><span class="lineNum">    1764 </span><span class="lineCov">         16 :       } else if (type-&gt;variant.integer.wchar_t_type &amp;&amp;</span></a>
<a name="1765"><span class="lineNum">    1765 </span><span class="lineNoCov">          0 :                  !octl-&gt;c_generating_back_end) {</span></a>
<a name="1766"><span class="lineNum">    1766 </span>            :         /* Output a wchar_t type as &quot;wchar_t&quot;, except in the C generating</a>
<a name="1767"><span class="lineNum">    1767 </span>            :            back end, where it is output as its underlying type. */</a>
<a name="1768"><span class="lineNum">    1768 </span><span class="lineNoCov">          0 :         if (ms_extensions &amp;&amp; microsoft_version &gt;= 1300) {</span></a>
<a name="1769"><span class="lineNum">    1769 </span>            :           /* In Microsoft mode, when microsoft_version is &gt;= 1300 __wchar_t</a>
<a name="1770"><span class="lineNum">    1770 </span>            :              can be used as a keyword even when wchar_t is not recognized.</a>
<a name="1771"><span class="lineNum">    1771 </span>            :              We don't know how the type was originally specified, so output it</a>
<a name="1772"><span class="lineNum">    1772 </span>            :              as __wchar_t or wchar_t based on microsoft_version. */</a>
<a name="1773"><span class="lineNum">    1773 </span>            :           octl-&gt;output_str(&quot;__wchar_t&quot;, octl);</a>
<a name="1774"><span class="lineNum">    1774 </span>            :         } else {</a>
<a name="1775"><span class="lineNum">    1775 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;wchar_t&quot;, octl);</span></a>
<a name="1776"><span class="lineNum">    1776 </span>            :         }  /* if */</a>
<a name="1777"><span class="lineNum">    1777 </span><span class="lineCov">         16 :       } else if (type-&gt;variant.integer.char16_t_type &amp;&amp;</span></a>
<a name="1778"><span class="lineNum">    1778 </span><span class="lineNoCov">          0 :                  !octl-&gt;c_generating_back_end) {</span></a>
<a name="1779"><span class="lineNum">    1779 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="1780"><span class="lineNum">    1780 </span>            :         /* Output a char16_t type as &quot;char16_t&quot;, except in the C generating</a>
<a name="1781"><span class="lineNum">    1781 </span>            :            back end, where it is output as its underlying type. */</a>
<a name="1782"><span class="lineNum">    1782 </span><span class="lineNoCov">          0 :         if (clang_is_generated_code_target &amp;&amp; octl-&gt;gen_compilable_code) {</span></a>
<a name="1783"><span class="lineNum">    1783 </span>            :           /* Use __char16_t when targeting clang; it is available in all</a>
<a name="1784"><span class="lineNum">    1784 </span>            :              C++ modes. */</a>
<a name="1785"><span class="lineNum">    1785 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;__char16_t&quot;, octl);</span></a>
<a name="1786"><span class="lineNum">    1786 </span>            :         } else</a>
<a name="1787"><span class="lineNum">    1787 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="1788"><span class="lineNum">    1788 </span>            :         /* Do not insert code here. */</a>
<a name="1789"><span class="lineNum">    1789 </span>            :         {</a>
<a name="1790"><span class="lineNum">    1790 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;char16_t&quot;, octl);</span></a>
<a name="1791"><span class="lineNum">    1791 </span>            :         }  /* if */</a>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineCov">         16 :       } else if (type-&gt;variant.integer.char32_t_type &amp;&amp;</span></a>
<a name="1793"><span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                  !octl-&gt;c_generating_back_end) {</span></a>
<a name="1794"><span class="lineNum">    1794 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="1795"><span class="lineNum">    1795 </span>            :         /* Output a char32_t type as &quot;char32_t&quot;, except in the C generating</a>
<a name="1796"><span class="lineNum">    1796 </span>            :            back end, where it is output as its underlying type. */</a>
<a name="1797"><span class="lineNum">    1797 </span><span class="lineNoCov">          0 :         if (clang_is_generated_code_target &amp;&amp; octl-&gt;gen_compilable_code) {</span></a>
<a name="1798"><span class="lineNum">    1798 </span>            :           /* Use __char32_t when targeting clang; it is available in all</a>
<a name="1799"><span class="lineNum">    1799 </span>            :              C++ modes. */</a>
<a name="1800"><span class="lineNum">    1800 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;__char32_t&quot;, octl);</span></a>
<a name="1801"><span class="lineNum">    1801 </span>            :         } else</a>
<a name="1802"><span class="lineNum">    1802 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="1803"><span class="lineNum">    1803 </span>            :         /* Do not insert code here. */</a>
<a name="1804"><span class="lineNum">    1804 </span>            :         {</a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;char32_t&quot;, octl);</span></a>
<a name="1806"><span class="lineNum">    1806 </span>            :         }  /* if */</a>
<a name="1807"><span class="lineNum">    1807 </span><span class="lineCov">         16 :       } else if (type-&gt;variant.integer.bool_type &amp;&amp;</span></a>
<a name="1808"><span class="lineNum">    1808 </span><span class="lineCov">         10 :                  (!octl-&gt;c_generating_back_end || octl-&gt;render_c99_bool)) {</span></a>
<a name="1809"><span class="lineNum">    1809 </span>            :         /* Output a bool type as &quot;bool&quot;, except in the C generating</a>
<a name="1810"><span class="lineNum">    1810 </span>            :            back end, where it is output as its underlying type. */</a>
<a name="1811"><span class="lineNum">    1811 </span><span class="lineCov">         20 :         octl-&gt;output_str((char *)(octl-&gt;render_c99_bool ? &quot;_Bool&quot; : &quot;bool&quot;),</span></a>
<a name="1812"><span class="lineNum">    1812 </span>            :                          octl);</a>
<a name="1813"><span class="lineNum">    1813 </span>            :       } else {</a>
<a name="1814"><span class="lineNum">    1814 </span>            :         /* Normal integer type. */</a>
<a name="1815"><span class="lineNum">    1815 </span><span class="lineCov">          6 :         if (type-&gt;variant.integer.explicitly_signed &amp;&amp;</span></a>
<a name="1816"><span class="lineNum">    1816 </span>            :             /* &quot;signed&quot; is not allowed when generating pcc code. */</a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             !octl-&gt;gen_pcc_code) {</span></a>
<a name="1818"><span class="lineNum">    1818 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;signed &quot;, octl);</span></a>
<a name="1819"><span class="lineNum">    1819 </span>            :         }  /* if */</a>
<a name="1820"><span class="lineNum">    1820 </span><span class="lineCov">          6 :         form_int_type_name(type, octl);</span></a>
<a name="1821"><span class="lineNum">    1821 </span>            :       }  /* if */</a>
<a name="1822"><span class="lineNum">    1822 </span>            :       break;</a>
<a name="1823"><span class="lineNum">    1823 </span>            : #if FIXED_POINT_ALLOWED</a>
<a name="1824"><span class="lineNum">    1824 </span><span class="lineNoCov">          0 :     case tk_fixed_point:</span></a>
<a name="1825"><span class="lineNum">    1825 </span>            :       {</a>
<a name="1826"><span class="lineNum">    1826 </span><span class="lineNoCov">          0 :         a_fixed_point_precision  prec = type-&gt;variant.fixed_point.precision;</span></a>
<a name="1827"><span class="lineNum">    1827 </span><span class="lineNoCov">          0 :         if (type-&gt;variant.fixed_point.saturating) {</span></a>
<a name="1828"><span class="lineNum">    1828 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;_Sat &quot;, octl);</span></a>
<a name="1829"><span class="lineNum">    1829 </span>            :         }  /* if */</a>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineNoCov">          0 :         if (type-&gt;variant.fixed_point.is_unsigned) {</span></a>
<a name="1831"><span class="lineNum">    1831 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;unsigned &quot;, octl);</span></a>
<a name="1832"><span class="lineNum">    1832 </span>            :         }  /* if */</a>
<a name="1833"><span class="lineNum">    1833 </span><span class="lineNoCov">          0 :         if (prec == (a_fixed_point_precision)fpp_short) {</span></a>
<a name="1834"><span class="lineNum">    1834 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;short &quot;, octl);</span></a>
<a name="1835"><span class="lineNum">    1835 </span><span class="lineNoCov">          0 :         } else if (prec == (a_fixed_point_precision)fpp_long) {</span></a>
<a name="1836"><span class="lineNum">    1836 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;long &quot;, octl);</span></a>
<a name="1837"><span class="lineNum">    1837 </span>            :         } else {</a>
<a name="1838"><span class="lineNum">    1838 </span><span class="lineNoCov">          0 :           check_assertion(prec == (a_fixed_point_precision)fpp_default);</span></a>
<a name="1839"><span class="lineNum">    1839 </span>            :         }  /* if */</a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineNoCov">          0 :         if (type-&gt;variant.fixed_point.is_fract_type) {</span></a>
<a name="1841"><span class="lineNum">    1841 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;_Fract&quot;, octl);</span></a>
<a name="1842"><span class="lineNum">    1842 </span>            :         } else {</a>
<a name="1843"><span class="lineNum">    1843 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;_Accum&quot;, octl);</span></a>
<a name="1844"><span class="lineNum">    1844 </span>            :         }  /* if */</a>
<a name="1845"><span class="lineNum">    1845 </span>            :       }</a>
<a name="1846"><span class="lineNum">    1846 </span>            :       break;</a>
<a name="1847"><span class="lineNum">    1847 </span>            : #endif /* FIXED_POINT_ALLOWED */</a>
<a name="1848"><span class="lineNum">    1848 </span>            : #if C99_IL_EXTENSIONS_SUPPORTED</a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     case tk_complex:</span></a>
<a name="1850"><span class="lineNum">    1850 </span><span class="lineNoCov">          0 :       form_float_kind_name(type-&gt;variant.float_kind, octl);</span></a>
<a name="1851"><span class="lineNum">    1851 </span><span class="lineNoCov">          0 :       if (use_gnu_form()) {</span></a>
<a name="1852"><span class="lineNum">    1852 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; __complex__&quot;, octl);</span></a>
<a name="1853"><span class="lineNum">    1853 </span>            :       } else {</a>
<a name="1854"><span class="lineNum">    1854 </span>            :         /* Put out the C99 form. */</a>
<a name="1855"><span class="lineNum">    1855 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; _Complex&quot;, octl);</span></a>
<a name="1856"><span class="lineNum">    1856 </span>            :       }  /* if */</a>
<a name="1857"><span class="lineNum">    1857 </span>            :       break;</a>
<a name="1858"><span class="lineNum">    1858 </span><span class="lineNoCov">          0 :     case tk_imaginary:</span></a>
<a name="1859"><span class="lineNum">    1859 </span><span class="lineNoCov">          0 :       form_float_kind_name(type-&gt;variant.float_kind, octl);</span></a>
<a name="1860"><span class="lineNum">    1860 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; _Imaginary&quot;, octl);</span></a>
<a name="1861"><span class="lineNum">    1861 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="1862"><span class="lineNum">    1862 </span>            : #endif /* C99_IL_EXTENSIONS_SUPPORTED */</a>
<a name="1863"><span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     case tk_float:</span></a>
<a name="1864"><span class="lineNum">    1864 </span><span class="lineNoCov">          0 :       form_float_kind_name(type-&gt;variant.float_kind, octl);</span></a>
<a name="1865"><span class="lineNum">    1865 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">          1 :     case tk_class:</span></a>
<a name="1867"><span class="lineNum">    1867 </span>            :     case tk_struct:</a>
<a name="1868"><span class="lineNum">    1868 </span>            :     case tk_union:</a>
<a name="1869"><span class="lineNum">    1869 </span><span class="lineCov">          1 :       form_tag_reference(type, octl);</span></a>
<a name="1870"><span class="lineNum">    1870 </span><span class="lineCov">          1 :       break;</span></a>
<a name="1871"><span class="lineNum">    1871 </span><span class="lineCov">         18 :     case tk_typeref:</span></a>
<a name="1872"><span class="lineNum">    1872 </span>            :       /* A typeref here should be a typedef, a decltype operator, an</a>
<a name="1873"><span class="lineNum">    1873 </span>            :          __underlying_type operator, or a typeof operator. */</a>
<a name="1874"><span class="lineNum">    1874 </span><span class="lineCov">         18 :       if (type-&gt;variant.typeref.is_decltype) {</span></a>
<a name="1875"><span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         if (octl-&gt;gen_compilable_code &amp;&amp; octl-&gt;output_name != NULL) {</span></a>
<a name="1876"><span class="lineNum">    1876 </span>            :           /* It may seem strange to use &quot;output_name&quot; to render a type that</a>
<a name="1877"><span class="lineNum">    1877 </span>            :              doesn't really have a name.  However, this uses the same</a>
<a name="1878"><span class="lineNum">    1878 </span>            :              mechanisms required to render non-autonomous unnamed tag types,</a>
<a name="1879"><span class="lineNum">    1879 </span>            :              and those use &quot;output_name&quot; for uniformity with named tag</a>
<a name="1880"><span class="lineNum">    1880 </span>            :              types. */</a>
<a name="1881"><span class="lineNum">    1881 </span><span class="lineNoCov">          0 :           octl-&gt;output_name((char*)type, iek_type);</span></a>
<a name="1882"><span class="lineNum">    1882 </span>            :         } else {</a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineNoCov">          0 :           an_expr_node_ptr expr = decltype_arg(type);</span></a>
<a name="1884"><span class="lineNum">    1884 </span><span class="lineNoCov">          0 :           char             *kwd;</span></a>
<a name="1885"><span class="lineNum">    1885 </span><span class="lineNoCov">          0 :           if (use_gnu_form() &amp;&amp; octl-&gt;gen_compilable_code) {</span></a>
<a name="1886"><span class="lineNum">    1886 </span>            :             /* Current versions of g++ only accept the decltype keyword</a>
<a name="1887"><span class="lineNum">    1887 </span>            :                with -std=c++0x, but they accept __decltype in both modes,</a>
<a name="1888"><span class="lineNum">    1888 </span>            :                so use the safer spelling. */</a>
<a name="1889"><span class="lineNum">    1889 </span>            :             kwd = (char *)&quot;__decltype(&quot;;</a>
<a name="1890"><span class="lineNum">    1890 </span>            :           } else {</a>
<a name="1891"><span class="lineNum">    1891 </span><span class="lineNoCov">          0 :             kwd = (char *)&quot;decltype(&quot;;</span></a>
<a name="1892"><span class="lineNum">    1892 </span>            :           }  /* if */</a>
<a name="1893"><span class="lineNum">    1893 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(kwd, octl);</span></a>
<a name="1894"><span class="lineNum">    1894 </span><span class="lineNoCov">          0 :           if (expr != NULL) {</span></a>
<a name="1895"><span class="lineNum">    1895 </span><span class="lineNoCov">          0 :             if (!type-&gt;variant.typeref.decltype_expr_not_parenthesized) {</span></a>
<a name="1896"><span class="lineNum">    1896 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="1897"><span class="lineNum">    1897 </span>            :             }  /* if */</a>
<a name="1898"><span class="lineNum">    1898 </span><span class="lineNoCov">          0 :             if (octl-&gt;output_expression != NULL) {</span></a>
<a name="1899"><span class="lineNum">    1899 </span>            :               /* Extra top-level parentheses should be suppressed since they</a>
<a name="1900"><span class="lineNum">    1900 </span>            :                  may change the meaning of the decltype construct. */</a>
<a name="1901"><span class="lineNum">    1901 </span><span class="lineNoCov">          0 :               octl-&gt;output_expression(expr, /*suppress_parens=*/TRUE);</span></a>
<a name="1902"><span class="lineNum">    1902 </span>            :             } else {</a>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineNoCov">          0 :               form_expression(expr, octl);</span></a>
<a name="1904"><span class="lineNum">    1904 </span>            :             }  /* if */</a>
<a name="1905"><span class="lineNum">    1905 </span><span class="lineNoCov">          0 :             if (!type-&gt;variant.typeref.decltype_expr_not_parenthesized) {</span></a>
<a name="1906"><span class="lineNum">    1906 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="1907"><span class="lineNum">    1907 </span>            :             }  /* if */</a>
<a name="1908"><span class="lineNum">    1908 </span>            :           } else {</a>
<a name="1909"><span class="lineNum">    1909 </span>            :             /* No expression is available: Just emit a placeholder for the</a>
<a name="1910"><span class="lineNum">    1910 </span>            :                expression.  (This should only occur when not emitting</a>
<a name="1911"><span class="lineNum">    1911 </span>            :                compilable output.) */</a>
<a name="1912"><span class="lineNum">    1912 </span><span class="lineNoCov">          0 :             check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;&lt;expr&gt;&quot;, octl);</span></a>
<a name="1914"><span class="lineNum">    1914 </span>            :           }  /* if */</a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="1916"><span class="lineNum">    1916 </span>            :         }  /* if */</a>
<a name="1917"><span class="lineNum">    1917 </span><span class="lineCov">         18 :       } else if (type-&gt;variant.typeref.is_underlying_type ||</span></a>
<a name="1918"><span class="lineNum">    1918 </span>            :                  type-&gt;variant.typeref.is_bases) {</a>
<a name="1919"><span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         if (octl-&gt;gen_compilable_code &amp;&amp; octl-&gt;output_name != NULL) {</span></a>
<a name="1920"><span class="lineNum">    1920 </span>            :           /* It may seem strange to use &quot;output_name&quot; to render a type that</a>
<a name="1921"><span class="lineNum">    1921 </span>            :              doesn't really have a name.  However, this uses the same</a>
<a name="1922"><span class="lineNum">    1922 </span>            :              mechanisms required to render non-autonomous unnamed tag types,</a>
<a name="1923"><span class="lineNum">    1923 </span>            :              and those use &quot;output_name&quot; for uniformity with named tag</a>
<a name="1924"><span class="lineNum">    1924 </span>            :              types. */</a>
<a name="1925"><span class="lineNum">    1925 </span><span class="lineNoCov">          0 :           octl-&gt;output_name((char*)type, iek_type);</span></a>
<a name="1926"><span class="lineNum">    1926 </span>            :         } else {</a>
<a name="1927"><span class="lineNum">    1927 </span><span class="lineNoCov">          0 :           if (type-&gt;variant.typeref.is_underlying_type) {</span></a>
<a name="1928"><span class="lineNum">    1928 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;__underlying_type(&quot;, octl);</span></a>
<a name="1929"><span class="lineNum">    1929 </span>            :           } else {</a>
<a name="1930"><span class="lineNum">    1930 </span><span class="lineNoCov">          0 :             check_assertion(type-&gt;variant.typeref.is_bases);</span></a>
<a name="1931"><span class="lineNum">    1931 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(type-&gt;variant.typeref.direct_bases</span></a>
<a name="1932"><span class="lineNum">    1932 </span><span class="lineNoCov">          0 :                                                    ? (char *)&quot;__direct_bases(&quot;</span></a>
<a name="1933"><span class="lineNum">    1933 </span>            :                                                    : (char *)&quot;__bases(&quot;,</a>
<a name="1934"><span class="lineNum">    1934 </span>            :                              octl);</a>
<a name="1935"><span class="lineNum">    1935 </span>            :           }  /* if */</a>
<a name="1936"><span class="lineNum">    1936 </span><span class="lineNoCov">          0 :           form_type(type-&gt;variant.typeref.extra_info-&gt;operator_type_arg, octl);</span></a>
<a name="1937"><span class="lineNum">    1937 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="1938"><span class="lineNum">    1938 </span>            :         } /* if */</a>
<a name="1939"><span class="lineNum">    1939 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="1940"><span class="lineNum">    1940 </span><span class="lineCov">         18 :       } else if (type-&gt;variant.typeref.is_typeof) {</span></a>
<a name="1941"><span class="lineNum">    1941 </span><span class="lineNoCov">          0 :         if (octl-&gt;gen_compilable_code &amp;&amp; octl-&gt;output_name != NULL) {</span></a>
<a name="1942"><span class="lineNum">    1942 </span>            :           /* It may seem strange to use &quot;output_name&quot; to render a type that</a>
<a name="1943"><span class="lineNum">    1943 </span>            :              doesn't really have a name.  However, this uses the same</a>
<a name="1944"><span class="lineNum">    1944 </span>            :              mechanisms required to render non-autonomous unnamed tag types,</a>
<a name="1945"><span class="lineNum">    1945 </span>            :              and those use &quot;output_name&quot; for uniformity with named tag</a>
<a name="1946"><span class="lineNum">    1946 </span>            :              types. */</a>
<a name="1947"><span class="lineNum">    1947 </span><span class="lineNoCov">          0 :           octl-&gt;output_name((char*)type, iek_type);</span></a>
<a name="1948"><span class="lineNum">    1948 </span>            :         } else {</a>
<a name="1949"><span class="lineNum">    1949 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;__typeof__(&quot;, octl);</span></a>
<a name="1950"><span class="lineNum">    1950 </span><span class="lineNoCov">          0 :           if (!type-&gt;variant.typeref.is_typeof_with_type_operand) {</span></a>
<a name="1951"><span class="lineNum">    1951 </span>            :             /* typeof(expression). */</a>
<a name="1952"><span class="lineNum">    1952 </span><span class="lineNoCov">          0 :             an_expr_node_ptr expr = decltype_arg(type);</span></a>
<a name="1953"><span class="lineNum">    1953 </span><span class="lineNoCov">          0 :             if (expr != NULL) {</span></a>
<a name="1954"><span class="lineNum">    1954 </span><span class="lineNoCov">          0 :               if (octl-&gt;output_expression != NULL) {</span></a>
<a name="1955"><span class="lineNum">    1955 </span>            :                 /* Unlike decltype, typeof is not affected by extra top-level</a>
<a name="1956"><span class="lineNum">    1956 </span>            :                    parentheses.  Suppress them anyway to produce more pleasing</a>
<a name="1957"><span class="lineNum">    1957 </span>            :                    output. */</a>
<a name="1958"><span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                 octl-&gt;output_expression(expr, /*suppress_parens=*/TRUE);</span></a>
<a name="1959"><span class="lineNum">    1959 </span>            :               } else {</a>
<a name="1960"><span class="lineNum">    1960 </span><span class="lineNoCov">          0 :                 form_expression(expr, octl);</span></a>
<a name="1961"><span class="lineNum">    1961 </span>            :               }  /* if */</a>
<a name="1962"><span class="lineNum">    1962 </span>            :             } else {</a>
<a name="1963"><span class="lineNum">    1963 </span>            :               /* No expression is available: Just emit a placeholder for the</a>
<a name="1964"><span class="lineNum">    1964 </span>            :                  expression.  (This should only occur when not emitting</a>
<a name="1965"><span class="lineNum">    1965 </span>            :                  compilable output.) */</a>
<a name="1966"><span class="lineNum">    1966 </span><span class="lineNoCov">          0 :               check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="1967"><span class="lineNum">    1967 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;&lt;expr&gt;&quot;, octl);</span></a>
<a name="1968"><span class="lineNum">    1968 </span>            :             }  /* if */</a>
<a name="1969"><span class="lineNum">    1969 </span>            :           } else {</a>
<a name="1970"><span class="lineNum">    1970 </span>            :             /* typeof(type-name). */</a>
<a name="1971"><span class="lineNum">    1971 </span><span class="lineNoCov">          0 :             form_type(type-&gt;variant.typeref.type, octl);</span></a>
<a name="1972"><span class="lineNum">    1972 </span>            :           }  /* if */</a>
<a name="1973"><span class="lineNum">    1973 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="1974"><span class="lineNum">    1974 </span>            :         } /* if */</a>
<a name="1975"><span class="lineNum">    1975 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="1976"><span class="lineNum">    1976 </span><span class="lineCov">         18 :       } else if (type-&gt;variant.typeref.is_deduced_decltype_auto) {</span></a>
<a name="1977"><span class="lineNum">    1977 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;decltype(auto)&quot;, octl);</span></a>
<a name="1978"><span class="lineNum">    1978 </span><span class="lineCov">         18 :       } else if (type-&gt;variant.typeref.is_deduced_auto) {</span></a>
<a name="1979"><span class="lineNum">    1979 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;auto&quot;, octl);</span></a>
<a name="1980"><span class="lineNum">    1980 </span><span class="lineCov">         18 :       } else if (type-&gt;variant.typeref.is_deduced_class) {</span></a>
<a name="1981"><span class="lineNum">    1981 </span><span class="lineNoCov">          0 :         a_type_ptr      instance = type-&gt;variant.typeref.type;</span></a>
<a name="1982"><span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         a_template_ptr  templ;</span></a>
<a name="1983"><span class="lineNum">    1983 </span><span class="lineNoCov">          0 :         check_assertion(instance != NULL &amp;&amp; is_immediate_class_type(instance));</span></a>
<a name="1984"><span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         templ = class_type_supp(instance)-&gt;assoc_template;</span></a>
<a name="1985"><span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         check_assertion(templ != NULL);</span></a>
<a name="1986"><span class="lineNum">    1986 </span><span class="lineNoCov">          0 :         form_name(&amp;templ-&gt;source_corresp, iek_template, octl);</span></a>
<a name="1987"><span class="lineNum">    1987 </span>            :       } else {</a>
<a name="1988"><span class="lineNum">    1988 </span><span class="lineCov">         18 :         check_assertion_str(typeref_is_typedef(type),</span></a>
<a name="1989"><span class="lineNum">    1989 </span><span class="lineCov">         18 :                             &quot;form_type_specifier: typeref is not typedef&quot;);</span></a>
<a name="1990"><span class="lineNum">    1990 </span><span class="lineCov">         18 :         form_name(&amp;type-&gt;source_corresp, iek_type, octl);</span></a>
<a name="1991"><span class="lineNum">    1991 </span>            :       }  /* if */</a>
<a name="1992"><span class="lineNum">    1992 </span>            :       break;</a>
<a name="1993"><span class="lineNum">    1993 </span><span class="lineCov">         10 :     case tk_template_param:</span></a>
<a name="1994"><span class="lineNum">    1994 </span>            :       {</a>
<a name="1995"><span class="lineNum">    1995 </span><span class="lineCov">         10 :         if (is_auto_type(type)) {</span></a>
<a name="1996"><span class="lineNum">    1996 </span>            :           /* A type entry representing an &quot;auto&quot; or &quot;decltype(auto)&quot; type</a>
<a name="1997"><span class="lineNum">    1997 </span>            :              specifier. */</a>
<a name="1998"><span class="lineNum">    1998 </span><span class="lineNoCov">          0 :           if (type-&gt;variant.template_param.extra_info</span></a>
<a name="1999"><span class="lineNum">    1999 </span><span class="lineNoCov">          0 :                   -&gt;coordinates.position == DECLTYPE_AUTO_POS_NUMBER) {</span></a>
<a name="2000"><span class="lineNum">    2000 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;decltype(auto)&quot;, octl);</span></a>
<a name="2001"><span class="lineNum">    2001 </span>            :           } else {</a>
<a name="2002"><span class="lineNum">    2002 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;auto&quot;, octl);</span></a>
<a name="2003"><span class="lineNum">    2003 </span>            :           }  /* if */</a>
<a name="2004"><span class="lineNum">    2004 </span><span class="lineCov">         10 :         } else if (type-&gt;variant.template_param.is_auto_param) {</span></a>
<a name="2005"><span class="lineNum">    2005 </span>            :           /* A template type parameter declared for an &quot;auto&quot; parameter in a</a>
<a name="2006"><span class="lineNum">    2006 </span>            :              C++14-style generic lambda. */</a>
<a name="2007"><span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;auto&quot;, octl);</span></a>
<a name="2008"><span class="lineNum">    2008 </span>            :         } else {</a>
<a name="2009"><span class="lineNum">    2009 </span><span class="lineCov">         10 :           a_source_correspondence_ptr scp = &amp;type-&gt;source_corresp;</span></a>
<a name="2010"><span class="lineNum">    2010 </span><span class="lineCov">         10 :           an_il_entry_kind            scp_kind = iek_type;</span></a>
<a name="2011"><span class="lineNum">    2011 </span>            :           /* See whether the template parameter name is remapped in the</a>
<a name="2012"><span class="lineNum">    2012 </span>            :              current context. */</a>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineCov">         10 :           if (type-&gt;variant.template_param.kind ==</span></a>
<a name="2014"><span class="lineNum">    2014 </span><span class="lineCov">         10 :                                      (a_template_param_type_kind)tptk_param &amp;&amp;</span></a>
<a name="2015"><span class="lineNum">    2015 </span><span class="lineCov">         10 :               type-&gt;variant.template_param.extra_info-&gt;coordinates.depth !=</span></a>
<a name="2016"><span class="lineNum">    2016 </span>            :                                     CLASS_TEMPLATE_PLACEHOLDER_NESTING_DEPTH) {</a>
<a name="2017"><span class="lineNum">    2017 </span><span class="lineCov">         10 :             a_source_correspondence_ptr new_scp;</span></a>
<a name="2018"><span class="lineNum">    2018 </span><span class="lineCov">         20 :             new_scp = source_corresp_for_template_param(</span></a>
<a name="2019"><span class="lineNum">    2019 </span><span class="lineCov">         10 :                        &amp;type-&gt;variant.template_param.extra_info-&gt;coordinates);</span></a>
<a name="2020"><span class="lineNum">    2020 </span><span class="lineCov">         10 :             if (new_scp != NULL) {</span></a>
<a name="2021"><span class="lineNum">    2021 </span><span class="lineNoCov">          0 :               scp = new_scp;</span></a>
<a name="2022"><span class="lineNum">    2022 </span><span class="lineNoCov">          0 :               scp_kind = iek_template_parameter;</span></a>
<a name="2023"><span class="lineNum">    2023 </span>            :             }  /* if */</a>
<a name="2024"><span class="lineNum">    2024 </span>            :           }  /* if */</a>
<a name="2025"><span class="lineNum">    2025 </span><span class="lineCov">         10 :           if (scp-&gt;member_of_unknown_base &amp;&amp;</span></a>
<a name="2026"><span class="lineNum">    2026 </span>            :               !scp-&gt;qualified_unknown_base_member) {</a>
<a name="2027"><span class="lineNum">    2027 </span>            :             /* We're pretending that we found the member in a dependent</a>
<a name="2028"><span class="lineNum">    2028 </span>            :                base class and the original form of reference was</a>
<a name="2029"><span class="lineNum">    2029 </span>            :                unqualified. */</a>
<a name="2030"><span class="lineNum">    2030 </span><span class="lineNoCov">          0 :             form_unqualified_name(scp, scp_kind, octl);</span></a>
<a name="2031"><span class="lineNum">    2031 </span>            :           } else {</a>
<a name="2032"><span class="lineNum">    2032 </span><span class="lineCov">         10 :             form_name(scp, (an_il_entry_kind)scp_kind, octl);</span></a>
<a name="2033"><span class="lineNum">    2033 </span>            :           }  /* if */</a>
<a name="2034"><span class="lineNum">    2034 </span>            :         }  /* if */</a>
<a name="2035"><span class="lineNum">    2035 </span>            :       }</a>
<a name="2036"><span class="lineNum">    2036 </span>            :       break;</a>
<a name="2037"><span class="lineNum">    2037 </span>            : #if GNU_VECTOR_TYPES_ALLOWED</a>
<a name="2038"><span class="lineNum">    2038 </span><span class="lineNoCov">          0 :     case tk_vector:</span></a>
<a name="2039"><span class="lineNum">    2039 </span>            :       /* GNU vector types are formed by associating the &quot;vector_size&quot; or</a>
<a name="2040"><span class="lineNum">    2040 </span>            :          &quot;mode&quot; attribute with the underlying element type.  If attributes</a>
<a name="2041"><span class="lineNum">    2041 </span>            :          are rendered from an_attribute entries, we only render the element</a>
<a name="2042"><span class="lineNum">    2042 </span>            :          type here.  Otherwise, we form the attribute also, unless it must</a>
<a name="2043"><span class="lineNum">    2043 </span>            :          be deferred to meet GCC requirements (which happens when vector_size</a>
<a name="2044"><span class="lineNum">    2044 </span>            :          occurs in a typedef definition).  It is also possible to have vector</a>
<a name="2045"><span class="lineNum">    2045 </span>            :          types rendered as &quot;__edg_vector_type__(T, N)&quot; by setting the global</a>
<a name="2046"><span class="lineNum">    2046 </span>            :          variable gen_edg_vector_type to TRUE. */</a>
<a name="2047"><span class="lineNum">    2047 </span><span class="lineNoCov">          0 :       if (gen_edg_vector_type) {</span></a>
<a name="2048"><span class="lineNum">    2048 </span><span class="lineNoCov">          0 :         a_type_ptr  etype = type-&gt;variant.vector.element_type;</span></a>
<a name="2049"><span class="lineNum">    2049 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;__edg_vector_type__(&quot;, octl);</span></a>
<a name="2050"><span class="lineNum">    2050 </span><span class="lineNoCov">          0 :         form_type(etype, octl);</span></a>
<a name="2051"><span class="lineNum">    2051 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="2052"><span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         if (type-&gt;variant.vector.size_constant != NULL) {</span></a>
<a name="2053"><span class="lineNum">    2053 </span><span class="lineNoCov">          0 :           form_constant(type-&gt;variant.vector.size_constant,</span></a>
<a name="2054"><span class="lineNum">    2054 </span>            :                         /*need_parens=*/FALSE, octl);</a>
<a name="2055"><span class="lineNum">    2055 </span>            :         } else {</a>
<a name="2056"><span class="lineNum">    2056 </span><span class="lineNoCov">          0 :           a_targ_size_t  vlen = type-&gt;size/skip_typerefs(etype)-&gt;size;</span></a>
<a name="2057"><span class="lineNum">    2057 </span><span class="lineNoCov">          0 :           form_unsigned_num((a_host_large_unsigned)vlen, octl);</span></a>
<a name="2058"><span class="lineNum">    2058 </span>            :         }  /* if */</a>
<a name="2059"><span class="lineNum">    2059 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="2060"><span class="lineNum">    2060 </span>            :       } else {</a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         if (!octl-&gt;defer_vector_attribute &amp;&amp; octl-&gt;output_attributes == NULL) {</span></a>
<a name="2062"><span class="lineNum">    2062 </span><span class="lineNoCov">          0 :           a_boolean need_leading_space = FALSE;</span></a>
<a name="2063"><span class="lineNum">    2063 </span><span class="lineNoCov">          0 :           form_vector_type_attribute(type, &amp;need_leading_space, octl);</span></a>
<a name="2064"><span class="lineNum">    2064 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="2065"><span class="lineNum">    2065 </span>            :         }  /* if */</a>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         form_type(type-&gt;variant.vector.element_type, octl);</span></a>
<a name="2067"><span class="lineNum">    2067 </span>            :       }  /* if */</a>
<a name="2068"><span class="lineNum">    2068 </span>            :       break;</a>
<a name="2069"><span class="lineNum">    2069 </span>            : #endif /* GNU_VECTOR_TYPES_ALLOWED */</a>
<a name="2070"><span class="lineNum">    2070 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2071"><span class="lineNum">    2071 </span>            :     case tk_pointer:</a>
<a name="2072"><span class="lineNum">    2072 </span>            :       /* C++/CLI interior_ptr&lt;T&gt; and pin_ptr&lt;T&gt; */</a>
<a name="2073"><span class="lineNum">    2073 </span>            :       if (type-&gt;variant.pointer.is_interior_ptr) {</a>
<a name="2074"><span class="lineNum">    2074 </span>            :         octl-&gt;output_str(&quot;interior_ptr&lt;&quot;, octl);</a>
<a name="2075"><span class="lineNum">    2075 </span>            :       } else if (type-&gt;variant.pointer.is_pin_ptr) {</a>
<a name="2076"><span class="lineNum">    2076 </span>            :         octl-&gt;output_str(&quot;pin_ptr&lt;&quot;, octl);</a>
<a name="2077"><span class="lineNum">    2077 </span>            :       } else {</a>
<a name="2078"><span class="lineNum">    2078 </span>            :         unexpected_condition();</a>
<a name="2079"><span class="lineNum">    2079 </span>            :       }  /* if */</a>
<a name="2080"><span class="lineNum">    2080 </span>            :       form_type(type-&gt;variant.pointer.type, octl);</a>
<a name="2081"><span class="lineNum">    2081 </span>            :       octl-&gt;output_str(&quot;&gt;&quot;, octl);</a>
<a name="2082"><span class="lineNum">    2082 </span>            :       break;</a>
<a name="2083"><span class="lineNum">    2083 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2084"><span class="lineNum">    2084 </span><span class="lineNoCov">          0 :     case tk_nullptr:</span></a>
<a name="2085"><span class="lineNum">    2085 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;c_generating_back_end);</span></a>
<a name="2086"><span class="lineNum">    2086 </span>            :       /* If this is the standard nullptr type, put it out as the name of the</a>
<a name="2087"><span class="lineNum">    2087 </span>            :          standard C++ typedef; otherwise, use decltype. */</a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineNoCov">          0 :       if (is_standard_nullptr_type(type)) {</span></a>
<a name="2089"><span class="lineNum">    2089 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;std::nullptr_t&quot;, octl);</span></a>
<a name="2090"><span class="lineNum">    2090 </span>            :       } else {</a>
<a name="2091"><span class="lineNum">    2091 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;decltype(nullptr)&quot;, octl);</span></a>
<a name="2092"><span class="lineNum">    2092 </span>            :       }  /* if */</a>
<a name="2093"><span class="lineNum">    2093 </span>            :       break;</a>
<a name="2094"><span class="lineNum">    2094 </span><span class="lineNoCov">          0 :     case tk_unknown:</span></a>
<a name="2095"><span class="lineNum">    2095 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="2096"><span class="lineNum">    2096 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;unknown-type&gt;&quot;, octl);</span></a>
<a name="2097"><span class="lineNum">    2097 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="2098"><span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="2099"><span class="lineNum">    2099 </span>            : #if DEBUG</a>
<a name="2100"><span class="lineNum">    2100 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="2101"><span class="lineNum">    2101 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;**BAD-TYPE-KIND**&quot;, octl);</span></a>
<a name="2102"><span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="2103"><span class="lineNum">    2103 </span>            :       }  /* if */</a>
<a name="2104"><span class="lineNum">    2104 </span>            : #endif /* DEBUG */</a>
<a name="2105"><span class="lineNum">    2105 </span><span class="lineNoCov">          0 :       unexpected_condition_str(&quot;form_type_specifier: bad type kind&quot;);</span></a>
<a name="2106"><span class="lineNum">    2106 </span>            :   }  /* switch */</a>
<a name="2107"><span class="lineNum">    2107 </span><span class="lineCov">         46 : }  /* form_type_specifier */</span></a>
<a name="2108"><span class="lineNum">    2108 </span>            : </a>
<a name="2109"><span class="lineNum">    2109 </span>            : </a>
<a name="2110"><span class="lineNum">    2110 </span>            : /*</a>
<a name="2111"><span class="lineNum">    2111 </span>            : Return TRUE if the indicated typedef is &quot;invisible&quot; now because (a) it's</a>
<a name="2112"><span class="lineNum">    2112 </span>            : local to a function and we're suppressing local typedefs, or</a>
<a name="2113"><span class="lineNum">    2113 </span>            : (b) suppress_const is TRUE (we're suppressing top-level &quot;const&quot;) and the</a>
<a name="2114"><span class="lineNum">    2114 </span>            : typedef contains a const qualifier, or (c) suppress_typedefs is TRUE, or</a>
<a name="2115"><span class="lineNum">    2115 </span>            : (d) a user visibility test routine (pointed to by the is_typedef_visible</a>
<a name="2116"><span class="lineNum">    2116 </span>            : control field) returns TRUE.</a>
<a name="2117"><span class="lineNum">    2117 </span>            : */</a>
<a name="2118"><span class="lineNum">    2118 </span>            : #define typedef_is_invisible(type, suppress_const, octl)              \</a>
<a name="2119"><span class="lineNum">    2119 </span>            :  (((type)-&gt;source_corresp.is_local_to_function &amp;&amp;                     \</a>
<a name="2120"><span class="lineNum">    2120 </span>            :    (octl)-&gt;suppress_local_typedefs) ||                                \</a>
<a name="2121"><span class="lineNum">    2121 </span>            :   ((suppress_const) &amp;&amp; is_const_qualified_type(type)) ||              \</a>
<a name="2122"><span class="lineNum">    2122 </span>            :   (octl)-&gt;suppress_typedefs ||                                        \</a>
<a name="2123"><span class="lineNum">    2123 </span>            :   ((octl)-&gt;is_typedef_invisible != NULL &amp;&amp;                            \</a>
<a name="2124"><span class="lineNum">    2124 </span>            :    (octl)-&gt;is_typedef_invisible(type)))</a>
<a name="2125"><span class="lineNum">    2125 </span>            : </a>
<a name="2126"><span class="lineNum">    2126 </span>            : </a>
<a name="2127"><span class="lineNum">    2127 </span><span class="lineNoCov">          0 : static a_boolean can_use_qualified_array_typedef(</span></a>
<a name="2128"><span class="lineNum">    2128 </span>            :                           a_type_ptr                            *p_type,</a>
<a name="2129"><span class="lineNum">    2129 </span>            :                           a_type_qualifier_set                  *p_qualifiers,</a>
<a name="2130"><span class="lineNum">    2130 </span>            :                           a_boolean                             suppress_const,</a>
<a name="2131"><span class="lineNum">    2131 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="2132"><span class="lineNum">    2132 </span>            : /*</a>
<a name="2133"><span class="lineNum">    2133 </span>            : If *p_type (an array type) was generated by adding a qualifier to a typedef</a>
<a name="2134"><span class="lineNum">    2134 </span>            : for an array type, and the qualified typedef can be used, return TRUE and</a>
<a name="2135"><span class="lineNum">    2135 </span>            : update *p_type and *p_qualifiers accordingly.  If suppress_const is TRUE,</a>
<a name="2136"><span class="lineNum">    2136 </span>            : we're supposed to suppress top-level &quot;const&quot;.  octl is the output control</a>
<a name="2137"><span class="lineNum">    2137 </span>            : block, needed because it indicates whether local typedefs are invisible.</a>
<a name="2138"><span class="lineNum">    2138 </span>            : */</a>
<a name="2139"><span class="lineNum">    2139 </span>            : {</a>
<a name="2140"><span class="lineNum">    2140 </span><span class="lineNoCov">          0 :   a_boolean            can_use_typedef = FALSE;</span></a>
<a name="2141"><span class="lineNum">    2141 </span><span class="lineNoCov">          0 :   a_type_ptr           type = *p_type, unqual_array_type;</span></a>
<a name="2142"><span class="lineNum">    2142 </span><span class="lineNoCov">          0 :   a_type_qualifier_set qualifiers;</span></a>
<a name="2143"><span class="lineNum">    2143 </span>            : </a>
<a name="2144"><span class="lineNum">    2144 </span><span class="lineNoCov">          0 :   if (is_qualified_version_of_array_typedef(type, &amp;unqual_array_type)) {</span></a>
<a name="2145"><span class="lineNum">    2145 </span>            :     /* This array type was generated by applying a type qualifier to</a>
<a name="2146"><span class="lineNum">    2146 </span>            :        a typedef of an array type. */</a>
<a name="2147"><span class="lineNum">    2147 </span><span class="lineNoCov">          0 :     if (typedef_is_invisible(unqual_array_type, suppress_const, octl)) {</span></a>
<a name="2148"><span class="lineNum">    2148 </span>            :       /* We can't use this typedef. */</a>
<a name="2149"><span class="lineNum">    2149 </span>            :     } else {</a>
<a name="2150"><span class="lineNum">    2150 </span>            :       /* We can use the array typedef. */</a>
<a name="2151"><span class="lineNum">    2151 </span>            :       /* The qualifiers to be added are those on the type we have here minus</a>
<a name="2152"><span class="lineNum">    2152 </span>            :          those that appeared on the element type of the array before</a>
<a name="2153"><span class="lineNum">    2153 </span>            :          qualification. */</a>
<a name="2154"><span class="lineNum">    2154 </span><span class="lineNoCov">          0 :       a_type_ptr           unqual_array_element_type =</span></a>
<a name="2155"><span class="lineNum">    2155 </span><span class="lineNoCov">          0 :                               underlying_array_element_type(unqual_array_type);</span></a>
<a name="2156"><span class="lineNum">    2156 </span><span class="lineNoCov">          0 :       a_type_qualifier_set unqual_array_qualifiers =</span></a>
<a name="2157"><span class="lineNum">    2157 </span><span class="lineNoCov">          0 :                       get_top_level_type_qualifiers(unqual_array_element_type);</span></a>
<a name="2158"><span class="lineNum">    2158 </span><span class="lineNoCov">          0 :       type = underlying_array_element_type(type);</span></a>
<a name="2159"><span class="lineNum">    2159 </span><span class="lineNoCov">          0 :       qualifiers = get_top_level_type_qualifiers(type);</span></a>
<a name="2160"><span class="lineNum">    2160 </span><span class="lineNoCov">          0 :       if (suppress_const) {</span></a>
<a name="2161"><span class="lineNum">    2161 </span><span class="lineNoCov">          0 :         qualifiers &amp;= ~TQ_CONST;</span></a>
<a name="2162"><span class="lineNum">    2162 </span>            :       }  /* if */</a>
<a name="2163"><span class="lineNum">    2163 </span><span class="lineNoCov">          0 :       *p_qualifiers = qualifiers &amp; ~unqual_array_qualifiers;</span></a>
<a name="2164"><span class="lineNum">    2164 </span><span class="lineNoCov">          0 :       *p_type = unqual_array_type;</span></a>
<a name="2165"><span class="lineNum">    2165 </span><span class="lineNoCov">          0 :       can_use_typedef = TRUE;</span></a>
<a name="2166"><span class="lineNum">    2166 </span>            :     }  /* if */</a>
<a name="2167"><span class="lineNum">    2167 </span>            :   }  /* if */</a>
<a name="2168"><span class="lineNum">    2168 </span><span class="lineNoCov">          0 :   return can_use_typedef;</span></a>
<a name="2169"><span class="lineNum">    2169 </span>            : }  /* can_use_qualified_array_typedef */</a>
<a name="2170"><span class="lineNum">    2170 </span>            : </a>
<a name="2171"><span class="lineNum">    2171 </span>            : </a>
<a name="2172"><span class="lineNum">    2172 </span><span class="lineCov">         80 : static a_boolean is_member_typedef_that_should_be_ignored(</span></a>
<a name="2173"><span class="lineNum">    2173 </span>            :                                 a_type_ptr                              type,</a>
<a name="2174"><span class="lineNum">    2174 </span>            :                                 an_il_to_str_output_control_block_ptr   octl)</a>
<a name="2175"><span class="lineNum">    2175 </span>            : /*</a>
<a name="2176"><span class="lineNum">    2176 </span>            : &quot;type&quot; is a typedef.  Return TRUE if the typedef is one that should be</a>
<a name="2177"><span class="lineNum">    2177 </span>            : replaced with the underlying type.  This is done for typedefs that are</a>
<a name="2178"><span class="lineNum">    2178 </span>            : members of template classes.</a>
<a name="2179"><span class="lineNum">    2179 </span>            : */</a>
<a name="2180"><span class="lineNum">    2180 </span>            : {</a>
<a name="2181"><span class="lineNum">    2181 </span><span class="lineCov">         80 :   a_boolean     result = FALSE;</span></a>
<a name="2182"><span class="lineNum">    2182 </span>            : </a>
<a name="2183"><span class="lineNum">    2183 </span><span class="lineCov">         80 :   if (octl-&gt;remove_template_typedefs) {</span></a>
<a name="2184"><span class="lineNum">    2184 </span><span class="lineCov">         80 :     if (type-&gt;source_corresp.is_class_member) {</span></a>
<a name="2185"><span class="lineNum">    2185 </span>            :       /* Drop the typedef if it was defined in a template class.  This is</a>
<a name="2186"><span class="lineNum">    2186 </span>            :          done even if the class was specialized. */</a>
<a name="2187"><span class="lineNum">    2187 </span><span class="lineCov">         44 :       a_type_ptr        parent_type = parent_class_of(type);</span></a>
<a name="2188"><span class="lineNum">    2188 </span><span class="lineCov">         44 :       if (parent_type-&gt;variant.class_struct_union.is_template_class) {</span></a>
<a name="2189"><span class="lineNum">    2189 </span>            :         result = TRUE;</a>
<a name="2190"><span class="lineNum">    2190 </span>            :       }  /* if */</a>
<a name="2191"><span class="lineNum">    2191 </span>            :     }  /* if */</a>
<a name="2192"><span class="lineNum">    2192 </span>            :   }  /* if */</a>
<a name="2193"><span class="lineNum">    2193 </span>            :   return result;</a>
<a name="2194"><span class="lineNum">    2194 </span>            : }  /* is_member_typedef_that_should_be_ignored */</a>
<a name="2195"><span class="lineNum">    2195 </span>            : </a>
<a name="2196"><span class="lineNum">    2196 </span>            : </a>
<a name="2197"><span class="lineNum">    2197 </span><span class="lineCov">          2 : static a_boolean is_type_operator_to_be_rendered(</span></a>
<a name="2198"><span class="lineNum">    2198 </span>            :                                    a_type_ptr                            type,</a>
<a name="2199"><span class="lineNum">    2199 </span>            :                                    an_il_to_str_output_control_block_ptr octl)</a>
<a name="2200"><span class="lineNum">    2200 </span>            : /*</a>
<a name="2201"><span class="lineNum">    2201 </span>            : Return TRUE if the given typeref type is a decltype, __underlying_type, or</a>
<a name="2202"><span class="lineNum">    2202 </span>            : typeof construct that should be rendered.  Otherwise, the underlying type</a>
<a name="2203"><span class="lineNum">    2203 </span>            : should be rendered (e.g., in diagnostics the underlying type is more helpful,</a>
<a name="2204"><span class="lineNum">    2204 </span>            : and in the C-generating back end typeof/decltype constructs are either not</a>
<a name="2205"><span class="lineNum">    2205 </span>            : available or not portable).</a>
<a name="2206"><span class="lineNum">    2206 </span>            : */</a>
<a name="2207"><span class="lineNum">    2207 </span>            : {</a>
<a name="2208"><span class="lineNum">    2208 </span><span class="lineCov">          2 :   a_boolean render = FALSE;</span></a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span><span class="lineCov">          2 :   if (typeref_is_type_operator(type)) {</span></a>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     if (octl-&gt;c_generating_back_end) {</span></a>
<a name="2212"><span class="lineNum">    2212 </span>            :       /* Never render a type operator in the C-generating back end. */</a>
<a name="2213"><span class="lineNum">    2213 </span>            :       render = FALSE;</a>
<a name="2214"><span class="lineNum">    2214 </span><span class="lineNoCov">          0 :     } else if (type-&gt;variant.typeref.is_underlying_type ||</span></a>
<a name="2215"><span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                type-&gt;variant.typeref.is_bases ||</span></a>
<a name="2216"><span class="lineNum">    2216 </span><span class="lineNoCov">          0 :                (!type-&gt;variant.typeref.is_decltype &amp;&amp;</span></a>
<a name="2217"><span class="lineNum">    2217 </span><span class="lineNoCov">          0 :                 decltype_arg(type) == NULL)) {</span></a>
<a name="2218"><span class="lineNum">    2218 </span>            :       /* A non-expression case: __underlying_type, typeof, etc. applied to</a>
<a name="2219"><span class="lineNum">    2219 </span>            :          a type name.  Render the operator in the C++-generating back end</a>
<a name="2220"><span class="lineNum">    2220 </span>            :          (to match the source form) or when the argument is template-dependent.</a>
<a name="2221"><span class="lineNum">    2221 </span>            :          Otherwise, render the underlying type. */</a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineNoCov">          0 :       render = octl-&gt;gen_compilable_code ||</span></a>
<a name="2223"><span class="lineNum">    2223 </span>            :                type-&gt;variant.typeref.is_dependent_type_operator;</a>
<a name="2224"><span class="lineNum">    2224 </span>            :     } else {</a>
<a name="2225"><span class="lineNum">    2225 </span>            :       /* The decltype or typeof is based on an expression. */</a>
<a name="2226"><span class="lineNum">    2226 </span><span class="lineNoCov">          0 :       a_type_ptr underlying_type = type-&gt;variant.typeref.type;</span></a>
<a name="2227"><span class="lineNum">    2227 </span><span class="lineNoCov">          0 :       underlying_type = skip_typerefs(underlying_type);</span></a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineNoCov">          0 :       if (underlying_type-&gt;kind == (a_type_kind)tk_template_param &amp;&amp;</span></a>
<a name="2229"><span class="lineNum">    2229 </span><span class="lineNoCov">          0 :           underlying_type-&gt;variant.template_param.kind ==</span></a>
<a name="2230"><span class="lineNum">    2230 </span>            :                                     (a_template_param_type_kind)tptk_unknown) {</a>
<a name="2231"><span class="lineNum">    2231 </span>            :         /* With unknown template cases, you always need the underlying</a>
<a name="2232"><span class="lineNum">    2232 </span>            :            expression to make sense of things. */</a>
<a name="2233"><span class="lineNum">    2233 </span>            :         render = TRUE;</a>
<a name="2234"><span class="lineNum">    2234 </span><span class="lineNoCov">          0 :       } else if (octl-&gt;gen_compilable_code) {</span></a>
<a name="2235"><span class="lineNum">    2235 </span>            :         /* We're generating compilable code, and the decltype or typeof is</a>
<a name="2236"><span class="lineNum">    2236 </span>            :            based on an expression.  Render it. */</a>
<a name="2237"><span class="lineNum">    2237 </span><span class="lineNoCov">          0 :         render = TRUE;</span></a>
<a name="2238"><span class="lineNum">    2238 </span>            :       }  /* if */</a>
<a name="2239"><span class="lineNum">    2239 </span>            :     }  /* if */</a>
<a name="2240"><span class="lineNum">    2240 </span><span class="lineCov">          2 :   } else if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="2241"><span class="lineNum">    2241 </span><span class="lineCov">          2 :              octl-&gt;render_auto_deduction_typerefs &amp;&amp;</span></a>
<a name="2242"><span class="lineNum">    2242 </span><span class="lineNoCov">          0 :              (type-&gt;variant.typeref.is_deduced_decltype_auto ||</span></a>
<a name="2243"><span class="lineNum">    2243 </span>            :               type-&gt;variant.typeref.is_deduced_auto)) {</a>
<a name="2244"><span class="lineNum">    2244 </span>            :     /* &quot;auto&quot; and &quot;decltype(auto)&quot; should only appear in declarative</a>
<a name="2245"><span class="lineNum">    2245 </span>            :        contexts, and should be rendered there. */</a>
<a name="2246"><span class="lineNum">    2246 </span><span class="lineNoCov">          0 :     render = TRUE;</span></a>
<a name="2247"><span class="lineNum">    2247 </span>            :   }  /* if */</a>
<a name="2248"><span class="lineNum">    2248 </span><span class="lineCov">          2 :   return render;</span></a>
<a name="2249"><span class="lineNum">    2249 </span>            : }  /* is_type_operator_to_be_rendered */</a>
<a name="2250"><span class="lineNum">    2250 </span>            : </a>
<a name="2251"><span class="lineNum">    2251 </span>            : </a>
<a name="2252"><span class="lineNum">    2252 </span><span class="lineCov">         54 : void form_type_first_part(</span></a>
<a name="2253"><span class="lineNum">    2253 </span>            :                     a_type_ptr                            type,</a>
<a name="2254"><span class="lineNum">    2254 </span>            :                     a_boolean                             under_lhs_declarator,</a>
<a name="2255"><span class="lineNum">    2255 </span>            :                     a_boolean                             need_trailing_space,</a>
<a name="2256"><span class="lineNum">    2256 </span>            :                     a_type_qualifier_set                  added_qualifiers,</a>
<a name="2257"><span class="lineNum">    2257 </span>            :                     a_form_type_options_set               options,</a>
<a name="2258"><span class="lineNum">    2258 </span>            :                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="2259"><span class="lineNum">    2259 </span>            : /*</a>
<a name="2260"><span class="lineNum">    2260 </span>            : For the indicated type, output the specifiers and the part of the declarator</a>
<a name="2261"><span class="lineNum">    2261 </span>            : that precedes the name.  If under_lhs_declarator is TRUE, this type is</a>
<a name="2262"><span class="lineNum">    2262 </span>            : directly under a type that uses a left-side declarator, e.g., a pointer type.</a>
<a name="2263"><span class="lineNum">    2263 </span>            : (That's used to control use of parentheses around parts of the declarator.)</a>
<a name="2264"><span class="lineNum">    2264 </span>            : If need_trailing_space is TRUE, put a space at the end of the specifiers</a>
<a name="2265"><span class="lineNum">    2265 </span>            : part (needed if the declarator part is not empty, because it contains a</a>
<a name="2266"><span class="lineNum">    2266 </span>            : name or a derived type).  added_qualifiers contains a set of type qualifiers</a>
<a name="2267"><span class="lineNum">    2267 </span>            : to be added on top of the type.  options contains options as bits in a set:</a>
<a name="2268"><span class="lineNum">    2268 </span>            : If FTO_SUPPRESS_CONST is TRUE, suppress generation of top-level &quot;const&quot;;</a>
<a name="2269"><span class="lineNum">    2269 </span>            : if FTO_SUPPRESS_SPECIFIERS is TRUE, suppress generation of the type specifiers</a>
<a name="2270"><span class="lineNum">    2270 </span>            : (put out only the declarator).  Do the output in the way described by octl.</a>
<a name="2271"><span class="lineNum">    2271 </span>            : */</a>
<a name="2272"><span class="lineNum">    2272 </span>            : {</a>
<a name="2273"><span class="lineNum">    2273 </span><span class="lineCov">         54 :   a_type_kind kind;</span></a>
<a name="2274"><span class="lineNum">    2274 </span><span class="lineCov">         54 :   a_boolean   suppress_const = (options &amp; FTO_SUPPRESS_CONST) != 0;</span></a>
<a name="2275"><span class="lineNum">    2275 </span><span class="lineCov">         54 :   a_type_qualifier_set</span></a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineCov">         54 :               qualifiers = TQ_NONE;</span></a>
<a name="2277"><span class="lineNum">    2277 </span>            : #if NEAR_AND_FAR_ALLOWED</a>
<a name="2278"><span class="lineNum">    2278 </span>            :   a_type_qualifier_set</a>
<a name="2279"><span class="lineNum">    2279 </span>            :               near_and_far_qualifiers;</a>
<a name="2280"><span class="lineNum">    2280 </span>            :   a_boolean   near_and_far_need_trailing_space = FALSE;</a>
<a name="2281"><span class="lineNum">    2281 </span>            : #endif /* NEAR_AND_FAR_ALLOWED */</a>
<a name="2282"><span class="lineNum">    2282 </span><span class="lineCov">         54 :   a_upc_block_size</span></a>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineCov">         54 :               upc_block_size = UPC_BLOCK_SIZE_NONE;</span></a>
<a name="2284"><span class="lineNum">    2284 </span><span class="lineCov">         54 :   a_type_ptr  orig_type = type;</span></a>
<a name="2285"><span class="lineNum">    2285 </span><span class="lineCov">         54 :   a_type_ptr  attrib_stop_type = type;</span></a>
<a name="2286"><span class="lineNum">    2286 </span>            : </a>
<a name="2287"><span class="lineNum">    2287 </span><span class="lineCov">         54 :   if (type == NULL) {</span></a>
<a name="2288"><span class="lineNum">    2288 </span>            :     /* NULL type pointer. */</a>
<a name="2289"><span class="lineNum">    2289 </span>            : #if DEBUG</a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineNoCov">          0 :     if (octl-&gt;debug_output) {</span></a>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;**NULL-TYPE-POINTER**&quot;, octl);</span></a>
<a name="2292"><span class="lineNum">    2292 </span><span class="lineNoCov">          0 :       goto end_of_routine;</span></a>
<a name="2293"><span class="lineNum">    2293 </span>            :     }  /* if */</a>
<a name="2294"><span class="lineNum">    2294 </span>            : #endif /* DEBUG */</a>
<a name="2295"><span class="lineNum">    2295 </span><span class="lineNoCov">          0 :     check_assertion_str(!octl-&gt;gen_compilable_code,</span></a>
<a name="2296"><span class="lineNum">    2296 </span><span class="lineNoCov">          0 :                         &quot;form_type_first_part: NULL type&quot;);</span></a>
<a name="2297"><span class="lineNum">    2297 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&lt;something&gt;&quot;, octl);</span></a>
<a name="2298"><span class="lineNum">    2298 </span><span class="lineNoCov">          0 :     goto end_of_routine;</span></a>
<a name="2299"><span class="lineNum">    2299 </span>            :   }  /* if */</a>
<a name="2300"><span class="lineNum">    2300 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2301"><span class="lineNum">    2301 </span>            :   if (is_cli_generic_definition_argument_type(type) &amp;&amp;</a>
<a name="2302"><span class="lineNum">    2302 </span>            :       is_handle_type(type)) {</a>
<a name="2303"><span class="lineNum">    2303 </span>            :     /* For a generic definition argument, strip the handle type if one is</a>
<a name="2304"><span class="lineNum">    2304 </span>            :        present. */</a>
<a name="2305"><span class="lineNum">    2305 </span>            :     type = type-&gt;variant.pointer.type;</a>
<a name="2306"><span class="lineNum">    2306 </span>            :   }  /* if */</a>
<a name="2307"><span class="lineNum">    2307 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2308"><span class="lineNum">    2308 </span><span class="lineCov">         54 :   options &amp;= ~FTO_SUPPRESS_CONST;</span></a>
<a name="2309"><span class="lineNum">    2309 </span>            :   /* Remove type qualifiers but not typedefs.  Also drop typedefs</a>
<a name="2310"><span class="lineNum">    2310 </span>            :      that aren't visible here.  Accumulate the type qualifier set. */</a>
<a name="2311"><span class="lineNum">    2311 </span><span class="lineCov">         77 :   while (type-&gt;kind == (a_type_kind)tk_typeref) {</span></a>
<a name="2312"><span class="lineNum">    2312 </span><span class="lineCov">         41 :     if (typeref_is_typedef(type)) {</span></a>
<a name="2313"><span class="lineNum">    2313 </span>            :       /* Typedef.  Stop unless it's invisible, or if it is a typedef that</a>
<a name="2314"><span class="lineNum">    2314 </span>            :          should be dropped in diagnostic output. */</a>
<a name="2315"><span class="lineNum">    2315 </span><span class="lineCov">         40 :       if (!typedef_is_invisible(type, suppress_const, octl) &amp;&amp;</span></a>
<a name="2316"><span class="lineNum">    2316 </span><span class="lineCov">         40 :           !is_member_typedef_that_should_be_ignored(type, octl)) {</span></a>
<a name="2317"><span class="lineNum">    2317 </span>            :         break;</a>
<a name="2318"><span class="lineNum">    2318 </span>            :       }  /* if */</a>
<a name="2319"><span class="lineNum">    2319 </span><span class="lineCov">          1 :     } else if (is_type_operator_to_be_rendered(type, octl)) {</span></a>
<a name="2320"><span class="lineNum">    2320 </span>            :       /* A decltype or typeof operator that should be rendered in its</a>
<a name="2321"><span class="lineNum">    2321 </span>            :          original form (instead of rendering the underlying type). */</a>
<a name="2322"><span class="lineNum">    2322 </span>            :       break;</a>
<a name="2323"><span class="lineNum">    2323 </span>            :     } else {</a>
<a name="2324"><span class="lineNum">    2324 </span>            :       /* Type qualifier typeref.  Accumulate the qualifiers. */</a>
<a name="2325"><span class="lineNum">    2325 </span><span class="lineCov">          1 :       qualifiers |= type-&gt;variant.typeref.qualifiers;</span></a>
<a name="2326"><span class="lineNum">    2326 </span>            :       /* If we're supposed to suppress &quot;const&quot; and this typeref has it, we</a>
<a name="2327"><span class="lineNum">    2327 </span>            :          can take care of the suppression now.  This has to be done inside</a>
<a name="2328"><span class="lineNum">    2328 </span>            :          the loop because the &quot;typedef_is_invisible&quot; test uses the</a>
<a name="2329"><span class="lineNum">    2329 </span>            :          suppress_const flag. */</a>
<a name="2330"><span class="lineNum">    2330 </span><span class="lineCov">          1 :       if (suppress_const &amp;&amp; (qualifiers &amp; TQ_CONST)) {</span></a>
<a name="2331"><span class="lineNum">    2331 </span><span class="lineNoCov">          0 :         qualifiers &amp;= ~TQ_CONST;</span></a>
<a name="2332"><span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         suppress_const = FALSE;</span></a>
<a name="2333"><span class="lineNum">    2333 </span>            :       }  /* if */</a>
<a name="2334"><span class="lineNum">    2334 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="2335"><span class="lineNum">    2335 </span><span class="lineCov">          1 :       if (type-&gt;variant.typeref.qualifiers &amp; TQ_UPC_SHARED) {</span></a>
<a name="2336"><span class="lineNum">    2336 </span><span class="lineNoCov">          0 :         upc_block_size = type-&gt;variant.typeref.extra_info-&gt;upc_block_size;</span></a>
<a name="2337"><span class="lineNum">    2337 </span>            :       }  /* if */</a>
<a name="2338"><span class="lineNum">    2338 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="2339"><span class="lineNum">    2339 </span><span class="lineCov">          1 :       if (type-&gt;variant.typeref.for_type_attributes) {</span></a>
<a name="2340"><span class="lineNum">    2340 </span>            :         /* The underlying type was modified with an attribute.  Record</a>
<a name="2341"><span class="lineNum">    2341 </span>            :            the target of the typeref as the end of the typeref chain for</a>
<a name="2342"><span class="lineNum">    2342 </span>            :            output_type_attributes. */</a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineNoCov">          0 :         attrib_stop_type = type-&gt;variant.typeref.type;</span></a>
<a name="2344"><span class="lineNum">    2344 </span>            :       }  /* if */</a>
<a name="2345"><span class="lineNum">    2345 </span>            :     }  /* if */</a>
<a name="2346"><span class="lineNum">    2346 </span><span class="lineCov">         23 :     type = type-&gt;variant.typeref.type;</span></a>
<a name="2347"><span class="lineNum">    2347 </span>            :   }  /* while */</a>
<a name="2348"><span class="lineNum">    2348 </span>            :   /* Add top-level qualifiers if told to. */</a>
<a name="2349"><span class="lineNum">    2349 </span><span class="lineCov">         54 :   qualifiers |= added_qualifiers;</span></a>
<a name="2350"><span class="lineNum">    2350 </span>            : #if NEAR_AND_FAR_ALLOWED</a>
<a name="2351"><span class="lineNum">    2351 </span>            :   /* Look for any qualifiers (like &quot;near&quot;) that are displayed specially. */</a>
<a name="2352"><span class="lineNum">    2352 </span>            :   near_and_far_qualifiers = qualifiers &amp; (TQ_NEAR | TQ_FAR);</a>
<a name="2353"><span class="lineNum">    2353 </span>            :   if (near_and_far_qualifiers != TQ_NONE) {</a>
<a name="2354"><span class="lineNum">    2354 </span>            :     qualifiers -= near_and_far_qualifiers;</a>
<a name="2355"><span class="lineNum">    2355 </span>            :     near_and_far_need_trailing_space = need_trailing_space;</a>
<a name="2356"><span class="lineNum">    2356 </span>            :     need_trailing_space = TRUE;</a>
<a name="2357"><span class="lineNum">    2357 </span>            :   }  /* if */</a>
<a name="2358"><span class="lineNum">    2358 </span>            : #endif /* NEAR_AND_FAR_ALLOWED */</a>
<a name="2359"><span class="lineNum">    2359 </span><span class="lineCov">         54 :   kind = type-&gt;kind;</span></a>
<a name="2360"><span class="lineNum">    2360 </span><span class="lineCov">         54 :   if (kind == (a_type_kind)tk_pointer</span></a>
<a name="2361"><span class="lineNum">    2361 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2362"><span class="lineNum">    2362 </span>            :       /* C++/CLI interior_ptr and pin_ptr are handled as specifier types. */</a>
<a name="2363"><span class="lineNum">    2363 </span>            :       &amp;&amp; !type-&gt;variant.pointer.is_interior_ptr</a>
<a name="2364"><span class="lineNum">    2364 </span>            :       &amp;&amp; !type-&gt;variant.pointer.is_pin_ptr</a>
<a name="2365"><span class="lineNum">    2365 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2366"><span class="lineNum">    2366 </span>            :                                           ) {</a>
<a name="2367"><span class="lineNum">    2367 </span>            :     /* Pointer or reference type. */</a>
<a name="2368"><span class="lineNum">    2368 </span><span class="lineCov">          3 :     form_type_first_part(type-&gt;variant.pointer.type,</span></a>
<a name="2369"><span class="lineNum">    2369 </span>            :                          /*under_lhs_declarator=*/TRUE,</a>
<a name="2370"><span class="lineNum">    2370 </span>            :                          /*need_trailing_space=*/TRUE,</a>
<a name="2371"><span class="lineNum">    2371 </span>            :                          TQ_NONE, options, octl);</a>
<a name="2372"><span class="lineNum">    2372 </span>            :     /* Output &quot;*&quot; or &quot;&amp;&quot; for pointer or reference. */</a>
<a name="2373"><span class="lineNum">    2373 </span>            :     /* Or, &quot;^&quot; or &quot;%&quot; for C++/CLI handles and references. */</a>
<a name="2374"><span class="lineNum">    2374 </span><span class="lineCov">          3 :     if (type-&gt;variant.pointer.is_reference &amp;&amp; !octl-&gt;c_generating_back_end) {</span></a>
<a name="2375"><span class="lineNum">    2375 </span><span class="lineCov">          1 :       if (type-&gt;variant.pointer.is_rvalue_reference) {</span></a>
<a name="2376"><span class="lineNum">    2376 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&amp;&amp;&quot;, octl);</span></a>
<a name="2377"><span class="lineNum">    2377 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2378"><span class="lineNum">    2378 </span>            :       } else if (type-&gt;variant.pointer.is_handle) {</a>
<a name="2379"><span class="lineNum">    2379 </span>            :         octl-&gt;output_str(&quot;%&quot;, octl);</a>
<a name="2380"><span class="lineNum">    2380 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2381"><span class="lineNum">    2381 </span>            :       } else {</a>
<a name="2382"><span class="lineNum">    2382 </span><span class="lineCov">          1 :         octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="2383"><span class="lineNum">    2383 </span>            :       }  /* if */</a>
<a name="2384"><span class="lineNum">    2384 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2385"><span class="lineNum">    2385 </span>            :     } else if (type-&gt;variant.pointer.is_handle) {</a>
<a name="2386"><span class="lineNum">    2386 </span>            :       octl-&gt;output_str(&quot;^&quot;, octl);</a>
<a name="2387"><span class="lineNum">    2387 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2388"><span class="lineNum">    2388 </span>            :     } else {</a>
<a name="2389"><span class="lineNum">    2389 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2390"><span class="lineNum">    2390 </span>            :       if (type-&gt;variant.pointer.base_variable != NULL) {</a>
<a name="2391"><span class="lineNum">    2391 </span>            :         /* This is a Microsoft based pointer -- add &quot;__based(var-name) &quot;</a>
<a name="2392"><span class="lineNum">    2392 </span>            :            before the asterisk. */</a>
<a name="2393"><span class="lineNum">    2393 </span>            :         octl-&gt;output_str(&quot;__based(&quot;, octl);</a>
<a name="2394"><span class="lineNum">    2394 </span>            :         form_name(&amp;type-&gt;variant.pointer.base_variable-&gt;source_corresp,</a>
<a name="2395"><span class="lineNum">    2395 </span>            :                   iek_variable, octl);</a>
<a name="2396"><span class="lineNum">    2396 </span>            :         octl-&gt;output_str(&quot;) &quot;, octl);</a>
<a name="2397"><span class="lineNum">    2397 </span>            :       }  /* if */</a>
<a name="2398"><span class="lineNum">    2398 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2399"><span class="lineNum">    2399 </span><span class="lineCov">          2 :       octl-&gt;output_str(&quot;*&quot;, octl);</span></a>
<a name="2400"><span class="lineNum">    2400 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2401"><span class="lineNum">    2401 </span>            :       if (type-&gt;has_microsoft_w64_specifier &amp;&amp;</a>
<a name="2402"><span class="lineNum">    2402 </span>            :           !(octl-&gt;gen_compilable_code &amp;&amp; octl-&gt;c_generating_back_end)) {</a>
<a name="2403"><span class="lineNum">    2403 </span>            :         /* Do not propagate the &quot;__w64&quot; specifier to the C-generating back</a>
<a name="2404"><span class="lineNum">    2404 </span>            :            end. */</a>
<a name="2405"><span class="lineNum">    2405 </span>            :         octl-&gt;output_str(&quot;__w64&quot;, octl);</a>
<a name="2406"><span class="lineNum">    2406 </span>            :         if (need_trailing_space || qualifiers != TQ_NONE ||</a>
<a name="2407"><span class="lineNum">    2407 </span>            :             type-&gt;variant.pointer.modifiers != PM_NONE) {</a>
<a name="2408"><span class="lineNum">    2408 </span>            :           octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="2409"><span class="lineNum">    2409 </span>            :         }  /* if */</a>
<a name="2410"><span class="lineNum">    2410 </span>            :       }  /* if */</a>
<a name="2411"><span class="lineNum">    2411 </span>            :       if (type-&gt;variant.pointer.modifiers != PM_NONE) {</a>
<a name="2412"><span class="lineNum">    2412 </span>            :         form_pointer_modifiers(type-&gt;variant.pointer.modifiers, octl);</a>
<a name="2413"><span class="lineNum">    2413 </span>            :         if (need_trailing_space || qualifiers != TQ_NONE) {</a>
<a name="2414"><span class="lineNum">    2414 </span>            :           octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="2415"><span class="lineNum">    2415 </span>            :         }  /* if */</a>
<a name="2416"><span class="lineNum">    2416 </span>            :       }  /* if */</a>
<a name="2417"><span class="lineNum">    2417 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2418"><span class="lineNum">    2418 </span>            :     }  /* if */</a>
<a name="2419"><span class="lineNum">    2419 </span>            :     /* Output the type qualifiers on the pointer, if any. */</a>
<a name="2420"><span class="lineNum">    2420 </span><span class="lineCov">          3 :     if (qualifiers != TQ_NONE) {</span></a>
<a name="2421"><span class="lineNum">    2421 </span><span class="lineNoCov">          0 :       form_type_qualifier(qualifiers, upc_block_size, need_trailing_space,</span></a>
<a name="2422"><span class="lineNum">    2422 </span>            :                           octl);</a>
<a name="2423"><span class="lineNum">    2423 </span>            :     }  /* if */</a>
<a name="2424"><span class="lineNum">    2424 </span><span class="lineCov">          3 :     if (attrib_stop_type != orig_type) {</span></a>
<a name="2425"><span class="lineNum">    2425 </span><span class="lineNoCov">          0 :       output_type_attributes(orig_type, attrib_stop_type, octl);</span></a>
<a name="2426"><span class="lineNum">    2426 </span>            :     }  /* if */</a>
<a name="2427"><span class="lineNum">    2427 </span><span class="lineCov">         51 :   } else if (kind == (a_type_kind)tk_ptr_to_member) {</span></a>
<a name="2428"><span class="lineNum">    2428 </span>            :     /* Pointer-to-member type. */</a>
<a name="2429"><span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     form_type_first_part(type-&gt;variant.ptr_to_member.type,</span></a>
<a name="2430"><span class="lineNum">    2430 </span>            :                          /*under_lhs_declarator=*/TRUE,</a>
<a name="2431"><span class="lineNum">    2431 </span>            :                          /*need_trailing_space=*/TRUE,</a>
<a name="2432"><span class="lineNum">    2432 </span>            :                          TQ_NONE, options, octl);</a>
<a name="2433"><span class="lineNum">    2433 </span>            :     /* Output Classname::*. */</a>
<a name="2434"><span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="2435"><span class="lineNum">    2435 </span><span class="lineNoCov">          0 :         type-&gt;variant.ptr_to_member.type-&gt;kind != (a_type_kind)tk_routine &amp;&amp;</span></a>
<a name="2436"><span class="lineNum">    2436 </span><span class="lineNoCov">          0 :         !octl-&gt;suppress_ptr_to_data_member_parens) {</span></a>
<a name="2437"><span class="lineNum">    2437 </span>            :       /* The class name might be put out as a qualified name with a leading</a>
<a name="2438"><span class="lineNum">    2438 </span>            :          &quot;::&quot;, so the declarator must be enclosed in parentheses to prevent</a>
<a name="2439"><span class="lineNum">    2439 </span>            :          something like &quot;T (::C::*p)&quot; from being interpreted as &quot;T::C::*p&quot;.</a>
<a name="2440"><span class="lineNum">    2440 </span>            :          If the type is a pointer to member function, the parentheses will</a>
<a name="2441"><span class="lineNum">    2441 </span>            :          be put out automatically because of the declarator operator</a>
<a name="2442"><span class="lineNum">    2442 </span>            :          precedence, but we need to supply the &quot;(&quot; here explicitly in the</a>
<a name="2443"><span class="lineNum">    2443 </span>            :          pointer to data member case.  The matching &quot;)&quot; will be put out in</a>
<a name="2444"><span class="lineNum">    2444 </span>            :          form_type_second_part. */</a>
<a name="2445"><span class="lineNum">    2445 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="2446"><span class="lineNum">    2446 </span>            :     }  /* if */</a>
<a name="2447"><span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     form_class_qualifier(type-&gt;variant.ptr_to_member.class_of_which_a_member,</span></a>
<a name="2448"><span class="lineNum">    2448 </span><span class="lineNoCov">          0 :                          type-&gt;variant.ptr_to_member.type-&gt;kind !=</span></a>
<a name="2449"><span class="lineNum">    2449 </span>            :                                                        (a_type_kind)tk_routine,</a>
<a name="2450"><span class="lineNum">    2450 </span>            :                          octl);</a>
<a name="2451"><span class="lineNum">    2451 </span>            :     /* form_class_qualifier put out &quot;::&quot;.  Add the final &quot;*&quot; here.  That's</a>
<a name="2452"><span class="lineNum">    2452 </span>            :        okay; it's a separate token. */</a>
<a name="2453"><span class="lineNum">    2453 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;*&quot;, octl);</span></a>
<a name="2454"><span class="lineNum">    2454 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2455"><span class="lineNum">    2455 </span>            :     if (type-&gt;variant.ptr_to_member.modifiers != PM_NONE) {</a>
<a name="2456"><span class="lineNum">    2456 </span>            :       form_pointer_modifiers(type-&gt;variant.ptr_to_member.modifiers, octl);</a>
<a name="2457"><span class="lineNum">    2457 </span>            :       if (need_trailing_space || qualifiers != TQ_NONE) {</a>
<a name="2458"><span class="lineNum">    2458 </span>            :         octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="2459"><span class="lineNum">    2459 </span>            :       }  /* if */</a>
<a name="2460"><span class="lineNum">    2460 </span>            :     }  /* if */</a>
<a name="2461"><span class="lineNum">    2461 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2462"><span class="lineNum">    2462 </span>            :     /* Output the type qualifiers on the pointer, if any. */</a>
<a name="2463"><span class="lineNum">    2463 </span><span class="lineNoCov">          0 :     if (qualifiers != TQ_NONE) {</span></a>
<a name="2464"><span class="lineNum">    2464 </span><span class="lineNoCov">          0 :       form_type_qualifier(qualifiers, upc_block_size, need_trailing_space,</span></a>
<a name="2465"><span class="lineNum">    2465 </span>            :                           octl);</a>
<a name="2466"><span class="lineNum">    2466 </span>            :     }  /* if */</a>
<a name="2467"><span class="lineNum">    2467 </span><span class="lineNoCov">          0 :     if (attrib_stop_type != orig_type) {</span></a>
<a name="2468"><span class="lineNum">    2468 </span><span class="lineNoCov">          0 :       output_type_attributes(orig_type, attrib_stop_type, octl);</span></a>
<a name="2469"><span class="lineNum">    2469 </span>            :     }  /* if */</a>
<a name="2470"><span class="lineNum">    2470 </span><span class="lineCov">         51 :   } else if (kind == (a_type_kind)tk_routine) {</span></a>
<a name="2471"><span class="lineNum">    2471 </span>            :     /* Function type. */</a>
<a name="2472"><span class="lineNum">    2472 </span><span class="lineCov">          5 :     a_boolean                  is_lambda = is_lambda_body_routine_type(type);</span></a>
<a name="2473"><span class="lineNum">    2473 </span><span class="lineCov">          5 :     a_boolean                  is_deduction_guide = FALSE;</span></a>
<a name="2474"><span class="lineNum">    2474 </span><span class="lineCov">          5 :     a_routine_type_supplement  *rtsp = type-&gt;variant.routine.extra_info;</span></a>
<a name="2475"><span class="lineNum">    2475 </span>            :     /* A qualifier on a function type shouldn't be possible in compilable</a>
<a name="2476"><span class="lineNum">    2476 </span>            :        code without a typedef; however, it shouldn't be a fatal error in</a>
<a name="2477"><span class="lineNum">    2477 </span>            :        diagnostic or debugging output. */</a>
<a name="2478"><span class="lineNum">    2478 </span><span class="lineCov">          5 :     check_assertion_str(qualifiers == TQ_NONE || !octl-&gt;gen_compilable_code,</span></a>
<a name="2479"><span class="lineNum">    2479 </span><span class="lineCov">          5 :                         &quot;form_type_first_part: qualifier on function type&quot;);</span></a>
<a name="2480"><span class="lineNum">    2480 </span><span class="lineCov">          5 :     if (rtsp-&gt;assoc_routine != NULL &amp;&amp;</span></a>
<a name="2481"><span class="lineNum">    2481 </span><span class="lineCov">          5 :         special_kind_is(rtsp-&gt;assoc_routine, sfk_deduction_guide)) {</span></a>
<a name="2482"><span class="lineNum">    2482 </span><span class="lineNoCov">          0 :       is_deduction_guide = TRUE;</span></a>
<a name="2483"><span class="lineNum">    2483 </span>            :     }  /* if */</a>
<a name="2484"><span class="lineNum">    2484 </span><span class="lineCov">          5 :     if ((rtsp-&gt;trailing_return_type || is_lambda || is_deduction_guide) &amp;&amp;</span></a>
<a name="2485"><span class="lineNum">    2485 </span><span class="lineNoCov">          0 :         !octl-&gt;c_generating_back_end) {</span></a>
<a name="2486"><span class="lineNum">    2486 </span>            :       /* For a routine type specified with a trailing return type, the </a>
<a name="2487"><span class="lineNum">    2487 </span>            :          type specifiers are simply &quot;auto&quot;, except for lambda expressions</a>
<a name="2488"><span class="lineNum">    2488 </span>            :          where the specifiers are omitted altogether.  (The C-generating back</a>
<a name="2489"><span class="lineNum">    2489 </span>            :          end does not attempt to render routine types with trailing return</a>
<a name="2490"><span class="lineNum">    2490 </span>            :          types, since those are a C++ feature.)   Deduction guides have</a>
<a name="2491"><span class="lineNum">    2491 </span>            :          trailing return types, but don't use the &quot;auto&quot; keyword. */</a>
<a name="2492"><span class="lineNum">    2492 </span><span class="lineNoCov">          0 :       if (!is_lambda &amp;&amp; !is_deduction_guide &amp;&amp;</span></a>
<a name="2493"><span class="lineNum">    2493 </span><span class="lineNoCov">          0 :           !(options &amp; FTO_SUPPRESS_SPECIFIERS)) {</span></a>
<a name="2494"><span class="lineNum">    2494 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;auto &quot;, octl);</span></a>
<a name="2495"><span class="lineNum">    2495 </span>            :       }  /* if */</a>
<a name="2496"><span class="lineNum">    2496 </span>            :     } else {</a>
<a name="2497"><span class="lineNum">    2497 </span><span class="lineCov">          5 :       form_type_first_part(type-&gt;variant.routine.return_type,</span></a>
<a name="2498"><span class="lineNum">    2498 </span>            :                            /*under_lhs_declarator=*/FALSE,</a>
<a name="2499"><span class="lineNum">    2499 </span>            :                            /*need_trailing_space=*/TRUE,</a>
<a name="2500"><span class="lineNum">    2500 </span>            :                            TQ_NONE, options, octl);</a>
<a name="2501"><span class="lineNum">    2501 </span>            :     }  /* if */</a>
<a name="2502"><span class="lineNum">    2502 </span>            :     /* This is a right-side declarator, so if it's under a left-side</a>
<a name="2503"><span class="lineNum">    2503 </span>            :        declarator parentheses are needed. */</a>
<a name="2504"><span class="lineNum">    2504 </span><span class="lineCov">          5 :     if (under_lhs_declarator) {</span></a>
<a name="2505"><span class="lineNum">    2505 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="2506"><span class="lineNum">    2506 </span><span class="lineNoCov">          0 :       output_predeclarator_attributes(type, octl);</span></a>
<a name="2507"><span class="lineNum">    2507 </span>            :     }  /* if */</a>
<a name="2508"><span class="lineNum">    2508 </span><span class="lineCov">          5 :     if (qualifiers != TQ_NONE) {</span></a>
<a name="2509"><span class="lineNum">    2509 </span>            :       /* As noted above, qualifiers cannot appear in compilable code, only</a>
<a name="2510"><span class="lineNum">    2510 </span>            :          in diagnostic and debugging output. */</a>
<a name="2511"><span class="lineNum">    2511 </span><span class="lineNoCov">          0 :       form_type_qualifier(qualifiers, upc_block_size, need_trailing_space,</span></a>
<a name="2512"><span class="lineNum">    2512 </span>            :                           octl);</a>
<a name="2513"><span class="lineNum">    2513 </span>            :     }  /* if */</a>
<a name="2514"><span class="lineNum">    2514 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2515"><span class="lineNum">    2515 </span>            :     /* A calling convention specifier is put out as a left-hand-side</a>
<a name="2516"><span class="lineNum">    2516 </span>            :        declarator. */</a>
<a name="2517"><span class="lineNum">    2517 </span>            :     if (rtsp-&gt;explicit_calling_convention) {</a>
<a name="2518"><span class="lineNum">    2518 </span>            :       form_calling_convention(rtsp-&gt;calling_convention, octl);</a>
<a name="2519"><span class="lineNum">    2519 </span>            :     }  /* if */</a>
<a name="2520"><span class="lineNum">    2520 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2521"><span class="lineNum">    2521 </span><span class="lineCov">         46 :   } else if (kind == (a_type_kind)tk_array) {</span></a>
<a name="2522"><span class="lineNum">    2522 </span>            :     /* Array type. */</a>
<a name="2523"><span class="lineNum">    2523 </span>            :     /* A qualifier on an array type shouldn't be possible, period. */</a>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineNoCov">          0 :     check_assertion_str(qualifiers == TQ_NONE,</span></a>
<a name="2525"><span class="lineNum">    2525 </span><span class="lineNoCov">          0 :                         &quot;form_type_first_part: qualifier on array type&quot;);</span></a>
<a name="2526"><span class="lineNum">    2526 </span><span class="lineNoCov">          0 :     if (can_use_qualified_array_typedef(&amp;type, &amp;qualifiers, suppress_const,</span></a>
<a name="2527"><span class="lineNum">    2527 </span>            :                                         octl)) {</a>
<a name="2528"><span class="lineNum">    2528 </span>            :       /* This array type was generated by applying a type qualifier to</a>
<a name="2529"><span class="lineNum">    2529 </span>            :          a typedef of an array type.  Use the typedef. */</a>
<a name="2530"><span class="lineNum">    2530 </span><span class="lineNoCov">          0 :       goto handle_specifiers_type;</span></a>
<a name="2531"><span class="lineNum">    2531 </span>            :     }  /* if */</a>
<a name="2532"><span class="lineNum">    2532 </span><span class="lineNoCov">          0 :     if (suppress_const) options |= FTO_SUPPRESS_CONST;</span></a>
<a name="2533"><span class="lineNum">    2533 </span><span class="lineNoCov">          0 :     form_type_first_part(type-&gt;variant.array.element_type,</span></a>
<a name="2534"><span class="lineNum">    2534 </span>            :                          /*under_lhs_declarator=*/FALSE,</a>
<a name="2535"><span class="lineNum">    2535 </span>            :                          /*need_trailing_space=*/TRUE,</a>
<a name="2536"><span class="lineNum">    2536 </span>            :                          TQ_NONE,</a>
<a name="2537"><span class="lineNum">    2537 </span>            :                          options,</a>
<a name="2538"><span class="lineNum">    2538 </span>            :                          octl);</a>
<a name="2539"><span class="lineNum">    2539 </span>            :     /* This is a right-side declarator, so if it's under a left-side</a>
<a name="2540"><span class="lineNum">    2540 </span>            :        declarator parentheses are needed. */</a>
<a name="2541"><span class="lineNum">    2541 </span><span class="lineNoCov">          0 :     if (under_lhs_declarator) {</span></a>
<a name="2542"><span class="lineNum">    2542 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="2543"><span class="lineNum">    2543 </span><span class="lineNoCov">          0 :       output_predeclarator_attributes(type, octl);</span></a>
<a name="2544"><span class="lineNum">    2544 </span>            :     }  /* if */</a>
<a name="2545"><span class="lineNum">    2545 </span>            :   } else {</a>
<a name="2546"><span class="lineNum">    2546 </span><span class="lineCov">         46 : handle_specifiers_type:</span></a>
<a name="2547"><span class="lineNum">    2547 </span>            :     /* No declarator part to process.  Handle the specifier type. */</a>
<a name="2548"><span class="lineNum">    2548 </span><span class="lineCov">         46 :     if ((options &amp; FTO_SUPPRESS_SPECIFIERS) == 0) {</span></a>
<a name="2549"><span class="lineNum">    2549 </span><span class="lineCov">         46 :       a_boolean  c11_atomic = FALSE;</span></a>
<a name="2550"><span class="lineNum">    2550 </span><span class="lineCov">         46 :       if (qualifiers != TQ_NONE) {</span></a>
<a name="2551"><span class="lineNum">    2551 </span><span class="lineCov">          1 :         if (qualifiers &amp; TQ_C11_ATOMIC) {</span></a>
<a name="2552"><span class="lineNum">    2552 </span>            :           /* We should be able to emit _Atomic like other type qualifiers, but</a>
<a name="2553"><span class="lineNum">    2553 </span>            :              early Clang versions only accepted the &quot;_Atomic(T)&quot; form; not</a>
<a name="2554"><span class="lineNum">    2554 </span>            :              &quot;_Atomic T&quot;.  We therefore handle TQ_C11_ATOMIC separately. */</a>
<a name="2555"><span class="lineNum">    2555 </span><span class="lineNoCov">          0 :           c11_atomic = TRUE;</span></a>
<a name="2556"><span class="lineNum">    2556 </span><span class="lineNoCov">          0 :           qualifiers &amp;= ~TQ_C11_ATOMIC;</span></a>
<a name="2557"><span class="lineNum">    2557 </span>            :         }  /* if */</a>
<a name="2558"><span class="lineNum">    2558 </span><span class="lineCov">          1 :         form_type_qualifier(qualifiers, upc_block_size,</span></a>
<a name="2559"><span class="lineNum">    2559 </span>            :                             /*need_trailing_space=*/TRUE, octl);</a>
<a name="2560"><span class="lineNum">    2560 </span><span class="lineCov">          1 :         if (c11_atomic) {</span></a>
<a name="2561"><span class="lineNum">    2561 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;_Atomic(&quot;, octl);</span></a>
<a name="2562"><span class="lineNum">    2562 </span>            :         }  /* if */</a>
<a name="2563"><span class="lineNum">    2563 </span>            :       }  /* if */</a>
<a name="2564"><span class="lineNum">    2564 </span><span class="lineCov">         46 :       form_type_specifier(type, octl);</span></a>
<a name="2565"><span class="lineNum">    2565 </span><span class="lineCov">         46 :       if (c11_atomic) {</span></a>
<a name="2566"><span class="lineNum">    2566 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="2567"><span class="lineNum">    2567 </span>            :       }  /* if */</a>
<a name="2568"><span class="lineNum">    2568 </span><span class="lineCov">         46 :       if (attrib_stop_type != orig_type) {</span></a>
<a name="2569"><span class="lineNum">    2569 </span><span class="lineNoCov">          0 :         output_type_attributes(orig_type, attrib_stop_type, octl);</span></a>
<a name="2570"><span class="lineNum">    2570 </span>            :       }  /* if */</a>
<a name="2571"><span class="lineNum">    2571 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2572"><span class="lineNum">    2572 </span>            :       if (type-&gt;has_microsoft_w64_specifier &amp;&amp;</a>
<a name="2573"><span class="lineNum">    2573 </span>            :           !(octl-&gt;gen_compilable_code &amp;&amp; octl-&gt;c_generating_back_end)) {</a>
<a name="2574"><span class="lineNum">    2574 </span>            :         /* Do not propagate the &quot;__w64&quot; specifier to the C-generating back</a>
<a name="2575"><span class="lineNum">    2575 </span>            :            end. */</a>
<a name="2576"><span class="lineNum">    2576 </span>            :         octl-&gt;output_str(&quot; __w64&quot;, octl);</a>
<a name="2577"><span class="lineNum">    2577 </span>            :       }  /* if */</a>
<a name="2578"><span class="lineNum">    2578 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2579"><span class="lineNum">    2579 </span><span class="lineCov">         92 :       if (has_predeclarator_attribute(orig_type)) {</span></a>
<a name="2580"><span class="lineNum">    2580 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; (&quot;, octl);</span></a>
<a name="2581"><span class="lineNum">    2581 </span><span class="lineNoCov">          0 :         output_predeclarator_attributes(orig_type, octl);</span></a>
<a name="2582"><span class="lineNum">    2582 </span>            :       }  /* if */</a>
<a name="2583"><span class="lineNum">    2583 </span>            :       /* Put out a trailing space if required. */</a>
<a name="2584"><span class="lineNum">    2584 </span><span class="lineCov">         46 :       if (need_trailing_space) octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="2585"><span class="lineNum">    2585 </span>            :     }  /* if */</a>
<a name="2586"><span class="lineNum">    2586 </span>            :   }  /* if */</a>
<a name="2587"><span class="lineNum">    2587 </span>            : #if NEAR_AND_FAR_ALLOWED</a>
<a name="2588"><span class="lineNum">    2588 </span>            :   if (near_and_far_qualifiers != TQ_NONE) {</a>
<a name="2589"><span class="lineNum">    2589 </span>            :     /* &quot;near&quot; or &quot;far&quot;: display it next to the declarator name. */</a>
<a name="2590"><span class="lineNum">    2590 </span>            :     form_type_qualifier(near_and_far_qualifiers, upc_block_size,</a>
<a name="2591"><span class="lineNum">    2591 </span>            :                         near_and_far_need_trailing_space, octl);</a>
<a name="2592"><span class="lineNum">    2592 </span>            :   }  /* if */</a>
<a name="2593"><span class="lineNum">    2593 </span>            : #endif /* NEAR_AND_FAR_ALLOWED */</a>
<a name="2594"><span class="lineNum">    2594 </span><span class="lineCov">         39 : end_of_routine:;</span></a>
<a name="2595"><span class="lineNum">    2595 </span><span class="lineCov">         54 : }  /* form_type_first_part */</span></a>
<a name="2596"><span class="lineNum">    2596 </span>            : </a>
<a name="2597"><span class="lineNum">    2597 </span>            : </a>
<a name="2598"><span class="lineNum">    2598 </span>            : static</a>
<a name="2599"><span class="lineNum">    2599 </span>            : void form_exception_specification(a_type_ptr                            type,</a>
<a name="2600"><span class="lineNum">    2600 </span>            :                                   an_il_to_str_output_control_block_ptr octl)</a>
<a name="2601"><span class="lineNum">    2601 </span>            : /*</a>
<a name="2602"><span class="lineNum">    2602 </span>            : Output the exception specification (as can appear after a function declarator),</a>
<a name="2603"><span class="lineNum">    2603 </span>            : if any, recorded in the given routine type in the way described by octl.</a>
<a name="2604"><span class="lineNum">    2604 </span>            : */</a>
<a name="2605"><span class="lineNum">    2605 </span>            : {</a>
<a name="2606"><span class="lineNum">    2606 </span>            :   an_exception_specification_ptr  esp;</a>
<a name="2607"><span class="lineNum">    2607 </span>            : </a>
<a name="2608"><span class="lineNum">    2608 </span>            :   esp = type-&gt;variant.routine.extra_info-&gt;exception_specification;</a>
<a name="2609"><span class="lineNum">    2609 </span>            :   if (esp == NULL || esp-&gt;throw_any) {</a>
<a name="2610"><span class="lineNum">    2610 </span>            :     /* Nothing to output. */</a>
<a name="2611"><span class="lineNum">    2611 </span>            :   } else if (esp-&gt;is_noexcept) {</a>
<a name="2612"><span class="lineNum">    2612 </span>            :     octl-&gt;output_str(&quot; noexcept&quot;, octl);</a>
<a name="2613"><span class="lineNum">    2613 </span>            :     if (esp-&gt;arg_cached) {</a>
<a name="2614"><span class="lineNum">    2614 </span>            :       octl-&gt;output_str(&quot;(&lt;expr&gt;)&quot;, octl);</a>
<a name="2615"><span class="lineNum">    2615 </span>            :     } else if (esp-&gt;variant.noexcept_arg != NULL) {</a>
<a name="2616"><span class="lineNum">    2616 </span>            :       octl-&gt;output_str(&quot;(&quot;, octl);</a>
<a name="2617"><span class="lineNum">    2617 </span>            :       form_constant(esp-&gt;variant.noexcept_arg, /*need_parens=*/FALSE, octl);</a>
<a name="2618"><span class="lineNum">    2618 </span>            :       octl-&gt;output_str(&quot;)&quot;, octl);</a>
<a name="2619"><span class="lineNum">    2619 </span>            :     }  /* if */</a>
<a name="2620"><span class="lineNum">    2620 </span>            :   } else {</a>
<a name="2621"><span class="lineNum">    2621 </span>            :     an_exception_specification_type_ptr  estp;</a>
<a name="2622"><span class="lineNum">    2622 </span>            :     estp = esp-&gt;variant.exception_specification_type_list;</a>
<a name="2623"><span class="lineNum">    2623 </span>            :     octl-&gt;output_str(&quot; throw(&quot;, octl);</a>
<a name="2624"><span class="lineNum">    2624 </span>            :     for (; estp != NULL; estp = estp-&gt;next) {</a>
<a name="2625"><span class="lineNum">    2625 </span>            :       form_type(estp-&gt;type, octl);</a>
<a name="2626"><span class="lineNum">    2626 </span>            :       if (estp-&gt;next != NULL) {</a>
<a name="2627"><span class="lineNum">    2627 </span>            :         octl-&gt;output_str(&quot;, &quot;, octl);</a>
<a name="2628"><span class="lineNum">    2628 </span>            :       }  /* if */</a>
<a name="2629"><span class="lineNum">    2629 </span>            :     }  /* for */</a>
<a name="2630"><span class="lineNum">    2630 </span>            :     octl-&gt;output_str(&quot;)&quot;, octl);</a>
<a name="2631"><span class="lineNum">    2631 </span>            :   }  /* if */</a>
<a name="2632"><span class="lineNum">    2632 </span>            : }  /* form_exception_specification */</a>
<a name="2633"><span class="lineNum">    2633 </span>            : </a>
<a name="2634"><span class="lineNum">    2634 </span>            : </a>
<a name="2635"><span class="lineNum">    2635 </span><span class="lineCov">          6 : void form_function_declarator(a_type_ptr                            type,</span></a>
<a name="2636"><span class="lineNum">    2636 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="2637"><span class="lineNum">    2637 </span>            : /*</a>
<a name="2638"><span class="lineNum">    2638 </span>            : Output a function declarator for the indicated routine type.  Do the output</a>
<a name="2639"><span class="lineNum">    2639 </span>            : in the way described by octl.</a>
<a name="2640"><span class="lineNum">    2640 </span>            : */</a>
<a name="2641"><span class="lineNum">    2641 </span>            : {</a>
<a name="2642"><span class="lineNum">    2642 </span><span class="lineCov">          6 :   a_routine_type_supplement_ptr rtsp = type-&gt;variant.routine.extra_info;</span></a>
<a name="2643"><span class="lineNum">    2643 </span><span class="lineCov">          6 :   a_param_type_ptr              param;</span></a>
<a name="2644"><span class="lineNum">    2644 </span>            : </a>
<a name="2645"><span class="lineNum">    2645 </span>            :   /* See if there's a special routine to output function declarators.</a>
<a name="2646"><span class="lineNum">    2646 </span>            :      If so, use it. */</a>
<a name="2647"><span class="lineNum">    2647 </span><span class="lineCov">          6 :   if (octl-&gt;output_func_declarator != NULL) {</span></a>
<a name="2648"><span class="lineNum">    2648 </span><span class="lineNoCov">          0 :     octl-&gt;output_func_declarator(type);</span></a>
<a name="2649"><span class="lineNum">    2649 </span>            :   } else {</a>
<a name="2650"><span class="lineNum">    2650 </span><span class="lineCov">          6 :     a_boolean            is_lambda = is_lambda_body_routine_type(type);</span></a>
<a name="2651"><span class="lineNum">    2651 </span><span class="lineCov">         12 :     a_type_qualifier_set qualifiers =</span></a>
<a name="2652"><span class="lineNum">    2652 </span><span class="lineCov">          8 :             rtsp-&gt;this_class != NULL ? rtsp-&gt;qualifiers | rtsp-&gt;this_qualifiers</span></a>
<a name="2653"><span class="lineNum">    2653 </span><span class="lineCov">          6 :                                      : TQ_NONE;</span></a>
<a name="2654"><span class="lineNum">    2654 </span>            :     /* Default processing. */</a>
<a name="2655"><span class="lineNum">    2655 </span><span class="lineCov">          6 :     octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="2656"><span class="lineNum">    2656 </span><span class="lineCov">          6 :     if ((!rtsp-&gt;prototyped || rtsp-&gt;old_style_params_scanned) &amp;&amp;</span></a>
<a name="2657"><span class="lineNum">    2657 </span><span class="lineNoCov">          0 :         (il_header.source_language != sl_Cplusplus ||</span></a>
<a name="2658"><span class="lineNum">    2658 </span><span class="lineNoCov">          0 :          octl-&gt;gen_compilable_code)) {</span></a>
<a name="2659"><span class="lineNum">    2659 </span>            :       /* Unprototyped function.  Put out nothing between the parentheses. */</a>
<a name="2660"><span class="lineNum">    2660 </span>            :       /* Note that in C++ the parameter types for old-style functions are</a>
<a name="2661"><span class="lineNum">    2661 </span>            :          listed when generating human-readable output. */</a>
<a name="2662"><span class="lineNum">    2662 </span>            :     } else {</a>
<a name="2663"><span class="lineNum">    2663 </span>            :       /* Prototyped list. */</a>
<a name="2664"><span class="lineNum">    2664 </span><span class="lineCov">          6 :       param = rtsp-&gt;param_type_list;</span></a>
<a name="2665"><span class="lineNum">    2665 </span><span class="lineCov">          6 :       if (param == NULL) {</span></a>
<a name="2666"><span class="lineNum">    2666 </span><span class="lineCov">          4 :         if (!rtsp-&gt;has_ellipsis) {</span></a>
<a name="2667"><span class="lineNum">    2667 </span>            :           /* The first argument is NULL, so this is a &quot;void&quot; parameter list.</a>
<a name="2668"><span class="lineNum">    2668 </span>            :              Write it as void in C, as empty in C++. */</a>
<a name="2669"><span class="lineNum">    2669 </span><span class="lineCov">          4 :           if (il_header.source_language == sl_C) {</span></a>
<a name="2670"><span class="lineNum">    2670 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;void&quot;, octl);</span></a>
<a name="2671"><span class="lineNum">    2671 </span>            :           }  /* if */</a>
<a name="2672"><span class="lineNum">    2672 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="2673"><span class="lineNum">    2673 </span>            : #if !ALLOW_ELLIPSIS_ONLY_PARAM_IN_GENERATED_C</a>
<a name="2674"><span class="lineNum">    2674 </span><span class="lineNoCov">          0 :         } else if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="2675"><span class="lineNum">    2675 </span><span class="lineNoCov">          0 :                    (octl-&gt;c_generating_back_end ||</span></a>
<a name="2676"><span class="lineNum">    2676 </span><span class="lineNoCov">          0 :                     il_header.source_language == sl_C)) {</span></a>
<a name="2677"><span class="lineNum">    2677 </span>            :           /* For the C-generating back end (or the C++-generating back end</a>
<a name="2678"><span class="lineNum">    2678 </span>            :              when it is producing C code), we put out the ellipsis by itself</a>
<a name="2679"><span class="lineNum">    2679 </span>            :              only if it can be handled.  Otherwise, &quot;(...)&quot; is rendered by</a>
<a name="2680"><span class="lineNum">    2680 </span>            :              &quot;()&quot; in the generated C. */</a>
<a name="2681"><span class="lineNum">    2681 </span>            : #endif /* !ALLOW_ELLIPSIS_ONLY_PARAM_IN_GENERATED_C */</a>
<a name="2682"><span class="lineNum">    2682 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="2683"><span class="lineNum">    2683 </span>            :         } else {</a>
<a name="2684"><span class="lineNum">    2684 </span>            :           /* This is a parameter list consisting of only an ellipsis, which</a>
<a name="2685"><span class="lineNum">    2685 </span>            :              is standard in C++ and may be accepted as an extension in C</a>
<a name="2686"><span class="lineNum">    2686 </span>            :              mode. */</a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;...&quot;, octl);</span></a>
<a name="2688"><span class="lineNum">    2688 </span>            :         }  /* if */</a>
<a name="2689"><span class="lineNum">    2689 </span>            :       } else {</a>
<a name="2690"><span class="lineNum">    2690 </span>            :         /* List the parameter types. */</a>
<a name="2691"><span class="lineNum">    2691 </span><span class="lineCov">          5 :         for (; param != NULL; param = param-&gt;next) {</span></a>
<a name="2692"><span class="lineNum">    2692 </span><span class="lineCov">          3 :           if (octl-&gt;suppress_compiler_generated_parameters &amp;&amp;</span></a>
<a name="2693"><span class="lineNum">    2693 </span><span class="lineNoCov">          0 :               param-&gt;param_num == 0) {</span></a>
<a name="2694"><span class="lineNum">    2694 </span>            :             /* This parameter was added by lowering and thus should not be</a>
<a name="2695"><span class="lineNum">    2695 </span>            :                put out. */</a>
<a name="2696"><span class="lineNum">    2696 </span>            :           } else {</a>
<a name="2697"><span class="lineNum">    2697 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2698"><span class="lineNum">    2698 </span>            :             if (param-&gt;is_cli_param_array) octl-&gt;output_str(&quot;... &quot;, octl);</a>
<a name="2699"><span class="lineNum">    2699 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2700"><span class="lineNum">    2700 </span><span class="lineCov">          3 :             form_type(param-&gt;type, octl);</span></a>
<a name="2701"><span class="lineNum">    2701 </span><span class="lineCov">          3 :             if (param-&gt;is_parameter_pack) octl-&gt;output_str(&quot;...&quot;, octl);</span></a>
<a name="2702"><span class="lineNum">    2702 </span>            :             /* Default argument expressions are not put out. */</a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">          3 :             if (param-&gt;next != NULL &amp;&amp;</span></a>
<a name="2704"><span class="lineNum">    2704 </span><span class="lineCov">          1 :                 !(octl-&gt;suppress_compiler_generated_parameters &amp;&amp;</span></a>
<a name="2705"><span class="lineNum">    2705 </span><span class="lineNoCov">          0 :                   param-&gt;next-&gt;param_num == 0)) {</span></a>
<a name="2706"><span class="lineNum">    2706 </span>            :               /* There is another unsuppressed parameter, so output a</a>
<a name="2707"><span class="lineNum">    2707 </span>            :                  separator. */</a>
<a name="2708"><span class="lineNum">    2708 </span><span class="lineCov">          1 :               octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="2709"><span class="lineNum">    2709 </span>            :             }  /* if */</a>
<a name="2710"><span class="lineNum">    2710 </span>            :           }  /* if */</a>
<a name="2711"><span class="lineNum">    2711 </span>            :         }  /* for */</a>
<a name="2712"><span class="lineNum">    2712 </span>            :         /* Put out the ellipsis if there is one. */</a>
<a name="2713"><span class="lineNum">    2713 </span><span class="lineCov">          2 :         if (rtsp-&gt;has_ellipsis) octl-&gt;output_str(&quot;, ...&quot;, octl);</span></a>
<a name="2714"><span class="lineNum">    2714 </span>            :       }  /* if */</a>
<a name="2715"><span class="lineNum">    2715 </span>            :     }  /* if */</a>
<a name="2716"><span class="lineNum">    2716 </span><span class="lineCov">          6 :     octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="2717"><span class="lineNum">    2717 </span>            :     /* If the function type has a linkage that's not compatible with the</a>
<a name="2718"><span class="lineNum">    2718 </span>            :        default, add the linkage string after the closing parenthesis.  This</a>
<a name="2719"><span class="lineNum">    2719 </span>            :        is done only for non-compilable code. */</a>
<a name="2720"><span class="lineNum">    2720 </span><span class="lineCov">          6 :     if (!octl-&gt;gen_compilable_code) {</span></a>
<a name="2721"><span class="lineNum">    2721 </span><span class="lineCov">          6 :       a_name_linkage_kind linkage = rtsp-&gt;routine_name_linkage;</span></a>
<a name="2722"><span class="lineNum">    2722 </span><span class="lineCov">          6 :       if (linkage != (a_name_linkage_kind)nlk_internal &amp;&amp;</span></a>
<a name="2723"><span class="lineNum">    2723 </span><span class="lineCov">          6 :           linkage != (a_name_linkage_kind)nlk_none &amp;&amp;</span></a>
<a name="2724"><span class="lineNum">    2724 </span><span class="lineCov">          6 :           !routine_linkages_are_compatible(linkage,</span></a>
<a name="2725"><span class="lineNum">    2725 </span>            :                                            default_routine_name_linkage,</a>
<a name="2726"><span class="lineNum">    2726 </span>            :                                            /*is_impl_conv=*/FALSE)) {</a>
<a name="2727"><span class="lineNum">    2727 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="2728"><span class="lineNum">    2728 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(name_linkage_kind_names[linkage], octl);</span></a>
<a name="2729"><span class="lineNum">    2729 </span>            :       }  /* if */</a>
<a name="2730"><span class="lineNum">    2730 </span>            :     } /* if */</a>
<a name="2731"><span class="lineNum">    2731 </span>            :     /* Output a cv-qualifier for a member function, if there is one.  For a</a>
<a name="2732"><span class="lineNum">    2732 </span>            :        lambda body, however, output &quot;mutable&quot; if the routine is not const. */</a>
<a name="2733"><span class="lineNum">    2733 </span><span class="lineCov">          6 :     if (is_lambda) {</span></a>
<a name="2734"><span class="lineNum">    2734 </span><span class="lineNoCov">          0 :       if ((qualifiers &amp; TQ_CONST) == 0) {</span></a>
<a name="2735"><span class="lineNum">    2735 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot; mutable&quot;, octl);</span></a>
<a name="2736"><span class="lineNum">    2736 </span>            :       } else {</a>
<a name="2737"><span class="lineNum">    2737 </span><span class="lineNoCov">          0 :         check_assertion(qualifiers == TQ_CONST);</span></a>
<a name="2738"><span class="lineNum">    2738 </span>            :       }  /* if */</a>
<a name="2739"><span class="lineNum">    2739 </span><span class="lineCov">          6 :     } else if (qualifiers != TQ_NONE) {</span></a>
<a name="2740"><span class="lineNum">    2740 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="2741"><span class="lineNum">    2741 </span><span class="lineNoCov">          0 :       form_type_qualifier(qualifiers, UPC_BLOCK_SIZE_NONE,</span></a>
<a name="2742"><span class="lineNum">    2742 </span>            :                          /*need_trailing_space=*/FALSE, octl);</a>
<a name="2743"><span class="lineNum">    2743 </span>            :     }  /* if */</a>
<a name="2744"><span class="lineNum">    2744 </span><span class="lineCov">          6 :     if (rtsp-&gt;ref_qualifiers == (a_ref_qualifier_kind)rqk_lvalue) {</span></a>
<a name="2745"><span class="lineNum">    2745 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &amp;&quot;, octl);</span></a>
<a name="2746"><span class="lineNum">    2746 </span><span class="lineCov">          6 :     } else if (rtsp-&gt;ref_qualifiers == (a_ref_qualifier_kind)rqk_rvalue) {</span></a>
<a name="2747"><span class="lineNum">    2747 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &amp;&amp;&quot;, octl);</span></a>
<a name="2748"><span class="lineNum">    2748 </span>            :     }  /* if */</a>
<a name="2749"><span class="lineNum">    2749 </span><span class="lineCov">          6 :     if ((rtsp-&gt;trailing_return_type || is_lambda) &amp;&amp;</span></a>
<a name="2750"><span class="lineNum">    2750 </span><span class="lineNoCov">          0 :         !octl-&gt;c_generating_back_end) {</span></a>
<a name="2751"><span class="lineNum">    2751 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;-&gt;&quot;, octl);</span></a>
<a name="2752"><span class="lineNum">    2752 </span><span class="lineNoCov">          0 :       form_type(type-&gt;variant.routine.return_type, octl);</span></a>
<a name="2753"><span class="lineNum">    2753 </span>            :     }  /* if */</a>
<a name="2754"><span class="lineNum">    2754 </span><span class="lineCov">          6 :     if (!octl-&gt;gen_compilable_code &amp;&amp; exc_spec_in_func_type) {</span></a>
<a name="2755"><span class="lineNum">    2755 </span><span class="lineNoCov">          0 :       form_exception_specification(type, octl);</span></a>
<a name="2756"><span class="lineNum">    2756 </span>            :     }  /* if */</a>
<a name="2757"><span class="lineNum">    2757 </span>            :   }  /* if */</a>
<a name="2758"><span class="lineNum">    2758 </span><span class="lineCov">          6 : }  /* form_function_declarator */</span></a>
<a name="2759"><span class="lineNum">    2759 </span>            : </a>
<a name="2760"><span class="lineNum">    2760 </span>            : </a>
<a name="2761"><span class="lineNum">    2761 </span><span class="lineNoCov">          0 : static void form_array_declarator(a_type_ptr                            type,</span></a>
<a name="2762"><span class="lineNum">    2762 </span>            :                                   an_il_to_str_output_control_block_ptr octl)</a>
<a name="2763"><span class="lineNum">    2763 </span>            : /*</a>
<a name="2764"><span class="lineNum">    2764 </span>            : Output an array declarator for the indicated array type.  Do the output in</a>
<a name="2765"><span class="lineNum">    2765 </span>            : the way described by octl.</a>
<a name="2766"><span class="lineNum">    2766 </span>            : */</a>
<a name="2767"><span class="lineNum">    2767 </span>            : {</a>
<a name="2768"><span class="lineNum">    2768 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;[&quot;, octl);</span></a>
<a name="2769"><span class="lineNum">    2769 </span><span class="lineNoCov">          0 :   form_type_qualifier(type-&gt;variant.array.qualifiers, UPC_BLOCK_SIZE_NONE,</span></a>
<a name="2770"><span class="lineNum">    2770 </span>            :                       /*need_trailing_space=*/TRUE, octl);</a>
<a name="2771"><span class="lineNum">    2771 </span>            : #if !SUPPRESS_ARRAY_STATIC_IN_GENERATED_CODE</a>
<a name="2772"><span class="lineNum">    2772 </span>            :   if (type-&gt;variant.array.is_static) {</a>
<a name="2773"><span class="lineNum">    2773 </span>            :     /* C99 static. */</a>
<a name="2774"><span class="lineNum">    2774 </span>            :     octl-&gt;output_str(&quot;static &quot;, octl);</a>
<a name="2775"><span class="lineNum">    2775 </span>            :   }  /* if */</a>
<a name="2776"><span class="lineNum">    2776 </span>            : #endif /* !SUPPRESS_ARRAY_STATIC_IN_GENERATED_CODE */</a>
<a name="2777"><span class="lineNum">    2777 </span><span class="lineNoCov">          0 :   if (type-&gt;variant.array.is_vla) {</span></a>
<a name="2778"><span class="lineNum">    2778 </span>            :     /* Variable-length array. */</a>
<a name="2779"><span class="lineNum">    2779 </span><span class="lineNoCov">          0 :     if (!type-&gt;variant.array.has_assoc_vla_dimension ||</span></a>
<a name="2780"><span class="lineNum">    2780 </span><span class="lineNoCov">          0 :         octl-&gt;gen_vla_array_as_asterisk_bound_array) {</span></a>
<a name="2781"><span class="lineNum">    2781 </span>            :       /* Array[*] case. */</a>
<a name="2782"><span class="lineNum">    2782 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;*&quot;, octl);</span></a>
<a name="2783"><span class="lineNum">    2783 </span><span class="lineNoCov">          0 :     } else if (innermost_function_scope == NULL) {</span></a>
<a name="2784"><span class="lineNum">    2784 </span>            :       /* find_vla_dimension requires that innermost function scope be set.</a>
<a name="2785"><span class="lineNum">    2785 </span>            :          Since this is not the case, we just emit a placeholder.  This should</a>
<a name="2786"><span class="lineNum">    2786 </span>            :          only happen when called from the stand-alone IL display code. */</a>
<a name="2787"><span class="lineNum">    2787 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="2788"><span class="lineNum">    2788 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;expr&gt;&quot;, octl);</span></a>
<a name="2789"><span class="lineNum">    2789 </span>            :     } else {</a>
<a name="2790"><span class="lineNum">    2790 </span>            :       /* Variable-length array with an associated expression. */</a>
<a name="2791"><span class="lineNum">    2791 </span><span class="lineNoCov">          0 :       a_vla_dimension_ptr vlap = find_vla_dimension(type);</span></a>
<a name="2792"><span class="lineNum">    2792 </span>            : #if DO_IL_LOWERING &amp;&amp; !LOWER_VARIABLE_LENGTH_ARRAYS</a>
<a name="2793"><span class="lineNum">    2793 </span>            :       if (octl-&gt;gen_compilable_code &amp;&amp; vlap-&gt;dimension_variable != NULL) {</a>
<a name="2794"><span class="lineNum">    2794 </span>            :         /* The expression was fixed in a separate variable.  Use that instead</a>
<a name="2795"><span class="lineNum">    2795 </span>            :            of the expression (to avoid potential duplicate side-effects). */</a>
<a name="2796"><span class="lineNum">    2796 </span>            :         form_name(&amp;vlap-&gt;dimension_variable-&gt;source_corresp, iek_variable,</a>
<a name="2797"><span class="lineNum">    2797 </span>            :                   octl);</a>
<a name="2798"><span class="lineNum">    2798 </span>            :       } else</a>
<a name="2799"><span class="lineNum">    2799 </span>            : #endif /* DO_IL_LOWERING &amp;&amp; !LOWER_VARIABLE_LENGTH_ARRAYS */</a>
<a name="2800"><span class="lineNum">    2800 </span>            :       /* Do not insert code here. */</a>
<a name="2801"><span class="lineNum">    2801 </span>            :       {</a>
<a name="2802"><span class="lineNum">    2802 </span><span class="lineNoCov">          0 :         form_expression(vlap-&gt;dimension_expr, octl);</span></a>
<a name="2803"><span class="lineNum">    2803 </span>            :       }  /* if */</a>
<a name="2804"><span class="lineNum">    2804 </span>            :     }  /* if */      </a>
<a name="2805"><span class="lineNum">    2805 </span><span class="lineNoCov">          0 :   } else if (type-&gt;variant.array.is_variable_size_array) {</span></a>
<a name="2806"><span class="lineNum">    2806 </span><span class="lineNoCov">          0 :     an_expr_node_ptr count = type-&gt;variant.array.variant.element_count_expr;</span></a>
<a name="2807"><span class="lineNum">    2807 </span><span class="lineNoCov">          0 :     form_expression(count, octl);</span></a>
<a name="2808"><span class="lineNum">    2808 </span><span class="lineNoCov">          0 :   } else if (type-&gt;variant.array.constant_bound_expr_in_local_expr_node_ref &amp;&amp;</span></a>
<a name="2809"><span class="lineNum">    2809 </span><span class="lineNoCov">          0 :              innermost_function_scope != NULL &amp;&amp;</span></a>
<a name="2810"><span class="lineNum">    2810 </span><span class="lineNoCov">          0 :              !octl-&gt;c_generating_back_end) {</span></a>
<a name="2811"><span class="lineNum">    2811 </span>            :     /* The bound expression has a reference to a local variable and is</a>
<a name="2812"><span class="lineNum">    2812 </span>            :        consequently represented by an a_local_expr_node_ref entry. */</a>
<a name="2813"><span class="lineNum">    2813 </span><span class="lineNoCov">          0 :     an_expr_node_ptr expr = find_local_expr_node(</span></a>
<a name="2814"><span class="lineNum">    2814 </span>            :                                  (char *)type,</a>
<a name="2815"><span class="lineNum">    2815 </span>            :                                  (a_local_expr_node_ref_kind)lerk_array_bound);</a>
<a name="2816"><span class="lineNum">    2816 </span><span class="lineNoCov">          0 :     check_assertion(expr != NULL);</span></a>
<a name="2817"><span class="lineNum">    2817 </span><span class="lineNoCov">          0 :     form_expression(expr, octl);</span></a>
<a name="2818"><span class="lineNum">    2818 </span><span class="lineNoCov">          0 :   } else if (type-&gt;variant.array.bound_constant != NULL &amp;&amp;</span></a>
<a name="2819"><span class="lineNum">    2819 </span><span class="lineNoCov">          0 :              !type-&gt;variant.array.is_template_dependent_size_array &amp;&amp;</span></a>
<a name="2820"><span class="lineNum">    2820 </span><span class="lineNoCov">          0 :              !octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineNoCov">          0 :              octl-&gt;output_expression != NULL) {</span></a>
<a name="2822"><span class="lineNum">    2822 </span>            :     /* Use the recorded a_constant entry rather than a plain integer.  This</a>
<a name="2823"><span class="lineNum">    2823 </span>            :        allows the output to be closer to the original bound expression when</a>
<a name="2824"><span class="lineNum">    2824 </span>            :        the bound is more than just a literal (e.g., &quot;2*2&quot; instead of &quot;4&quot;). */</a>
<a name="2825"><span class="lineNum">    2825 </span><span class="lineNoCov">          0 :     form_constant(type-&gt;variant.array.bound_constant,</span></a>
<a name="2826"><span class="lineNum">    2826 </span>            :                   /*need_parens=*/FALSE, octl);</a>
<a name="2827"><span class="lineNum">    2827 </span><span class="lineNoCov">          0 :   } else if (type-&gt;variant.array.is_template_dependent_size_array) {</span></a>
<a name="2828"><span class="lineNum">    2828 </span><span class="lineNoCov">          0 :     a_constant_ptr constant =</span></a>
<a name="2829"><span class="lineNum">    2829 </span>            :                             type-&gt;variant.array.variant.element_count_constant;</a>
<a name="2830"><span class="lineNum">    2830 </span><span class="lineNoCov">          0 :     if (constant != NULL) {</span></a>
<a name="2831"><span class="lineNum">    2831 </span><span class="lineNoCov">          0 :       an_expr_node_ptr *expr_ptr = NULL;</span></a>
<a name="2832"><span class="lineNum">    2832 </span><span class="lineNoCov">          0 :       if (type-&gt;variant.array.dep_constant_bound_expr_in_local_expr_node_ref &amp;&amp;</span></a>
<a name="2833"><span class="lineNum">    2833 </span><span class="lineNoCov">          0 :           innermost_function_scope != NULL) {</span></a>
<a name="2834"><span class="lineNum">    2834 </span>            :         /* The expression associated with the element count constant referred</a>
<a name="2835"><span class="lineNum">    2835 </span>            :            to local variables and thus could not be copied into the file</a>
<a name="2836"><span class="lineNum">    2836 </span>            :            scope.  Retrieve it and temporarily restore it to the constant so</a>
<a name="2837"><span class="lineNum">    2837 </span>            :            we can print it. */</a>
<a name="2838"><span class="lineNum">    2838 </span><span class="lineNoCov">          0 :         a_template_param_constant_kind tkind;</span></a>
<a name="2839"><span class="lineNum">    2839 </span><span class="lineNoCov">          0 :         check_assertion(constant-&gt;kind ==</span></a>
<a name="2840"><span class="lineNum">    2840 </span>            :                                       (a_constant_repr_kind)ck_template_param);</a>
<a name="2841"><span class="lineNum">    2841 </span><span class="lineNoCov">          0 :         tkind = constant-&gt;variant.template_param.kind;</span></a>
<a name="2842"><span class="lineNum">    2842 </span><span class="lineNoCov">          0 :         if (tkind == (a_template_param_constant_kind)tpck_expression) {</span></a>
<a name="2843"><span class="lineNum">    2843 </span><span class="lineNoCov">          0 :           expr_ptr = &amp;constant-&gt;variant.template_param.variant.expr;</span></a>
<a name="2844"><span class="lineNum">    2844 </span><span class="lineNoCov">          0 :         } else if (tkind == (a_template_param_constant_kind)tpck_sizeof ||</span></a>
<a name="2845"><span class="lineNum">    2845 </span>            :                    tkind == (a_template_param_constant_kind)tpck_alignof ||</a>
<a name="2846"><span class="lineNum">    2846 </span>            :                    tkind == (a_template_param_constant_kind)tpck_uuidof ||</a>
<a name="2847"><span class="lineNum">    2847 </span><span class="lineNoCov">          0 :                    tkind == (a_template_param_constant_kind)tpck_typeid ||</span></a>
<a name="2848"><span class="lineNum">    2848 </span>            :                    tkind == (a_template_param_constant_kind)tpck_noexcept) {</a>
<a name="2849"><span class="lineNum">    2849 </span><span class="lineNoCov">          0 :           expr_ptr=&amp;constant-&gt;variant.template_param.variant.templ_sizeof.expr;</span></a>
<a name="2850"><span class="lineNum">    2850 </span>            :         }  /* if */</a>
<a name="2851"><span class="lineNum">    2851 </span><span class="lineNoCov">          0 :         check_assertion(expr_ptr != NULL &amp;&amp; *expr_ptr == NULL);</span></a>
<a name="2852"><span class="lineNum">    2852 </span><span class="lineNoCov">          0 :         *expr_ptr = find_local_expr_node(</span></a>
<a name="2853"><span class="lineNum">    2853 </span>            :                              (char *)type,</a>
<a name="2854"><span class="lineNum">    2854 </span>            :                              (a_local_expr_node_ref_kind)lerk_dep_array_bound);</a>
<a name="2855"><span class="lineNum">    2855 </span><span class="lineNoCov">          0 :         check_assertion(*expr_ptr != NULL);</span></a>
<a name="2856"><span class="lineNum">    2856 </span>            :       }  /* if */</a>
<a name="2857"><span class="lineNum">    2857 </span><span class="lineNoCov">          0 :       form_constant(constant, /*need_parens=*/FALSE, octl);</span></a>
<a name="2858"><span class="lineNum">    2858 </span><span class="lineNoCov">          0 :       if (expr_ptr != NULL) {</span></a>
<a name="2859"><span class="lineNum">    2859 </span><span class="lineNoCov">          0 :         *expr_ptr = NULL;</span></a>
<a name="2860"><span class="lineNum">    2860 </span>            :       }  /* if */</a>
<a name="2861"><span class="lineNum">    2861 </span>            :     }  /* if */</a>
<a name="2862"><span class="lineNum">    2862 </span><span class="lineNoCov">          0 :   } else if (type-&gt;variant.array.variant.number_of_elements == 0 &amp;&amp;</span></a>
<a name="2863"><span class="lineNum">    2863 </span><span class="lineNoCov">          0 :              !type-&gt;variant.array.bound_is_zero) {</span></a>
<a name="2864"><span class="lineNum">    2864 </span>            :     /* For unknown-bound arrays, put nothing between the []. */</a>
<a name="2865"><span class="lineNum">    2865 </span>            :   } else {</a>
<a name="2866"><span class="lineNum">    2866 </span><span class="lineNoCov">          0 :     form_unsigned_num((a_host_large_unsigned)type-&gt;</span></a>
<a name="2867"><span class="lineNum">    2867 </span>            :                                      variant.array.variant.number_of_elements,</a>
<a name="2868"><span class="lineNum">    2868 </span>            :                       octl);</a>
<a name="2869"><span class="lineNum">    2869 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="2870"><span class="lineNum">    2870 </span><span class="lineNoCov">          0 :     if (type-&gt;variant.array.is_threads_dimension) {</span></a>
<a name="2871"><span class="lineNum">    2871 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;*THREADS&quot;, octl);</span></a>
<a name="2872"><span class="lineNum">    2872 </span>            :     }  /* if */</a>
<a name="2873"><span class="lineNum">    2873 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="2874"><span class="lineNum">    2874 </span>            :   }  /* if */</a>
<a name="2875"><span class="lineNum">    2875 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;]&quot;, octl);</span></a>
<a name="2876"><span class="lineNum">    2876 </span><span class="lineNoCov">          0 : }  /* form_array_declarator */</span></a>
<a name="2877"><span class="lineNum">    2877 </span>            : </a>
<a name="2878"><span class="lineNum">    2878 </span>            : </a>
<a name="2879"><span class="lineNum">    2879 </span><span class="lineCov">         54 : void form_type_second_part(</span></a>
<a name="2880"><span class="lineNum">    2880 </span>            :                     a_type_ptr                            type,</a>
<a name="2881"><span class="lineNum">    2881 </span>            :                     a_boolean                             under_lhs_declarator,</a>
<a name="2882"><span class="lineNum">    2882 </span>            :                     a_form_type_options_set               options,</a>
<a name="2883"><span class="lineNum">    2883 </span>            :                     an_il_to_str_output_control_block_ptr octl)</a>
<a name="2884"><span class="lineNum">    2884 </span>            : /*</a>
<a name="2885"><span class="lineNum">    2885 </span>            : Output the second part of a type reference, the part of the declarator</a>
<a name="2886"><span class="lineNum">    2886 </span>            : that follows the name.  If under_lhs_declarator is TRUE, this type is</a>
<a name="2887"><span class="lineNum">    2887 </span>            : directly under a type that uses a left-side declarator, e.g., a pointer type.</a>
<a name="2888"><span class="lineNum">    2888 </span>            : (That's used to control use of parentheses around parts of the declarator.)</a>
<a name="2889"><span class="lineNum">    2889 </span>            : If options contains FTO_SUPPRESS_CONST, suppress generation of top-level</a>
<a name="2890"><span class="lineNum">    2890 </span>            : &quot;const&quot;.  Do the output in the way described by octl.</a>
<a name="2891"><span class="lineNum">    2891 </span>            : */</a>
<a name="2892"><span class="lineNum">    2892 </span>            : {</a>
<a name="2893"><span class="lineNum">    2893 </span><span class="lineCov">         54 :   a_type_kind kind;</span></a>
<a name="2894"><span class="lineNum">    2894 </span><span class="lineCov">         54 :   a_boolean   suppress_const = (options &amp; FTO_SUPPRESS_CONST) != 0;</span></a>
<a name="2895"><span class="lineNum">    2895 </span><span class="lineCov">         54 :   a_type_qualifier_set</span></a>
<a name="2896"><span class="lineNum">    2896 </span><span class="lineCov">         54 :               qualifiers = TQ_NONE;</span></a>
<a name="2897"><span class="lineNum">    2897 </span><span class="lineCov">         54 :   a_type_ptr  orig_type = type;</span></a>
<a name="2898"><span class="lineNum">    2898 </span><span class="lineCov">         54 :   a_type_ptr  attrib_stop_type = type;</span></a>
<a name="2899"><span class="lineNum">    2899 </span>            : </a>
<a name="2900"><span class="lineNum">    2900 </span><span class="lineCov">         54 :   if (type == NULL) {</span></a>
<a name="2901"><span class="lineNum">    2901 </span>            :     /* NULL type pointer.  Handled in form_type_first_part. */</a>
<a name="2902"><span class="lineNum">    2902 </span><span class="lineNoCov">          0 :     goto end_of_routine;</span></a>
<a name="2903"><span class="lineNum">    2903 </span>            :   }  /* if */</a>
<a name="2904"><span class="lineNum">    2904 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2905"><span class="lineNum">    2905 </span>            :   if (is_cli_generic_definition_argument_type(type) &amp;&amp;</a>
<a name="2906"><span class="lineNum">    2906 </span>            :       is_handle_type(type)) {</a>
<a name="2907"><span class="lineNum">    2907 </span>            :     /* For a generic definition argument, strip the handle type if one is</a>
<a name="2908"><span class="lineNum">    2908 </span>            :        present. */</a>
<a name="2909"><span class="lineNum">    2909 </span>            :     type = type-&gt;variant.pointer.type;</a>
<a name="2910"><span class="lineNum">    2910 </span>            :   }  /* if */</a>
<a name="2911"><span class="lineNum">    2911 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2912"><span class="lineNum">    2912 </span><span class="lineCov">         54 :   options &amp;= ~FTO_SUPPRESS_CONST;</span></a>
<a name="2913"><span class="lineNum">    2913 </span>            :   /* Remove type qualifiers but not typedefs.  Also drop typedefs that aren't</a>
<a name="2914"><span class="lineNum">    2914 </span>            :      visible here.  The decltype and GNU typeof operators are like visible</a>
<a name="2915"><span class="lineNum">    2915 </span>            :      typedefs.  Accumulate the type qualifier set. */</a>
<a name="2916"><span class="lineNum">    2916 </span><span class="lineCov">         77 :   while (type-&gt;kind == (a_type_kind)tk_typeref) {</span></a>
<a name="2917"><span class="lineNum">    2917 </span><span class="lineCov">         41 :     if (typeref_is_typedef(type)) {</span></a>
<a name="2918"><span class="lineNum">    2918 </span>            :       /* Typedef.  Stop unless it's invisible, or if it is a typedef that</a>
<a name="2919"><span class="lineNum">    2919 </span>            :          should be dropped in diagnostic output. */</a>
<a name="2920"><span class="lineNum">    2920 </span><span class="lineCov">         40 :       if (!typedef_is_invisible(type, suppress_const, octl) &amp;&amp;</span></a>
<a name="2921"><span class="lineNum">    2921 </span><span class="lineCov">         40 :           !is_member_typedef_that_should_be_ignored(type, octl)) {</span></a>
<a name="2922"><span class="lineNum">    2922 </span>            :         break;</a>
<a name="2923"><span class="lineNum">    2923 </span>            :       }  /* if */</a>
<a name="2924"><span class="lineNum">    2924 </span><span class="lineCov">          1 :     } else if (is_type_operator_to_be_rendered(type, octl)) {</span></a>
<a name="2925"><span class="lineNum">    2925 </span>            :       /* A decltype or typeof operator that should be rendered in its</a>
<a name="2926"><span class="lineNum">    2926 </span>            :          original form (instead of rendering the underlying type). */</a>
<a name="2927"><span class="lineNum">    2927 </span>            :       break;</a>
<a name="2928"><span class="lineNum">    2928 </span>            :     } else {</a>
<a name="2929"><span class="lineNum">    2929 </span>            :       /* Type qualifier typeref.  Accumulate the qualifiers. */</a>
<a name="2930"><span class="lineNum">    2930 </span><span class="lineCov">          1 :       qualifiers |= type-&gt;variant.typeref.qualifiers;</span></a>
<a name="2931"><span class="lineNum">    2931 </span>            :       /* If we're supposed to suppress &quot;const&quot; and this typeref has it, we</a>
<a name="2932"><span class="lineNum">    2932 </span>            :          can take care of the suppression now.  This has to be done inside</a>
<a name="2933"><span class="lineNum">    2933 </span>            :          the loop because the &quot;typedef_is_invisible&quot; test uses the</a>
<a name="2934"><span class="lineNum">    2934 </span>            :          suppress_const flag. */</a>
<a name="2935"><span class="lineNum">    2935 </span><span class="lineCov">          1 :       if (suppress_const &amp;&amp; (qualifiers &amp; TQ_CONST)) {</span></a>
<a name="2936"><span class="lineNum">    2936 </span><span class="lineNoCov">          0 :         qualifiers &amp;= ~TQ_CONST;</span></a>
<a name="2937"><span class="lineNum">    2937 </span><span class="lineNoCov">          0 :         suppress_const = FALSE;</span></a>
<a name="2938"><span class="lineNum">    2938 </span>            :       }  /* if */</a>
<a name="2939"><span class="lineNum">    2939 </span><span class="lineCov">          1 :       if (type-&gt;variant.typeref.for_type_attributes) {</span></a>
<a name="2940"><span class="lineNum">    2940 </span>            :         /* The underlying type was modified with an attribute.  Record</a>
<a name="2941"><span class="lineNum">    2941 </span>            :            the target of the typeref as the end of the typeref chain for</a>
<a name="2942"><span class="lineNum">    2942 </span>            :            output_type_attributes. */</a>
<a name="2943"><span class="lineNum">    2943 </span><span class="lineNoCov">          0 :         attrib_stop_type = type-&gt;variant.typeref.type;</span></a>
<a name="2944"><span class="lineNum">    2944 </span>            :       }  /* if */</a>
<a name="2945"><span class="lineNum">    2945 </span>            :     }  /* if */</a>
<a name="2946"><span class="lineNum">    2946 </span><span class="lineCov">         23 :     type = type-&gt;variant.typeref.type;</span></a>
<a name="2947"><span class="lineNum">    2947 </span>            :   }  /* while */</a>
<a name="2948"><span class="lineNum">    2948 </span><span class="lineCov">         54 :   kind = type-&gt;kind;</span></a>
<a name="2949"><span class="lineNum">    2949 </span><span class="lineCov">         54 :   if (kind == (a_type_kind)tk_pointer</span></a>
<a name="2950"><span class="lineNum">    2950 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="2951"><span class="lineNum">    2951 </span>            :       /* C++/CLI interior_ptr and pin_ptr are handled as specifier types. */</a>
<a name="2952"><span class="lineNum">    2952 </span>            :       &amp;&amp; !type-&gt;variant.pointer.is_interior_ptr</a>
<a name="2953"><span class="lineNum">    2953 </span>            :       &amp;&amp; !type-&gt;variant.pointer.is_pin_ptr</a>
<a name="2954"><span class="lineNum">    2954 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="2955"><span class="lineNum">    2955 </span>            :                                           ) {</a>
<a name="2956"><span class="lineNum">    2956 </span>            :     /* Pointer or reference type. */</a>
<a name="2957"><span class="lineNum">    2957 </span><span class="lineCov">          3 :     form_type_second_part(type-&gt;variant.pointer.type,</span></a>
<a name="2958"><span class="lineNum">    2958 </span>            :                           /*under_lhs_declarator=*/TRUE,</a>
<a name="2959"><span class="lineNum">    2959 </span>            :                           options, octl);</a>
<a name="2960"><span class="lineNum">    2960 </span><span class="lineCov">         51 :   } else if (kind == (a_type_kind)tk_ptr_to_member) {</span></a>
<a name="2961"><span class="lineNum">    2961 </span>            :     /* Pointer-to-member type. */</a>
<a name="2962"><span class="lineNum">    2962 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="2963"><span class="lineNum">    2963 </span><span class="lineNoCov">          0 :         type-&gt;variant.ptr_to_member.type-&gt;kind != (a_type_kind)tk_routine &amp;&amp;</span></a>
<a name="2964"><span class="lineNum">    2964 </span><span class="lineNoCov">          0 :         !octl-&gt;suppress_ptr_to_data_member_parens) {</span></a>
<a name="2965"><span class="lineNum">    2965 </span>            :       /* When we put out the first part of the type, we added a &quot;(&quot; to</a>
<a name="2966"><span class="lineNum">    2966 </span>            :          separate the member type from a possible leading global qualifier</a>
<a name="2967"><span class="lineNum">    2967 </span>            :          &quot;::&quot; on the class type.  We need to put out the matching &quot;)&quot;</a>
<a name="2968"><span class="lineNum">    2968 </span>            :          here. */</a>
<a name="2969"><span class="lineNum">    2969 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="2970"><span class="lineNum">    2970 </span>            :     }  /* if */</a>
<a name="2971"><span class="lineNum">    2971 </span><span class="lineNoCov">          0 :     form_type_second_part(type-&gt;variant.ptr_to_member.type,</span></a>
<a name="2972"><span class="lineNum">    2972 </span>            :                           /*under_lhs_declarator=*/TRUE,</a>
<a name="2973"><span class="lineNum">    2973 </span>            :                           options, octl);</a>
<a name="2974"><span class="lineNum">    2974 </span><span class="lineCov">         51 :   } else if (kind == (a_type_kind)tk_routine) {</span></a>
<a name="2975"><span class="lineNum">    2975 </span>            :     /* Function type. */</a>
<a name="2976"><span class="lineNum">    2976 </span>            :     /* This is a right-side declarator, so if it's under a left-side</a>
<a name="2977"><span class="lineNum">    2977 </span>            :        declarator parentheses are needed. */</a>
<a name="2978"><span class="lineNum">    2978 </span><span class="lineCov">          5 :     if (under_lhs_declarator) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="2979"><span class="lineNum">    2979 </span><span class="lineCov">          5 :     form_function_declarator(type, octl);</span></a>
<a name="2980"><span class="lineNum">    2980 </span><span class="lineCov">          5 :     if (attrib_stop_type != orig_type) {</span></a>
<a name="2981"><span class="lineNum">    2981 </span><span class="lineNoCov">          0 :       output_type_attributes(orig_type, attrib_stop_type, octl);</span></a>
<a name="2982"><span class="lineNum">    2982 </span>            :     }  /* if */</a>
<a name="2983"><span class="lineNum">    2983 </span><span class="lineCov">          5 :     if ((type-&gt;variant.routine.extra_info-&gt;trailing_return_type ||</span></a>
<a name="2984"><span class="lineNum">    2984 </span><span class="lineNoCov">          0 :          is_lambda_body_routine_type(type)) &amp;&amp;</span></a>
<a name="2985"><span class="lineNum">    2985 </span><span class="lineNoCov">          0 :         !octl-&gt;c_generating_back_end) {</span></a>
<a name="2986"><span class="lineNum">    2986 </span>            :       /* Suppress the normal return type for trailing return types.  (The C-</a>
<a name="2987"><span class="lineNum">    2987 </span>            :          generating back end does not attempt to render routine types with</a>
<a name="2988"><span class="lineNum">    2988 </span>            :          trailing return types, since those are a C++ feature.) */</a>
<a name="2989"><span class="lineNum">    2989 </span>            :     } else {</a>
<a name="2990"><span class="lineNum">    2990 </span><span class="lineCov">          5 :       form_type_second_part(type-&gt;variant.routine.return_type,</span></a>
<a name="2991"><span class="lineNum">    2991 </span>            :                             /*under_lhs_declarator=*/FALSE,</a>
<a name="2992"><span class="lineNum">    2992 </span>            :                             options, octl);</a>
<a name="2993"><span class="lineNum">    2993 </span>            :     }  /* if */</a>
<a name="2994"><span class="lineNum">    2994 </span><span class="lineCov">         46 :   } else if (kind == (a_type_kind)tk_array) {</span></a>
<a name="2995"><span class="lineNum">    2995 </span>            :     /* Array type. */</a>
<a name="2996"><span class="lineNum">    2996 </span><span class="lineNoCov">          0 :     if (can_use_qualified_array_typedef(&amp;type, &amp;qualifiers, suppress_const,</span></a>
<a name="2997"><span class="lineNum">    2997 </span>            :                                         octl)) {</a>
<a name="2998"><span class="lineNum">    2998 </span>            :       /* This array type was generated by applying a type qualifier to</a>
<a name="2999"><span class="lineNum">    2999 </span>            :          a typedef of an array type.  The type was handled as a specifiers</a>
<a name="3000"><span class="lineNum">    3000 </span>            :          type. */</a>
<a name="3001"><span class="lineNum">    3001 </span>            :     } else {</a>
<a name="3002"><span class="lineNum">    3002 </span>            :       /* This is a right-side declarator, so if it's under a left-side</a>
<a name="3003"><span class="lineNum">    3003 </span>            :          declarator parentheses are needed. */</a>
<a name="3004"><span class="lineNum">    3004 </span><span class="lineNoCov">          0 :       if (under_lhs_declarator) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3005"><span class="lineNum">    3005 </span><span class="lineNoCov">          0 :       form_array_declarator(type, octl);</span></a>
<a name="3006"><span class="lineNum">    3006 </span><span class="lineNoCov">          0 :       if (attrib_stop_type != orig_type) {</span></a>
<a name="3007"><span class="lineNum">    3007 </span><span class="lineNoCov">          0 :         output_type_attributes(orig_type, attrib_stop_type, octl);</span></a>
<a name="3008"><span class="lineNum">    3008 </span>            :       }  /* if */</a>
<a name="3009"><span class="lineNum">    3009 </span><span class="lineNoCov">          0 :       if (suppress_const) options |= FTO_SUPPRESS_CONST;</span></a>
<a name="3010"><span class="lineNum">    3010 </span><span class="lineNoCov">          0 :       form_type_second_part(type-&gt;variant.array.element_type,</span></a>
<a name="3011"><span class="lineNum">    3011 </span>            :                             /*under_lhs_declarator=*/FALSE,</a>
<a name="3012"><span class="lineNum">    3012 </span>            :                             options, octl);</a>
<a name="3013"><span class="lineNum">    3013 </span>            :     }  /* if */</a>
<a name="3014"><span class="lineNum">    3014 </span>            :   } else {</a>
<a name="3015"><span class="lineNum">    3015 </span><span class="lineCov">         92 :     if (has_predeclarator_attribute(orig_type)) {</span></a>
<a name="3016"><span class="lineNum">    3016 </span>            :       /* form_type_first_part opened a parenthesis to render predeclarator</a>
<a name="3017"><span class="lineNum">    3017 </span>            :          attributes.  Close that parenthesis now. */</a>
<a name="3018"><span class="lineNum">    3018 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3019"><span class="lineNum">    3019 </span>            :     }  /* if */</a>
<a name="3020"><span class="lineNum">    3020 </span>            :   }  /* if */</a>
<a name="3021"><span class="lineNum">    3021 </span><span class="lineCov">         46 : end_of_routine:;</span></a>
<a name="3022"><span class="lineNum">    3022 </span><span class="lineCov">         54 : }  /* form_type_second_part */</span></a>
<a name="3023"><span class="lineNum">    3023 </span>            : </a>
<a name="3024"><span class="lineNum">    3024 </span>            : </a>
<a name="3025"><span class="lineNum">    3025 </span><span class="lineCov">         41 : void form_type(a_type_ptr                            type,</span></a>
<a name="3026"><span class="lineNum">    3026 </span>            :                an_il_to_str_output_control_block_ptr octl)</a>
<a name="3027"><span class="lineNum">    3027 </span>            : /*</a>
<a name="3028"><span class="lineNum">    3028 </span>            : Output a string for a type.  Do the output in the way described by octl.</a>
<a name="3029"><span class="lineNum">    3029 </span>            : */</a>
<a name="3030"><span class="lineNum">    3030 </span>            : {</a>
<a name="3031"><span class="lineNum">    3031 </span><span class="lineCov">         41 :   if (type == NULL) {</span></a>
<a name="3032"><span class="lineNum">    3032 </span><span class="lineNoCov">          0 :     check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="3033"><span class="lineNum">    3033 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&lt;null-type&gt;&quot;, octl);</span></a>
<a name="3034"><span class="lineNum">    3034 </span>            :   } else {</a>
<a name="3035"><span class="lineNum">    3035 </span>            :     /* Write the specifiers and the first part of the declarator. */</a>
<a name="3036"><span class="lineNum">    3036 </span><span class="lineCov">         41 :     form_type_first_part_simple(type, /*under_lhs_declarator=*/FALSE,</span></a>
<a name="3037"><span class="lineNum">    3037 </span>            :                                 /*need_trailing_space=*/FALSE, octl);</a>
<a name="3038"><span class="lineNum">    3038 </span>            :     /* Write the second part of the declarator. */</a>
<a name="3039"><span class="lineNum">    3039 </span><span class="lineCov">         41 :     form_type_second_part_simple(type, /*under_lhs_declarator=*/FALSE, octl);</span></a>
<a name="3040"><span class="lineNum">    3040 </span>            :   }  /* if */</a>
<a name="3041"><span class="lineNum">    3041 </span><span class="lineCov">         41 : }  /* form_type */</span></a>
<a name="3042"><span class="lineNum">    3042 </span>            : </a>
<a name="3043"><span class="lineNum">    3043 </span>            : </a>
<a name="3044"><span class="lineNum">    3044 </span><span class="lineNoCov">          0 : static void form_cast(a_type_ptr                            type,</span></a>
<a name="3045"><span class="lineNum">    3045 </span>            :                       an_il_to_str_output_control_block_ptr octl)</a>
<a name="3046"><span class="lineNum">    3046 </span>            : /*</a>
<a name="3047"><span class="lineNum">    3047 </span>            : Output a cast to the indicated type.  Do the output in the way described</a>
<a name="3048"><span class="lineNum">    3048 </span>            : by octl.</a>
<a name="3049"><span class="lineNum">    3049 </span>            : */</a>
<a name="3050"><span class="lineNum">    3050 </span>            : {</a>
<a name="3051"><span class="lineNum">    3051 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="3052"><span class="lineNum">    3052 </span><span class="lineNoCov">          0 :   form_type(type, octl);</span></a>
<a name="3053"><span class="lineNum">    3053 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3054"><span class="lineNum">    3054 </span><span class="lineNoCov">          0 : }  /* form_cast */</span></a>
<a name="3055"><span class="lineNum">    3055 </span>            : </a>
<a name="3056"><span class="lineNum">    3056 </span>            : </a>
<a name="3057"><span class="lineNum">    3057 </span><span class="lineNoCov">          0 : static void form_general_cast(</span></a>
<a name="3058"><span class="lineNum">    3058 </span>            :                      a_type_ptr                            type,</a>
<a name="3059"><span class="lineNum">    3059 </span>            :                      a_boolean                             is_reinterpret_cast,</a>
<a name="3060"><span class="lineNum">    3060 </span>            :                      an_il_to_str_output_control_block_ptr octl)</a>
<a name="3061"><span class="lineNum">    3061 </span>            : /*</a>
<a name="3062"><span class="lineNum">    3062 </span>            : Output a cast to the indicated type.  If is_reinterpret_cast is TRUE,</a>
<a name="3063"><span class="lineNum">    3063 </span>            : output a reinterpret_cast (note that a closing parenthesis will have to</a>
<a name="3064"><span class="lineNum">    3064 </span>            : be output later).  Do the output in the way described by octl.</a>
<a name="3065"><span class="lineNum">    3065 </span>            : */</a>
<a name="3066"><span class="lineNum">    3066 </span>            : {</a>
<a name="3067"><span class="lineNum">    3067 </span><span class="lineNoCov">          0 :   if (is_reinterpret_cast) {</span></a>
<a name="3068"><span class="lineNum">    3068 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;reinterpret_cast&lt;&quot;, octl);</span></a>
<a name="3069"><span class="lineNum">    3069 </span><span class="lineNoCov">          0 :     form_type(type, octl);</span></a>
<a name="3070"><span class="lineNum">    3070 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&gt;(&quot;, octl);</span></a>
<a name="3071"><span class="lineNum">    3071 </span>            :   } else {</a>
<a name="3072"><span class="lineNum">    3072 </span><span class="lineNoCov">          0 :     form_cast(type, octl);</span></a>
<a name="3073"><span class="lineNum">    3073 </span>            :   }  /* if */</a>
<a name="3074"><span class="lineNum">    3074 </span><span class="lineNoCov">          0 : }  /* form_general_cast */</span></a>
<a name="3075"><span class="lineNum">    3075 </span>            : </a>
<a name="3076"><span class="lineNum">    3076 </span>            : </a>
<a name="3077"><span class="lineNum">    3077 </span><span class="lineNoCov">          0 : static void output_optional_open_paren(</span></a>
<a name="3078"><span class="lineNum">    3078 </span>            :                        a_boolean                             *need_parens,</a>
<a name="3079"><span class="lineNum">    3079 </span>            :                        a_boolean                             *need_close_paren,</a>
<a name="3080"><span class="lineNum">    3080 </span>            :                        an_il_to_str_output_control_block_ptr octl)</a>
<a name="3081"><span class="lineNum">    3081 </span>            : /*</a>
<a name="3082"><span class="lineNum">    3082 </span>            : Output an opening parenthesis and set *need_close_paren to indicate that</a>
<a name="3083"><span class="lineNum">    3083 </span>            : the closing parenthesis is needed later.  However, if *need_parens is</a>
<a name="3084"><span class="lineNum">    3084 </span>            : FALSE, the parenthesis can be optimized away: don't generate it,</a>
<a name="3085"><span class="lineNum">    3085 </span>            : leave *need_close_paren set to FALSE, and set *need_parens to TRUE to</a>
<a name="3086"><span class="lineNum">    3086 </span>            : prevent doing the optimization more than once.</a>
<a name="3087"><span class="lineNum">    3087 </span>            : */</a>
<a name="3088"><span class="lineNum">    3088 </span>            : {</a>
<a name="3089"><span class="lineNum">    3089 </span><span class="lineNoCov">          0 :   if (*need_parens) {</span></a>
<a name="3090"><span class="lineNum">    3090 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="3091"><span class="lineNum">    3091 </span><span class="lineNoCov">          0 :     *need_close_paren = TRUE;</span></a>
<a name="3092"><span class="lineNum">    3092 </span>            :   } else {</a>
<a name="3093"><span class="lineNum">    3093 </span>            :     /* Suppress the parenthesis. */</a>
<a name="3094"><span class="lineNum">    3094 </span><span class="lineNoCov">          0 :     *need_parens = TRUE;</span></a>
<a name="3095"><span class="lineNum">    3095 </span>            :   }  /* if */</a>
<a name="3096"><span class="lineNum">    3096 </span>            : }  /* output_optional_open_paren */</a>
<a name="3097"><span class="lineNum">    3097 </span>            : </a>
<a name="3098"><span class="lineNum">    3098 </span>            : </a>
<a name="3099"><span class="lineNum">    3099 </span><span class="lineCov">       9690 : static void output_optional_close_paren(</span></a>
<a name="3100"><span class="lineNum">    3100 </span>            :                         a_boolean                             need_close_paren,</a>
<a name="3101"><span class="lineNum">    3101 </span>            :                         an_il_to_str_output_control_block_ptr octl)</a>
<a name="3102"><span class="lineNum">    3102 </span>            : /*</a>
<a name="3103"><span class="lineNum">    3103 </span>            : Output the closing parenthesis that is part of an optional set of</a>
<a name="3104"><span class="lineNum">    3104 </span>            : parentheses begun by output_optional_open_paren.  The parenthesis is</a>
<a name="3105"><span class="lineNum">    3105 </span>            : output only if need_close_paren is TRUE.</a>
<a name="3106"><span class="lineNum">    3106 </span>            : */</a>
<a name="3107"><span class="lineNum">    3107 </span>            : {</a>
<a name="3108"><span class="lineNum">    3108 </span><span class="lineNoCov">          0 :   if (need_close_paren) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3109"><span class="lineNum">    3109 </span>            : }  /* output_optional_close_paren */</a>
<a name="3110"><span class="lineNum">    3110 </span>            : </a>
<a name="3111"><span class="lineNum">    3111 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="3112"><span class="lineNum">    3112 </span>            : </a>
<a name="3113"><span class="lineNum">    3113 </span>            : static void form_label_difference_constant(</a>
<a name="3114"><span class="lineNum">    3114 </span>            :                             a_constant_ptr                         constant,</a>
<a name="3115"><span class="lineNum">    3115 </span>            :                             a_boolean                              need_parens,</a>
<a name="3116"><span class="lineNum">    3116 </span>            :                             an_il_to_str_output_control_block_ptr  octl)</a>
<a name="3117"><span class="lineNum">    3117 </span>            : /*</a>
<a name="3118"><span class="lineNum">    3118 </span>            : Output the given constant, which represents a difference between two label</a>
<a name="3119"><span class="lineNum">    3119 </span>            : addresses (possible in GNU mode).  The output has the form &quot;&amp;&amp;x - &amp;&amp;y&quot;</a>
<a name="3120"><span class="lineNum">    3120 </span>            : (enclosed in parentheses if need_parens is TRUE) where x and y are label</a>
<a name="3121"><span class="lineNum">    3121 </span>            : names.  Do the output in the way described by octl.</a>
<a name="3122"><span class="lineNum">    3122 </span>            : */</a>
<a name="3123"><span class="lineNum">    3123 </span>            : {</a>
<a name="3124"><span class="lineNum">    3124 </span>            :   if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</a>
<a name="3125"><span class="lineNum">    3125 </span>            :   form_constant(constant-&gt;variant.label_difference.to_address,</a>
<a name="3126"><span class="lineNum">    3126 </span>            :                 /*need_parens=*/FALSE, octl);</a>
<a name="3127"><span class="lineNum">    3127 </span>            :   octl-&gt;output_str(&quot; - &quot;, octl);</a>
<a name="3128"><span class="lineNum">    3128 </span>            :   form_constant(constant-&gt;variant.label_difference.from_address,</a>
<a name="3129"><span class="lineNum">    3129 </span>            :                 /*need_parens=*/FALSE, octl);</a>
<a name="3130"><span class="lineNum">    3130 </span>            :   if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</a>
<a name="3131"><span class="lineNum">    3131 </span>            : }  /* form_label_difference_constant */</a>
<a name="3132"><span class="lineNum">    3132 </span>            : </a>
<a name="3133"><span class="lineNum">    3133 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="3134"><span class="lineNum">    3134 </span>            : </a>
<a name="3135"><span class="lineNum">    3135 </span><span class="lineCov">       4617 : void form_integer_constant(a_constant_ptr                        constant,</span></a>
<a name="3136"><span class="lineNum">    3136 </span>            :                            a_boolean                             suppress_cast,</a>
<a name="3137"><span class="lineNum">    3137 </span>            :                            a_boolean                             need_parens,</a>
<a name="3138"><span class="lineNum">    3138 </span>            :                            an_il_to_str_output_control_block_ptr octl)</a>
<a name="3139"><span class="lineNum">    3139 </span>            : /*</a>
<a name="3140"><span class="lineNum">    3140 </span>            : Output a string for an integer constant (i.e., a constant with an integral</a>
<a name="3141"><span class="lineNum">    3141 </span>            : type; this includes ck_integer, ck_label_difference, and ck_upc_threads</a>
<a name="3142"><span class="lineNum">    3142 </span>            : constants).  The constant is written in integer form even if it has been</a>
<a name="3143"><span class="lineNum">    3143 </span>            : cast to another type (e.g., a pointer type); the caller must handle</a>
<a name="3144"><span class="lineNum">    3144 </span>            : the implicit cast for that case if appropriate.  If suppress_cast is TRUE,</a>
<a name="3145"><span class="lineNum">    3145 </span>            : suppress any cast of the constant to another type.  If need_parens is TRUE,</a>
<a name="3146"><span class="lineNum">    3146 </span>            : parentheses are placed around the constant if there's any possibility of</a>
<a name="3147"><span class="lineNum">    3147 </span>            : precedence confusion.  Do the output in the way described by octl.</a>
<a name="3148"><span class="lineNum">    3148 </span>            : */</a>
<a name="3149"><span class="lineNum">    3149 </span>            : {</a>
<a name="3150"><span class="lineNum">    3150 </span><span class="lineCov">       4617 :   a_boolean       need_cast_close_paren = FALSE;</span></a>
<a name="3151"><span class="lineNum">    3151 </span><span class="lineCov">       4617 :   a_boolean       need_negative_close_paren = FALSE;</span></a>
<a name="3152"><span class="lineNum">    3152 </span><span class="lineCov">       4617 :   a_boolean       err, minus_1_trick = FALSE;</span></a>
<a name="3153"><span class="lineNum">    3153 </span><span class="lineCov">       4617 :   a_constant_ptr  eff_constant = constant;</span></a>
<a name="3154"><span class="lineNum">    3154 </span><span class="lineCov">       4617 :   a_constant_ptr  local_con = local_constant();</span></a>
<a name="3155"><span class="lineNum">    3155 </span><span class="lineCov">       4617 :   a_type_ptr      con_type = skip_typerefs(constant-&gt;type);</span></a>
<a name="3156"><span class="lineNum">    3156 </span><span class="lineCov">       4617 :   a_boolean       integer_type_constant =</span></a>
<a name="3157"><span class="lineNum">    3157 </span><span class="lineCov">       4617 :                                    (con_type-&gt;kind == (a_type_kind)tk_integer);</span></a>
<a name="3158"><span class="lineNum">    3158 </span><span class="lineCov">       4617 :   an_integer_kind ikind = (an_integer_kind)ik_none;</span></a>
<a name="3159"><span class="lineNum">    3159 </span><span class="lineCov">       4617 :   a_boolean       signed_constant = FALSE;</span></a>
<a name="3160"><span class="lineNum">    3160 </span><span class="lineCov">       4617 :   char            *literal_form;</span></a>
<a name="3161"><span class="lineNum">    3161 </span>            : </a>
<a name="3162"><span class="lineNum">    3162 </span>            :   /* See if the constant is signed. */</a>
<a name="3163"><span class="lineNum">    3163 </span><span class="lineCov">       4617 :   if (integer_type_constant) {</span></a>
<a name="3164"><span class="lineNum">    3164 </span><span class="lineCov">       4617 :     ikind = con_type-&gt;variant.integer.int_kind;</span></a>
<a name="3165"><span class="lineNum">    3165 </span><span class="lineCov">       4617 :     signed_constant = int_kind_is_signed[(int)ikind];</span></a>
<a name="3166"><span class="lineNum">    3166 </span>            :   } else {</a>
<a name="3167"><span class="lineNum">    3167 </span>            :     /* Treat null pointer constants as signed since it doesn't change the</a>
<a name="3168"><span class="lineNum">    3168 </span>            :        meaning and looks nicer. */</a>
<a name="3169"><span class="lineNum">    3169 </span><span class="lineNoCov">          0 :     if (cmplit_integer_constant(constant, (a_host_large_integer)0) == 0) {</span></a>
<a name="3170"><span class="lineNum">    3170 </span><span class="lineNoCov">          0 :       signed_constant = TRUE;</span></a>
<a name="3171"><span class="lineNum">    3171 </span>            :     }  /* if */</a>
<a name="3172"><span class="lineNum">    3172 </span>            :   }  /* if */</a>
<a name="3173"><span class="lineNum">    3173 </span><span class="lineCov">       4617 :   if (!suppress_cast &amp;&amp;</span></a>
<a name="3174"><span class="lineNum">    3174 </span>            :       /* If this is an integer value or enumerator constant cast to</a>
<a name="3175"><span class="lineNum">    3175 </span>            :          an enum type in C mode, or an integer value cast to an enum</a>
<a name="3176"><span class="lineNum">    3176 </span>            :          type in C++ mode (note that real enumerator constants don't</a>
<a name="3177"><span class="lineNum">    3177 </span>            :          get here), ... */</a>
<a name="3178"><span class="lineNum">    3178 </span><span class="lineCov">       4617 :       ((integer_type_constant &amp;&amp; con_type-&gt;variant.integer.enum_type &amp;&amp;</span></a>
<a name="3179"><span class="lineNum">    3179 </span>            :       /* Don't do this in the C-generating back end when generating K&amp;R C,</a>
<a name="3180"><span class="lineNum">    3180 </span>            :          because enum types don't appear. */</a>
<a name="3181"><span class="lineNum">    3181 </span><span class="lineNoCov">          0 :         !(octl-&gt;c_generating_back_end &amp;&amp; octl-&gt;gen_pcc_code)) ||</span></a>
<a name="3182"><span class="lineNum">    3182 </span>            :       /* ... or, it's a constant that's shorter than int, ... */</a>
<a name="3183"><span class="lineNum">    3183 </span><span class="lineCov">       4617 :        (integer_type_constant &amp;&amp; (int)ikind &lt; (int)ik_int &amp;&amp;</span></a>
<a name="3184"><span class="lineNum">    3184 </span><span class="lineCov">       4617 :         !octl-&gt;suppress_cast_on_short_integral_const) ||</span></a>
<a name="3185"><span class="lineNum">    3185 </span>            :       /* ... or, we're generating K&amp;R C and it's an unsigned constant</a>
<a name="3186"><span class="lineNum">    3186 </span>            :          (pcc doesn't support unsigned integral constants), ... */</a>
<a name="3187"><span class="lineNum">    3187 </span><span class="lineNoCov">          0 :         (!signed_constant &amp;&amp; octl-&gt;gen_pcc_code))) {</span></a>
<a name="3188"><span class="lineNum">    3188 </span>            :     /* ... then prefix the constant with an explicit cast. */</a>
<a name="3189"><span class="lineNum">    3189 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens, &amp;need_cast_close_paren, octl);</span></a>
<a name="3190"><span class="lineNum">    3190 </span><span class="lineNoCov">          0 :     form_cast(constant-&gt;type, octl);</span></a>
<a name="3191"><span class="lineNum">    3191 </span>            :   }  /* if */</a>
<a name="3192"><span class="lineNum">    3192 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="3193"><span class="lineNum">    3193 </span><span class="lineCov">       4617 :   if (constant-&gt;kind == (a_constant_repr_kind)ck_label_difference) {</span></a>
<a name="3194"><span class="lineNum">    3194 </span><span class="lineNoCov">          0 :     form_label_difference_constant(constant, need_parens, octl);</span></a>
<a name="3195"><span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     goto close_paren_if_needed;</span></a>
<a name="3196"><span class="lineNum">    3196 </span>            :   }  /* if */</a>
<a name="3197"><span class="lineNum">    3197 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="3198"><span class="lineNum">    3198 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="3199"><span class="lineNum">    3199 </span><span class="lineCov">       4617 :   if (constant-&gt;kind == (a_constant_repr_kind)ck_upc_threads) {</span></a>
<a name="3200"><span class="lineNum">    3200 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="3201"><span class="lineNum">    3201 </span>            :   } else</a>
<a name="3202"><span class="lineNum">    3202 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="3203"><span class="lineNum">    3203 </span>            :   /* Do not insert code here. */</a>
<a name="3204"><span class="lineNum">    3204 </span>            :   {</a>
<a name="3205"><span class="lineNum">    3205 </span><span class="lineCov">       4617 :     check_assertion(constant-&gt;kind == (a_constant_repr_kind)ck_integer);</span></a>
<a name="3206"><span class="lineNum">    3206 </span>            :   }  /* if */</a>
<a name="3207"><span class="lineNum">    3207 </span><span class="lineCov">       4617 :   if (signed_constant &amp;&amp; sign_of_integer_constant(constant) &lt; 0) {</span></a>
<a name="3208"><span class="lineNum">    3208 </span>            :     /* Negative value.  Put in parentheses. */</a>
<a name="3209"><span class="lineNum">    3209 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens, &amp;need_negative_close_paren, octl);</span></a>
<a name="3210"><span class="lineNum">    3210 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_compilable_code) {</span></a>
<a name="3211"><span class="lineNum">    3211 </span>            :       /* Check for cases on two's complement machines where the constant</a>
<a name="3212"><span class="lineNum">    3212 </span>            :          cannot be represented as a positive constant preceded by a minus</a>
<a name="3213"><span class="lineNum">    3213 </span>            :          sign.  For those cases, use the -INT_MAX-1 trick.  One reason</a>
<a name="3214"><span class="lineNum">    3214 </span>            :          we do this is so that the type of the constant is right. */</a>
<a name="3215"><span class="lineNum">    3215 </span><span class="lineNoCov">          0 :       *local_con = *constant;</span></a>
<a name="3216"><span class="lineNum">    3216 </span><span class="lineNoCov">          0 :       negate_integer_value(&amp;local_con-&gt;variant.integer_value, &amp;err);</span></a>
<a name="3217"><span class="lineNum">    3217 </span>            :       /* coverity[uninit_use_in_call] */</a>
<a name="3218"><span class="lineNum">    3218 </span><span class="lineNoCov">          0 :       if (!err &amp;&amp;</span></a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineNoCov">          0 :           le_max_integer_value_of_kind(&amp;local_con-&gt;variant.integer_value,</span></a>
<a name="3220"><span class="lineNum">    3220 </span>            :                                        /*is_signed=*/TRUE, ikind)) {</a>
<a name="3221"><span class="lineNum">    3221 </span>            :         /* The negative of the constant is a legal constant. */</a>
<a name="3222"><span class="lineNum">    3222 </span>            :       } else {</a>
<a name="3223"><span class="lineNum">    3223 </span>            :         /* The negative of the constant is not legal.  Use the -INT_MAX-1</a>
<a name="3224"><span class="lineNum">    3224 </span>            :            trick. */</a>
<a name="3225"><span class="lineNum">    3225 </span><span class="lineNoCov">          0 :         minus_1_trick = TRUE;</span></a>
<a name="3226"><span class="lineNum">    3226 </span><span class="lineNoCov">          0 :         *local_con = *constant;</span></a>
<a name="3227"><span class="lineNum">    3227 </span><span class="lineNoCov">          0 :         eff_constant = local_con;</span></a>
<a name="3228"><span class="lineNum">    3228 </span><span class="lineNoCov">          0 :         incr_integer_value(&amp;local_con-&gt;variant.integer_value);</span></a>
<a name="3229"><span class="lineNum">    3229 </span>            :       }  /* if */</a>
<a name="3230"><span class="lineNum">    3230 </span>            :     }  /* if */</a>
<a name="3231"><span class="lineNum">    3231 </span>            :   }  /* if */</a>
<a name="3232"><span class="lineNum">    3232 </span>            :   /* Write the literal form of the constant. */</a>
<a name="3233"><span class="lineNum">    3233 </span><span class="lineCov">       4617 :   if (octl-&gt;gen_compilable_code) {</span></a>
<a name="3234"><span class="lineNum">    3234 </span>            :     /* In compilable code, we want to represent non-arithmetic integer</a>
<a name="3235"><span class="lineNum">    3235 </span>            :        constants in hexadecimal. */</a>
<a name="3236"><span class="lineNum">    3236 </span><span class="lineCov">       4617 :     literal_form = str_for_integer_constant(eff_constant);</span></a>
<a name="3237"><span class="lineNum">    3237 </span>            :   } else {</a>
<a name="3238"><span class="lineNum">    3238 </span>            :     /* In diagnostics and debugging output, always use decimal. */</a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineNoCov">          0 :     literal_form = decimal_str_for_integer_constant(eff_constant);</span></a>
<a name="3240"><span class="lineNum">    3240 </span>            :   }  /* if */</a>
<a name="3241"><span class="lineNum">    3241 </span><span class="lineCov">       4617 :   output_partial_token_str(literal_form, octl);</span></a>
<a name="3242"><span class="lineNum">    3242 </span><span class="lineCov">       4617 :   if (!octl-&gt;part_of_ud_literal) {</span></a>
<a name="3243"><span class="lineNum">    3243 </span>            :     /* Put out a suffix if needed.  The suffix must be suppressed for the</a>
<a name="3244"><span class="lineNum">    3244 </span>            :        numeric part of a user-defined literal lest it be considered part of</a>
<a name="3245"><span class="lineNum">    3245 </span>            :        the literal suffix. */</a>
<a name="3246"><span class="lineNum">    3246 </span>            :     /* Unsigned suffix is only valid in ANSI C.  When generating K&amp;R C,</a>
<a name="3247"><span class="lineNum">    3247 </span>            :        a prefix cast is used (see above). */</a>
<a name="3248"><span class="lineNum">    3248 </span><span class="lineCov">       4617 :     if (!signed_constant &amp;&amp; !octl-&gt;gen_pcc_code) {</span></a>
<a name="3249"><span class="lineNum">    3249 </span>            :       /* Unsigned constant. */</a>
<a name="3250"><span class="lineNum">    3250 </span><span class="lineNoCov">          0 :       output_partial_token_str(&quot;U&quot;, octl);</span></a>
<a name="3251"><span class="lineNum">    3251 </span>            :     }  /* if */</a>
<a name="3252"><span class="lineNum">    3252 </span><span class="lineCov">       4617 :     if (integer_type_constant) {</span></a>
<a name="3253"><span class="lineNum">    3253 </span>            :       /* Add length suffixes if appropriate. */</a>
<a name="3254"><span class="lineNum">    3254 </span><span class="lineCov">       4617 :       if (ikind == (an_integer_kind)ik_long           ||</span></a>
<a name="3255"><span class="lineNum">    3255 </span>            :           ikind == (an_integer_kind)ik_unsigned_long) {</a>
<a name="3256"><span class="lineNum">    3256 </span><span class="lineCov">         20 :         output_partial_token_str(&quot;L&quot;, octl);</span></a>
<a name="3257"><span class="lineNum">    3257 </span>            :   #if LONG_LONG_ALLOWED</a>
<a name="3258"><span class="lineNum">    3258 </span><span class="lineCov">       4597 :       } else if (ikind == (an_integer_kind)ik_long_long ||</span></a>
<a name="3259"><span class="lineNum">    3259 </span>            :                  ikind == (an_integer_kind)ik_unsigned_long_long) {</a>
<a name="3260"><span class="lineNum">    3260 </span><span class="lineNoCov">          0 :         if (use_microsoft_form()) {</span></a>
<a name="3261"><span class="lineNum">    3261 </span><span class="lineNoCov">          0 :           output_partial_token_str(&quot;i64&quot;, octl);</span></a>
<a name="3262"><span class="lineNum">    3262 </span>            :         } else {</a>
<a name="3263"><span class="lineNum">    3263 </span><span class="lineNoCov">          0 :           output_partial_token_str(&quot;LL&quot;, octl);</span></a>
<a name="3264"><span class="lineNum">    3264 </span>            :         }  /* if */</a>
<a name="3265"><span class="lineNum">    3265 </span>            :   #endif /* LONG_LONG_ALLOWED */</a>
<a name="3266"><span class="lineNum">    3266 </span>            :       }  /* if */</a>
<a name="3267"><span class="lineNum">    3267 </span>            :     }  /* if */</a>
<a name="3268"><span class="lineNum">    3268 </span>            :   }  /* if */</a>
<a name="3269"><span class="lineNum">    3269 </span><span class="lineCov">       4617 :   if (minus_1_trick) octl-&gt;output_str(&quot;-1&quot;, octl);</span></a>
<a name="3270"><span class="lineNum">    3270 </span><span class="lineCov">       4617 :   output_optional_close_paren(need_negative_close_paren, octl);</span></a>
<a name="3271"><span class="lineNum">    3271 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="3272"><span class="lineNum">    3272 </span><span class="lineCov">       4617 :   if (constant-&gt;kind == (a_constant_repr_kind)ck_upc_threads) {</span></a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;*THREADS)&quot;, octl);</span></a>
<a name="3274"><span class="lineNum">    3274 </span>            :   }  /* if */</a>
<a name="3275"><span class="lineNum">    3275 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="3276"><span class="lineNum">    3276 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="3277"><span class="lineNum">    3277 </span><span class="lineCov">       4617 : close_paren_if_needed:</span></a>
<a name="3278"><span class="lineNum">    3278 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="3279"><span class="lineNum">    3279 </span><span class="lineCov">       4617 :   output_optional_close_paren(need_cast_close_paren, octl);</span></a>
<a name="3280"><span class="lineNum">    3280 </span><span class="lineCov">       4617 :   release_local_constant(&amp;local_con);</span></a>
<a name="3281"><span class="lineNum">    3281 </span><span class="lineCov">       4617 : }  /* form_integer_constant */</span></a>
<a name="3282"><span class="lineNum">    3282 </span>            : </a>
<a name="3283"><span class="lineNum">    3283 </span>            : </a>
<a name="3284"><span class="lineNum">    3284 </span><span class="lineCov">      13612 : int form_char(char                                  ch,</span></a>
<a name="3285"><span class="lineNum">    3285 </span>            :               an_il_to_str_output_control_block_ptr octl)</a>
<a name="3286"><span class="lineNum">    3286 </span>            : /*</a>
<a name="3287"><span class="lineNum">    3287 </span>            : Output the indicated character as part of a string literal or character</a>
<a name="3288"><span class="lineNum">    3288 </span>            : constant.  Handle unprintable characters and necessary escapes.  Do the</a>
<a name="3289"><span class="lineNum">    3289 </span>            : output in the way described by octl.  Return the number of characters</a>
<a name="3290"><span class="lineNum">    3290 </span>            : output.</a>
<a name="3291"><span class="lineNum">    3291 </span>            : */</a>
<a name="3292"><span class="lineNum">    3292 </span>            : {</a>
<a name="3293"><span class="lineNum">    3293 </span><span class="lineCov">      13612 :   char buffer[10];</span></a>
<a name="3294"><span class="lineNum">    3294 </span><span class="lineCov">      13612 :   char *bptr = buffer;</span></a>
<a name="3295"><span class="lineNum">    3295 </span><span class="lineCov">      13612 :   int  nchars = 1;</span></a>
<a name="3296"><span class="lineNum">    3296 </span>            : </a>
<a name="3297"><span class="lineNum">    3297 </span><span class="lineCov">      13612 :   if ((isprint((unsigned char)ch) &amp;&amp;</span></a>
<a name="3298"><span class="lineNum">    3298 </span>            :        /* Render extended characters as octal escapes in compilable code to</a>
<a name="3299"><span class="lineNum">    3299 </span>            :           avoid potential misinterpretation in a different code page: */</a>
<a name="3300"><span class="lineNum">    3300 </span><span class="lineCov">      13572 :        !(octl-&gt;gen_compilable_code &amp;&amp; ((unsigned char)ch) &gt; 0x7f)</span></a>
<a name="3301"><span class="lineNum">    3301 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="3302"><span class="lineNum">    3302 </span>            :        /* The Sun cc (4.1.2) in -O mode when outputting assembly language</a>
<a name="3303"><span class="lineNum">    3303 </span>            :           has a bug that transforms quote into accent grave.  Avoid it. */</a>
<a name="3304"><span class="lineNum">    3304 </span><span class="lineCov">      13572 :        &amp;&amp; !(sun_is_generated_code_target &amp;&amp; ch == '\'')</span></a>
<a name="3305"><span class="lineNum">    3305 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="3306"><span class="lineNum">    3306 </span><span class="lineCov">         40 :                                                        ) ||</span></a>
<a name="3307"><span class="lineNum">    3307 </span><span class="lineNoCov">          0 :       (ch == '\t' &amp;&amp; octl-&gt;gen_raw_tab_in_literals)) {</span></a>
<a name="3308"><span class="lineNum">    3308 </span>            :     /* Escape some characters, e.g., quotes. */</a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">      13572 :     if (ch == '&quot;' || ch == '\'' || ch == '\\' ||</span></a>
<a name="3310"><span class="lineNum">    3310 </span>            :         /* Avoid accidentally putting out trigraphs by escaping &quot;?&quot;. */</a>
<a name="3311"><span class="lineNum">    3311 </span><span class="lineNoCov">          0 :         (ch == '?' &amp;&amp; octl-&gt;gen_compilable_code &amp;&amp; !octl-&gt;gen_pcc_code)) {</span></a>
<a name="3312"><span class="lineNum">    3312 </span><span class="lineCov">         16 :       *bptr++ = '\\';</span></a>
<a name="3313"><span class="lineNum">    3313 </span><span class="lineCov">         16 :       nchars++;</span></a>
<a name="3314"><span class="lineNum">    3314 </span>            :     }  /* if */</a>
<a name="3315"><span class="lineNum">    3315 </span><span class="lineCov">      13572 :     *bptr++ = ch;</span></a>
<a name="3316"><span class="lineNum">    3316 </span><span class="lineCov">      13572 :     *bptr = '\0';</span></a>
<a name="3317"><span class="lineNum">    3317 </span>            :   } else {</a>
<a name="3318"><span class="lineNum">    3318 </span><span class="lineCov">         40 :     char c = 0;</span></a>
<a name="3319"><span class="lineNum">    3319 </span>            :     /* Look for unprintable characters with specific escape codes. */</a>
<a name="3320"><span class="lineNum">    3320 </span><span class="lineCov">         40 :     switch (ch) {</span></a>
<a name="3321"><span class="lineNum">    3321 </span>            :                                   /* pcc does not recognize \a.  Also, some</a>
<a name="3322"><span class="lineNum">    3322 </span>            :                                      SVR4 compilers give a warning on it. */</a>
<a name="3323"><span class="lineNum">    3323 </span><span class="lineNoCov">          0 :       case TARG_ALERT_CHAR:       if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="3324"><span class="lineNum">    3324 </span>            :                                       !octl-&gt;gen_pcc_code) c = 'a';</a>
<a name="3325"><span class="lineNum">    3325 </span>            :                                   break;</a>
<a name="3326"><span class="lineNum">    3326 </span><span class="lineNoCov">          0 :       case TARG_BACKSPACE_CHAR:   c = 'b'; break;</span></a>
<a name="3327"><span class="lineNum">    3327 </span><span class="lineNoCov">          0 :       case TARG_FORM_FEED_CHAR:   c = 'f'; break;</span></a>
<a name="3328"><span class="lineNum">    3328 </span><span class="lineCov">         40 :       case TARG_NEWLINE_CHAR:     c = 'n'; break;</span></a>
<a name="3329"><span class="lineNum">    3329 </span><span class="lineNoCov">          0 :       case TARG_CARR_RETURN_CHAR: c = 'r'; break;</span></a>
<a name="3330"><span class="lineNum">    3330 </span><span class="lineNoCov">          0 :       case TARG_HORIZ_TAB_CHAR:   c = 't'; break;</span></a>
<a name="3331"><span class="lineNum">    3331 </span>            :       case TARG_VERT_TAB_CHAR:    c = 'v'; break;</a>
<a name="3332"><span class="lineNum">    3332 </span>            :       /* Default case: no escape sequence is defined. */</a>
<a name="3333"><span class="lineNum">    3333 </span>            :       default:                    break;</a>
<a name="3334"><span class="lineNum">    3334 </span>            :     }  /* switch */</a>
<a name="3335"><span class="lineNum">    3335 </span><span class="lineCov">         40 :     if (c != 0) {</span></a>
<a name="3336"><span class="lineNum">    3336 </span>            :       /* Use a defined escape code. */</a>
<a name="3337"><span class="lineNum">    3337 </span><span class="lineCov">         40 :       buffer[0] = '\\';</span></a>
<a name="3338"><span class="lineNum">    3338 </span><span class="lineCov">         40 :       buffer[1] = c;</span></a>
<a name="3339"><span class="lineNum">    3339 </span><span class="lineCov">         40 :       buffer[2] = '\0';</span></a>
<a name="3340"><span class="lineNum">    3340 </span><span class="lineCov">         40 :       nchars = 2;</span></a>
<a name="3341"><span class="lineNum">    3341 </span>            :     } else {</a>
<a name="3342"><span class="lineNum">    3342 </span>            :       /* Use the \nnn form for other unprintable characters. */</a>
<a name="3343"><span class="lineNum">    3343 </span><span class="lineNoCov">          0 :       (void)sprintf(buffer, &quot;\\%03o&quot;,</span></a>
<a name="3344"><span class="lineNum">    3344 </span><span class="lineNoCov">          0 :                     (unsigned int)(ch&amp;((1&lt;&lt;targ_host_string_char_bit)-1)));</span></a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineNoCov">          0 :       nchars = 4;</span></a>
<a name="3346"><span class="lineNum">    3346 </span>            :     }  /* if */</a>
<a name="3347"><span class="lineNum">    3347 </span>            :   }  /* if */</a>
<a name="3348"><span class="lineNum">    3348 </span>            :   /* Output the character. */</a>
<a name="3349"><span class="lineNum">    3349 </span><span class="lineCov">      13612 :   output_partial_token_str(buffer, octl);</span></a>
<a name="3350"><span class="lineNum">    3350 </span><span class="lineCov">      13612 :   return nchars;</span></a>
<a name="3351"><span class="lineNum">    3351 </span>            : }  /* form_char */</a>
<a name="3352"><span class="lineNum">    3352 </span>            : </a>
<a name="3353"><span class="lineNum">    3353 </span>            : </a>
<a name="3354"><span class="lineNum">    3354 </span><span class="lineNoCov">          0 : static int form_wide_char(unsigned long                         wc,</span></a>
<a name="3355"><span class="lineNum">    3355 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="3356"><span class="lineNum">    3356 </span>            : /*</a>
<a name="3357"><span class="lineNum">    3357 </span>            : Output the indicated wide character (which may be a wchar_t, char16_t, or</a>
<a name="3358"><span class="lineNum">    3358 </span>            : char32_t character) as part of a string literal or character constant.</a>
<a name="3359"><span class="lineNum">    3359 </span>            : Handle unprintable characters and necessary escapes.  Do the output in the</a>
<a name="3360"><span class="lineNum">    3360 </span>            : way described by octl.  Return the number of characters output.</a>
<a name="3361"><span class="lineNum">    3361 </span>            : */</a>
<a name="3362"><span class="lineNum">    3362 </span>            : {</a>
<a name="3363"><span class="lineNum">    3363 </span><span class="lineNoCov">          0 :   int   result;</span></a>
<a name="3364"><span class="lineNum">    3364 </span><span class="lineNoCov">          0 :   char  buffer[2*sizeof(unsigned long)+3];</span></a>
<a name="3365"><span class="lineNum">    3365 </span>            : </a>
<a name="3366"><span class="lineNum">    3366 </span>            :   /* Use hex escapes always to avoid having to convert the wide character</a>
<a name="3367"><span class="lineNum">    3367 </span>            :      back to a multibyte character string. */</a>
<a name="3368"><span class="lineNum">    3368 </span><span class="lineNoCov">          0 :   (void)sprintf(buffer, &quot;\\x%lx&quot;, wc);</span></a>
<a name="3369"><span class="lineNum">    3369 </span><span class="lineNoCov">          0 :   result = (int)strlen(buffer);</span></a>
<a name="3370"><span class="lineNum">    3370 </span>            :   /* Output the character. */</a>
<a name="3371"><span class="lineNum">    3371 </span><span class="lineNoCov">          0 :   output_partial_token_str(buffer, octl);</span></a>
<a name="3372"><span class="lineNum">    3372 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="3373"><span class="lineNum">    3373 </span>            : }  /* form_wide_char */</a>
<a name="3374"><span class="lineNum">    3374 </span>            : </a>
<a name="3375"><span class="lineNum">    3375 </span>            : </a>
<a name="3376"><span class="lineNum">    3376 </span>            : static void form_pm_base_casts(a_derivation_step_ptr                path,</a>
<a name="3377"><span class="lineNum">    3377 </span>            :                               a_type_ptr                            pm_type,</a>
<a name="3378"><span class="lineNum">    3378 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="3379"><span class="lineNum">    3379 </span>            : /*</a>
<a name="3380"><span class="lineNum">    3380 </span>            : Output casts to cast a pointer-to-member constant to a pointer-to-member</a>
<a name="3381"><span class="lineNum">    3381 </span>            : of a base class (this requires an explicit cast).  path is the derivation</a>
<a name="3382"><span class="lineNum">    3382 </span>            : path to the base class.  pm_type is the pointer-to-member type we want</a>
<a name="3383"><span class="lineNum">    3383 </span>            : to end up with.  Do the output in the way described by octl.</a>
<a name="3384"><span class="lineNum">    3384 </span>            : */</a>
<a name="3385"><span class="lineNum">    3385 </span>            : {</a>
<a name="3386"><span class="lineNum">    3386 </span>            :   a_type temp_type;</a>
<a name="3387"><span class="lineNum">    3387 </span>            : </a>
<a name="3388"><span class="lineNum">    3388 </span>            :   check_assertion(pm_type-&gt;kind == (a_type_kind)tk_ptr_to_member);</a>
<a name="3389"><span class="lineNum">    3389 </span>            :   /* Generate a cast for each derivation step in case there are ambiguities</a>
<a name="3390"><span class="lineNum">    3390 </span>            :      etc.  They have to be put out in reverse order, since the last cast</a>
<a name="3391"><span class="lineNum">    3391 </span>            :      comes first in the source. */</a>
<a name="3392"><span class="lineNum">    3392 </span>            :   if (path-&gt;next == NULL) {</a>
<a name="3393"><span class="lineNum">    3393 </span>            :     /* Don't do the last step, since it is done at the top of form_constant</a>
<a name="3394"><span class="lineNum">    3394 </span>            :        because the implicit_cast flag is set. */</a>
<a name="3395"><span class="lineNum">    3395 </span>            :   } else {</a>
<a name="3396"><span class="lineNum">    3396 </span>            :     /* Use a recursive call to process all the steps after the first one. */</a>
<a name="3397"><span class="lineNum">    3397 </span>            :     form_pm_base_casts(path-&gt;next, pm_type, octl);</a>
<a name="3398"><span class="lineNum">    3398 </span>            :     /* Make a temporary pointer-to-member type with the right class type by</a>
<a name="3399"><span class="lineNum">    3399 </span>            :        modifying a copy of the pm_type. */</a>
<a name="3400"><span class="lineNum">    3400 </span>            :     temp_type = *pm_type;</a>
<a name="3401"><span class="lineNum">    3401 </span>            :     temp_type.variant.ptr_to_member.class_of_which_a_member =</a>
<a name="3402"><span class="lineNum">    3402 </span>            :                                                         path-&gt;base_class-&gt;type;</a>
<a name="3403"><span class="lineNum">    3403 </span>            :     /* Generate the cast for the first step. */</a>
<a name="3404"><span class="lineNum">    3404 </span>            :     form_cast(&amp;temp_type, octl);</a>
<a name="3405"><span class="lineNum">    3405 </span>            :   }  /* for */</a>
<a name="3406"><span class="lineNum">    3406 </span>            : }  /* form_pm_base_casts */</a>
<a name="3407"><span class="lineNum">    3407 </span>            : </a>
<a name="3408"><span class="lineNum">    3408 </span>            : </a>
<a name="3409"><span class="lineNum">    3409 </span><span class="lineNoCov">          0 : static void form_pm_derived_casts(</span></a>
<a name="3410"><span class="lineNum">    3410 </span>            :                                  a_derivation_step_ptr                 path,</a>
<a name="3411"><span class="lineNum">    3411 </span>            :                                  a_type_ptr                            pm_type,</a>
<a name="3412"><span class="lineNum">    3412 </span>            :                                  an_il_to_str_output_control_block_ptr octl)</a>
<a name="3413"><span class="lineNum">    3413 </span>            : /*</a>
<a name="3414"><span class="lineNum">    3414 </span>            : Output casts to cast a pointer-to-member constant to a pointer-to-member</a>
<a name="3415"><span class="lineNum">    3415 </span>            : of a derived class.  path is the derivation to the base class.  pm_type</a>
<a name="3416"><span class="lineNum">    3416 </span>            : is the pointer-to-member type we want to end up with.  Do the output in</a>
<a name="3417"><span class="lineNum">    3417 </span>            : the way described by octl.</a>
<a name="3418"><span class="lineNum">    3418 </span>            : */</a>
<a name="3419"><span class="lineNum">    3419 </span>            : {</a>
<a name="3420"><span class="lineNum">    3420 </span><span class="lineNoCov">          0 :   a_type temp_type;</span></a>
<a name="3421"><span class="lineNum">    3421 </span>            : </a>
<a name="3422"><span class="lineNum">    3422 </span><span class="lineNoCov">          0 :   check_assertion(pm_type-&gt;kind == (a_type_kind)tk_ptr_to_member);</span></a>
<a name="3423"><span class="lineNum">    3423 </span>            :   /* Generate a cast for each derivation step in case there are ambiguities</a>
<a name="3424"><span class="lineNum">    3424 </span>            :      etc.  The derivation is in reverse order, but we want to put it</a>
<a name="3425"><span class="lineNum">    3425 </span>            :      out in reverse order because the last cast comes first in the source,</a>
<a name="3426"><span class="lineNum">    3426 </span>            :      so a simple loop works right. */</a>
<a name="3427"><span class="lineNum">    3427 </span>            :   /* Don't do the last step, since it is done at the top of form_constant</a>
<a name="3428"><span class="lineNum">    3428 </span>            :      because the implicit_cast flag is set. */</a>
<a name="3429"><span class="lineNum">    3429 </span><span class="lineNoCov">          0 :   for (; path-&gt;next != NULL; path = path-&gt;next) {</span></a>
<a name="3430"><span class="lineNum">    3430 </span>            :     /* Make a temporary pointer-to-member type with the right class type by</a>
<a name="3431"><span class="lineNum">    3431 </span>            :        modifying a copy of the pm_type. */</a>
<a name="3432"><span class="lineNum">    3432 </span><span class="lineNoCov">          0 :     temp_type = *pm_type;</span></a>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineNoCov">          0 :     temp_type.variant.ptr_to_member.class_of_which_a_member =</span></a>
<a name="3434"><span class="lineNum">    3434 </span><span class="lineNoCov">          0 :                                                         path-&gt;base_class-&gt;type;</span></a>
<a name="3435"><span class="lineNum">    3435 </span>            :     /* Generate the cast for the first step. */</a>
<a name="3436"><span class="lineNum">    3436 </span><span class="lineNoCov">          0 :     form_cast(&amp;temp_type, octl);</span></a>
<a name="3437"><span class="lineNum">    3437 </span>            :   }  /* for */</a>
<a name="3438"><span class="lineNum">    3438 </span><span class="lineNoCov">          0 : }  /* form_pm_derived_casts */</span></a>
<a name="3439"><span class="lineNum">    3439 </span>            : </a>
<a name="3440"><span class="lineNum">    3440 </span>            : </a>
<a name="3441"><span class="lineNum">    3441 </span><span class="lineNoCov">          0 : void form_pm_constant(a_constant_ptr                        constant,</span></a>
<a name="3442"><span class="lineNum">    3442 </span>            :                       a_boolean                             minimal_casts,</a>
<a name="3443"><span class="lineNum">    3443 </span>            :                       a_boolean                             need_parens,</a>
<a name="3444"><span class="lineNum">    3444 </span>            :                       an_il_to_str_output_control_block_ptr octl)</a>
<a name="3445"><span class="lineNum">    3445 </span>            : /*</a>
<a name="3446"><span class="lineNum">    3446 </span>            : Output a pointer-to-member constant.  If minimal_casts is TRUE, suppress</a>
<a name="3447"><span class="lineNum">    3447 </span>            : any unnecessary casts in the generated form of the constant (casts that</a>
<a name="3448"><span class="lineNum">    3448 </span>            : serve just to disambiguate).  If need_parens is TRUE, parentheses are</a>
<a name="3449"><span class="lineNum">    3449 </span>            : placed around the constant if there's any possibility of precedence confusion.</a>
<a name="3450"><span class="lineNum">    3450 </span>            : Do the output in the way described by octl.</a>
<a name="3451"><span class="lineNum">    3451 </span>            : */</a>
<a name="3452"><span class="lineNum">    3452 </span>            : {</a>
<a name="3453"><span class="lineNum">    3453 </span><span class="lineNoCov">          0 :   a_type_ptr              orig_type = constant-&gt;type;</span></a>
<a name="3454"><span class="lineNum">    3454 </span><span class="lineNoCov">          0 :   a_type_ptr              con_type = skip_typerefs(orig_type);</span></a>
<a name="3455"><span class="lineNum">    3455 </span><span class="lineNoCov">          0 :   a_source_correspondence *scp = NULL;</span></a>
<a name="3456"><span class="lineNum">    3456 </span><span class="lineNoCov">          0 :   a_boolean               need_cast_close_paren = FALSE;</span></a>
<a name="3457"><span class="lineNum">    3457 </span><span class="lineNoCov">          0 :   an_il_entry_kind        entry_kind;</span></a>
<a name="3458"><span class="lineNum">    3458 </span><span class="lineNoCov">          0 :   a_base_class_ptr        bcp =</span></a>
<a name="3459"><span class="lineNum">    3459 </span>            :                             constant-&gt;variant.ptr_to_member.casting_base_class;</a>
<a name="3460"><span class="lineNum">    3460 </span><span class="lineNoCov">          0 :   a_boolean               function_case =</span></a>
<a name="3461"><span class="lineNum">    3461 </span><span class="lineNoCov">          0 :                                constant-&gt;variant.ptr_to_member.is_function_ptr;</span></a>
<a name="3462"><span class="lineNum">    3462 </span>            : </a>
<a name="3463"><span class="lineNum">    3463 </span>            :   /* See if this is a pointer to data member or pointer to member function. */</a>
<a name="3464"><span class="lineNum">    3464 </span><span class="lineNoCov">          0 :   if (function_case) {</span></a>
<a name="3465"><span class="lineNum">    3465 </span><span class="lineNoCov">          0 :     a_routine_ptr rout = constant-&gt;variant.ptr_to_member.variant.routine;</span></a>
<a name="3466"><span class="lineNum">    3466 </span><span class="lineNoCov">          0 :     if (rout != NULL) scp = &amp;rout-&gt;source_corresp;</span></a>
<a name="3467"><span class="lineNum">    3467 </span>            :     entry_kind = iek_routine;</a>
<a name="3468"><span class="lineNum">    3468 </span>            :   } else {</a>
<a name="3469"><span class="lineNum">    3469 </span><span class="lineNoCov">          0 :     a_field_ptr field = constant-&gt;variant.ptr_to_member.variant.field;</span></a>
<a name="3470"><span class="lineNum">    3470 </span><span class="lineNoCov">          0 :     if (field != NULL) scp = &amp;field-&gt;source_corresp;</span></a>
<a name="3471"><span class="lineNum">    3471 </span>            :     entry_kind = iek_field;</a>
<a name="3472"><span class="lineNum">    3472 </span>            :   }  /* if */</a>
<a name="3473"><span class="lineNum">    3473 </span>            :   /* If the constant is implicitly cast to another type, ... */</a>
<a name="3474"><span class="lineNum">    3474 </span><span class="lineNoCov">          0 :   if (constant-&gt;implicit_cast) {</span></a>
<a name="3475"><span class="lineNum">    3475 </span>            :     /* ... then optionally prefix the constant with an explicit cast. */</a>
<a name="3476"><span class="lineNum">    3476 </span><span class="lineNoCov">          0 :     if (!minimal_casts ||</span></a>
<a name="3477"><span class="lineNum">    3477 </span><span class="lineNoCov">          0 :         constant-&gt;variant.ptr_to_member.cast_to_base ||</span></a>
<a name="3478"><span class="lineNum">    3478 </span><span class="lineNoCov">          0 :         (bcp != NULL &amp;&amp; any_nonpublic_steps_in_derivation(bcp)) ||</span></a>
<a name="3479"><span class="lineNum">    3479 </span>            :         scp == NULL) {</a>
<a name="3480"><span class="lineNum">    3480 </span>            :       /* If minimal_casts is TRUE, we only output the explicit cast if:</a>
<a name="3481"><span class="lineNum">    3481 </span>            :          1) the cast is from a pointer-to-derived-member to a</a>
<a name="3482"><span class="lineNum">    3482 </span>            :             pointer-to-base-member, or</a>
<a name="3483"><span class="lineNum">    3483 </span>            :          2) there's a chance the base class might be inaccessible, or</a>
<a name="3484"><span class="lineNum">    3484 </span>            :          3) the operand of the cast is 0 rather than the address of a data</a>
<a name="3485"><span class="lineNum">    3485 </span>            :             member or member function. */</a>
<a name="3486"><span class="lineNum">    3486 </span><span class="lineNoCov">          0 :       output_optional_open_paren(&amp;need_parens, &amp;need_cast_close_paren, octl);</span></a>
<a name="3487"><span class="lineNum">    3487 </span><span class="lineNoCov">          0 :       form_cast(orig_type, octl);</span></a>
<a name="3488"><span class="lineNum">    3488 </span>            :     }  /* if */</a>
<a name="3489"><span class="lineNum">    3489 </span>            :   }  /* if */</a>
<a name="3490"><span class="lineNum">    3490 </span><span class="lineNoCov">          0 :   if (scp == NULL) {</span></a>
<a name="3491"><span class="lineNum">    3491 </span>            :     /* A null pointer-to-member.  implicit_cast will be TRUE, so a cast</a>
<a name="3492"><span class="lineNum">    3492 </span>            :        to the right type has been put out above. */</a>
<a name="3493"><span class="lineNum">    3493 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;0&quot;, octl);</span></a>
<a name="3494"><span class="lineNum">    3494 </span>            :   } else {</a>
<a name="3495"><span class="lineNum">    3495 </span>            :     /* A non-null pointer-to-member. */</a>
<a name="3496"><span class="lineNum">    3496 </span><span class="lineNoCov">          0 :     a_boolean need_pm_close_paren = FALSE;</span></a>
<a name="3497"><span class="lineNum">    3497 </span><span class="lineNoCov">          0 :     a_boolean force_qualified_name;</span></a>
<a name="3498"><span class="lineNum">    3498 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens, &amp;need_pm_close_paren, octl);</span></a>
<a name="3499"><span class="lineNum">    3499 </span><span class="lineNoCov">          0 :     if (!minimal_casts &amp;&amp; bcp != NULL) {</span></a>
<a name="3500"><span class="lineNum">    3500 </span>            :       /* The pointer-to-member has been cast to another class.  Put in</a>
<a name="3501"><span class="lineNum">    3501 </span>            :          proper casts.  Note that implicit_cast will be set and therefore</a>
<a name="3502"><span class="lineNum">    3502 </span>            :          the final cast has already been issued above. */</a>
<a name="3503"><span class="lineNum">    3503 </span><span class="lineNoCov">          0 :       if (bcp-&gt;is_virtual) {</span></a>
<a name="3504"><span class="lineNum">    3504 </span>            :         /* For virtual base classes, the single cast generated above is</a>
<a name="3505"><span class="lineNum">    3505 </span>            :            enough.  In fact, we don't want to choose among the possible</a>
<a name="3506"><span class="lineNum">    3506 </span>            :            paths to the virtual base class if there are several. */</a>
<a name="3507"><span class="lineNum">    3507 </span>            :       } else {</a>
<a name="3508"><span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         a_derivation_step_ptr path = bcp-&gt;derivation-&gt;path;</span></a>
<a name="3509"><span class="lineNum">    3509 </span>            :         /* Cast to the proper result type. */</a>
<a name="3510"><span class="lineNum">    3510 </span><span class="lineNoCov">          0 :         if (constant-&gt;variant.ptr_to_member.cast_to_base) {</span></a>
<a name="3511"><span class="lineNum">    3511 </span><span class="lineNoCov">          0 :           form_pm_base_casts(path, con_type, octl);</span></a>
<a name="3512"><span class="lineNum">    3512 </span>            :         } else {</a>
<a name="3513"><span class="lineNum">    3513 </span><span class="lineNoCov">          0 :           form_pm_derived_casts(path, con_type, octl);</span></a>
<a name="3514"><span class="lineNum">    3514 </span>            :         }  /* if */</a>
<a name="3515"><span class="lineNum">    3515 </span>            :       }  /* if */</a>
<a name="3516"><span class="lineNum">    3516 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="3517"><span class="lineNum">    3517 </span>            :       if (microsoft_mode &amp;&amp; microsoft_version &lt; 1100 &amp;&amp;</a>
<a name="3518"><span class="lineNum">    3518 </span>            :           octl-&gt;gen_compilable_code) {</a>
<a name="3519"><span class="lineNum">    3519 </span>            :         /* MSVC++ 4.2 doesn't like pointer-to-member casts that adjust both</a>
<a name="3520"><span class="lineNum">    3520 </span>            :            the base class and the member type, so add an extra cast to</a>
<a name="3521"><span class="lineNum">    3521 </span>            :            adjust the member type, if necessary. */</a>
<a name="3522"><span class="lineNum">    3522 </span>            :         a_type_ptr new_member_type = pm_member_type(con_type);</a>
<a name="3523"><span class="lineNum">    3523 </span>            :         a_type_ptr member_type = NULL, member_class = NULL;</a>
<a name="3524"><span class="lineNum">    3524 </span>            :         if (function_case) {</a>
<a name="3525"><span class="lineNum">    3525 </span>            :           a_routine_ptr rout = constant-&gt;variant.ptr_to_member.variant.routine;</a>
<a name="3526"><span class="lineNum">    3526 </span>            :           if (rout != NULL) {</a>
<a name="3527"><span class="lineNum">    3527 </span>            :             member_type = rout-&gt;type;</a>
<a name="3528"><span class="lineNum">    3528 </span>            :             member_class = parent_class_of(rout);</a>
<a name="3529"><span class="lineNum">    3529 </span>            :           }  /* if */</a>
<a name="3530"><span class="lineNum">    3530 </span>            :         } else {</a>
<a name="3531"><span class="lineNum">    3531 </span>            :           a_field_ptr field = constant-&gt;variant.ptr_to_member.variant.field;</a>
<a name="3532"><span class="lineNum">    3532 </span>            :           if (field != NULL) {</a>
<a name="3533"><span class="lineNum">    3533 </span>            :             member_type = field-&gt;type;</a>
<a name="3534"><span class="lineNum">    3534 </span>            :             member_class = parent_class_of(field);</a>
<a name="3535"><span class="lineNum">    3535 </span>            :           }  /* if */</a>
<a name="3536"><span class="lineNum">    3536 </span>            :         }  /* if */</a>
<a name="3537"><span class="lineNum">    3537 </span>            :         if (member_type != NULL &amp;&amp;</a>
<a name="3538"><span class="lineNum">    3538 </span>            :             standalone_identical_types(member_type, new_member_type)) {</a>
<a name="3539"><span class="lineNum">    3539 </span>            :           /* The cast is not needed if the old and new types are the</a>
<a name="3540"><span class="lineNum">    3540 </span>            :              same. */</a>
<a name="3541"><span class="lineNum">    3541 </span>            :           member_type = NULL;</a>
<a name="3542"><span class="lineNum">    3542 </span>            :         }  /* if */</a>
<a name="3543"><span class="lineNum">    3543 </span>            :         /* No cast is needed for a null pointer-to-member constant. */</a>
<a name="3544"><span class="lineNum">    3544 </span>            :         if (member_type != NULL) {</a>
<a name="3545"><span class="lineNum">    3545 </span>            :           /* Make a local pointer to member type and cast to it. */</a>
<a name="3546"><span class="lineNum">    3546 </span>            :           a_type temp_type;</a>
<a name="3547"><span class="lineNum">    3547 </span>            :           /* Can't call clear_type in a standalone program, so copy and</a>
<a name="3548"><span class="lineNum">    3548 </span>            :              modify an existing type. */</a>
<a name="3549"><span class="lineNum">    3549 </span>            :           temp_type = *con_type;</a>
<a name="3550"><span class="lineNum">    3550 </span>            :           temp_type.variant.ptr_to_member.type = new_member_type;</a>
<a name="3551"><span class="lineNum">    3551 </span>            :           temp_type.variant.ptr_to_member.class_of_which_a_member=member_class;</a>
<a name="3552"><span class="lineNum">    3552 </span>            :           form_cast(&amp;temp_type, octl);</a>
<a name="3553"><span class="lineNum">    3553 </span>            :         }  /* if */</a>
<a name="3554"><span class="lineNum">    3554 </span>            :       }  /* if */</a>
<a name="3555"><span class="lineNum">    3555 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="3556"><span class="lineNum">    3556 </span>            :     }  /* if */</a>
<a name="3557"><span class="lineNum">    3557 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="3558"><span class="lineNum">    3558 </span>            :     /* Output the name, either in the original form or as a qualified</a>
<a name="3559"><span class="lineNum">    3559 </span>            :        name. */</a>
<a name="3560"><span class="lineNum">    3560 </span><span class="lineNoCov">          0 :     if (constant-&gt;variant.ptr_to_member.name_reference != NULL) {</span></a>
<a name="3561"><span class="lineNum">    3561 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="3562"><span class="lineNum">    3562 </span><span class="lineNoCov">          0 :       if (constant-&gt;variant.ptr_to_member.name_reference-&gt;qualifier == NULL &amp;&amp;</span></a>
<a name="3563"><span class="lineNum">    3563 </span><span class="lineNoCov">          0 :           use_microsoft_form() &amp;&amp; msvc_target_version_number &lt; 1310) {</span></a>
<a name="3564"><span class="lineNum">    3564 </span>            :         /* MSVC++ versions before 7.1 sometimes get confused with an</a>
<a name="3565"><span class="lineNum">    3565 </span>            :            unqualified name in a pointer-to-member constant, so for those</a>
<a name="3566"><span class="lineNum">    3566 </span>            :            versions we always use a qualified name, even if the source did</a>
<a name="3567"><span class="lineNum">    3567 </span>            :            not. */</a>
<a name="3568"><span class="lineNum">    3568 </span>            :         force_qualified_name = TRUE;</a>
<a name="3569"><span class="lineNum">    3569 </span>            :       } else</a>
<a name="3570"><span class="lineNum">    3570 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="3571"><span class="lineNum">    3571 </span>            :       /* Do not insert code here. */</a>
<a name="3572"><span class="lineNum">    3572 </span>            :       {</a>
<a name="3573"><span class="lineNum">    3573 </span>            :         /* If there is a special routine for name reference output, attempt</a>
<a name="3574"><span class="lineNum">    3574 </span>            :            to use it to put out the name.  If there is no special routine,</a>
<a name="3575"><span class="lineNum">    3575 </span>            :            or if the name was not emitted, put it out as a qualified</a>
<a name="3576"><span class="lineNum">    3576 </span>            :            name. */</a>
<a name="3577"><span class="lineNum">    3577 </span><span class="lineNoCov">          0 :         force_qualified_name =</span></a>
<a name="3578"><span class="lineNum">    3578 </span><span class="lineNoCov">          0 :                    !(octl-&gt;output_name_reference != NULL &amp;&amp;</span></a>
<a name="3579"><span class="lineNum">    3579 </span><span class="lineNoCov">          0 :                      octl-&gt;output_name_reference(</span></a>
<a name="3580"><span class="lineNum">    3580 </span>            :                                 constant-&gt;variant.ptr_to_member.name_reference,</a>
<a name="3581"><span class="lineNum">    3581 </span>            :                                 scp, entry_kind,</a>
<a name="3582"><span class="lineNum">    3582 </span>            :                                 /*is_declaration=*/FALSE,</a>
<a name="3583"><span class="lineNum">    3583 </span>            :                                 /*suppress_declarator_parens=*/FALSE));</a>
<a name="3584"><span class="lineNum">    3584 </span>            :       }</a>
<a name="3585"><span class="lineNum">    3585 </span>            :     } else {</a>
<a name="3586"><span class="lineNum">    3586 </span>            :       /* There's no name reference available; use a qualified name. */</a>
<a name="3587"><span class="lineNum">    3587 </span>            :       force_qualified_name = TRUE;</a>
<a name="3588"><span class="lineNum">    3588 </span>            :     }  /* if */</a>
<a name="3589"><span class="lineNum">    3589 </span>            :     if (force_qualified_name) {</a>
<a name="3590"><span class="lineNum">    3590 </span><span class="lineNoCov">          0 :       a_boolean saved_force_qualified_name = octl-&gt;force_qualified_name;</span></a>
<a name="3591"><span class="lineNum">    3591 </span><span class="lineNoCov">          0 :       octl-&gt;force_qualified_name = TRUE;</span></a>
<a name="3592"><span class="lineNum">    3592 </span><span class="lineNoCov">          0 :       form_name(scp, entry_kind, octl);</span></a>
<a name="3593"><span class="lineNum">    3593 </span><span class="lineNoCov">          0 :       octl-&gt;force_qualified_name = saved_force_qualified_name;</span></a>
<a name="3594"><span class="lineNum">    3594 </span>            :     }  /* if */</a>
<a name="3595"><span class="lineNum">    3595 </span><span class="lineNoCov">          0 :     output_optional_close_paren(need_pm_close_paren, octl);</span></a>
<a name="3596"><span class="lineNum">    3596 </span>            :   }  /* if */</a>
<a name="3597"><span class="lineNum">    3597 </span><span class="lineNoCov">          0 :   output_optional_close_paren(need_cast_close_paren, octl);</span></a>
<a name="3598"><span class="lineNum">    3598 </span><span class="lineNoCov">          0 : }  /* form_pm_constant */</span></a>
<a name="3599"><span class="lineNum">    3599 </span>            : </a>
<a name="3600"><span class="lineNum">    3600 </span>            : </a>
<a name="3601"><span class="lineNum">    3601 </span><span class="lineNoCov">          0 : static a_boolean types_match_ignoring_qualifiers(a_type_ptr type_1,</span></a>
<a name="3602"><span class="lineNum">    3602 </span>            :                                                  a_type_ptr type_2)</a>
<a name="3603"><span class="lineNum">    3603 </span>            : /*</a>
<a name="3604"><span class="lineNum">    3604 </span>            : Return TRUE if type_1 and type_2 are the same type ignoring type qualifiers.</a>
<a name="3605"><span class="lineNum">    3605 </span>            : This is used in deciding whether a particular lvalue formulation should</a>
<a name="3606"><span class="lineNum">    3606 </span>            : be used for an address constant; the differences allowed are ones that</a>
<a name="3607"><span class="lineNum">    3607 </span>            : can be bridged by a cast on an lvalue address.  This routine is similar to</a>
<a name="3608"><span class="lineNum">    3608 </span>            : same_type_with_added_qualifiers, but simpler, and needed here because</a>
<a name="3609"><span class="lineNum">    3609 </span>            : in il_to_str we can't use routines that aren't available to back ends</a>
<a name="3610"><span class="lineNum">    3610 </span>            : and standalone utility programs.</a>
<a name="3611"><span class="lineNum">    3611 </span>            : */</a>
<a name="3612"><span class="lineNum">    3612 </span>            : {</a>
<a name="3613"><span class="lineNum">    3613 </span><span class="lineNoCov">          0 :   a_boolean types_match = FALSE;</span></a>
<a name="3614"><span class="lineNum">    3614 </span>            : </a>
<a name="3615"><span class="lineNum">    3615 </span><span class="lineNoCov">          0 :   type_1 = skip_typerefs(type_1);</span></a>
<a name="3616"><span class="lineNum">    3616 </span><span class="lineNoCov">          0 :   type_2 = skip_typerefs(type_2);</span></a>
<a name="3617"><span class="lineNum">    3617 </span><span class="lineNoCov">          0 :   if (same_entities(type_1, type_2)) {</span></a>
<a name="3618"><span class="lineNum">    3618 </span>            :     types_match = TRUE;</a>
<a name="3619"><span class="lineNum">    3619 </span><span class="lineNoCov">          0 :   } else if (type_1-&gt;kind != type_2-&gt;kind) {</span></a>
<a name="3620"><span class="lineNum">    3620 </span>            :     /* Type kinds do not match, so types do not match. */</a>
<a name="3621"><span class="lineNum">    3621 </span>            :     /* types_match = FALSE; -- already set. */</a>
<a name="3622"><span class="lineNum">    3622 </span><span class="lineNoCov">          0 :   } else if (type_1-&gt;kind == (a_type_kind)tk_pointer</span></a>
<a name="3623"><span class="lineNum">    3623 </span>            : #ifdef pointer_types_have_same_repr</a>
<a name="3624"><span class="lineNum">    3624 </span>            :              &amp;&amp; pointer_types_have_same_repr(type_1, type_2)</a>
<a name="3625"><span class="lineNum">    3625 </span>            : #endif /* ifdef pointer_types_have_same_repr */</a>
<a name="3626"><span class="lineNum">    3626 </span><span class="lineNoCov">          0 :              &amp;&amp; type_1-&gt;variant.pointer.is_reference ==</span></a>
<a name="3627"><span class="lineNum">    3627 </span>            :                 type_2-&gt;variant.pointer.is_reference</a>
<a name="3628"><span class="lineNum">    3628 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="3629"><span class="lineNum">    3629 </span>            :              &amp;&amp; type_1-&gt;variant.pointer.is_handle == </a>
<a name="3630"><span class="lineNum">    3630 </span>            :                 type_2-&gt;variant.pointer.is_handle</a>
<a name="3631"><span class="lineNum">    3631 </span>            :              &amp;&amp; type_1-&gt;variant.pointer.is_interior_ptr == </a>
<a name="3632"><span class="lineNum">    3632 </span>            :                 type_2-&gt;variant.pointer.is_interior_ptr</a>
<a name="3633"><span class="lineNum">    3633 </span>            :              &amp;&amp; type_1-&gt;variant.pointer.is_pin_ptr == </a>
<a name="3634"><span class="lineNum">    3634 </span>            :                 type_2-&gt;variant.pointer.is_pin_ptr</a>
<a name="3635"><span class="lineNum">    3635 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="3636"><span class="lineNum">    3636 </span>            :             ) {</a>
<a name="3637"><span class="lineNum">    3637 </span>            :     /* Continue at the next level for pointers. */</a>
<a name="3638"><span class="lineNum">    3638 </span><span class="lineNoCov">          0 :     types_match = types_match_ignoring_qualifiers(type_pointed_to(type_1),</span></a>
<a name="3639"><span class="lineNum">    3639 </span>            :                                                   type_pointed_to(type_2));</a>
<a name="3640"><span class="lineNum">    3640 </span><span class="lineNoCov">          0 :   } else if (type_1-&gt;kind == (a_type_kind)tk_ptr_to_member) {</span></a>
<a name="3641"><span class="lineNum">    3641 </span><span class="lineNoCov">          0 :     a_type_ptr  class_type_1 = pm_class_type(type_1);</span></a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 :     a_type_ptr  class_type_2 = pm_class_type(type_2);</span></a>
<a name="3643"><span class="lineNum">    3643 </span><span class="lineNoCov">          0 :     if (same_entities(class_type_1, class_type_2)) {</span></a>
<a name="3644"><span class="lineNum">    3644 </span>            :       /* Continue at the next level for pointers to members. */</a>
<a name="3645"><span class="lineNum">    3645 </span><span class="lineNoCov">          0 :       types_match = types_match_ignoring_qualifiers(pm_member_type(type_1),</span></a>
<a name="3646"><span class="lineNum">    3646 </span>            :                                                     pm_member_type(type_2));</a>
<a name="3647"><span class="lineNum">    3647 </span>            :     }  /* if */</a>
<a name="3648"><span class="lineNum">    3648 </span><span class="lineNoCov">          0 :   } else if (!C_mode() &amp;&amp;</span></a>
<a name="3649"><span class="lineNum">    3649 </span><span class="lineNoCov">          0 :              type_1-&gt;kind == (a_type_kind)tk_array &amp;&amp;</span></a>
<a name="3650"><span class="lineNum">    3650 </span><span class="lineNoCov">          0 :              !has_unknown_specified_bound(type_1) &amp;&amp;</span></a>
<a name="3651"><span class="lineNum">    3651 </span><span class="lineNoCov">          0 :              !has_unknown_specified_bound(type_2) &amp;&amp;</span></a>
<a name="3652"><span class="lineNum">    3652 </span><span class="lineNoCov">          0 :              type_1-&gt;variant.array.variant.number_of_elements ==</span></a>
<a name="3653"><span class="lineNum">    3653 </span><span class="lineNoCov">          0 :                             type_2-&gt;variant.array.variant.number_of_elements) {</span></a>
<a name="3654"><span class="lineNum">    3654 </span>            :     /* Continue at the next level for arrays (in C++ mode, the qualifiers on</a>
<a name="3655"><span class="lineNum">    3655 </span>            :        array element types count as qualifiers on the array). */</a>
<a name="3656"><span class="lineNum">    3656 </span><span class="lineNoCov">          0 :     types_match = types_match_ignoring_qualifiers(array_element_type(type_1),</span></a>
<a name="3657"><span class="lineNum">    3657 </span>            :                                                   array_element_type(type_2));</a>
<a name="3658"><span class="lineNum">    3658 </span>            :   }  /* if */</a>
<a name="3659"><span class="lineNum">    3659 </span><span class="lineNoCov">          0 :   return types_match;</span></a>
<a name="3660"><span class="lineNum">    3660 </span>            : }  /* types_match_ignoring_qualifiers */</a>
<a name="3661"><span class="lineNum">    3661 </span>            : </a>
<a name="3662"><span class="lineNum">    3662 </span>            : </a>
<a name="3663"><span class="lineNum">    3663 </span><span class="lineNoCov">          0 : static a_boolean type_matches_desired_type(a_type_ptr type,</span></a>
<a name="3664"><span class="lineNum">    3664 </span>            :                                            a_type_ptr desired_type,</a>
<a name="3665"><span class="lineNum">    3665 </span>            :                                            a_boolean  will_use_as_addr,</a>
<a name="3666"><span class="lineNum">    3666 </span>            :                                            a_boolean  *type_decay_used)</a>
<a name="3667"><span class="lineNum">    3667 </span>            : /*</a>
<a name="3668"><span class="lineNum">    3668 </span>            : Return TRUE if type is the same as desired_type, for the purpose of</a>
<a name="3669"><span class="lineNum">    3669 </span>            : forming an lvalue as part of generating an address constant.</a>
<a name="3670"><span class="lineNum">    3670 </span>            : If will_use_as_addr is TRUE, array-to-pointer decay can be considered</a>
<a name="3671"><span class="lineNum">    3671 </span>            : in the match-up.  If type decay is used in making the match, return</a>
<a name="3672"><span class="lineNum">    3672 </span>            : *type_decay_used TRUE.</a>
<a name="3673"><span class="lineNum">    3673 </span>            : */</a>
<a name="3674"><span class="lineNum">    3674 </span>            : {</a>
<a name="3675"><span class="lineNum">    3675 </span><span class="lineNoCov">          0 :   a_boolean type_matches = FALSE;</span></a>
<a name="3676"><span class="lineNum">    3676 </span>            : </a>
<a name="3677"><span class="lineNum">    3677 </span><span class="lineNoCov">          0 :   *type_decay_used = FALSE;</span></a>
<a name="3678"><span class="lineNum">    3678 </span>            :   /* Check for the same type, ignoring qualifier differences. */</a>
<a name="3679"><span class="lineNum">    3679 </span><span class="lineNoCov">          0 :   if (type == desired_type ||  /* For speed. */</span></a>
<a name="3680"><span class="lineNum">    3680 </span><span class="lineNoCov">          0 :       types_match_ignoring_qualifiers(type, desired_type)) {</span></a>
<a name="3681"><span class="lineNum">    3681 </span>            :     type_matches = TRUE;</a>
<a name="3682"><span class="lineNum">    3682 </span><span class="lineNoCov">          0 :   } else if (will_use_as_addr) {</span></a>
<a name="3683"><span class="lineNum">    3683 </span>            :     /* Check for the decay cases.  Note that this is checked only when the</a>
<a name="3684"><span class="lineNum">    3684 </span>            :        result will be used as an address, and therefore will decay from an</a>
<a name="3685"><span class="lineNum">    3685 </span>            :        lvalue to an rvalue.  Note that desired_type is an lvalue type, but</a>
<a name="3686"><span class="lineNum">    3686 </span>            :        when will_use_as_addr is TRUE what we're really aiming for is</a>
<a name="3687"><span class="lineNum">    3687 </span>            :        pointer-to that type, e.g., if type is &quot;int[3]&quot; and desired_type</a>
<a name="3688"><span class="lineNum">    3688 </span>            :        is &quot;int&quot; there's a match, because the type after decay (&quot;int *&quot;)</a>
<a name="3689"><span class="lineNum">    3689 </span>            :        matches the type when you take the address of the lvalue.</a>
<a name="3690"><span class="lineNum">    3690 </span>            :        Note that under this formulation there's no need to check for</a>
<a name="3691"><span class="lineNum">    3691 </span>            :        the function decay, since it comes out the same as the first test</a>
<a name="3692"><span class="lineNum">    3692 </span>            :        above. */</a>
<a name="3693"><span class="lineNum">    3693 </span><span class="lineNoCov">          0 :     if (is_array_type(type)) {</span></a>
<a name="3694"><span class="lineNum">    3694 </span><span class="lineNoCov">          0 :       a_type_ptr element_type = array_element_type(type);</span></a>
<a name="3695"><span class="lineNum">    3695 </span><span class="lineNoCov">          0 :       if (types_match_ignoring_qualifiers(element_type, desired_type)) {</span></a>
<a name="3696"><span class="lineNum">    3696 </span><span class="lineNoCov">          0 :         type_matches = TRUE;</span></a>
<a name="3697"><span class="lineNum">    3697 </span><span class="lineNoCov">          0 :         *type_decay_used = TRUE;</span></a>
<a name="3698"><span class="lineNum">    3698 </span>            :       }  /* if */</a>
<a name="3699"><span class="lineNum">    3699 </span>            :     }  /* if */</a>
<a name="3700"><span class="lineNum">    3700 </span>            :   }  /* if */</a>
<a name="3701"><span class="lineNum">    3701 </span><span class="lineNoCov">          0 :   return type_matches;</span></a>
<a name="3702"><span class="lineNum">    3702 </span>            : }  /* type_matches_desired_type */</a>
<a name="3703"><span class="lineNum">    3703 </span>            : </a>
<a name="3704"><span class="lineNum">    3704 </span>            : </a>
<a name="3705"><span class="lineNum">    3705 </span>            : static a_field_ptr select_union_field_for_addr_constant(</a>
<a name="3706"><span class="lineNum">    3706 </span>            :                                                    a_type_ptr union_type,</a>
<a name="3707"><span class="lineNum">    3707 </span>            :                                                    a_type_ptr desired_type,</a>
<a name="3708"><span class="lineNum">    3708 </span>            :                                                    a_boolean  will_use_as_addr)</a>
<a name="3709"><span class="lineNum">    3709 </span>            : /*</a>
<a name="3710"><span class="lineNum">    3710 </span>            : union_type is a union type.  Try to find a field of that union that has</a>
<a name="3711"><span class="lineNum">    3711 </span>            : type desired_type, and return a pointer to it.  If desired_type is NULL or</a>
<a name="3712"><span class="lineNum">    3712 </span>            : if no field matches, return NULL.  If will_use_as_addr is TRUE,</a>
<a name="3713"><span class="lineNum">    3713 </span>            : array-to-pointer decay can be considered in matching the type.</a>
<a name="3714"><span class="lineNum">    3714 </span>            : */</a>
<a name="3715"><span class="lineNum">    3715 </span>            : {</a>
<a name="3716"><span class="lineNum">    3716 </span>            :   a_field_ptr field, selected_field = NULL;</a>
<a name="3717"><span class="lineNum">    3717 </span>            :   a_boolean   type_decay_used;</a>
<a name="3718"><span class="lineNum">    3718 </span>            : </a>
<a name="3719"><span class="lineNum">    3719 </span>            :   if (desired_type != NULL) {</a>
<a name="3720"><span class="lineNum">    3720 </span>            :     /* Go through the fields, looking for one with the right type. */</a>
<a name="3721"><span class="lineNum">    3721 </span>            :     for (field = union_type-&gt;variant.class_struct_union.field_list;</a>
<a name="3722"><span class="lineNum">    3722 </span>            :          field != NULL;</a>
<a name="3723"><span class="lineNum">    3723 </span>            :          field = field-&gt;next) {</a>
<a name="3724"><span class="lineNum">    3724 </span>            :       if (type_matches_desired_type(field-&gt;type, desired_type,</a>
<a name="3725"><span class="lineNum">    3725 </span>            :                                     will_use_as_addr, &amp;type_decay_used)) {</a>
<a name="3726"><span class="lineNum">    3726 </span>            :         /* If there are several fields with the same type, favor the one with</a>
<a name="3727"><span class="lineNum">    3727 </span>            :            the most access. */</a>
<a name="3728"><span class="lineNum">    3728 </span>            :         if (field-&gt;source_corresp.access == (an_access_specifier)as_public) {</a>
<a name="3729"><span class="lineNum">    3729 </span>            :           selected_field = field;</a>
<a name="3730"><span class="lineNum">    3730 </span>            :           break;</a>
<a name="3731"><span class="lineNum">    3731 </span>            :         }  /* if */</a>
<a name="3732"><span class="lineNum">    3732 </span>            :         if (selected_field == NULL ||</a>
<a name="3733"><span class="lineNum">    3733 </span>            :             is_more_accessible(field-&gt;source_corresp.access,</a>
<a name="3734"><span class="lineNum">    3734 </span>            :                                selected_field-&gt;source_corresp.access)) {</a>
<a name="3735"><span class="lineNum">    3735 </span>            :           /* This field is not public, but it's the most accessible field of</a>
<a name="3736"><span class="lineNum">    3736 </span>            :              the right type we've seen so far, so remember it and keep</a>
<a name="3737"><span class="lineNum">    3737 </span>            :              looking. */</a>
<a name="3738"><span class="lineNum">    3738 </span>            :           selected_field = field;</a>
<a name="3739"><span class="lineNum">    3739 </span>            :         }  /* if */</a>
<a name="3740"><span class="lineNum">    3740 </span>            :       }  /* if */</a>
<a name="3741"><span class="lineNum">    3741 </span>            :     }  /* for */</a>
<a name="3742"><span class="lineNum">    3742 </span>            :   }  /* if */</a>
<a name="3743"><span class="lineNum">    3743 </span>            :   return selected_field;</a>
<a name="3744"><span class="lineNum">    3744 </span>            : }  /* select_union_field_for_addr_constant */</a>
<a name="3745"><span class="lineNum">    3745 </span>            : </a>
<a name="3746"><span class="lineNum">    3746 </span>            : </a>
<a name="3747"><span class="lineNum">    3747 </span>            : static a_field_ptr select_arbitrary_field_of_union(a_type_ptr union_type)</a>
<a name="3748"><span class="lineNum">    3748 </span>            : /*</a>
<a name="3749"><span class="lineNum">    3749 </span>            : union_type points to a union.  Select an arbitrary field from that union</a>
<a name="3750"><span class="lineNum">    3750 </span>            : and return a pointer to it.  But try to pick a field that does not have</a>
<a name="3751"><span class="lineNum">    3751 </span>            : a class type, because putting a &quot;&amp;&quot; in front of a class can run into</a>
<a name="3752"><span class="lineNum">    3752 </span>            : problems if the class overloads operator&amp;.  Generates an internal error</a>
<a name="3753"><span class="lineNum">    3753 </span>            : if given an empty union.</a>
<a name="3754"><span class="lineNum">    3754 </span>            : */</a>
<a name="3755"><span class="lineNum">    3755 </span>            : {</a>
<a name="3756"><span class="lineNum">    3756 </span>            :   a_field_ptr field;</a>
<a name="3757"><span class="lineNum">    3757 </span>            : </a>
<a name="3758"><span class="lineNum">    3758 </span>            :   /* Go though the fields, looking for one with a non-class type. */</a>
<a name="3759"><span class="lineNum">    3759 </span>            :   for (field = union_type-&gt;variant.class_struct_union.field_list;</a>
<a name="3760"><span class="lineNum">    3760 </span>            :        field != NULL;</a>
<a name="3761"><span class="lineNum">    3761 </span>            :        field = field-&gt;next) {</a>
<a name="3762"><span class="lineNum">    3762 </span>            :     a_type_ptr ftype = skip_typerefs(field-&gt;type);</a>
<a name="3763"><span class="lineNum">    3763 </span>            :     if (ftype-&gt;kind != (a_type_kind)tk_class &amp;&amp;</a>
<a name="3764"><span class="lineNum">    3764 </span>            :         ftype-&gt;kind != (a_type_kind)tk_struct) break;</a>
<a name="3765"><span class="lineNum">    3765 </span>            :   }  /* for */</a>
<a name="3766"><span class="lineNum">    3766 </span>            :   if (field == NULL) {</a>
<a name="3767"><span class="lineNum">    3767 </span>            :     /* No field had a non-class type, so use the first field. */</a>
<a name="3768"><span class="lineNum">    3768 </span>            :     field = union_type-&gt;variant.class_struct_union.field_list;</a>
<a name="3769"><span class="lineNum">    3769 </span>            :     /* Unions can be empty, but we shouldn't be taking the address of</a>
<a name="3770"><span class="lineNum">    3770 </span>            :        something inside an empty one. */</a>
<a name="3771"><span class="lineNum">    3771 </span>            :     check_assertion(field != NULL);</a>
<a name="3772"><span class="lineNum">    3772 </span>            :   }  /* if */</a>
<a name="3773"><span class="lineNum">    3773 </span>            :   return field;</a>
<a name="3774"><span class="lineNum">    3774 </span>            : }  /* select_arbitrary_field_of_union */</a>
<a name="3775"><span class="lineNum">    3775 </span>            : </a>
<a name="3776"><span class="lineNum">    3776 </span>            : </a>
<a name="3777"><span class="lineNum">    3777 </span><span class="lineNoCov">          0 : void form_uuidof_reference(a_constant_ptr                        con,</span></a>
<a name="3778"><span class="lineNum">    3778 </span>            :                            an_il_to_str_output_control_block_ptr octl)</a>
<a name="3779"><span class="lineNum">    3779 </span>            : /*</a>
<a name="3780"><span class="lineNum">    3780 </span>            : Output a Microsoft __uuidof reference implied by the given constant (which is a</a>
<a name="3781"><span class="lineNum">    3781 </span>            : ck_address or ck_template_param constant).  Do the output in the way described</a>
<a name="3782"><span class="lineNum">    3782 </span>            : by octl.</a>
<a name="3783"><span class="lineNum">    3783 </span>            : */</a>
<a name="3784"><span class="lineNum">    3784 </span>            : {</a>
<a name="3785"><span class="lineNum">    3785 </span><span class="lineNoCov">          0 :   a_type_ptr        uuid_type = NULL;</span></a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineNoCov">          0 :   an_expr_node_ptr  uuid_expr = NULL;</span></a>
<a name="3787"><span class="lineNum">    3787 </span>            : </a>
<a name="3788"><span class="lineNum">    3788 </span><span class="lineNoCov">          0 :   switch (con-&gt;kind) {</span></a>
<a name="3789"><span class="lineNum">    3789 </span><span class="lineNoCov">          0 :     case ck_address:</span></a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineNoCov">          0 :       check_assertion_str(con-&gt;variant.address.kind ==</span></a>
<a name="3791"><span class="lineNum">    3791 </span>            :                                               (an_address_base_kind)abk_uuidof,</a>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineNoCov">          0 :                           &quot;form_uuidof_reference: bad kind&quot;);</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineNoCov">          0 :       uuid_type = con-&gt;variant.address.variant.type;</span></a>
<a name="3794"><span class="lineNum">    3794 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3795"><span class="lineNum">    3795 </span><span class="lineNoCov">          0 :     case ck_template_param:</span></a>
<a name="3796"><span class="lineNum">    3796 </span><span class="lineNoCov">          0 :       uuid_expr = generic_sizeof_arg_expr(con);</span></a>
<a name="3797"><span class="lineNum">    3797 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3798"><span class="lineNum">    3798 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="3799"><span class="lineNum">    3799 </span><span class="lineNoCov">          0 :       unexpected_condition();</span></a>
<a name="3800"><span class="lineNum">    3800 </span>            :   }  /* switch */</a>
<a name="3801"><span class="lineNum">    3801 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;__uuidof(&quot;, octl);</span></a>
<a name="3802"><span class="lineNum">    3802 </span><span class="lineNoCov">          0 :   if (uuid_expr != NULL) {</span></a>
<a name="3803"><span class="lineNum">    3803 </span><span class="lineNoCov">          0 :     form_expression(uuid_expr, octl);</span></a>
<a name="3804"><span class="lineNum">    3804 </span><span class="lineNoCov">          0 :   } else if (uuid_type != NULL) {</span></a>
<a name="3805"><span class="lineNum">    3805 </span><span class="lineNoCov">          0 :     form_type(uuid_type, octl);</span></a>
<a name="3806"><span class="lineNum">    3806 </span>            :   } else {</a>
<a name="3807"><span class="lineNum">    3807 </span>            :     /* Zero GUID. */</a>
<a name="3808"><span class="lineNum">    3808 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;0&quot;, octl);</span></a>
<a name="3809"><span class="lineNum">    3809 </span>            :   }  /* if */</a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3811"><span class="lineNum">    3811 </span><span class="lineNoCov">          0 : }  /* form_uuidof_reference */</span></a>
<a name="3812"><span class="lineNum">    3812 </span>            : </a>
<a name="3813"><span class="lineNum">    3813 </span>            : </a>
<a name="3814"><span class="lineNum">    3814 </span><span class="lineNoCov">          0 : void form_typeid_reference(a_constant_ptr                        con,</span></a>
<a name="3815"><span class="lineNum">    3815 </span>            :                            an_il_to_str_output_control_block_ptr octl)</a>
<a name="3816"><span class="lineNum">    3816 </span>            : /*</a>
<a name="3817"><span class="lineNum">    3817 </span>            : Output a  typeid reference implied by the given constant (which is a</a>
<a name="3818"><span class="lineNum">    3818 </span>            : ck_address constant).  Do the output in the way described by octl.</a>
<a name="3819"><span class="lineNum">    3819 </span>            : */</a>
<a name="3820"><span class="lineNum">    3820 </span>            : {</a>
<a name="3821"><span class="lineNum">    3821 </span><span class="lineNoCov">          0 :   a_type_ptr        typeid_type = NULL;</span></a>
<a name="3822"><span class="lineNum">    3822 </span><span class="lineNoCov">          0 :   an_expr_node_ptr  typeid_expr = NULL;</span></a>
<a name="3823"><span class="lineNum">    3823 </span><span class="lineNoCov">          0 :   a_boolean         is_cli_typeid = FALSE;</span></a>
<a name="3824"><span class="lineNum">    3824 </span>            : </a>
<a name="3825"><span class="lineNum">    3825 </span><span class="lineNoCov">          0 :   switch (con-&gt;kind) {</span></a>
<a name="3826"><span class="lineNum">    3826 </span>            :     case ck_address:</a>
<a name="3827"><span class="lineNum">    3827 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="3828"><span class="lineNum">    3828 </span>            :       is_cli_typeid =</a>
<a name="3829"><span class="lineNum">    3829 </span>            :             cli_or_cx_enabled &amp;&amp;</a>
<a name="3830"><span class="lineNum">    3830 </span>            :             con-&gt;variant.address.kind == (an_address_base_kind)abk_cli_typeid;</a>
<a name="3831"><span class="lineNum">    3831 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="3832"><span class="lineNum">    3832 </span><span class="lineNoCov">          0 :       check_assertion_str(is_cli_typeid ||</span></a>
<a name="3833"><span class="lineNum">    3833 </span>            :                           con-&gt;variant.address.kind ==</a>
<a name="3834"><span class="lineNum">    3834 </span>            :                                              (an_address_base_kind)abk_typeid,</a>
<a name="3835"><span class="lineNum">    3835 </span><span class="lineNoCov">          0 :                           &quot;form_typeid_reference: bad kind&quot;);</span></a>
<a name="3836"><span class="lineNum">    3836 </span><span class="lineNoCov">          0 :       typeid_type = con-&gt;variant.address.variant.type;</span></a>
<a name="3837"><span class="lineNum">    3837 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3838"><span class="lineNum">    3838 </span><span class="lineNoCov">          0 :     case ck_template_param:</span></a>
<a name="3839"><span class="lineNum">    3839 </span><span class="lineNoCov">          0 :       typeid_expr = generic_sizeof_arg_expr(con);</span></a>
<a name="3840"><span class="lineNum">    3840 </span><span class="lineNoCov">          0 :       typeid_type = con-&gt;variant.template_param.variant.templ_sizeof.type;</span></a>
<a name="3841"><span class="lineNum">    3841 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3842"><span class="lineNum">    3842 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="3843"><span class="lineNum">    3843 </span><span class="lineNoCov">          0 :       unexpected_condition();</span></a>
<a name="3844"><span class="lineNum">    3844 </span>            :   }  /* switch */</a>
<a name="3845"><span class="lineNum">    3845 </span><span class="lineNoCov">          0 :   if (!is_cli_typeid) {</span></a>
<a name="3846"><span class="lineNum">    3846 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;typeid(&quot;, octl);</span></a>
<a name="3847"><span class="lineNum">    3847 </span>            :   }  /* if */</a>
<a name="3848"><span class="lineNum">    3848 </span><span class="lineNoCov">          0 :   if (typeid_expr != NULL) {</span></a>
<a name="3849"><span class="lineNum">    3849 </span><span class="lineNoCov">          0 :     form_expression(typeid_expr, octl);</span></a>
<a name="3850"><span class="lineNum">    3850 </span><span class="lineNoCov">          0 :   } else if (typeid_type != NULL) {</span></a>
<a name="3851"><span class="lineNum">    3851 </span><span class="lineNoCov">          0 :     form_type(typeid_type, octl);</span></a>
<a name="3852"><span class="lineNum">    3852 </span>            :   } else {</a>
<a name="3853"><span class="lineNum">    3853 </span><span class="lineNoCov">          0 :     unexpected_condition();</span></a>
<a name="3854"><span class="lineNum">    3854 </span>            :   }  /* if */</a>
<a name="3855"><span class="lineNum">    3855 </span><span class="lineNoCov">          0 :   if (is_cli_typeid) {</span></a>
<a name="3856"><span class="lineNum">    3856 </span>            :     octl-&gt;output_str(&quot;::typeid&quot;, octl);</a>
<a name="3857"><span class="lineNum">    3857 </span>            :   } else {</a>
<a name="3858"><span class="lineNum">    3858 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="3859"><span class="lineNum">    3859 </span>            :   } /* if */</a>
<a name="3860"><span class="lineNum">    3860 </span><span class="lineNoCov">          0 : }  /* form_typeid_reference */</span></a>
<a name="3861"><span class="lineNum">    3861 </span>            : </a>
<a name="3862"><span class="lineNum">    3862 </span>            : </a>
<a name="3863"><span class="lineNum">    3863 </span><span class="lineNoCov">          0 : static a_type_ptr static_unknown_type(void)</span></a>
<a name="3864"><span class="lineNum">    3864 </span>            : /*</a>
<a name="3865"><span class="lineNum">    3865 </span>            : Return a pointer to an unknown type.  Don't do allocation, because that is not</a>
<a name="3866"><span class="lineNum">    3866 </span>            : allowed in a back end.  This is used to produce a type that will not</a>
<a name="3867"><span class="lineNum">    3867 </span>            : match other types in the IL.</a>
<a name="3868"><span class="lineNum">    3868 </span>            : */</a>
<a name="3869"><span class="lineNum">    3869 </span>            : {</a>
<a name="3870"><span class="lineNum">    3870 </span><span class="lineNoCov">          0 :   a_type_ptr    type;</span></a>
<a name="3871"><span class="lineNum">    3871 </span><span class="lineNoCov">          0 :   static a_type unkn_type;</span></a>
<a name="3872"><span class="lineNum">    3872 </span>            : </a>
<a name="3873"><span class="lineNum">    3873 </span><span class="lineNoCov">          0 :   type = &amp;unkn_type;</span></a>
<a name="3874"><span class="lineNum">    3874 </span>            :   /* Can't use clear_type here either.  This is unfortunate, but all we</a>
<a name="3875"><span class="lineNum">    3875 </span>            :      need is a type that won't match other types. */</a>
<a name="3876"><span class="lineNum">    3876 </span><span class="lineNoCov">          0 :   memzero((char *)&amp;unkn_type, sizeof(unkn_type));</span></a>
<a name="3877"><span class="lineNum">    3877 </span><span class="lineNoCov">          0 :   unkn_type.kind = (a_type_kind)tk_unknown;</span></a>
<a name="3878"><span class="lineNum">    3878 </span><span class="lineNoCov">          0 :   return type;</span></a>
<a name="3879"><span class="lineNum">    3879 </span>            : }  /* static_unknown_type */</a>
<a name="3880"><span class="lineNum">    3880 </span>            : </a>
<a name="3881"><span class="lineNum">    3881 </span>            : </a>
<a name="3882"><span class="lineNum">    3882 </span><span class="lineNoCov">          0 : static void form_lvalue_for_addressed_entity(</span></a>
<a name="3883"><span class="lineNum">    3883 </span>            :                    a_constant_ptr                        constant,</a>
<a name="3884"><span class="lineNum">    3884 </span>            :                    a_type_ptr                            desired_type,</a>
<a name="3885"><span class="lineNum">    3885 </span>            :                    a_boolean                             will_use_as_addr,</a>
<a name="3886"><span class="lineNum">    3886 </span>            :                    a_boolean                             base_entity_only,</a>
<a name="3887"><span class="lineNum">    3887 </span>            :                    a_boolean                             gen_output,</a>
<a name="3888"><span class="lineNum">    3888 </span>            :                    a_type_ptr                            *achieved_type,</a>
<a name="3889"><span class="lineNum">    3889 </span>            :                    a_boolean                             *type_decay_used,</a>
<a name="3890"><span class="lineNum">    3890 </span>            :                    a_targ_ptrdiff_t                      *offset,</a>
<a name="3891"><span class="lineNum">    3891 </span>            :                    a_boolean                             *formed_useful_lvalue,</a>
<a name="3892"><span class="lineNum">    3892 </span>            :                    an_il_to_str_output_control_block_ptr octl)</a>
<a name="3893"><span class="lineNum">    3893 </span>            : /*</a>
<a name="3894"><span class="lineNum">    3894 </span>            : Output code that is an lvalue for the entity addressed by the ck_address</a>
<a name="3895"><span class="lineNum">    3895 </span>            : constant &quot;constant&quot;.  This is done as part of outputting an address constant.</a>
<a name="3896"><span class="lineNum">    3896 </span>            : The output can be as simple as &quot;x&quot; or something more complicated like</a>
<a name="3897"><span class="lineNum">    3897 </span>            : &quot;x.a.b[5]&quot;.  desired_type is the lvalue type ultimately wanted, or NULL</a>
<a name="3898"><span class="lineNum">    3898 </span>            : if no preference is indicated; will_use_as_addr is TRUE if the lvalue</a>
<a name="3899"><span class="lineNum">    3899 </span>            : will be used as an address (rather than directly as an lvalue).  If</a>
<a name="3900"><span class="lineNum">    3900 </span>            : base_entity_only is TRUE, the base entity is put out but no attempt is</a>
<a name="3901"><span class="lineNum">    3901 </span>            : made to add addressing modifiers to it.  On return, *achieved_type is set</a>
<a name="3902"><span class="lineNum">    3902 </span>            : to the type of the lvalue.  If type decay was used in making the match,</a>
<a name="3903"><span class="lineNum">    3903 </span>            : *type_decay_used is returned TRUE, and *achieved_type is the type after</a>
<a name="3904"><span class="lineNum">    3904 </span>            : the type decay, minus the top-level pointer-to.  *offset is set to</a>
<a name="3905"><span class="lineNum">    3905 </span>            : whatever part of the ck_address constant offset couldn't be dealt with</a>
<a name="3906"><span class="lineNum">    3906 </span>            : in the lvalue.  If the type achieved is the desired type, ignoring</a>
<a name="3907"><span class="lineNum">    3907 </span>            : type qualifiers, and the offset was dealt with in some appropriate way,</a>
<a name="3908"><span class="lineNum">    3908 </span>            : *formed_useful_lvalue is returned TRUE.  If it's returned FALSE,</a>
<a name="3909"><span class="lineNum">    3909 </span>            : *achieved_type is set to the base entity type.  Do the output in the</a>
<a name="3910"><span class="lineNum">    3910 </span>            : way described by octl, but output nothing if gen_output == FALSE; that</a>
<a name="3911"><span class="lineNum">    3911 </span>            : is used for a first exploratory pass.  Note that the addressing</a>
<a name="3912"><span class="lineNum">    3912 </span>            : operators put out by this routine are never affected by overloading.</a>
<a name="3913"><span class="lineNum">    3913 </span>            : That is, this routine never puts out something like a &quot;&amp;&quot; on a class</a>
<a name="3914"><span class="lineNum">    3914 </span>            : that might have operator&amp; overloaded.  However, this routine still</a>
<a name="3915"><span class="lineNum">    3915 </span>            : generates code that is not compilable in some obscure C++ cases (e.g.,</a>
<a name="3916"><span class="lineNum">    3916 </span>            : taking the address of an inaccessible nonstatic data member of a class);</a>
<a name="3917"><span class="lineNum">    3917 </span>            : the C++-generating back end avoids that by arranging to have constant</a>
<a name="3918"><span class="lineNum">    3918 </span>            : addressing operations not folded to constants so that such cases won't</a>
<a name="3919"><span class="lineNum">    3919 </span>            : come here.  Parentheses are not put around the output; all the</a>
<a name="3920"><span class="lineNum">    3920 </span>            : operations generated bind very tightly to the identifier, so</a>
<a name="3921"><span class="lineNum">    3921 </span>            : parentheses are not needed.</a>
<a name="3922"><span class="lineNum">    3922 </span>            : */</a>
<a name="3923"><span class="lineNum">    3923 </span>            : {</a>
<a name="3924"><span class="lineNum">    3924 </span><span class="lineNoCov">          0 :   a_type_ptr              type = NULL, orig_type;</span></a>
<a name="3925"><span class="lineNum">    3925 </span><span class="lineNoCov">          0 :   a_constant_ptr          con = NULL;</span></a>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineNoCov">          0 :   a_source_correspondence *entity_scp = NULL;</span></a>
<a name="3927"><span class="lineNum">    3927 </span><span class="lineNoCov">          0 :   an_il_entry_kind        entity_kind = iek_none;</span></a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineNoCov">          0 :   a_field_ptr             field;</span></a>
<a name="3929"><span class="lineNum">    3929 </span><span class="lineNoCov">          0 :   a_boolean               proper_type = FALSE;</span></a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineNoCov">          0 :   a_boolean               local_type_decay_used;</span></a>
<a name="3931"><span class="lineNum">    3931 </span><span class="lineNoCov">          0 :   a_targ_ptrdiff_t        orig_offset = constant-&gt;variant.address.offset;</span></a>
<a name="3932"><span class="lineNum">    3932 </span><span class="lineNoCov">          0 :   an_address_base_kind    special_address_kind =</span></a>
<a name="3933"><span class="lineNum">    3933 </span>            :                                                (an_address_base_kind)abk_last;</a>
<a name="3934"><span class="lineNum">    3934 </span>            : </a>
<a name="3935"><span class="lineNum">    3935 </span><span class="lineNoCov">          0 :   *formed_useful_lvalue = FALSE;</span></a>
<a name="3936"><span class="lineNum">    3936 </span><span class="lineNoCov">          0 :   *type_decay_used = FALSE;</span></a>
<a name="3937"><span class="lineNum">    3937 </span><span class="lineNoCov">          0 :   *offset = orig_offset;</span></a>
<a name="3938"><span class="lineNum">    3938 </span>            :   /* Get the type of the underlying entity. */</a>
<a name="3939"><span class="lineNum">    3939 </span><span class="lineNoCov">          0 :   switch (constant-&gt;variant.address.kind) {</span></a>
<a name="3940"><span class="lineNum">    3940 </span><span class="lineNoCov">          0 :     case abk_routine:</span></a>
<a name="3941"><span class="lineNum">    3941 </span>            :       /* A routine. */</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineNoCov">          0 :       { a_routine_ptr rout = constant-&gt;variant.address.variant.routine;</span></a>
<a name="3943"><span class="lineNum">    3943 </span><span class="lineNoCov">          0 :         type = rout-&gt;type;</span></a>
<a name="3944"><span class="lineNum">    3944 </span><span class="lineNoCov">          0 :         entity_kind = iek_routine;</span></a>
<a name="3945"><span class="lineNum">    3945 </span><span class="lineNoCov">          0 :         entity_scp = &amp;rout-&gt;source_corresp;</span></a>
<a name="3946"><span class="lineNum">    3946 </span><span class="lineNoCov">          0 :         *type_decay_used = TRUE;</span></a>
<a name="3947"><span class="lineNum">    3947 </span>            :       }</a>
<a name="3948"><span class="lineNum">    3948 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3949"><span class="lineNum">    3949 </span><span class="lineNoCov">          0 :     case abk_variable:</span></a>
<a name="3950"><span class="lineNum">    3950 </span>            :       /* A variable. */</a>
<a name="3951"><span class="lineNum">    3951 </span><span class="lineNoCov">          0 :       { a_variable_ptr var = constant-&gt;variant.address.variant.variable;</span></a>
<a name="3952"><span class="lineNum">    3952 </span>            :         /* In C++, an anonymous union cannot be named directly, so we have to</a>
<a name="3953"><span class="lineNum">    3953 </span>            :            find a field within the union. */</a>
<a name="3954"><span class="lineNum">    3954 </span><span class="lineNoCov">          0 :         if (var-&gt;is_anonymous_parent_object &amp;&amp; !octl-&gt;c_generating_back_end) {</span></a>
<a name="3955"><span class="lineNum">    3955 </span><span class="lineNoCov">          0 :           a_type_ptr  union_type = skip_typerefs(var-&gt;type);</span></a>
<a name="3956"><span class="lineNum">    3956 </span><span class="lineNoCov">          0 :           field = select_union_field_for_addr_constant(union_type,</span></a>
<a name="3957"><span class="lineNum">    3957 </span>            :                                                        desired_type,</a>
<a name="3958"><span class="lineNum">    3958 </span>            :                                                        will_use_as_addr);</a>
<a name="3959"><span class="lineNum">    3959 </span><span class="lineNoCov">          0 :           if (field == NULL) {</span></a>
<a name="3960"><span class="lineNum">    3960 </span>            :             /* If no field matches, choose one mostly arbitrarily. */</a>
<a name="3961"><span class="lineNum">    3961 </span>            :             /* Note that we're lucky that anonymous unions cannot have</a>
<a name="3962"><span class="lineNum">    3962 </span>            :                nonpublic members. */</a>
<a name="3963"><span class="lineNum">    3963 </span><span class="lineNoCov">          0 :             field = select_arbitrary_field_of_union(union_type);</span></a>
<a name="3964"><span class="lineNum">    3964 </span>            :           }  /* if */</a>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineNoCov">          0 :           type = field-&gt;type;</span></a>
<a name="3966"><span class="lineNum">    3966 </span><span class="lineNoCov">          0 :           entity_kind = iek_field;</span></a>
<a name="3967"><span class="lineNum">    3967 </span><span class="lineNoCov">          0 :           entity_scp = &amp;field-&gt;source_corresp;</span></a>
<a name="3968"><span class="lineNum">    3968 </span>            :         } else {</a>
<a name="3969"><span class="lineNum">    3969 </span>            :           /* Normal variable, not anonymous union. */</a>
<a name="3970"><span class="lineNum">    3970 </span><span class="lineNoCov">          0 :           type = var-&gt;type;</span></a>
<a name="3971"><span class="lineNum">    3971 </span><span class="lineNoCov">          0 :           entity_kind = iek_variable;</span></a>
<a name="3972"><span class="lineNum">    3972 </span><span class="lineNoCov">          0 :           entity_scp = &amp;var-&gt;source_corresp;</span></a>
<a name="3973"><span class="lineNum">    3973 </span>            :         }  /* if */</a>
<a name="3974"><span class="lineNum">    3974 </span>            :       }</a>
<a name="3975"><span class="lineNum">    3975 </span>            :       break;</a>
<a name="3976"><span class="lineNum">    3976 </span><span class="lineNoCov">          0 :     case abk_constant:</span></a>
<a name="3977"><span class="lineNum">    3977 </span>            :       /* Address of a constant, specifically a string. */</a>
<a name="3978"><span class="lineNum">    3978 </span><span class="lineNoCov">          0 :       con = constant-&gt;variant.address.variant.constant;</span></a>
<a name="3979"><span class="lineNum">    3979 </span>            : #if !STANDALONE_UTILITY_PROGRAM</a>
<a name="3980"><span class="lineNum">    3980 </span><span class="lineNoCov">          0 :       check_assertion_str(con-&gt;kind == (a_constant_repr_kind)ck_string ||</span></a>
<a name="3981"><span class="lineNum">    3981 </span>            :                           con-&gt;kind == (a_constant_repr_kind)ck_error ||</a>
<a name="3982"><span class="lineNum">    3982 </span>            :                           constexpr_enabled, </a>
<a name="3983"><span class="lineNum">    3983 </span><span class="lineNoCov">          0 :                  &quot;form_lvalue_for_addressed_entity: address of nonstring con&quot;);</span></a>
<a name="3984"><span class="lineNum">    3984 </span>            : #endif /* !STANDALONE_UTILITY_PROGRAM */</a>
<a name="3985"><span class="lineNum">    3985 </span><span class="lineNoCov">          0 :       type = con-&gt;type;</span></a>
<a name="3986"><span class="lineNum">    3986 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3987"><span class="lineNum">    3987 </span><span class="lineNoCov">          0 :     case abk_temporary:</span></a>
<a name="3988"><span class="lineNum">    3988 </span>            :       /* Temporary with a constant value. */</a>
<a name="3989"><span class="lineNum">    3989 </span><span class="lineNoCov">          0 :       con = constant-&gt;variant.address.variant.constant;</span></a>
<a name="3990"><span class="lineNum">    3990 </span><span class="lineNoCov">          0 :       type = con-&gt;type;</span></a>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="3992"><span class="lineNum">    3992 </span><span class="lineNoCov">          0 :     case abk_uuidof:</span></a>
<a name="3993"><span class="lineNum">    3993 </span>            :     case abk_typeid:</a>
<a name="3994"><span class="lineNum">    3994 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="3995"><span class="lineNum">    3995 </span>            :     case abk_cli_typeid:</a>
<a name="3996"><span class="lineNum">    3996 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="3997"><span class="lineNum">    3997 </span>            :       /* Address of a structure that represents the uuid or typeid information</a>
<a name="3998"><span class="lineNum">    3998 </span>            :          for a given type. */</a>
<a name="3999"><span class="lineNum">    3999 </span><span class="lineNoCov">          0 :       special_address_kind = constant-&gt;variant.address.kind;</span></a>
<a name="4000"><span class="lineNum">    4000 </span><span class="lineNoCov">          0 :       if (!constant-&gt;implicit_cast) {</span></a>
<a name="4001"><span class="lineNum">    4001 </span><span class="lineNoCov">          0 :         type = type_pointed_to(constant-&gt;type);</span></a>
<a name="4002"><span class="lineNum">    4002 </span>            :       } else {</a>
<a name="4003"><span class="lineNum">    4003 </span>            :         /* The uuidof address is cast to some other type (e.g., int). */</a>
<a name="4004"><span class="lineNum">    4004 </span><span class="lineNoCov">          0 :         type = static_unknown_type();</span></a>
<a name="4005"><span class="lineNum">    4005 </span>            :       }  /* if */</a>
<a name="4006"><span class="lineNum">    4006 </span>            :       break;</a>
<a name="4007"><span class="lineNum">    4007 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4008"><span class="lineNum">    4008 </span>            :     case abk_cli_array:</a>
<a name="4009"><span class="lineNum">    4009 </span>            :       special_address_kind = constant-&gt;variant.address.kind;</a>
<a name="4010"><span class="lineNum">    4010 </span>            :       type = type_pointed_to(constant-&gt;type);</a>
<a name="4011"><span class="lineNum">    4011 </span>            :       break;</a>
<a name="4012"><span class="lineNum">    4012 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4013"><span class="lineNum">    4013 </span><span class="lineNoCov">          0 :     case abk_label:</span></a>
<a name="4014"><span class="lineNum">    4014 </span>            :       /* Address of a label (GNU C extension). */</a>
<a name="4015"><span class="lineNum">    4015 </span><span class="lineNoCov">          0 :       { a_label_ptr label = constant-&gt;variant.address.variant.label;</span></a>
<a name="4016"><span class="lineNum">    4016 </span><span class="lineNoCov">          0 :         if (!constant-&gt;implicit_cast) {</span></a>
<a name="4017"><span class="lineNum">    4017 </span><span class="lineNoCov">          0 :           type = type_pointed_to(constant-&gt;type);</span></a>
<a name="4018"><span class="lineNum">    4018 </span>            :         } else {</a>
<a name="4019"><span class="lineNum">    4019 </span>            :           /* The label address is cast to some other type (e.g., int). */</a>
<a name="4020"><span class="lineNum">    4020 </span><span class="lineNoCov">          0 :           type = static_unknown_type();</span></a>
<a name="4021"><span class="lineNum">    4021 </span>            :         }  /* if */</a>
<a name="4022"><span class="lineNum">    4022 </span><span class="lineNoCov">          0 :         entity_kind = iek_label;</span></a>
<a name="4023"><span class="lineNum">    4023 </span><span class="lineNoCov">          0 :         entity_scp = &amp;label-&gt;source_corresp;</span></a>
<a name="4024"><span class="lineNum">    4024 </span>            :       }</a>
<a name="4025"><span class="lineNum">    4025 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="4026"><span class="lineNum">    4026 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="4027"><span class="lineNum">    4027 </span><span class="lineNoCov">          0 :       unexpected_condition_str(</span></a>
<a name="4028"><span class="lineNum">    4028 </span>            :                    &quot;form_lvalue_for_addressed_entity: bad addr constant kind&quot;);</a>
<a name="4029"><span class="lineNum">    4029 </span>            :   }  /* switch */</a>
<a name="4030"><span class="lineNum">    4030 </span><span class="lineNoCov">          0 :   orig_type = type;</span></a>
<a name="4031"><span class="lineNum">    4031 </span>            :   /* If the desired type was not specified, use the entity type. */</a>
<a name="4032"><span class="lineNum">    4032 </span><span class="lineNoCov">          0 :   if (desired_type == NULL) desired_type = type;</span></a>
<a name="4033"><span class="lineNum">    4033 </span>            :   /* Put out the base entity name or constant. */</a>
<a name="4034"><span class="lineNum">    4034 </span><span class="lineNoCov">          0 :   if (gen_output) {</span></a>
<a name="4035"><span class="lineNum">    4035 </span><span class="lineNoCov">          0 :     if (entity_scp != NULL) {</span></a>
<a name="4036"><span class="lineNum">    4036 </span><span class="lineNoCov">          0 :       form_name(entity_scp, entity_kind, octl);</span></a>
<a name="4037"><span class="lineNum">    4037 </span><span class="lineNoCov">          0 :     } else if (con != NULL) {</span></a>
<a name="4038"><span class="lineNum">    4038 </span>            :       /* Constant case. */</a>
<a name="4039"><span class="lineNum">    4039 </span><span class="lineNoCov">          0 :       form_constant(con, /*need_parens=*/FALSE, octl);</span></a>
<a name="4040"><span class="lineNum">    4040 </span><span class="lineNoCov">          0 :     } else if (special_address_kind == (an_address_base_kind)abk_uuidof) {</span></a>
<a name="4041"><span class="lineNum">    4041 </span>            :       /* Microsoft __uuidof. */</a>
<a name="4042"><span class="lineNum">    4042 </span><span class="lineNoCov">          0 :       form_uuidof_reference(constant, octl);</span></a>
<a name="4043"><span class="lineNum">    4043 </span><span class="lineNoCov">          0 :     } else if (special_address_kind == (an_address_base_kind)abk_typeid</span></a>
<a name="4044"><span class="lineNum">    4044 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4045"><span class="lineNum">    4045 </span>            :                || constant-&gt;variant.address.kind == </a>
<a name="4046"><span class="lineNum">    4046 </span>            :                                           (an_address_base_kind)abk_cli_typeid</a>
<a name="4047"><span class="lineNum">    4047 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4048"><span class="lineNum">    4048 </span>            :                ) {</a>
<a name="4049"><span class="lineNum">    4049 </span><span class="lineNoCov">          0 :       form_typeid_reference(constant, octl);</span></a>
<a name="4050"><span class="lineNum">    4050 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4051"><span class="lineNum">    4051 </span>            :     } else if (special_address_kind == (an_address_base_kind)abk_cli_array) {</a>
<a name="4052"><span class="lineNum">    4052 </span>            :       /* A C++/CLI array constant, used only in custom attribute argument</a>
<a name="4053"><span class="lineNum">    4053 </span>            :          expressions, is represented with an enk_gcnew expression node</a>
<a name="4054"><span class="lineNum">    4054 </span>            :          in constant-&gt;expr.  That expression is emitted by form_constant,</a>
<a name="4055"><span class="lineNum">    4055 </span>            :          so this code path should not be hit. */</a>
<a name="4056"><span class="lineNum">    4056 </span>            :       unexpected_condition();</a>
<a name="4057"><span class="lineNum">    4057 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4058"><span class="lineNum">    4058 </span>            :     } else {</a>
<a name="4059"><span class="lineNum">    4059 </span><span class="lineNoCov">          0 :       unexpected_condition();</span></a>
<a name="4060"><span class="lineNum">    4060 </span>            :     }  /* if */</a>
<a name="4061"><span class="lineNum">    4061 </span>            :   }  /* if */</a>
<a name="4062"><span class="lineNum">    4062 </span>            :   /* If the type is right and the offset is zero, we have what we need. */</a>
<a name="4063"><span class="lineNum">    4063 </span><span class="lineNoCov">          0 :   local_type_decay_used = FALSE;</span></a>
<a name="4064"><span class="lineNum">    4064 </span><span class="lineNoCov">          0 :   if (!constant-&gt;implicit_cast || /* For speed. */</span></a>
<a name="4065"><span class="lineNum">    4065 </span><span class="lineNoCov">          0 :       type_matches_desired_type(type, desired_type, will_use_as_addr,</span></a>
<a name="4066"><span class="lineNum">    4066 </span>            :                                 &amp;local_type_decay_used)) {</a>
<a name="4067"><span class="lineNum">    4067 </span>            :     proper_type = TRUE;</a>
<a name="4068"><span class="lineNum">    4068 </span>            :   }  /* if */</a>
<a name="4069"><span class="lineNum">    4069 </span><span class="lineNoCov">          0 :   if (proper_type &amp;&amp; orig_offset == 0) {</span></a>
<a name="4070"><span class="lineNum">    4070 </span>            :     /* The base entity has the type and offset we need. */</a>
<a name="4071"><span class="lineNum">    4071 </span><span class="lineNoCov">          0 :     *formed_useful_lvalue = TRUE;</span></a>
<a name="4072"><span class="lineNum">    4072 </span>            :     /* Note we're careful not to clear *type_decay_used if it was set above</a>
<a name="4073"><span class="lineNum">    4073 </span>            :        for the function case. */</a>
<a name="4074"><span class="lineNum">    4074 </span><span class="lineNoCov">          0 :     if (local_type_decay_used) *type_decay_used = TRUE;</span></a>
<a name="4075"><span class="lineNum">    4075 </span><span class="lineNoCov">          0 :   } else if (base_entity_only) {</span></a>
<a name="4076"><span class="lineNum">    4076 </span>            :     /* We've been told not to look at addressing modifiers, so stop here. */</a>
<a name="4077"><span class="lineNum">    4077 </span>            :   } else {</a>
<a name="4078"><span class="lineNum">    4078 </span>            :     /* Loop, refining the lvalue each time around, until we get something with</a>
<a name="4079"><span class="lineNum">    4079 </span>            :        the right type and right address, or until we decide to give up. */</a>
<a name="4080"><span class="lineNum">    4080 </span>            :     a_boolean prev_field_was_base_class_subobject_with_tail_padding = FALSE;</a>
<a name="4081"><span class="lineNum">    4081 </span><span class="lineNoCov">          0 :     for (;;) {</span></a>
<a name="4082"><span class="lineNum">    4082 </span><span class="lineNoCov">          0 :       a_type_ptr unqual_type = skip_typerefs(type);</span></a>
<a name="4083"><span class="lineNum">    4083 </span><span class="lineNoCov">          0 :       if (unqual_type-&gt;kind == (a_type_kind)tk_array) {</span></a>
<a name="4084"><span class="lineNum">    4084 </span>            :         /* Array. */</a>
<a name="4085"><span class="lineNum">    4085 </span>            :         /* When forming an address for an array element, it sometimes makes</a>
<a name="4086"><span class="lineNum">    4086 </span>            :            sense to leave part of the offset to be done by the caller.</a>
<a name="4087"><span class="lineNum">    4087 </span>            :              A arr[4];</a>
<a name="4088"><span class="lineNum">    4088 </span>            :              A *p = arr + 2;</a>
<a name="4089"><span class="lineNum">    4089 </span>            :            This form works better than &quot;&amp;arr[2]&quot;, which might be taking the</a>
<a name="4090"><span class="lineNum">    4090 </span>            :            address of a class object whose operator&amp; is overloaded. */</a>
<a name="4091"><span class="lineNum">    4091 </span><span class="lineNoCov">          0 :         if (proper_type &amp;&amp; will_use_as_addr) {</span></a>
<a name="4092"><span class="lineNum">    4092 </span><span class="lineNoCov">          0 :           *formed_useful_lvalue = TRUE;</span></a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineNoCov">          0 :           *type_decay_used = TRUE;</span></a>
<a name="4094"><span class="lineNum">    4094 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="4095"><span class="lineNum">    4095 </span>            :         } else {</a>
<a name="4096"><span class="lineNum">    4096 </span>            :           /* Add a subscripting operation. */</a>
<a name="4097"><span class="lineNum">    4097 </span><span class="lineNoCov">          0 :           a_type_ptr       element_type = array_element_type(unqual_type);</span></a>
<a name="4098"><span class="lineNum">    4098 </span><span class="lineNoCov">          0 :           a_targ_ptrdiff_t element_size = f_skip_typerefs(element_type)-&gt;size;</span></a>
<a name="4099"><span class="lineNum">    4099 </span><span class="lineNoCov">          0 :           a_targ_ptrdiff_t idx;</span></a>
<a name="4100"><span class="lineNum">    4100 </span>            :           /* g++ allows zero-length arrays. */</a>
<a name="4101"><span class="lineNum">    4101 </span><span class="lineNoCov">          0 :           if (element_size == 0) element_size = 1;</span></a>
<a name="4102"><span class="lineNum">    4102 </span><span class="lineNoCov">          0 :           idx = *offset / element_size;</span></a>
<a name="4103"><span class="lineNum">    4103 </span>            :           /* C division of negative numbers does not necessarily truncate</a>
<a name="4104"><span class="lineNum">    4104 </span>            :              towards zero.  If it doesn't, adjust to the result one would get</a>
<a name="4105"><span class="lineNum">    4105 </span>            :              if it did.  See comments in the routine divide_integers. */</a>
<a name="4106"><span class="lineNum">    4106 </span><span class="lineNoCov">          0 :           if (*offset &lt; 0 &amp;&amp; (*offset % element_size) &gt; 0) idx++;</span></a>
<a name="4107"><span class="lineNum">    4107 </span>            :           /* Put out the subscripting operation. */</a>
<a name="4108"><span class="lineNum">    4108 </span><span class="lineNoCov">          0 :           if (gen_output) {</span></a>
<a name="4109"><span class="lineNum">    4109 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;[&quot;, octl);</span></a>
<a name="4110"><span class="lineNum">    4110 </span><span class="lineNoCov">          0 :             form_num(idx, octl);</span></a>
<a name="4111"><span class="lineNum">    4111 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;]&quot;, octl);</span></a>
<a name="4112"><span class="lineNum">    4112 </span>            :           }  /* if */</a>
<a name="4113"><span class="lineNum">    4113 </span><span class="lineNoCov">          0 :           type = element_type;</span></a>
<a name="4114"><span class="lineNum">    4114 </span><span class="lineNoCov">          0 :           *offset -= idx * element_size;</span></a>
<a name="4115"><span class="lineNum">    4115 </span>            :         }  /* if */</a>
<a name="4116"><span class="lineNum">    4116 </span><span class="lineNoCov">          0 :         prev_field_was_base_class_subobject_with_tail_padding = FALSE;</span></a>
<a name="4117"><span class="lineNum">    4117 </span><span class="lineNoCov">          0 :       } else if (unqual_type-&gt;kind == (a_type_kind)tk_class ||</span></a>
<a name="4118"><span class="lineNum">    4118 </span>            :                  unqual_type-&gt;kind == (a_type_kind)tk_struct) {</a>
<a name="4119"><span class="lineNum">    4119 </span>            :         /* A class; try to find a field with the right offset, or at least</a>
<a name="4120"><span class="lineNum">    4120 </span>            :            get closer. */</a>
<a name="4121"><span class="lineNum">    4121 </span>            :         /* Give up if the offset is outside the class bounds. */</a>
<a name="4122"><span class="lineNum">    4122 </span><span class="lineNoCov">          0 :         if (*offset &lt; 0 ||</span></a>
<a name="4123"><span class="lineNum">    4123 </span><span class="lineNoCov">          0 :             *offset &gt;= (a_targ_ptrdiff_t)unqual_type-&gt;size) break;</span></a>
<a name="4124"><span class="lineNum">    4124 </span><span class="lineNoCov">          0 :         for (field = unqual_type-&gt;variant.class_struct_union.field_list;</span></a>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineNoCov">          0 :              field != NULL;</span></a>
<a name="4126"><span class="lineNum">    4126 </span><span class="lineNoCov">          0 :              field = field-&gt;next) {</span></a>
<a name="4127"><span class="lineNum">    4127 </span>            :           /* Look for a field with the right offset.  We do a full check</a>
<a name="4128"><span class="lineNum">    4128 </span>            :              on the bounds of the field because there might be holes between</a>
<a name="4129"><span class="lineNum">    4129 </span>            :              fields (e.g., base classes). */</a>
<a name="4130"><span class="lineNum">    4130 </span><span class="lineNoCov">          0 :           if ((a_targ_ptrdiff_t)field-&gt;offset &lt;= *offset &amp;&amp;</span></a>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineNoCov">          0 :               *offset &lt; (a_targ_ptrdiff_t)(field-&gt;offset +</span></a>
<a name="4132"><span class="lineNum">    4132 </span><span class="lineNoCov">          0 :                                       skip_typerefs(field-&gt;type)-&gt;size) &amp;&amp;</span></a>
<a name="4133"><span class="lineNum">    4133 </span>            :               /* Ignore bit fields. */</a>
<a name="4134"><span class="lineNum">    4134 </span><span class="lineNoCov">          0 :               field-&gt;bit_size == 0) break;</span></a>
<a name="4135"><span class="lineNum">    4135 </span>            :         }  /* for */</a>
<a name="4136"><span class="lineNum">    4136 </span>            :         /* Watch out for classes with no fields. */</a>
<a name="4137"><span class="lineNum">    4137 </span><span class="lineNoCov">          0 :         if (field == NULL) break;</span></a>
<a name="4138"><span class="lineNum">    4138 </span><span class="lineNoCov">          0 :         if (!has_name(field)) {</span></a>
<a name="4139"><span class="lineNum">    4139 </span>            :           /* An anonymous union field.  Usually, the field selection for such</a>
<a name="4140"><span class="lineNum">    4140 </span>            :              a field is just omitted.  In the C-generating back end, however,</a>
<a name="4141"><span class="lineNum">    4141 </span>            :              references to anonymous union fields can't be omitted, so give</a>
<a name="4142"><span class="lineNum">    4142 </span>            :              up. */</a>
<a name="4143"><span class="lineNum">    4143 </span><span class="lineNoCov">          0 :           if (octl-&gt;c_generating_back_end) break;</span></a>
<a name="4144"><span class="lineNum">    4144 </span>            :         } else {</a>
<a name="4145"><span class="lineNum">    4145 </span>            :           /* Normal field (not anonymous union field). */</a>
<a name="4146"><span class="lineNum">    4146 </span>            :           /* Put out the field selection. */</a>
<a name="4147"><span class="lineNum">    4147 </span><span class="lineNoCov">          0 :           if (gen_output) {</span></a>
<a name="4148"><span class="lineNum">    4148 </span><span class="lineNoCov">          0 :             if (prev_field_was_base_class_subobject_with_tail_padding) {</span></a>
<a name="4149"><span class="lineNum">    4149 </span>            :               /* This field is a member of a base class subobject that was</a>
<a name="4150"><span class="lineNum">    4150 </span>            :                  promoted by the C-generating back end into the derived</a>
<a name="4151"><span class="lineNum">    4151 </span>            :                  class.  Instead of base_obj.base_mem, it must therefore be</a>
<a name="4152"><span class="lineNum">    4152 </span>            :                  put out as base_obj_base_mem. */</a>
<a name="4153"><span class="lineNum">    4153 </span>            :               octl-&gt;output_str(&quot;_&quot;, octl);</a>
<a name="4154"><span class="lineNum">    4154 </span>            :             } else {</a>
<a name="4155"><span class="lineNum">    4155 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;.&quot;, octl);</span></a>
<a name="4156"><span class="lineNum">    4156 </span>            :             }  /* if */</a>
<a name="4157"><span class="lineNum">    4157 </span>            : #if DO_IL_LOWERING</a>
<a name="4158"><span class="lineNum">    4158 </span>            :             if (octl-&gt;c_generating_back_end) {</a>
<a name="4159"><span class="lineNum">    4159 </span>            :               /* Set up for the next pass to use &quot;_&quot; instead of &quot;.&quot;. */</a>
<a name="4160"><span class="lineNum">    4160 </span>            :               prev_field_was_base_class_subobject_with_tail_padding =</a>
<a name="4161"><span class="lineNum">    4161 </span>            :                                  field-&gt;base_class_subobject_with_tail_padding;</a>
<a name="4162"><span class="lineNum">    4162 </span>            :             }  /* if */</a>
<a name="4163"><span class="lineNum">    4163 </span>            : #endif /* DO_IL_LOWERING */</a>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineNoCov">          0 :             form_unqualified_name(&amp;field-&gt;source_corresp, iek_field, octl);</span></a>
<a name="4165"><span class="lineNum">    4165 </span>            :           }  /* if */</a>
<a name="4166"><span class="lineNum">    4166 </span>            :         }  /* if */</a>
<a name="4167"><span class="lineNum">    4167 </span><span class="lineNoCov">          0 :         type = field-&gt;type;</span></a>
<a name="4168"><span class="lineNum">    4168 </span><span class="lineNoCov">          0 :         *offset -= (a_targ_ptrdiff_t)field-&gt;offset;</span></a>
<a name="4169"><span class="lineNum">    4169 </span><span class="lineNoCov">          0 :       } else if (unqual_type-&gt;kind == (a_type_kind)tk_union) {</span></a>
<a name="4170"><span class="lineNum">    4170 </span>            :         /* For a union, try to find a field with the right type.  If there's</a>
<a name="4171"><span class="lineNum">    4171 </span>            :            no match at the top level, don't try to find some sub-aggregate</a>
<a name="4172"><span class="lineNum">    4172 </span>            :            of those fields that will give the right offset; just give up. */</a>
<a name="4173"><span class="lineNum">    4173 </span><span class="lineNoCov">          0 :         if (*offset != 0) break;</span></a>
<a name="4174"><span class="lineNum">    4174 </span><span class="lineNoCov">          0 :         field = select_union_field_for_addr_constant(unqual_type,</span></a>
<a name="4175"><span class="lineNum">    4175 </span>            :                                                      desired_type,</a>
<a name="4176"><span class="lineNum">    4176 </span>            :                                                      will_use_as_addr);</a>
<a name="4177"><span class="lineNum">    4177 </span><span class="lineNoCov">          0 :         if (field == NULL) break;</span></a>
<a name="4178"><span class="lineNum">    4178 </span>            :         /* Found a field with the right type, so use it. */</a>
<a name="4179"><span class="lineNum">    4179 </span>            :         /* Put out the field selection. */</a>
<a name="4180"><span class="lineNum">    4180 </span><span class="lineNoCov">          0 :         if (gen_output) {</span></a>
<a name="4181"><span class="lineNum">    4181 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;.&quot;, octl);</span></a>
<a name="4182"><span class="lineNum">    4182 </span><span class="lineNoCov">          0 :           form_unqualified_name(&amp;field-&gt;source_corresp, iek_field, octl);</span></a>
<a name="4183"><span class="lineNum">    4183 </span>            :         }  /* if */</a>
<a name="4184"><span class="lineNum">    4184 </span><span class="lineNoCov">          0 :         type = field-&gt;type;</span></a>
<a name="4185"><span class="lineNum">    4185 </span><span class="lineNoCov">          0 :         prev_field_was_base_class_subobject_with_tail_padding = FALSE;</span></a>
<a name="4186"><span class="lineNum">    4186 </span>            :       } else {</a>
<a name="4187"><span class="lineNum">    4187 </span>            :         /* Some other type (not an aggregate); we can't adjust the offset or</a>
<a name="4188"><span class="lineNum">    4188 </span>            :            type.  Give up. */</a>
<a name="4189"><span class="lineNum">    4189 </span>            :         break;</a>
<a name="4190"><span class="lineNum">    4190 </span>            :       }  /* if */</a>
<a name="4191"><span class="lineNum">    4191 </span>            :       /* If the offset is now zero, and the type is right, we have what we</a>
<a name="4192"><span class="lineNum">    4192 </span>            :          need. */</a>
<a name="4193"><span class="lineNum">    4193 </span><span class="lineNoCov">          0 :       if (type_matches_desired_type(type, desired_type, will_use_as_addr,</span></a>
<a name="4194"><span class="lineNum">    4194 </span>            :                                     &amp;local_type_decay_used)) {</a>
<a name="4195"><span class="lineNum">    4195 </span>            :         proper_type = TRUE;</a>
<a name="4196"><span class="lineNum">    4196 </span>            :       }  /* if */</a>
<a name="4197"><span class="lineNum">    4197 </span><span class="lineNoCov">          0 :       if (proper_type &amp;&amp; *offset == 0) {</span></a>
<a name="4198"><span class="lineNum">    4198 </span><span class="lineNoCov">          0 :         *formed_useful_lvalue = TRUE;</span></a>
<a name="4199"><span class="lineNum">    4199 </span><span class="lineNoCov">          0 :         *type_decay_used = local_type_decay_used;</span></a>
<a name="4200"><span class="lineNum">    4200 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="4201"><span class="lineNum">    4201 </span>            :       }  /* if */</a>
<a name="4202"><span class="lineNum">    4202 </span>            :     }  /* for */</a>
<a name="4203"><span class="lineNum">    4203 </span>            :   }  /* if */</a>
<a name="4204"><span class="lineNum">    4204 </span><span class="lineNoCov">          0 :   if (*formed_useful_lvalue) {</span></a>
<a name="4205"><span class="lineNum">    4205 </span><span class="lineNoCov">          0 :     if (*type_decay_used &amp;&amp;</span></a>
<a name="4206"><span class="lineNum">    4206 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.kind != (an_address_base_kind)abk_routine) {</span></a>
<a name="4207"><span class="lineNum">    4207 </span>            :       /* Adjust the type to reflect that fact that type decay was used.</a>
<a name="4208"><span class="lineNum">    4208 </span>            :          The type returned is the type under the resulting pointer type.</a>
<a name="4209"><span class="lineNum">    4209 </span>            :          Note that because of the convention used for the type, function</a>
<a name="4210"><span class="lineNum">    4210 </span>            :          to pointer decay does not change the type. */</a>
<a name="4211"><span class="lineNum">    4211 </span><span class="lineNoCov">          0 :       type = array_element_type(type);</span></a>
<a name="4212"><span class="lineNum">    4212 </span>            :     }  /* if */</a>
<a name="4213"><span class="lineNum">    4213 </span>            :   } else {</a>
<a name="4214"><span class="lineNum">    4214 </span>            :     /* If we didn't succeed in getting the right type and offset, roll the</a>
<a name="4215"><span class="lineNum">    4215 </span>            :        type and offset back to the original from the base entity. */</a>
<a name="4216"><span class="lineNum">    4216 </span><span class="lineNoCov">          0 :     type = orig_type;</span></a>
<a name="4217"><span class="lineNum">    4217 </span><span class="lineNoCov">          0 :     *offset = orig_offset;</span></a>
<a name="4218"><span class="lineNum">    4218 </span>            :   }  /* if */</a>
<a name="4219"><span class="lineNum">    4219 </span><span class="lineNoCov">          0 :   *achieved_type = type;</span></a>
<a name="4220"><span class="lineNum">    4220 </span><span class="lineNoCov">          0 : }  /* form_lvalue_for_addressed_entity */</span></a>
<a name="4221"><span class="lineNum">    4221 </span>            : </a>
<a name="4222"><span class="lineNum">    4222 </span>            : </a>
<a name="4223"><span class="lineNum">    4223 </span><span class="lineNoCov">          0 : static void form_address_constant(</span></a>
<a name="4224"><span class="lineNum">    4224 </span>            :                           a_constant_ptr                        constant,</a>
<a name="4225"><span class="lineNum">    4225 </span>            :                           a_boolean                             form_lvalue,</a>
<a name="4226"><span class="lineNum">    4226 </span>            :                           a_boolean                             need_parens,</a>
<a name="4227"><span class="lineNum">    4227 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="4228"><span class="lineNum">    4228 </span>            : /*</a>
<a name="4229"><span class="lineNum">    4229 </span>            : Output the value of a ck_address constant.  If form_lvalue is TRUE,</a>
<a name="4230"><span class="lineNum">    4230 </span>            : put out an lvalue for the thing at that address.  If need_parens is TRUE,</a>
<a name="4231"><span class="lineNum">    4231 </span>            : parentheses are placed around the constant if there's any possibility of</a>
<a name="4232"><span class="lineNum">    4232 </span>            : precedence confusion.  Do the output in the way described by octl.</a>
<a name="4233"><span class="lineNum">    4233 </span>            : */</a>
<a name="4234"><span class="lineNum">    4234 </span>            : {</a>
<a name="4235"><span class="lineNum">    4235 </span><span class="lineNoCov">          0 :   a_type_ptr       orig_type = constant-&gt;type;</span></a>
<a name="4236"><span class="lineNum">    4236 </span><span class="lineNoCov">          0 :   a_type_ptr       con_type, desired_type, achieved_type;</span></a>
<a name="4237"><span class="lineNum">    4237 </span><span class="lineNoCov">          0 :   a_type_ptr       direct_desired_type, direct_achieved_type;</span></a>
<a name="4238"><span class="lineNum">    4238 </span><span class="lineNoCov">          0 :   a_targ_ptrdiff_t offset, dummy_offset;</span></a>
<a name="4239"><span class="lineNum">    4239 </span><span class="lineNoCov">          0 :   a_boolean        cast_to_nonpointer = FALSE, type_decay_used;</span></a>
<a name="4240"><span class="lineNum">    4240 </span><span class="lineNoCov">          0 :   a_boolean        need_ampersand_paren = FALSE;</span></a>
<a name="4241"><span class="lineNum">    4241 </span><span class="lineNoCov">          0 :   a_boolean        final_cast_needed = FALSE;</span></a>
<a name="4242"><span class="lineNum">    4242 </span><span class="lineNoCov">          0 :   a_boolean        need_final_cast_close_paren = FALSE;</span></a>
<a name="4243"><span class="lineNum">    4243 </span><span class="lineNoCov">          0 :   a_boolean        need_offset_addition_close_paren = FALSE;</span></a>
<a name="4244"><span class="lineNum">    4244 </span><span class="lineNoCov">          0 :   a_boolean        need_char_star_cast_close_paren = FALSE;</span></a>
<a name="4245"><span class="lineNum">    4245 </span><span class="lineNoCov">          0 :   a_boolean        reinterpret_cast_needed = FALSE;</span></a>
<a name="4246"><span class="lineNum">    4246 </span><span class="lineNoCov">          0 :   a_boolean        need_reinterpret_cast_close_paren = FALSE;</span></a>
<a name="4247"><span class="lineNum">    4247 </span><span class="lineNoCov">          0 :   a_boolean        formed_useful_lvalue, need_char_star_cast = FALSE;</span></a>
<a name="4248"><span class="lineNum">    4248 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4249"><span class="lineNum">    4249 </span>            :   a_boolean        string_handle_case = FALSE;</a>
<a name="4250"><span class="lineNum">    4250 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4251"><span class="lineNum">    4251 </span>            : </a>
<a name="4252"><span class="lineNum">    4252 </span><span class="lineNoCov">          0 :   con_type = skip_typerefs(orig_type);</span></a>
<a name="4253"><span class="lineNum">    4253 </span>            :   /* When the address constant is cast to some strange type (e.g., long),</a>
<a name="4254"><span class="lineNum">    4254 </span>            :      do that as a final cast and don't try to accommodate it in the normal</a>
<a name="4255"><span class="lineNum">    4255 </span>            :      processing. */</a>
<a name="4256"><span class="lineNum">    4256 </span>            :   /* Note that the test for pointer includes reference as well. */</a>
<a name="4257"><span class="lineNum">    4257 </span><span class="lineNoCov">          0 :   if (constant-&gt;implicit_cast &amp;&amp; con_type-&gt;kind != (a_type_kind)tk_pointer) {</span></a>
<a name="4258"><span class="lineNum">    4258 </span><span class="lineNoCov">          0 :     check_assertion(!form_lvalue);</span></a>
<a name="4259"><span class="lineNum">    4259 </span>            :     cast_to_nonpointer = TRUE;</a>
<a name="4260"><span class="lineNum">    4260 </span>            :     final_cast_needed = TRUE;</a>
<a name="4261"><span class="lineNum">    4261 </span>            :     desired_type = NULL;</a>
<a name="4262"><span class="lineNum">    4262 </span><span class="lineNoCov">          0 :   } else if (</span></a>
<a name="4263"><span class="lineNum">    4263 </span>            : #if DEBUG</a>
<a name="4264"><span class="lineNum">    4264 </span><span class="lineNoCov">          0 :              !octl-&gt;debug_output &amp;&amp;</span></a>
<a name="4265"><span class="lineNum">    4265 </span>            : #endif /* DEBUG */</a>
<a name="4266"><span class="lineNum">    4266 </span>            :              !octl-&gt;c_generating_back_end &amp;&amp;</a>
<a name="4267"><span class="lineNum">    4267 </span><span class="lineNoCov">          0 :              constant-&gt;implicit_cast &amp;&amp;</span></a>
<a name="4268"><span class="lineNum">    4268 </span>            :              !(constant-&gt;explicit_cast_applied ||</a>
<a name="4269"><span class="lineNum">    4269 </span>            :                constant-&gt;is_compound_literal)) {</a>
<a name="4270"><span class="lineNum">    4270 </span>            :     /* The constant was cast, but only implicitly, so leave off the cast.</a>
<a name="4271"><span class="lineNum">    4271 </span>            :        Don't do this in the C-generating back end, because some casts</a>
<a name="4272"><span class="lineNum">    4272 </span>            :        added there are &quot;implicit&quot; and yet they have to be put out. */</a>
<a name="4273"><span class="lineNum">    4273 </span><span class="lineNoCov">          0 :     a_boolean need_desired_type = FALSE;</span></a>
<a name="4274"><span class="lineNum">    4274 </span><span class="lineNoCov">          0 :     if (constant-&gt;variant.address.kind == (an_address_base_kind)abk_variable) {</span></a>
<a name="4275"><span class="lineNum">    4275 </span><span class="lineNoCov">          0 :       a_type_ptr var_type =</span></a>
<a name="4276"><span class="lineNum">    4276 </span><span class="lineNoCov">          0 :                skip_typerefs(constant-&gt;variant.address.variant.variable-&gt;type);</span></a>
<a name="4277"><span class="lineNum">    4277 </span><span class="lineNoCov">          0 :       a_type_ptr target_type = f_skip_typerefs(type_pointed_to(con_type));</span></a>
<a name="4278"><span class="lineNum">    4278 </span><span class="lineNoCov">          0 :       if (is_array_type(var_type)) {</span></a>
<a name="4279"><span class="lineNum">    4279 </span>            :         /* The decay of an array variable to a pointer is implicit, but</a>
<a name="4280"><span class="lineNum">    4280 </span>            :          requires a non-NULL desired_type in the form_lvalue... routine</a>
<a name="4281"><span class="lineNum">    4281 </span>            :          to get the right result. */</a>
<a name="4282"><span class="lineNum">    4282 </span>            :         need_desired_type = TRUE;</a>
<a name="4283"><span class="lineNum">    4283 </span><span class="lineNoCov">          0 :       } else if (is_class_struct_union_type(var_type) &amp;&amp;</span></a>
<a name="4284"><span class="lineNum">    4284 </span><span class="lineNoCov">          0 :                  !standalone_identical_types(target_type, var_type)) {</span></a>
<a name="4285"><span class="lineNum">    4285 </span>            :         /* Similarly, if the variable is of a class type and the type of the</a>
<a name="4286"><span class="lineNum">    4286 </span>            :            constant is different (indicating that the constant addresses a</a>
<a name="4287"><span class="lineNum">    4287 </span>            :            member of the class/struct/union object and not the object itself),</a>
<a name="4288"><span class="lineNum">    4288 </span>            :            the target type is potentially needed to address the correct</a>
<a name="4289"><span class="lineNum">    4289 </span>            :            member. */</a>
<a name="4290"><span class="lineNum">    4290 </span>            :         need_desired_type = TRUE;</a>
<a name="4291"><span class="lineNum">    4291 </span>            :       }  /* if */</a>
<a name="4292"><span class="lineNum">    4292 </span>            :     }</a>
<a name="4293"><span class="lineNum">    4293 </span>            :     if (need_desired_type) {</a>
<a name="4294"><span class="lineNum">    4294 </span><span class="lineNoCov">          0 :       desired_type = type_pointed_to(con_type);</span></a>
<a name="4295"><span class="lineNum">    4295 </span>            :     } else {</a>
<a name="4296"><span class="lineNum">    4296 </span>            :       /* Normal implicit cast on a constant. */</a>
<a name="4297"><span class="lineNum">    4297 </span>            :       desired_type = NULL;</a>
<a name="4298"><span class="lineNum">    4298 </span>            :     }  /* if */</a>
<a name="4299"><span class="lineNum">    4299 </span>            :   } else {</a>
<a name="4300"><span class="lineNum">    4300 </span><span class="lineNoCov">          0 :     desired_type = con_type;</span></a>
<a name="4301"><span class="lineNum">    4301 </span><span class="lineNoCov">          0 :     desired_type = type_pointed_to(desired_type);</span></a>
<a name="4302"><span class="lineNum">    4302 </span>            :   }  /* if */</a>
<a name="4303"><span class="lineNum">    4303 </span><span class="lineNoCov">          0 :   if (constant-&gt;is_reinterpret_cast &amp;&amp; !octl-&gt;c_generating_back_end) {</span></a>
<a name="4304"><span class="lineNum">    4304 </span><span class="lineNoCov">          0 :     reinterpret_cast_needed = TRUE;</span></a>
<a name="4305"><span class="lineNum">    4305 </span>            :   }  /* if */</a>
<a name="4306"><span class="lineNum">    4306 </span>            :   /* Examine the addressed entity (without generating any code) to</a>
<a name="4307"><span class="lineNum">    4307 </span>            :      determine how it will be put out as an lvalue.  This lets us decide</a>
<a name="4308"><span class="lineNum">    4308 </span>            :      on putting out a leading cast, etc. before the lvalue is put out. */</a>
<a name="4309"><span class="lineNum">    4309 </span><span class="lineNoCov">          0 :   form_lvalue_for_addressed_entity(constant, desired_type,</span></a>
<a name="4310"><span class="lineNum">    4310 </span>            :                                    /*will_use_as_addr=*/!form_lvalue,</a>
<a name="4311"><span class="lineNum">    4311 </span>            :                                    /*base_entity_only=*/FALSE,</a>
<a name="4312"><span class="lineNum">    4312 </span>            :                                    /*gen_output=*/FALSE,</a>
<a name="4313"><span class="lineNum">    4313 </span>            :                                    &amp;achieved_type, &amp;type_decay_used, &amp;offset,</a>
<a name="4314"><span class="lineNum">    4314 </span>            :                                    &amp;formed_useful_lvalue, octl);</a>
<a name="4315"><span class="lineNum">    4315 </span><span class="lineNoCov">          0 :   if (!type_decay_used &amp;&amp; is_array_type(achieved_type) &amp;&amp; !form_lvalue) {</span></a>
<a name="4316"><span class="lineNum">    4316 </span>            :     /* Array for which type decay is not being used.  This means, so far,</a>
<a name="4317"><span class="lineNum">    4317 </span>            :        that we plan to put a &quot;&amp;&quot; in front of the array.  See if there's a</a>
<a name="4318"><span class="lineNum">    4318 </span>            :        reason not to. */</a>
<a name="4319"><span class="lineNum">    4319 </span><span class="lineNoCov">          0 :     if (octl-&gt;gen_pcc_code) {</span></a>
<a name="4320"><span class="lineNum">    4320 </span>            :       /* Don't do address-of-array in pcc mode, because pcc gives warnings</a>
<a name="4321"><span class="lineNum">    4321 </span>            :          on that and uses the pointer-to-element type anyway. */</a>
<a name="4322"><span class="lineNum">    4322 </span><span class="lineNoCov">          0 :       type_decay_used = TRUE;</span></a>
<a name="4323"><span class="lineNum">    4323 </span><span class="lineNoCov">          0 :     } else if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="4324"><span class="lineNum">    4324 </span><span class="lineNoCov">          0 :                constant-&gt;variant.address.kind ==</span></a>
<a name="4325"><span class="lineNum">    4325 </span><span class="lineNoCov">          0 :                                           (an_address_base_kind)abk_constant &amp;&amp;</span></a>
<a name="4326"><span class="lineNum">    4326 </span><span class="lineNoCov">          0 :                constant-&gt;variant.address.variant.constant-&gt;kind ==</span></a>
<a name="4327"><span class="lineNum">    4327 </span>            :                                              (a_constant_repr_kind)ck_string) {</a>
<a name="4328"><span class="lineNum">    4328 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4329"><span class="lineNum">    4329 </span>            :       if (is_handle_type(con_type)) {</a>
<a name="4330"><span class="lineNum">    4330 </span>            :         /* Omit the cast from a string literal to a handle type. */</a>
<a name="4331"><span class="lineNum">    4331 </span>            :         string_handle_case = TRUE;</a>
<a name="4332"><span class="lineNum">    4332 </span>            :       } else</a>
<a name="4333"><span class="lineNum">    4333 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4334"><span class="lineNum">    4334 </span>            :       /* Do not insert code here. */</a>
<a name="4335"><span class="lineNum">    4335 </span>            :       {</a>
<a name="4336"><span class="lineNum">    4336 </span>            :         /* Address of a string constant, e.g., &amp;&quot;abc&quot;.  Some ANSI/ISO C</a>
<a name="4337"><span class="lineNum">    4337 </span>            :            compilers have difficulty with that, perhaps because they don't</a>
<a name="4338"><span class="lineNum">    4338 </span>            :            believe a string is an lvalue.  Force type decay and a cast. */</a>
<a name="4339"><span class="lineNum">    4339 </span><span class="lineNoCov">          0 :         type_decay_used = TRUE;</span></a>
<a name="4340"><span class="lineNum">    4340 </span>            :       }</a>
<a name="4341"><span class="lineNum">    4341 </span><span class="lineNoCov">          0 :     } else if (offset != 0) {</span></a>
<a name="4342"><span class="lineNum">    4342 </span>            :       /* Some compilers have difficulty with getting the size right when</a>
<a name="4343"><span class="lineNum">    4343 </span>            :          adding an offset to the address of an array. */</a>
<a name="4344"><span class="lineNum">    4344 </span><span class="lineNoCov">          0 :       type_decay_used = TRUE;</span></a>
<a name="4345"><span class="lineNum">    4345 </span>            :     }  /* if */</a>
<a name="4346"><span class="lineNum">    4346 </span><span class="lineNoCov">          0 :     if (type_decay_used) {</span></a>
<a name="4347"><span class="lineNum">    4347 </span>            :       /* If we've turned on array type decay, adjust the type.  Note that</a>
<a name="4348"><span class="lineNum">    4348 </span>            :          because of the convention used for the achieved type, the</a>
<a name="4349"><span class="lineNum">    4349 </span>            :          pointer-to part of the type is not needed. */</a>
<a name="4350"><span class="lineNum">    4350 </span><span class="lineNoCov">          0 :       achieved_type = array_element_type(achieved_type);</span></a>
<a name="4351"><span class="lineNum">    4351 </span><span class="lineNoCov">          0 :       final_cast_needed = TRUE;</span></a>
<a name="4352"><span class="lineNum">    4352 </span>            :     }  /* if */</a>
<a name="4353"><span class="lineNum">    4353 </span>            :   }  /* if */</a>
<a name="4354"><span class="lineNum">    4354 </span><span class="lineNoCov">          0 :   if (offset != 0) {</span></a>
<a name="4355"><span class="lineNum">    4355 </span>            :     /* The offset is nonzero.  The general way of dealing with this is to cast</a>
<a name="4356"><span class="lineNum">    4356 </span>            :        to &quot;char *&quot; and add in the offset.  However, in the right situation</a>
<a name="4357"><span class="lineNum">    4357 </span>            :        the addition can be done without going to &quot;char *&quot;. */</a>
<a name="4358"><span class="lineNum">    4358 </span><span class="lineNoCov">          0 :     need_char_star_cast = TRUE;</span></a>
<a name="4359"><span class="lineNum">    4359 </span><span class="lineNoCov">          0 :     if (!form_lvalue) {</span></a>
<a name="4360"><span class="lineNum">    4360 </span><span class="lineNoCov">          0 :       a_targ_ptrdiff_t size = f_skip_typerefs(achieved_type)-&gt;size;</span></a>
<a name="4361"><span class="lineNum">    4361 </span><span class="lineNoCov">          0 :       if (size != 0 &amp;&amp; (offset % size) == 0) {</span></a>
<a name="4362"><span class="lineNum">    4362 </span><span class="lineNoCov">          0 :         need_char_star_cast = FALSE;</span></a>
<a name="4363"><span class="lineNum">    4363 </span><span class="lineNoCov">          0 :         offset /= size;</span></a>
<a name="4364"><span class="lineNum">    4364 </span>            :       }  /* if */</a>
<a name="4365"><span class="lineNum">    4365 </span>            :     }  /* if */</a>
<a name="4366"><span class="lineNum">    4366 </span><span class="lineNoCov">          0 :     if (need_char_star_cast) final_cast_needed = TRUE;</span></a>
<a name="4367"><span class="lineNum">    4367 </span>            :   }  /* if */</a>
<a name="4368"><span class="lineNum">    4368 </span>            :   /* See if we need a final cast to the desired type. */</a>
<a name="4369"><span class="lineNum">    4369 </span><span class="lineNoCov">          0 :   direct_achieved_type = skip_typedefs(achieved_type);</span></a>
<a name="4370"><span class="lineNum">    4370 </span><span class="lineNoCov">          0 :   direct_desired_type = (desired_type == NULL) ? (a_type_ptr)NULL</span></a>
<a name="4371"><span class="lineNum">    4371 </span><span class="lineNoCov">          0 :                                                : skip_typedefs(desired_type);</span></a>
<a name="4372"><span class="lineNum">    4372 </span><span class="lineNoCov">          0 :   if (desired_type != NULL &amp;&amp;</span></a>
<a name="4373"><span class="lineNum">    4373 </span><span class="lineNoCov">          0 :       !standalone_identical_types(direct_achieved_type, direct_desired_type)) {</span></a>
<a name="4374"><span class="lineNum">    4374 </span><span class="lineNoCov">          0 :     if (!constant-&gt;implicit_cast &amp;&amp;</span></a>
<a name="4375"><span class="lineNum">    4375 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.kind == (an_address_base_kind)abk_routine) {</span></a>
<a name="4376"><span class="lineNum">    4376 </span>            :       /* Function declarators don't get shared, so a pointer equality test</a>
<a name="4377"><span class="lineNum">    4377 </span>            :          doesn't work well.  We also can't use a routine like</a>
<a name="4378"><span class="lineNum">    4378 </span>            :          types_are_compatible to do a full test because those routines are</a>
<a name="4379"><span class="lineNum">    4379 </span>            :          not available in standalone utility programs.  It's okay to err on</a>
<a name="4380"><span class="lineNum">    4380 </span>            :          the side of putting out the cast, but in the most common case we</a>
<a name="4381"><span class="lineNum">    4381 </span>            :          can know that no cast is needed. */</a>
<a name="4382"><span class="lineNum">    4382 </span><span class="lineNoCov">          0 :     } else if (C_mode() &amp;&amp; is_directly_variably_modified_type(desired_type)) {</span></a>
<a name="4383"><span class="lineNum">    4383 </span>            :       /* Eliminate an implicit cast to a variably-modified type.  We know</a>
<a name="4384"><span class="lineNum">    4384 </span>            :          the cast is implicit because explicit casts to directly</a>
<a name="4385"><span class="lineNum">    4385 </span>            :          variably-modified types are not folded into the constant. */</a>
<a name="4386"><span class="lineNum">    4386 </span><span class="lineNoCov">          0 :       final_cast_needed = FALSE;</span></a>
<a name="4387"><span class="lineNum">    4387 </span>            :       /* Cast to &quot;(void *)&quot; in case there were intervening casts on the</a>
<a name="4388"><span class="lineNum">    4388 </span>            :          original entity before the implicit cast to a variably-modified</a>
<a name="4389"><span class="lineNum">    4389 </span>            :          type. */</a>
<a name="4390"><span class="lineNum">    4390 </span><span class="lineNoCov">          0 :       output_optional_open_paren(&amp;need_parens,</span></a>
<a name="4391"><span class="lineNum">    4391 </span>            :                                  &amp;need_final_cast_close_paren, octl);</a>
<a name="4392"><span class="lineNum">    4392 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(void *)&quot;, octl);</span></a>
<a name="4393"><span class="lineNum">    4393 </span><span class="lineNoCov">          0 :     } else if (octl-&gt;processing_nontype_template_argument &amp;&amp;</span></a>
<a name="4394"><span class="lineNum">    4394 </span><span class="lineNoCov">          0 :                octl-&gt;gen_compilable_code</span></a>
<a name="4395"><span class="lineNum">    4395 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="4396"><span class="lineNum">    4396 </span><span class="lineNoCov">          0 :                &amp;&amp; !microsoft_dialect_is_generated_code_target</span></a>
<a name="4397"><span class="lineNum">    4397 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="4398"><span class="lineNum">    4398 </span>            :                                                 ) {</a>
<a name="4399"><span class="lineNum">    4399 </span>            :       /* MSVC accepts a cast in a non-type template argument; otherwise, a</a>
<a name="4400"><span class="lineNum">    4400 </span>            :          non-type template argument that is an address constant must not</a>
<a name="4401"><span class="lineNum">    4401 </span>            :          have a cast applied. */</a>
<a name="4402"><span class="lineNum">    4402 </span>            :     } else {</a>
<a name="4403"><span class="lineNum">    4403 </span>            :       /* The proper type couldn't be achieved with address operators, so we</a>
<a name="4404"><span class="lineNum">    4404 </span>            :          need a final cast to adjust the type.  One important category of cases</a>
<a name="4405"><span class="lineNum">    4405 </span>            :          this handles is cases that require just qualification adjustments. */</a>
<a name="4406"><span class="lineNum">    4406 </span><span class="lineNoCov">          0 :       final_cast_needed = TRUE;</span></a>
<a name="4407"><span class="lineNum">    4407 </span>            :     }  /* if */</a>
<a name="4408"><span class="lineNum">    4408 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="4409"><span class="lineNum">    4409 </span><span class="lineNoCov">          0 :   } else if (constant-&gt;kind == (a_constant_repr_kind)ck_address &amp;&amp;</span></a>
<a name="4410"><span class="lineNum">    4410 </span><span class="lineNoCov">          0 :              constant-&gt;variant.address.kind ==</span></a>
<a name="4411"><span class="lineNum">    4411 </span><span class="lineNoCov">          0 :                                           (an_address_base_kind)abk_variable &amp;&amp;</span></a>
<a name="4412"><span class="lineNum">    4412 </span><span class="lineNoCov">          0 :              is_array_type(direct_achieved_type) &amp;&amp;</span></a>
<a name="4413"><span class="lineNum">    4413 </span><span class="lineNoCov">          0 :              !has_unknown_specified_bound(direct_achieved_type) &amp;&amp;</span></a>
<a name="4414"><span class="lineNum">    4414 </span><span class="lineNoCov">          0 :              direct_achieved_type-&gt;variant.array.variant.number_of_elements</span></a>
<a name="4415"><span class="lineNum">    4415 </span>            :                                                                         != 0) {</a>
<a name="4416"><span class="lineNum">    4416 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="4417"><span class="lineNum">    4417 </span>            :     a_type_ptr elem_type = underlying_array_element_type(direct_achieved_type);</a>
<a name="4418"><span class="lineNum">    4418 </span>            :     if (get_top_level_type_qualifiers(elem_type) &amp; TQ_CONST) {</a>
<a name="4419"><span class="lineNum">    4419 </span>            :       /* In some cases const qualifiers are removed from arrays to permit</a>
<a name="4420"><span class="lineNum">    4420 </span>            :          initialization by assignment.  We need to restore the qualifier by</a>
<a name="4421"><span class="lineNum">    4421 </span>            :          means of a cast so this address constant will have the proper type</a>
<a name="4422"><span class="lineNum">    4422 </span>            :          when used.  For example:</a>
<a name="4423"><span class="lineNum">    4423 </span>            : </a>
<a name="4424"><span class="lineNum">    4424 </span>            :              struct A {</a>
<a name="4425"><span class="lineNum">    4425 </span>            :                const char ccarray[32];</a>
<a name="4426"><span class="lineNum">    4426 </span>            :              } a = {&quot;constant string literal&quot;};</a>
<a name="4427"><span class="lineNum">    4427 </span>            :              void f() {</a>
<a name="4428"><span class="lineNum">    4428 </span>            :                const char (&amp;rconst)[32] = a.ccarray;</a>
<a name="4429"><span class="lineNum">    4429 </span>            :              }</a>
<a name="4430"><span class="lineNum">    4430 </span>            : </a>
<a name="4431"><span class="lineNum">    4431 </span>            :          A::ccarray is generated as non-const, so the reference to a.array</a>
<a name="4432"><span class="lineNum">    4432 </span>            :          must be cast to &quot;const char (*)[32]&quot; to have the required type. */</a>
<a name="4433"><span class="lineNum">    4433 </span>            :       final_cast_needed = TRUE;</a>
<a name="4434"><span class="lineNum">    4434 </span>            :     } else</a>
<a name="4435"><span class="lineNum">    4435 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="4436"><span class="lineNum">    4436 </span>            :     /* Do not insert code here. */</a>
<a name="4437"><span class="lineNum">    4437 </span><span class="lineNoCov">          0 :     if (msvc_is_generated_code_target &amp;&amp;</span></a>
<a name="4438"><span class="lineNum">    4438 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.variant.variable-&gt;is_template_variable &amp;&amp;</span></a>
<a name="4439"><span class="lineNum">    4439 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.offset == 0) {</span></a>
<a name="4440"><span class="lineNum">    4440 </span>            :       /* The Microsoft compiler cannot complete the type of a static data</a>
<a name="4441"><span class="lineNum">    4441 </span>            :          member of a template instance in cases like the following:</a>
<a name="4442"><span class="lineNum">    4442 </span>            : </a>
<a name="4443"><span class="lineNum">    4443 </span>            :              template&lt;typename T&gt; struct S {</a>
<a name="4444"><span class="lineNum">    4444 </span>            :                static int arr[];</a>
<a name="4445"><span class="lineNum">    4445 </span>            :              };</a>
<a name="4446"><span class="lineNum">    4446 </span>            :              template&lt;typename T&gt; int S&lt;T&gt;::arr[4];</a>
<a name="4447"><span class="lineNum">    4447 </span>            :              int (&amp;r)[4] = &amp;S&lt;int&gt;::arr;</a>
<a name="4448"><span class="lineNum">    4448 </span>            : </a>
<a name="4449"><span class="lineNum">    4449 </span>            :          We must therefore add a cast to the final type in such cases (but not</a>
<a name="4450"><span class="lineNum">    4450 </span>            :          if the array type is still incomplete, as MSVC++ cannot handle a cast</a>
<a name="4451"><span class="lineNum">    4451 </span>            :          to a reference to an array of unknown bound). */</a>
<a name="4452"><span class="lineNum">    4452 </span><span class="lineNoCov">          0 :       final_cast_needed = TRUE;</span></a>
<a name="4453"><span class="lineNum">    4453 </span>            :     }  /* if */</a>
<a name="4454"><span class="lineNum">    4454 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="4455"><span class="lineNum">    4455 </span>            :   }  /* if */</a>
<a name="4456"><span class="lineNum">    4456 </span><span class="lineNoCov">          0 :   if (final_cast_needed) {</span></a>
<a name="4457"><span class="lineNum">    4457 </span>            :     /* Generate a final cast to the constant type. */</a>
<a name="4458"><span class="lineNum">    4458 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens,</span></a>
<a name="4459"><span class="lineNum">    4459 </span>            :                                &amp;need_final_cast_close_paren, octl);</a>
<a name="4460"><span class="lineNum">    4460 </span><span class="lineNoCov">          0 :     if (!form_lvalue) {</span></a>
<a name="4461"><span class="lineNum">    4461 </span>            :       /* Forming an address, not an lvalue. */</a>
<a name="4462"><span class="lineNum">    4462 </span><span class="lineNoCov">          0 :       form_general_cast(con_type, reinterpret_cast_needed, octl);</span></a>
<a name="4463"><span class="lineNum">    4463 </span><span class="lineNoCov">          0 :       if (reinterpret_cast_needed) need_reinterpret_cast_close_paren = TRUE;</span></a>
<a name="4464"><span class="lineNum">    4464 </span><span class="lineNoCov">          0 :       if (cast_to_nonpointer) {</span></a>
<a name="4465"><span class="lineNum">    4465 </span><span class="lineNoCov">          0 :         a_targ_alignment alignment;</span></a>
<a name="4466"><span class="lineNum">    4466 </span>            :         /* This is a case where the final type is a nonpointer.  See if an</a>
<a name="4467"><span class="lineNum">    4467 </span>            :            extra cast to unsigned long is needed. */</a>
<a name="4468"><span class="lineNum">    4468 </span><span class="lineNoCov">          0 :         if (is_integral_or_enum_type(con_type) &amp;&amp;</span></a>
<a name="4469"><span class="lineNum">    4469 </span><span class="lineNoCov">          0 :             con_type-&gt;size &gt;= size_of_pointer_to(achieved_type, &amp;alignment)) {</span></a>
<a name="4470"><span class="lineNum">    4470 </span>            :           /* Cast to large-enough integral type.  No extra cast needed. */</a>
<a name="4471"><span class="lineNum">    4471 </span>            :         } else {</a>
<a name="4472"><span class="lineNum">    4472 </span>            :           /* Anything else (e.g., cast to float).  Go by way of unsigned long</a>
<a name="4473"><span class="lineNum">    4473 </span>            :              first. */</a>
<a name="4474"><span class="lineNum">    4474 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;(unsigned long)&quot;, octl);</span></a>
<a name="4475"><span class="lineNum">    4475 </span>            :         }  /* if */</a>
<a name="4476"><span class="lineNum">    4476 </span>            :       }  /* if */</a>
<a name="4477"><span class="lineNum">    4477 </span>            :     } else {</a>
<a name="4478"><span class="lineNum">    4478 </span><span class="lineNoCov">          0 :       a_type type_copy;</span></a>
<a name="4479"><span class="lineNum">    4479 </span>            :       /* When forming an lvalue (C++ only), generate a reference cast.</a>
<a name="4480"><span class="lineNum">    4480 </span>            :          Make a copy of the type so it can be changed to a reference type. */</a>
<a name="4481"><span class="lineNum">    4481 </span><span class="lineNoCov">          0 :       check_assertion(con_type-&gt;kind == (a_type_kind)tk_pointer);</span></a>
<a name="4482"><span class="lineNum">    4482 </span><span class="lineNoCov">          0 :       type_copy = *con_type;</span></a>
<a name="4483"><span class="lineNum">    4483 </span><span class="lineNoCov">          0 :       if (offset != 0 || il_header.source_language != sl_Cplusplus) {</span></a>
<a name="4484"><span class="lineNum">    4484 </span>            :         /* However, that's not possible when the offset is nonzero, or in</a>
<a name="4485"><span class="lineNum">    4485 </span>            :            C.  For those cases, use &quot;*(type *)&amp;x&quot;. */</a>
<a name="4486"><span class="lineNum">    4486 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;*&quot;, octl);</span></a>
<a name="4487"><span class="lineNum">    4487 </span><span class="lineNoCov">          0 :         type_copy.variant.pointer.is_reference = FALSE;</span></a>
<a name="4488"><span class="lineNum">    4488 </span><span class="lineNoCov">          0 :         form_cast(&amp;type_copy, octl);</span></a>
<a name="4489"><span class="lineNum">    4489 </span><span class="lineNoCov">          0 :         form_lvalue = FALSE;</span></a>
<a name="4490"><span class="lineNum">    4490 </span><span class="lineNoCov">          0 :         type_decay_used = FALSE;</span></a>
<a name="4491"><span class="lineNum">    4491 </span>            :       } else {</a>
<a name="4492"><span class="lineNum">    4492 </span>            :         /* Offset is zero, so use reference cast. */</a>
<a name="4493"><span class="lineNum">    4493 </span><span class="lineNoCov">          0 :         type_copy.variant.pointer.is_reference = TRUE;</span></a>
<a name="4494"><span class="lineNum">    4494 </span><span class="lineNoCov">          0 :         form_general_cast(&amp;type_copy, reinterpret_cast_needed, octl);</span></a>
<a name="4495"><span class="lineNum">    4495 </span><span class="lineNoCov">          0 :         if (reinterpret_cast_needed) need_reinterpret_cast_close_paren = TRUE;</span></a>
<a name="4496"><span class="lineNum">    4496 </span>            :       }  /* if */</a>
<a name="4497"><span class="lineNum">    4497 </span>            :     }  /* if */</a>
<a name="4498"><span class="lineNum">    4498 </span>            :   }  /* if */</a>
<a name="4499"><span class="lineNum">    4499 </span><span class="lineNoCov">          0 :   if (offset != 0) {</span></a>
<a name="4500"><span class="lineNum">    4500 </span>            :     /* The offset couldn't be handled with addressing operators, so it</a>
<a name="4501"><span class="lineNum">    4501 </span>            :        will be added in later.  Put parentheses around the offset</a>
<a name="4502"><span class="lineNum">    4502 </span>            :        computation. */</a>
<a name="4503"><span class="lineNum">    4503 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens,</span></a>
<a name="4504"><span class="lineNum">    4504 </span>            :                                &amp;need_offset_addition_close_paren, octl);</a>
<a name="4505"><span class="lineNum">    4505 </span>            :   }  /* if */</a>
<a name="4506"><span class="lineNum">    4506 </span><span class="lineNoCov">          0 :   if (need_char_star_cast) {</span></a>
<a name="4507"><span class="lineNum">    4507 </span>            :     /* Cast to &quot;char *&quot; because the scaling on the offset addition is wrong</a>
<a name="4508"><span class="lineNum">    4508 </span>            :        otherwise. */</a>
<a name="4509"><span class="lineNum">    4509 </span><span class="lineNoCov">          0 :     output_optional_open_paren(&amp;need_parens,</span></a>
<a name="4510"><span class="lineNum">    4510 </span>            :                                &amp;need_char_star_cast_close_paren, octl);</a>
<a name="4511"><span class="lineNum">    4511 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;(char *)&quot;, octl);</span></a>
<a name="4512"><span class="lineNum">    4512 </span>            :   }  /* if */</a>
<a name="4513"><span class="lineNum">    4513 </span><span class="lineNoCov">          0 :   if (!form_lvalue) {</span></a>
<a name="4514"><span class="lineNum">    4514 </span>            :     /* Forming an address, not an lvalue. */</a>
<a name="4515"><span class="lineNum">    4515 </span><span class="lineNoCov">          0 :     if (is_reference_type(con_type) &amp;&amp; !octl-&gt;gen_compilable_code) {</span></a>
<a name="4516"><span class="lineNum">    4516 </span>            :       /* Explicitly identify a reference type instead of using &quot;&amp;&quot;. */</a>
<a name="4517"><span class="lineNum">    4517 </span><span class="lineNoCov">          0 :       if (is_rvalue_reference_type(con_type)) {</span></a>
<a name="4518"><span class="lineNum">    4518 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;rvalue reference to &quot;, octl);</span></a>
<a name="4519"><span class="lineNum">    4519 </span>            :       } else {</a>
<a name="4520"><span class="lineNum">    4520 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;reference to &quot;, octl);</span></a>
<a name="4521"><span class="lineNum">    4521 </span>            :       }  /* if */</a>
<a name="4522"><span class="lineNum">    4522 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="4523"><span class="lineNum">    4523 </span>            :     } else if (is_tracking_reference_type(con_type) &amp;&amp;</a>
<a name="4524"><span class="lineNum">    4524 </span>            :                !octl-&gt;gen_compilable_code) {</a>
<a name="4525"><span class="lineNum">    4525 </span>            :         octl-&gt;output_str(&quot;tracking reference to &quot;, octl);</a>
<a name="4526"><span class="lineNum">    4526 </span>            :     } else if (is_handle_type(con_type) &amp;&amp; !octl-&gt;gen_compilable_code) {</a>
<a name="4527"><span class="lineNum">    4527 </span>            :       octl-&gt;output_str(&quot;handle to &quot;, octl);</a>
<a name="4528"><span class="lineNum">    4528 </span>            :     } else if (string_handle_case) {</a>
<a name="4529"><span class="lineNum">    4529 </span>            :       /* No &quot;&amp;&quot; for implicit cast of string literal to handle. */</a>
<a name="4530"><span class="lineNum">    4530 </span>            :     } else if (constant-&gt;variant.address.kind ==</a>
<a name="4531"><span class="lineNum">    4531 </span>            :                                        (an_address_base_kind)abk_cli_typeid ||</a>
<a name="4532"><span class="lineNum">    4532 </span>            :                constant-&gt;variant.address.kind ==</a>
<a name="4533"><span class="lineNum">    4533 </span>            :                                         (an_address_base_kind)abk_cli_array) {</a>
<a name="4534"><span class="lineNum">    4534 </span>            :       /* No &quot;&amp;&quot; for C++/CLI T::typeid or array constants. */</a>
<a name="4535"><span class="lineNum">    4535 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="4536"><span class="lineNum">    4536 </span><span class="lineNoCov">          0 :     } else if (type_decay_used) {</span></a>
<a name="4537"><span class="lineNum">    4537 </span>            :       /* Using type decay to get a pointer. */</a>
<a name="4538"><span class="lineNum">    4538 </span>            :     } else {</a>
<a name="4539"><span class="lineNum">    4539 </span><span class="lineNoCov">          0 :       output_optional_open_paren(&amp;need_parens, &amp;need_ampersand_paren, octl);</span></a>
<a name="4540"><span class="lineNum">    4540 </span><span class="lineNoCov">          0 :       if (constant-&gt;kind == (a_constant_repr_kind)ck_address &amp;&amp;</span></a>
<a name="4541"><span class="lineNum">    4541 </span><span class="lineNoCov">          0 :           constant-&gt;variant.address.kind == (an_address_base_kind)abk_label) {</span></a>
<a name="4542"><span class="lineNum">    4542 </span>            :         /* The address of a label is taken with &quot;&amp;&amp;&quot;, rather than the</a>
<a name="4543"><span class="lineNum">    4543 </span>            :            ordinary &quot;&amp;&quot;. */</a>
<a name="4544"><span class="lineNum">    4544 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&amp;&amp;&quot;, octl);</span></a>
<a name="4545"><span class="lineNum">    4545 </span>            :       } else {</a>
<a name="4546"><span class="lineNum">    4546 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="4547"><span class="lineNum">    4547 </span>            :       }  /* if */</a>
<a name="4548"><span class="lineNum">    4548 </span>            :     }  /* if */</a>
<a name="4549"><span class="lineNum">    4549 </span>            :   }  /* if */</a>
<a name="4550"><span class="lineNum">    4550 </span>            :   /* Generate code for the lvalue for the entity. */</a>
<a name="4551"><span class="lineNum">    4551 </span><span class="lineNoCov">          0 :   form_lvalue_for_addressed_entity(constant, desired_type,</span></a>
<a name="4552"><span class="lineNum">    4552 </span>            :                                    /*will_use_as_addr=*/!form_lvalue,</a>
<a name="4553"><span class="lineNum">    4553 </span>            :                                    /*base_entity_only=*/!formed_useful_lvalue,</a>
<a name="4554"><span class="lineNum">    4554 </span>            :                                    /*gen_output=*/TRUE,</a>
<a name="4555"><span class="lineNum">    4555 </span>            :                                    &amp;achieved_type, &amp;type_decay_used,</a>
<a name="4556"><span class="lineNum">    4556 </span>            :                                    &amp;dummy_offset,</a>
<a name="4557"><span class="lineNum">    4557 </span>            :                                    &amp;formed_useful_lvalue, octl);</a>
<a name="4558"><span class="lineNum">    4558 </span><span class="lineNoCov">          0 :   if (need_ampersand_paren) {</span></a>
<a name="4559"><span class="lineNum">    4559 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="4560"><span class="lineNum">    4560 </span>            :   }  /* if */</a>
<a name="4561"><span class="lineNum">    4561 </span><span class="lineNoCov">          0 :   output_optional_close_paren(need_char_star_cast_close_paren, octl);</span></a>
<a name="4562"><span class="lineNum">    4562 </span><span class="lineNoCov">          0 :   if (offset != 0) {</span></a>
<a name="4563"><span class="lineNum">    4563 </span>            :     /* Add in the (signed) offset. */</a>
<a name="4564"><span class="lineNum">    4564 </span><span class="lineNoCov">          0 :     if (offset &gt;= 0) {</span></a>
<a name="4565"><span class="lineNum">    4565 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; + &quot;, octl);</span></a>
<a name="4566"><span class="lineNum">    4566 </span>            :     } else {</a>
<a name="4567"><span class="lineNum">    4567 </span>            :       /* For negative numbers, the sign on the number will be the operator. */</a>
<a name="4568"><span class="lineNum">    4568 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="4569"><span class="lineNum">    4569 </span>            :     }  /* if */</a>
<a name="4570"><span class="lineNum">    4570 </span><span class="lineNoCov">          0 :     form_num((a_host_large_integer)offset, octl);</span></a>
<a name="4571"><span class="lineNum">    4571 </span><span class="lineNoCov">          0 :     output_optional_close_paren(need_offset_addition_close_paren, octl);</span></a>
<a name="4572"><span class="lineNum">    4572 </span>            :   }  /* if */</a>
<a name="4573"><span class="lineNum">    4573 </span><span class="lineNoCov">          0 :   if (need_reinterpret_cast_close_paren) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="4574"><span class="lineNum">    4574 </span><span class="lineNoCov">          0 :   output_optional_close_paren(need_final_cast_close_paren, octl);</span></a>
<a name="4575"><span class="lineNum">    4575 </span><span class="lineNoCov">          0 : }  /* form_address_constant */</span></a>
<a name="4576"><span class="lineNum">    4576 </span>            : </a>
<a name="4577"><span class="lineNum">    4577 </span>            : </a>
<a name="4578"><span class="lineNum">    4578 </span><span class="lineNoCov">          0 : static a_boolean is_enum_constant_equivalent(a_constant_ptr constant,</span></a>
<a name="4579"><span class="lineNum">    4579 </span>            :                                              a_constant_ptr *equiv_constant)</a>
<a name="4580"><span class="lineNum">    4580 </span>            : /*</a>
<a name="4581"><span class="lineNum">    4581 </span>            : Given a constant for which is_enum_constant is TRUE, see if it is</a>
<a name="4582"><span class="lineNum">    4582 </span>            : an equivalent of a named enum constant.  If it is, set *equiv_constant to</a>
<a name="4583"><span class="lineNum">    4583 </span>            : point to the enum constant and return TRUE.  An equivalent of an enum constant</a>
<a name="4584"><span class="lineNum">    4584 </span>            : is a copy of the enum constant made to be used in an initializer (because</a>
<a name="4585"><span class="lineNum">    4585 </span>            : an initializer requires an unshared copy of the constant).  It can be put</a>
<a name="4586"><span class="lineNum">    4586 </span>            : out as the original enum constant.</a>
<a name="4587"><span class="lineNum">    4587 </span>            : */</a>
<a name="4588"><span class="lineNum">    4588 </span>            : {</a>
<a name="4589"><span class="lineNum">    4589 </span><span class="lineNoCov">          0 :   a_boolean      is_enum_equiv = FALSE;</span></a>
<a name="4590"><span class="lineNum">    4590 </span><span class="lineNoCov">          0 :   a_type_ptr     con_type = constant-&gt;type, enum_type;</span></a>
<a name="4591"><span class="lineNum">    4591 </span><span class="lineNoCov">          0 :   a_constant_ptr con;</span></a>
<a name="4592"><span class="lineNum">    4592 </span>            : </a>
<a name="4593"><span class="lineNum">    4593 </span><span class="lineNoCov">          0 :   *equiv_constant = NULL;</span></a>
<a name="4594"><span class="lineNum">    4594 </span><span class="lineNoCov">          0 :   con_type = skip_typerefs(con_type);</span></a>
<a name="4595"><span class="lineNum">    4595 </span>            :   /* Get the enum type. */</a>
<a name="4596"><span class="lineNum">    4596 </span><span class="lineNoCov">          0 :   if (il_header.source_language == sl_Cplusplus) {</span></a>
<a name="4597"><span class="lineNum">    4597 </span>            :     enum_type = con_type;</a>
<a name="4598"><span class="lineNum">    4598 </span>            :   } else {</a>
<a name="4599"><span class="lineNum">    4599 </span>            :     /* In C, enum constants have type int but an affiliated type that is the</a>
<a name="4600"><span class="lineNum">    4600 </span>            :        enum type. */</a>
<a name="4601"><span class="lineNum">    4601 </span><span class="lineNoCov">          0 :     enum_type = con_type-&gt;variant.integer.enum_info.affiliated_type;</span></a>
<a name="4602"><span class="lineNum">    4602 </span>            :   }  /* if */</a>
<a name="4603"><span class="lineNum">    4603 </span><span class="lineNoCov">          0 :   check_assertion(enum_type-&gt;kind == (a_type_kind)tk_integer &amp;&amp;</span></a>
<a name="4604"><span class="lineNum">    4604 </span>            :                   enum_type-&gt;variant.integer.enum_type);</a>
<a name="4605"><span class="lineNum">    4605 </span>            :   /* Go through the list of enum constants and compare each one to the</a>
<a name="4606"><span class="lineNum">    4606 </span>            :      constant we want. */</a>
<a name="4607"><span class="lineNum">    4607 </span><span class="lineNoCov">          0 :   for (con = enum_constants(enum_type); con != NULL; con = con-&gt;next) {</span></a>
<a name="4608"><span class="lineNum">    4608 </span>            :     /* Compare the constant on the list to the one we want. */</a>
<a name="4609"><span class="lineNum">    4609 </span><span class="lineNoCov">          0 :     if (cmp_integer_constants(con, constant) == 0) {</span></a>
<a name="4610"><span class="lineNum">    4610 </span>            :       /* Equal, so we found the constant we want. */</a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineNoCov">          0 :       is_enum_equiv = TRUE;</span></a>
<a name="4612"><span class="lineNum">    4612 </span><span class="lineNoCov">          0 :       *equiv_constant = con;</span></a>
<a name="4613"><span class="lineNum">    4613 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="4614"><span class="lineNum">    4614 </span>            :     }  /* if */</a>
<a name="4615"><span class="lineNum">    4615 </span>            :     /* Keep looking.  Note that there is no guarantee that the constants are</a>
<a name="4616"><span class="lineNum">    4616 </span>            :        in ascending order, so we can't stop on a too-large constant. */</a>
<a name="4617"><span class="lineNum">    4617 </span>            :   }  /* for */</a>
<a name="4618"><span class="lineNum">    4618 </span><span class="lineNoCov">          0 :   return is_enum_equiv;</span></a>
<a name="4619"><span class="lineNum">    4619 </span>            : }  /* is_enum_constant_equivalent */</a>
<a name="4620"><span class="lineNum">    4620 </span>            : </a>
<a name="4621"><span class="lineNum">    4621 </span>            : </a>
<a name="4622"><span class="lineNum">    4622 </span><span class="lineNoCov">          0 : void form_unknown_function_constant(</span></a>
<a name="4623"><span class="lineNum">    4623 </span>            :                              a_constant_ptr                        constant,</a>
<a name="4624"><span class="lineNum">    4624 </span>            :                              an_il_to_str_output_control_block_ptr octl)</a>
<a name="4625"><span class="lineNum">    4625 </span>            : /*</a>
<a name="4626"><span class="lineNum">    4626 </span>            : Output the name indicated by a ck_template_param/tpck_unknown_function</a>
<a name="4627"><span class="lineNum">    4627 </span>            : or .../tpck_template_ref constant.  Note that while the constant represents</a>
<a name="4628"><span class="lineNum">    4628 </span>            : the address of the unknown function, this routine puts out just the name,</a>
<a name="4629"><span class="lineNum">    4629 </span>            : without a leading &quot;&amp;&quot;.  Do the output in the way described by octl.</a>
<a name="4630"><span class="lineNum">    4630 </span>            : */</a>
<a name="4631"><span class="lineNum">    4631 </span>            : {</a>
<a name="4632"><span class="lineNum">    4632 </span><span class="lineNoCov">          0 :   a_boolean      is_template = FALSE;</span></a>
<a name="4633"><span class="lineNum">    4633 </span><span class="lineNoCov">          0 :   a_constant_ptr con = constant;</span></a>
<a name="4634"><span class="lineNum">    4634 </span>            : </a>
<a name="4635"><span class="lineNum">    4635 </span><span class="lineNoCov">          0 :   check_assertion(constant-&gt;kind == (a_constant_repr_kind)ck_template_param);</span></a>
<a name="4636"><span class="lineNum">    4636 </span><span class="lineNoCov">          0 :   if (constant-&gt;variant.template_param.kind ==</span></a>
<a name="4637"><span class="lineNum">    4637 </span>            :                            (a_template_param_constant_kind)tpck_template_ref) {</a>
<a name="4638"><span class="lineNum">    4638 </span><span class="lineNoCov">          0 :     is_template = TRUE;</span></a>
<a name="4639"><span class="lineNum">    4639 </span><span class="lineNoCov">          0 :     con = constant-&gt;variant.template_param.variant.template_ref.con;</span></a>
<a name="4640"><span class="lineNum">    4640 </span>            :   }  /* if */</a>
<a name="4641"><span class="lineNum">    4641 </span><span class="lineNoCov">          0 :   check_assertion(con-&gt;variant.template_param.kind ==</span></a>
<a name="4642"><span class="lineNum">    4642 </span>            :                         (a_template_param_constant_kind)tpck_unknown_function);</a>
<a name="4643"><span class="lineNum">    4643 </span><span class="lineNoCov">          0 :   if (con-&gt;variant.template_param.variant.unknown_function.</span></a>
<a name="4644"><span class="lineNum">    4644 </span>            :                                                      conversion_type != NULL) {</a>
<a name="4645"><span class="lineNum">    4645 </span>            :     /* The associated function is a conversion function.  Generate</a>
<a name="4646"><span class="lineNum">    4646 </span>            :        its name from the type. */</a>
<a name="4647"><span class="lineNum">    4647 </span><span class="lineNoCov">          0 :     check_assertion(con-&gt;source_corresp.is_class_member);</span></a>
<a name="4648"><span class="lineNum">    4648 </span><span class="lineNoCov">          0 :     form_class_qualifier(parent_class_of(con),</span></a>
<a name="4649"><span class="lineNum">    4649 </span>            :                          /*for_ptr_to_data_member=*/FALSE, octl);</a>
<a name="4650"><span class="lineNum">    4650 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;operator &quot;, octl);</span></a>
<a name="4651"><span class="lineNum">    4651 </span><span class="lineNoCov">          0 :     form_type(con-&gt;variant.template_param.variant.</span></a>
<a name="4652"><span class="lineNum">    4652 </span>            :                                               unknown_function.conversion_type,</a>
<a name="4653"><span class="lineNum">    4653 </span>            :               octl);</a>
<a name="4654"><span class="lineNum">    4654 </span>            :   } else {</a>
<a name="4655"><span class="lineNum">    4655 </span>            :     /* Normal case (not a conversion function). */</a>
<a name="4656"><span class="lineNum">    4656 </span><span class="lineNoCov">          0 :     a_boolean saved_force_qualified_name = octl-&gt;force_qualified_name;</span></a>
<a name="4657"><span class="lineNum">    4657 </span><span class="lineNoCov">          0 :     octl-&gt;force_qualified_name = con-&gt;variant.template_param.is_qualified_name;</span></a>
<a name="4658"><span class="lineNum">    4658 </span><span class="lineNoCov">          0 :     if (is_template &amp;&amp; octl-&gt;output_template_name != NULL) {</span></a>
<a name="4659"><span class="lineNum">    4659 </span><span class="lineNoCov">          0 :       octl-&gt;output_template_name((char *)&amp;con-&gt;source_corresp,</span></a>
<a name="4660"><span class="lineNum">    4660 </span>            :                                  iek_constant);</a>
<a name="4661"><span class="lineNum">    4661 </span><span class="lineNoCov">          0 :     } else if (con-&gt;source_corresp.member_of_unknown_base &amp;&amp;</span></a>
<a name="4662"><span class="lineNum">    4662 </span>            :                !con-&gt;source_corresp.qualified_unknown_base_member) {</a>
<a name="4663"><span class="lineNum">    4663 </span>            :       /* We're pretending that we found the member in a dependent base</a>
<a name="4664"><span class="lineNum">    4664 </span>            :          class and the original form of the reference was unqualified. */</a>
<a name="4665"><span class="lineNum">    4665 </span><span class="lineNoCov">          0 :       form_unqualified_name(&amp;con-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="4666"><span class="lineNum">    4666 </span>            :     } else {</a>
<a name="4667"><span class="lineNum">    4667 </span><span class="lineNoCov">          0 :       form_name(&amp;con-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="4668"><span class="lineNum">    4668 </span>            :     }  /* if */</a>
<a name="4669"><span class="lineNum">    4669 </span><span class="lineNoCov">          0 :     octl-&gt;force_qualified_name = saved_force_qualified_name;</span></a>
<a name="4670"><span class="lineNum">    4670 </span>            :   }  /* if */</a>
<a name="4671"><span class="lineNum">    4671 </span><span class="lineNoCov">          0 :   if (is_template) {</span></a>
<a name="4672"><span class="lineNum">    4672 </span>            :     /* Add the template arguments. */</a>
<a name="4673"><span class="lineNum">    4673 </span><span class="lineNoCov">          0 :     form_template_args(constant-&gt;variant.template_param.variant.</span></a>
<a name="4674"><span class="lineNum">    4674 </span>            :                                                          template_ref.arg_list,</a>
<a name="4675"><span class="lineNum">    4675 </span>            :                        octl);</a>
<a name="4676"><span class="lineNum">    4676 </span>            :   }  /* if */</a>
<a name="4677"><span class="lineNum">    4677 </span><span class="lineNoCov">          0 : }  /* form_unknown_function_constant */</span></a>
<a name="4678"><span class="lineNum">    4678 </span>            : </a>
<a name="4679"><span class="lineNum">    4679 </span>            : #if FIXED_POINT_ALLOWED</a>
<a name="4680"><span class="lineNum">    4680 </span>            : </a>
<a name="4681"><span class="lineNum">    4681 </span><span class="lineNoCov">          0 : static void form_fixed_point_constant(</span></a>
<a name="4682"><span class="lineNum">    4682 </span>            :                             a_fixed_point_value                    *value,</a>
<a name="4683"><span class="lineNum">    4683 </span>            :                             a_fixed_point_type_descr               *fxp_descr,</a>
<a name="4684"><span class="lineNum">    4684 </span>            :                             an_il_to_str_output_control_block_ptr  octl)</a>
<a name="4685"><span class="lineNum">    4685 </span>            : /*</a>
<a name="4686"><span class="lineNum">    4686 </span>            : Output the given fixed-point value with the proper suffix.</a>
<a name="4687"><span class="lineNum">    4687 </span>            : */</a>
<a name="4688"><span class="lineNum">    4688 </span>            : {</a>
<a name="4689"><span class="lineNum">    4689 </span><span class="lineNoCov">          0 :   char  *str = fxp_to_string(fxp_descr, value);</span></a>
<a name="4690"><span class="lineNum">    4690 </span>            : </a>
<a name="4691"><span class="lineNum">    4691 </span><span class="lineNoCov">          0 :   octl-&gt;output_str(str, octl);</span></a>
<a name="4692"><span class="lineNum">    4692 </span>            : }  /* form_fixed_point_constant */</a>
<a name="4693"><span class="lineNum">    4693 </span>            : </a>
<a name="4694"><span class="lineNum">    4694 </span>            : #endif /* FIXED_POINT_ALLOWED */</a>
<a name="4695"><span class="lineNum">    4695 </span>            : </a>
<a name="4696"><span class="lineNum">    4696 </span>            : #if !((BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4697"><span class="lineNum">    4697 </span>            :       BUILTIN_FUNCTIONS_ENABLED)</a>
<a name="4698"><span class="lineNum">    4698 </span>            : /*ARGSUSED*/ /* expr is not used in this case. */</a>
<a name="4699"><span class="lineNum">    4699 </span>            : #endif /* !((BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; ... */</a>
<a name="4700"><span class="lineNum">    4700 </span><span class="lineCov">          2 : static void form_float_constant(</span></a>
<a name="4701"><span class="lineNum">    4701 </span>            :                            an_internal_float_value               *float_value,</a>
<a name="4702"><span class="lineNum">    4702 </span>            :                            a_float_kind                          fkind,</a>
<a name="4703"><span class="lineNum">    4703 </span>            :                            an_expr_node_ptr                      expr,</a>
<a name="4704"><span class="lineNum">    4704 </span>            :                            an_il_to_str_output_control_block_ptr octl)</a>
<a name="4705"><span class="lineNum">    4705 </span>            : /*</a>
<a name="4706"><span class="lineNum">    4706 </span>            : Output the given floating-point value with the proper suffix (or cast in</a>
<a name="4707"><span class="lineNum">    4707 </span>            : K&amp;R/pcc mode) determined by fkind.  Typically a decimal string is generated,</a>
<a name="4708"><span class="lineNum">    4708 </span>            : but when generating compilable output, a hexadecimal string will be</a>
<a name="4709"><span class="lineNum">    4709 </span>            : generated (in configurations that support that).  When expr is non-NULL,</a>
<a name="4710"><span class="lineNum">    4710 </span>            : it represents a backing expression for the floating-point constant value.</a>
<a name="4711"><span class="lineNum">    4711 </span>            : */</a>
<a name="4712"><span class="lineNum">    4712 </span>            : {</a>
<a name="4713"><span class="lineNum">    4713 </span><span class="lineCov">          2 :   a_const_char  *str, *suffix = &quot;&quot;;</span></a>
<a name="4714"><span class="lineNum">    4714 </span><span class="lineCov">          2 :   char          buf[64];</span></a>
<a name="4715"><span class="lineNum">    4715 </span><span class="lineCov">          2 :   a_boolean pos_infinity, neg_infinity, not_a_number;</span></a>
<a name="4716"><span class="lineNum">    4716 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4717"><span class="lineNum">    4717 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4718"><span class="lineNum">    4718 </span>            :   a_routine_ptr rp;</a>
<a name="4719"><span class="lineNum">    4719 </span>            :   an_expr_node_ptr arg;</a>
<a name="4720"><span class="lineNum">    4720 </span>            :   a_constant_ptr string_con;</a>
<a name="4721"><span class="lineNum">    4721 </span>            :   a_const_char  *gnu_builtin_suffix = &quot;&quot;;</a>
<a name="4722"><span class="lineNum">    4722 </span>            :   int           max_exp = targ_dbl_max_exp;</a>
<a name="4723"><span class="lineNum">    4723 </span>            :   unsigned long gnu_targ_version =</a>
<a name="4724"><span class="lineNum">    4724 </span>            : #if GCC_IS_GENERATED_CODE_TARGET || \</a>
<a name="4725"><span class="lineNum">    4725 </span>            :     (BACK_END_IS_CP_GEN_BE &amp;&amp; CP_GEN_BE_TARGET_MATCHES_SOURCE_DIALECT)</a>
<a name="4726"><span class="lineNum">    4726 </span>            :                                    gnu_target_version_number;</a>
<a name="4727"><span class="lineNum">    4727 </span>            : #else /* !(GCC_IS_GENERATED_CODE_TARGET || ...) */</a>
<a name="4728"><span class="lineNum">    4728 </span>            :   /* We don't have a variable that gives us the actual target version, but</a>
<a name="4729"><span class="lineNum">    4729 </span>            :      all gcc versions since 2.96 (including ones newer than 3.2) can handle</a>
<a name="4730"><span class="lineNum">    4730 </span>            :      the &quot;large constant&quot; form of HUGE_VAL, so we'll assume that. */</a>
<a name="4731"><span class="lineNum">    4731 </span>            :                                    29600;</a>
<a name="4732"><span class="lineNum">    4732 </span>            : #endif /* GCC_IS_GENERATED_CODE_TARGET || ... */</a>
<a name="4733"><span class="lineNum">    4733 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4734"><span class="lineNum">    4734 </span>            : </a>
<a name="4735"><span class="lineNum">    4735 </span><span class="lineCov">          2 :   if (!octl-&gt;gen_pcc_code) {</span></a>
<a name="4736"><span class="lineNum">    4736 </span>            :     /* Determine the suffix. */</a>
<a name="4737"><span class="lineNum">    4737 </span><span class="lineCov">          2 :     if (fkind == (a_float_kind)fk_float) {</span></a>
<a name="4738"><span class="lineNum">    4738 </span>            :       suffix = &quot;F&quot;;</a>
<a name="4739"><span class="lineNum">    4739 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4740"><span class="lineNum">    4740 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4741"><span class="lineNum">    4741 </span>            :       gnu_builtin_suffix = &quot;f&quot;;</a>
<a name="4742"><span class="lineNum">    4742 </span>            :       max_exp = targ_flt_max_exp;</a>
<a name="4743"><span class="lineNum">    4743 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4744"><span class="lineNum">    4744 </span><span class="lineNoCov">          0 :     } else if (fkind == (a_float_kind)fk_long_double) {</span></a>
<a name="4745"><span class="lineNum">    4745 </span>            :       suffix = &quot;L&quot;;</a>
<a name="4746"><span class="lineNum">    4746 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="4747"><span class="lineNum">    4747 </span>            : #if LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C</a>
<a name="4748"><span class="lineNum">    4748 </span>            :       /* No suffix when generating long double as double in the</a>
<a name="4749"><span class="lineNum">    4749 </span>            :          C-generating back end. */</a>
<a name="4750"><span class="lineNum">    4750 </span>            :       if (octl-&gt;c_generating_back_end) suffix = &quot;&quot;;</a>
<a name="4751"><span class="lineNum">    4751 </span>            : #endif /* LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C */</a>
<a name="4752"><span class="lineNum">    4752 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="4753"><span class="lineNum">    4753 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4754"><span class="lineNum">    4754 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4755"><span class="lineNum">    4755 </span>            :       gnu_builtin_suffix = &quot;l&quot;;</a>
<a name="4756"><span class="lineNum">    4756 </span>            :       max_exp = targ_ldbl_max_exp;</a>
<a name="4757"><span class="lineNum">    4757 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineNoCov">          0 :     } else if (fkind == (a_float_kind)fk_float80) {</span></a>
<a name="4759"><span class="lineNum">    4759 </span>            :       suffix = &quot;W&quot;;</a>
<a name="4760"><span class="lineNum">    4760 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4761"><span class="lineNum">    4761 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4762"><span class="lineNum">    4762 </span>            :       gnu_builtin_suffix = &quot;w&quot;;</a>
<a name="4763"><span class="lineNum">    4763 </span>            :       max_exp = targ_flt80_max_exp;</a>
<a name="4764"><span class="lineNum">    4764 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4765"><span class="lineNum">    4765 </span><span class="lineNoCov">          0 :     } else if (fkind == (a_float_kind)fk_float128) {</span></a>
<a name="4766"><span class="lineNum">    4766 </span><span class="lineNoCov">          0 :       suffix = &quot;Q&quot;;</span></a>
<a name="4767"><span class="lineNum">    4767 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4768"><span class="lineNum">    4768 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4769"><span class="lineNum">    4769 </span>            :       gnu_builtin_suffix = &quot;q&quot;;</a>
<a name="4770"><span class="lineNum">    4770 </span>            :       max_exp = targ_flt128_max_exp;</a>
<a name="4771"><span class="lineNum">    4771 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4772"><span class="lineNum">    4772 </span>            :     }  /* if */</a>
<a name="4773"><span class="lineNum">    4773 </span><span class="lineCov">          2 :     if (octl-&gt;part_of_ud_literal) {</span></a>
<a name="4774"><span class="lineNum">    4774 </span>            :       /* Suppress the suffix on the numeric part of a user-defined literal</a>
<a name="4775"><span class="lineNum">    4775 </span>            :          lest it be considered part of the literal suffix. */</a>
<a name="4776"><span class="lineNum">    4776 </span><span class="lineNoCov">          0 :       suffix = &quot;&quot;;</span></a>
<a name="4777"><span class="lineNum">    4777 </span>            :     }  /* if */</a>
<a name="4778"><span class="lineNum">    4778 </span>            :   } else {</a>
<a name="4779"><span class="lineNum">    4779 </span>            :     /* Generating K&amp;R C.  Suffixes are not allowed. */</a>
<a name="4780"><span class="lineNum">    4780 </span>            :     /* Cast to float if type is float (by default it would be double). */</a>
<a name="4781"><span class="lineNum">    4781 </span><span class="lineNoCov">          0 :     if (fkind == (a_float_kind)fk_float) {</span></a>
<a name="4782"><span class="lineNum">    4782 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(float)&quot;, octl);</span></a>
<a name="4783"><span class="lineNum">    4783 </span>            :     }  /* if */</a>
<a name="4784"><span class="lineNum">    4784 </span>            :   }  /* if */</a>
<a name="4785"><span class="lineNum">    4785 </span>            : #if USE_HEX_FP_CONSTANTS_IN_GENERATED_CODE</a>
<a name="4786"><span class="lineNum">    4786 </span>            :   if (octl-&gt;gen_compilable_code &amp;&amp; !octl-&gt;gen_pcc_code) {</a>
<a name="4787"><span class="lineNum">    4787 </span>            :     /* When generating code that will be compiled by a back end, don't</a>
<a name="4788"><span class="lineNum">    4788 </span>            :        bother to do the conversion from floating-point to decimal string</a>
<a name="4789"><span class="lineNum">    4789 </span>            :        conversion (which may lose precision -- and requires the opposite</a>
<a name="4790"><span class="lineNum">    4790 </span>            :        conversion by the back end).  Instead, use a hexadecimal</a>
<a name="4791"><span class="lineNum">    4791 </span>            :        floating-point string (when the back end supports that). */</a>
<a name="4792"><span class="lineNum">    4792 </span>            :     str = fp_to_hex_constant_string(fkind, float_value,</a>
<a name="4793"><span class="lineNum">    4793 </span>            :                                     &amp;pos_infinity, &amp;neg_infinity,</a>
<a name="4794"><span class="lineNum">    4794 </span>            :                                     &amp;not_a_number);</a>
<a name="4795"><span class="lineNum">    4795 </span>            :   } else</a>
<a name="4796"><span class="lineNum">    4796 </span>            : #endif /* USE_HEX_FP_CONSTANTS_IN_GENERATED_CODE */</a>
<a name="4797"><span class="lineNum">    4797 </span>            :   /* Do not insert code here. */</a>
<a name="4798"><span class="lineNum">    4798 </span>            :   {</a>
<a name="4799"><span class="lineNum">    4799 </span>            :     /* Generate a decimal string that best represents the floating-point</a>
<a name="4800"><span class="lineNum">    4800 </span>            :        value. */</a>
<a name="4801"><span class="lineNum">    4801 </span><span class="lineCov">          2 :     str = fp_to_string(fkind, float_value,</span></a>
<a name="4802"><span class="lineNum">    4802 </span>            :                        &amp;pos_infinity, &amp;neg_infinity, &amp;not_a_number);</a>
<a name="4803"><span class="lineNum">    4803 </span>            :   }  /* if */</a>
<a name="4804"><span class="lineNum">    4804 </span><span class="lineCov">          2 :   if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="4805"><span class="lineNum">    4805 </span><span class="lineCov">          2 :       (pos_infinity || neg_infinity || not_a_number)) {</span></a>
<a name="4806"><span class="lineNum">    4806 </span>            :     /* In compilable code, generate NaNs and Infinities as expressions.</a>
<a name="4807"><span class="lineNum">    4807 </span>            :        0.0/0.0 gives a NaN, 1.0/0.0 gives an infinity. */</a>
<a name="4808"><span class="lineNum">    4808 </span><span class="lineNoCov">          0 :     a_const_char *dividend;</span></a>
<a name="4809"><span class="lineNum">    4809 </span><span class="lineNoCov">          0 :     if (not_a_number) {</span></a>
<a name="4810"><span class="lineNum">    4810 </span>            :       dividend = &quot;0.0&quot;;</a>
<a name="4811"><span class="lineNum">    4811 </span><span class="lineNoCov">          0 :     } else if (pos_infinity) {</span></a>
<a name="4812"><span class="lineNum">    4812 </span>            :       dividend = &quot;1.0&quot;;</a>
<a name="4813"><span class="lineNum">    4813 </span>            :     } else {</a>
<a name="4814"><span class="lineNum">    4814 </span><span class="lineNoCov">          0 :       dividend = &quot;-1.0&quot;;</span></a>
<a name="4815"><span class="lineNum">    4815 </span>            :     }  /* if */</a>
<a name="4816"><span class="lineNum">    4816 </span>            : #if (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; \</a>
<a name="4817"><span class="lineNum">    4817 </span>            :     BUILTIN_FUNCTIONS_ENABLED</a>
<a name="4818"><span class="lineNum">    4818 </span>            :     if (not_a_number &amp;&amp; expr != NULL) {</a>
<a name="4819"><span class="lineNum">    4819 </span>            :       /* Strip any compiler-generated casts from the backing expression before</a>
<a name="4820"><span class="lineNum">    4820 </span>            :          testing it below. */</a>
<a name="4821"><span class="lineNum">    4821 </span>            :       while (is_operation_node(expr) &amp;&amp;</a>
<a name="4822"><span class="lineNum">    4822 </span>            :              expr-&gt;variant.operation.compiler_generated &amp;&amp;</a>
<a name="4823"><span class="lineNum">    4823 </span>            :              is_cast_operation_node(expr)) {</a>
<a name="4824"><span class="lineNum">    4824 </span>            :         expr = expr-&gt;variant.operation.operands;</a>
<a name="4825"><span class="lineNum">    4825 </span>            :       }  /* while */</a>
<a name="4826"><span class="lineNum">    4826 </span>            :     }  /* if */</a>
<a name="4827"><span class="lineNum">    4827 </span>            :     if (not_a_number &amp;&amp;</a>
<a name="4828"><span class="lineNum">    4828 </span>            :         (clang_is_generated_code_target ||</a>
<a name="4829"><span class="lineNum">    4829 </span>            :          (msvc_is_generated_code_target &amp;&amp;</a>
<a name="4830"><span class="lineNum">    4830 </span>            :           msvc_target_version_number &gt;= 1900) ||</a>
<a name="4831"><span class="lineNum">    4831 </span>            :          (gcc_is_generated_code_target &amp;&amp;</a>
<a name="4832"><span class="lineNum">    4832 </span>            :           gnu_targ_version &gt;= 30300)) &amp;&amp;</a>
<a name="4833"><span class="lineNum">    4833 </span>            :         expr != NULL &amp;&amp;</a>
<a name="4834"><span class="lineNum">    4834 </span>            :         is_operation_node(expr) &amp;&amp;</a>
<a name="4835"><span class="lineNum">    4835 </span>            :         node_operator_is(expr, eok_call) &amp;&amp;</a>
<a name="4836"><span class="lineNum">    4836 </span>            :         is_routine_node(expr-&gt;variant.operation.operands) &amp;&amp;</a>
<a name="4837"><span class="lineNum">    4837 </span>            :         (rp = expr-&gt;variant.operation.operands-&gt;variant.routine.ptr,</a>
<a name="4838"><span class="lineNum">    4838 </span>            :          arg = expr-&gt;variant.operation.operands-&gt;next,</a>
<a name="4839"><span class="lineNum">    4839 </span>            :          is_gnu_builtin_function(rp) &amp;&amp;</a>
<a name="4840"><span class="lineNum">    4840 </span>            :          is_constant_node(arg) &amp;&amp;</a>
<a name="4841"><span class="lineNum">    4841 </span>            :          node_constant(arg)-&gt;kind == (a_constant_repr_kind)ck_address &amp;&amp;</a>
<a name="4842"><span class="lineNum">    4842 </span>            :          (string_con = node_constant(arg)-&gt;variant.address.variant.constant,</a>
<a name="4843"><span class="lineNum">    4843 </span>            :           string_con-&gt;kind == (a_constant_repr_kind)ck_string))) {</a>
<a name="4844"><span class="lineNum">    4844 </span>            :       /* NaNs can have various bit patterns; to most accurately recreate</a>
<a name="4845"><span class="lineNum">    4845 </span>            :          this particular NaN pattern, see if the NaN constant has a backing</a>
<a name="4846"><span class="lineNum">    4846 </span>            :          expression that specifies a builtin call.  If so, use that call</a>
<a name="4847"><span class="lineNum">    4847 </span>            :          (and argument) to recreate it in the back end. */</a>
<a name="4848"><span class="lineNum">    4848 </span>            :       check_assertion(strlen(unmangled_or_fabricated_name_of(</a>
<a name="4849"><span class="lineNum">    4849 </span>            :                                                         &amp;rp-&gt;source_corresp)) +</a>
<a name="4850"><span class="lineNum">    4850 </span>            :                       string_con-&gt;variant.string.length + 7 &lt; sizeof(buf));</a>
<a name="4851"><span class="lineNum">    4851 </span>            :       (void)sprintf(buf, &quot;(%s(\&quot;%s\&quot;))&quot;,</a>
<a name="4852"><span class="lineNum">    4852 </span>            :                     unmangled_or_fabricated_name_of(&amp;rp-&gt;source_corresp),</a>
<a name="4853"><span class="lineNum">    4853 </span>            :                     string_con-&gt;variant.string.value);</a>
<a name="4854"><span class="lineNum">    4854 </span>            :     } else if (msvc_is_generated_code_target) {</a>
<a name="4855"><span class="lineNum">    4855 </span>            :       /* MSVC++ gives an error on (x/0.0), so use a comma operator to</a>
<a name="4856"><span class="lineNum">    4856 </span>            :          fool it. */</a>
<a name="4857"><span class="lineNum">    4857 </span>            :       (void)sprintf(buf, &quot;(%s%s/(0,0.0%s))&quot;, dividend, suffix, suffix);</a>
<a name="4858"><span class="lineNum">    4858 </span>            :     } else if (clang_is_generated_code_target ||</a>
<a name="4859"><span class="lineNum">    4859 </span>            :                (gcc_is_generated_code_target &amp;&amp;</a>
<a name="4860"><span class="lineNum">    4860 </span>            :                 gnu_targ_version &gt;= 30300)) /*lint !e845*/ {</a>
<a name="4861"><span class="lineNum">    4861 </span>            :       /* Use the builtin function. */</a>
<a name="4862"><span class="lineNum">    4862 </span>            :       if (not_a_number) {</a>
<a name="4863"><span class="lineNum">    4863 </span>            :         (void)sprintf(buf, &quot;(__builtin_nan%s(\&quot;\&quot;))&quot;, gnu_builtin_suffix);</a>
<a name="4864"><span class="lineNum">    4864 </span>            :       } else {</a>
<a name="4865"><span class="lineNum">    4865 </span>            :         (void)sprintf(buf, &quot;(%s__builtin_huge_val%s())&quot;,</a>
<a name="4866"><span class="lineNum">    4866 </span>            :                       (neg_infinity) ? &quot;-&quot; : &quot;&quot;, gnu_builtin_suffix);</a>
<a name="4867"><span class="lineNum">    4867 </span>            :       }  /* if */</a>
<a name="4868"><span class="lineNum">    4868 </span>            :     } else if (gcc_is_generated_code_target &amp;&amp; gnu_targ_version &gt;= 29600 &amp;&amp;</a>
<a name="4869"><span class="lineNum">    4869 </span>            :                !not_a_number) {</a>
<a name="4870"><span class="lineNum">    4870 </span>            :       /* Use a large hexadecimal floating-point constant. */</a>
<a name="4871"><span class="lineNum">    4871 </span>            :       (void)sprintf(buf, &quot;(%s(__extension__ 0x1.0p%d%s))&quot;,</a>
<a name="4872"><span class="lineNum">    4872 </span>            :                     (neg_infinity) ? &quot;-&quot; : &quot;&quot;, 2*max_exp-1, suffix);</a>
<a name="4873"><span class="lineNum">    4873 </span>            :     } else</a>
<a name="4874"><span class="lineNum">    4874 </span>            : #endif /* (BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE) &amp;&amp; BUILTIN_... */</a>
<a name="4875"><span class="lineNum">    4875 </span>            :     {</a>
<a name="4876"><span class="lineNum">    4876 </span><span class="lineNoCov">          0 :       (void)sprintf(buf, &quot;(%s%s/0.0%s)&quot;, dividend, suffix, suffix);</span></a>
<a name="4877"><span class="lineNum">    4877 </span>            :     }  /* if */</a>
<a name="4878"><span class="lineNum">    4878 </span><span class="lineNoCov">          0 :     str = buf;</span></a>
<a name="4879"><span class="lineNum">    4879 </span><span class="lineNoCov">          0 :     suffix = &quot;&quot;;</span></a>
<a name="4880"><span class="lineNum">    4880 </span>            :   }  /* if */</a>
<a name="4881"><span class="lineNum">    4881 </span><span class="lineCov">          2 :   if (suffix[0] == '\0') {</span></a>
<a name="4882"><span class="lineNum">    4882 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(str, octl);</span></a>
<a name="4883"><span class="lineNum">    4883 </span>            :   } else {</a>
<a name="4884"><span class="lineNum">    4884 </span><span class="lineCov">          2 :     output_partial_token_str(str, octl);</span></a>
<a name="4885"><span class="lineNum">    4885 </span><span class="lineCov">          2 :     output_partial_token_str(suffix, octl);</span></a>
<a name="4886"><span class="lineNum">    4886 </span>            :   }  /* if */</a>
<a name="4887"><span class="lineNum">    4887 </span><span class="lineCov">          2 : }  /* form_float_constant */</span></a>
<a name="4888"><span class="lineNum">    4888 </span>            : </a>
<a name="4889"><span class="lineNum">    4889 </span>            : </a>
<a name="4890"><span class="lineNum">    4890 </span>            : static void form_dynamic_init(a_dynamic_init_ptr                    dip,</a>
<a name="4891"><span class="lineNum">    4891 </span>            :                               an_il_to_str_output_control_block_ptr octl)</a>
<a name="4892"><span class="lineNum">    4892 </span>            : /*</a>
<a name="4893"><span class="lineNum">    4893 </span>            : Output the indicated dynamic initialization.  Do the output in the way</a>
<a name="4894"><span class="lineNum">    4894 </span>            : described by octl.  This is used only for non-compilable output (e.g.,</a>
<a name="4895"><span class="lineNum">    4895 </span>            : for debug output).</a>
<a name="4896"><span class="lineNum">    4896 </span>            : */</a>
<a name="4897"><span class="lineNum">    4897 </span>            : {</a>
<a name="4898"><span class="lineNum">    4898 </span>            :   switch (dip-&gt;kind) {</a>
<a name="4899"><span class="lineNum">    4899 </span>            :     case dik_none:</a>
<a name="4900"><span class="lineNum">    4900 </span>            :       octl-&gt;output_str(&quot;&lt;no-init&gt;&quot;, octl);</a>
<a name="4901"><span class="lineNum">    4901 </span>            :       break;</a>
<a name="4902"><span class="lineNum">    4902 </span>            :     case dik_zero:</a>
<a name="4903"><span class="lineNum">    4903 </span>            :       octl-&gt;output_str(&quot;&lt;zero-init&gt;&quot;, octl);</a>
<a name="4904"><span class="lineNum">    4904 </span>            :       break;</a>
<a name="4905"><span class="lineNum">    4905 </span>            :     case dik_bitwise_copy:</a>
<a name="4906"><span class="lineNum">    4906 </span>            :       if (dip-&gt;variant.bitwise_copy.source != NULL) {</a>
<a name="4907"><span class="lineNum">    4907 </span>            :         octl-&gt;output_str(&quot;bitwise copy of: &quot;, octl);</a>
<a name="4908"><span class="lineNum">    4908 </span>            :         form_expression(dip-&gt;variant.bitwise_copy.source, octl);</a>
<a name="4909"><span class="lineNum">    4909 </span>            :       } else {</a>
<a name="4910"><span class="lineNum">    4910 </span>            :         octl-&gt;output_str(&quot;&lt;bitwise-copy&gt;&quot;, octl);</a>
<a name="4911"><span class="lineNum">    4911 </span>            :       }  /* if */</a>
<a name="4912"><span class="lineNum">    4912 </span>            :       break;</a>
<a name="4913"><span class="lineNum">    4913 </span>            :     case dik_constant:</a>
<a name="4914"><span class="lineNum">    4914 </span>            :     case dik_nonconstant_aggregate:</a>
<a name="4915"><span class="lineNum">    4915 </span>            :       form_constant(dip-&gt;variant.constant, /*need_parens=*/TRUE, octl);</a>
<a name="4916"><span class="lineNum">    4916 </span>            :       break;</a>
<a name="4917"><span class="lineNum">    4917 </span>            :     case dik_class_result_via_ctor:</a>
<a name="4918"><span class="lineNum">    4918 </span>            :       octl-&gt;output_str(&quot;class result via ctor: &quot;, octl);</a>
<a name="4919"><span class="lineNum">    4919 </span>            :       /*FALLTHROUGH*/</a>
<a name="4920"><span class="lineNum">    4920 </span>            :     case dik_expression:</a>
<a name="4921"><span class="lineNum">    4921 </span>            :       form_expression(dip-&gt;variant.expression, octl);</a>
<a name="4922"><span class="lineNum">    4922 </span>            :       break;</a>
<a name="4923"><span class="lineNum">    4923 </span>            :     case dik_constructor:</a>
<a name="4924"><span class="lineNum">    4924 </span>            :       octl-&gt;output_str(&quot;&lt;constructor-call&gt;&quot;, octl);</a>
<a name="4925"><span class="lineNum">    4925 </span>            :       break;</a>
<a name="4926"><span class="lineNum">    4926 </span>            :     default:</a>
<a name="4927"><span class="lineNum">    4927 </span>            :       unexpected_condition_str(&quot;form_dynamic_init: bad kind&quot;);</a>
<a name="4928"><span class="lineNum">    4928 </span>            :   }  /* switch */</a>
<a name="4929"><span class="lineNum">    4929 </span>            : }  /* form_dynamic_init */</a>
<a name="4930"><span class="lineNum">    4930 </span>            : </a>
<a name="4931"><span class="lineNum">    4931 </span>            : </a>
<a name="4932"><span class="lineNum">    4932 </span><span class="lineNoCov">          0 : static void form_expression(an_expr_node_ptr                      expr,</span></a>
<a name="4933"><span class="lineNum">    4933 </span>            :                             an_il_to_str_output_control_block_ptr octl)</a>
<a name="4934"><span class="lineNum">    4934 </span>            : /*</a>
<a name="4935"><span class="lineNum">    4935 </span>            : Output the indicated expression.  Do the output in the way described by</a>
<a name="4936"><span class="lineNum">    4936 </span>            : octl.  When there is a user-provided output_expression routine, it is</a>
<a name="4937"><span class="lineNum">    4937 </span>            : used.  Otherwise, this routine produces non-compilable output (e.g.,</a>
<a name="4938"><span class="lineNum">    4938 </span>            : for debug output), and it doesn't have to provide detailed information</a>
<a name="4939"><span class="lineNum">    4939 </span>            : on every expression.</a>
<a name="4940"><span class="lineNum">    4940 </span>            : */</a>
<a name="4941"><span class="lineNum">    4941 </span>            : {</a>
<a name="4942"><span class="lineNum">    4942 </span><span class="lineNoCov">          0 :   a_boolean  saved_render_auto_deduction_typerefs =</span></a>
<a name="4943"><span class="lineNum">    4943 </span><span class="lineNoCov">          0 :                                          octl-&gt;render_auto_deduction_typerefs;</span></a>
<a name="4944"><span class="lineNum">    4944 </span>            : </a>
<a name="4945"><span class="lineNum">    4945 </span>            :   /* Don't form &quot;auto&quot; or &quot;decltype(auto)&quot; instead of the deduced types when</a>
<a name="4946"><span class="lineNum">    4946 </span>            :      in expression contexts. */</a>
<a name="4947"><span class="lineNum">    4947 </span><span class="lineNoCov">          0 :   octl-&gt;render_auto_deduction_typerefs = FALSE;</span></a>
<a name="4948"><span class="lineNum">    4948 </span><span class="lineNoCov">          0 :   if (octl-&gt;output_expression != NULL) {</span></a>
<a name="4949"><span class="lineNum">    4949 </span>            :     /* Output the expression using a special routine. */</a>
<a name="4950"><span class="lineNum">    4950 </span><span class="lineNoCov">          0 :     octl-&gt;output_expression(expr, /*suppress_parens=*/FALSE);</span></a>
<a name="4951"><span class="lineNum">    4951 </span>            :   } else {</a>
<a name="4952"><span class="lineNum">    4952 </span>            :     /* No routine to do the expression output.  Do default</a>
<a name="4953"><span class="lineNum">    4953 </span>            :        non-compilable output. */</a>
<a name="4954"><span class="lineNum">    4954 </span><span class="lineNoCov">          0 :     check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="4955"><span class="lineNum">    4955 </span><span class="lineNoCov">          0 :     if (expr == NULL) {</span></a>
<a name="4956"><span class="lineNum">    4956 </span>            :       /* This can occur in array bound constants in which the expression</a>
<a name="4957"><span class="lineNum">    4957 </span>            :          involves a local variable and is thus represented via the local</a>
<a name="4958"><span class="lineNum">    4958 </span>            :          expr node reference mechanism instead of as a direct expression</a>
<a name="4959"><span class="lineNum">    4959 </span>            :          node. */</a>
<a name="4960"><span class="lineNum">    4960 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;NULL expression&gt;&quot;, octl);</span></a>
<a name="4961"><span class="lineNum">    4961 </span><span class="lineNoCov">          0 :     } else switch (expr-&gt;kind) {</span></a>
<a name="4962"><span class="lineNum">    4962 </span><span class="lineNoCov">          0 :       case enk_error:</span></a>
<a name="4963"><span class="lineNum">    4963 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&lt;error&gt;&quot;, octl);</span></a>
<a name="4964"><span class="lineNum">    4964 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="4965"><span class="lineNum">    4965 </span><span class="lineNoCov">          0 :       case enk_operation:</span></a>
<a name="4966"><span class="lineNum">    4966 </span><span class="lineNoCov">          0 :         { an_expr_node_ptr      operand = expr-&gt;variant.operation.operands;</span></a>
<a name="4967"><span class="lineNum">    4967 </span><span class="lineNoCov">          0 :           an_expr_operator_kind op = expr-&gt;variant.operation.kind;</span></a>
<a name="4968"><span class="lineNum">    4968 </span><span class="lineNoCov">          0 :           a_constant_ptr        con;</span></a>
<a name="4969"><span class="lineNum">    4969 </span><span class="lineNoCov">          0 :           if (op == (an_expr_operator_kind)eok_parens) {</span></a>
<a name="4970"><span class="lineNum">    4970 </span>            :             /* Parentheses. */</a>
<a name="4971"><span class="lineNum">    4971 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="4972"><span class="lineNum">    4972 </span><span class="lineNoCov">          0 :             form_expression(operand, octl);</span></a>
<a name="4973"><span class="lineNum">    4973 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="4974"><span class="lineNum">    4974 </span>            : #if DEBUG</a>
<a name="4975"><span class="lineNum">    4975 </span><span class="lineNoCov">          0 :           } else if (octl-&gt;debug_output) {</span></a>
<a name="4976"><span class="lineNum">    4976 </span><span class="lineNoCov">          0 :             a_const_char *op_str =</span></a>
<a name="4977"><span class="lineNum">    4977 </span><span class="lineNoCov">          0 :                                db_operator_names[expr-&gt;variant.operation.kind];</span></a>
<a name="4978"><span class="lineNum">    4978 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="4979"><span class="lineNum">    4979 </span><span class="lineNoCov">          0 :             if (is_call_node(expr)) {</span></a>
<a name="4980"><span class="lineNum">    4980 </span>            :               /* Calls. */</a>
<a name="4981"><span class="lineNum">    4981 </span><span class="lineNoCov">          0 :               form_expression(operand, octl);</span></a>
<a name="4982"><span class="lineNum">    4982 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="4983"><span class="lineNum">    4983 </span><span class="lineNoCov">          0 :               while ((operand = operand-&gt;next) != NULL) {</span></a>
<a name="4984"><span class="lineNum">    4984 </span><span class="lineNoCov">          0 :                 form_expression(operand, octl);</span></a>
<a name="4985"><span class="lineNum">    4985 </span><span class="lineNoCov">          0 :                 if (operand-&gt;next != NULL) octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="4986"><span class="lineNum">    4986 </span>            :               }  /* while */</a>
<a name="4987"><span class="lineNum">    4987 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="4988"><span class="lineNum">    4988 </span><span class="lineNoCov">          0 :             } else if (op == (an_expr_operator_kind)eok_subscript) {</span></a>
<a name="4989"><span class="lineNum">    4989 </span>            :               /* Subscripting. */</a>
<a name="4990"><span class="lineNum">    4990 </span><span class="lineNoCov">          0 :               form_expression(operand, octl);</span></a>
<a name="4991"><span class="lineNum">    4991 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;[&quot;, octl);</span></a>
<a name="4992"><span class="lineNum">    4992 </span><span class="lineNoCov">          0 :               form_expression(operand-&gt;next, octl);</span></a>
<a name="4993"><span class="lineNum">    4993 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;]&quot;, octl);</span></a>
<a name="4994"><span class="lineNum">    4994 </span><span class="lineNoCov">          0 :             } else if (is_cast_operation_node(expr)) {</span></a>
<a name="4995"><span class="lineNum">    4995 </span>            :               /* Casts. */</a>
<a name="4996"><span class="lineNum">    4996 </span><span class="lineNoCov">          0 :               a_const_char *new_style_op = NULL;</span></a>
<a name="4997"><span class="lineNum">    4997 </span><span class="lineNoCov">          0 :               a_type       ref_type;</span></a>
<a name="4998"><span class="lineNum">    4998 </span><span class="lineNoCov">          0 :               a_type_ptr   dest_type = expr-&gt;type;</span></a>
<a name="4999"><span class="lineNum">    4999 </span><span class="lineNoCov">          0 :               if (expr-&gt;variant.operation.is_reference_cast ||</span></a>
<a name="5000"><span class="lineNum">    5000 </span><span class="lineNoCov">          0 :                   op == (an_expr_operator_kind)eok_ref_cast ||</span></a>
<a name="5001"><span class="lineNum">    5001 </span><span class="lineNoCov">          0 :                   op == (an_expr_operator_kind)eok_ref_dynamic_cast) {</span></a>
<a name="5002"><span class="lineNum">    5002 </span>            :                 /* A cast to a reference type. */</a>
<a name="5003"><span class="lineNum">    5003 </span><span class="lineNoCov">          0 :                 destination_type_for_reference_cast(expr, &amp;ref_type);</span></a>
<a name="5004"><span class="lineNum">    5004 </span><span class="lineNoCov">          0 :                 dest_type = &amp;ref_type;</span></a>
<a name="5005"><span class="lineNum">    5005 </span>            :               }  /* if */</a>
<a name="5006"><span class="lineNum">    5006 </span><span class="lineNoCov">          0 :               if (expr-&gt;is_static_cast) {</span></a>
<a name="5007"><span class="lineNum">    5007 </span>            :                 new_style_op = &quot;static_cast&quot;;</a>
<a name="5008"><span class="lineNum">    5008 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="5009"><span class="lineNum">    5009 </span>            :               } else if (expr-&gt;is_safe_cast) {</a>
<a name="5010"><span class="lineNum">    5010 </span>            :                 new_style_op = &quot;safe_cast&quot;;</a>
<a name="5011"><span class="lineNum">    5011 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="5012"><span class="lineNum">    5012 </span><span class="lineNoCov">          0 :               } else if (expr-&gt;variant.operation.is_const_cast) {</span></a>
<a name="5013"><span class="lineNum">    5013 </span>            :                 new_style_op = &quot;const_cast&quot;;</a>
<a name="5014"><span class="lineNum">    5014 </span><span class="lineNoCov">          0 :               } else if (expr-&gt;variant.operation.is_reinterpret_cast) {</span></a>
<a name="5015"><span class="lineNum">    5015 </span>            :                 new_style_op = &quot;reinterpret_cast&quot;;</a>
<a name="5016"><span class="lineNum">    5016 </span>            :               }  /* if */</a>
<a name="5017"><span class="lineNum">    5017 </span><span class="lineNoCov">          0 :               if (new_style_op != NULL) {</span></a>
<a name="5018"><span class="lineNum">    5018 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(new_style_op, octl);</span></a>
<a name="5019"><span class="lineNum">    5019 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;&lt;&quot;, octl);</span></a>
<a name="5020"><span class="lineNum">    5020 </span><span class="lineNoCov">          0 :                 form_type(dest_type, octl);</span></a>
<a name="5021"><span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;&gt;(&quot;, octl);</span></a>
<a name="5022"><span class="lineNum">    5022 </span><span class="lineNoCov">          0 :                 form_expression(operand, octl);</span></a>
<a name="5023"><span class="lineNum">    5023 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5024"><span class="lineNum">    5024 </span>            :               } else {</a>
<a name="5025"><span class="lineNum">    5025 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5026"><span class="lineNum">    5026 </span><span class="lineNoCov">          0 :                 form_type(dest_type, octl);</span></a>
<a name="5027"><span class="lineNum">    5027 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5028"><span class="lineNum">    5028 </span><span class="lineNoCov">          0 :                 form_expression(operand, octl);</span></a>
<a name="5029"><span class="lineNum">    5029 </span>            :               }  /* if */</a>
<a name="5030"><span class="lineNum">    5030 </span><span class="lineNoCov">          0 :             } else if (operand-&gt;next == NULL) {</span></a>
<a name="5031"><span class="lineNum">    5031 </span>            :               /* Unary operators. */</a>
<a name="5032"><span class="lineNum">    5032 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(op_str, octl);</span></a>
<a name="5033"><span class="lineNum">    5033 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="5034"><span class="lineNum">    5034 </span><span class="lineNoCov">          0 :               form_expression(operand, octl);</span></a>
<a name="5035"><span class="lineNum">    5035 </span><span class="lineNoCov">          0 :             } else if (operand-&gt;next-&gt;next == NULL) {</span></a>
<a name="5036"><span class="lineNum">    5036 </span>            :               /* Binary operators. */</a>
<a name="5037"><span class="lineNum">    5037 </span><span class="lineNoCov">          0 :               form_expression(operand, octl);</span></a>
<a name="5038"><span class="lineNum">    5038 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="5039"><span class="lineNum">    5039 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(op_str, octl);</span></a>
<a name="5040"><span class="lineNum">    5040 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="5041"><span class="lineNum">    5041 </span><span class="lineNoCov">          0 :               form_expression(operand-&gt;next, octl);</span></a>
<a name="5042"><span class="lineNum">    5042 </span>            :             } else {</a>
<a name="5043"><span class="lineNum">    5043 </span>            :               /* Other operators, e.g., &quot;?&quot;.  Use generic form. */</a>
<a name="5044"><span class="lineNum">    5044 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(op_str, octl);</span></a>
<a name="5045"><span class="lineNum">    5045 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5046"><span class="lineNum">    5046 </span><span class="lineNoCov">          0 :               while (operand != NULL) {</span></a>
<a name="5047"><span class="lineNum">    5047 </span><span class="lineNoCov">          0 :                 form_expression(operand, octl);</span></a>
<a name="5048"><span class="lineNum">    5048 </span><span class="lineNoCov">          0 :                 if (operand-&gt;next != NULL) octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="5049"><span class="lineNum">    5049 </span><span class="lineNoCov">          0 :                 operand = operand-&gt;next;</span></a>
<a name="5050"><span class="lineNum">    5050 </span>            :               }  /* while */</a>
<a name="5051"><span class="lineNum">    5051 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5052"><span class="lineNum">    5052 </span>            :             }  /* if */</a>
<a name="5053"><span class="lineNum">    5053 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5054"><span class="lineNum">    5054 </span>            : #endif /* DEBUG */</a>
<a name="5055"><span class="lineNum">    5055 </span><span class="lineNoCov">          0 :           } else if (op == (an_expr_operator_kind)eok_array_to_pointer ||</span></a>
<a name="5056"><span class="lineNum">    5056 </span><span class="lineNoCov">          0 :                      op == (an_expr_operator_kind)eok_lvalue_adjust ||</span></a>
<a name="5057"><span class="lineNum">    5057 </span><span class="lineNoCov">          0 :                      op == (an_expr_operator_kind)eok_class_rvalue_adjust ||</span></a>
<a name="5058"><span class="lineNum">    5058 </span><span class="lineNoCov">          0 :                      op == (an_expr_operator_kind)eok_unbox_lvalue ||</span></a>
<a name="5059"><span class="lineNum">    5059 </span><span class="lineNoCov">          0 :                      (expr-&gt;variant.operation.compiler_generated &amp;&amp;</span></a>
<a name="5060"><span class="lineNum">    5060 </span><span class="lineNoCov">          0 :                       is_cast_operation_node(expr))) {</span></a>
<a name="5061"><span class="lineNum">    5061 </span>            :             /* Elide certain implicit operations. */</a>
<a name="5062"><span class="lineNum">    5062 </span><span class="lineNoCov">          0 :             form_expression(operand, octl);</span></a>
<a name="5063"><span class="lineNum">    5063 </span><span class="lineNoCov">          0 :           } else if (op == (an_expr_operator_kind)eok_address_of &amp;&amp;</span></a>
<a name="5064"><span class="lineNum">    5064 </span><span class="lineNoCov">          0 :                      is_operation_node(operand) &amp;&amp;</span></a>
<a name="5065"><span class="lineNum">    5065 </span><span class="lineNoCov">          0 :                      node_operator_is(operand, eok_lvalue) &amp;&amp;</span></a>
<a name="5066"><span class="lineNum">    5066 </span><span class="lineNoCov">          0 :                      is_constant_node(operand-&gt;variant.operation.operands) &amp;&amp;</span></a>
<a name="5067"><span class="lineNum">    5067 </span><span class="lineNoCov">          0 :                      (con = node_constant(operand-&gt;variant.operation.operands))</span></a>
<a name="5068"><span class="lineNum">    5068 </span><span class="lineNoCov">          0 :                            -&gt;kind == (a_constant_repr_kind)ck_template_param &amp;&amp;</span></a>
<a name="5069"><span class="lineNum">    5069 </span><span class="lineNoCov">          0 :                      (con-&gt;variant.template_param.kind ==</span></a>
<a name="5070"><span class="lineNum">    5070 </span><span class="lineNoCov">          0 :                        (a_template_param_constant_kind)tpck_unknown_function ||</span></a>
<a name="5071"><span class="lineNum">    5071 </span>            :                       con-&gt;variant.template_param.kind ==</a>
<a name="5072"><span class="lineNum">    5072 </span>            :                        (a_template_param_constant_kind)tpck_template_ref)) {</a>
<a name="5073"><span class="lineNum">    5073 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="5074"><span class="lineNum">    5074 </span><span class="lineNoCov">          0 :             form_unknown_function_constant(con, octl);</span></a>
<a name="5075"><span class="lineNum">    5075 </span>            :           } else {</a>
<a name="5076"><span class="lineNum">    5076 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="5077"><span class="lineNum">    5077 </span>            :           }  /* if */</a>
<a name="5078"><span class="lineNum">    5078 </span>            :         }</a>
<a name="5079"><span class="lineNum">    5079 </span>            :         break;</a>
<a name="5080"><span class="lineNum">    5080 </span><span class="lineNoCov">          0 :       case enk_constant:</span></a>
<a name="5081"><span class="lineNum">    5081 </span><span class="lineNoCov">          0 :         form_constant(node_constant(expr), /*need_parens=*/TRUE, octl);</span></a>
<a name="5082"><span class="lineNum">    5082 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5083"><span class="lineNum">    5083 </span><span class="lineNoCov">          0 :       case enk_variable:</span></a>
<a name="5084"><span class="lineNum">    5084 </span><span class="lineNoCov">          0 :         form_name(&amp;node_variable(expr)-&gt;source_corresp,</span></a>
<a name="5085"><span class="lineNum">    5085 </span>            :                   (an_il_entry_kind)iek_variable, octl);</a>
<a name="5086"><span class="lineNum">    5086 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5087"><span class="lineNum">    5087 </span><span class="lineNoCov">          0 :       case enk_routine:</span></a>
<a name="5088"><span class="lineNum">    5088 </span><span class="lineNoCov">          0 :         form_name(&amp;node_routine(expr)-&gt;source_corresp,</span></a>
<a name="5089"><span class="lineNum">    5089 </span>            :                   (an_il_entry_kind)iek_routine, octl);</a>
<a name="5090"><span class="lineNum">    5090 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5091"><span class="lineNum">    5091 </span><span class="lineNoCov">          0 :       case enk_field:</span></a>
<a name="5092"><span class="lineNum">    5092 </span><span class="lineNoCov">          0 :         form_name(&amp;node_field(expr)-&gt;source_corresp,</span></a>
<a name="5093"><span class="lineNum">    5093 </span>            :                   (an_il_entry_kind)iek_field, octl);</a>
<a name="5094"><span class="lineNum">    5094 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5095"><span class="lineNum">    5095 </span><span class="lineNoCov">          0 :       case enk_temp_init:</span></a>
<a name="5096"><span class="lineNum">    5096 </span>            : #if DEBUG</a>
<a name="5097"><span class="lineNum">    5097 </span><span class="lineNoCov">          0 :         if (octl-&gt;debug_output) {</span></a>
<a name="5098"><span class="lineNum">    5098 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;temp(&quot;, octl);</span></a>
<a name="5099"><span class="lineNum">    5099 </span><span class="lineNoCov">          0 :           form_type(expr-&gt;type, octl);</span></a>
<a name="5100"><span class="lineNum">    5100 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;):(&quot;, octl);</span></a>
<a name="5101"><span class="lineNum">    5101 </span><span class="lineNoCov">          0 :           form_dynamic_init(expr-&gt;variant.init.dynamic_init, octl);</span></a>
<a name="5102"><span class="lineNum">    5102 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5103"><span class="lineNum">    5103 </span>            :         } else</a>
<a name="5104"><span class="lineNum">    5104 </span>            : #endif /* DEBUG */</a>
<a name="5105"><span class="lineNum">    5105 </span>            :         /* Do not insert code here */</a>
<a name="5106"><span class="lineNum">    5106 </span><span class="lineNoCov">          0 :         { a_dynamic_init_ptr  dip = expr-&gt;variant.init.dynamic_init;</span></a>
<a name="5107"><span class="lineNum">    5107 </span><span class="lineNoCov">          0 :           if (has_name_before_mangling(expr-&gt;type) &amp;&amp;</span></a>
<a name="5108"><span class="lineNum">    5108 </span><span class="lineNoCov">          0 :               (dip-&gt;kind == (a_dynamic_init_kind)dik_none ||</span></a>
<a name="5109"><span class="lineNum">    5109 </span>            :                dip-&gt;kind == (a_dynamic_init_kind)dik_zero)) {</a>
<a name="5110"><span class="lineNum">    5110 </span><span class="lineNoCov">          0 :             form_type(expr-&gt;type, octl);</span></a>
<a name="5111"><span class="lineNum">    5111 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;()&quot;, octl);</span></a>
<a name="5112"><span class="lineNum">    5112 </span>            :           } else {</a>
<a name="5113"><span class="lineNum">    5113 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="5114"><span class="lineNum">    5114 </span>            :           }  /* if */</a>
<a name="5115"><span class="lineNum">    5115 </span>            :         }  /* if */</a>
<a name="5116"><span class="lineNum">    5116 </span>            :         break;</a>
<a name="5117"><span class="lineNum">    5117 </span><span class="lineNoCov">          0 :       case enk_type_operand:</span></a>
<a name="5118"><span class="lineNum">    5118 </span><span class="lineNoCov">          0 :         if (expr-&gt;variant.type_operand.type != NULL) {</span></a>
<a name="5119"><span class="lineNum">    5119 </span><span class="lineNoCov">          0 :           form_type(expr-&gt;variant.type_operand.type, octl);</span></a>
<a name="5120"><span class="lineNum">    5120 </span>            :         } else {</a>
<a name="5121"><span class="lineNum">    5121 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&lt;default&gt;&quot;, octl);</span></a>
<a name="5122"><span class="lineNum">    5122 </span>            :         }  /* if */</a>
<a name="5123"><span class="lineNum">    5123 </span>            :         break;</a>
<a name="5124"><span class="lineNum">    5124 </span><span class="lineNoCov">          0 :       case enk_builtin_operation:</span></a>
<a name="5125"><span class="lineNum">    5125 </span>            : #if DEBUG</a>
<a name="5126"><span class="lineNum">    5126 </span><span class="lineNoCov">          0 :         if (octl-&gt;debug_output) {</span></a>
<a name="5127"><span class="lineNum">    5127 </span><span class="lineNoCov">          0 :           an_expr_node_ptr  operand = expr-&gt;variant.builtin_operation.operands;</span></a>
<a name="5128"><span class="lineNum">    5128 </span><span class="lineNoCov">          0 :           a_const_char      *op_str = builtin_operation_names[</span></a>
<a name="5129"><span class="lineNum">    5129 </span><span class="lineNoCov">          0 :                                          expr-&gt;variant.builtin_operation.kind];</span></a>
<a name="5130"><span class="lineNum">    5130 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(op_str, octl);</span></a>
<a name="5131"><span class="lineNum">    5131 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5132"><span class="lineNum">    5132 </span><span class="lineNoCov">          0 :           while (operand != NULL) {</span></a>
<a name="5133"><span class="lineNum">    5133 </span><span class="lineNoCov">          0 :             form_expression(operand, octl);</span></a>
<a name="5134"><span class="lineNum">    5134 </span><span class="lineNoCov">          0 :             if (operand-&gt;next != NULL) octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="5135"><span class="lineNum">    5135 </span><span class="lineNoCov">          0 :             operand = operand-&gt;next;</span></a>
<a name="5136"><span class="lineNum">    5136 </span>            :           }  /* while */</a>
<a name="5137"><span class="lineNum">    5137 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5138"><span class="lineNum">    5138 </span>            :         } else</a>
<a name="5139"><span class="lineNum">    5139 </span>            : #endif /* DEBUG */</a>
<a name="5140"><span class="lineNum">    5140 </span>            :         /* Do not insert code here. */</a>
<a name="5141"><span class="lineNum">    5141 </span>            :         {</a>
<a name="5142"><span class="lineNum">    5142 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="5143"><span class="lineNum">    5143 </span>            :         }  /* if */</a>
<a name="5144"><span class="lineNum">    5144 </span>            :         break;</a>
<a name="5145"><span class="lineNum">    5145 </span><span class="lineNoCov">          0 :       case enk_param_ref:</span></a>
<a name="5146"><span class="lineNum">    5146 </span><span class="lineNoCov">          0 :         if (expr-&gt;variant.param_ref.param_num == 0) {</span></a>
<a name="5147"><span class="lineNum">    5147 </span>            :           /* A zero parameter number indicates &quot;this&quot;. */</a>
<a name="5148"><span class="lineNum">    5148 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;this&quot;, octl);</span></a>
<a name="5149"><span class="lineNum">    5149 </span>            :         } else {</a>
<a name="5150"><span class="lineNum">    5150 </span>            :           /* Describe a parameter for non-compilable output.  If the reference</a>
<a name="5151"><span class="lineNum">    5151 </span>            :              is to the innermost function parameter list or to a parameter list</a>
<a name="5152"><span class="lineNum">    5152 </span>            :              preceding a trailing return type (presumably the most common</a>
<a name="5153"><span class="lineNum">    5153 </span>            :              cases), just give the parameter number.  Otherwise, also indicate</a>
<a name="5154"><span class="lineNum">    5154 </span>            :              how many &quot;levels up&quot; the function prototype scope is. */</a>
<a name="5155"><span class="lineNum">    5155 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&lt;parameter #&quot;, octl);</span></a>
<a name="5156"><span class="lineNum">    5156 </span><span class="lineNoCov">          0 :           form_unsigned_num((a_host_large_unsigned)</span></a>
<a name="5157"><span class="lineNum">    5157 </span><span class="lineNoCov">          0 :                                             expr-&gt;variant.param_ref.param_num,</span></a>
<a name="5158"><span class="lineNum">    5158 </span>            :                             octl);</a>
<a name="5159"><span class="lineNum">    5159 </span><span class="lineNoCov">          0 :           if (expr-&gt;variant.param_ref.levels_up == 2) {</span></a>
<a name="5160"><span class="lineNum">    5160 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot; (one level up)&quot;, octl);</span></a>
<a name="5161"><span class="lineNum">    5161 </span><span class="lineNoCov">          0 :           } else if (expr-&gt;variant.param_ref.levels_up &gt; 2) {</span></a>
<a name="5162"><span class="lineNum">    5162 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot; (&quot;, octl);</span></a>
<a name="5163"><span class="lineNum">    5163 </span><span class="lineNoCov">          0 :             form_unsigned_num((a_host_large_unsigned)</span></a>
<a name="5164"><span class="lineNum">    5164 </span><span class="lineNoCov">          0 :                                           expr-&gt;variant.param_ref.levels_up-1,</span></a>
<a name="5165"><span class="lineNum">    5165 </span>            :                                octl);</a>
<a name="5166"><span class="lineNum">    5166 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot; levels up)&quot;, octl);</span></a>
<a name="5167"><span class="lineNum">    5167 </span>            :           }  /* if */</a>
<a name="5168"><span class="lineNum">    5168 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&gt;&quot;, octl);</span></a>
<a name="5169"><span class="lineNum">    5169 </span>            :         }  /* if */</a>
<a name="5170"><span class="lineNum">    5170 </span>            :         break;</a>
<a name="5171"><span class="lineNum">    5171 </span><span class="lineNoCov">          0 :       case enk_braced_init_list:</span></a>
<a name="5172"><span class="lineNum">    5172 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;{ ... }&quot;, octl);</span></a>
<a name="5173"><span class="lineNum">    5173 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5174"><span class="lineNum">    5174 </span><span class="lineNoCov">          0 :       case enk_c11_generic:</span></a>
<a name="5175"><span class="lineNum">    5175 </span>            : #if DEBUG</a>
<a name="5176"><span class="lineNum">    5176 </span><span class="lineNoCov">          0 :         if (octl-&gt;debug_output) {</span></a>
<a name="5177"><span class="lineNum">    5177 </span><span class="lineNoCov">          0 :           an_expr_node_ptr  operand = expr-&gt;variant.c11_generic.operands;</span></a>
<a name="5178"><span class="lineNum">    5178 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;_Generic&quot;, octl);</span></a>
<a name="5179"><span class="lineNum">    5179 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5180"><span class="lineNum">    5180 </span><span class="lineNoCov">          0 :           form_expression(operand, octl);</span></a>
<a name="5181"><span class="lineNum">    5181 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="5182"><span class="lineNum">    5182 </span><span class="lineNoCov">          0 :           while (operand != NULL) {</span></a>
<a name="5183"><span class="lineNum">    5183 </span><span class="lineNoCov">          0 :             form_expression(operand, octl);</span></a>
<a name="5184"><span class="lineNum">    5184 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;: &quot;, octl);</span></a>
<a name="5185"><span class="lineNum">    5185 </span><span class="lineNoCov">          0 :             operand = operand-&gt;next;</span></a>
<a name="5186"><span class="lineNum">    5186 </span><span class="lineNoCov">          0 :             if (operand != NULL) {</span></a>
<a name="5187"><span class="lineNum">    5187 </span><span class="lineNoCov">          0 :               form_expression(operand, octl);</span></a>
<a name="5188"><span class="lineNum">    5188 </span><span class="lineNoCov">          0 :               operand = operand-&gt;next;</span></a>
<a name="5189"><span class="lineNum">    5189 </span><span class="lineNoCov">          0 :               if (operand != NULL) octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="5190"><span class="lineNum">    5190 </span>            :             }  /* if */</a>
<a name="5191"><span class="lineNum">    5191 </span>            :           }  /* while */</a>
<a name="5192"><span class="lineNum">    5192 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5193"><span class="lineNum">    5193 </span>            :         } else</a>
<a name="5194"><span class="lineNum">    5194 </span>            : #endif /* DEBUG */</a>
<a name="5195"><span class="lineNum">    5195 </span>            :         /* Do not insert code here. */</a>
<a name="5196"><span class="lineNum">    5196 </span>            :         {</a>
<a name="5197"><span class="lineNum">    5197 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="5198"><span class="lineNum">    5198 </span>            :         }  /* if */</a>
<a name="5199"><span class="lineNum">    5199 </span>            :         break;</a>
<a name="5200"><span class="lineNum">    5200 </span><span class="lineNoCov">          0 :       default:</span></a>
<a name="5201"><span class="lineNum">    5201 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;&lt;expression&gt;&quot;, octl);</span></a>
<a name="5202"><span class="lineNum">    5202 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5203"><span class="lineNum">    5203 </span>            :     }  /* switch */</a>
<a name="5204"><span class="lineNum">    5204 </span><span class="lineNoCov">          0 :     if (expr != NULL &amp;&amp; expr-&gt;is_pack_expansion) {</span></a>
<a name="5205"><span class="lineNum">    5205 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;...&quot;, octl);</span></a>
<a name="5206"><span class="lineNum">    5206 </span>            :     }  /* if */</a>
<a name="5207"><span class="lineNum">    5207 </span>            :   }  /* if */</a>
<a name="5208"><span class="lineNum">    5208 </span><span class="lineNoCov">          0 :   octl-&gt;render_auto_deduction_typerefs = saved_render_auto_deduction_typerefs;</span></a>
<a name="5209"><span class="lineNum">    5209 </span><span class="lineNoCov">          0 : }  /* form_expression */</span></a>
<a name="5210"><span class="lineNum">    5210 </span>            : </a>
<a name="5211"><span class="lineNum">    5211 </span>            : </a>
<a name="5212"><span class="lineNum">    5212 </span>            : static void form_dynamic_init_constant(</a>
<a name="5213"><span class="lineNum">    5213 </span>            :                                 a_constant_ptr                        constant,</a>
<a name="5214"><span class="lineNum">    5214 </span>            :                                 an_il_to_str_output_control_block_ptr octl)</a>
<a name="5215"><span class="lineNum">    5215 </span>            : /*</a>
<a name="5216"><span class="lineNum">    5216 </span>            : Output the indicated ck_dynamic_init constant.  Do the output in the way</a>
<a name="5217"><span class="lineNum">    5217 </span>            : described by octl.  This is used only for non-compilable output (e.g.,</a>
<a name="5218"><span class="lineNum">    5218 </span>            : for debug output).</a>
<a name="5219"><span class="lineNum">    5219 </span>            : */</a>
<a name="5220"><span class="lineNum">    5220 </span>            : {</a>
<a name="5221"><span class="lineNum">    5221 </span>            :   a_dynamic_init_ptr dip;</a>
<a name="5222"><span class="lineNum">    5222 </span>            : </a>
<a name="5223"><span class="lineNum">    5223 </span>            :   check_assertion(!octl-&gt;gen_compilable_code &amp;&amp;</a>
<a name="5224"><span class="lineNum">    5224 </span>            :                   constant-&gt;kind == (a_constant_repr_kind)ck_dynamic_init);</a>
<a name="5225"><span class="lineNum">    5225 </span>            :   octl-&gt;output_str(&quot;dynamic-init: &quot;, octl);</a>
<a name="5226"><span class="lineNum">    5226 </span>            :   dip = constant-&gt;variant.dynamic_init;</a>
<a name="5227"><span class="lineNum">    5227 </span>            :   form_dynamic_init(dip, octl);</a>
<a name="5228"><span class="lineNum">    5228 </span>            : }  /* form_dynamic_init_constant */</a>
<a name="5229"><span class="lineNum">    5229 </span>            : </a>
<a name="5230"><span class="lineNum">    5230 </span>            : </a>
<a name="5231"><span class="lineNum">    5231 </span><span class="lineCov">       5596 : void form_constant(a_constant_ptr                        constant,</span></a>
<a name="5232"><span class="lineNum">    5232 </span>            :                    a_boolean                             need_parens,</a>
<a name="5233"><span class="lineNum">    5233 </span>            :                    an_il_to_str_output_control_block_ptr octl)</a>
<a name="5234"><span class="lineNum">    5234 </span>            : /*</a>
<a name="5235"><span class="lineNum">    5235 </span>            : Output the indicated constant.  If an expression node corresponding to the</a>
<a name="5236"><span class="lineNum">    5236 </span>            : operation that resulted in the constant is available, output the expression</a>
<a name="5237"><span class="lineNum">    5237 </span>            : instead of just the result of the operation.  If need_parens is TRUE,</a>
<a name="5238"><span class="lineNum">    5238 </span>            : parentheses are placed around the constant if there's any possibility of</a>
<a name="5239"><span class="lineNum">    5239 </span>            : precedence confusion.  Do the output in the way described by octl.</a>
<a name="5240"><span class="lineNum">    5240 </span>            : */</a>
<a name="5241"><span class="lineNum">    5241 </span>            : {</a>
<a name="5242"><span class="lineNum">    5242 </span><span class="lineCov">       5596 :   a_constant_repr_kind kind = constant-&gt;kind;</span></a>
<a name="5243"><span class="lineNum">    5243 </span><span class="lineCov">       5596 :   a_type_ptr           con_type = NULL, orig_type;</span></a>
<a name="5244"><span class="lineNum">    5244 </span><span class="lineCov">       5596 :   a_boolean            need_cast_close_paren = FALSE, is_enum;</span></a>
<a name="5245"><span class="lineNum">    5245 </span><span class="lineCov">       5596 :   a_boolean            need_reinterpret_cast = FALSE;</span></a>
<a name="5246"><span class="lineNum">    5246 </span><span class="lineCov">       5596 :   a_constant_ptr       equiv_constant;</span></a>
<a name="5247"><span class="lineNum">    5247 </span><span class="lineCov">       5596 :   a_boolean            cast_already_put_out = FALSE;</span></a>
<a name="5248"><span class="lineNum">    5248 </span>            : </a>
<a name="5249"><span class="lineNum">    5249 </span><span class="lineCov">       5596 :   orig_type = constant-&gt;type;</span></a>
<a name="5250"><span class="lineNum">    5250 </span>            :   /* Watch out for constants (like ck_init_repeat) that have no type. */</a>
<a name="5251"><span class="lineNum">    5251 </span><span class="lineCov">       5596 :   if (orig_type == NULL) {</span></a>
<a name="5252"><span class="lineNum">    5252 </span>            : #if CHECKING</a>
<a name="5253"><span class="lineNum">    5253 </span><span class="lineNoCov">          0 :     if (kind != (a_constant_repr_kind)ck_init_repeat &amp;&amp;</span></a>
<a name="5254"><span class="lineNum">    5254 </span><span class="lineNoCov">          0 :         kind != (a_constant_repr_kind)ck_designator) {</span></a>
<a name="5255"><span class="lineNum">    5255 </span>            : #if DEBUG</a>
<a name="5256"><span class="lineNum">    5256 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="5257"><span class="lineNum">    5257 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;**NULL-CONSTANT-TYPE**&quot;, octl);</span></a>
<a name="5258"><span class="lineNum">    5258 </span>            :       } else</a>
<a name="5259"><span class="lineNum">    5259 </span>            : #endif /* DEBUG */</a>
<a name="5260"><span class="lineNum">    5260 </span>            :       /* Do not insert code here.  This is the else of an &quot;if&quot;. */</a>
<a name="5261"><span class="lineNum">    5261 </span>            :       {</a>
<a name="5262"><span class="lineNum">    5262 </span><span class="lineNoCov">          0 :         unexpected_condition_str(&quot;form_constant: constant with null type&quot;);</span></a>
<a name="5263"><span class="lineNum">    5263 </span>            :       }</a>
<a name="5264"><span class="lineNum">    5264 </span>            :     }  /* if */</a>
<a name="5265"><span class="lineNum">    5265 </span>            : #endif /* CHECKING */</a>
<a name="5266"><span class="lineNum">    5266 </span><span class="lineCov">       5596 :   } else if (constant_should_be_put_out_as_expr(constant) &amp;&amp;</span></a>
<a name="5267"><span class="lineNum">    5267 </span><span class="lineNoCov">          0 :              !octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5268"><span class="lineNum">    5268 </span><span class="lineNoCov">          0 :              octl-&gt;output_expression != NULL) {</span></a>
<a name="5269"><span class="lineNum">    5269 </span>            :     /* An expression was recorded for this constant.  Output that expression</a>
<a name="5270"><span class="lineNum">    5270 </span>            :        rather than the folded constant. */</a>
<a name="5271"><span class="lineNum">    5271 </span><span class="lineNoCov">          0 :     octl-&gt;output_expression(constant-&gt;expr, !need_parens);</span></a>
<a name="5272"><span class="lineNum">    5272 </span><span class="lineNoCov">          0 :     goto done;</span></a>
<a name="5273"><span class="lineNum">    5273 </span>            :   } else {</a>
<a name="5274"><span class="lineNum">    5274 </span><span class="lineCov">       5596 :     con_type = skip_typerefs(orig_type);</span></a>
<a name="5275"><span class="lineNum">    5275 </span>            :     /* See if we need a cast to the constant result type. */</a>
<a name="5276"><span class="lineNum">    5276 </span><span class="lineCov">       5596 :     if (kind == (a_constant_repr_kind)ck_address ||</span></a>
<a name="5277"><span class="lineNum">    5277 </span>            :         kind == (a_constant_repr_kind)ck_ptr_to_member) {</a>
<a name="5278"><span class="lineNum">    5278 </span>            :       /* Don't do this here for address constants or pointer-to-member</a>
<a name="5279"><span class="lineNum">    5279 </span>            :          constants (they're handled in the subroutines). */</a>
<a name="5280"><span class="lineNum">    5280 </span>            :     } else {</a>
<a name="5281"><span class="lineNum">    5281 </span>            :       /* If the constant is implicitly cast to another type, prefix the</a>
<a name="5282"><span class="lineNum">    5282 </span>            :          constant with an explicit cast. */</a>
<a name="5283"><span class="lineNum">    5283 </span><span class="lineCov">       5596 :       a_boolean need_cast = FALSE;</span></a>
<a name="5284"><span class="lineNum">    5284 </span><span class="lineCov">       5596 :       if (constant-&gt;is_reinterpret_cast &amp;&amp; !octl-&gt;c_generating_back_end) {</span></a>
<a name="5285"><span class="lineNum">    5285 </span>            :         /* The source form used reinterpret_cast, so a cast is needed. */</a>
<a name="5286"><span class="lineNum">    5286 </span>            :         need_cast = TRUE;</a>
<a name="5287"><span class="lineNum">    5287 </span>            :         need_reinterpret_cast = TRUE;</a>
<a name="5288"><span class="lineNum">    5288 </span><span class="lineCov">       5596 :       } else if (constant-&gt;explicit_cast_applied ||</span></a>
<a name="5289"><span class="lineNum">    5289 </span>            :                  constant-&gt;is_compound_literal) {</a>
<a name="5290"><span class="lineNum">    5290 </span>            :         /* The source form involved an explicit cast. */</a>
<a name="5291"><span class="lineNum">    5291 </span><span class="lineNoCov">          0 :         if (kind == (a_constant_repr_kind)ck_string) {</span></a>
<a name="5292"><span class="lineNum">    5292 </span>            :           /* This was a compound literal in the source, but the generated</a>
<a name="5293"><span class="lineNum">    5293 </span>            :              C code should just have the string form. */</a>
<a name="5294"><span class="lineNum">    5294 </span><span class="lineNoCov">          0 :           need_cast = (!octl-&gt;gen_compilable_code ||</span></a>
<a name="5295"><span class="lineNum">    5295 </span><span class="lineNoCov">          0 :                        !octl-&gt;c_generating_back_end);</span></a>
<a name="5296"><span class="lineNum">    5296 </span>            :         } else {</a>
<a name="5297"><span class="lineNum">    5297 </span>            :           need_cast = TRUE;</a>
<a name="5298"><span class="lineNum">    5298 </span>            :         }  /* if */</a>
<a name="5299"><span class="lineNum">    5299 </span><span class="lineCov">       5596 :       } else if (constant-&gt;implicit_cast) {</span></a>
<a name="5300"><span class="lineNum">    5300 </span><span class="lineNoCov">          0 :         if (</span></a>
<a name="5301"><span class="lineNum">    5301 </span>            : #if DEBUG</a>
<a name="5302"><span class="lineNum">    5302 </span><span class="lineNoCov">          0 :             (octl-&gt;debug_output &amp;&amp; !is_nullptr_type(con_type)) ||</span></a>
<a name="5303"><span class="lineNum">    5303 </span>            : #endif /* DEBUG */</a>
<a name="5304"><span class="lineNum">    5304 </span><span class="lineNoCov">          0 :             octl-&gt;c_generating_back_end) {</span></a>
<a name="5305"><span class="lineNum">    5305 </span>            : #if GCC_BUILTIN_VARARGS</a>
<a name="5306"><span class="lineNum">    5306 </span><span class="lineNoCov">          0 :           a_type_ptr tp;</span></a>
<a name="5307"><span class="lineNum">    5307 </span><span class="lineNoCov">          0 :           a_boolean  builtin_va_list = FALSE;</span></a>
<a name="5308"><span class="lineNum">    5308 </span><span class="lineNoCov">          0 :           for (tp = orig_type;</span></a>
<a name="5309"><span class="lineNum">    5309 </span><span class="lineNoCov">          0 :                !builtin_va_list &amp;&amp; tp != NULL &amp;&amp;</span></a>
<a name="5310"><span class="lineNum">    5310 </span><span class="lineNoCov">          0 :                                            tp-&gt;kind == (a_type_kind)tk_typeref;</span></a>
<a name="5311"><span class="lineNum">    5311 </span><span class="lineNoCov">          0 :                tp = tp-&gt;variant.typeref.type) {</span></a>
<a name="5312"><span class="lineNum">    5312 </span><span class="lineNoCov">          0 :             builtin_va_list = tp-&gt;is_builtin_va_list;</span></a>
<a name="5313"><span class="lineNum">    5313 </span>            :           }  /* for */</a>
<a name="5314"><span class="lineNum">    5314 </span><span class="lineNoCov">          0 :           if (builtin_va_list) {</span></a>
<a name="5315"><span class="lineNum">    5315 </span>            :             /* We must avoid casting to __builtin_va_list because it might</a>
<a name="5316"><span class="lineNum">    5316 </span>            :                be an array type on some systems. */</a>
<a name="5317"><span class="lineNum">    5317 </span>            :           } else</a>
<a name="5318"><span class="lineNum">    5318 </span>            : #endif /* GCC_BUILTIN_VARARGS */</a>
<a name="5319"><span class="lineNum">    5319 </span>            :           /* Do not insert code here. */</a>
<a name="5320"><span class="lineNum">    5320 </span>            :           {</a>
<a name="5321"><span class="lineNum">    5321 </span>            :             /* Give full information about implicit casts when generating</a>
<a name="5322"><span class="lineNum">    5322 </span>            :                debug output and in the C generating back end (for the</a>
<a name="5323"><span class="lineNum">    5323 </span>            :                latter, because casts added by IL lowering are &quot;implicit&quot;</a>
<a name="5324"><span class="lineNum">    5324 </span>            :                but they need to be put out). */</a>
<a name="5325"><span class="lineNum">    5325 </span><span class="lineNoCov">          0 :             need_cast = TRUE;</span></a>
<a name="5326"><span class="lineNum">    5326 </span><span class="lineNoCov">          0 :             if (octl-&gt;gen_compilable_code &amp;&amp; C_mode() &amp;&amp;</span></a>
<a name="5327"><span class="lineNum">    5327 </span><span class="lineNoCov">          0 :                 is_directly_variably_modified_type(orig_type)) {</span></a>
<a name="5328"><span class="lineNum">    5328 </span>            :               /* Casts to directly variably-modified types must be</a>
<a name="5329"><span class="lineNum">    5329 </span>            :                  suppressed.  That's possible because they are folded into</a>
<a name="5330"><span class="lineNum">    5330 </span>            :                  the constant only if they are implicit.  However, we must</a>
<a name="5331"><span class="lineNum">    5331 </span>            :                  still deal with the fact that the constant may have been</a>
<a name="5332"><span class="lineNum">    5332 </span>            :                  explicitly cast to some other pointer type before it was</a>
<a name="5333"><span class="lineNum">    5333 </span>            :                  cast to the variably-modified type. */</a>
<a name="5334"><span class="lineNum">    5334 </span><span class="lineNoCov">          0 :               check_assertion(is_pointer_type(orig_type));</span></a>
<a name="5335"><span class="lineNum">    5335 </span><span class="lineNoCov">          0 :               need_cast = FALSE;</span></a>
<a name="5336"><span class="lineNum">    5336 </span>            :               /* For null pointer constants, the extra cast to &quot;void *&quot; is</a>
<a name="5337"><span class="lineNum">    5337 </span>            :                  not necessary. */</a>
<a name="5338"><span class="lineNum">    5338 </span><span class="lineNoCov">          0 :               if (constant-&gt;kind != (a_constant_repr_kind)ck_integer ||</span></a>
<a name="5339"><span class="lineNum">    5339 </span><span class="lineNoCov">          0 :                   cmplit_integer_constant(constant,</span></a>
<a name="5340"><span class="lineNum">    5340 </span>            :                                           (a_host_large_integer)0) != 0) {</a>
<a name="5341"><span class="lineNum">    5341 </span><span class="lineNoCov">          0 :                 output_optional_open_paren(&amp;need_parens,</span></a>
<a name="5342"><span class="lineNum">    5342 </span>            :                                            &amp;need_cast_close_paren, octl);</a>
<a name="5343"><span class="lineNum">    5343 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot;(void *)&quot;, octl);</span></a>
<a name="5344"><span class="lineNum">    5344 </span><span class="lineNoCov">          0 :                 cast_already_put_out = TRUE;</span></a>
<a name="5345"><span class="lineNum">    5345 </span>            :               }  /* if */</a>
<a name="5346"><span class="lineNum">    5346 </span>            :             }  /* if */</a>
<a name="5347"><span class="lineNum">    5347 </span>            :           }  /* if */</a>
<a name="5348"><span class="lineNum">    5348 </span><span class="lineNoCov">          0 :         } else if (is_pointer_type(con_type) &amp;&amp;</span></a>
<a name="5349"><span class="lineNum">    5349 </span><span class="lineNoCov">          0 :                    kind == (a_constant_repr_kind)ck_integer &amp;&amp;</span></a>
<a name="5350"><span class="lineNum">    5350 </span><span class="lineNoCov">          0 :                    cmplit_integer_constant(constant,</span></a>
<a name="5351"><span class="lineNum">    5351 </span>            :                                            (a_host_large_integer)0) == 0) {</a>
<a name="5352"><span class="lineNum">    5352 </span>            :           /* Always put casts on null pointers, because when &quot;x&quot; is</a>
<a name="5353"><span class="lineNum">    5353 </span>            :              changed to &quot;x != (T *)0&quot; because it appears in a condition</a>
<a name="5354"><span class="lineNum">    5354 </span>            :              context, you don't want to put out &quot;x != 0&quot; which might be</a>
<a name="5355"><span class="lineNum">    5355 </span>            :              ambiguous when x has a class type. */</a>
<a name="5356"><span class="lineNum">    5356 </span><span class="lineNoCov">          0 :           need_cast = TRUE;</span></a>
<a name="5357"><span class="lineNum">    5357 </span>            :         }  /* if */</a>
<a name="5358"><span class="lineNum">    5358 </span>            : #if GNU_VECTOR_TYPES_ALLOWED</a>
<a name="5359"><span class="lineNum">    5359 </span><span class="lineCov">       5596 :       } else if (is_vector_type(con_type)) {</span></a>
<a name="5360"><span class="lineNum">    5360 </span>            :         /* Vector constants must be generated as an aggregate constant,</a>
<a name="5361"><span class="lineNum">    5361 </span>            :            e.g., (VF2){ 1.0, 2.0 }. */</a>
<a name="5362"><span class="lineNum">    5362 </span><span class="lineNoCov">          0 :         need_cast = TRUE;</span></a>
<a name="5363"><span class="lineNum">    5363 </span>            : #endif /* GNU_VECTOR_TYPES_ALLOWED */</a>
<a name="5364"><span class="lineNum">    5364 </span>            :       }  /* if */</a>
<a name="5365"><span class="lineNum">    5365 </span><span class="lineCov">       5596 :       if (need_cast) {</span></a>
<a name="5366"><span class="lineNum">    5366 </span>            :         /* Prefix the constant with an explicit cast. */</a>
<a name="5367"><span class="lineNum">    5367 </span><span class="lineNoCov">          0 :         output_optional_open_paren(&amp;need_parens, &amp;need_cast_close_paren, octl);</span></a>
<a name="5368"><span class="lineNum">    5368 </span><span class="lineNoCov">          0 :         if (constant-&gt;kind == (a_constant_repr_kind)ck_aggregate &amp;&amp;</span></a>
<a name="5369"><span class="lineNum">    5369 </span><span class="lineNoCov">          0 :             !constant-&gt;is_compound_literal &amp;&amp;</span></a>
<a name="5370"><span class="lineNum">    5370 </span><span class="lineNoCov">          0 :             !octl-&gt;c_generating_back_end) {</span></a>
<a name="5371"><span class="lineNum">    5371 </span>            :           /* This must have been a cast like T{}, so just put out the type</a>
<a name="5372"><span class="lineNum">    5372 </span>            :              name here; the ck_aggregate output will provide the braces. */</a>
<a name="5373"><span class="lineNum">    5373 </span><span class="lineNoCov">          0 :           form_type(orig_type, octl);</span></a>
<a name="5374"><span class="lineNum">    5374 </span>            :         } else {</a>
<a name="5375"><span class="lineNum">    5375 </span>            :           /* Put out either a reintepret_cast or a C-style cast. */</a>
<a name="5376"><span class="lineNum">    5376 </span><span class="lineNoCov">          0 :           form_general_cast(orig_type, need_reinterpret_cast, octl);</span></a>
<a name="5377"><span class="lineNum">    5377 </span>            :         }  /* if */</a>
<a name="5378"><span class="lineNum">    5378 </span>            :         cast_already_put_out = TRUE;</a>
<a name="5379"><span class="lineNum">    5379 </span>            :       }  /* if */</a>
<a name="5380"><span class="lineNum">    5380 </span>            :     }  /* if */</a>
<a name="5381"><span class="lineNum">    5381 </span>            :   }  /* if */</a>
<a name="5382"><span class="lineNum">    5382 </span><span class="lineCov">       5596 :   switch (kind) {</span></a>
<a name="5383"><span class="lineNum">    5383 </span><span class="lineNoCov">          0 :     case ck_error:</span></a>
<a name="5384"><span class="lineNum">    5384 </span><span class="lineNoCov">          0 :       check_assertion_str(!octl-&gt;gen_compilable_code,</span></a>
<a name="5385"><span class="lineNum">    5385 </span><span class="lineNoCov">          0 :                           &quot;form_constant: error constant&quot;);</span></a>
<a name="5386"><span class="lineNum">    5386 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;error-constant&gt;&quot;, octl);</span></a>
<a name="5387"><span class="lineNum">    5387 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5388"><span class="lineNum">    5388 </span>            : #if UPC_EXTENSIONS_ALLOWED</a>
<a name="5389"><span class="lineNum">    5389 </span><span class="lineNoCov">          0 :     case ck_upc_mythread:</span></a>
<a name="5390"><span class="lineNum">    5390 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;MYTHREAD&quot;, octl);</span></a>
<a name="5391"><span class="lineNum">    5391 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5392"><span class="lineNum">    5392 </span><span class="lineCov">       5073 :     case ck_upc_threads:</span></a>
<a name="5393"><span class="lineNum">    5393 </span>            : #endif /* UPC_EXTENSIONS_ALLOWED */</a>
<a name="5394"><span class="lineNum">    5394 </span>            :     case ck_integer:</a>
<a name="5395"><span class="lineNum">    5395 </span>            :       /* See if the constant is an enum constant, but don't emit enum</a>
<a name="5396"><span class="lineNum">    5396 </span>            :          constants when generating K&amp;R C from the C-generating back end. */</a>
<a name="5397"><span class="lineNum">    5397 </span><span class="lineCov">      10146 :       is_enum = !(octl-&gt;c_generating_back_end &amp;&amp; octl-&gt;gen_pcc_code) &amp;&amp;</span></a>
<a name="5398"><span class="lineNum">    5398 </span><span class="lineCov">       5073 :                 is_enum_constant(constant);</span></a>
<a name="5399"><span class="lineNum">    5399 </span><span class="lineNoCov">          0 :       if (is_enum &amp;&amp; has_name(constant) &amp;&amp;</span></a>
<a name="5400"><span class="lineNum">    5400 </span><span class="lineNoCov">          0 :           !(octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5401"><span class="lineNum">    5401 </span><span class="lineNoCov">          0 :             !constant-&gt;is_named_constant_definition)) {</span></a>
<a name="5402"><span class="lineNum">    5402 </span>            :         /* A named enum constant.  The original constant entry used to</a>
<a name="5403"><span class="lineNum">    5403 </span>            :            represent the enumerator constant declaration can always just be</a>
<a name="5404"><span class="lineNum">    5404 </span>            :            rendered.  However, for copies of that entry (used in expression</a>
<a name="5405"><span class="lineNum">    5405 </span>            :            contexts), only the unmangled name is available, which may not</a>
<a name="5406"><span class="lineNum">    5406 </span>            :            be appropriate when generating code in the C-generating back</a>
<a name="5407"><span class="lineNum">    5407 </span>            :            end. */</a>
<a name="5408"><span class="lineNum">    5408 </span><span class="lineNoCov">          0 :         a_scope_ptr orig_parent_scope = constant-&gt;source_corresp.parent_scope;</span></a>
<a name="5409"><span class="lineNum">    5409 </span><span class="lineNoCov">          0 :         a_boolean   orig_class_member =</span></a>
<a name="5410"><span class="lineNum">    5410 </span><span class="lineNoCov">          0 :                                       constant-&gt;source_corresp.is_class_member;</span></a>
<a name="5411"><span class="lineNum">    5411 </span><span class="lineNoCov">          0 :         if (orig_parent_scope == NULL) {</span></a>
<a name="5412"><span class="lineNum">    5412 </span>            :           /* The parent scope can be lost when copying an enumerator</a>
<a name="5413"><span class="lineNum">    5413 </span>            :              constant.  Temporarily set the enumerator's parent scope as</a>
<a name="5414"><span class="lineNum">    5414 </span>            :              determined by its type (the enumeration's parent scope or, for</a>
<a name="5415"><span class="lineNum">    5415 </span>            :              a scoped enumeration, the associated scope of the type itself)</a>
<a name="5416"><span class="lineNum">    5416 </span>            :              so that the name's qualification will be correct. */</a>
<a name="5417"><span class="lineNum">    5417 </span><span class="lineNoCov">          0 :           a_type_ptr tp = constant-&gt;type;</span></a>
<a name="5418"><span class="lineNum">    5418 </span><span class="lineNoCov">          0 :           if (tp-&gt;variant.integer.is_scoped_enum) {</span></a>
<a name="5419"><span class="lineNum">    5419 </span><span class="lineNoCov">          0 :             constant-&gt;source_corresp.parent_scope =</span></a>
<a name="5420"><span class="lineNum">    5420 </span><span class="lineNoCov">          0 :                                      tp-&gt;variant.integer.enum_info.assoc_scope;</span></a>
<a name="5421"><span class="lineNum">    5421 </span>            :           } else {</a>
<a name="5422"><span class="lineNum">    5422 </span><span class="lineNoCov">          0 :             constant-&gt;source_corresp.parent_scope =</span></a>
<a name="5423"><span class="lineNum">    5423 </span><span class="lineNoCov">          0 :                                                tp-&gt;source_corresp.parent_scope;</span></a>
<a name="5424"><span class="lineNum">    5424 </span><span class="lineNoCov">          0 :             constant-&gt;source_corresp.is_class_member =</span></a>
<a name="5425"><span class="lineNum">    5425 </span><span class="lineNoCov">          0 :                                             tp-&gt;source_corresp.is_class_member;</span></a>
<a name="5426"><span class="lineNum">    5426 </span>            :           }  /* if */</a>
<a name="5427"><span class="lineNum">    5427 </span>            :         }  /* if */</a>
<a name="5428"><span class="lineNum">    5428 </span><span class="lineNoCov">          0 :         form_name(&amp;constant-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="5429"><span class="lineNum">    5429 </span>            :         /* Restore the enumerator's parent scope information in case it was</a>
<a name="5430"><span class="lineNum">    5430 </span>            :            overwritten above. */</a>
<a name="5431"><span class="lineNum">    5431 </span><span class="lineNoCov">          0 :         constant-&gt;source_corresp.parent_scope = orig_parent_scope;</span></a>
<a name="5432"><span class="lineNum">    5432 </span><span class="lineNoCov">          0 :         constant-&gt;source_corresp.is_class_member = orig_class_member;</span></a>
<a name="5433"><span class="lineNum">    5433 </span><span class="lineCov">       5073 :       } else if (is_enum &amp;&amp; il_header.source_language == sl_Cplusplus &amp;&amp;</span></a>
<a name="5434"><span class="lineNum">    5434 </span>            : #if DEBUG</a>
<a name="5435"><span class="lineNum">    5435 </span><span class="lineNoCov">          0 :                  !octl-&gt;debug_output &amp;&amp;</span></a>
<a name="5436"><span class="lineNum">    5436 </span>            : #endif /* DEBUG */</a>
<a name="5437"><span class="lineNum">    5437 </span><span class="lineNoCov">          0 :                  is_enum_constant_equivalent(constant, &amp;equiv_constant)) {</span></a>
<a name="5438"><span class="lineNum">    5438 </span>            :         /* The equivalent of an enum constant (an enum constant used in</a>
<a name="5439"><span class="lineNum">    5439 </span>            :            an initializer; it's a nonshared constant with the same value as</a>
<a name="5440"><span class="lineNum">    5440 </span>            :            the named enumeration constant). */</a>
<a name="5441"><span class="lineNum">    5441 </span><span class="lineNoCov">          0 :         form_name(&amp;equiv_constant-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="5442"><span class="lineNum">    5442 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="5443"><span class="lineNum">    5443 </span><span class="lineCov">       5073 :       } else if (!octl-&gt;c_generating_back_end &amp;&amp; constant-&gt;null_keyword) {</span></a>
<a name="5444"><span class="lineNum">    5444 </span>            :         /* The GNU C++ __null keyword. */</a>
<a name="5445"><span class="lineNum">    5445 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;__null&quot;, octl);</span></a>
<a name="5446"><span class="lineNum">    5446 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="5447"><span class="lineNum">    5447 </span><span class="lineCov">      10146 :       } else if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5448"><span class="lineNum">    5448 </span><span class="lineCov">      10146 :                  (is_nullptr_type(con_type) || constant-&gt;nullptr_keyword)) {</span></a>
<a name="5449"><span class="lineNum">    5449 </span>            :         /* The C++ and C++/CLI nullptr keyword.  (We test the type in</a>
<a name="5450"><span class="lineNum">    5450 </span>            :            addition to checking constant-&gt;nullptr_keyword in order to</a>
<a name="5451"><span class="lineNum">    5451 </span>            :            handle the case of a call to a constexpr function resulting in a</a>
<a name="5452"><span class="lineNum">    5452 </span>            :            constant for which the call was not kept as the constant's</a>
<a name="5453"><span class="lineNum">    5453 </span>            :            backing expression, e.g., in a template argument.  Both tests</a>
<a name="5454"><span class="lineNum">    5454 </span>            :            are necessary as sometimes the type of the constant will have</a>
<a name="5455"><span class="lineNum">    5455 </span>            :            been adjusted to something other than std:nullptr_t but the</a>
<a name="5456"><span class="lineNum">    5456 </span>            :            constant should still be put out as the nullptr keyword.) */</a>
<a name="5457"><span class="lineNum">    5457 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;nullptr&quot;, octl);</span></a>
<a name="5458"><span class="lineNum">    5458 </span>            : #if MICROSOFT_EXTENSIONS_ALLOWED</a>
<a name="5459"><span class="lineNum">    5459 </span>            :       } else if (!octl-&gt;c_generating_back_end &amp;&amp;</a>
<a name="5460"><span class="lineNum">    5460 </span>            :                                             constant-&gt;native_nullptr_keyword) {</a>
<a name="5461"><span class="lineNum">    5461 </span>            :         /* The Microsoft __nullptr keyword. */</a>
<a name="5462"><span class="lineNum">    5462 </span>            :         octl-&gt;output_str(&quot;__nullptr&quot;, octl);</a>
<a name="5463"><span class="lineNum">    5463 </span>            : #endif /* MICROSOFT_EXTENSIONS_ALLOWED */</a>
<a name="5464"><span class="lineNum">    5464 </span>            :         /* coverity[var_deref_model] */</a>
<a name="5465"><span class="lineNum">    5465 </span><span class="lineCov">       5073 :       } else if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5466"><span class="lineNum">    5466 </span><span class="lineCov">      10146 :                  il_header.source_language == sl_Cplusplus &amp;&amp;</span></a>
<a name="5467"><span class="lineNum">    5467 </span><span class="lineCov">       5073 :                  is_bool_type(con_type)) {</span></a>
<a name="5468"><span class="lineNum">    5468 </span>            :         /* A bool constant. */</a>
<a name="5469"><span class="lineNum">    5469 </span><span class="lineNoCov">          0 :         octl-&gt;output_str((char *)(</span></a>
<a name="5470"><span class="lineNum">    5470 </span><span class="lineNoCov">          0 :                cmplit_integer_constant(constant,</span></a>
<a name="5471"><span class="lineNum">    5471 </span>            :                             (a_host_large_integer)0) != 0 ? &quot;true&quot; : &quot;false&quot;),</a>
<a name="5472"><span class="lineNum">    5472 </span>            :                          octl);</a>
<a name="5473"><span class="lineNum">    5473 </span>            :         /* coverity[var_deref_model] */</a>
<a name="5474"><span class="lineNum">    5474 </span><span class="lineCov">       5073 :       } else if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5475"><span class="lineNum">    5475 </span><span class="lineCov">      10146 :                  il_header.source_language == sl_Cplusplus &amp;&amp;</span></a>
<a name="5476"><span class="lineNum">    5476 </span><span class="lineCov">       5073 :                  is_character_type(con_type)) {</span></a>
<a name="5477"><span class="lineNum">    5477 </span>            :         /* In C++, character constants have char type. */</a>
<a name="5478"><span class="lineNum">    5478 </span><span class="lineCov">        456 :         a_boolean       ovflo, need_char_cast_close_paren = FALSE;</span></a>
<a name="5479"><span class="lineNum">    5479 </span>            :         /* coverity[var_deref_op] */</a>
<a name="5480"><span class="lineNum">    5480 </span><span class="lineCov">        456 :         an_integer_kind ikind = con_type-&gt;variant.integer.int_kind;</span></a>
<a name="5481"><span class="lineNum">    5481 </span>            :         /* Use a cast if the constant is signed or unsigned, e.g.,</a>
<a name="5482"><span class="lineNum">    5482 </span>            :            (unsigned char)'a'. */</a>
<a name="5483"><span class="lineNum">    5483 </span><span class="lineCov">        456 :         if (ikind == (an_integer_kind)ik_signed_char ||</span></a>
<a name="5484"><span class="lineNum">    5484 </span>            :             ikind == (an_integer_kind)ik_unsigned_char) {</a>
<a name="5485"><span class="lineNum">    5485 </span><span class="lineNoCov">          0 :           output_optional_open_paren(&amp;need_parens,</span></a>
<a name="5486"><span class="lineNum">    5486 </span>            :                                      &amp;need_char_cast_close_paren,</a>
<a name="5487"><span class="lineNum">    5487 </span>            :                                      octl);</a>
<a name="5488"><span class="lineNum">    5488 </span><span class="lineNoCov">          0 :           form_cast(orig_type, octl);</span></a>
<a name="5489"><span class="lineNum">    5489 </span>            :         }  /* if */</a>
<a name="5490"><span class="lineNum">    5490 </span><span class="lineCov">        456 :         output_partial_token_str(&quot;'&quot;, octl);</span></a>
<a name="5491"><span class="lineNum">    5491 </span>            :         /* Coverity complains because form_char passes the character value</a>
<a name="5492"><span class="lineNum">    5492 </span>            :            to isprint, but it casts it to unsigned char the complaint is</a>
<a name="5493"><span class="lineNum">    5493 </span>            :            spurious. */</a>
<a name="5494"><span class="lineNum">    5494 </span>            :         /* coverity[negative_returns] */  /* Coverity bug. */</a>
<a name="5495"><span class="lineNum">    5495 </span><span class="lineCov">        456 :         (void)form_char((char)value_of_integer_constant(constant, &amp;ovflo),</span></a>
<a name="5496"><span class="lineNum">    5496 </span>            :                         octl);</a>
<a name="5497"><span class="lineNum">    5497 </span><span class="lineCov">        456 :         output_partial_token_str(&quot;'&quot;, octl);</span></a>
<a name="5498"><span class="lineNum">    5498 </span><span class="lineCov">        456 :         output_optional_close_paren(need_char_cast_close_paren, octl);</span></a>
<a name="5499"><span class="lineNum">    5499 </span>            :         /* coverity[var_deref_op] */</a>
<a name="5500"><span class="lineNum">    5500 </span><span class="lineCov">       4617 :       } else if (!octl-&gt;c_generating_back_end &amp;&amp;</span></a>
<a name="5501"><span class="lineNum">    5501 </span><span class="lineCov">       4617 :                  con_type-&gt;kind == (a_type_kind)tk_integer &amp;&amp;</span></a>
<a name="5502"><span class="lineNum">    5502 </span><span class="lineCov">       4617 :                  !is_normal_character_kind(constant-&gt;character_kind)) {</span></a>
<a name="5503"><span class="lineNum">    5503 </span>            :         /* A wide character literal (wchar_t, char16_t, or char32_t). */</a>
<a name="5504"><span class="lineNum">    5504 </span><span class="lineNoCov">          0 :         a_boolean    ovflo;</span></a>
<a name="5505"><span class="lineNum">    5505 </span><span class="lineNoCov">          0 :         a_const_char *prefix = NULL;</span></a>
<a name="5506"><span class="lineNum">    5506 </span><span class="lineNoCov">          0 :         switch (constant-&gt;character_kind) {</span></a>
<a name="5507"><span class="lineNum">    5507 </span>            :           case chk_wchar_t:   prefix = &quot;L'&quot;;     break;</a>
<a name="5508"><span class="lineNum">    5508 </span><span class="lineNoCov">          0 :           case chk_char16_t:  prefix = &quot;u'&quot;;     break;</span></a>
<a name="5509"><span class="lineNum">    5509 </span><span class="lineNoCov">          0 :           case chk_char32_t:  prefix = &quot;U'&quot;;     break;</span></a>
<a name="5510"><span class="lineNum">    5510 </span><span class="lineNoCov">          0 :           default:            unexpected_condition();</span></a>
<a name="5511"><span class="lineNum">    5511 </span>            :         }  /* switch */</a>
<a name="5512"><span class="lineNum">    5512 </span><span class="lineNoCov">          0 :         output_partial_token_str(prefix, octl);</span></a>
<a name="5513"><span class="lineNum">    5513 </span><span class="lineNoCov">          0 :         (void)form_wide_char(</span></a>
<a name="5514"><span class="lineNum">    5514 </span><span class="lineNoCov">          0 :                     (unsigned long)unsigned_value_of_integer_constant(constant,</span></a>
<a name="5515"><span class="lineNum">    5515 </span>            :                                                                       &amp;ovflo),</a>
<a name="5516"><span class="lineNum">    5516 </span>            :                     octl);</a>
<a name="5517"><span class="lineNum">    5517 </span><span class="lineNoCov">          0 :         output_partial_token_str(&quot;'&quot;, octl);</span></a>
<a name="5518"><span class="lineNum">    5518 </span>            :       } else {</a>
<a name="5519"><span class="lineNum">    5519 </span>            :         /* A normal integer constant. */</a>
<a name="5520"><span class="lineNum">    5520 </span><span class="lineCov">       4617 :         form_integer_constant(constant, cast_already_put_out,</span></a>
<a name="5521"><span class="lineNum">    5521 </span>            :                               need_parens, octl);</a>
<a name="5522"><span class="lineNum">    5522 </span>            :       }  /* if */</a>
<a name="5523"><span class="lineNum">    5523 </span>            :       break;</a>
<a name="5524"><span class="lineNum">    5524 </span>            : #if FIXED_POINT_ALLOWED</a>
<a name="5525"><span class="lineNum">    5525 </span><span class="lineNoCov">          0 :     case ck_fixed_point:</span></a>
<a name="5526"><span class="lineNum">    5526 </span>            :       /* Fixed-point constant. */</a>
<a name="5527"><span class="lineNum">    5527 </span>            :       /* Put parentheses around the constant in case it's negative. */</a>
<a name="5528"><span class="lineNum">    5528 </span><span class="lineNoCov">          0 :       check_assertion(is_fixed_point_type(constant-&gt;type));</span></a>
<a name="5529"><span class="lineNum">    5529 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5530"><span class="lineNum">    5530 </span>            :       /* coverity[var_deref_op] */</a>
<a name="5531"><span class="lineNum">    5531 </span><span class="lineNoCov">          0 :       form_fixed_point_constant(&amp;constant-&gt;variant.fixed_point_value,</span></a>
<a name="5532"><span class="lineNum">    5532 </span>            :                                 &amp;con_type-&gt;variant.fixed_point,</a>
<a name="5533"><span class="lineNum">    5533 </span>            :                                 octl);</a>
<a name="5534"><span class="lineNum">    5534 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5535"><span class="lineNum">    5535 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5536"><span class="lineNum">    5536 </span>            : #endif /* FIXED_POINT_ALLOWED */</a>
<a name="5537"><span class="lineNum">    5537 </span><span class="lineCov">        521 :     case ck_string:</span></a>
<a name="5538"><span class="lineNum">    5538 </span>            :       /* String constant. */</a>
<a name="5539"><span class="lineNum">    5539 </span><span class="lineCov">        521 :       { a_targ_size_t a;</span></a>
<a name="5540"><span class="lineNum">    5540 </span><span class="lineCov">        521 :         char          ch;</span></a>
<a name="5541"><span class="lineNum">    5541 </span><span class="lineCov">        521 :         unsigned long wc;</span></a>
<a name="5542"><span class="lineNum">    5542 </span><span class="lineCov">        521 :         a_const_char  *str = constant-&gt;variant.string.value, *prefix = NULL;</span></a>
<a name="5543"><span class="lineNum">    5543 </span><span class="lineCov">        521 :         a_targ_size_t len = constant-&gt;variant.string.length;</span></a>
<a name="5544"><span class="lineNum">    5544 </span><span class="lineCov">        521 :         int           out_len = 0;</span></a>
<a name="5545"><span class="lineNum">    5545 </span><span class="lineCov">        521 :         a_character_kind  character_kind = constant-&gt;character_kind;</span></a>
<a name="5546"><span class="lineNum">    5546 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="5547"><span class="lineNum">    5547 </span>            :         if (octl-&gt;c_generating_back_end &amp;&amp; constant-&gt;assoc_var != NULL &amp;&amp;</a>
<a name="5548"><span class="lineNum">    5548 </span>            :             !is_normal_character_kind(character_kind)) {</a>
<a name="5549"><span class="lineNum">    5549 </span>            :           /* The C-generating back end transforms wide string literals: it</a>
<a name="5550"><span class="lineNum">    5550 </span>            :              creates a variable initialized with the string value and then</a>
<a name="5551"><span class="lineNum">    5551 </span>            :              uses the variable instead of the string.  This ensures proper</a>
<a name="5552"><span class="lineNum">    5552 </span>            :              alignment for the string.  The temp name for the variable is</a>
<a name="5553"><span class="lineNum">    5553 </span>            :              derived from the address of the constant; there is no actual</a>
<a name="5554"><span class="lineNum">    5554 </span>            :              variable entry. */</a>
<a name="5555"><span class="lineNum">    5555 </span>            :           output_temp_name((char *)constant, octl);</a>
<a name="5556"><span class="lineNum">    5556 </span>            :         } else</a>
<a name="5557"><span class="lineNum">    5557 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="5558"><span class="lineNum">    5558 </span>            :         /* Do not insert code here.  This is the &quot;else&quot; of an &quot;if&quot;. */</a>
<a name="5559"><span class="lineNum">    5559 </span><span class="lineCov">        521 :         { if (constant-&gt;is_compound_literal &amp;&amp;</span></a>
<a name="5560"><span class="lineNum">    5560 </span><span class="lineNoCov">          0 :               (!octl-&gt;gen_compilable_code || !octl-&gt;c_generating_back_end)) {</span></a>
<a name="5561"><span class="lineNum">    5561 </span>            :             /* The string was originally a compound literal and, except in</a>
<a name="5562"><span class="lineNum">    5562 </span>            :                generated C code, should be put out that way. */</a>
<a name="5563"><span class="lineNum">    5563 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;{&quot;, octl);</span></a>
<a name="5564"><span class="lineNum">    5564 </span>            :           }  /* if */</a>
<a name="5565"><span class="lineNum">    5565 </span><span class="lineCov">        521 :           if (!is_normal_character_kind(character_kind)) {</span></a>
<a name="5566"><span class="lineNum">    5566 </span>            :             /* A string literal with a prefix, e.g., L&quot;abc&quot; or U&quot;xyz&quot;. */</a>
<a name="5567"><span class="lineNum">    5567 </span>            :             /* The processing here must invert the processing done in</a>
<a name="5568"><span class="lineNum">    5568 </span>            :                conv_single_wide_char.  Do something that's right for the</a>
<a name="5569"><span class="lineNum">    5569 </span>            :                default (simple-minded) implementation, which maps one input</a>
<a name="5570"><span class="lineNum">    5570 </span>            :                character to one wide character. */</a>
<a name="5571"><span class="lineNum">    5571 </span><span class="lineNoCov">          0 :             a_targ_size_t char_size = character_size[character_kind];</span></a>
<a name="5572"><span class="lineNum">    5572 </span><span class="lineNoCov">          0 :             switch (character_kind) {</span></a>
<a name="5573"><span class="lineNum">    5573 </span>            :               case chk_wchar_t:   prefix = &quot;L\&quot;&quot;;     break;</a>
<a name="5574"><span class="lineNum">    5574 </span><span class="lineNoCov">          0 :               case chk_char16_t:  prefix = &quot;u\&quot;&quot;;     break;</span></a>
<a name="5575"><span class="lineNum">    5575 </span><span class="lineNoCov">          0 :               case chk_char32_t:  prefix = &quot;U\&quot;&quot;;     break;</span></a>
<a name="5576"><span class="lineNum">    5576 </span><span class="lineNoCov">          0 :               default:            unexpected_condition();</span></a>
<a name="5577"><span class="lineNum">    5577 </span>            :             }  /* switch */</a>
<a name="5578"><span class="lineNum">    5578 </span><span class="lineNoCov">          0 :             output_partial_token_str(prefix, octl);</span></a>
<a name="5579"><span class="lineNum">    5579 </span><span class="lineNoCov">          0 :             for (a = 0; a &lt; len; a += char_size) {</span></a>
<a name="5580"><span class="lineNum">    5580 </span>            :               /* When generating output for humans to read, abbreviate</a>
<a name="5581"><span class="lineNum">    5581 </span>            :                  long strings. */</a>
<a name="5582"><span class="lineNum">    5582 </span><span class="lineNoCov">          0 :               if (!octl-&gt;gen_compilable_code &amp;&amp; a &gt; 20*char_size &amp;&amp;</span></a>
<a name="5583"><span class="lineNum">    5583 </span><span class="lineNoCov">          0 :                   len &gt; 25*char_size) {</span></a>
<a name="5584"><span class="lineNum">    5584 </span><span class="lineNoCov">          0 :                 output_partial_token_str(&quot;...&quot;, octl);</span></a>
<a name="5585"><span class="lineNum">    5585 </span>            :                 break;</a>
<a name="5586"><span class="lineNum">    5586 </span><span class="lineNoCov">          0 :               } else if (out_len &gt;= 128 &amp;&amp; octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="5587"><span class="lineNum">    5587 </span><span class="lineNoCov">          0 :                          !octl-&gt;gen_pcc_code &amp;&amp;</span></a>
<a name="5588"><span class="lineNum">    5588 </span><span class="lineNoCov">          0 :                          !octl-&gt;suppress_line_breaking) {</span></a>
<a name="5589"><span class="lineNum">    5589 </span>            :                 /* Break long string constants by using concatenation.  This</a>
<a name="5590"><span class="lineNum">    5590 </span>            :                    allows the output routine to begin a new line. */</a>
<a name="5591"><span class="lineNum">    5591 </span><span class="lineNoCov">          0 :                 output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5592"><span class="lineNum">    5592 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="5593"><span class="lineNum">    5593 </span><span class="lineNoCov">          0 :                 output_partial_token_str(prefix, octl);</span></a>
<a name="5594"><span class="lineNum">    5594 </span><span class="lineNoCov">          0 :                 out_len = 0;</span></a>
<a name="5595"><span class="lineNum">    5595 </span>            :               }  /* if */</a>
<a name="5596"><span class="lineNum">    5596 </span><span class="lineNoCov">          0 :               wc = extract_character_from_string(str+a,</span></a>
<a name="5597"><span class="lineNum">    5597 </span>            :                                                  (unsigned int)char_size);</a>
<a name="5598"><span class="lineNum">    5598 </span>            :               /* Suppress the last character if it is a null. */</a>
<a name="5599"><span class="lineNum">    5599 </span><span class="lineNoCov">          0 :               if (a != (len - char_size) || wc != '\0') {</span></a>
<a name="5600"><span class="lineNum">    5600 </span><span class="lineNoCov">          0 :                 out_len += form_wide_char(wc, octl);</span></a>
<a name="5601"><span class="lineNum">    5601 </span>            :               }  /* if */</a>
<a name="5602"><span class="lineNum">    5602 </span>            :             }  /* for */</a>
<a name="5603"><span class="lineNum">    5603 </span><span class="lineNoCov">          0 :             output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5604"><span class="lineNum">    5604 </span>            :           } else {</a>
<a name="5605"><span class="lineNum">    5605 </span>            :             /* Normal (non-wide) string. */</a>
<a name="5606"><span class="lineNum">    5606 </span><span class="lineCov">        521 :             output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5607"><span class="lineNum">    5607 </span><span class="lineCov">      14719 :             for (a = 0; a &lt; len; a++) {</span></a>
<a name="5608"><span class="lineNum">    5608 </span>            :               /* When generating output for humans to read, abbreviate</a>
<a name="5609"><span class="lineNum">    5609 </span>            :                  long strings. */</a>
<a name="5610"><span class="lineNum">    5610 </span><span class="lineCov">      13677 :               if (!octl-&gt;gen_compilable_code &amp;&amp; a &gt; 20 &amp;&amp; len &gt; 25) {</span></a>
<a name="5611"><span class="lineNum">    5611 </span><span class="lineNoCov">          0 :                 output_partial_token_str(&quot;...&quot;, octl);</span></a>
<a name="5612"><span class="lineNum">    5612 </span>            :                 break;</a>
<a name="5613"><span class="lineNum">    5613 </span>            :               }  /* if */</a>
<a name="5614"><span class="lineNum">    5614 </span><span class="lineCov">      13677 :               if (out_len &gt;= 128 &amp;&amp; octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="5615"><span class="lineNum">    5615 </span><span class="lineNoCov">          0 :                   !octl-&gt;gen_pcc_code &amp;&amp; !octl-&gt;suppress_line_breaking) {</span></a>
<a name="5616"><span class="lineNum">    5616 </span>            :                 /* Break long string constants by using concatenation.  This</a>
<a name="5617"><span class="lineNum">    5617 </span>            :                    allows the output routine to begin a new line. */</a>
<a name="5618"><span class="lineNum">    5618 </span><span class="lineNoCov">          0 :                 output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5619"><span class="lineNum">    5619 </span><span class="lineNoCov">          0 :                 octl-&gt;output_str(&quot; &quot;, octl);</span></a>
<a name="5620"><span class="lineNum">    5620 </span><span class="lineNoCov">          0 :                 output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5621"><span class="lineNum">    5621 </span><span class="lineNoCov">          0 :                 out_len = 0;</span></a>
<a name="5622"><span class="lineNum">    5622 </span>            :               }  /* if */</a>
<a name="5623"><span class="lineNum">    5623 </span><span class="lineCov">      13677 :               ch = str[a];</span></a>
<a name="5624"><span class="lineNum">    5624 </span>            :               /* Suppress the last character if it is a null. */</a>
<a name="5625"><span class="lineNum">    5625 </span><span class="lineCov">      13677 :               if (a != (len - 1) || ch != '\0') {</span></a>
<a name="5626"><span class="lineNum">    5626 </span><span class="lineCov">      13156 :                 out_len += form_char(ch, octl);</span></a>
<a name="5627"><span class="lineNum">    5627 </span>            :               }  /* if */</a>
<a name="5628"><span class="lineNum">    5628 </span>            :             }  /* for */</a>
<a name="5629"><span class="lineNum">    5629 </span><span class="lineCov">        521 :             output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="5630"><span class="lineNum">    5630 </span>            :           }  /* if */</a>
<a name="5631"><span class="lineNum">    5631 </span><span class="lineCov">        521 :           if (constant-&gt;is_compound_literal &amp;&amp;</span></a>
<a name="5632"><span class="lineNum">    5632 </span><span class="lineNoCov">          0 :               (!octl-&gt;gen_compilable_code || !octl-&gt;c_generating_back_end)) {</span></a>
<a name="5633"><span class="lineNum">    5633 </span>            :             /* The string was originally a compound literal and, except in</a>
<a name="5634"><span class="lineNum">    5634 </span>            :                generated C code, should be put out that way. */</a>
<a name="5635"><span class="lineNum">    5635 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;}&quot;, octl);</span></a>
<a name="5636"><span class="lineNum">    5636 </span>            :           }  /* if */</a>
<a name="5637"><span class="lineNum">    5637 </span>            :         }</a>
<a name="5638"><span class="lineNum">    5638 </span>            :       }</a>
<a name="5639"><span class="lineNum">    5639 </span>            :       break;</a>
<a name="5640"><span class="lineNum">    5640 </span><span class="lineCov">          2 :     case ck_float:</span></a>
<a name="5641"><span class="lineNum">    5641 </span>            : #if C99_IL_EXTENSIONS_SUPPORTED</a>
<a name="5642"><span class="lineNum">    5642 </span>            :     case ck_imaginary:</a>
<a name="5643"><span class="lineNum">    5643 </span>            : #endif /* C99_IL_EXTENSIONS_SUPPORTED */</a>
<a name="5644"><span class="lineNum">    5644 </span>            :       /* Floating-point constant. */</a>
<a name="5645"><span class="lineNum">    5645 </span>            :       /* Put parentheses around the constant in case it's negative. */</a>
<a name="5646"><span class="lineNum">    5646 </span><span class="lineCov">          2 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5647"><span class="lineNum">    5647 </span>            :       /* coverity[var_deref_op] */</a>
<a name="5648"><span class="lineNum">    5648 </span><span class="lineCov">          2 :       form_float_constant(&amp;constant-&gt;variant.float_value,</span></a>
<a name="5649"><span class="lineNum">    5649 </span><span class="lineCov">          2 :                           con_type-&gt;variant.float_kind,</span></a>
<a name="5650"><span class="lineNum">    5650 </span>            :                           constant-&gt;expr,</a>
<a name="5651"><span class="lineNum">    5651 </span>            :                           octl);</a>
<a name="5652"><span class="lineNum">    5652 </span>            : #if C99_IL_EXTENSIONS_SUPPORTED</a>
<a name="5653"><span class="lineNum">    5653 </span><span class="lineCov">          2 :       if (kind == (a_constant_repr_kind)ck_imaginary) {</span></a>
<a name="5654"><span class="lineNum">    5654 </span>            :         /* Imaginary constants are constructed with the EDG-specific __I__. */</a>
<a name="5655"><span class="lineNum">    5655 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;*__I__&quot;, octl);</span></a>
<a name="5656"><span class="lineNum">    5656 </span>            :       }  /* if */</a>
<a name="5657"><span class="lineNum">    5657 </span>            : #endif /* C99_IL_EXTENSIONS_SUPPORTED */</a>
<a name="5658"><span class="lineNum">    5658 </span><span class="lineCov">          2 :       if (octl-&gt;part_of_ud_literal) {</span></a>
<a name="5659"><span class="lineNum">    5659 </span>            :         /* This constant is the literal portion of a C++11 user-defined</a>
<a name="5660"><span class="lineNum">    5660 </span>            :            literal.  The ud-suffix must follow the literal immediately, so</a>
<a name="5661"><span class="lineNum">    5661 </span>            :            the right parenthesis cannot be put out now. */</a>
<a name="5662"><span class="lineNum">    5662 </span><span class="lineNoCov">          0 :         octl-&gt;pending_right_paren = TRUE;</span></a>
<a name="5663"><span class="lineNum">    5663 </span>            :       } else {</a>
<a name="5664"><span class="lineNum">    5664 </span><span class="lineCov">          2 :         octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5665"><span class="lineNum">    5665 </span>            :       }  /* if */</a>
<a name="5666"><span class="lineNum">    5666 </span>            :       break;</a>
<a name="5667"><span class="lineNum">    5667 </span>            : #if C99_IL_EXTENSIONS_SUPPORTED</a>
<a name="5668"><span class="lineNum">    5668 </span><span class="lineNoCov">          0 :     case ck_complex:</span></a>
<a name="5669"><span class="lineNum">    5669 </span>            :       /* Complex constant. */</a>
<a name="5670"><span class="lineNum">    5670 </span>            :       /* Put parentheses around the constant and use the form</a>
<a name="5671"><span class="lineNum">    5671 </span>            :          ( A + B*__I__ ). */</a>
<a name="5672"><span class="lineNum">    5672 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5673"><span class="lineNum">    5673 </span>            :       /* coverity[var_deref_op] */</a>
<a name="5674"><span class="lineNum">    5674 </span><span class="lineNoCov">          0 :       form_float_constant(&amp;constant-&gt;variant.complex_value-&gt;real,</span></a>
<a name="5675"><span class="lineNum">    5675 </span><span class="lineNoCov">          0 :                           con_type-&gt;variant.float_kind,</span></a>
<a name="5676"><span class="lineNum">    5676 </span>            :                           (an_expr_node_ptr)NULL,</a>
<a name="5677"><span class="lineNum">    5677 </span>            :                           octl);</a>
<a name="5678"><span class="lineNum">    5678 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; + &quot;, octl);</span></a>
<a name="5679"><span class="lineNum">    5679 </span>            :       /* coverity[var_deref_op] */</a>
<a name="5680"><span class="lineNum">    5680 </span><span class="lineNoCov">          0 :       form_float_constant(&amp;constant-&gt;variant.complex_value-&gt;imag,</span></a>
<a name="5681"><span class="lineNum">    5681 </span><span class="lineNoCov">          0 :                           con_type-&gt;variant.float_kind,</span></a>
<a name="5682"><span class="lineNum">    5682 </span>            :                           (an_expr_node_ptr)NULL,</a>
<a name="5683"><span class="lineNum">    5683 </span>            :                           octl);</a>
<a name="5684"><span class="lineNum">    5684 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="5685"><span class="lineNum">    5685 </span><span class="lineNoCov">          0 :       if (!octl-&gt;gen_compilable_code ||</span></a>
<a name="5686"><span class="lineNum">    5686 </span>            :           gcc_or_clang_is_generated_code_target) {</a>
<a name="5687"><span class="lineNum">    5687 </span>            :         /* GNU compilers can parse complex constants like 1.0+2.0i.  That</a>
<a name="5688"><span class="lineNum">    5688 </span>            :            form is also used in contexts that aren't actual code. */</a>
<a name="5689"><span class="lineNum">    5689 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;i&quot;, octl);</span></a>
<a name="5690"><span class="lineNum">    5690 </span>            :       } else</a>
<a name="5691"><span class="lineNum">    5691 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="5692"><span class="lineNum">    5692 </span>            :       /* Do not insert code here. */</a>
<a name="5693"><span class="lineNum">    5693 </span>            :       {</a>
<a name="5694"><span class="lineNum">    5694 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;*__I__&quot;, octl);</span></a>
<a name="5695"><span class="lineNum">    5695 </span>            :       }  /* if */</a>
<a name="5696"><span class="lineNum">    5696 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5697"><span class="lineNum">    5697 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5698"><span class="lineNum">    5698 </span>            : #endif /* C99_IL_EXTENSIONS_SUPPORTED */</a>
<a name="5699"><span class="lineNum">    5699 </span><span class="lineNoCov">          0 :     case ck_address:</span></a>
<a name="5700"><span class="lineNum">    5700 </span>            :       /* Address constant. */</a>
<a name="5701"><span class="lineNum">    5701 </span><span class="lineNoCov">          0 :       form_address_constant(constant, /*form_lvalue=*/FALSE, need_parens,</span></a>
<a name="5702"><span class="lineNum">    5702 </span>            :                             octl);</a>
<a name="5703"><span class="lineNum">    5703 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5704"><span class="lineNum">    5704 </span><span class="lineNoCov">          0 :     case ck_ptr_to_member:</span></a>
<a name="5705"><span class="lineNum">    5705 </span>            :       /* Pointer-to-member constant. */</a>
<a name="5706"><span class="lineNum">    5706 </span><span class="lineNoCov">          0 :       form_pm_constant(constant, /*minimal_casts=*/!octl-&gt;gen_compilable_code,</span></a>
<a name="5707"><span class="lineNum">    5707 </span>            :                        need_parens, octl);</a>
<a name="5708"><span class="lineNum">    5708 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5709"><span class="lineNum">    5709 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="5710"><span class="lineNum">    5710 </span><span class="lineNoCov">          0 :     case ck_label_difference:</span></a>
<a name="5711"><span class="lineNum">    5711 </span><span class="lineNoCov">          0 :       form_label_difference_constant(constant, need_parens, octl);</span></a>
<a name="5712"><span class="lineNum">    5712 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5713"><span class="lineNum">    5713 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="5714"><span class="lineNum">    5714 </span>            : #if DO_IL_LOWERING &amp;&amp; GENERATE_EH_TABLES &amp;&amp; !DO_FULL_PORTABLE_EH_LOWERING</a>
<a name="5715"><span class="lineNum">    5715 </span>            :     case ck_stack_offset:</a>
<a name="5716"><span class="lineNum">    5716 </span>            :       octl-&gt;output_str(&quot;&lt;stack-offset-of: &quot;, octl);</a>
<a name="5717"><span class="lineNum">    5717 </span>            :       form_name(&amp;constant-&gt;variant.stack_offset.variable-&gt;source_corresp,</a>
<a name="5718"><span class="lineNum">    5718 </span>            :                 iek_variable, octl);</a>
<a name="5719"><span class="lineNum">    5719 </span>            :       if (constant-&gt;variant.stack_offset.offset != 0) {</a>
<a name="5720"><span class="lineNum">    5720 </span>            :         octl-&gt;output_str(&quot;+&quot;, octl);</a>
<a name="5721"><span class="lineNum">    5721 </span>            :         form_unsigned_num(</a>
<a name="5722"><span class="lineNum">    5722 </span>            :                   (a_host_large_unsigned)constant-&gt;variant.stack_offset.offset,</a>
<a name="5723"><span class="lineNum">    5723 </span>            :                   octl);</a>
<a name="5724"><span class="lineNum">    5724 </span>            :       }  /* if */</a>
<a name="5725"><span class="lineNum">    5725 </span>            :       octl-&gt;output_str(&quot;&gt;&quot;, octl);</a>
<a name="5726"><span class="lineNum">    5726 </span>            :       break;</a>
<a name="5727"><span class="lineNum">    5727 </span>            : #endif /* DO_IL_LOWERING &amp;&amp; ... */</a>
<a name="5728"><span class="lineNum">    5728 </span><span class="lineNoCov">          0 :     case ck_dynamic_init:</span></a>
<a name="5729"><span class="lineNum">    5729 </span><span class="lineNoCov">          0 :       if (octl-&gt;gen_compilable_code &amp;&amp;</span></a>
<a name="5730"><span class="lineNum">    5730 </span><span class="lineNoCov">          0 :           constant-&gt;variant.dynamic_init-&gt;kind ==</span></a>
<a name="5731"><span class="lineNum">    5731 </span>            :                                          (a_dynamic_init_kind)dik_expression) {</a>
<a name="5732"><span class="lineNum">    5732 </span><span class="lineNoCov">          0 :         form_expression(constant-&gt;variant.dynamic_init-&gt;variant.expression,</span></a>
<a name="5733"><span class="lineNum">    5733 </span>            :                         octl);</a>
<a name="5734"><span class="lineNum">    5734 </span>            :       } else {</a>
<a name="5735"><span class="lineNum">    5735 </span><span class="lineNoCov">          0 :         form_dynamic_init_constant(constant, octl);</span></a>
<a name="5736"><span class="lineNum">    5736 </span>            :       }  /* if */</a>
<a name="5737"><span class="lineNum">    5737 </span>            :       break;</a>
<a name="5738"><span class="lineNum">    5738 </span><span class="lineNoCov">          0 :     case ck_aggregate:</span></a>
<a name="5739"><span class="lineNum">    5739 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;{&quot;, octl);</span></a>
<a name="5740"><span class="lineNum">    5740 </span><span class="lineNoCov">          0 :       { a_constant_ptr sub_con = constant-&gt;variant.aggregate.first_constant;</span></a>
<a name="5741"><span class="lineNum">    5741 </span><span class="lineNoCov">          0 :         for (; sub_con != NULL; sub_con = sub_con-&gt;next) {</span></a>
<a name="5742"><span class="lineNum">    5742 </span><span class="lineNoCov">          0 :           if (sub_con-&gt;implicit_aggr_element &amp;&amp;</span></a>
<a name="5743"><span class="lineNum">    5743 </span><span class="lineNoCov">          0 :               !octl-&gt;c_generating_back_end) {</span></a>
<a name="5744"><span class="lineNum">    5744 </span>            : #if DEBUG</a>
<a name="5745"><span class="lineNum">    5745 </span><span class="lineNoCov">          0 :             if (octl-&gt;debug_output) {</span></a>
<a name="5746"><span class="lineNum">    5746 </span>            :               /* Emit the constant (with an indication that it is implicit). */</a>
<a name="5747"><span class="lineNum">    5747 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;&lt;implicit element&gt; &quot;, octl);</span></a>
<a name="5748"><span class="lineNum">    5748 </span>            :             } else</a>
<a name="5749"><span class="lineNum">    5749 </span>            : #endif /* DEBUG */</a>
<a name="5750"><span class="lineNum">    5750 </span>            :             /* Do not insert code here. */</a>
<a name="5751"><span class="lineNum">    5751 </span>            :             {</a>
<a name="5752"><span class="lineNum">    5752 </span>            :               /* Don't render implicit elements unless the C-generating back</a>
<a name="5753"><span class="lineNum">    5753 </span>            :                  end has to compile them. */</a>
<a name="5754"><span class="lineNum">    5754 </span><span class="lineNoCov">          0 :               continue;</span></a>
<a name="5755"><span class="lineNum">    5755 </span>            :             }  /* if */</a>
<a name="5756"><span class="lineNum">    5756 </span>            :           }  /* if */</a>
<a name="5757"><span class="lineNum">    5757 </span><span class="lineNoCov">          0 :           form_constant(sub_con, /*need_parens=*/FALSE, octl);</span></a>
<a name="5758"><span class="lineNum">    5758 </span><span class="lineNoCov">          0 :           if (sub_con-&gt;next != NULL &amp;&amp;</span></a>
<a name="5759"><span class="lineNum">    5759 </span><span class="lineNoCov">          0 :               sub_con-&gt;kind != (a_constant_repr_kind)ck_designator) {</span></a>
<a name="5760"><span class="lineNum">    5760 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;, &quot;, octl);</span></a>
<a name="5761"><span class="lineNum">    5761 </span>            :           }  /* if */</a>
<a name="5762"><span class="lineNum">    5762 </span>            :         }  /* for */</a>
<a name="5763"><span class="lineNum">    5763 </span>            :       }</a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;}&quot;, octl);</span></a>
<a name="5765"><span class="lineNum">    5765 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5766"><span class="lineNum">    5766 </span><span class="lineNoCov">          0 :     case ck_init_repeat:</span></a>
<a name="5767"><span class="lineNum">    5767 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code);</span></a>
<a name="5768"><span class="lineNum">    5768 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&lt;&quot;, octl);</span></a>
<a name="5769"><span class="lineNum">    5769 </span><span class="lineNoCov">          0 :       form_unsigned_num(</span></a>
<a name="5770"><span class="lineNum">    5770 </span><span class="lineNoCov">          0 :              (a_host_large_unsigned)constant-&gt;variant.init_repeat.count, octl);</span></a>
<a name="5771"><span class="lineNum">    5771 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot; repetitions of &quot;, octl);</span></a>
<a name="5772"><span class="lineNum">    5772 </span><span class="lineNoCov">          0 :       form_constant(constant-&gt;variant.init_repeat.constant,</span></a>
<a name="5773"><span class="lineNum">    5773 </span>            :                     /*need_parens=*/FALSE, octl);</a>
<a name="5774"><span class="lineNum">    5774 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;&gt;&quot;, octl);</span></a>
<a name="5775"><span class="lineNum">    5775 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5776"><span class="lineNum">    5776 </span><span class="lineNoCov">          0 :     case ck_template_param:</span></a>
<a name="5777"><span class="lineNum">    5777 </span><span class="lineNoCov">          0 :       check_assertion(!octl-&gt;gen_compilable_code ||</span></a>
<a name="5778"><span class="lineNum">    5778 </span>            :                       prototype_instantiations_in_il);</a>
<a name="5779"><span class="lineNum">    5779 </span><span class="lineNoCov">          0 :       switch (constant-&gt;variant.template_param.kind) {</span></a>
<a name="5780"><span class="lineNum">    5780 </span><span class="lineNoCov">          0 :         case tpck_unknown_function:</span></a>
<a name="5781"><span class="lineNum">    5781 </span>            :         case tpck_template_ref:</a>
<a name="5782"><span class="lineNum">    5782 </span>            :           /* Address of an unknown function, or of an unknown function template</a>
<a name="5783"><span class="lineNum">    5783 </span>            :              with an explicit template argument list. */</a>
<a name="5784"><span class="lineNum">    5784 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5785"><span class="lineNum">    5785 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="5786"><span class="lineNum">    5786 </span><span class="lineNoCov">          0 :           form_unknown_function_constant(constant, octl);</span></a>
<a name="5787"><span class="lineNum">    5787 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5788"><span class="lineNum">    5788 </span>            :           break;</a>
<a name="5789"><span class="lineNum">    5789 </span><span class="lineNoCov">          0 :         case tpck_param:</span></a>
<a name="5790"><span class="lineNum">    5790 </span>            :           {</a>
<a name="5791"><span class="lineNum">    5791 </span><span class="lineNoCov">          0 :             a_source_correspondence_ptr scp = &amp;constant-&gt;source_corresp;</span></a>
<a name="5792"><span class="lineNum">    5792 </span><span class="lineNoCov">          0 :             an_il_entry_kind            scp_kind = iek_constant;</span></a>
<a name="5793"><span class="lineNum">    5793 </span><span class="lineNoCov">          0 :             a_source_correspondence_ptr new_scp;</span></a>
<a name="5794"><span class="lineNum">    5794 </span>            :             /* See whether the template parameter name is remapped in the</a>
<a name="5795"><span class="lineNum">    5795 </span>            :                current context. */</a>
<a name="5796"><span class="lineNum">    5796 </span><span class="lineNoCov">          0 :             new_scp = source_corresp_for_template_param(</span></a>
<a name="5797"><span class="lineNum">    5797 </span><span class="lineNoCov">          0 :                        &amp;constant-&gt;variant.template_param.variant.coordinates);</span></a>
<a name="5798"><span class="lineNum">    5798 </span><span class="lineNoCov">          0 :             if (new_scp != NULL) {</span></a>
<a name="5799"><span class="lineNum">    5799 </span><span class="lineNoCov">          0 :               scp = new_scp;</span></a>
<a name="5800"><span class="lineNum">    5800 </span><span class="lineNoCov">          0 :               scp_kind = iek_template_parameter;</span></a>
<a name="5801"><span class="lineNum">    5801 </span>            :             }  /* if */</a>
<a name="5802"><span class="lineNum">    5802 </span><span class="lineNoCov">          0 :             form_name(scp, scp_kind, octl);</span></a>
<a name="5803"><span class="lineNum">    5803 </span>            :           }</a>
<a name="5804"><span class="lineNum">    5804 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="5805"><span class="lineNum">    5805 </span><span class="lineNoCov">          0 :         case tpck_member:</span></a>
<a name="5806"><span class="lineNum">    5806 </span>            :           {</a>
<a name="5807"><span class="lineNum">    5807 </span><span class="lineNoCov">          0 :             a_source_correspondence_ptr scp = &amp;constant-&gt;source_corresp;</span></a>
<a name="5808"><span class="lineNum">    5808 </span><span class="lineNoCov">          0 :             if (scp-&gt;member_of_unknown_base &amp;&amp;</span></a>
<a name="5809"><span class="lineNum">    5809 </span>            :                 !scp-&gt;qualified_unknown_base_member) {</a>
<a name="5810"><span class="lineNum">    5810 </span>            :               /* We're pretending that we found the member in a dependent</a>
<a name="5811"><span class="lineNum">    5811 </span>            :                  base class and the original form of reference was</a>
<a name="5812"><span class="lineNum">    5812 </span>            :                  unqualified. */</a>
<a name="5813"><span class="lineNum">    5813 </span><span class="lineNoCov">          0 :               form_unqualified_name(scp, (an_il_entry_kind)iek_constant, octl);</span></a>
<a name="5814"><span class="lineNum">    5814 </span>            :             } else {</a>
<a name="5815"><span class="lineNum">    5815 </span><span class="lineNoCov">          0 :               form_name(scp, (an_il_entry_kind)iek_constant, octl);</span></a>
<a name="5816"><span class="lineNum">    5816 </span>            :             }  /* if */</a>
<a name="5817"><span class="lineNum">    5817 </span>            :           }</a>
<a name="5818"><span class="lineNum">    5818 </span>            :           break;</a>
<a name="5819"><span class="lineNum">    5819 </span><span class="lineNoCov">          0 :         case tpck_expression:</span></a>
<a name="5820"><span class="lineNum">    5820 </span><span class="lineNoCov">          0 :           if (constant-&gt;type-&gt;kind == (a_constant_repr_kind)tk_integer &amp;&amp;</span></a>
<a name="5821"><span class="lineNum">    5821 </span><span class="lineNoCov">          0 :               constant-&gt;type-&gt;variant.integer.enum_type &amp;&amp;</span></a>
<a name="5822"><span class="lineNum">    5822 </span><span class="lineNoCov">          0 :               has_name(constant) &amp;&amp;</span></a>
<a name="5823"><span class="lineNum">    5823 </span><span class="lineNoCov">          0 :               !octl-&gt;suppress_name_in_template_cast_enum_const) {</span></a>
<a name="5824"><span class="lineNum">    5824 </span>            :             /* This is an alias for a named enumerator -- just put out the</a>
<a name="5825"><span class="lineNum">    5825 </span>            :                name. */</a>
<a name="5826"><span class="lineNum">    5826 </span><span class="lineNoCov">          0 :             form_name(&amp;constant-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="5827"><span class="lineNum">    5827 </span><span class="lineNoCov">          0 :           } else if (octl-&gt;output_expression != NULL) {</span></a>
<a name="5828"><span class="lineNum">    5828 </span>            :             /* Do not add parentheses gratuitously. */</a>
<a name="5829"><span class="lineNum">    5829 </span><span class="lineNoCov">          0 :             octl-&gt;output_expression(expr_node_from_tpck_expression(constant),</span></a>
<a name="5830"><span class="lineNum">    5830 </span>            :                                     !need_parens);</a>
<a name="5831"><span class="lineNum">    5831 </span>            :           } else {</a>
<a name="5832"><span class="lineNum">    5832 </span><span class="lineNoCov">          0 :             form_expression(expr_node_from_tpck_expression(constant), octl);</span></a>
<a name="5833"><span class="lineNum">    5833 </span>            :           }  /* if */</a>
<a name="5834"><span class="lineNum">    5834 </span>            :           break;</a>
<a name="5835"><span class="lineNum">    5835 </span><span class="lineNoCov">          0 :         case tpck_address:</span></a>
<a name="5836"><span class="lineNum">    5836 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5837"><span class="lineNum">    5837 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="5838"><span class="lineNum">    5838 </span><span class="lineNoCov">          0 :           form_constant(constant-&gt;variant.template_param.variant.constant,</span></a>
<a name="5839"><span class="lineNum">    5839 </span>            :                         /*need_parens=*/FALSE, octl);</a>
<a name="5840"><span class="lineNum">    5840 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5841"><span class="lineNum">    5841 </span>            :           break;</a>
<a name="5842"><span class="lineNum">    5842 </span><span class="lineNoCov">          0 :         case tpck_sizeof:</span></a>
<a name="5843"><span class="lineNum">    5843 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;sizeof(&quot;, octl);</span></a>
<a name="5844"><span class="lineNum">    5844 </span><span class="lineNoCov">          0 :           goto do_sizeof_cases;</span></a>
<a name="5845"><span class="lineNum">    5845 </span><span class="lineNoCov">          0 :         case tpck_alignof:</span></a>
<a name="5846"><span class="lineNum">    5846 </span><span class="lineNoCov">          0 :           if (use_microsoft_form() || use_sun_form()) {</span></a>
<a name="5847"><span class="lineNum">    5847 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;__alignof(&quot;, octl);</span></a>
<a name="5848"><span class="lineNum">    5848 </span><span class="lineNoCov">          0 :           } else if (use_gnu_form()) {</span></a>
<a name="5849"><span class="lineNum">    5849 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;__alignof__(&quot;, octl);</span></a>
<a name="5850"><span class="lineNum">    5850 </span><span class="lineNoCov">          0 :           } else if (constant-&gt;variant.template_param</span></a>
<a name="5851"><span class="lineNum">    5851 </span>            :                               .variant.templ_sizeof.is_std_alignof) {</a>
<a name="5852"><span class="lineNum">    5852 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;alignof(&quot;, octl);</span></a>
<a name="5853"><span class="lineNum">    5853 </span>            :           } else {</a>
<a name="5854"><span class="lineNum">    5854 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;__ALIGNOF__(&quot;, octl);</span></a>
<a name="5855"><span class="lineNum">    5855 </span>            :           }  /* if */</a>
<a name="5856"><span class="lineNum">    5856 </span><span class="lineNoCov">          0 :           goto do_sizeof_cases;</span></a>
<a name="5857"><span class="lineNum">    5857 </span><span class="lineNoCov">          0 :         case tpck_noexcept:</span></a>
<a name="5858"><span class="lineNum">    5858 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;noexcept(&quot;, octl);</span></a>
<a name="5859"><span class="lineNum">    5859 </span><span class="lineNoCov">          0 : do_sizeof_cases:</span></a>
<a name="5860"><span class="lineNum">    5860 </span><span class="lineNoCov">          0 :           { an_expr_node_ptr  expr = generic_sizeof_arg_expr(constant);</span></a>
<a name="5861"><span class="lineNum">    5861 </span><span class="lineNoCov">          0 :             if (expr != NULL) {</span></a>
<a name="5862"><span class="lineNum">    5862 </span><span class="lineNoCov">          0 :               form_expression(expr, octl);</span></a>
<a name="5863"><span class="lineNum">    5863 </span>            :             } else {</a>
<a name="5864"><span class="lineNum">    5864 </span><span class="lineNoCov">          0 :               form_type(</span></a>
<a name="5865"><span class="lineNum">    5865 </span>            :                     constant-&gt;variant.template_param.variant.templ_sizeof.type,</a>
<a name="5866"><span class="lineNum">    5866 </span>            :                     octl);</a>
<a name="5867"><span class="lineNum">    5867 </span>            :             }  /* if */</a>
<a name="5868"><span class="lineNum">    5868 </span><span class="lineNoCov">          0 :             octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5869"><span class="lineNum">    5869 </span>            :           }</a>
<a name="5870"><span class="lineNum">    5870 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="5871"><span class="lineNum">    5871 </span><span class="lineNoCov">          0 :         case tpck_uuidof:</span></a>
<a name="5872"><span class="lineNum">    5872 </span>            :           /* The constant represents the address of the __uuidof, so add</a>
<a name="5873"><span class="lineNum">    5873 </span>            :              a &quot;&amp;&quot;. */</a>
<a name="5874"><span class="lineNum">    5874 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5875"><span class="lineNum">    5875 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="5876"><span class="lineNum">    5876 </span><span class="lineNoCov">          0 :           form_uuidof_reference(constant, octl);</span></a>
<a name="5877"><span class="lineNum">    5877 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5878"><span class="lineNum">    5878 </span>            :           break;</a>
<a name="5879"><span class="lineNum">    5879 </span><span class="lineNoCov">          0 :         case tpck_typeid:</span></a>
<a name="5880"><span class="lineNum">    5880 </span>            :           /* The constant represents the address of a typeid result, so add</a>
<a name="5881"><span class="lineNum">    5881 </span>            :              a &quot;&amp;&quot;. */</a>
<a name="5882"><span class="lineNum">    5882 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5883"><span class="lineNum">    5883 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;&amp;&quot;, octl);</span></a>
<a name="5884"><span class="lineNum">    5884 </span><span class="lineNoCov">          0 :           form_typeid_reference(constant, octl);</span></a>
<a name="5885"><span class="lineNum">    5885 </span><span class="lineNoCov">          0 :           if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5886"><span class="lineNum">    5886 </span>            :           break;</a>
<a name="5887"><span class="lineNum">    5887 </span><span class="lineNoCov">          0 :         case tpck_integer_pack:</span></a>
<a name="5888"><span class="lineNum">    5888 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;__integer_pack(&quot;, octl);</span></a>
<a name="5889"><span class="lineNum">    5889 </span><span class="lineNoCov">          0 :           form_constant(constant-&gt;variant.template_param.variant.bound,</span></a>
<a name="5890"><span class="lineNum">    5890 </span>            :                         /*need_parens=*/FALSE, octl);</a>
<a name="5891"><span class="lineNum">    5891 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;)...&quot;, octl);</span></a>
<a name="5892"><span class="lineNum">    5892 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="5893"><span class="lineNum">    5893 </span><span class="lineNoCov">          0 :         case tpck_destructor:</span></a>
<a name="5894"><span class="lineNum">    5894 </span><span class="lineNoCov">          0 :           { a_type_ptr dtor_type =</span></a>
<a name="5895"><span class="lineNum">    5895 </span>            :                      constant-&gt;variant.template_param.variant.destructor.type;</a>
<a name="5896"><span class="lineNum">    5896 </span><span class="lineNoCov">          0 :             if (need_parens) octl-&gt;output_str(&quot;(&quot;, octl);</span></a>
<a name="5897"><span class="lineNum">    5897 </span><span class="lineNoCov">          0 :             if (has_name(constant) &amp;&amp;</span></a>
<a name="5898"><span class="lineNum">    5898 </span><span class="lineNoCov">          0 :                 constant-&gt;source_corresp.name[0] == '~' &amp;&amp;</span></a>
<a name="5899"><span class="lineNum">    5899 </span><span class="lineNoCov">          0 :                 constant-&gt;source_corresp.name[1] != '&lt;') {</span></a>
<a name="5900"><span class="lineNum">    5900 </span>            :               /* The constant's name reflects the way it actually appeared</a>
<a name="5901"><span class="lineNum">    5901 </span>            :                  in the original source code, which might involve typedefs</a>
<a name="5902"><span class="lineNum">    5902 </span>            :                  or dependent names that should be preserved, rather than</a>
<a name="5903"><span class="lineNum">    5903 </span>            :                  using resolved types.  (The check to exclude names</a>
<a name="5904"><span class="lineNum">    5904 </span>            :                  beginning with &quot;~&lt;&quot; is so that destructors involving type</a>
<a name="5905"><span class="lineNum">    5905 </span>            :                  operators like decltype will use form_type.) */</a>
<a name="5906"><span class="lineNum">    5906 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(constant-&gt;source_corresp.name, octl);</span></a>
<a name="5907"><span class="lineNum">    5907 </span>            :             } else {</a>
<a name="5908"><span class="lineNum">    5908 </span><span class="lineNoCov">          0 :               octl-&gt;output_str(&quot;~&quot;, octl);</span></a>
<a name="5909"><span class="lineNum">    5909 </span><span class="lineNoCov">          0 :               if (has_name(dtor_type) &amp;&amp;</span></a>
<a name="5910"><span class="lineNum">    5910 </span>            :                   constant</a>
<a name="5911"><span class="lineNum">    5911 </span><span class="lineNoCov">          0 :                     -&gt;variant.template_param.variant.destructor.unqualified) {</span></a>
<a name="5912"><span class="lineNum">    5912 </span>            :                 /* Render the type with an unqualified name (form_type has</a>
<a name="5913"><span class="lineNum">    5913 </span>            :                    insufficient information to determine this, so we handle</a>
<a name="5914"><span class="lineNum">    5914 </span>            :                    that case at this level).  Note that an unqualified</a>
<a name="5915"><span class="lineNum">    5915 </span>            :                    destructor invocation like p-&gt;~decltype(...) should</a>
<a name="5916"><span class="lineNum">    5916 </span>            :                    still go through form_type (hence the &quot;has_name&quot; test</a>
<a name="5917"><span class="lineNum">    5917 </span>            :                    above). */</a>
<a name="5918"><span class="lineNum">    5918 </span><span class="lineNoCov">          0 :                 a_boolean  saved_suppress_template_args =</span></a>
<a name="5919"><span class="lineNum">    5919 </span><span class="lineNoCov">          0 :                                                   octl-&gt;suppress_template_args;</span></a>
<a name="5920"><span class="lineNum">    5920 </span><span class="lineNoCov">          0 :                 if (is_immediate_class_type(dtor_type) &amp;&amp;</span></a>
<a name="5921"><span class="lineNum">    5921 </span>            :                     dtor_type-&gt;</a>
<a name="5922"><span class="lineNum">    5922 </span>            :                        variant.class_struct_union.is_prototype_instantiation) {</a>
<a name="5923"><span class="lineNum">    5923 </span>            :                   /* A destructor prototype instantiation can only appear</a>
<a name="5924"><span class="lineNum">    5924 </span>            :                      in the prototype instantiation of its parent, so no</a>
<a name="5925"><span class="lineNum">    5925 </span>            :                      template argument list is needed (and, if a template</a>
<a name="5926"><span class="lineNum">    5926 </span>            :                      parameter is unnamed, couldn't be put out in any</a>
<a name="5927"><span class="lineNum">    5927 </span>            :                      case). */</a>
<a name="5928"><span class="lineNum">    5928 </span><span class="lineNoCov">          0 :                   octl-&gt;suppress_template_args = TRUE;</span></a>
<a name="5929"><span class="lineNum">    5929 </span>            :                 }  /* if */</a>
<a name="5930"><span class="lineNum">    5930 </span><span class="lineNoCov">          0 :                 form_unqualified_name(&amp;dtor_type-&gt;source_corresp, iek_type,</span></a>
<a name="5931"><span class="lineNum">    5931 </span>            :                                       octl);</a>
<a name="5932"><span class="lineNum">    5932 </span><span class="lineNoCov">          0 :                 octl-&gt;suppress_template_args = saved_suppress_template_args;</span></a>
<a name="5933"><span class="lineNum">    5933 </span>            :               } else {</a>
<a name="5934"><span class="lineNum">    5934 </span><span class="lineNoCov">          0 :                 form_type(dtor_type, octl);</span></a>
<a name="5935"><span class="lineNum">    5935 </span>            :               }  /* if */</a>
<a name="5936"><span class="lineNum">    5936 </span>            :             }  /* if */</a>
<a name="5937"><span class="lineNum">    5937 </span><span class="lineNoCov">          0 :             if (need_parens) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5938"><span class="lineNum">    5938 </span>            :           }</a>
<a name="5939"><span class="lineNum">    5939 </span>            :           break;</a>
<a name="5940"><span class="lineNum">    5940 </span><span class="lineNoCov">          0 :         default:</span></a>
<a name="5941"><span class="lineNum">    5941 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;**BAD-TEMPLATE-PARAM-CONSTANT-KIND**&quot;, octl);</span></a>
<a name="5942"><span class="lineNum">    5942 </span>            :       }  /* switch */</a>
<a name="5943"><span class="lineNum">    5943 </span>            :       break;</a>
<a name="5944"><span class="lineNum">    5944 </span><span class="lineNoCov">          0 :     case ck_designator:</span></a>
<a name="5945"><span class="lineNum">    5945 </span><span class="lineNoCov">          0 :       if (constant-&gt;variant.designator.is_field_designator) {</span></a>
<a name="5946"><span class="lineNum">    5946 </span><span class="lineNoCov">          0 :         a_const_char  *name;</span></a>
<a name="5947"><span class="lineNum">    5947 </span><span class="lineNoCov">          0 :         if (constant-&gt;variant.designator.is_generic) {</span></a>
<a name="5948"><span class="lineNum">    5948 </span><span class="lineNoCov">          0 :           name = constant-&gt;variant.designator.variant.field_name;</span></a>
<a name="5949"><span class="lineNum">    5949 </span>            :         } else {</a>
<a name="5950"><span class="lineNum">    5950 </span><span class="lineNoCov">          0 :           name = unmangled_name_of(&amp;constant-&gt;variant.designator.variant.field</span></a>
<a name="5951"><span class="lineNum">    5951 </span>            :                                             -&gt;source_corresp);</a>
<a name="5952"><span class="lineNum">    5952 </span>            :         }  /* if */</a>
<a name="5953"><span class="lineNum">    5953 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="5954"><span class="lineNum">    5954 </span><span class="lineNoCov">          0 :         if (il_header.source_language == sl_Cplusplus &amp;&amp;</span></a>
<a name="5955"><span class="lineNum">    5955 </span>            :             gcc_or_clang_is_generated_code_target) {</a>
<a name="5956"><span class="lineNum">    5956 </span>            :           /* g++ does not accept the C99 syntax for designated initializers</a>
<a name="5957"><span class="lineNum">    5957 </span>            :              but does accept a nonstandard variant:</a>
<a name="5958"><span class="lineNum">    5958 </span>            :                  struct S s = { m: 0 }; */</a>
<a name="5959"><span class="lineNum">    5959 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(name, octl);</span></a>
<a name="5960"><span class="lineNum">    5960 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;: &quot;, octl);</span></a>
<a name="5961"><span class="lineNum">    5961 </span>            :         } else</a>
<a name="5962"><span class="lineNum">    5962 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="5963"><span class="lineNum">    5963 </span>            :         /* Do not insert code here. */</a>
<a name="5964"><span class="lineNum">    5964 </span>            :         {</a>
<a name="5965"><span class="lineNum">    5965 </span>            :           /* Use the C99 designated initializer syntax. */</a>
<a name="5966"><span class="lineNum">    5966 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot;.&quot;, octl);</span></a>
<a name="5967"><span class="lineNum">    5967 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(name, octl);</span></a>
<a name="5968"><span class="lineNum">    5968 </span><span class="lineNoCov">          0 :           octl-&gt;output_str(&quot; = &quot;, octl);</span></a>
<a name="5969"><span class="lineNum">    5969 </span>            :         }  /* if */</a>
<a name="5970"><span class="lineNum">    5970 </span>            :       } else {</a>
<a name="5971"><span class="lineNum">    5971 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;[&quot;, octl);</span></a>
<a name="5972"><span class="lineNum">    5972 </span><span class="lineNoCov">          0 :         if (constant-&gt;variant.designator.is_generic) {</span></a>
<a name="5973"><span class="lineNum">    5973 </span><span class="lineNoCov">          0 :           form_constant(constant-&gt;variant.designator.variant.subscript,</span></a>
<a name="5974"><span class="lineNum">    5974 </span>            :                         /*need_parens=*/FALSE, octl);</a>
<a name="5975"><span class="lineNum">    5975 </span>            :         } else {</a>
<a name="5976"><span class="lineNum">    5976 </span><span class="lineNoCov">          0 :           form_unsigned_num(constant-&gt;variant.designator.variant.array_element,</span></a>
<a name="5977"><span class="lineNum">    5977 </span>            :                             octl);</a>
<a name="5978"><span class="lineNum">    5978 </span>            :         }  /* if */</a>
<a name="5979"><span class="lineNum">    5979 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;] = &quot;, octl);</span></a>
<a name="5980"><span class="lineNum">    5980 </span>            :       } /* if */</a>
<a name="5981"><span class="lineNum">    5981 </span>            :       break;</a>
<a name="5982"><span class="lineNum">    5982 </span><span class="lineNoCov">          0 :     case ck_void:</span></a>
<a name="5983"><span class="lineNum">    5983 </span><span class="lineNoCov">          0 :       octl-&gt;output_str(&quot;((void)0)&quot;, octl);</span></a>
<a name="5984"><span class="lineNum">    5984 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="5985"><span class="lineNum">    5985 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="5986"><span class="lineNum">    5986 </span>            : #if DEBUG</a>
<a name="5987"><span class="lineNum">    5987 </span><span class="lineNoCov">          0 :       if (octl-&gt;debug_output) {</span></a>
<a name="5988"><span class="lineNum">    5988 </span><span class="lineNoCov">          0 :         octl-&gt;output_str(&quot;**BAD-CONSTANT-KIND**&quot;, octl);</span></a>
<a name="5989"><span class="lineNum">    5989 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="5990"><span class="lineNum">    5990 </span>            :       }  /* if */</a>
<a name="5991"><span class="lineNum">    5991 </span>            : #endif /* DEBUG */</a>
<a name="5992"><span class="lineNum">    5992 </span><span class="lineNoCov">          0 :       unexpected_condition_str(&quot;form_constant: bad constant kind&quot;);</span></a>
<a name="5993"><span class="lineNum">    5993 </span>            :   }  /* switch */</a>
<a name="5994"><span class="lineNum">    5994 </span><span class="lineCov">       5596 :   if (need_reinterpret_cast) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5995"><span class="lineNum">    5995 </span><span class="lineCov">       5596 :   if (need_cast_close_paren) octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="5996"><span class="lineNum">    5996 </span><span class="lineCov">       5596 : done:;</span></a>
<a name="5997"><span class="lineNum">    5997 </span><span class="lineCov">       5596 : }  /* form_constant */</span></a>
<a name="5998"><span class="lineNum">    5998 </span>            : </a>
<a name="5999"><span class="lineNum">    5999 </span>            : </a>
<a name="6000"><span class="lineNum">    6000 </span><span class="lineNoCov">          0 : void form_lvalue_address_constant(</span></a>
<a name="6001"><span class="lineNum">    6001 </span>            :                           a_constant_ptr                        constant,</a>
<a name="6002"><span class="lineNum">    6002 </span>            :                           a_boolean                             need_parens,</a>
<a name="6003"><span class="lineNum">    6003 </span>            :                           an_il_to_str_output_control_block_ptr octl)</a>
<a name="6004"><span class="lineNum">    6004 </span>            : /*</a>
<a name="6005"><span class="lineNum">    6005 </span>            : Output the indicated constant.  It's the initial value of a reference,</a>
<a name="6006"><span class="lineNum">    6006 </span>            : so remove one level of indirection (basically, the constant is an address).</a>
<a name="6007"><span class="lineNum">    6007 </span>            : If need_parens is TRUE, parentheses are placed around the constant if</a>
<a name="6008"><span class="lineNum">    6008 </span>            : there's any possibility of precedence confusion.  Do the output in the</a>
<a name="6009"><span class="lineNum">    6009 </span>            : way described by octl.</a>
<a name="6010"><span class="lineNum">    6010 </span>            : */</a>
<a name="6011"><span class="lineNum">    6011 </span>            : {</a>
<a name="6012"><span class="lineNum">    6012 </span><span class="lineNoCov">          0 :   a_type_ptr  object_type, element_type;</span></a>
<a name="6013"><span class="lineNum">    6013 </span><span class="lineNoCov">          0 :   if (constant-&gt;kind == (a_constant_repr_kind)ck_address &amp;&amp;</span></a>
<a name="6014"><span class="lineNum">    6014 </span>            :       /* Suppress this special processing on something like *&quot;abcd&quot;, because</a>
<a name="6015"><span class="lineNum">    6015 </span>            :          gcc 2.95.2 issues a warning on storing into &quot;abcd&quot;[0] but not on</a>
<a name="6016"><span class="lineNum">    6016 </span>            :          storing into *&quot;abcd&quot;.  The other form is correct; it's avoided</a>
<a name="6017"><span class="lineNum">    6017 </span>            :          only because it draws this warning in one form and not in the</a>
<a name="6018"><span class="lineNum">    6018 </span>            :          other.  (The issue is differences in test suite runs, not</a>
<a name="6019"><span class="lineNum">    6019 </span>            :          the warning per se.) */</a>
<a name="6020"><span class="lineNum">    6020 </span><span class="lineNoCov">          0 :       !(constant-&gt;implicit_cast &amp;&amp;</span></a>
<a name="6021"><span class="lineNum">    6021 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.kind == (an_address_base_kind)abk_constant &amp;&amp;</span></a>
<a name="6022"><span class="lineNum">    6022 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.variant.constant-&gt;kind ==</span></a>
<a name="6023"><span class="lineNum">    6023 </span><span class="lineNoCov">          0 :                                              (a_constant_repr_kind)ck_string &amp;&amp;</span></a>
<a name="6024"><span class="lineNum">    6024 </span><span class="lineNoCov">          0 :         constant-&gt;variant.address.offset == 0 &amp;&amp;</span></a>
<a name="6025"><span class="lineNum">    6025 </span><span class="lineNoCov">          0 :         is_pointer_type(constant-&gt;type) &amp;&amp;</span></a>
<a name="6026"><span class="lineNum">    6026 </span><span class="lineNoCov">          0 :         (object_type = type_pointed_to(constant-&gt;type),</span></a>
<a name="6027"><span class="lineNum">    6027 </span><span class="lineNoCov">          0 :          element_type = array_element_type(</span></a>
<a name="6028"><span class="lineNum">    6028 </span><span class="lineNoCov">          0 :                             constant-&gt;variant.address.variant.constant-&gt;type),</span></a>
<a name="6029"><span class="lineNum">    6029 </span><span class="lineNoCov">          0 :          standalone_identical_types(object_type, element_type)))) {</span></a>
<a name="6030"><span class="lineNum">    6030 </span>            :     /* An address constant (the usual case).  Drop one level of &quot;&amp;&quot;. */</a>
<a name="6031"><span class="lineNum">    6031 </span><span class="lineNoCov">          0 :     form_address_constant(constant, /*form_lvalue=*/TRUE, need_parens, octl);</span></a>
<a name="6032"><span class="lineNum">    6032 </span><span class="lineNoCov">          0 :   } else if (constant-&gt;kind == (a_constant_repr_kind)ck_template_param &amp;&amp;</span></a>
<a name="6033"><span class="lineNum">    6033 </span><span class="lineNoCov">          0 :              constant-&gt;variant.template_param.kind ==</span></a>
<a name="6034"><span class="lineNum">    6034 </span>            :                                   (a_template_param_constant_kind)tpck_param) {</a>
<a name="6035"><span class="lineNum">    6035 </span>            :     /* This is a template parameter list in a prototype instantiation.</a>
<a name="6036"><span class="lineNum">    6036 </span>            :        The parameter has a reference type, so no adjustment is needed. */</a>
<a name="6037"><span class="lineNum">    6037 </span><span class="lineNoCov">          0 :     form_name(&amp;constant-&gt;source_corresp, iek_constant, octl);</span></a>
<a name="6038"><span class="lineNum">    6038 </span>            :   } else {</a>
<a name="6039"><span class="lineNum">    6039 </span>            :     /* For other cases, e.g.,</a>
<a name="6040"><span class="lineNum">    6040 </span>            :          int &amp;r = *(int *)5;</a>
<a name="6041"><span class="lineNum">    6041 </span>            :        just display the constant. */</a>
<a name="6042"><span class="lineNum">    6042 </span><span class="lineNoCov">          0 :     form_constant(constant, need_parens, octl);</span></a>
<a name="6043"><span class="lineNum">    6043 </span>            :   }  /* if */</a>
<a name="6044"><span class="lineNum">    6044 </span><span class="lineNoCov">          0 : }  /* form_lvalue_address_constant */</span></a>
<a name="6045"><span class="lineNum">    6045 </span>            : </a>
<a name="6046"><span class="lineNum">    6046 </span>            : #if GNU_EXTENSIONS_ALLOWED</a>
<a name="6047"><span class="lineNum">    6047 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="6048"><span class="lineNum">    6048 </span>            : </a>
<a name="6049"><span class="lineNum">    6049 </span>            : static void form_simple_attribute(</a>
<a name="6050"><span class="lineNum">    6050 </span>            :                    a_const_char                           *attribute_name,</a>
<a name="6051"><span class="lineNum">    6051 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6052"><span class="lineNum">    6052 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6053"><span class="lineNum">    6053 </span>            : /*</a>
<a name="6054"><span class="lineNum">    6054 </span>            : Output a simple GNU attribute described by attribute_name in the way</a>
<a name="6055"><span class="lineNum">    6055 </span>            : described by octl.  If *need_leading_space is TRUE, precede the attribute</a>
<a name="6056"><span class="lineNum">    6056 </span>            : with a leading space.  *need_leading_space is set to TRUE in all cases,</a>
<a name="6057"><span class="lineNum">    6057 </span>            : to indicate that a space will be needed after the attribute.</a>
<a name="6058"><span class="lineNum">    6058 </span>            : */</a>
<a name="6059"><span class="lineNum">    6059 </span>            : {</a>
<a name="6060"><span class="lineNum">    6060 </span>            :   if (*need_leading_space) {</a>
<a name="6061"><span class="lineNum">    6061 </span>            :     octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="6062"><span class="lineNum">    6062 </span>            :   }  /* if */</a>
<a name="6063"><span class="lineNum">    6063 </span>            :   octl-&gt;output_str(&quot;__attribute__((&quot;, octl);</a>
<a name="6064"><span class="lineNum">    6064 </span>            :   octl-&gt;output_str(attribute_name, octl);</a>
<a name="6065"><span class="lineNum">    6065 </span>            :   octl-&gt;output_str(&quot;))&quot;, octl);</a>
<a name="6066"><span class="lineNum">    6066 </span>            :   *need_leading_space = TRUE;</a>
<a name="6067"><span class="lineNum">    6067 </span>            : }  /* form_simple_attribute */</a>
<a name="6068"><span class="lineNum">    6068 </span>            :                                   </a>
<a name="6069"><span class="lineNum">    6069 </span>            : </a>
<a name="6070"><span class="lineNum">    6070 </span>            : static void form_string_argument_attribute(</a>
<a name="6071"><span class="lineNum">    6071 </span>            :                    a_const_char                           *attribute_name,</a>
<a name="6072"><span class="lineNum">    6072 </span>            :                    a_const_char                           *argument,</a>
<a name="6073"><span class="lineNum">    6073 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6074"><span class="lineNum">    6074 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6075"><span class="lineNum">    6075 </span>            : /*</a>
<a name="6076"><span class="lineNum">    6076 </span>            : Output an attribute that takes a string as an argument.  The attribute_name</a>
<a name="6077"><span class="lineNum">    6077 </span>            : is assumed to have no characters that require escapes, but the argument might</a>
<a name="6078"><span class="lineNum">    6078 </span>            : have characters like &quot;\n&quot; or &quot;\t&quot; that need to be handled specially.</a>
<a name="6079"><span class="lineNum">    6079 </span>            : If *need_leading_space is TRUE, precede the attribute with a leading space.</a>
<a name="6080"><span class="lineNum">    6080 </span>            : *need_leading_space is set to TRUE in all cases, to indicate that a</a>
<a name="6081"><span class="lineNum">    6081 </span>            : space will be needed after the attribute.  Do the output in the way</a>
<a name="6082"><span class="lineNum">    6082 </span>            : described by octl.</a>
<a name="6083"><span class="lineNum">    6083 </span>            : */</a>
<a name="6084"><span class="lineNum">    6084 </span>            : {</a>
<a name="6085"><span class="lineNum">    6085 </span>            :   a_const_char *c;</a>
<a name="6086"><span class="lineNum">    6086 </span>            : </a>
<a name="6087"><span class="lineNum">    6087 </span>            :   if (*need_leading_space) {</a>
<a name="6088"><span class="lineNum">    6088 </span>            :     octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="6089"><span class="lineNum">    6089 </span>            :   }  /* if */</a>
<a name="6090"><span class="lineNum">    6090 </span>            :   octl-&gt;output_str(&quot;__attribute__((&quot;, octl);</a>
<a name="6091"><span class="lineNum">    6091 </span>            :   octl-&gt;output_str(attribute_name, octl);</a>
<a name="6092"><span class="lineNum">    6092 </span>            :   octl-&gt;output_str(&quot;(&quot;, octl);</a>
<a name="6093"><span class="lineNum">    6093 </span>            :   output_partial_token_str(&quot;\&quot;&quot;, octl);</a>
<a name="6094"><span class="lineNum">    6094 </span>            :   for (c = argument; *c != '\0'; c++) {</a>
<a name="6095"><span class="lineNum">    6095 </span>            :     (void)form_char(*c, octl);</a>
<a name="6096"><span class="lineNum">    6096 </span>            :   }  /* for */</a>
<a name="6097"><span class="lineNum">    6097 </span>            :   output_partial_token_str(&quot;\&quot;&quot;, octl);</a>
<a name="6098"><span class="lineNum">    6098 </span>            :   octl-&gt;output_str(&quot;)))&quot;, octl);</a>
<a name="6099"><span class="lineNum">    6099 </span>            :   *need_leading_space = TRUE;</a>
<a name="6100"><span class="lineNum">    6100 </span>            : }  /* form_string_argument_attribute */</a>
<a name="6101"><span class="lineNum">    6101 </span>            : </a>
<a name="6102"><span class="lineNum">    6102 </span>            : </a>
<a name="6103"><span class="lineNum">    6103 </span>            : static void form_unsigned_argument_attribute(</a>
<a name="6104"><span class="lineNum">    6104 </span>            :                    a_const_char                           *attribute_name,</a>
<a name="6105"><span class="lineNum">    6105 </span>            :                    a_host_large_unsigned                  argument,</a>
<a name="6106"><span class="lineNum">    6106 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6107"><span class="lineNum">    6107 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6108"><span class="lineNum">    6108 </span>            : /*</a>
<a name="6109"><span class="lineNum">    6109 </span>            : Output an attribute that takes an unsigned integer as an argument.  The</a>
<a name="6110"><span class="lineNum">    6110 </span>            : attribute_name is assumed to have no characters that require escapes.</a>
<a name="6111"><span class="lineNum">    6111 </span>            : If *need_leading_space is TRUE, precede the attribute with a leading space.</a>
<a name="6112"><span class="lineNum">    6112 </span>            : *need_leading_space is set to TRUE in all cases, to indicate that a</a>
<a name="6113"><span class="lineNum">    6113 </span>            : space will be needed after the attribute.  Do the output in the way</a>
<a name="6114"><span class="lineNum">    6114 </span>            : described by octl.</a>
<a name="6115"><span class="lineNum">    6115 </span>            : */</a>
<a name="6116"><span class="lineNum">    6116 </span>            : {</a>
<a name="6117"><span class="lineNum">    6117 </span>            :   if (*need_leading_space) {</a>
<a name="6118"><span class="lineNum">    6118 </span>            :     octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="6119"><span class="lineNum">    6119 </span>            :   }  /* if */</a>
<a name="6120"><span class="lineNum">    6120 </span>            :   octl-&gt;output_str(&quot;__attribute__((&quot;, octl);</a>
<a name="6121"><span class="lineNum">    6121 </span>            :   octl-&gt;output_str(attribute_name, octl);</a>
<a name="6122"><span class="lineNum">    6122 </span>            :   octl-&gt;output_str(&quot;(&quot;, octl);</a>
<a name="6123"><span class="lineNum">    6123 </span>            :   form_unsigned_num((a_host_large_unsigned)argument, octl);</a>
<a name="6124"><span class="lineNum">    6124 </span>            :   octl-&gt;output_str(&quot;)))&quot;, octl);</a>
<a name="6125"><span class="lineNum">    6125 </span>            :   *need_leading_space = TRUE;</a>
<a name="6126"><span class="lineNum">    6126 </span>            : }  /* form_unsigned_argument_attribute */</a>
<a name="6127"><span class="lineNum">    6127 </span>            : </a>
<a name="6128"><span class="lineNum">    6128 </span>            : </a>
<a name="6129"><span class="lineNum">    6129 </span>            : static void form_recorded_gnu_attribute(</a>
<a name="6130"><span class="lineNum">    6130 </span>            :                    an_attribute_kind                      kind,</a>
<a name="6131"><span class="lineNum">    6131 </span>            :                    an_attribute_ptr                       attributes,</a>
<a name="6132"><span class="lineNum">    6132 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6133"><span class="lineNum">    6133 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6134"><span class="lineNum">    6134 </span>            : /*</a>
<a name="6135"><span class="lineNum">    6135 </span>            : If the given list of attributes contains an attribute of the given kind,</a>
<a name="6136"><span class="lineNum">    6136 </span>            : render that attribute as a GNU attribute.  If *need_leading_space is TRUE,</a>
<a name="6137"><span class="lineNum">    6137 </span>            : precede the attribute with a leading space.  *need_leading_space is set to</a>
<a name="6138"><span class="lineNum">    6138 </span>            : TRUE if an attribute is emitted, to indicate that a space will be needed after</a>
<a name="6139"><span class="lineNum">    6139 </span>            : the attribute.  Do the output in the way described by octl.</a>
<a name="6140"><span class="lineNum">    6140 </span>            : */</a>
<a name="6141"><span class="lineNum">    6141 </span>            : {</a>
<a name="6142"><span class="lineNum">    6142 </span>            :   an_attribute_ptr  ap = find_attribute(kind, attributes);</a>
<a name="6143"><span class="lineNum">    6143 </span>            : </a>
<a name="6144"><span class="lineNum">    6144 </span>            :   if (ap != NULL) {</a>
<a name="6145"><span class="lineNum">    6145 </span>            :     if (*need_leading_space) {</a>
<a name="6146"><span class="lineNum">    6146 </span>            :       octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="6147"><span class="lineNum">    6147 </span>            :     }  /* if */</a>
<a name="6148"><span class="lineNum">    6148 </span>            :     octl-&gt;output_str(&quot;__attribute__((&quot;, octl);</a>
<a name="6149"><span class="lineNum">    6149 </span>            :     octl-&gt;output_str(ap-&gt;name, octl);</a>
<a name="6150"><span class="lineNum">    6150 </span>            :     if (ap-&gt;arguments != NULL) {</a>
<a name="6151"><span class="lineNum">    6151 </span>            :       /* An attribute with arguments: Render them. */</a>
<a name="6152"><span class="lineNum">    6152 </span>            :       an_attribute_arg_ptr  aap = ap-&gt;arguments;</a>
<a name="6153"><span class="lineNum">    6153 </span>            :       octl-&gt;output_str(&quot;(&quot;, octl);</a>
<a name="6154"><span class="lineNum">    6154 </span>            :       for (; aap != NULL; aap = aap-&gt;next) {</a>
<a name="6155"><span class="lineNum">    6155 </span>            :         /* Emit the attribute argument. */</a>
<a name="6156"><span class="lineNum">    6156 </span>            :         switch (aap-&gt;kind) {</a>
<a name="6157"><span class="lineNum">    6157 </span>            :           case aak_empty:</a>
<a name="6158"><span class="lineNum">    6158 </span>            :             /* Nothing to emit. */</a>
<a name="6159"><span class="lineNum">    6159 </span>            :             break;</a>
<a name="6160"><span class="lineNum">    6160 </span>            :           case aak_token:</a>
<a name="6161"><span class="lineNum">    6161 </span>            :           case aak_raw_token:</a>
<a name="6162"><span class="lineNum">    6162 </span>            :             octl-&gt;output_str(aap-&gt;variant.token, octl);</a>
<a name="6163"><span class="lineNum">    6163 </span>            :             break;</a>
<a name="6164"><span class="lineNum">    6164 </span>            :           case aak_constant:</a>
<a name="6165"><span class="lineNum">    6165 </span>            :             form_constant(aap-&gt;variant.constant, /*need_parens=*/FALSE, octl);</a>
<a name="6166"><span class="lineNum">    6166 </span>            :             break;</a>
<a name="6167"><span class="lineNum">    6167 </span>            :           case aak_type:</a>
<a name="6168"><span class="lineNum">    6168 </span>            :             form_type(aap-&gt;variant.type, octl);</a>
<a name="6169"><span class="lineNum">    6169 </span>            :             break;</a>
<a name="6170"><span class="lineNum">    6170 </span>            :           default:</a>
<a name="6171"><span class="lineNum">    6171 </span>            :             unexpected_condition();</a>
<a name="6172"><span class="lineNum">    6172 </span>            :         }  /* for */</a>
<a name="6173"><span class="lineNum">    6173 </span>            :         /* Check if a separator must be issued. */</a>
<a name="6174"><span class="lineNum">    6174 </span>            :         if (aap-&gt;next != NULL) {</a>
<a name="6175"><span class="lineNum">    6175 </span>            :           if (aap-&gt;kind != (an_attribute_arg_kind)aak_raw_token) {</a>
<a name="6176"><span class="lineNum">    6176 </span>            :             octl-&gt;output_str(&quot;, &quot;, octl);</a>
<a name="6177"><span class="lineNum">    6177 </span>            :           }  /* if */</a>
<a name="6178"><span class="lineNum">    6178 </span>            :         }  /* if */</a>
<a name="6179"><span class="lineNum">    6179 </span>            :       }  /* for */</a>
<a name="6180"><span class="lineNum">    6180 </span>            :       octl-&gt;output_str(&quot;)&quot;, octl);</a>
<a name="6181"><span class="lineNum">    6181 </span>            :     }  /*if */</a>
<a name="6182"><span class="lineNum">    6182 </span>            :     octl-&gt;output_str(&quot;))&quot;, octl);</a>
<a name="6183"><span class="lineNum">    6183 </span>            :     *need_leading_space = TRUE;</a>
<a name="6184"><span class="lineNum">    6184 </span>            :   }  /* if */</a>
<a name="6185"><span class="lineNum">    6185 </span>            : }  /* form_recorded_gnu_attribute */</a>
<a name="6186"><span class="lineNum">    6186 </span>            : </a>
<a name="6187"><span class="lineNum">    6187 </span>            : #if GNU_VISIBILITY_ATTRIBUTE_ALLOWED</a>
<a name="6188"><span class="lineNum">    6188 </span>            : </a>
<a name="6189"><span class="lineNum">    6189 </span>            : static void form_ELF_visibility_attribute(</a>
<a name="6190"><span class="lineNum">    6190 </span>            :                    an_ELF_visibility_kind                 visibility,</a>
<a name="6191"><span class="lineNum">    6191 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6192"><span class="lineNum">    6192 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6193"><span class="lineNum">    6193 </span>            : /*</a>
<a name="6194"><span class="lineNum">    6194 </span>            : Output the given visibility as an attribute specification (provided it is</a>
<a name="6195"><span class="lineNum">    6195 </span>            : not evk_unspecified).  If *need_leading_space is TRUE, precede the attribute</a>
<a name="6196"><span class="lineNum">    6196 </span>            : with a leading space.  If an attribute is output, set *need_leading_space to</a>
<a name="6197"><span class="lineNum">    6197 </span>            : TRUE.  Do the output in the way described by octl.</a>
<a name="6198"><span class="lineNum">    6198 </span>            : */</a>
<a name="6199"><span class="lineNum">    6199 </span>            : {</a>
<a name="6200"><span class="lineNum">    6200 </span>            :   switch (visibility) {</a>
<a name="6201"><span class="lineNum">    6201 </span>            :     case evk_unspecified:</a>
<a name="6202"><span class="lineNum">    6202 </span>            :       /* No visibility attribute. */</a>
<a name="6203"><span class="lineNum">    6203 </span>            :       break;</a>
<a name="6204"><span class="lineNum">    6204 </span>            :     case evk_hidden:</a>
<a name="6205"><span class="lineNum">    6205 </span>            :       form_simple_attribute(&quot;visibility(\&quot;hidden\&quot;)&quot;, need_leading_space,</a>
<a name="6206"><span class="lineNum">    6206 </span>            :                             octl);</a>
<a name="6207"><span class="lineNum">    6207 </span>            :       break;</a>
<a name="6208"><span class="lineNum">    6208 </span>            :     case evk_protected:</a>
<a name="6209"><span class="lineNum">    6209 </span>            :       form_simple_attribute(&quot;visibility(\&quot;protected\&quot;)&quot;, need_leading_space,</a>
<a name="6210"><span class="lineNum">    6210 </span>            :                             octl);</a>
<a name="6211"><span class="lineNum">    6211 </span>            :       break;</a>
<a name="6212"><span class="lineNum">    6212 </span>            :     case evk_internal:</a>
<a name="6213"><span class="lineNum">    6213 </span>            :       form_simple_attribute(&quot;visibility(\&quot;internal\&quot;)&quot;, need_leading_space,</a>
<a name="6214"><span class="lineNum">    6214 </span>            :                             octl);</a>
<a name="6215"><span class="lineNum">    6215 </span>            :       break;</a>
<a name="6216"><span class="lineNum">    6216 </span>            :     case evk_default:</a>
<a name="6217"><span class="lineNum">    6217 </span>            :       form_simple_attribute(&quot;visibility(\&quot;default\&quot;)&quot;, need_leading_space,</a>
<a name="6218"><span class="lineNum">    6218 </span>            :                             octl);</a>
<a name="6219"><span class="lineNum">    6219 </span>            :       break;</a>
<a name="6220"><span class="lineNum">    6220 </span>            :     default:</a>
<a name="6221"><span class="lineNum">    6221 </span>            :       unexpected_condition();</a>
<a name="6222"><span class="lineNum">    6222 </span>            :   }  /* switch */</a>
<a name="6223"><span class="lineNum">    6223 </span>            : }  /* form_ELF_visibility_attribute */</a>
<a name="6224"><span class="lineNum">    6224 </span>            : </a>
<a name="6225"><span class="lineNum">    6225 </span>            : #endif /* GNU_VISIBILITY_ATTRIBUTE_ALLOWED */</a>
<a name="6226"><span class="lineNum">    6226 </span>            : </a>
<a name="6227"><span class="lineNum">    6227 </span>            : static void form_alignment_attributes(</a>
<a name="6228"><span class="lineNum">    6228 </span>            :                    a_type_ptr                             type,</a>
<a name="6229"><span class="lineNum">    6229 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6230"><span class="lineNum">    6230 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6231"><span class="lineNum">    6231 </span>            : /*</a>
<a name="6232"><span class="lineNum">    6232 </span>            : Output GNU &quot;aligned&quot; and &quot;packed&quot; attributes as recorded in the given type.</a>
<a name="6233"><span class="lineNum">    6233 </span>            : If *need_leading_space is TRUE, precede the attribute with a leading space.</a>
<a name="6234"><span class="lineNum">    6234 </span>            : If an attribute is output, set *need_leading_space to TRUE.  Do the output</a>
<a name="6235"><span class="lineNum">    6235 </span>            : in the way described by octl.</a>
<a name="6236"><span class="lineNum">    6236 </span>            : */</a>
<a name="6237"><span class="lineNum">    6237 </span>            : {</a>
<a name="6238"><span class="lineNum">    6238 </span>            :   if (type-&gt;alignment_set_explicitly) {</a>
<a name="6239"><span class="lineNum">    6239 </span>            :     /* Output an attribute to indicate the explicit alignment. */</a>
<a name="6240"><span class="lineNum">    6240 </span>            :     form_unsigned_argument_attribute(&quot;__aligned__&quot;,</a>
<a name="6241"><span class="lineNum">    6241 </span>            :                                      (a_host_large_unsigned)type-&gt;alignment,</a>
<a name="6242"><span class="lineNum">    6242 </span>            :                                      need_leading_space, octl);</a>
<a name="6243"><span class="lineNum">    6243 </span>            :   }  /* if */</a>
<a name="6244"><span class="lineNum">    6244 </span>            :   if ((is_immediate_class_type(type) &amp;&amp;</a>
<a name="6245"><span class="lineNum">    6245 </span>            :        type-&gt;variant.class_struct_union.is_packed) ||</a>
<a name="6246"><span class="lineNum">    6246 </span>            :       (is_immediate_enum_type(type) &amp;&amp; type-&gt;variant.integer.packed)) {</a>
<a name="6247"><span class="lineNum">    6247 </span>            :     form_simple_attribute(&quot;__packed__&quot;, need_leading_space, octl);</a>
<a name="6248"><span class="lineNum">    6248 </span>            :   }  /* if */</a>
<a name="6249"><span class="lineNum">    6249 </span>            : }  /* form_alignment_attributes */</a>
<a name="6250"><span class="lineNum">    6250 </span>            : </a>
<a name="6251"><span class="lineNum">    6251 </span>            : </a>
<a name="6252"><span class="lineNum">    6252 </span>            : static void form_routine_type_attributes(</a>
<a name="6253"><span class="lineNum">    6253 </span>            :                    a_type_ptr                             type,</a>
<a name="6254"><span class="lineNum">    6254 </span>            :                    a_boolean                              *need_leading_space,</a>
<a name="6255"><span class="lineNum">    6255 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6256"><span class="lineNum">    6256 </span>            : /*</a>
<a name="6257"><span class="lineNum">    6257 </span>            : Output GNU attributes that apply to the indicated type (which must be a</a>
<a name="6258"><span class="lineNum">    6258 </span>            : routine type).  If *need_leading_space is TRUE, precede the attribute with</a>
<a name="6259"><span class="lineNum">    6259 </span>            : a leading space.  If an attribute is output, set *need_leading_space to TRUE.</a>
<a name="6260"><span class="lineNum">    6260 </span>            : Do the output in the way described by octl.</a>
<a name="6261"><span class="lineNum">    6261 </span>            : */</a>
<a name="6262"><span class="lineNum">    6262 </span>            : {</a>
<a name="6263"><span class="lineNum">    6263 </span>            :   a_routine_type_supplement_ptr </a>
<a name="6264"><span class="lineNum">    6264 </span>            :                       rtsp = skip_typerefs(type)-&gt;variant.routine.extra_info;</a>
<a name="6265"><span class="lineNum">    6265 </span>            : </a>
<a name="6266"><span class="lineNum">    6266 </span>            :   form_alignment_attributes(type, need_leading_space, octl);</a>
<a name="6267"><span class="lineNum">    6267 </span>            :   if (rtsp-&gt;result_should_be_used &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6268"><span class="lineNum">    6268 </span>            :     /* If we're generating output for the C-generating back end, we do not</a>
<a name="6269"><span class="lineNum">    6269 </span>            :        output the attribute __warn_unused_result__ because any diagnostics it</a>
<a name="6270"><span class="lineNum">    6270 </span>            :        might trigger were already issued by the front end. */</a>
<a name="6271"><span class="lineNum">    6271 </span>            :     form_simple_attribute(&quot;__warn_unused_result__&quot;, need_leading_space, octl);</a>
<a name="6272"><span class="lineNum">    6272 </span>            :   }  /* if */</a>
<a name="6273"><span class="lineNum">    6273 </span>            :   if (rtsp-&gt;does_not_return) {</a>
<a name="6274"><span class="lineNum">    6274 </span>            :     form_simple_attribute(&quot;__noreturn__&quot;, need_leading_space, octl);</a>
<a name="6275"><span class="lineNum">    6275 </span>            :   }  /* if */</a>
<a name="6276"><span class="lineNum">    6276 </span>            :   if (rtsp-&gt;is_const) {</a>
<a name="6277"><span class="lineNum">    6277 </span>            :     form_simple_attribute(&quot;__const__&quot;, need_leading_space, octl);</a>
<a name="6278"><span class="lineNum">    6278 </span>            :   }  /* if */</a>
<a name="6279"><span class="lineNum">    6279 </span>            : #if GNU_X86_ATTRIBUTES_ALLOWED</a>
<a name="6280"><span class="lineNum">    6280 </span>            :   if (!targ_supports_x86_64) {</a>
<a name="6281"><span class="lineNum">    6281 </span>            :     switch (rtsp-&gt;calling_convention) {</a>
<a name="6282"><span class="lineNum">    6282 </span>            :       case cc_default:</a>
<a name="6283"><span class="lineNum">    6283 </span>            :         /* No attribute to generate. */</a>
<a name="6284"><span class="lineNum">    6284 </span>            :         break;</a>
<a name="6285"><span class="lineNum">    6285 </span>            :       case cc_cdecl:</a>
<a name="6286"><span class="lineNum">    6286 </span>            :         form_simple_attribute(&quot;__cdecl__&quot;, need_leading_space, octl);</a>
<a name="6287"><span class="lineNum">    6287 </span>            :         break;</a>
<a name="6288"><span class="lineNum">    6288 </span>            :       case cc_fastcall:</a>
<a name="6289"><span class="lineNum">    6289 </span>            :         if (!octl-&gt;gen_compilable_code</a>
<a name="6290"><span class="lineNum">    6290 </span>            : #if GCC_IS_GENERATED_CODE_TARGET</a>
<a name="6291"><span class="lineNum">    6291 </span>            :             || gnu_target_version_number &gt;= 40200</a>
<a name="6292"><span class="lineNum">    6292 </span>            : #endif /* GCC_IS_GENERATED_CODE_TARGET */</a>
<a name="6293"><span class="lineNum">    6293 </span>            :                                                  ) {</a>
<a name="6294"><span class="lineNum">    6294 </span>            :           form_simple_attribute(&quot;__fastcall__&quot;, need_leading_space, octl);</a>
<a name="6295"><span class="lineNum">    6295 </span>            :         }  /* if */</a>
<a name="6296"><span class="lineNum">    6296 </span>            :         break;</a>
<a name="6297"><span class="lineNum">    6297 </span>            :       case cc_stdcall:</a>
<a name="6298"><span class="lineNum">    6298 </span>            :         form_simple_attribute(&quot;__stdcall__&quot;, need_leading_space, octl);</a>
<a name="6299"><span class="lineNum">    6299 </span>            :         break;</a>
<a name="6300"><span class="lineNum">    6300 </span>            :       case cc_thiscall:</a>
<a name="6301"><span class="lineNum">    6301 </span>            :         /* A Microsoft-only calling convention.  These aren't generated for</a>
<a name="6302"><span class="lineNum">    6302 </span>            :            the GNU C compiler. */</a>
<a name="6303"><span class="lineNum">    6303 </span>            :         break;</a>
<a name="6304"><span class="lineNum">    6304 </span>            :       case cc_vectorcall:</a>
<a name="6305"><span class="lineNum">    6305 </span>            :         /* A Microsoft-only calling convention.  These aren't generated for</a>
<a name="6306"><span class="lineNum">    6306 </span>            :            the GNU C compiler. */</a>
<a name="6307"><span class="lineNum">    6307 </span>            :         break;</a>
<a name="6308"><span class="lineNum">    6308 </span>            :       case cc_clrcall:</a>
<a name="6309"><span class="lineNum">    6309 </span>            :         /* A Microsoft-only calling convention.  These aren't generated for</a>
<a name="6310"><span class="lineNum">    6310 </span>            :            the GNU C compiler. */</a>
<a name="6311"><span class="lineNum">    6311 </span>            :         break;</a>
<a name="6312"><span class="lineNum">    6312 </span>            :       default:</a>
<a name="6313"><span class="lineNum">    6313 </span>            :         unexpected_condition();</a>
<a name="6314"><span class="lineNum">    6314 </span>            :     }  /* switch */</a>
<a name="6315"><span class="lineNum">    6315 </span>            :   }  /* if */</a>
<a name="6316"><span class="lineNum">    6316 </span>            : #endif /* GNU_X86_ATTRIBUTES_ALLOWED */</a>
<a name="6317"><span class="lineNum">    6317 </span>            :   if (!octl-&gt;c_generating_back_end) {</a>
<a name="6318"><span class="lineNum">    6318 </span>            :     /* Don't emit the following attributes in generated C code to avoid having</a>
<a name="6319"><span class="lineNum">    6319 </span>            :        a back-end C compiler duplicate a diagnostic already emitted by the</a>
<a name="6320"><span class="lineNum">    6320 </span>            :        front end. */</a>
<a name="6321"><span class="lineNum">    6321 </span>            :     /* Generate any needed &quot;nonnull&quot; attributes: */</a>
<a name="6322"><span class="lineNum">    6322 </span>            :     a_param_type_ptr  ptp = rtsp-&gt;param_type_list;</a>
<a name="6323"><span class="lineNum">    6323 </span>            :     unsigned int      p = 1;</a>
<a name="6324"><span class="lineNum">    6324 </span>            :     for (; ptp != NULL; ptp = ptp-&gt;next, ++p) {</a>
<a name="6325"><span class="lineNum">    6325 </span>            :       if (ptp-&gt;nonnull) {</a>
<a name="6326"><span class="lineNum">    6326 </span>            :         form_unsigned_argument_attribute(&quot;nonnull&quot;, (a_host_large_unsigned)p,</a>
<a name="6327"><span class="lineNum">    6327 </span>            :                                          need_leading_space, octl);</a>
<a name="6328"><span class="lineNum">    6328 </span>            :       }  /* if */</a>
<a name="6329"><span class="lineNum">    6329 </span>            :     }  /* for */</a>
<a name="6330"><span class="lineNum">    6330 </span>            :     /* Generate the &quot;sentinel&quot; attribute if needed: */</a>
<a name="6331"><span class="lineNum">    6331 </span>            :     if (rtsp-&gt;sentinel_pos != 0) {</a>
<a name="6332"><span class="lineNum">    6332 </span>            :       /* Note that our representation is &quot;one off&quot; compared to the source form:</a>
<a name="6333"><span class="lineNum">    6333 </span>            :          I.e., &quot;sentinel(0)&quot; in the source is corresponds to sentinel_pos == 1</a>
<a name="6334"><span class="lineNum">    6334 </span>            :          to reserve sentinel_pos == 0 as a representation for &quot;no sentinel&quot;. */</a>
<a name="6335"><span class="lineNum">    6335 </span>            :       form_unsigned_argument_attribute(</a>
<a name="6336"><span class="lineNum">    6336 </span>            :                &quot;sentinel&quot;,</a>
<a name="6337"><span class="lineNum">    6337 </span>            :                (a_host_large_unsigned)(rtsp-&gt;sentinel_pos-1) /*lint --e(571)*/,</a>
<a name="6338"><span class="lineNum">    6338 </span>            :                need_leading_space, octl);</a>
<a name="6339"><span class="lineNum">    6339 </span>            :     }  /* if */</a>
<a name="6340"><span class="lineNum">    6340 </span>            :   }  /* if */</a>
<a name="6341"><span class="lineNum">    6341 </span>            : }  /* form_routine_type_attributes */</a>
<a name="6342"><span class="lineNum">    6342 </span>            : </a>
<a name="6343"><span class="lineNum">    6343 </span>            : </a>
<a name="6344"><span class="lineNum">    6344 </span>            : a_boolean form_type_attributes(</a>
<a name="6345"><span class="lineNum">    6345 </span>            :                     a_type_ptr                             type,</a>
<a name="6346"><span class="lineNum">    6346 </span>            :                     a_boolean                              need_leading_space,</a>
<a name="6347"><span class="lineNum">    6347 </span>            :                     an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6348"><span class="lineNum">    6348 </span>            : /*</a>
<a name="6349"><span class="lineNum">    6349 </span>            : Output GNU attributes that apply to the indicated type.  If need_leading_space</a>
<a name="6350"><span class="lineNum">    6350 </span>            : is TRUE, precede the first attribute with a leading space.  If an attribute is</a>
<a name="6351"><span class="lineNum">    6351 </span>            : output or if need_leading_space is TRUE, return TRUE (this allows the caller</a>
<a name="6352"><span class="lineNum">    6352 </span>            : to determine if a leading space is still needed).  Do the output in the way</a>
<a name="6353"><span class="lineNum">    6353 </span>            : described by octl.</a>
<a name="6354"><span class="lineNum">    6354 </span>            : */</a>
<a name="6355"><span class="lineNum">    6355 </span>            : {</a>
<a name="6356"><span class="lineNum">    6356 </span>            :   if (!octl-&gt;gen_compilable_code || gcc_or_clang_is_generated_code_target) {</a>
<a name="6357"><span class="lineNum">    6357 </span>            :     /* First emit the attributes that when appearing on a typedef would be</a>
<a name="6358"><span class="lineNum">    6358 </span>            :        recorded in the typedef entry itself (as opposed to the underlying</a>
<a name="6359"><span class="lineNum">    6359 </span>            :        type). */</a>
<a name="6360"><span class="lineNum">    6360 </span>            :     if (type-&gt;kind != (a_type_kind)tk_routine) {</a>
<a name="6361"><span class="lineNum">    6361 </span>            :       form_alignment_attributes(type, &amp;need_leading_space, octl);</a>
<a name="6362"><span class="lineNum">    6362 </span>            :       if (type-&gt;may_alias) {</a>
<a name="6363"><span class="lineNum">    6363 </span>            :         form_simple_attribute(&quot;__may_alias__&quot;, &amp;need_leading_space, octl);</a>
<a name="6364"><span class="lineNum">    6364 </span>            :       }  /* if */</a>
<a name="6365"><span class="lineNum">    6365 </span>            :     } else {</a>
<a name="6366"><span class="lineNum">    6366 </span>            :       /* For routine types, the alignment attributes are emitted by the call</a>
<a name="6367"><span class="lineNum">    6367 </span>            :          to form_routine_type_attributes (below) and the may_alias attribute</a>
<a name="6368"><span class="lineNum">    6368 </span>            :          is rendered by output_type_attributes. */</a>
<a name="6369"><span class="lineNum">    6369 </span>            :     }  /* if */</a>
<a name="6370"><span class="lineNum">    6370 </span>            : #if GNU_VISIBILITY_ATTRIBUTE_ALLOWED</a>
<a name="6371"><span class="lineNum">    6371 </span>            :     if (is_immediate_class_type(type) &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6372"><span class="lineNum">    6372 </span>            :       form_ELF_visibility_attribute(class_type_supp(type)-&gt;ELF_visibility,</a>
<a name="6373"><span class="lineNum">    6373 </span>            :                                     &amp;need_leading_space, octl);</a>
<a name="6374"><span class="lineNum">    6374 </span>            :     }  /* if */</a>
<a name="6375"><span class="lineNum">    6375 </span>            : #endif /* GNU_VISIBILITY_ATTRIBUTE_ALLOWED */</a>
<a name="6376"><span class="lineNum">    6376 </span>            :     if (type-&gt;variables_are_implicitly_referenced) {</a>
<a name="6377"><span class="lineNum">    6377 </span>            :       /* Output the &quot;unused&quot; attribute. */</a>
<a name="6378"><span class="lineNum">    6378 </span>            :       form_simple_attribute(&quot;__unused__&quot;, &amp;need_leading_space, octl);</a>
<a name="6379"><span class="lineNum">    6379 </span>            :     }  /* if */</a>
<a name="6380"><span class="lineNum">    6380 </span>            :     if (type-&gt;source_corresp.is_deprecated &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6381"><span class="lineNum">    6381 </span>            :       /* If we're generating output for the C-generating back end, we do not</a>
<a name="6382"><span class="lineNum">    6382 </span>            :          output the attribute __deprecated__ because any diagnostics it might</a>
<a name="6383"><span class="lineNum">    6383 </span>            :          trigger were already issued by the front end. */</a>
<a name="6384"><span class="lineNum">    6384 </span>            :       form_simple_attribute(&quot;__deprecated__&quot;, &amp;need_leading_space, octl);</a>
<a name="6385"><span class="lineNum">    6385 </span>            :     }  /* if */</a>
<a name="6386"><span class="lineNum">    6386 </span>            :     form_recorded_gnu_attribute(ak_alloc_size, type-&gt;source_corresp.attributes,</a>
<a name="6387"><span class="lineNum">    6387 </span>            :                                 &amp;need_leading_space, octl);</a>
<a name="6388"><span class="lineNum">    6388 </span>            :     /* The following attributes would be recorded on the underlying type</a>
<a name="6389"><span class="lineNum">    6389 </span>            :        if the attribute appeared on a typedef. */</a>
<a name="6390"><span class="lineNum">    6390 </span>            :     type = skip_typerefs(type);</a>
<a name="6391"><span class="lineNum">    6391 </span>            :     if (type-&gt;kind == (a_type_kind)tk_union &amp;&amp;</a>
<a name="6392"><span class="lineNum">    6392 </span>            :         type-&gt;variant.class_struct_union.is_transparent) {</a>
<a name="6393"><span class="lineNum">    6393 </span>            :       form_simple_attribute(&quot;__transparent_union__&quot;, &amp;need_leading_space,</a>
<a name="6394"><span class="lineNum">    6394 </span>            :                             octl);</a>
<a name="6395"><span class="lineNum">    6395 </span>            :     }  /* if */</a>
<a name="6396"><span class="lineNum">    6396 </span>            :     if (is_pointer_type(type) &amp;&amp;</a>
<a name="6397"><span class="lineNum">    6397 </span>            :         is_function_type(type_pointed_to(type))) {</a>
<a name="6398"><span class="lineNum">    6398 </span>            :       form_routine_type_attributes(f_skip_typerefs(type_pointed_to(type)),</a>
<a name="6399"><span class="lineNum">    6399 </span>            :                                    &amp;need_leading_space, octl);</a>
<a name="6400"><span class="lineNum">    6400 </span>            :     }  /* if */</a>
<a name="6401"><span class="lineNum">    6401 </span>            :   }  /* if */</a>
<a name="6402"><span class="lineNum">    6402 </span>            :   return need_leading_space;</a>
<a name="6403"><span class="lineNum">    6403 </span>            : }  /* form_type_attributes */</a>
<a name="6404"><span class="lineNum">    6404 </span>            : </a>
<a name="6405"><span class="lineNum">    6405 </span>            : </a>
<a name="6406"><span class="lineNum">    6406 </span>            : a_boolean form_variable_attributes(</a>
<a name="6407"><span class="lineNum">    6407 </span>            :                     a_variable_ptr                         var,</a>
<a name="6408"><span class="lineNum">    6408 </span>            :                     a_boolean                              need_leading_space,</a>
<a name="6409"><span class="lineNum">    6409 </span>            :                     an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6410"><span class="lineNum">    6410 </span>            : /*</a>
<a name="6411"><span class="lineNum">    6411 </span>            : Output the GNU attributes that apply to the indicated variable.</a>
<a name="6412"><span class="lineNum">    6412 </span>            : If need_leading_space is TRUE, precede the first attribute with a leading</a>
<a name="6413"><span class="lineNum">    6413 </span>            : space.  If an attribute is output or if need_leading_space is TRUE, return</a>
<a name="6414"><span class="lineNum">    6414 </span>            : TRUE (this allows the caller to determine if a leading space is still needed).</a>
<a name="6415"><span class="lineNum">    6415 </span>            : Do the output in the way described by octl.</a>
<a name="6416"><span class="lineNum">    6416 </span>            : */</a>
<a name="6417"><span class="lineNum">    6417 </span>            : {</a>
<a name="6418"><span class="lineNum">    6418 </span>            :   if (!octl-&gt;gen_compilable_code || gcc_or_clang_is_generated_code_target) {</a>
<a name="6419"><span class="lineNum">    6419 </span>            :     form_recorded_gnu_attribute(ak_alloc_size, var-&gt;source_corresp.attributes,</a>
<a name="6420"><span class="lineNum">    6420 </span>            :                                 &amp;need_leading_space, octl);</a>
<a name="6421"><span class="lineNum">    6421 </span>            :     if (var-&gt;alignment != 0) {</a>
<a name="6422"><span class="lineNum">    6422 </span>            :       /* Output the alignment attribute. */</a>
<a name="6423"><span class="lineNum">    6423 </span>            :       form_unsigned_argument_attribute(&quot;__aligned__&quot;,</a>
<a name="6424"><span class="lineNum">    6424 </span>            :                                        (a_host_large_unsigned)var-&gt;alignment,</a>
<a name="6425"><span class="lineNum">    6425 </span>            :                                        &amp;need_leading_space, octl);</a>
<a name="6426"><span class="lineNum">    6426 </span>            :     }  /* if */</a>
<a name="6427"><span class="lineNum">    6427 </span>            : #if GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED</a>
<a name="6428"><span class="lineNum">    6428 </span>            :     if (var-&gt;init_priority != 0 &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6429"><span class="lineNum">    6429 </span>            :       /* The init_priority is a C++-only attribute; it is ignored with a</a>
<a name="6430"><span class="lineNum">    6430 </span>            :          warning by GNU C compilers.  To avoid the warning, we do not emit it</a>
<a name="6431"><span class="lineNum">    6431 </span>            :          in the C-generating back end.  (IL lowering ensures the</a>
<a name="6432"><span class="lineNum">    6432 </span>            :          initializations are performed in the right order.) */</a>
<a name="6433"><span class="lineNum">    6433 </span>            :       form_unsigned_argument_attribute(</a>
<a name="6434"><span class="lineNum">    6434 </span>            :                 &quot;__init_priority__&quot;, (a_host_large_unsigned)var-&gt;init_priority,</a>
<a name="6435"><span class="lineNum">    6435 </span>            :                 &amp;need_leading_space, octl);</a>
<a name="6436"><span class="lineNum">    6436 </span>            :     }  /* if */</a>
<a name="6437"><span class="lineNum">    6437 </span>            : #endif /* GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED */</a>
<a name="6438"><span class="lineNum">    6438 </span>            :     if (var-&gt;cleanup_routine != NULL) {</a>
<a name="6439"><span class="lineNum">    6439 </span>            :       if (need_leading_space) octl-&gt;output_str(&quot; &quot;, octl);</a>
<a name="6440"><span class="lineNum">    6440 </span>            :       need_leading_space = TRUE;</a>
<a name="6441"><span class="lineNum">    6441 </span>            :       octl-&gt;output_str(&quot;__attribute__((cleanup(&quot;, octl);</a>
<a name="6442"><span class="lineNum">    6442 </span>            :       form_unqualified_name(&amp;var-&gt;cleanup_routine-&gt;source_corresp,</a>
<a name="6443"><span class="lineNum">    6443 </span>            :                             iek_routine, octl);</a>
<a name="6444"><span class="lineNum">    6444 </span>            :       octl-&gt;output_str(&quot;)))&quot;, octl);</a>
<a name="6445"><span class="lineNum">    6445 </span>            :     }  /* if */</a>
<a name="6446"><span class="lineNum">    6446 </span>            :     form_recorded_gnu_attribute(ak_externally_visible,</a>
<a name="6447"><span class="lineNum">    6447 </span>            :                                 var-&gt;source_corresp.attributes,</a>
<a name="6448"><span class="lineNum">    6448 </span>            :                                 &amp;need_leading_space, octl);</a>
<a name="6449"><span class="lineNum">    6449 </span>            : #if GNU_VISIBILITY_ATTRIBUTE_ALLOWED</a>
<a name="6450"><span class="lineNum">    6450 </span>            :     form_ELF_visibility_attribute(var-&gt;ELF_visibility, &amp;need_leading_space,</a>
<a name="6451"><span class="lineNum">    6451 </span>            :                                   octl);</a>
<a name="6452"><span class="lineNum">    6452 </span>            : #endif /* GNU_VISIBILITY_ATTRIBUTE_ALLOWED */</a>
<a name="6453"><span class="lineNum">    6453 </span>            :     if (var-&gt;is_weak &amp;&amp; !var-&gt;is_weakref) {</a>
<a name="6454"><span class="lineNum">    6454 </span>            :       /* The &quot;weakref&quot; attribute implies the &quot;weak&quot; attribute: We don't need</a>
<a name="6455"><span class="lineNum">    6455 </span>            :          to emit both. */</a>
<a name="6456"><span class="lineNum">    6456 </span>            :       form_simple_attribute(&quot;__weak__&quot;, &amp;need_leading_space, octl);</a>
<a name="6457"><span class="lineNum">    6457 </span>            :     }  /* if */</a>
<a name="6458"><span class="lineNum">    6458 </span>            :     if (var-&gt;source_corresp.maybe_unused) {</a>
<a name="6459"><span class="lineNum">    6459 </span>            :       form_simple_attribute(&quot;__unused__&quot;, &amp;need_leading_space, octl);</a>
<a name="6460"><span class="lineNum">    6460 </span>            :     }  /* if */</a>
<a name="6461"><span class="lineNum">    6461 </span>            :     if (var-&gt;has_gnu_used_attribute) {</a>
<a name="6462"><span class="lineNum">    6462 </span>            :       form_simple_attribute(&quot;__used__&quot;, &amp;need_leading_space, octl);</a>
<a name="6463"><span class="lineNum">    6463 </span>            :     }  /* if */</a>
<a name="6464"><span class="lineNum">    6464 </span>            :     if (var-&gt;source_corresp.is_deprecated &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6465"><span class="lineNum">    6465 </span>            :       /* If we're generating output for the C-generating back end, we do not</a>
<a name="6466"><span class="lineNum">    6466 </span>            :          output the attribute __deprecated__ because any diagnostics it might</a>
<a name="6467"><span class="lineNum">    6467 </span>            :          trigger were already issued by the front end. */</a>
<a name="6468"><span class="lineNum">    6468 </span>            :       form_simple_attribute(&quot;__deprecated__&quot;, &amp;need_leading_space, octl);</a>
<a name="6469"><span class="lineNum">    6469 </span>            :     }  /* if */</a>
<a name="6470"><span class="lineNum">    6470 </span>            :     if (var-&gt;is_not_common) {</a>
<a name="6471"><span class="lineNum">    6471 </span>            :       form_simple_attribute(&quot;__nocommon__&quot;, &amp;need_leading_space, octl);</a>
<a name="6472"><span class="lineNum">    6472 </span>            :     }  /* if */</a>
<a name="6473"><span class="lineNum">    6473 </span>            :     if (var-&gt;is_parameter &amp;&amp;</a>
<a name="6474"><span class="lineNum">    6474 </span>            :         var-&gt;variant.assoc_param_type != NULL &amp;&amp;</a>
<a name="6475"><span class="lineNum">    6475 </span>            :         var-&gt;variant.assoc_param_type-&gt;is_transparent) {</a>
<a name="6476"><span class="lineNum">    6476 </span>            :       form_simple_attribute(&quot;__transparent_union__&quot;, &amp;need_leading_space,</a>
<a name="6477"><span class="lineNum">    6477 </span>            :                             octl);</a>
<a name="6478"><span class="lineNum">    6478 </span>            :     }  /* if */</a>
<a name="6479"><span class="lineNum">    6479 </span>            :     if (var-&gt;section != NULL) {</a>
<a name="6480"><span class="lineNum">    6480 </span>            :       form_string_argument_attribute(&quot;__section__&quot;, var-&gt;section,</a>
<a name="6481"><span class="lineNum">    6481 </span>            :                                      &amp;need_leading_space, octl);</a>
<a name="6482"><span class="lineNum">    6482 </span>            :     }  /* if */</a>
<a name="6483"><span class="lineNum">    6483 </span>            : #if THREAD_LOCAL_STORAGE_SPECIFIER_ALLOWED</a>
<a name="6484"><span class="lineNum">    6484 </span>            :     if ((var-&gt;decl_modifiers &amp; DM_THREAD) != 0) {</a>
<a name="6485"><span class="lineNum">    6485 </span>            :       form_recorded_gnu_attribute(ak_tls_model, var-&gt;source_corresp.attributes,</a>
<a name="6486"><span class="lineNum">    6486 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6487"><span class="lineNum">    6487 </span>            :     }  /* if */</a>
<a name="6488"><span class="lineNum">    6488 </span>            : #endif /* THREAD_LOCAL_STORAGE_SPECIFIER_ALLOWED */</a>
<a name="6489"><span class="lineNum">    6489 </span>            :     if (var-&gt;is_gnu_alias) {</a>
<a name="6490"><span class="lineNum">    6490 </span>            :       form_recorded_gnu_attribute(ak_alias, var-&gt;source_corresp.attributes,</a>
<a name="6491"><span class="lineNum">    6491 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6492"><span class="lineNum">    6492 </span>            :     } else if (var-&gt;is_weakref) {</a>
<a name="6493"><span class="lineNum">    6493 </span>            :       form_recorded_gnu_attribute(ak_weakref, var-&gt;source_corresp.attributes,</a>
<a name="6494"><span class="lineNum">    6494 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6495"><span class="lineNum">    6495 </span>            :     }  /* if */</a>
<a name="6496"><span class="lineNum">    6496 </span>            :     if (is_pointer_type(var-&gt;type) &amp;&amp;</a>
<a name="6497"><span class="lineNum">    6497 </span>            :         is_function_type(type_pointed_to(var-&gt;type))) {</a>
<a name="6498"><span class="lineNum">    6498 </span>            :       form_routine_type_attributes(f_skip_typerefs(type_pointed_to(var-&gt;type)),</a>
<a name="6499"><span class="lineNum">    6499 </span>            :                                    &amp;need_leading_space, octl);</a>
<a name="6500"><span class="lineNum">    6500 </span>            :     }  /* if */</a>
<a name="6501"><span class="lineNum">    6501 </span>            :   }  /* if */</a>
<a name="6502"><span class="lineNum">    6502 </span>            :   return need_leading_space;</a>
<a name="6503"><span class="lineNum">    6503 </span>            : }  /* form_variable_attributes */</a>
<a name="6504"><span class="lineNum">    6504 </span>            : </a>
<a name="6505"><span class="lineNum">    6505 </span>            : </a>
<a name="6506"><span class="lineNum">    6506 </span>            : a_boolean form_field_attributes(</a>
<a name="6507"><span class="lineNum">    6507 </span>            :                    a_field_ptr                            field,</a>
<a name="6508"><span class="lineNum">    6508 </span>            :                    a_boolean                              need_leading_space,</a>
<a name="6509"><span class="lineNum">    6509 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6510"><span class="lineNum">    6510 </span>            : /*</a>
<a name="6511"><span class="lineNum">    6511 </span>            : Output the GNU attributes that apply to the indicated field.</a>
<a name="6512"><span class="lineNum">    6512 </span>            : If need_leading_space is TRUE, precede the first attribute with a leading</a>
<a name="6513"><span class="lineNum">    6513 </span>            : space.  If an attribute is output or if need_leading_space is TRUE, return</a>
<a name="6514"><span class="lineNum">    6514 </span>            : TRUE (this allows the caller to determine if a leading space is still needed).</a>
<a name="6515"><span class="lineNum">    6515 </span>            : Do the output in the way described by octl.</a>
<a name="6516"><span class="lineNum">    6516 </span>            : */</a>
<a name="6517"><span class="lineNum">    6517 </span>            : {</a>
<a name="6518"><span class="lineNum">    6518 </span>            :   if (!octl-&gt;gen_compilable_code || gcc_or_clang_is_generated_code_target) {</a>
<a name="6519"><span class="lineNum">    6519 </span>            :     form_recorded_gnu_attribute(ak_alloc_size,</a>
<a name="6520"><span class="lineNum">    6520 </span>            :                                 field-&gt;source_corresp.attributes,</a>
<a name="6521"><span class="lineNum">    6521 </span>            :                                 &amp;need_leading_space, octl);</a>
<a name="6522"><span class="lineNum">    6522 </span>            :     if (field-&gt;source_corresp.is_deprecated &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6523"><span class="lineNum">    6523 </span>            :       /* If we're generating output for the C-generating back end, we do not</a>
<a name="6524"><span class="lineNum">    6524 </span>            :          output the attribute __deprecated__ because any diagnostics it might</a>
<a name="6525"><span class="lineNum">    6525 </span>            :          trigger were already issued by the front end. */</a>
<a name="6526"><span class="lineNum">    6526 </span>            :       form_simple_attribute(&quot;__deprecated__&quot;, &amp;need_leading_space, octl);</a>
<a name="6527"><span class="lineNum">    6527 </span>            :     }  /* if */</a>
<a name="6528"><span class="lineNum">    6528 </span>            :     if (field-&gt;is_packed) {</a>
<a name="6529"><span class="lineNum">    6529 </span>            :       form_simple_attribute(&quot;__packed__&quot;, &amp;need_leading_space, octl);</a>
<a name="6530"><span class="lineNum">    6530 </span>            :     }  /* if */</a>
<a name="6531"><span class="lineNum">    6531 </span>            :     if (field-&gt;alignment != 0) {</a>
<a name="6532"><span class="lineNum">    6532 </span>            :       form_unsigned_argument_attribute(&quot;__aligned__&quot;,</a>
<a name="6533"><span class="lineNum">    6533 </span>            :                                        (a_host_large_unsigned)field-&gt;alignment,</a>
<a name="6534"><span class="lineNum">    6534 </span>            :                                        &amp;need_leading_space, octl);</a>
<a name="6535"><span class="lineNum">    6535 </span>            :     }  /* if */</a>
<a name="6536"><span class="lineNum">    6536 </span>            :     if (is_pointer_type(field-&gt;type) &amp;&amp;</a>
<a name="6537"><span class="lineNum">    6537 </span>            :         is_function_type(type_pointed_to(field-&gt;type))) {</a>
<a name="6538"><span class="lineNum">    6538 </span>            :       form_routine_type_attributes(</a>
<a name="6539"><span class="lineNum">    6539 </span>            :                                 f_skip_typerefs(type_pointed_to(field-&gt;type)),</a>
<a name="6540"><span class="lineNum">    6540 </span>            :                                 &amp;need_leading_space, octl);</a>
<a name="6541"><span class="lineNum">    6541 </span>            :     }  /* if */</a>
<a name="6542"><span class="lineNum">    6542 </span>            :   }  /* if */</a>
<a name="6543"><span class="lineNum">    6543 </span>            :   return need_leading_space;</a>
<a name="6544"><span class="lineNum">    6544 </span>            : }  /* form_field_attributes */</a>
<a name="6545"><span class="lineNum">    6545 </span>            : </a>
<a name="6546"><span class="lineNum">    6546 </span>            : </a>
<a name="6547"><span class="lineNum">    6547 </span>            : a_boolean form_routine_attributes(</a>
<a name="6548"><span class="lineNum">    6548 </span>            :                    a_routine_ptr                          rout,</a>
<a name="6549"><span class="lineNum">    6549 </span>            :                    a_boolean                              need_leading_space,</a>
<a name="6550"><span class="lineNum">    6550 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6551"><span class="lineNum">    6551 </span>            : /*</a>
<a name="6552"><span class="lineNum">    6552 </span>            : Output the GNU attributes that apply to the indicated routine.</a>
<a name="6553"><span class="lineNum">    6553 </span>            : If need_leading_space is TRUE, precede the first attribute with a leading</a>
<a name="6554"><span class="lineNum">    6554 </span>            : space.  If an attribute is output or if need_leading_space is TRUE, return</a>
<a name="6555"><span class="lineNum">    6555 </span>            : TRUE (this allows the caller to determine if a leading space is still needed).</a>
<a name="6556"><span class="lineNum">    6556 </span>            : Do the output in the way described by octl.</a>
<a name="6557"><span class="lineNum">    6557 </span>            : */</a>
<a name="6558"><span class="lineNum">    6558 </span>            : {</a>
<a name="6559"><span class="lineNum">    6559 </span>            :   if (!octl-&gt;gen_compilable_code || gcc_or_clang_is_generated_code_target) {</a>
<a name="6560"><span class="lineNum">    6560 </span>            :     an_attribute_ptr  attributes = rout-&gt;source_corresp.attributes;</a>
<a name="6561"><span class="lineNum">    6561 </span>            :     if (attributes != NULL) {</a>
<a name="6562"><span class="lineNum">    6562 </span>            :       /* Check for attributes that are recorded only as attribute entries</a>
<a name="6563"><span class="lineNum">    6563 </span>            :          (i.e., without additional fields in the IL entry for the routine). */</a>
<a name="6564"><span class="lineNum">    6564 </span>            :       form_recorded_gnu_attribute(ak_alloc_size, attributes,</a>
<a name="6565"><span class="lineNum">    6565 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6566"><span class="lineNum">    6566 </span>            :       form_recorded_gnu_attribute(ak_artificial, attributes,</a>
<a name="6567"><span class="lineNum">    6567 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6568"><span class="lineNum">    6568 </span>            :       form_recorded_gnu_attribute(ak_cold, attributes,</a>
<a name="6569"><span class="lineNum">    6569 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6570"><span class="lineNum">    6570 </span>            :       form_recorded_gnu_attribute(ak_error, attributes,</a>
<a name="6571"><span class="lineNum">    6571 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6572"><span class="lineNum">    6572 </span>            :       form_recorded_gnu_attribute(ak_externally_visible,</a>
<a name="6573"><span class="lineNum">    6573 </span>            :                                   attributes,</a>
<a name="6574"><span class="lineNum">    6574 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6575"><span class="lineNum">    6575 </span>            :       form_recorded_gnu_attribute(ak_flatten, attributes,</a>
<a name="6576"><span class="lineNum">    6576 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6577"><span class="lineNum">    6577 </span>            :       form_recorded_gnu_attribute(ak_hot, attributes,</a>
<a name="6578"><span class="lineNum">    6578 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6579"><span class="lineNum">    6579 </span>            :       form_recorded_gnu_attribute(ak_warning, attributes,</a>
<a name="6580"><span class="lineNum">    6580 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6581"><span class="lineNum">    6581 </span>            :     }  /* if */</a>
<a name="6582"><span class="lineNum">    6582 </span>            :     if (rout-&gt;is_initialization_routine) {</a>
<a name="6583"><span class="lineNum">    6583 </span>            : #if GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED</a>
<a name="6584"><span class="lineNum">    6584 </span>            :       if (rout-&gt;has_ctor_priority) {</a>
<a name="6585"><span class="lineNum">    6585 </span>            :         form_unsigned_argument_attribute(</a>
<a name="6586"><span class="lineNum">    6586 </span>            :                &quot;__constructor__&quot;,</a>
<a name="6587"><span class="lineNum">    6587 </span>            :                (a_host_large_unsigned)gnu_routine_supp(rout)-&gt;ctor_priority,</a>
<a name="6588"><span class="lineNum">    6588 </span>            :                &amp;need_leading_space, octl);</a>
<a name="6589"><span class="lineNum">    6589 </span>            :       } else</a>
<a name="6590"><span class="lineNum">    6590 </span>            : #endif /* GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED */</a>
<a name="6591"><span class="lineNum">    6591 </span>            :       /* Do not insert code here. */</a>
<a name="6592"><span class="lineNum">    6592 </span>            :       {</a>
<a name="6593"><span class="lineNum">    6593 </span>            :         form_simple_attribute(&quot;__constructor__&quot;, &amp;need_leading_space, octl);</a>
<a name="6594"><span class="lineNum">    6594 </span>            :       }  /* if */</a>
<a name="6595"><span class="lineNum">    6595 </span>            :     }  /* if */</a>
<a name="6596"><span class="lineNum">    6596 </span>            :     if (rout-&gt;is_finalization_routine) {</a>
<a name="6597"><span class="lineNum">    6597 </span>            : #if GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED</a>
<a name="6598"><span class="lineNum">    6598 </span>            :       if (rout-&gt;has_dtor_priority) {</a>
<a name="6599"><span class="lineNum">    6599 </span>            :         form_unsigned_argument_attribute(</a>
<a name="6600"><span class="lineNum">    6600 </span>            :                &quot;__destructor__&quot;,</a>
<a name="6601"><span class="lineNum">    6601 </span>            :                (a_host_large_unsigned)gnu_routine_supp(rout)-&gt;dtor_priority,</a>
<a name="6602"><span class="lineNum">    6602 </span>            :                &amp;need_leading_space, octl);</a>
<a name="6603"><span class="lineNum">    6603 </span>            :       } else</a>
<a name="6604"><span class="lineNum">    6604 </span>            : #endif /* GNU_INIT_PRIORITY_ATTRIBUTE_ALLOWED */</a>
<a name="6605"><span class="lineNum">    6605 </span>            :       /* Do not insert code here. */</a>
<a name="6606"><span class="lineNum">    6606 </span>            :       {</a>
<a name="6607"><span class="lineNum">    6607 </span>            :         form_simple_attribute(&quot;__destructor__&quot;, &amp;need_leading_space, octl);</a>
<a name="6608"><span class="lineNum">    6608 </span>            :       }  /* if */</a>
<a name="6609"><span class="lineNum">    6609 </span>            :     }  /* if */</a>
<a name="6610"><span class="lineNum">    6610 </span>            :     if (rout-&gt;is_pure) {</a>
<a name="6611"><span class="lineNum">    6611 </span>            :       form_simple_attribute(&quot;__pure__&quot;, &amp;need_leading_space, octl);</a>
<a name="6612"><span class="lineNum">    6612 </span>            :     }  /* if */</a>
<a name="6613"><span class="lineNum">    6613 </span>            :     if (rout-&gt;is_weak &amp;&amp; !rout-&gt;is_weakref) {</a>
<a name="6614"><span class="lineNum">    6614 </span>            :       /* The &quot;weakref&quot; attribute implies the &quot;weak&quot; attribute: We don't need</a>
<a name="6615"><span class="lineNum">    6615 </span>            :          to emit both. */</a>
<a name="6616"><span class="lineNum">    6616 </span>            :       form_simple_attribute(&quot;__weak__&quot;, &amp;need_leading_space, octl);</a>
<a name="6617"><span class="lineNum">    6617 </span>            :     }  /* if */</a>
<a name="6618"><span class="lineNum">    6618 </span>            :     if (rout-&gt;source_corresp.maybe_unused) {</a>
<a name="6619"><span class="lineNum">    6619 </span>            :       form_simple_attribute(&quot;__unused__&quot;, &amp;need_leading_space, octl);</a>
<a name="6620"><span class="lineNum">    6620 </span>            :     }  /* if */</a>
<a name="6621"><span class="lineNum">    6621 </span>            :     if (rout-&gt;has_gnu_used_attribute) {</a>
<a name="6622"><span class="lineNum">    6622 </span>            :       form_simple_attribute(&quot;__used__&quot;, &amp;need_leading_space, octl);</a>
<a name="6623"><span class="lineNum">    6623 </span>            :     }  /* if */</a>
<a name="6624"><span class="lineNum">    6624 </span>            :     if (rout-&gt;source_corresp.is_deprecated &amp;&amp; !octl-&gt;c_generating_back_end) {</a>
<a name="6625"><span class="lineNum">    6625 </span>            :       /* If we're generating output for the C-generating back end, we do not</a>
<a name="6626"><span class="lineNum">    6626 </span>            :          output the attribute __deprecated__ because any diagnostics it might</a>
<a name="6627"><span class="lineNum">    6627 </span>            :          trigger were already issued by the front end. */</a>
<a name="6628"><span class="lineNum">    6628 </span>            :       form_simple_attribute(&quot;__deprecated__&quot;, &amp;need_leading_space, octl);</a>
<a name="6629"><span class="lineNum">    6629 </span>            :     }  /* if */</a>
<a name="6630"><span class="lineNum">    6630 </span>            :     if (rout-&gt;allocates_memory) {</a>
<a name="6631"><span class="lineNum">    6631 </span>            :       form_simple_attribute(&quot;__malloc__&quot;, &amp;need_leading_space, octl);</a>
<a name="6632"><span class="lineNum">    6632 </span>            :     }  /* if */</a>
<a name="6633"><span class="lineNum">    6633 </span>            : #if GNU_NAKED_ATTRIBUTE_ALLOWED</a>
<a name="6634"><span class="lineNum">    6634 </span>            :     if (rout-&gt;is_naked) {</a>
<a name="6635"><span class="lineNum">    6635 </span>            :       form_simple_attribute(&quot;__naked__&quot;, &amp;need_leading_space, octl);</a>
<a name="6636"><span class="lineNum">    6636 </span>            :     }  /* if */</a>
<a name="6637"><span class="lineNum">    6637 </span>            : #endif /* GNU_NAKED_ATTRIBUTE_ALLOWED */</a>
<a name="6638"><span class="lineNum">    6638 </span>            :     if (rout-&gt;no_instrument_function) {</a>
<a name="6639"><span class="lineNum">    6639 </span>            :       form_simple_attribute(&quot;__no_instrument_function__&quot;, &amp;need_leading_space,</a>
<a name="6640"><span class="lineNum">    6640 </span>            :                             octl);</a>
<a name="6641"><span class="lineNum">    6641 </span>            :     }  /* if */</a>
<a name="6642"><span class="lineNum">    6642 </span>            :     if (rout-&gt;no_check_memory_usage) {</a>
<a name="6643"><span class="lineNum">    6643 </span>            :       form_simple_attribute(&quot;__no_check_memory_usage__&quot;, &amp;need_leading_space,</a>
<a name="6644"><span class="lineNum">    6644 </span>            :                             octl);</a>
<a name="6645"><span class="lineNum">    6645 </span>            :     }  /* if */</a>
<a name="6646"><span class="lineNum">    6646 </span>            :     if (rout-&gt;never_inline) {</a>
<a name="6647"><span class="lineNum">    6647 </span>            :       form_simple_attribute(&quot;__noinline__&quot;, &amp;need_leading_space, octl);</a>
<a name="6648"><span class="lineNum">    6648 </span>            :     }  /* if */</a>
<a name="6649"><span class="lineNum">    6649 </span>            :     if (rout-&gt;always_inline) {</a>
<a name="6650"><span class="lineNum">    6650 </span>            :       form_simple_attribute(&quot;__always_inline__&quot;, &amp;need_leading_space, octl);</a>
<a name="6651"><span class="lineNum">    6651 </span>            :     }  /* if */</a>
<a name="6652"><span class="lineNum">    6652 </span>            :     /* The &quot;gnu_inline&quot; attribute isn't recognized by older GNU compilers, but</a>
<a name="6653"><span class="lineNum">    6653 </span>            :        on those compilers the associated semantics are enabled by default. */</a>
<a name="6654"><span class="lineNum">    6654 </span>            :     if (rout-&gt;gnu_c89_inline &amp;&amp;</a>
<a name="6655"><span class="lineNum">    6655 </span>            :         (clang_is_generated_code_target ||</a>
<a name="6656"><span class="lineNum">    6656 </span>            :          (gcc_is_generated_code_target</a>
<a name="6657"><span class="lineNum">    6657 </span>            : #if GCC_IS_GENERATED_CODE_TARGET</a>
<a name="6658"><span class="lineNum">    6658 </span>            :           &amp;&amp; gnu_target_version_number &gt;= 40200</a>
<a name="6659"><span class="lineNum">    6659 </span>            : #endif /* GCC_IS_GENERATED_CODE_TARGET */</a>
<a name="6660"><span class="lineNum">    6660 </span>            :                                                ))) {</a>
<a name="6661"><span class="lineNum">    6661 </span>            :       form_simple_attribute(&quot;__gnu_inline__&quot;, &amp;need_leading_space, octl);</a>
<a name="6662"><span class="lineNum">    6662 </span>            :     }  /* if */</a>
<a name="6663"><span class="lineNum">    6663 </span>            :     if (rout-&gt;never_throws &amp;&amp;</a>
<a name="6664"><span class="lineNum">    6664 </span>            :         (clang_is_generated_code_target ||</a>
<a name="6665"><span class="lineNum">    6665 </span>            :          (gcc_is_generated_code_target</a>
<a name="6666"><span class="lineNum">    6666 </span>            : #if GCC_IS_GENERATED_CODE_TARGET</a>
<a name="6667"><span class="lineNum">    6667 </span>            :           &amp;&amp; gnu_target_version_number &gt;= 30300</a>
<a name="6668"><span class="lineNum">    6668 </span>            : #endif /* GCC_IS_GENERATED_CODE_TARGET */</a>
<a name="6669"><span class="lineNum">    6669 </span>            :                                                ))) {</a>
<a name="6670"><span class="lineNum">    6670 </span>            :       form_simple_attribute(&quot;__nothrow__&quot;, &amp;need_leading_space, octl);</a>
<a name="6671"><span class="lineNum">    6671 </span>            :     }  /* if */</a>
<a name="6672"><span class="lineNum">    6672 </span>            :     if (rout-&gt;type-&gt;kind == (a_type_kind)tk_routine) {</a>
<a name="6673"><span class="lineNum">    6673 </span>            :       /* If this routine is declared using ordinary function declarator</a>
<a name="6674"><span class="lineNum">    6674 </span>            :          syntax (i.e., not using a typedef), generate the associated</a>
<a name="6675"><span class="lineNum">    6675 </span>            :          routine type attributes. */</a>
<a name="6676"><span class="lineNum">    6676 </span>            :       form_routine_type_attributes(rout-&gt;type, &amp;need_leading_space, octl);</a>
<a name="6677"><span class="lineNum">    6677 </span>            :     }  /* if */</a>
<a name="6678"><span class="lineNum">    6678 </span>            :     if (has_gnu_routine_supp(rout) &amp;&amp;</a>
<a name="6679"><span class="lineNum">    6679 </span>            :         gnu_routine_supp(rout)-&gt;section != NULL) {</a>
<a name="6680"><span class="lineNum">    6680 </span>            :       form_string_argument_attribute(&quot;__section__&quot;,</a>
<a name="6681"><span class="lineNum">    6681 </span>            :                                      gnu_routine_supp(rout)-&gt;section,</a>
<a name="6682"><span class="lineNum">    6682 </span>            :                                      &amp;need_leading_space, octl);</a>
<a name="6683"><span class="lineNum">    6683 </span>            :     }  /* if */</a>
<a name="6684"><span class="lineNum">    6684 </span>            :     if (rout-&gt;is_gnu_alias) {</a>
<a name="6685"><span class="lineNum">    6685 </span>            :       form_recorded_gnu_attribute(ak_alias, rout-&gt;source_corresp.attributes,</a>
<a name="6686"><span class="lineNum">    6686 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6687"><span class="lineNum">    6687 </span>            :     } else if (rout-&gt;is_weakref) {</a>
<a name="6688"><span class="lineNum">    6688 </span>            :       form_recorded_gnu_attribute(ak_weakref, rout-&gt;source_corresp.attributes,</a>
<a name="6689"><span class="lineNum">    6689 </span>            :                                   &amp;need_leading_space, octl);</a>
<a name="6690"><span class="lineNum">    6690 </span>            :     }  /* if */</a>
<a name="6691"><span class="lineNum">    6691 </span>            : #if GNU_VISIBILITY_ATTRIBUTE_ALLOWED</a>
<a name="6692"><span class="lineNum">    6692 </span>            :     form_ELF_visibility_attribute(rout-&gt;ELF_visibility, &amp;need_leading_space,</a>
<a name="6693"><span class="lineNum">    6693 </span>            :                                   octl);</a>
<a name="6694"><span class="lineNum">    6694 </span>            : #endif /* GNU_VISIBILITY_ATTRIBUTE_ALLOWED */</a>
<a name="6695"><span class="lineNum">    6695 </span>            :   }  /* if */</a>
<a name="6696"><span class="lineNum">    6696 </span>            :   return need_leading_space;</a>
<a name="6697"><span class="lineNum">    6697 </span>            : }  /* form_routine_attributes */</a>
<a name="6698"><span class="lineNum">    6698 </span>            : </a>
<a name="6699"><span class="lineNum">    6699 </span>            : </a>
<a name="6700"><span class="lineNum">    6700 </span>            : a_boolean form_label_attributes(</a>
<a name="6701"><span class="lineNum">    6701 </span>            :                    a_label_ptr                            label,</a>
<a name="6702"><span class="lineNum">    6702 </span>            :                    a_boolean                              need_leading_space,</a>
<a name="6703"><span class="lineNum">    6703 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6704"><span class="lineNum">    6704 </span>            : /*</a>
<a name="6705"><span class="lineNum">    6705 </span>            : Output the GNU attributes that apply to the indicated label in the way</a>
<a name="6706"><span class="lineNum">    6706 </span>            : described by octl.  If need_leading_space is TRUE, precede the first </a>
<a name="6707"><span class="lineNum">    6707 </span>            : attribute with a leading space.  If an attribute is output or if</a>
<a name="6708"><span class="lineNum">    6708 </span>            : need_leading_space is TRUE, return TRUE (this allows the caller to</a>
<a name="6709"><span class="lineNum">    6709 </span>            : determine if a leading space is still needed).</a>
<a name="6710"><span class="lineNum">    6710 </span>            : */</a>
<a name="6711"><span class="lineNum">    6711 </span>            : {</a>
<a name="6712"><span class="lineNum">    6712 </span>            :   if (!octl-&gt;gen_compilable_code || gcc_or_clang_is_generated_code_target) {</a>
<a name="6713"><span class="lineNum">    6713 </span>            :     if (label-&gt;source_corresp.maybe_unused) {</a>
<a name="6714"><span class="lineNum">    6714 </span>            :       form_simple_attribute(&quot;__unused__&quot;, &amp;need_leading_space, octl);</a>
<a name="6715"><span class="lineNum">    6715 </span>            :     }  /* if */</a>
<a name="6716"><span class="lineNum">    6716 </span>            :   }  /* if */</a>
<a name="6717"><span class="lineNum">    6717 </span>            :   return need_leading_space;</a>
<a name="6718"><span class="lineNum">    6718 </span>            : }  /* form_label_attributes */</a>
<a name="6719"><span class="lineNum">    6719 </span>            : </a>
<a name="6720"><span class="lineNum">    6720 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="6721"><span class="lineNum">    6721 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="6722"><span class="lineNum">    6722 </span>            : </a>
<a name="6723"><span class="lineNum">    6723 </span><span class="lineNoCov">          0 : void form_asm_name(a_const_char                           *asm_name,</span></a>
<a name="6724"><span class="lineNum">    6724 </span>            :                    an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6725"><span class="lineNum">    6725 </span>            : /*</a>
<a name="6726"><span class="lineNum">    6726 </span>            : Output an asm name for a routine or variable in the way described by octl.</a>
<a name="6727"><span class="lineNum">    6727 </span>            : asm_name is allowed to be NULL.</a>
<a name="6728"><span class="lineNum">    6728 </span>            : */</a>
<a name="6729"><span class="lineNum">    6729 </span>            : {</a>
<a name="6730"><span class="lineNum">    6730 </span><span class="lineNoCov">          0 :   a_const_char *c;</span></a>
<a name="6731"><span class="lineNum">    6731 </span>            : </a>
<a name="6732"><span class="lineNum">    6732 </span><span class="lineNoCov">          0 :   if (gcc_or_clang_is_generated_code_target &amp;&amp; asm_name != NULL) {</span></a>
<a name="6733"><span class="lineNum">    6733 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot; __asm__(&quot;, octl);</span></a>
<a name="6734"><span class="lineNum">    6734 </span><span class="lineNoCov">          0 :     output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="6735"><span class="lineNum">    6735 </span><span class="lineNoCov">          0 :     for (c = asm_name; *c != '\0'; c++) {</span></a>
<a name="6736"><span class="lineNum">    6736 </span><span class="lineNoCov">          0 :       (void)form_char(*c, octl);</span></a>
<a name="6737"><span class="lineNum">    6737 </span>            :     }  /* for */</a>
<a name="6738"><span class="lineNum">    6738 </span><span class="lineNoCov">          0 :     output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="6739"><span class="lineNum">    6739 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="6740"><span class="lineNum">    6740 </span>            :   }  /* if */</a>
<a name="6741"><span class="lineNum">    6741 </span><span class="lineNoCov">          0 : }  /* form_asm_name */</span></a>
<a name="6742"><span class="lineNum">    6742 </span>            : </a>
<a name="6743"><span class="lineNum">    6743 </span>            : </a>
<a name="6744"><span class="lineNum">    6744 </span><span class="lineNoCov">          0 : void form_var_reg_name(a_named_register                       reg,</span></a>
<a name="6745"><span class="lineNum">    6745 </span>            :                        an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6746"><span class="lineNum">    6746 </span>            : /*</a>
<a name="6747"><span class="lineNum">    6747 </span>            : Output an asm register name for a variable in the way described by octl.</a>
<a name="6748"><span class="lineNum">    6748 </span>            : */</a>
<a name="6749"><span class="lineNum">    6749 </span>            : {</a>
<a name="6750"><span class="lineNum">    6750 </span><span class="lineNoCov">          0 :   if (gcc_or_clang_is_generated_code_target) {</span></a>
<a name="6751"><span class="lineNum">    6751 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot; __asm__(&quot;, octl);</span></a>
<a name="6752"><span class="lineNum">    6752 </span><span class="lineNoCov">          0 :     output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="6753"><span class="lineNum">    6753 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(named_register_names[(int)reg], octl);</span></a>
<a name="6754"><span class="lineNum">    6754 </span><span class="lineNoCov">          0 :     output_partial_token_str(&quot;\&quot;&quot;, octl);</span></a>
<a name="6755"><span class="lineNum">    6755 </span><span class="lineNoCov">          0 :     octl-&gt;output_str(&quot;)&quot;, octl);</span></a>
<a name="6756"><span class="lineNum">    6756 </span>            :   }  /* if */</a>
<a name="6757"><span class="lineNum">    6757 </span><span class="lineNoCov">          0 : }  /* form_var_reg_name */</span></a>
<a name="6758"><span class="lineNum">    6758 </span>            : </a>
<a name="6759"><span class="lineNum">    6759 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="6760"><span class="lineNum">    6760 </span>            : </a>
<a name="6761"><span class="lineNum">    6761 </span>            : #endif /* GNU_EXTENSIONS_ALLOWED */</a>
<a name="6762"><span class="lineNum">    6762 </span>            : #if SUN_EXTENSIONS_ALLOWED</a>
<a name="6763"><span class="lineNum">    6763 </span>            : #if (BACK_END_IS_C_GEN_BE &amp;&amp; C_GEN_BE_GENERATES_ANSI_C) || \</a>
<a name="6764"><span class="lineNum">    6764 </span>            :     BACK_END_IS_CP_GEN_BE</a>
<a name="6765"><span class="lineNum">    6765 </span>            : </a>
<a name="6766"><span class="lineNum">    6766 </span>            : void form_sun_link_scope_specifiers(</a>
<a name="6767"><span class="lineNum">    6767 </span>            :                                  a_decl_modifier                        flags,</a>
<a name="6768"><span class="lineNum">    6768 </span>            :                                  an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6769"><span class="lineNum">    6769 </span>            : /*</a>
<a name="6770"><span class="lineNum">    6770 </span>            : Output the Sun link scope specifiers as indicated by flags (in the way</a>
<a name="6771"><span class="lineNum">    6771 </span>            : described by octl).</a>
<a name="6772"><span class="lineNum">    6772 </span>            : */</a>
<a name="6773"><span class="lineNum">    6773 </span>            : {</a>
<a name="6774"><span class="lineNum">    6774 </span>            :   if (flags &amp; DM_GLOBAL_LINK_SCOPE) {</a>
<a name="6775"><span class="lineNum">    6775 </span>            :     octl-&gt;output_str(&quot;__global &quot;, octl);</a>
<a name="6776"><span class="lineNum">    6776 </span>            :   }  /* if */</a>
<a name="6777"><span class="lineNum">    6777 </span>            :   if (flags &amp; DM_SYMBOLIC_LINK_SCOPE) {</a>
<a name="6778"><span class="lineNum">    6778 </span>            :     octl-&gt;output_str(&quot;__symbolic &quot;, octl);</a>
<a name="6779"><span class="lineNum">    6779 </span>            :   }  /* if */</a>
<a name="6780"><span class="lineNum">    6780 </span>            :   if (flags &amp; DM_HIDDEN_LINK_SCOPE) {</a>
<a name="6781"><span class="lineNum">    6781 </span>            :     octl-&gt;output_str(&quot;__hidden &quot;, octl);</a>
<a name="6782"><span class="lineNum">    6782 </span>            :   }  /* if */</a>
<a name="6783"><span class="lineNum">    6783 </span>            : }  /* form_sun_link_scope_specifiers */</a>
<a name="6784"><span class="lineNum">    6784 </span>            : </a>
<a name="6785"><span class="lineNum">    6785 </span>            : #endif /* (BACK_END_IS_C_GEN_BE &amp;&amp; C_GEN_BE_GENERATES_ANSI_C) || ... */</a>
<a name="6786"><span class="lineNum">    6786 </span>            : #endif /* SUN_EXTENSIONS_ALLOWED */</a>
<a name="6787"><span class="lineNum">    6787 </span>            : #if BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE</a>
<a name="6788"><span class="lineNum">    6788 </span>            : </a>
<a name="6789"><span class="lineNum">    6789 </span><span class="lineNoCov">          0 : void push_function_prototype(a_func_prototype_stack_entry_ptr       fpsep,</span></a>
<a name="6790"><span class="lineNum">    6790 </span>            :                              an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6791"><span class="lineNum">    6791 </span>            : /*</a>
<a name="6792"><span class="lineNum">    6792 </span>            : Add the given function prototype stack entry on top of the function prototype</a>
<a name="6793"><span class="lineNum">    6793 </span>            : stack associated with octl.</a>
<a name="6794"><span class="lineNum">    6794 </span>            : */</a>
<a name="6795"><span class="lineNum">    6795 </span>            : {</a>
<a name="6796"><span class="lineNum">    6796 </span><span class="lineNoCov">          0 :   fpsep-&gt;next = octl-&gt;func_prototype_stack;</span></a>
<a name="6797"><span class="lineNum">    6797 </span><span class="lineNoCov">          0 :   octl-&gt;func_prototype_stack = fpsep;</span></a>
<a name="6798"><span class="lineNum">    6798 </span><span class="lineNoCov">          0 : }  /* push_function_prototype */</span></a>
<a name="6799"><span class="lineNum">    6799 </span>            : </a>
<a name="6800"><span class="lineNum">    6800 </span>            : </a>
<a name="6801"><span class="lineNum">    6801 </span><span class="lineNoCov">          0 : void pop_function_prototype(an_il_to_str_output_control_block_ptr  octl)</span></a>
<a name="6802"><span class="lineNum">    6802 </span>            : /*</a>
<a name="6803"><span class="lineNum">    6803 </span>            : Pop a function prototype stack entry from the top of the function prototype</a>
<a name="6804"><span class="lineNum">    6804 </span>            : stack associated with octl.</a>
<a name="6805"><span class="lineNum">    6805 </span>            : */</a>
<a name="6806"><span class="lineNum">    6806 </span>            : {</a>
<a name="6807"><span class="lineNum">    6807 </span><span class="lineNoCov">          0 :   check_assertion(octl-&gt;func_prototype_stack != NULL);</span></a>
<a name="6808"><span class="lineNum">    6808 </span><span class="lineNoCov">          0 :   octl-&gt;func_prototype_stack = octl-&gt;func_prototype_stack-&gt;next;</span></a>
<a name="6809"><span class="lineNum">    6809 </span><span class="lineNoCov">          0 : }  /* pop_function_prototype */</span></a>
<a name="6810"><span class="lineNum">    6810 </span>            : </a>
<a name="6811"><span class="lineNum">    6811 </span>            : </a>
<a name="6812"><span class="lineNum">    6812 </span><span class="lineNoCov">          0 : a_param_type_ptr get_param_for_param_ref(</span></a>
<a name="6813"><span class="lineNum">    6813 </span>            :                                       an_expr_node_ptr                  expr,</a>
<a name="6814"><span class="lineNum">    6814 </span>            :                                       a_func_prototype_stack_entry_ptr  fpsep)</a>
<a name="6815"><span class="lineNum">    6815 </span>            : /*</a>
<a name="6816"><span class="lineNum">    6816 </span>            : Return the a_param_type entry indicated by the given enk_param_ref node expr</a>
<a name="6817"><span class="lineNum">    6817 </span>            : for the function prototype scope context described by fpsep.</a>
<a name="6818"><span class="lineNum">    6818 </span>            : */</a>
<a name="6819"><span class="lineNum">    6819 </span>            : {</a>
<a name="6820"><span class="lineNum">    6820 </span><span class="lineNoCov">          0 :   unsigned          k, levels_up = expr-&gt;variant.param_ref.levels_up;</span></a>
<a name="6821"><span class="lineNum">    6821 </span><span class="lineNoCov">          0 :   a_param_type_ptr  ptp;</span></a>
<a name="6822"><span class="lineNum">    6822 </span>            : </a>
<a name="6823"><span class="lineNum">    6823 </span>            :   /* enk_param_ref nodes representing &quot;this&quot; should not get here. */</a>
<a name="6824"><span class="lineNum">    6824 </span><span class="lineNoCov">          0 :   check_assertion(fpsep != NULL &amp;&amp;</span></a>
<a name="6825"><span class="lineNum">    6825 </span>            :                   expr-&gt;kind == (an_expr_node_kind)enk_param_ref &amp;&amp;</a>
<a name="6826"><span class="lineNum">    6826 </span>            :                   expr-&gt;variant.param_ref.param_num != 0);</a>
<a name="6827"><span class="lineNum">    6827 </span><span class="lineNoCov">          0 :   if (levels_up == 0) {</span></a>
<a name="6828"><span class="lineNum">    6828 </span>            :     /* We're outside the parameter list containing the parameter of interest,</a>
<a name="6829"><span class="lineNum">    6829 </span>            :        but we may be inside a parameter list of a function declarator appearing</a>
<a name="6830"><span class="lineNum">    6830 </span>            :        in a type-id.  For example:</a>
<a name="6831"><span class="lineNum">    6831 </span>            :          template&lt;class T&gt; struct S {};</a>
<a name="6832"><span class="lineNum">    6832 </span>            :          auto f(int p) -&gt; S&lt;void (decltype(p))&gt;;</a>
<a name="6833"><span class="lineNum">    6833 </span>            :        Here, levels_up is 0, but fpsep represents the function declarator in</a>
<a name="6834"><span class="lineNum">    6834 </span>            :        the template argument for S&lt;...&gt;.  Skip any such prototypes. */</a>
<a name="6835"><span class="lineNum">    6835 </span><span class="lineNoCov">          0 :     while (!fpsep-&gt;outside_parameter_list) {</span></a>
<a name="6836"><span class="lineNum">    6836 </span><span class="lineNoCov">          0 :       fpsep = fpsep-&gt;next;</span></a>
<a name="6837"><span class="lineNum">    6837 </span>            :     }  /* if */</a>
<a name="6838"><span class="lineNum">    6838 </span><span class="lineNoCov">          0 :   } else if (!fpsep-&gt;outside_parameter_list) {</span></a>
<a name="6839"><span class="lineNum">    6839 </span>            :     /* levels_up includes the function prototype enclosing the parameter of</a>
<a name="6840"><span class="lineNum">    6840 </span>            :        interest.  Since we only want to skip to that level, decrease the count</a>
<a name="6841"><span class="lineNum">    6841 </span>            :        by one. */</a>
<a name="6842"><span class="lineNum">    6842 </span><span class="lineNoCov">          0 :     levels_up -= 1;</span></a>
<a name="6843"><span class="lineNum">    6843 </span>            :   }  /* if */</a>
<a name="6844"><span class="lineNum">    6844 </span><span class="lineNoCov">          0 :   for (k = 0; k&lt;levels_up; ++k) {</span></a>
<a name="6845"><span class="lineNum">    6845 </span><span class="lineNoCov">          0 :     fpsep = fpsep-&gt;next;</span></a>
<a name="6846"><span class="lineNum">    6846 </span><span class="lineNoCov">          0 :     check_assertion(fpsep != NULL);</span></a>
<a name="6847"><span class="lineNum">    6847 </span>            :   }  /* for */</a>
<a name="6848"><span class="lineNum">    6848 </span><span class="lineNoCov">          0 :   check_assertion(fpsep-&gt;function_type-&gt;kind == (a_type_kind)tk_routine);</span></a>
<a name="6849"><span class="lineNum">    6849 </span><span class="lineNoCov">          0 :   ptp = fpsep-&gt;function_type-&gt;variant.routine.extra_info-&gt;param_type_list;</span></a>
<a name="6850"><span class="lineNum">    6850 </span><span class="lineNoCov">          0 :   check_assertion(ptp != NULL);</span></a>
<a name="6851"><span class="lineNum">    6851 </span><span class="lineNoCov">          0 :   for (k = 1; k&lt;expr-&gt;variant.param_ref.param_num; ++k) {</span></a>
<a name="6852"><span class="lineNum">    6852 </span><span class="lineNoCov">          0 :     ptp = ptp-&gt;next;</span></a>
<a name="6853"><span class="lineNum">    6853 </span><span class="lineNoCov">          0 :     check_assertion(ptp != NULL);</span></a>
<a name="6854"><span class="lineNum">    6854 </span>            :   }  /* for */</a>
<a name="6855"><span class="lineNum">    6855 </span><span class="lineNoCov">          0 :   return ptp;</span></a>
<a name="6856"><span class="lineNum">    6856 </span>            : }  /* get_param_for_param_ref */</a>
<a name="6857"><span class="lineNum">    6857 </span>            : </a>
<a name="6858"><span class="lineNum">    6858 </span>            : #endif /* BACK_END_IS_C_GEN_BE || BACK_END_IS_CP_GEN_BE */</a>
<a name="6859"><span class="lineNum">    6859 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="6860"><span class="lineNum">    6860 </span>            : </a>
<a name="6861"><span class="lineNum">    6861 </span>            : void form_param_ref(an_expr_node_ptr                       expr,</a>
<a name="6862"><span class="lineNum">    6862 </span>            :                     an_il_to_str_output_control_block_ptr  octl)</a>
<a name="6863"><span class="lineNum">    6863 </span>            : /*</a>
<a name="6864"><span class="lineNum">    6864 </span>            : Render the name of the parameter described by the given enk_param_ref node.</a>
<a name="6865"><span class="lineNum">    6865 </span>            : The node itself only indicates the position and &quot;level&quot; of the parameter in</a>
<a name="6866"><span class="lineNum">    6866 </span>            : the function prototype stack.  Callers must therefore ensure that the stack</a>
<a name="6867"><span class="lineNum">    6867 </span>            : is properly maintained.  Do the output as indicated by octl.</a>
<a name="6868"><span class="lineNum">    6868 </span>            : */</a>
<a name="6869"><span class="lineNum">    6869 </span>            : {</a>
<a name="6870"><span class="lineNum">    6870 </span>            :   check_assertion(expr-&gt;kind == (an_expr_node_kind)enk_param_ref);</a>
<a name="6871"><span class="lineNum">    6871 </span>            :   if (expr-&gt;variant.param_ref.param_num == 0) {</a>
<a name="6872"><span class="lineNum">    6872 </span>            :     /* This node represents &quot;this&quot;. */</a>
<a name="6873"><span class="lineNum">    6873 </span>            :     octl-&gt;output_str(&quot;this&quot;, octl);</a>
<a name="6874"><span class="lineNum">    6874 </span>            :   } else {</a>
<a name="6875"><span class="lineNum">    6875 </span>            :     a_param_type_ptr ptp = get_param_for_param_ref(</a>
<a name="6876"><span class="lineNum">    6876 </span>            :                                             expr, octl-&gt;func_prototype_stack);</a>
<a name="6877"><span class="lineNum">    6877 </span>            :     check_assertion(ptp-&gt;name != NULL);</a>
<a name="6878"><span class="lineNum">    6878 </span>            :     octl-&gt;output_str(ptp-&gt;name, octl);</a>
<a name="6879"><span class="lineNum">    6879 </span>            :   }  /* if */</a>
<a name="6880"><span class="lineNum">    6880 </span>            : }  /* form_param_ref */</a>
<a name="6881"><span class="lineNum">    6881 </span>            : </a>
<a name="6882"><span class="lineNum">    6882 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="6883"><span class="lineNum">    6883 </span>            : </a>
<a name="6884"><span class="lineNum">    6884 </span><span class="lineCov">        320 : void il_to_str_one_time_init(void)</span></a>
<a name="6885"><span class="lineNum">    6885 </span>            : /*</a>
<a name="6886"><span class="lineNum">    6886 </span>            : One-time initialization for il_to_str static variables.</a>
<a name="6887"><span class="lineNum">    6887 </span>            : */</a>
<a name="6888"><span class="lineNum">    6888 </span>            : {</a>
<a name="6889"><span class="lineNum">    6889 </span><span class="lineCov">        320 :   template_param_map = NULL;</span></a>
<a name="6890"><span class="lineNum">    6890 </span><span class="lineCov">        320 :   template_param_map_max_level = 0;</span></a>
<a name="6891"><span class="lineNum">    6891 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="6892"><span class="lineNum">    6892 </span><span class="lineCov">        320 :   avail_template_param_mappings = NULL;</span></a>
<a name="6893"><span class="lineNum">    6893 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="6894"><span class="lineNum">    6894 </span>            : #if BACK_END_IS_C_GEN_BE</a>
<a name="6895"><span class="lineNum">    6895 </span>            : #if LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C</a>
<a name="6896"><span class="lineNum">    6896 </span>            : #if ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE</a>
<a name="6897"><span class="lineNum">    6897 </span>            :   double_for_long_double_warning_issued = FALSE;</a>
<a name="6898"><span class="lineNum">    6898 </span>            : #endif /* ISSUE_WARNING_ON_LONG_DOUBLE_AS_DOUBLE */</a>
<a name="6899"><span class="lineNum">    6899 </span>            : #endif /* LONG_DOUBLE_AS_DOUBLE_IN_GENERATED_C */</a>
<a name="6900"><span class="lineNum">    6900 </span>            : #endif /* BACK_END_IS_C_GEN_BE */</a>
<a name="6901"><span class="lineNum">    6901 </span><span class="lineCov">        320 : }  /* il_to_str_one_time_init */</span></a>
<a name="6902"><span class="lineNum">    6902 </span>            : </a>
<a name="6903"><span class="lineNum">    6903 </span>            : </a>
<a name="6904"><span class="lineNum">    6904 </span><span class="lineCov">        320 : void il_to_str_init(void)</span></a>
<a name="6905"><span class="lineNum">    6905 </span>            : /*</a>
<a name="6906"><span class="lineNum">    6906 </span>            : Initialization for il_to_str that must be performed before each source</a>
<a name="6907"><span class="lineNum">    6907 </span>            : file is processed.</a>
<a name="6908"><span class="lineNum">    6908 </span>            : */</a>
<a name="6909"><span class="lineNum">    6909 </span>            : {</a>
<a name="6910"><span class="lineNum">    6910 </span><span class="lineCov">        320 :   if (template_param_map != NULL) {</span></a>
<a name="6911"><span class="lineNum">    6911 </span>            :     /* Make sure there are no leftover mappings from previous processing. */</a>
<a name="6912"><span class="lineNum">    6912 </span>            :     a_template_param_map_level_ptr level;</a>
<a name="6913"><span class="lineNum">    6913 </span>            :     a_template_nesting_depth       depth;</a>
<a name="6914"><span class="lineNum">    6914 </span>            :     a_template_param_list_pos      pos;</a>
<a name="6915"><span class="lineNum">    6915 </span>            : </a>
<a name="6916"><span class="lineNum">    6916 </span><span class="lineNoCov">          0 :     for (depth = 0; depth &lt; template_param_map_max_level; ++depth) {</span></a>
<a name="6917"><span class="lineNum">    6917 </span><span class="lineNoCov">          0 :       level = &amp;template_param_map[depth];</span></a>
<a name="6918"><span class="lineNum">    6918 </span><span class="lineNoCov">          0 :       for (pos = 0; pos &lt; level-&gt;max_position; ++pos) {</span></a>
<a name="6919"><span class="lineNum">    6919 </span><span class="lineNoCov">          0 :         level-&gt;source_corresp[pos] = NULL;</span></a>
<a name="6920"><span class="lineNum">    6920 </span>            :       }  /* for */</a>
<a name="6921"><span class="lineNum">    6921 </span>            :     }  /* for */</a>
<a name="6922"><span class="lineNum">    6922 </span>            :   }  /* if */</a>
<a name="6923"><span class="lineNum">    6923 </span>            : #if BACK_END_IS_CP_GEN_BE</a>
<a name="6924"><span class="lineNum">    6924 </span><span class="lineCov">        320 :   saved_template_param_mappings = NULL;</span></a>
<a name="6925"><span class="lineNum">    6925 </span><span class="lineCov">        320 :   saving_template_param_mappings = FALSE;</span></a>
<a name="6926"><span class="lineNum">    6926 </span>            : #endif /* BACK_END_IS_CP_GEN_BE */</a>
<a name="6927"><span class="lineNum">    6927 </span><span class="lineCov">        320 : }  /* il_to_str_init */</span></a>
<a name="6928"><span class="lineNum">    6928 </span>            : </a>
<a name="6929"><span class="lineNum">    6929 </span>            : </a>
<a name="6930"><span class="lineNum">    6930 </span>            : /******************************************************************************</a>
<a name="6931"><span class="lineNum">    6931 </span>            : *                                                             \  ___  /       *</a>
<a name="6932"><span class="lineNum">    6932 </span>            : *                                                               /   \         *</a>
<a name="6933"><span class="lineNum">    6933 </span>            : * Edison Design Group C++/C Front End                        - | \^/ | -      *</a>
<a name="6934"><span class="lineNum">    6934 </span>            : *                                                               \   /         *</a>
<a name="6935"><span class="lineNum">    6935 </span>            : * Proprietary information of Edison Design Group Inc.         /  | |  \       *</a>
<a name="6936"><span class="lineNum">    6936 </span>            : * Copyright 1988-2018 Edison Design Group Inc.                   [_]          *</a>
<a name="6937"><span class="lineNum">    6937 </span>            : *                                                                             *</a>
<a name="6938"><span class="lineNum">    6938 </span>            : ******************************************************************************/</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
