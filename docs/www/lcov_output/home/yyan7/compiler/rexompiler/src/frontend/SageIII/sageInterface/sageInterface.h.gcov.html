<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface/sageInterface.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface</a> - sageInterface.h<span style="font-size: 80%;"> (source / <a href="sageInterface.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">91</td>
            <td class="headerCovTableEntry">99</td>
            <td class="headerCovTableEntryHi">91.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntry">58</td>
            <td class="headerCovTableEntryLo">46.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ROSE_SAGE_INTERFACE</a>
<a name="2"><span class="lineNum">       2 </span>            : #define ROSE_SAGE_INTERFACE</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            : #include &quot;sage3basic.hhh&quot;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &lt;stdint.h&gt;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;utility&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : #include &quot;rosePublicConfig.h&quot; // for ROSE_BUILD_JAVA_LANGUAGE_SUPPORT</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : #if 0   // FMZ(07/07/2010): the argument &quot;nextErrorCode&quot; should be call-by-reference</a>
<a name="11"><span class="lineNum">      11 </span>            : SgFile* determineFileType ( std::vector&lt;std::string&gt; argv, int nextErrorCode, SgProject* project );</a>
<a name="12"><span class="lineNum">      12 </span>            : #else</a>
<a name="13"><span class="lineNum">      13 </span>            : SgFile* determineFileType ( std::vector&lt;std::string&gt; argv, int&amp; nextErrorCode, SgProject* project );</a>
<a name="14"><span class="lineNum">      14 </span>            : #endif</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &quot;rewrite.h&quot;</a>
<a name="18"><span class="lineNum">      18 </span>            : #endif</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : // DQ (7/20/2008): Added support for unparsing abitrary strings in the unparser.</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;astUnparseAttribute.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;set&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;LivenessAnalysis.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &quot;abstract_handle.h&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &quot;ClassHierarchyGraph.h&quot;</a>
<a name="28"><span class="lineNum">      28 </span>            : #endif</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;ompSupport.h&quot;</a>
<a name="31"><span class="lineNum">      31 </span>            : // DQ (8/19/2004): Moved from ROSE/src/midend/astRewriteMechanism/rewrite.h</a>
<a name="32"><span class="lineNum">      32 </span>            : //! A global function for getting the string associated with an enum (which is defined in global scope)</a>
<a name="33"><span class="lineNum">      33 </span>            : ROSE_DLL_API std::string getVariantName (VariantT v);</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : // DQ (12/9/2004): Qing, Rich and Dan have decided to start this namespace within ROSE</a>
<a name="36"><span class="lineNum">      36 </span>            : // This namespace is specific to interface functions that operate on the Sage III AST.</a>
<a name="37"><span class="lineNum">      37 </span>            : // The name was chosen so as not to conflict with other classes within ROSE.</a>
<a name="38"><span class="lineNum">      38 </span>            : // This will become the future home of many interface functions which operate on</a>
<a name="39"><span class="lineNum">      39 </span>            : // the AST and which are generally useful to users.  As a namespace multiple files can be used</a>
<a name="40"><span class="lineNum">      40 </span>            : // to represent the compete interface and different developers may contribute interface</a>
<a name="41"><span class="lineNum">      41 </span>            : // functions easily.</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            : // Constructor handling: (We have sageBuilder.h now for this purpose, Liao 2/1/2008)</a>
<a name="44"><span class="lineNum">      44 </span>            : //     We could add simpler layers of support for construction of IR nodes by</a>
<a name="45"><span class="lineNum">      45 </span>            : // hiding many details in &quot;makeSg***()&quot; functions. Such functions would</a>
<a name="46"><span class="lineNum">      46 </span>            : // return pointers to the associated Sg*** objects and would be able to hide</a>
<a name="47"><span class="lineNum">      47 </span>            : // many IR specific details, including:</a>
<a name="48"><span class="lineNum">      48 </span>            : //      memory handling</a>
<a name="49"><span class="lineNum">      49 </span>            : //      optional parameter settings not often required</a>
<a name="50"><span class="lineNum">      50 </span>            : //      use of Sg_File_Info objects (and setting them as transformations)</a>
<a name="51"><span class="lineNum">      51 </span>            : //</a>
<a name="52"><span class="lineNum">      52 </span>            : // namespace AST_Interface  (this name is taken already by some of Qing's work :-)</a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<a name="54"><span class="lineNum">      54 </span>            : //! An alias for Sg_File_Info::generateDefaultFileInfoForTransformationNode()</a>
<a name="55"><span class="lineNum">      55 </span>            : #define TRANS_FILE Sg_File_Info::generateDefaultFileInfoForTransformationNode()</a>
<a name="56"><span class="lineNum">      56 </span>            : </a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span>            : /** Functions that are useful when operating on the AST.</a>
<a name="59"><span class="lineNum">      59 </span>            :  *</a>
<a name="60"><span class="lineNum">      60 </span>            :  *  The Sage III IR design attempts to be minimalist. Thus additional functionality is intended to be presented using separate</a>
<a name="61"><span class="lineNum">      61 </span>            :  *  higher level interfaces which work with the IR.  This namespace collects functions that operate on the IR and support</a>
<a name="62"><span class="lineNum">      62 </span>            :  *  numerous types of operations that are common to general analysis and transformation of the AST. */</a>
<a name="63"><span class="lineNum">      63 </span>            : namespace SageInterface</a>
<a name="64"><span class="lineNum">      64 </span>            :    {</a>
<a name="65"><span class="lineNum">      65 </span>            :   // Liao 6/22/2016: keep records of loop init-stmt normalization, later help undo it to support autoPar.</a>
<a name="66"><span class="lineNum">      66 </span>            :   struct Transformation_Record</a>
<a name="67"><span class="lineNum">      67 </span>            :   {</a>
<a name="68"><span class="lineNum">      68 </span>            :     // a lookup table to check if a for loop has been normalized for its c99-style init-stmt</a>
<a name="69"><span class="lineNum">      69 </span>            :     std::map &lt;SgForStatement* , bool &gt; forLoopInitNormalizationTable;</a>
<a name="70"><span class="lineNum">      70 </span>            :     // Detailed record about the original declaration (1st in the pair) and the normalization generated new declaration (2nd in the pair)</a>
<a name="71"><span class="lineNum">      71 </span>            :     std::map &lt;SgForStatement* , std::pair&lt;SgVariableDeclaration*, SgVariableDeclaration*&gt;  &gt;  forLoopInitNormalizationRecord;</a>
<a name="72"><span class="lineNum">      72 </span>            :   } ;</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            :   ROSE_DLL_API extern Transformation_Record trans_records;</a>
<a name="75"><span class="lineNum">      75 </span>            : </a>
<a name="76"><span class="lineNum">      76 </span>            :   // DQ (4/3/2014): Added general AST support separate from the AST.</a>
<a name="77"><span class="lineNum">      77 </span>            : </a>
<a name="78"><span class="lineNum">      78 </span>            :   // Container and API for analysis information that is outside of the AST and as a result</a>
<a name="79"><span class="lineNum">      79 </span>            :   // prevents frequent modification of the IR.</a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">         66 :      class DeclarationSets</span></a>
<a name="81"><span class="lineNum">      81 </span>            :         {</a>
<a name="82"><span class="lineNum">      82 </span>            :        // DQ (4/3/2014): This stores all associated declarations as a map of sets.</a>
<a name="83"><span class="lineNum">      83 </span>            :        // the key to the map is the first nondefining declaration and the elements of the set are</a>
<a name="84"><span class="lineNum">      84 </span>            :        // all of the associated declarations (including the defining declaration).</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :           private:</a>
<a name="87"><span class="lineNum">      87 </span>            :            //! Map of first-nondefining declaration to all other associated declarations.</a>
<a name="88"><span class="lineNum">      88 </span>            :                std::map&lt;SgDeclarationStatement*,std::set&lt;SgDeclarationStatement*&gt;* &gt; declarationMap;</a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            :           public:</a>
<a name="91"><span class="lineNum">      91 </span>            :                void addDeclaration(SgDeclarationStatement* decl);</a>
<a name="92"><span class="lineNum">      92 </span>            :                const std::set&lt;SgDeclarationStatement*&gt;* getDeclarations(SgDeclarationStatement* decl);</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :                std::map&lt;SgDeclarationStatement*,std::set&lt;SgDeclarationStatement*&gt;* &gt; &amp; getDeclarationMap();</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span>            :                bool isLocatedInDefiningScope(SgDeclarationStatement* decl);</a>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<a name="98"><span class="lineNum">      98 </span>            :         };</a>
<a name="99"><span class="lineNum">      99 </span>            : </a>
<a name="100"><span class="lineNum">     100 </span>            :   // DQ (4/3/2014): This constructs a data structure that holds analysis information about</a>
<a name="101"><span class="lineNum">     101 </span>            :   // the AST that is separate from the AST.  This is intended to be a general mechanism</a>
<a name="102"><span class="lineNum">     102 </span>            :   // to support analysis information without constantly modifying the IR.</a>
<a name="103"><span class="lineNum">     103 </span>            :      DeclarationSets* buildDeclarationSets(SgNode*);</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            : //! An internal counter for generating unique SgName</a>
<a name="106"><span class="lineNum">     106 </span>            : ROSE_DLL_API extern int gensym_counter;</a>
<a name="107"><span class="lineNum">     107 </span>            : </a>
<a name="108"><span class="lineNum">     108 </span>            : //! Function to add &quot;C&quot; style comment to statement.</a>
<a name="109"><span class="lineNum">     109 </span>            :  void addMessageStatement( SgStatement* stmt, std::string message );</a>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<a name="111"><span class="lineNum">     111 </span>            : //! A persistent attribute to represent a unique name for an expression</a>
<a name="112"><span class="lineNum">     112 </span>            :   class UniqueNameAttribute : public AstAttribute</a>
<a name="113"><span class="lineNum">     113 </span>            :   {</a>
<a name="114"><span class="lineNum">     114 </span>            :     private:</a>
<a name="115"><span class="lineNum">     115 </span>            :      std::string name;</a>
<a name="116"><span class="lineNum">     116 </span>            :     public:</a>
<a name="117"><span class="lineNum">     117 </span><span class="lineCov">          8 :      UniqueNameAttribute(std::string n=&quot;&quot;) {name =n; };</span></a>
<a name="118"><span class="lineNum">     118 </span>            :      void set_name (std::string n) {name = n;};</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :      std::string get_name () {return name;};</span></a>
<a name="120"><span class="lineNum">     120 </span>            :   };</a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span>            :  //------------------------------------------------------------------------</a>
<a name="123"><span class="lineNum">     123 </span>            :  //@{</a>
<a name="124"><span class="lineNum">     124 </span>            :  /*! @name Symbol tables</a>
<a name="125"><span class="lineNum">     125 </span>            :    \brief  utility functions for symbol tables</a>
<a name="126"><span class="lineNum">     126 </span>            :  */</a>
<a name="127"><span class="lineNum">     127 </span>            : </a>
<a name="128"><span class="lineNum">     128 </span>            : // DQ (8/5/2020): the &quot;using namespace&quot; directive will not hide existing visability of symbols in resolving visability.</a>
<a name="129"><span class="lineNum">     129 </span>            : // So we need to test if a symbol is visible exclusing matching alises due to using direectives before we can decide to</a>
<a name="130"><span class="lineNum">     130 </span>            : // persue name space qualification. This is best demonstrated by Cxx_tests/test2020_18.C, test2020_19.C, test2020_20.C,</a>
<a name="131"><span class="lineNum">     131 </span>            : // and test2020_21.C.</a>
<a name="132"><span class="lineNum">     132 </span>            :    ROSE_DLL_API SgSymbol *lookupSymbolInParentScopesIgnoringAliasSymbols (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL);</a>
<a name="133"><span class="lineNum">     133 </span>            : </a>
<a name="134"><span class="lineNum">     134 </span>            : // DQ (8/21/2013): Modified to make newest function parameters be default arguments.</a>
<a name="135"><span class="lineNum">     135 </span>            : // DQ (8/16/2013): For now we want to remove the use of default parameters and add the support for template parameters and template arguments.</a>
<a name="136"><span class="lineNum">     136 </span>            :    //! Find a symbol in current and ancestor scopes for a given variable name, starting from top of ScopeStack if currentscope is not given or NULL.</a>
<a name="137"><span class="lineNum">     137 </span>            : // SgSymbol *lookupSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope=NULL);</a>
<a name="138"><span class="lineNum">     138 </span>            : // SgSymbol *lookupSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList);</a>
<a name="139"><span class="lineNum">     139 </span>            :    ROSE_DLL_API SgSymbol *lookupSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL);</a>
<a name="140"><span class="lineNum">     140 </span>            : </a>
<a name="141"><span class="lineNum">     141 </span>            :    // Liao 1/22/2008, used for get symbols for generating variable reference nodes</a>
<a name="142"><span class="lineNum">     142 </span>            :    // ! Find a variable symbol in current and ancestor scopes for a given name</a>
<a name="143"><span class="lineNum">     143 </span>            :    ROSE_DLL_API SgVariableSymbol *lookupVariableSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope=NULL);</a>
<a name="144"><span class="lineNum">     144 </span>            : </a>
<a name="145"><span class="lineNum">     145 </span>            :    // DQ (11/24/2007): Functions moved from the Fortran support so that they could be called from within astPostProcessing.</a>
<a name="146"><span class="lineNum">     146 </span>            :    //!look up the first matched function symbol in parent scopes given only a function name, starting from top of ScopeStack if currentscope is not given or NULL</a>
<a name="147"><span class="lineNum">     147 </span>            :    ROSE_DLL_API SgFunctionSymbol *lookupFunctionSymbolInParentScopes (const SgName &amp; functionName, SgScopeStatement *currentScope=NULL);</a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            :    // Liao, 1/24/2008, find exact match for a function</a>
<a name="150"><span class="lineNum">     150 </span>            :    //!look up function symbol in parent scopes given both name and function type, starting from top of ScopeStack if currentscope is not given or NULL</a>
<a name="151"><span class="lineNum">     151 </span>            :    ROSE_DLL_API SgFunctionSymbol *lookupFunctionSymbolInParentScopes (const SgName &amp;  functionName,</a>
<a name="152"><span class="lineNum">     152 </span>            :                                                          const SgType* t,</a>
<a name="153"><span class="lineNum">     153 </span>            :                                                          SgScopeStatement *currentScope=NULL);</a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :    ROSE_DLL_API SgFunctionSymbol *lookupTemplateFunctionSymbolInParentScopes (const SgName &amp; functionName, SgFunctionType * ftype, SgTemplateParameterPtrList * tplparams, SgScopeStatement *currentScope=NULL);</a>
<a name="156"><span class="lineNum">     156 </span>            :    ROSE_DLL_API SgFunctionSymbol *lookupTemplateMemberFunctionSymbolInParentScopes (const SgName &amp; functionName, SgFunctionType * ftype, SgTemplateParameterPtrList * tplparams, SgScopeStatement *currentScope=NULL);</a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span>            :    ROSE_DLL_API SgTemplateVariableSymbol * lookupTemplateVariableSymbolInParentScopes (const SgName &amp; name, SgTemplateParameterPtrList * tplparams, SgTemplateArgumentPtrList* tplargs, SgScopeStatement *currentScope=NULL);</a>
<a name="159"><span class="lineNum">     159 </span>            : </a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            : // DQ (8/21/2013): Modified to make newest function parameters be default arguments.</a>
<a name="162"><span class="lineNum">     162 </span>            : // DQ (8/16/2013): For now we want to remove the use of default parameters and add the support for template parameters and template arguments.</a>
<a name="163"><span class="lineNum">     163 </span>            : // DQ (5/7/2011): Added support for SgClassSymbol (used in name qualification support).</a>
<a name="164"><span class="lineNum">     164 </span>            : // SgClassSymbol*     lookupClassSymbolInParentScopes    (const SgName &amp; name, SgScopeStatement *currentScope = NULL);</a>
<a name="165"><span class="lineNum">     165 </span>            :    ROSE_DLL_API SgClassSymbol*     lookupClassSymbolInParentScopes    (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL);</a>
<a name="166"><span class="lineNum">     166 </span>            :    ROSE_DLL_API SgTypedefSymbol*   lookupTypedefSymbolInParentScopes  (const SgName &amp; name, SgScopeStatement *currentScope = NULL);</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            :    ROSE_DLL_API SgNonrealSymbol*   lookupNonrealSymbolInParentScopes  (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL);</a>
<a name="169"><span class="lineNum">     169 </span>            : #if 0</a>
<a name="170"><span class="lineNum">     170 </span>            :  // DQ (8/13/2013): This function does not make since any more, now that we have made the symbol</a>
<a name="171"><span class="lineNum">     171 </span>            :  // table handling more precise and we have to provide template parameters for any template lookup.</a>
<a name="172"><span class="lineNum">     172 </span>            :  // We also have to know if we want to lookup template classes, template functions, or template</a>
<a name="173"><span class="lineNum">     173 </span>            :  // member functions (since each have specific requirements).</a>
<a name="174"><span class="lineNum">     174 </span>            :    SgTemplateSymbol*  lookupTemplateSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope = NULL);</a>
<a name="175"><span class="lineNum">     175 </span>            : #endif</a>
<a name="176"><span class="lineNum">     176 </span>            : #if 0</a>
<a name="177"><span class="lineNum">     177 </span>            : // DQ (8/13/2013): I am not sure if we want this functions in place of lookupTemplateSymbolInParentScopes.</a>
<a name="178"><span class="lineNum">     178 </span>            : // Where these are called we might not know enough information about the template parameters or function</a>
<a name="179"><span class="lineNum">     179 </span>            : // types, for example.</a>
<a name="180"><span class="lineNum">     180 </span>            :    SgTemplateClassSymbol*           lookupTemplateClassSymbolInParentScopes          (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL);</a>
<a name="181"><span class="lineNum">     181 </span>            :    SgTemplateFunctionSymbol*        lookupTemplateFunctionSymbolInParentScopes       (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL);</a>
<a name="182"><span class="lineNum">     182 </span>            :    SgTemplateMemberFunctionSymbol*  lookupTemplateMemberFunctionSymbolInParentScopes (const SgName &amp; name, SgScopeStatement *currentScope = NULL, SgTemplateParameterPtrList* templateParameterList = NULL);</a>
<a name="183"><span class="lineNum">     183 </span>            : #endif</a>
<a name="184"><span class="lineNum">     184 </span>            : </a>
<a name="185"><span class="lineNum">     185 </span>            : // DQ (8/21/2013): Modified to make some of the newest function parameters be default arguments.</a>
<a name="186"><span class="lineNum">     186 </span>            : // DQ (8/13/2013): I am not sure if we want this functions in place of lookupTemplateSymbolInParentScopes.</a>
<a name="187"><span class="lineNum">     187 </span>            :    ROSE_DLL_API SgTemplateClassSymbol* lookupTemplateClassSymbolInParentScopes (const SgName &amp;  name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, SgScopeStatement *cscope = NULL);</a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :    ROSE_DLL_API SgEnumSymbol*      lookupEnumSymbolInParentScopes     (const SgName &amp; name, SgScopeStatement *currentScope = NULL);</a>
<a name="190"><span class="lineNum">     190 </span>            :    ROSE_DLL_API SgNamespaceSymbol* lookupNamespaceSymbolInParentScopes(const SgName &amp; name, SgScopeStatement *currentScope = NULL);</a>
<a name="191"><span class="lineNum">     191 </span>            : </a>
<a name="192"><span class="lineNum">     192 </span>            : // DQ (7/17/2011): Added function from cxx branch that I need here for the Java support.</a>
<a name="193"><span class="lineNum">     193 </span>            : // SgClassSymbol* lookupClassSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope);</a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span>            :    /*! \brief set_name of symbol in symbol table.</a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            :        This function extracts the symbol from the relavant symbol table,</a>
<a name="198"><span class="lineNum">     198 </span>            :        changes the name (at the declaration) and reinserts it into the</a>
<a name="199"><span class="lineNum">     199 </span>            :        symbol table.</a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span>            :        \internal  I think this is what this function does, I need to double check.</a>
<a name="202"><span class="lineNum">     202 </span>            :     */</a>
<a name="203"><span class="lineNum">     203 </span>            :    // DQ (12/9/2004): Moved this function (by Alin Jula) from being a member of SgInitializedName</a>
<a name="204"><span class="lineNum">     204 </span>            :    // to this location where it can be a part of the interface for the Sage III AST.</a>
<a name="205"><span class="lineNum">     205 </span>            :    ROSE_DLL_API int set_name (SgInitializedName * initializedNameNode, SgName new_name);</a>
<a name="206"><span class="lineNum">     206 </span>            : </a>
<a name="207"><span class="lineNum">     207 </span>            :    /*! \brief Output function type symbols in global function type symbol table.</a>
<a name="208"><span class="lineNum">     208 </span>            :     */</a>
<a name="209"><span class="lineNum">     209 </span>            :    void outputGlobalFunctionTypeSymbolTable ();</a>
<a name="210"><span class="lineNum">     210 </span>            : </a>
<a name="211"><span class="lineNum">     211 </span>            :    // DQ (6/27/2005):</a>
<a name="212"><span class="lineNum">     212 </span>            :    /*! \brief Output the local symbol tables.</a>
<a name="213"><span class="lineNum">     213 </span>            : </a>
<a name="214"><span class="lineNum">     214 </span>            :        \implementation Each symbol table is output with the file infor where it is located in the source code.</a>
<a name="215"><span class="lineNum">     215 </span>            :     */</a>
<a name="216"><span class="lineNum">     216 </span>            :    ROSE_DLL_API void outputLocalSymbolTables (SgNode * node);</a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">          1 :    class OutputLocalSymbolTables:public AstSimpleProcessing</span></a>
<a name="219"><span class="lineNum">     219 </span>            :          {</a>
<a name="220"><span class="lineNum">     220 </span>            :            public:</a>
<a name="221"><span class="lineNum">     221 </span>            :      void visit (SgNode * node);</a>
<a name="222"><span class="lineNum">     222 </span>            :          };</a>
<a name="223"><span class="lineNum">     223 </span>            :    /*! \brief Regenerate the symbol table.</a>
<a name="224"><span class="lineNum">     224 </span>            : </a>
<a name="225"><span class="lineNum">     225 </span>            :       \implementation current symbol table must be NULL pointer before calling this</a>
<a name="226"><span class="lineNum">     226 </span>            :       function (for safety, but is this a good idea?)</a>
<a name="227"><span class="lineNum">     227 </span>            :     */</a>
<a name="228"><span class="lineNum">     228 </span>            :    // DQ (9/28/2005):</a>
<a name="229"><span class="lineNum">     229 </span>            :    void rebuildSymbolTable (SgScopeStatement * scope);</a>
<a name="230"><span class="lineNum">     230 </span>            : </a>
<a name="231"><span class="lineNum">     231 </span>            :    /*! \brief Clear those variable symbols with unknown type (together with initialized names) which are also not referenced by any variable references or declarations under root. If root is NULL, all symbols with unknown type will be deleted.</a>
<a name="232"><span class="lineNum">     232 </span>            :     */</a>
<a name="233"><span class="lineNum">     233 </span>            :    void clearUnusedVariableSymbols (SgNode* root = NULL);</a>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<a name="235"><span class="lineNum">     235 </span>            :    // DQ (3/1/2009):</a>
<a name="236"><span class="lineNum">     236 </span>            :    //! All the symbol table references in the copied AST need to be reset after rebuilding the copied scope's symbol table.</a>
<a name="237"><span class="lineNum">     237 </span>            :    void fixupReferencesToSymbols( const SgScopeStatement* this_scope,  SgScopeStatement* copy_scope, SgCopyHelp &amp; help );</a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<a name="239"><span class="lineNum">     239 </span>            :  //@}</a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            :  //------------------------------------------------------------------------</a>
<a name="242"><span class="lineNum">     242 </span>            :  //@{</a>
<a name="243"><span class="lineNum">     243 </span>            :  /*! @name Stringify</a>
<a name="244"><span class="lineNum">     244 </span>            :    \brief Generate a useful string (name) to describe a SgNode</a>
<a name="245"><span class="lineNum">     245 </span>            :  */</a>
<a name="246"><span class="lineNum">     246 </span>            :    /*! \brief Generate a useful name to describe the SgNode</a>
<a name="247"><span class="lineNum">     247 </span>            : </a>
<a name="248"><span class="lineNum">     248 </span>            :        \internal default names are used for SgNode objects that can not be associated with a name.</a>
<a name="249"><span class="lineNum">     249 </span>            :     */</a>
<a name="250"><span class="lineNum">     250 </span>            :    // DQ (9/21/2005): General function for extracting the name of declarations (when they have names)</a>
<a name="251"><span class="lineNum">     251 </span>            :      std::string get_name (const SgNode * node);</a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span>            :    /*! \brief Generate a useful name to describe the declaration</a>
<a name="254"><span class="lineNum">     254 </span>            : </a>
<a name="255"><span class="lineNum">     255 </span>            :        \internal default names are used for declarations that can not be associated with a name.</a>
<a name="256"><span class="lineNum">     256 </span>            :     */</a>
<a name="257"><span class="lineNum">     257 </span>            :    // DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</a>
<a name="258"><span class="lineNum">     258 </span>            :      std::string get_name (const SgStatement * stmt);</a>
<a name="259"><span class="lineNum">     259 </span>            : </a>
<a name="260"><span class="lineNum">     260 </span>            :    /*! \brief Generate a useful name to describe the expression</a>
<a name="261"><span class="lineNum">     261 </span>            : </a>
<a name="262"><span class="lineNum">     262 </span>            :        \internal default names are used for expressions that can not be associated with a name.</a>
<a name="263"><span class="lineNum">     263 </span>            :     */</a>
<a name="264"><span class="lineNum">     264 </span>            :      std::string get_name (const SgExpression * expr);</a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span>            :    /*! \brief Generate a useful name to describe the declaration</a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span>            :        \internal default names are used for declarations that can not be associated with a name.</a>
<a name="269"><span class="lineNum">     269 </span>            :     */</a>
<a name="270"><span class="lineNum">     270 </span>            :    // DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</a>
<a name="271"><span class="lineNum">     271 </span>            :      std::string get_name (const SgDeclarationStatement * declaration);</a>
<a name="272"><span class="lineNum">     272 </span>            : </a>
<a name="273"><span class="lineNum">     273 </span>            :    /*! \brief Generate a useful name to describe the scope</a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span>            :        \internal default names are used for scope that cannot be associated with a name.</a>
<a name="276"><span class="lineNum">     276 </span>            :     */</a>
<a name="277"><span class="lineNum">     277 </span>            :    // DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</a>
<a name="278"><span class="lineNum">     278 </span>            :      std::string get_name (const SgScopeStatement * scope);</a>
<a name="279"><span class="lineNum">     279 </span>            : </a>
<a name="280"><span class="lineNum">     280 </span>            :    /*! \brief Generate a useful name to describe the SgSymbol</a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            :        \internal default names are used for SgSymbol objects that cannot be associated with a name.</a>
<a name="283"><span class="lineNum">     283 </span>            :     */</a>
<a name="284"><span class="lineNum">     284 </span>            :    // DQ (2/11/2007): Added this function to make debugging support more complete (useful for symbol table debugging support).</a>
<a name="285"><span class="lineNum">     285 </span>            :      std::string get_name (const SgSymbol * symbol);</a>
<a name="286"><span class="lineNum">     286 </span>            : </a>
<a name="287"><span class="lineNum">     287 </span>            :    /*! \brief Generate a useful name to describe the SgType</a>
<a name="288"><span class="lineNum">     288 </span>            : </a>
<a name="289"><span class="lineNum">     289 </span>            :        \internal default names are used for SgType objects that cannot be associated with a name.</a>
<a name="290"><span class="lineNum">     290 </span>            :     */</a>
<a name="291"><span class="lineNum">     291 </span>            :      std::string get_name (const SgType * type);</a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span>            : </a>
<a name="294"><span class="lineNum">     294 </span>            :    /*! \brief Generate a useful name to describe the SgSupport IR node</a>
<a name="295"><span class="lineNum">     295 </span>            :     */</a>
<a name="296"><span class="lineNum">     296 </span>            :      std::string get_name (const SgSupport * node);</a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span>            : </a>
<a name="299"><span class="lineNum">     299 </span>            :    /*! \brief Generate a useful name to describe the SgLocatedNodeSupport IR node</a>
<a name="300"><span class="lineNum">     300 </span>            :     */</a>
<a name="301"><span class="lineNum">     301 </span>            :      std::string get_name (const SgLocatedNodeSupport * node);</a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span>            :    /*! \brief Generate a useful name to describe the SgC_PreprocessorDirectiveStatement IR node</a>
<a name="304"><span class="lineNum">     304 </span>            :     */</a>
<a name="305"><span class="lineNum">     305 </span>            :      std::string get_name ( const SgC_PreprocessorDirectiveStatement* directive );</a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span>            :    /*! \brief Generate a useful name to describe the SgToken IR node</a>
<a name="308"><span class="lineNum">     308 </span>            :     */</a>
<a name="309"><span class="lineNum">     309 </span>            :      std::string get_name ( const SgToken* token );</a>
<a name="310"><span class="lineNum">     310 </span>            : </a>
<a name="311"><span class="lineNum">     311 </span>            :    /*! \brief Returns the type introduced by a declaration.</a>
<a name="312"><span class="lineNum">     312 </span>            :     */</a>
<a name="313"><span class="lineNum">     313 </span>            :    // PP (11/22/2021): General function for extracting the type of declarations (when they declare types)</a>
<a name="314"><span class="lineNum">     314 </span>            :      SgType* getDeclaredType(const SgDeclarationStatement* declaration);</a>
<a name="315"><span class="lineNum">     315 </span>            : </a>
<a name="316"><span class="lineNum">     316 </span>            : </a>
<a name="317"><span class="lineNum">     317 </span>            :   // DQ (3/20/2016): Added to refactor some of the DSL infrastructure support.</a>
<a name="318"><span class="lineNum">     318 </span>            :    /*! \brief Generate a useful name to support construction of identifiers from declarations.</a>
<a name="319"><span class="lineNum">     319 </span>            : </a>
<a name="320"><span class="lineNum">     320 </span>            :        This function permits names to be generated that will be unique across translation units</a>
<a name="321"><span class="lineNum">     321 </span>            :        (a specific requirement different from the context of the get_name() functions above).</a>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<a name="323"><span class="lineNum">     323 </span>            :        \internal This supports only a restricted set of declarations presently.</a>
<a name="324"><span class="lineNum">     324 </span>            :     */</a>
<a name="325"><span class="lineNum">     325 </span>            :      std::string generateUniqueNameForUseAsIdentifier ( SgDeclarationStatement* declaration );</a>
<a name="326"><span class="lineNum">     326 </span>            :      std::string generateUniqueNameForUseAsIdentifier_support ( SgDeclarationStatement* declaration );</a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            :    /*! \brief Global map of name collisions to support generateUniqueNameForUseAsIdentifier() function.</a>
<a name="329"><span class="lineNum">     329 </span>            :     */</a>
<a name="330"><span class="lineNum">     330 </span>            :      extern std::map&lt;std::string,int&gt;     local_name_collision_map;</a>
<a name="331"><span class="lineNum">     331 </span>            :      extern std::map&lt;std::string,SgNode*&gt; local_name_to_node_map;</a>
<a name="332"><span class="lineNum">     332 </span>            :      extern std::map&lt;SgNode*,std::string&gt; local_node_to_name_map;</a>
<a name="333"><span class="lineNum">     333 </span>            : </a>
<a name="334"><span class="lineNum">     334 </span>            :    /*! \brief Traversal to set the global map of names to node and node to names.collisions to support generateUniqueNameForUseAsIdentifier() function.</a>
<a name="335"><span class="lineNum">     335 </span>            :     */</a>
<a name="336"><span class="lineNum">     336 </span>            :      void computeUniqueNameForUseAsIdentifier( SgNode* astNode );</a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span>            :    /*! \brief Reset map variables used to support generateUniqueNameForUseAsIdentifier() function.</a>
<a name="339"><span class="lineNum">     339 </span>            :     */</a>
<a name="340"><span class="lineNum">     340 </span>            :      void reset_name_collision_map();</a>
<a name="341"><span class="lineNum">     341 </span>            : </a>
<a name="342"><span class="lineNum">     342 </span>            :  //@}</a>
<a name="343"><span class="lineNum">     343 </span>            : </a>
<a name="344"><span class="lineNum">     344 </span>            :  //------------------------------------------------------------------------</a>
<a name="345"><span class="lineNum">     345 </span>            :  //@{</a>
<a name="346"><span class="lineNum">     346 </span>            :  /*! @name Class utilities</a>
<a name="347"><span class="lineNum">     347 </span>            :    \brief</a>
<a name="348"><span class="lineNum">     348 </span>            :  */</a>
<a name="349"><span class="lineNum">     349 </span>            :    /*! \brief Get the default destructor from the class declaration</a>
<a name="350"><span class="lineNum">     350 </span>            :     */</a>
<a name="351"><span class="lineNum">     351 </span>            :   // DQ (6/21/2005): Get the default destructor from the class declaration</a>
<a name="352"><span class="lineNum">     352 </span>            :      ROSE_DLL_API SgMemberFunctionDeclaration *getDefaultDestructor (SgClassDeclaration* classDeclaration);</a>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<a name="354"><span class="lineNum">     354 </span>            :    /*! \brief Get the default constructor from the class declaration</a>
<a name="355"><span class="lineNum">     355 </span>            :     */</a>
<a name="356"><span class="lineNum">     356 </span>            :    // DQ (6/22/2005): Get the default constructor from the class declaration</a>
<a name="357"><span class="lineNum">     357 </span>            :      ROSE_DLL_API SgMemberFunctionDeclaration *getDefaultConstructor (SgClassDeclaration* classDeclaration);</a>
<a name="358"><span class="lineNum">     358 </span>            :    /*! \brief Return true if template definition is in the class, false if outside of class.</a>
<a name="359"><span class="lineNum">     359 </span>            :     */</a>
<a name="360"><span class="lineNum">     360 </span>            :   // DQ (8/27/2005):</a>
<a name="361"><span class="lineNum">     361 </span>            :      ROSE_DLL_API bool templateDefinitionIsInClass (SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration);</a>
<a name="362"><span class="lineNum">     362 </span>            : </a>
<a name="363"><span class="lineNum">     363 </span>            :    /*! \brief Generate a non-defining (forward) declaration from a defining function declaration.</a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            :       \internal should put into sageBuilder ?</a>
<a name="366"><span class="lineNum">     366 </span>            :     */</a>
<a name="367"><span class="lineNum">     367 </span>            :   // DQ (9/17/2005):</a>
<a name="368"><span class="lineNum">     368 </span>            :      ROSE_DLL_API SgTemplateInstantiationMemberFunctionDecl* buildForwardFunctionDeclaration (SgTemplateInstantiationMemberFunctionDecl * memberFunctionInstantiation);</a>
<a name="369"><span class="lineNum">     369 </span>            : </a>
<a name="370"><span class="lineNum">     370 </span>            :    //! Check if a SgNode is a declaration for a structure</a>
<a name="371"><span class="lineNum">     371 </span>            :      ROSE_DLL_API bool isStructDeclaration(SgNode * node);</a>
<a name="372"><span class="lineNum">     372 </span>            :    //! Check if a SgNode is a declaration for a union</a>
<a name="373"><span class="lineNum">     373 </span>            :      ROSE_DLL_API bool isUnionDeclaration(SgNode * node);</a>
<a name="374"><span class="lineNum">     374 </span>            : </a>
<a name="375"><span class="lineNum">     375 </span>            : #if 0</a>
<a name="376"><span class="lineNum">     376 </span>            :  // DQ (8/28/2005): This is already a member function of the SgFunctionDeclaration</a>
<a name="377"><span class="lineNum">     377 </span>            :  // (so that it can handle template functions and member functions)</a>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<a name="379"><span class="lineNum">     379 </span>            :    /*! \brief Return true if member function of a template member function,</a>
<a name="380"><span class="lineNum">     380 </span>            :               of false if a non-template member function in a templated class.</a>
<a name="381"><span class="lineNum">     381 </span>            :     */</a>
<a name="382"><span class="lineNum">     382 </span>            :     // DQ (8/27/2005):</a>
<a name="383"><span class="lineNum">     383 </span>            :      bool isTemplateMemberFunction (SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration);</a>
<a name="384"><span class="lineNum">     384 </span>            : #endif</a>
<a name="385"><span class="lineNum">     385 </span>            : </a>
<a name="386"><span class="lineNum">     386 </span>            :   // DQ (11/9/2020): Added function to support adding a default constructor definition to a class</a>
<a name="387"><span class="lineNum">     387 </span>            :   // if it does not have a default constructor, but has any other constructor that would prevend</a>
<a name="388"><span class="lineNum">     388 </span>            :   // a compiler generated default constructor from being generated by the compiler.</a>
<a name="389"><span class="lineNum">     389 </span>            :   // Note the physical_file_id is so that it can be marked to be unparsed when header file unparsing is active.</a>
<a name="390"><span class="lineNum">     390 </span>            :      ROSE_DLL_API bool addDefaultConstructorIfRequired ( SgClassType* classType, int physical_file_id = Sg_File_Info::TRANSFORMATION_FILE_ID );</a>
<a name="391"><span class="lineNum">     391 </span>            : </a>
<a name="392"><span class="lineNum">     392 </span>            :  //@}</a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span>            :  //------------------------------------------------------------------------</a>
<a name="395"><span class="lineNum">     395 </span>            :  //@{</a>
<a name="396"><span class="lineNum">     396 </span>            :  /*! @name Misc.</a>
<a name="397"><span class="lineNum">     397 </span>            :    \brief Not sure the classifications right now</a>
<a name="398"><span class="lineNum">     398 </span>            :  */</a>
<a name="399"><span class="lineNum">     399 </span>            : </a>
<a name="400"><span class="lineNum">     400 </span>            :   //! Recursively print current and parent nodes. used within gdb to probe the context of a node.</a>
<a name="401"><span class="lineNum">     401 </span>            :   void recursivePrintCurrentAndParent (SgNode* n) ;</a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span>            :    //! Save AST into a pdf file. Start from a node to find its enclosing file node. The entire file's AST will be saved into a pdf.</a>
<a name="404"><span class="lineNum">     404 </span>            :    void saveToPDF(SgNode* node, std::string filename);</a>
<a name="405"><span class="lineNum">     405 </span>            :    void saveToPDF(SgNode* node); // enable calling from gdb</a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :    //! Pretty print AST horizontally, output to std output.</a>
<a name="408"><span class="lineNum">     408 </span>            :    void printAST (SgNode* node);</a>
<a name="409"><span class="lineNum">     409 </span>            : </a>
<a name="410"><span class="lineNum">     410 </span>            :    //! Pretty print AST horizontally, output to a specified text file. If printType is set to false, don't print out type info.</a>
<a name="411"><span class="lineNum">     411 </span>            :    void printAST2TextFile (SgNode* node, const char* filename, bool printType=true);</a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span>            :    //! Pretty print AST horizontally, output to a specified text file. If printType is set to false, don't print out types info.</a>
<a name="414"><span class="lineNum">     414 </span>            :    void printAST2TextFile (SgNode* node, std::string filename, bool printType=true);</a>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<a name="416"><span class="lineNum">     416 </span>            :  // DQ (2/12/2012): Added some diagnostic support.</a>
<a name="417"><span class="lineNum">     417 </span>            : //! Diagnostic function for tracing back through the parent list to understand at runtime where in the AST a failure happened.</a>
<a name="418"><span class="lineNum">     418 </span>            :    void whereAmI(SgNode* node);</a>
<a name="419"><span class="lineNum">     419 </span>            : </a>
<a name="420"><span class="lineNum">     420 </span>            :    //! Extract a SgPragmaDeclaration's leading keyword . For example &quot;#pragma omp parallel&quot; has a keyword of &quot;omp&quot;.</a>
<a name="421"><span class="lineNum">     421 </span>            :    std::string extractPragmaKeyword(const SgPragmaDeclaration *);</a>
<a name="422"><span class="lineNum">     422 </span>            : </a>
<a name="423"><span class="lineNum">     423 </span>            :    //! Check if a node is SgOmp*Statement</a>
<a name="424"><span class="lineNum">     424 </span>            :    ROSE_DLL_API bool isOmpStatement(SgNode* );</a>
<a name="425"><span class="lineNum">     425 </span>            :    /*! \brief Return true if function is overloaded.</a>
<a name="426"><span class="lineNum">     426 </span>            :     */</a>
<a name="427"><span class="lineNum">     427 </span>            :    // DQ (8/27/2005):</a>
<a name="428"><span class="lineNum">     428 </span>            :    bool isOverloaded (SgFunctionDeclaration * functionDeclaration);</a>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<a name="430"><span class="lineNum">     430 </span>            : // DQ (2/14/2012): Added support function used for variable declarations in conditionals.</a>
<a name="431"><span class="lineNum">     431 </span>            : //! Support function used for variable declarations in conditionals</a>
<a name="432"><span class="lineNum">     432 </span>            :    void initializeIfStmt(SgIfStmt *ifstmt, SgStatement* conditional, SgStatement * true_body, SgStatement * false_body);</a>
<a name="433"><span class="lineNum">     433 </span>            : </a>
<a name="434"><span class="lineNum">     434 </span>            : //! Support function used for variable declarations in conditionals</a>
<a name="435"><span class="lineNum">     435 </span>            :    void initializeSwitchStatement(SgSwitchStatement* switchStatement,SgStatement *item_selector,SgStatement *body);</a>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<a name="437"><span class="lineNum">     437 </span>            : //! Support function used for variable declarations in conditionals</a>
<a name="438"><span class="lineNum">     438 </span>            :    void initializeWhileStatement(SgWhileStmt* whileStatement, SgStatement *  condition, SgStatement *body, SgStatement *else_body);</a>
<a name="439"><span class="lineNum">     439 </span>            : </a>
<a name="440"><span class="lineNum">     440 </span>            :   //! Generate unique names for expressions and attach the names as persistent attributes (&quot;UniqueNameAttribute&quot;)</a>
<a name="441"><span class="lineNum">     441 </span>            :    void annotateExpressionsWithUniqueNames (SgProject* project);</a>
<a name="442"><span class="lineNum">     442 </span>            : </a>
<a name="443"><span class="lineNum">     443 </span>            :    //! Check if a SgNode is a main() function declaration</a>
<a name="444"><span class="lineNum">     444 </span>            :    ROSE_DLL_API bool isMain (const SgNode* node);</a>
<a name="445"><span class="lineNum">     445 </span>            :    // DQ (6/22/2005):</a>
<a name="446"><span class="lineNum">     446 </span>            :    /*! \brief Generate unique name from C and C++ constructs. The name may contain space.</a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            :        This is support for the AST merge, but is generally useful as a more general mechanism than</a>
<a name="449"><span class="lineNum">     449 </span>            :        name mangling which is more closely ties to the generation of names to support link-time function name</a>
<a name="450"><span class="lineNum">     450 </span>            :        resolution.  This is more general than common name mangling in that it resolves more relevant differences</a>
<a name="451"><span class="lineNum">     451 </span>            :        between C and C++ declarations. (e.g. the type within the declaration: &quot;struct { int:8; } foo;&quot;).</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            :       \implementation current work does not support expressions.</a>
<a name="454"><span class="lineNum">     454 </span>            : </a>
<a name="455"><span class="lineNum">     455 </span>            :    */</a>
<a name="456"><span class="lineNum">     456 </span>            :     std::string generateUniqueName ( const SgNode * node, bool ignoreDifferenceBetweenDefiningAndNondefiningDeclarations);</a>
<a name="457"><span class="lineNum">     457 </span>            : </a>
<a name="458"><span class="lineNum">     458 </span>            :     /** Generate a name like __temp#__ that is unique in the current scope and any parent and children scopes. # is a unique integer counter.</a>
<a name="459"><span class="lineNum">     459 </span>            :     * @param baseName the word to be included in the variable names. */</a>
<a name="460"><span class="lineNum">     460 </span>            :     std::string generateUniqueVariableName(SgScopeStatement* scope, std::string baseName = &quot;temp&quot;);</a>
<a name="461"><span class="lineNum">     461 </span>            : </a>
<a name="462"><span class="lineNum">     462 </span>            :   // DQ (8/10/2010): Added const to first parameter.</a>
<a name="463"><span class="lineNum">     463 </span>            :   // DQ (3/10/2007):</a>
<a name="464"><span class="lineNum">     464 </span>            :   //! Generate a unique string from the source file position information</a>
<a name="465"><span class="lineNum">     465 </span>            :     std::string declarationPositionString (const SgDeclarationStatement * declaration);</a>
<a name="466"><span class="lineNum">     466 </span>            : </a>
<a name="467"><span class="lineNum">     467 </span>            :   // DQ (1/20/2007):</a>
<a name="468"><span class="lineNum">     468 </span>            :   //! Added mechanism to generate project name from list of file names</a>
<a name="469"><span class="lineNum">     469 </span>            :     ROSE_DLL_API std::string generateProjectName (const SgProject * project, bool supressSuffix = false );</a>
<a name="470"><span class="lineNum">     470 </span>            : </a>
<a name="471"><span class="lineNum">     471 </span>            :   //! Given a SgExpression that represents a named function (or bound member</a>
<a name="472"><span class="lineNum">     472 </span>            :   //! function), return the mentioned function</a>
<a name="473"><span class="lineNum">     473 </span>            :   SgFunctionDeclaration* getDeclarationOfNamedFunction(SgExpression* func);</a>
<a name="474"><span class="lineNum">     474 </span>            : </a>
<a name="475"><span class="lineNum">     475 </span>            :   //! Get the mask expression from the header of a SgForAllStatement</a>
<a name="476"><span class="lineNum">     476 </span>            :   SgExpression* forallMaskExpression(SgForAllStatement* stmt);</a>
<a name="477"><span class="lineNum">     477 </span>            : </a>
<a name="478"><span class="lineNum">     478 </span>            :   //! Find all SgPntrArrRefExp under astNode, then add SgVarRefExp (if any) of SgPntrArrRefExp's dim_info into NodeList_t</a>
<a name="479"><span class="lineNum">     479 </span>            :   void addVarRefExpFromArrayDimInfo(SgNode * astNode, Rose_STL_Container&lt;SgNode *&gt;&amp; NodeList_t);</a>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<a name="481"><span class="lineNum">     481 </span>            :   // DQ (10/6/2006): Added support for faster mangled name generation (caching avoids recomputation).</a>
<a name="482"><span class="lineNum">     482 </span>            :   /*! \brief Support for faster mangled name generation (caching avoids recomputation).</a>
<a name="483"><span class="lineNum">     483 </span>            : </a>
<a name="484"><span class="lineNum">     484 </span>            :    */</a>
<a name="485"><span class="lineNum">     485 </span>            : #ifndef SWIG</a>
<a name="486"><span class="lineNum">     486 </span>            : // DQ (3/10/2013): This appears to be a problem for the SWIG interface (undefined reference at link-time).</a>
<a name="487"><span class="lineNum">     487 </span>            :   void clearMangledNameCache (SgGlobal * globalScope);</a>
<a name="488"><span class="lineNum">     488 </span>            :   void resetMangledNameCache (SgGlobal * globalScope);</a>
<a name="489"><span class="lineNum">     489 </span>            : #endif</a>
<a name="490"><span class="lineNum">     490 </span>            : </a>
<a name="491"><span class="lineNum">     491 </span>            :   std::string getMangledNameFromCache (SgNode * astNode);</a>
<a name="492"><span class="lineNum">     492 </span>            :   std::string addMangledNameToCache (SgNode * astNode, const std::string &amp; mangledName);</a>
<a name="493"><span class="lineNum">     493 </span>            : </a>
<a name="494"><span class="lineNum">     494 </span>            :   SgDeclarationStatement * getNonInstantiatonDeclarationForClass (SgTemplateInstantiationMemberFunctionDecl * memberFunctionInstantiation);</a>
<a name="495"><span class="lineNum">     495 </span>            : </a>
<a name="496"><span class="lineNum">     496 </span>            :   //! a better version for SgVariableDeclaration::set_baseTypeDefininingDeclaration(), handling all side effects automatically</a>
<a name="497"><span class="lineNum">     497 </span>            :   //! Used to have a struct declaration embedded into a variable declaration</a>
<a name="498"><span class="lineNum">     498 </span>            :   void setBaseTypeDefiningDeclaration(SgVariableDeclaration* var_decl, SgDeclarationStatement *base_decl);</a>
<a name="499"><span class="lineNum">     499 </span>            : </a>
<a name="500"><span class="lineNum">     500 </span>            :   // DQ (10/14/2006): This function tests the AST to see if for a non-defining declaration, the</a>
<a name="501"><span class="lineNum">     501 </span>            :   // bool declarationPreceedsDefinition ( SgClassDeclaration* classNonDefiningDeclaration, SgClassDeclaration* classDefiningDeclaration );</a>
<a name="502"><span class="lineNum">     502 </span>            :   //! Check if a defining declaration comes before of after the non-defining declaration.</a>
<a name="503"><span class="lineNum">     503 </span>            :   bool declarationPreceedsDefinition (SgDeclarationStatement *nonDefiningDeclaration, SgDeclarationStatement *definingDeclaration);</a>
<a name="504"><span class="lineNum">     504 </span>            : </a>
<a name="505"><span class="lineNum">     505 </span>            :   // DQ (10/19/2006): Function calls have interesting context dependent rules to determine if</a>
<a name="506"><span class="lineNum">     506 </span>            :   // they are output with a global qualifier or not.  Were this is true we have to avoid global</a>
<a name="507"><span class="lineNum">     507 </span>            :   // qualifiers, since the function's scope has not been defined.  This is an example of where</a>
<a name="508"><span class="lineNum">     508 </span>            :   // qualification of function names in function calls are context dependent; an interesting</a>
<a name="509"><span class="lineNum">     509 </span>            :   // example of where the C++ language is not friendly to source-to-source processing :-).</a>
<a name="510"><span class="lineNum">     510 </span>            :   bool functionCallExpressionPreceedsDeclarationWhichAssociatesScope (SgFunctionCallExp * functionCall);</a>
<a name="511"><span class="lineNum">     511 </span>            : </a>
<a name="512"><span class="lineNum">     512 </span>            :  /*! \brief Compute the intersection set for two ASTs.</a>
<a name="513"><span class="lineNum">     513 </span>            : </a>
<a name="514"><span class="lineNum">     514 </span>            :      This is part of a test done by the copy function to compute those IR nodes in the copy that still reference the original AST.</a>
<a name="515"><span class="lineNum">     515 </span>            :   */</a>
<a name="516"><span class="lineNum">     516 </span>            :     ROSE_DLL_API std::vector &lt; SgNode * &gt;astIntersection (SgNode * original, SgNode * copy, SgCopyHelp * help = NULL);</a>
<a name="517"><span class="lineNum">     517 </span>            : </a>
<a name="518"><span class="lineNum">     518 </span>            :   //! Deep copy an arbitrary subtree</a>
<a name="519"><span class="lineNum">     519 </span>            :    ROSE_DLL_API SgNode* deepCopyNode (const SgNode* subtree);</a>
<a name="520"><span class="lineNum">     520 </span>            : </a>
<a name="521"><span class="lineNum">     521 </span>            : //! A template function for deep copying a subtree. It is also  used to create deepcopy functions with specialized parameter and return types. e.g SgExpression* copyExpression(SgExpression* e);</a>
<a name="522"><span class="lineNum">     522 </span>            :    template &lt;typename NodeType&gt;</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">      35890 :    NodeType* deepCopy (const NodeType* subtree) {</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">      35890 :      return dynamic_cast&lt;NodeType*&gt;(deepCopyNode(subtree));</span></a>
<a name="525"><span class="lineNum">     525 </span>            :    }</a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span>            : //! Deep copy an expression</a>
<a name="528"><span class="lineNum">     528 </span>            :    ROSE_DLL_API SgExpression* copyExpression(SgExpression* e);</a>
<a name="529"><span class="lineNum">     529 </span>            : </a>
<a name="530"><span class="lineNum">     530 </span>            : //!Deep copy a statement</a>
<a name="531"><span class="lineNum">     531 </span>            :    ROSE_DLL_API SgStatement* copyStatement(SgStatement* s);</a>
<a name="532"><span class="lineNum">     532 </span>            : </a>
<a name="533"><span class="lineNum">     533 </span>            : // from VarSym.cc in src/midend/astOutlining/src/ASTtools</a>
<a name="534"><span class="lineNum">     534 </span>            : //! Get the variable symbol for the first initialized name of a declaration stmt.</a>
<a name="535"><span class="lineNum">     535 </span>            :   ROSE_DLL_API SgVariableSymbol* getFirstVarSym (SgVariableDeclaration* decl);</a>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<a name="537"><span class="lineNum">     537 </span>            : //! Get the first initialized name of a declaration statement</a>
<a name="538"><span class="lineNum">     538 </span>            :   ROSE_DLL_API SgInitializedName* getFirstInitializedName (SgVariableDeclaration* decl);</a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span>            : //! A special purpose statement removal function, originally from inlinerSupport.h, Need Jeremiah's attention to refine it. Please don't use it for now.</a>
<a name="541"><span class="lineNum">     541 </span>            : ROSE_DLL_API void myRemoveStatement(SgStatement* stmt);</a>
<a name="542"><span class="lineNum">     542 </span>            : </a>
<a name="543"><span class="lineNum">     543 </span>            : //! Check if a bool or int constant expression evaluates to be a true value</a>
<a name="544"><span class="lineNum">     544 </span>            : ROSE_DLL_API bool isConstantTrue(SgExpression* e);</a>
<a name="545"><span class="lineNum">     545 </span>            : </a>
<a name="546"><span class="lineNum">     546 </span>            : //! Check if a bool or int constant expression evaluates to be a false value</a>
<a name="547"><span class="lineNum">     547 </span>            : ROSE_DLL_API bool isConstantFalse(SgExpression* e);</a>
<a name="548"><span class="lineNum">     548 </span>            : </a>
<a name="549"><span class="lineNum">     549 </span>            : ROSE_DLL_API bool isCallToParticularFunction(SgFunctionDeclaration* decl, SgExpression* e);</a>
<a name="550"><span class="lineNum">     550 </span>            : ROSE_DLL_API bool isCallToParticularFunction(const std::string&amp; qualifiedName, size_t arity, SgExpression* e);</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span>            : //! Check if a declaration has a &quot;static' modifier</a>
<a name="553"><span class="lineNum">     553 </span>            : bool ROSE_DLL_API isStatic(SgDeclarationStatement* stmt);</a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span>            : //! Set a declaration as static</a>
<a name="556"><span class="lineNum">     556 </span>            : ROSE_DLL_API void setStatic(SgDeclarationStatement* stmt);</a>
<a name="557"><span class="lineNum">     557 </span>            : </a>
<a name="558"><span class="lineNum">     558 </span>            : //! Check if a declaration has an &quot;extern&quot; modifier</a>
<a name="559"><span class="lineNum">     559 </span>            : ROSE_DLL_API bool isExtern(SgDeclarationStatement* stmt);</a>
<a name="560"><span class="lineNum">     560 </span>            : </a>
<a name="561"><span class="lineNum">     561 </span>            : //! Set a declaration as extern</a>
<a name="562"><span class="lineNum">     562 </span>            : ROSE_DLL_API void setExtern(SgDeclarationStatement* stmt);</a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span>            : //! True if an SgInitializedName is &quot;mutable' (has storage modifier set)</a>
<a name="565"><span class="lineNum">     565 </span>            : bool ROSE_DLL_API isMutable(SgInitializedName* name);</a>
<a name="566"><span class="lineNum">     566 </span>            : </a>
<a name="567"><span class="lineNum">     567 </span>            : //! Get a vector of Jovial input parameters from the function parameter list (may work for Fortran in the future)</a>
<a name="568"><span class="lineNum">     568 </span>            : std::vector&lt;SgInitializedName*&gt; getInParameters(const SgInitializedNamePtrList &amp;params);</a>
<a name="569"><span class="lineNum">     569 </span>            : </a>
<a name="570"><span class="lineNum">     570 </span>            : //! Get a vector of Jovial output parameters from the function parameter list (may work for Fortran in the future)</a>
<a name="571"><span class="lineNum">     571 </span>            : std::vector&lt;SgInitializedName*&gt; getOutParameters(const SgInitializedNamePtrList &amp;params);</a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span>            : //! Interface for creating a statement whose computation writes its answer into</a>
<a name="574"><span class="lineNum">     574 </span>            : //! a given variable.</a>
<a name="575"><span class="lineNum">     575 </span><span class="lineNoCov">          0 : class StatementGenerator {</span></a>
<a name="576"><span class="lineNum">     576 </span>            :   public:</a>
<a name="577"><span class="lineNum">     577 </span><span class="lineNoCov">          0 :   virtual ~StatementGenerator() {};</span></a>
<a name="578"><span class="lineNum">     578 </span>            :   virtual SgStatement* generate(SgExpression* where_to_write_answer) = 0;</a>
<a name="579"><span class="lineNum">     579 </span>            : };</a>
<a name="580"><span class="lineNum">     580 </span>            : </a>
<a name="581"><span class="lineNum">     581 </span>            : //! Check if a SgNode _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc)</a>
<a name="582"><span class="lineNum">     582 </span>            : //!</a>
<a name="583"><span class="lineNum">     583 </span>            : //! Return the left hand, right hand expressions and if the left hand variable is also being read</a>
<a name="584"><span class="lineNum">     584 </span>            :   bool isAssignmentStatement(SgNode* _s, SgExpression** lhs=NULL, SgExpression** rhs=NULL, bool* readlhs=NULL);</a>
<a name="585"><span class="lineNum">     585 </span>            : </a>
<a name="586"><span class="lineNum">     586 </span>            : //! Variable references can be introduced by SgVarRef, SgPntrArrRefExp, SgInitializedName, SgMemberFunctionRef etc. For Dot and Arrow Expressions, their lhs is used to obtain SgInitializedName (coarse grain) by default. Otherwise, fine-grain rhs is used.</a>
<a name="587"><span class="lineNum">     587 </span>            : ROSE_DLL_API SgInitializedName* convertRefToInitializedName(SgNode* current, bool coarseGrain=true);</a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span>            : //! Build an abstract handle from an AST node, reuse previously built handle when possible</a>
<a name="590"><span class="lineNum">     590 </span>            : ROSE_DLL_API AbstractHandle::abstract_handle* buildAbstractHandle(SgNode*);</a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span>            : //! Obtain a matching SgNode from an abstract handle string</a>
<a name="593"><span class="lineNum">     593 </span>            : ROSE_DLL_API SgNode* getSgNodeFromAbstractHandleString(const std::string&amp; input_string);</a>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<a name="595"><span class="lineNum">     595 </span>            : //! Dump information about a SgNode for debugging</a>
<a name="596"><span class="lineNum">     596 </span>            : ROSE_DLL_API void dumpInfo(SgNode* node, std::string desc=&quot;&quot;);</a>
<a name="597"><span class="lineNum">     597 </span>            : </a>
<a name="598"><span class="lineNum">     598 </span>            : //! Reorder a list of declaration statements based on their appearance order in source files</a>
<a name="599"><span class="lineNum">     599 </span>            : ROSE_DLL_API std::vector&lt;SgDeclarationStatement*&gt;</a>
<a name="600"><span class="lineNum">     600 </span>            : sortSgNodeListBasedOnAppearanceOrderInSource(const std::vector&lt;SgDeclarationStatement*&gt;&amp; nodevec);</a>
<a name="601"><span class="lineNum">     601 </span>            : </a>
<a name="602"><span class="lineNum">     602 </span>            : // DQ (4/13/2013): We need these to support the unparing of operators defined by operator syntax or member function names.</a>
<a name="603"><span class="lineNum">     603 </span>            : //! Is an overloaded operator a prefix operator (e.g. address operator X * operator&amp;(), dereference operator X &amp; operator*(), unary plus operator X &amp; operator+(), etc.</a>
<a name="604"><span class="lineNum">     604 </span>            : // bool isPrefixOperator( const SgMemberFunctionRefExp* memberFunctionRefExp );</a>
<a name="605"><span class="lineNum">     605 </span>            : bool isPrefixOperator( SgExpression* exp );</a>
<a name="606"><span class="lineNum">     606 </span>            : </a>
<a name="607"><span class="lineNum">     607 </span>            : //! Check for proper names of possible prefix operators (used in isPrefixOperator()).</a>
<a name="608"><span class="lineNum">     608 </span>            : bool isPrefixOperatorName( const SgName &amp; functionName );</a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            : //! Is an overloaded operator a postfix operator. (e.g. ).</a>
<a name="611"><span class="lineNum">     611 </span>            : bool isPostfixOperator( SgExpression* exp );</a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            : //! Is an overloaded operator an index operator (also referred to as call or subscript operators). (e.g. X &amp; operator()() or X &amp; operator[]()).</a>
<a name="614"><span class="lineNum">     614 </span>            : bool isIndexOperator( SgExpression* exp );</a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span>            : // DQ (1/10/2014): Adding more general support for token based unparsing.</a>
<a name="617"><span class="lineNum">     617 </span>            : //! Used to support token unparsing (when the output the trailing token sequence).</a>
<a name="618"><span class="lineNum">     618 </span>            : SgStatement* lastStatementOfScopeWithTokenInfo (SgScopeStatement* scope, std::map&lt;SgNode*,TokenStreamSequenceToNodeMapping*&gt; &amp; tokenStreamSequenceMap);</a>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<a name="620"><span class="lineNum">     620 </span>            : // DQ (8/12/2020): Check the access permissions of all defining and nodefining declarations.</a>
<a name="621"><span class="lineNum">     621 </span>            : void checkAccessPermissions ( SgNode* );</a>
<a name="622"><span class="lineNum">     622 </span>            : </a>
<a name="623"><span class="lineNum">     623 </span>            : // DQ (8/14/2020): Check the symbol tables for specific scopes (debugging support).</a>
<a name="624"><span class="lineNum">     624 </span>            : void checkSymbolTables ( SgNode* );</a>
<a name="625"><span class="lineNum">     625 </span>            : </a>
<a name="626"><span class="lineNum">     626 </span>            : // DQ (11/9/2020): Added support for makring IR nodes and subtrees of the AST to be unparsed (physical_file_id</a>
<a name="627"><span class="lineNum">     627 </span>            : // is required when unparsing header files is true or support multiple files and shared IR nodes).</a>
<a name="628"><span class="lineNum">     628 </span>            : void markSubtreeToBeUnparsed(SgNode* root, int physical_file_id);</a>
<a name="629"><span class="lineNum">     629 </span>            : void markNodeToBeUnparsed(SgNode* node, int physical_file_id);</a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<a name="632"><span class="lineNum">     632 </span>            : //@}</a>
<a name="633"><span class="lineNum">     633 </span>            : </a>
<a name="634"><span class="lineNum">     634 </span>            : //------------------------------------------------------------------------</a>
<a name="635"><span class="lineNum">     635 </span>            : //@{</a>
<a name="636"><span class="lineNum">     636 </span>            : /*! @name AST properties</a>
<a name="637"><span class="lineNum">     637 </span>            :   \brief version, language properties of current AST.</a>
<a name="638"><span class="lineNum">     638 </span>            : */</a>
<a name="639"><span class="lineNum">     639 </span>            : </a>
<a name="640"><span class="lineNum">     640 </span>            : // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="641"><span class="lineNum">     641 </span>            : // The value of 0 allows the old implementation to be tested, and the value of 1 allows the new optimized implementation to be tested.</a>
<a name="642"><span class="lineNum">     642 </span>            : // However to get all of the functions to be inlined, we have to recompile all of ROSE.</a>
<a name="643"><span class="lineNum">     643 </span>            : #define INLINE_OPTIMIZED_IS_LANGUAGE_KIND_FUNCTIONS 1</a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span>            : //  std::string version();  // utility_functions.h, version number</a>
<a name="646"><span class="lineNum">     646 </span>            :   /*! Brief These traverse the memory pool of SgFile IR nodes and determine what languages are in use!</a>
<a name="647"><span class="lineNum">     647 </span>            :    */</a>
<a name="648"><span class="lineNum">     648 </span>            : #if INLINE_OPTIMIZED_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">    7099023 :   ROSE_DLL_API inline bool is_C_language ()         { return Rose::is_C_language; }</span></a>
<a name="650"><span class="lineNum">     650 </span>            :   ROSE_DLL_API inline bool is_OpenMP_language ()    { return Rose::is_OpenMP_language; }</a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">          1 :   ROSE_DLL_API inline bool is_UPC_language ()       { return Rose::is_UPC_language; }</span></a>
<a name="652"><span class="lineNum">     652 </span>            :   ROSE_DLL_API inline bool is_UPC_dynamic_threads() { return Rose::is_UPC_dynamic_threads; }</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">    1565927 :   ROSE_DLL_API inline bool is_C99_language ()       { return Rose::is_C99_language; }</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">    1245369 :   ROSE_DLL_API inline bool is_Cxx_language ()       { return Rose::is_Cxx_language; }</span></a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">   94217046 :   ROSE_DLL_API inline bool is_Fortran_language ()   { return Rose::is_Fortran_language; }</span></a>
<a name="656"><span class="lineNum">     656 </span>            :   ROSE_DLL_API inline bool is_CAF_language ()       { return Rose::is_CAF_language; }</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">      48732 :   ROSE_DLL_API inline bool is_Cuda_language()       { return Rose::is_Cuda_language; }</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">      48732 :   ROSE_DLL_API inline bool is_OpenCL_language()     { return Rose::is_OpenCL_language; }</span></a>
<a name="659"><span class="lineNum">     659 </span>            : #else</a>
<a name="660"><span class="lineNum">     660 </span>            :   ROSE_DLL_API bool is_C_language ();</a>
<a name="661"><span class="lineNum">     661 </span>            :   ROSE_DLL_API bool is_OpenMP_language ();</a>
<a name="662"><span class="lineNum">     662 </span>            :   ROSE_DLL_API bool is_UPC_language ();</a>
<a name="663"><span class="lineNum">     663 </span>            :   //! Check if dynamic threads compilation is used for UPC programs</a>
<a name="664"><span class="lineNum">     664 </span>            :   ROSE_DLL_API bool is_UPC_dynamic_threads();</a>
<a name="665"><span class="lineNum">     665 </span>            :   ROSE_DLL_API bool is_C99_language ();</a>
<a name="666"><span class="lineNum">     666 </span>            :   ROSE_DLL_API bool is_Cxx_language ();</a>
<a name="667"><span class="lineNum">     667 </span>            :   ROSE_DLL_API bool is_Fortran_language ();</a>
<a name="668"><span class="lineNum">     668 </span>            :   ROSE_DLL_API bool is_CAF_language ();</a>
<a name="669"><span class="lineNum">     669 </span>            :   ROSE_DLL_API bool is_Cuda_language();</a>
<a name="670"><span class="lineNum">     670 </span>            :   ROSE_DLL_API bool is_OpenCL_language();</a>
<a name="671"><span class="lineNum">     671 </span>            : #endif</a>
<a name="672"><span class="lineNum">     672 </span>            : </a>
<a name="673"><span class="lineNum">     673 </span>            :   ROSE_DLL_API bool is_mixed_C_and_Cxx_language ();</a>
<a name="674"><span class="lineNum">     674 </span>            :   ROSE_DLL_API bool is_mixed_Fortran_and_C_language ();</a>
<a name="675"><span class="lineNum">     675 </span>            :   ROSE_DLL_API bool is_mixed_Fortran_and_Cxx_language ();</a>
<a name="676"><span class="lineNum">     676 </span>            :   ROSE_DLL_API bool is_mixed_Fortran_and_C_and_Cxx_language ();</a>
<a name="677"><span class="lineNum">     677 </span>            : </a>
<a name="678"><span class="lineNum">     678 </span>            :   ROSE_DLL_API bool is_language_case_insensitive ();</a>
<a name="679"><span class="lineNum">     679 </span>            :   ROSE_DLL_API bool language_may_contain_nondeclarations_in_scope ();</a>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<a name="681"><span class="lineNum">     681 </span>            : //@}</a>
<a name="682"><span class="lineNum">     682 </span>            : </a>
<a name="683"><span class="lineNum">     683 </span>            : //------------------------------------------------------------------------</a>
<a name="684"><span class="lineNum">     684 </span>            : //@{</a>
<a name="685"><span class="lineNum">     685 </span>            : /*! @name Scope</a>
<a name="686"><span class="lineNum">     686 </span>            :   \brief</a>
<a name="687"><span class="lineNum">     687 </span>            : */</a>
<a name="688"><span class="lineNum">     688 </span>            : </a>
<a name="689"><span class="lineNum">     689 </span>            :   // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="690"><span class="lineNum">     690 </span>            :   // labels for scopes in a function (as required for name mangling).</a>
<a name="691"><span class="lineNum">     691 </span>            :   /*! \brief Assigns unique numbers to each SgScopeStatement of a function.</a>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<a name="693"><span class="lineNum">     693 </span>            :       This is used to provide unique names for variables and types defined is</a>
<a name="694"><span class="lineNum">     694 </span>            :       different nested scopes of a function (used in mangled name generation).</a>
<a name="695"><span class="lineNum">     695 </span>            :    */</a>
<a name="696"><span class="lineNum">     696 </span>            :   void resetScopeNumbers (SgFunctionDefinition * functionDeclaration);</a>
<a name="697"><span class="lineNum">     697 </span>            : </a>
<a name="698"><span class="lineNum">     698 </span>            :   // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="699"><span class="lineNum">     699 </span>            :   // labels for scopes in a function (as required for name mangling).</a>
<a name="700"><span class="lineNum">     700 </span>            :   /*! \brief Clears the cache of scope,integer pairs for the input function.</a>
<a name="701"><span class="lineNum">     701 </span>            : </a>
<a name="702"><span class="lineNum">     702 </span>            :       This is used to clear the cache of computed unique labels for scopes in a function.</a>
<a name="703"><span class="lineNum">     703 </span>            :       This function should be called after any transformation on a function that might effect</a>
<a name="704"><span class="lineNum">     704 </span>            :       the allocation of scopes and cause the existing unique numbers to be incorrect.</a>
<a name="705"><span class="lineNum">     705 </span>            :       This is part of support to provide unique names for variables and types defined is</a>
<a name="706"><span class="lineNum">     706 </span>            :       different nested scopes of a function (used in mangled name generation).</a>
<a name="707"><span class="lineNum">     707 </span>            :    */</a>
<a name="708"><span class="lineNum">     708 </span>            :   void clearScopeNumbers (SgFunctionDefinition * functionDefinition);</a>
<a name="709"><span class="lineNum">     709 </span>            : </a>
<a name="710"><span class="lineNum">     710 </span>            : </a>
<a name="711"><span class="lineNum">     711 </span>            :   //!Find the enclosing namespace of a declaration</a>
<a name="712"><span class="lineNum">     712 </span>            :   SgNamespaceDefinitionStatement * enclosingNamespaceScope (SgDeclarationStatement * declaration);</a>
<a name="713"><span class="lineNum">     713 </span>            : //  SgNamespaceDefinitionStatement * getEnclosingNamespaceScope (SgNode * node);</a>
<a name="714"><span class="lineNum">     714 </span>            : </a>
<a name="715"><span class="lineNum">     715 </span>            :   bool isPrototypeInScope (SgScopeStatement * scope,</a>
<a name="716"><span class="lineNum">     716 </span>            :                            SgFunctionDeclaration * functionDeclaration,</a>
<a name="717"><span class="lineNum">     717 </span>            :                            SgDeclarationStatement * startingAtDeclaration);</a>
<a name="718"><span class="lineNum">     718 </span>            : </a>
<a name="719"><span class="lineNum">     719 </span>            :   //!check if node1 is a strict ancestor of node 2. (a node is not considered its own ancestor)</a>
<a name="720"><span class="lineNum">     720 </span>            :   bool ROSE_DLL_API isAncestor(SgNode* node1, SgNode* node2);</a>
<a name="721"><span class="lineNum">     721 </span>            : //@}</a>
<a name="722"><span class="lineNum">     722 </span>            : //------------------------------------------------------------------------</a>
<a name="723"><span class="lineNum">     723 </span>            : //@{</a>
<a name="724"><span class="lineNum">     724 </span>            : /*! @name Preprocessing Information</a>
<a name="725"><span class="lineNum">     725 </span>            :   \brief #if-#else-#end, comments, #include, etc</a>
<a name="726"><span class="lineNum">     726 </span>            : */</a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span>            :   //! Dumps a located node's preprocessing information.</a>
<a name="729"><span class="lineNum">     729 </span>            :   void dumpPreprocInfo (SgLocatedNode* locatedNode);</a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span>            :   //! Find the preprocessingInfo node representing #include &lt;header.h&gt; or #include &quot;header.h&quot; within a source file. Return NULL if not found.</a>
<a name="732"><span class="lineNum">     732 </span>            : ROSE_DLL_API PreprocessingInfo * findHeader(SgSourceFile * source_file, const std::string &amp; header_file_name, bool isSystemHeader);</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            : //! Insert  #include &quot;filename&quot; or #include &lt;filename&gt; (system header) onto the global scope of a source file, add to be the last #include .. by default among existing headers, Or as the first header. Recommended for use.</a>
<a name="735"><span class="lineNum">     735 </span>            : ROSE_DLL_API PreprocessingInfo * insertHeader(SgSourceFile * source_file, const std::string &amp; header_file_name, bool isSystemHeader, bool asLastHeader);</a>
<a name="736"><span class="lineNum">     736 </span>            : </a>
<a name="737"><span class="lineNum">     737 </span>            : //! Insert a new header right before stmt,  if there are existing headers attached to stmt, insert it as the last or first header as specified by asLastHeader</a>
<a name="738"><span class="lineNum">     738 </span>            : ROSE_DLL_API void insertHeader (SgStatement* stmt, PreprocessingInfo* newheader, bool asLastHeader);</a>
<a name="739"><span class="lineNum">     739 </span>            : </a>
<a name="740"><span class="lineNum">     740 </span>            : //! Insert  #include &quot;filename&quot; or #include &lt;filename&gt; (system header) onto the global scope of a source file</a>
<a name="741"><span class="lineNum">     741 </span>            : ROSE_DLL_API PreprocessingInfo * insertHeader(SgSourceFile * source_file, const std::string &amp; header_file_name, bool isSystemHeader = false, PreprocessingInfo::RelativePositionType position = PreprocessingInfo::before);</a>
<a name="742"><span class="lineNum">     742 </span>            : </a>
<a name="743"><span class="lineNum">     743 </span>            : //! Insert  #include &quot;filename&quot; or #include &lt;filename&gt; (system header) into the global scope containing the current scope, right after other #include XXX.</a>
<a name="744"><span class="lineNum">     744 </span>            : ROSE_DLL_API PreprocessingInfo* insertHeader(const std::string&amp; filename, PreprocessingInfo::RelativePositionType position=PreprocessingInfo::after, bool isSystemHeader=false, SgScopeStatement* scope=NULL);</a>
<a name="745"><span class="lineNum">     745 </span>            : </a>
<a name="746"><span class="lineNum">     746 </span>            : //! Identical to movePreprocessingInfo(), except for the stale name and confusing order of parameters. It will be deprecated soon.</a>
<a name="747"><span class="lineNum">     747 </span>            : ROSE_DLL_API void moveUpPreprocessingInfo (SgStatement* stmt_dst, SgStatement* stmt_src, PreprocessingInfo::RelativePositionType src_position=PreprocessingInfo::undef,  PreprocessingInfo::RelativePositionType dst_position=PreprocessingInfo::undef, bool usePrepend= false);</a>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<a name="749"><span class="lineNum">     749 </span>            : //! Move preprocessing information of stmt_src to stmt_dst, Only move preprocessing information from the specified source-relative position to a specified target position, otherwise move all preprocessing information with position information intact. The preprocessing information is appended to the existing preprocessing information list of the target node by default. Prepending is used if usePreprend is set to true. Optionally, the relative position can be adjust after the moving using dst_position.</a>
<a name="750"><span class="lineNum">     750 </span>            : ROSE_DLL_API void movePreprocessingInfo (SgStatement* stmt_src, SgStatement* stmt_dst,  PreprocessingInfo::RelativePositionType src_position=PreprocessingInfo::undef,</a>
<a name="751"><span class="lineNum">     751 </span>            :                              PreprocessingInfo::RelativePositionType dst_position=PreprocessingInfo::undef, bool usePrepend= false);</a>
<a name="752"><span class="lineNum">     752 </span>            : </a>
<a name="753"><span class="lineNum">     753 </span>            : </a>
<a name="754"><span class="lineNum">     754 </span>            : //!Cut preprocessing information from a source node and save it into a buffer. Used in combination of pastePreprocessingInfo(). The cut-paste operation is similar to moveUpPreprocessingInfo() but it is more flexible in that the destination node can be unknown during the cut operation.</a>
<a name="755"><span class="lineNum">     755 </span>            : ROSE_DLL_API void cutPreprocessingInfo (SgLocatedNode* src_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType&amp; save_buf);</a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span>            : //!Paste preprocessing information from a buffer to a destination node. Used in combination of cutPreprocessingInfo()</a>
<a name="758"><span class="lineNum">     758 </span>            : ROSE_DLL_API void pastePreprocessingInfo (SgLocatedNode* dst_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType&amp; saved_buf);</a>
<a name="759"><span class="lineNum">     759 </span>            : </a>
<a name="760"><span class="lineNum">     760 </span>            : //! Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes.</a>
<a name="761"><span class="lineNum">     761 </span>            : ROSE_DLL_API PreprocessingInfo* attachArbitraryText(SgLocatedNode* target,</a>
<a name="762"><span class="lineNum">     762 </span>            :                 const std::string &amp; text,</a>
<a name="763"><span class="lineNum">     763 </span>            :                PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before);</a>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<a name="765"><span class="lineNum">     765 </span>            : //!Check if a pragma declaration node has macro calls attached, if yes, replace macro calls within the pragma string with expanded strings. This only works if -rose:wave is turned on.</a>
<a name="766"><span class="lineNum">     766 </span>            : ROSE_DLL_API void replaceMacroCallsWithExpandedStrings(SgPragmaDeclaration* target);</a>
<a name="767"><span class="lineNum">     767 </span>            : //@}</a>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<a name="769"><span class="lineNum">     769 </span>            : //! Build and attach comment onto the global scope of a source file</a>
<a name="770"><span class="lineNum">     770 </span>            : PreprocessingInfo* attachComment(</a>
<a name="771"><span class="lineNum">     771 </span>            :   SgSourceFile * source_file,</a>
<a name="772"><span class="lineNum">     772 </span>            :   const std::string &amp; content,</a>
<a name="773"><span class="lineNum">     773 </span>            :   PreprocessingInfo::DirectiveType directive_type = PreprocessingInfo::C_StyleComment,</a>
<a name="774"><span class="lineNum">     774 </span>            :   PreprocessingInfo::RelativePositionType  position = PreprocessingInfo::before</a>
<a name="775"><span class="lineNum">     775 </span>            : );</a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span>            : //! Build and attach comment, comment style is inferred from the language type of the target node if not provided</a>
<a name="778"><span class="lineNum">     778 </span>            :    ROSE_DLL_API PreprocessingInfo* attachComment(SgLocatedNode* target, const std::string &amp; content,</a>
<a name="779"><span class="lineNum">     779 </span>            :                PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before,</a>
<a name="780"><span class="lineNum">     780 </span>            :                PreprocessingInfo::DirectiveType dtype= PreprocessingInfo::CpreprocessorUnknownDeclaration);</a>
<a name="781"><span class="lineNum">     781 </span>            : </a>
<a name="782"><span class="lineNum">     782 </span>            : // DQ (7/20/2008): I am not clear were I should put this function, candidates include: SgLocatedNode or SgInterface</a>
<a name="783"><span class="lineNum">     783 </span>            : //! Add a string to be unparsed to support code generation for back-end specific tools or compilers.</a>
<a name="784"><span class="lineNum">     784 </span>            :   ROSE_DLL_API void addTextForUnparser ( SgNode* astNode, std::string s, AstUnparseAttribute::RelativePositionType inputlocation );</a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span>            : /**</a>
<a name="787"><span class="lineNum">     787 </span>            :  * Add preproccessor guard around a given node.</a>
<a name="788"><span class="lineNum">     788 </span>            :  * It surrounds the node with &quot;#if guard&quot; and &quot;#endif&quot;</a>
<a name="789"><span class="lineNum">     789 </span>            :  */</a>
<a name="790"><span class="lineNum">     790 </span>            : void guardNode(SgLocatedNode * target, std::string guard);</a>
<a name="791"><span class="lineNum">     791 </span>            : </a>
<a name="792"><span class="lineNum">     792 </span>            : //@}</a>
<a name="793"><span class="lineNum">     793 </span>            : </a>
<a name="794"><span class="lineNum">     794 </span>            : </a>
<a name="795"><span class="lineNum">     795 </span>            : //------------------------------------------------------------------------</a>
<a name="796"><span class="lineNum">     796 </span>            : //@{</a>
<a name="797"><span class="lineNum">     797 </span>            : /*! @name Source File Position</a>
<a name="798"><span class="lineNum">     798 </span>            :   \brief set Sg_File_Info for a SgNode</a>
<a name="799"><span class="lineNum">     799 </span>            : */</a>
<a name="800"><span class="lineNum">     800 </span>            : </a>
<a name="801"><span class="lineNum">     801 </span>            : // ************************************************************************</a>
<a name="802"><span class="lineNum">     802 </span>            : //              Newer versions of now depricated functions</a>
<a name="803"><span class="lineNum">     803 </span>            : // ************************************************************************</a>
<a name="804"><span class="lineNum">     804 </span>            : </a>
<a name="805"><span class="lineNum">     805 </span>            : // DQ (5/1/2012): This function queries the SageBuilder::SourcePositionClassification mode (stored in the SageBuilder</a>
<a name="806"><span class="lineNum">     806 </span>            : // interface) and used the specified mode to initialize the source position data (Sg_File_Info objects).  This</a>
<a name="807"><span class="lineNum">     807 </span>            : // function is the only function that should be called directly (though in a namespace we can't define permissions).</a>
<a name="808"><span class="lineNum">     808 </span>            : //! Set the source code positon for the current (input) node.</a>
<a name="809"><span class="lineNum">     809 </span>            :   ROSE_DLL_API void setSourcePosition(SgNode* node);</a>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<a name="811"><span class="lineNum">     811 </span>            : // A better name might be &quot;setSourcePositionForSubTree&quot;</a>
<a name="812"><span class="lineNum">     812 </span>            : //! Set the source code positon for the subtree (including the root).</a>
<a name="813"><span class="lineNum">     813 </span>            :   ROSE_DLL_API void setSourcePositionAtRootAndAllChildren(SgNode *root);</a>
<a name="814"><span class="lineNum">     814 </span>            : </a>
<a name="815"><span class="lineNum">     815 </span>            : //! DQ (5/1/2012): New function with improved name.</a>
<a name="816"><span class="lineNum">     816 </span>            : void setSourcePositionAsTransformation(SgNode *node);</a>
<a name="817"><span class="lineNum">     817 </span>            : </a>
<a name="818"><span class="lineNum">     818 </span>            : // DQ (5/1/2012): Newly renamed function (previous name preserved for backward compatability).</a>
<a name="819"><span class="lineNum">     819 </span>            : void setSourcePositionPointersToNull(SgNode *node);</a>
<a name="820"><span class="lineNum">     820 </span>            : </a>
<a name="821"><span class="lineNum">     821 </span>            : // ************************************************************************</a>
<a name="822"><span class="lineNum">     822 </span>            : </a>
<a name="823"><span class="lineNum">     823 </span>            : </a>
<a name="824"><span class="lineNum">     824 </span>            : </a>
<a name="825"><span class="lineNum">     825 </span>            : // ************************************************************************</a>
<a name="826"><span class="lineNum">     826 </span>            : //                  Older deprecated functions</a>
<a name="827"><span class="lineNum">     827 </span>            : // ************************************************************************</a>
<a name="828"><span class="lineNum">     828 </span>            :   // Liao, 1/8/2007, set file info. for a whole subtree as transformation generated</a>
<a name="829"><span class="lineNum">     829 </span>            : //! Set current node's source position as transformation generated</a>
<a name="830"><span class="lineNum">     830 </span>            :   ROSE_DLL_API void setOneSourcePositionForTransformation(SgNode *node);</a>
<a name="831"><span class="lineNum">     831 </span>            : </a>
<a name="832"><span class="lineNum">     832 </span>            : //! Set current node's source position as NULL</a>
<a name="833"><span class="lineNum">     833 </span>            :   ROSE_DLL_API void setOneSourcePositionNull(SgNode *node);</a>
<a name="834"><span class="lineNum">     834 </span>            : </a>
<a name="835"><span class="lineNum">     835 </span>            : //! Recursively set source position info(Sg_File_Info) as transformation generated</a>
<a name="836"><span class="lineNum">     836 </span>            :   ROSE_DLL_API void setSourcePositionForTransformation (SgNode * root);</a>
<a name="837"><span class="lineNum">     837 </span>            : </a>
<a name="838"><span class="lineNum">     838 </span>            : //! Set source position info(Sg_File_Info) as transformation generated for all SgNodes in memory pool</a>
<a name="839"><span class="lineNum">     839 </span>            : //  ROSE_DLL_API void setSourcePositionForTransformation_memoryPool();</a>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<a name="841"><span class="lineNum">     841 </span>            : //! Check if a node is from a system header file</a>
<a name="842"><span class="lineNum">     842 </span>            :   ROSE_DLL_API bool insideSystemHeader (SgLocatedNode* node);</a>
<a name="843"><span class="lineNum">     843 </span>            : </a>
<a name="844"><span class="lineNum">     844 </span>            : // DQ (2/27/2021): Adding support to detect if a SgLocatedNode is located in a header file.</a>
<a name="845"><span class="lineNum">     845 </span>            : //! Check if a node is from a header file</a>
<a name="846"><span class="lineNum">     846 </span>            :   ROSE_DLL_API bool insideHeader (SgLocatedNode* node);</a>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<a name="848"><span class="lineNum">     848 </span>            : //! Set the source position of SgLocatedNode to Sg_File_Info::generateDefaultFileInfo(). These nodes WILL be unparsed. Not for transformation usage.</a>
<a name="849"><span class="lineNum">     849 </span>            : // ROSE_DLL_API void setSourcePosition (SgLocatedNode * locatedNode);</a>
<a name="850"><span class="lineNum">     850 </span>            : // ************************************************************************</a>
<a name="851"><span class="lineNum">     851 </span>            : </a>
<a name="852"><span class="lineNum">     852 </span>            : //@}</a>
<a name="853"><span class="lineNum">     853 </span>            : </a>
<a name="854"><span class="lineNum">     854 </span>            : </a>
<a name="855"><span class="lineNum">     855 </span>            : //------------------------------------------------------------------------</a>
<a name="856"><span class="lineNum">     856 </span>            : //@{</a>
<a name="857"><span class="lineNum">     857 </span>            : /*! @name Data types</a>
<a name="858"><span class="lineNum">     858 </span>            :   \brief</a>
<a name="859"><span class="lineNum">     859 </span>            : */</a>
<a name="860"><span class="lineNum">     860 </span>            : </a>
<a name="861"><span class="lineNum">     861 </span>            : // from src/midend/astInlining/typeTraits.h</a>
<a name="862"><span class="lineNum">     862 </span>            : // src/midend/astUtil/astInterface/AstInterface.h</a>
<a name="863"><span class="lineNum">     863 </span>            : </a>
<a name="864"><span class="lineNum">     864 </span>            : //! Get the right bool type according to C or C++ language input</a>
<a name="865"><span class="lineNum">     865 </span>            : SgType* getBoolType(SgNode* n);</a>
<a name="866"><span class="lineNum">     866 </span>            : </a>
<a name="867"><span class="lineNum">     867 </span>            : </a>
<a name="868"><span class="lineNum">     868 </span>            : //! Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long.</a>
<a name="869"><span class="lineNum">     869 </span>            : ////!</a>
<a name="870"><span class="lineNum">     870 </span>            : ////! There is another similar function named SgType::isIntegerType(), which allows additional types char, wchar, and bool to be treated as integer types</a>
<a name="871"><span class="lineNum">     871 </span>            : ROSE_DLL_API bool isStrictIntegerType(SgType* t);</a>
<a name="872"><span class="lineNum">     872 </span>            : //!Get the data type of the first initialized name of a declaration statement</a>
<a name="873"><span class="lineNum">     873 </span>            : ROSE_DLL_API SgType* getFirstVarType(SgVariableDeclaration* decl);</a>
<a name="874"><span class="lineNum">     874 </span>            : </a>
<a name="875"><span class="lineNum">     875 </span>            : //! Is a type default constructible?  This may not quite work properly.</a>
<a name="876"><span class="lineNum">     876 </span>            : ROSE_DLL_API bool isDefaultConstructible(SgType* type);</a>
<a name="877"><span class="lineNum">     877 </span>            : </a>
<a name="878"><span class="lineNum">     878 </span>            : //! Is a type copy constructible?  This may not quite work properly.</a>
<a name="879"><span class="lineNum">     879 </span>            : ROSE_DLL_API bool isCopyConstructible(SgType* type);</a>
<a name="880"><span class="lineNum">     880 </span>            : </a>
<a name="881"><span class="lineNum">     881 </span>            : //! Is a type assignable?  This may not quite work properly.</a>
<a name="882"><span class="lineNum">     882 </span>            : ROSE_DLL_API bool isAssignable(SgType* type);</a>
<a name="883"><span class="lineNum">     883 </span>            : </a>
<a name="884"><span class="lineNum">     884 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="885"><span class="lineNum">     885 </span>            : //! Check if a class type is a pure virtual class. True means that there is at least</a>
<a name="886"><span class="lineNum">     886 </span>            : //! one pure virtual function that has not been overridden.</a>
<a name="887"><span class="lineNum">     887 </span>            : //! In the case of an incomplete class type (forward declaration), this function returns false.</a>
<a name="888"><span class="lineNum">     888 </span>            : ROSE_DLL_API bool isPureVirtualClass(SgType* type, const ClassHierarchyWrapper&amp; classHierarchy);</a>
<a name="889"><span class="lineNum">     889 </span>            : #endif</a>
<a name="890"><span class="lineNum">     890 </span>            : </a>
<a name="891"><span class="lineNum">     891 </span>            : //! Does a type have a trivial (built-in) destructor?</a>
<a name="892"><span class="lineNum">     892 </span>            : ROSE_DLL_API bool hasTrivialDestructor(SgType* t);</a>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<a name="894"><span class="lineNum">     894 </span>            : //! Is this type a non-constant reference type? (Handles typedefs correctly)</a>
<a name="895"><span class="lineNum">     895 </span>            : ROSE_DLL_API bool isNonconstReference(SgType* t);</a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span>            : //! Is this type a const or non-const reference type? (Handles typedefs correctly)</a>
<a name="898"><span class="lineNum">     898 </span>            : ROSE_DLL_API bool isReferenceType(SgType* t);</a>
<a name="899"><span class="lineNum">     899 </span>            : </a>
<a name="900"><span class="lineNum">     900 </span>            : //! Is this type a pointer type? (Handles typedefs correctly)</a>
<a name="901"><span class="lineNum">     901 </span>            : ROSE_DLL_API bool isPointerType(SgType* t);</a>
<a name="902"><span class="lineNum">     902 </span>            : </a>
<a name="903"><span class="lineNum">     903 </span>            : //! Is this a pointer to a non-const type? Note that this function will return true for const pointers pointing to</a>
<a name="904"><span class="lineNum">     904 </span>            : //! non-const types. For example, (int* const y) points to a modifiable int, so this function returns true. Meanwhile,</a>
<a name="905"><span class="lineNum">     905 </span>            : //! it returns false for (int const * x) and (int const * const x) because these types point to a const int.</a>
<a name="906"><span class="lineNum">     906 </span>            : //! Also, only the outer layer of nested pointers is unwrapped. So the function returns true for (const int ** y), but returns</a>
<a name="907"><span class="lineNum">     907 </span>            : //! false for const (int * const * x)</a>
<a name="908"><span class="lineNum">     908 </span>            : ROSE_DLL_API bool isPointerToNonConstType(SgType* type);</a>
<a name="909"><span class="lineNum">     909 </span>            : </a>
<a name="910"><span class="lineNum">     910 </span>            : //! Is this a const type?</a>
<a name="911"><span class="lineNum">     911 </span>            : /* const char* p = &quot;aa&quot;; is not treated as having a const type. It is a pointer to const char.</a>
<a name="912"><span class="lineNum">     912 </span>            :  * Similarly, neither for const int b[10]; or const int &amp; c =10;</a>
<a name="913"><span class="lineNum">     913 </span>            :  * The standard says, &quot;A compound type is not cv-qualified by the cv-qualifiers (if any) of</a>
<a name="914"><span class="lineNum">     914 </span>            : the types from which it is compounded. Any cv-qualifiers applied to an array type affect the array element type, not the array type&quot;.</a>
<a name="915"><span class="lineNum">     915 </span>            :  */</a>
<a name="916"><span class="lineNum">     916 </span>            : ROSE_DLL_API bool isConstType(SgType* t);</a>
<a name="917"><span class="lineNum">     917 </span>            : </a>
<a name="918"><span class="lineNum">     918 </span>            : //! Remove const (if present) from a type.  stripType() cannot do this because it removes all modifiers.</a>
<a name="919"><span class="lineNum">     919 </span>            : SgType* removeConst(SgType* t);</a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span>            : //! Is this a volatile type?</a>
<a name="922"><span class="lineNum">     922 </span>            : ROSE_DLL_API bool isVolatileType(SgType* t);</a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            : //! Is this a restrict type?</a>
<a name="925"><span class="lineNum">     925 </span>            : ROSE_DLL_API bool isRestrictType(SgType* t);</a>
<a name="926"><span class="lineNum">     926 </span>            : </a>
<a name="927"><span class="lineNum">     927 </span>            : //! Is this a scalar type?</a>
<a name="928"><span class="lineNum">     928 </span>            : /*! We define the following SgType as scalar types: char, short, int, long , void, Wchar, Float, double, long long, string, bool, complex, imaginary</a>
<a name="929"><span class="lineNum">     929 </span>            :  */</a>
<a name="930"><span class="lineNum">     930 </span>            : ROSE_DLL_API bool isScalarType(SgType* t);</a>
<a name="931"><span class="lineNum">     931 </span>            : </a>
<a name="932"><span class="lineNum">     932 </span>            : //! Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long.</a>
<a name="933"><span class="lineNum">     933 </span>            : //!</a>
<a name="934"><span class="lineNum">     934 </span>            : //! There is another similar function named SgType::isIntegerType(), which allows additional types char, wchar, and bool.</a>
<a name="935"><span class="lineNum">     935 </span>            : ROSE_DLL_API bool isStrictIntegerType(SgType* t);</a>
<a name="936"><span class="lineNum">     936 </span>            : </a>
<a name="937"><span class="lineNum">     937 </span>            : //! Check if a type is a struct type (a special SgClassType in ROSE). Typedef and modifier types are not stripped off. Only direct struct type is returned as true.</a>
<a name="938"><span class="lineNum">     938 </span>            : ROSE_DLL_API bool isStructType(SgType* t);</a>
<a name="939"><span class="lineNum">     939 </span>            : </a>
<a name="940"><span class="lineNum">     940 </span>            : //! Generate a mangled string for a given type based on Itanium C++ ABI</a>
<a name="941"><span class="lineNum">     941 </span>            : ROSE_DLL_API std::string mangleType(SgType* type);</a>
<a name="942"><span class="lineNum">     942 </span>            : </a>
<a name="943"><span class="lineNum">     943 </span>            : //! Generate mangled scalar type names according to Itanium C++ ABI, the input type should pass isScalarType() in ROSE</a>
<a name="944"><span class="lineNum">     944 </span>            : ROSE_DLL_API std::string mangleScalarType(SgType* type);</a>
<a name="945"><span class="lineNum">     945 </span>            : </a>
<a name="946"><span class="lineNum">     946 </span>            : //! Generated mangled modifier types, include const, volatile,according to Itanium C++ ABI, with extension to handle UPC shared types.</a>
<a name="947"><span class="lineNum">     947 </span>            : ROSE_DLL_API std::string mangleModifierType(SgModifierType* type);</a>
<a name="948"><span class="lineNum">     948 </span>            : </a>
<a name="949"><span class="lineNum">     949 </span>            : //! Calculate the number of elements of an array type: dim1* dim2*... , assume element count is 1 for int a[]; Strip off THREADS if it is a UPC array.</a>
<a name="950"><span class="lineNum">     950 </span>            : ROSE_DLL_API size_t getArrayElementCount(SgArrayType* t);</a>
<a name="951"><span class="lineNum">     951 </span>            : </a>
<a name="952"><span class="lineNum">     952 </span>            : //! Get the number of dimensions of an array type</a>
<a name="953"><span class="lineNum">     953 </span>            : ROSE_DLL_API int getDimensionCount(SgType* t);</a>
<a name="954"><span class="lineNum">     954 </span>            : </a>
<a name="955"><span class="lineNum">     955 </span>            : //! Get the element type of an array. It recursively find the base type for multi-dimension array types</a>
<a name="956"><span class="lineNum">     956 </span>            : ROSE_DLL_API SgType* getArrayElementType(SgType* t);</a>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<a name="958"><span class="lineNum">     958 </span>            : //! Get the element type of an array, pointer or string, or NULL if not applicable. This function only check one level base type. No recursion.</a>
<a name="959"><span class="lineNum">     959 </span>            : ROSE_DLL_API SgType* getElementType(SgType* t);</a>
<a name="960"><span class="lineNum">     960 </span>            : </a>
<a name="961"><span class="lineNum">     961 </span>            : </a>
<a name="962"><span class="lineNum">     962 </span>            : /// \brief  returns the array dimensions in an array as defined for arrtype</a>
<a name="963"><span class="lineNum">     963 </span>            : /// \param  arrtype the type of a C/C++ array</a>
<a name="964"><span class="lineNum">     964 </span>            : /// \return an array that contains an expression indicating each dimension's size.</a>
<a name="965"><span class="lineNum">     965 </span>            : ///         OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which</a>
<a name="966"><span class="lineNum">     966 </span>            : ///         becomes responsible for freeing the expressions).</a>
<a name="967"><span class="lineNum">     967 </span>            : ///         Note, the first entry of the array is a SgNullExpression, iff the</a>
<a name="968"><span class="lineNum">     968 </span>            : ///         first array dimension was not specified.</a>
<a name="969"><span class="lineNum">     969 </span>            : /// \code</a>
<a name="970"><span class="lineNum">     970 </span>            : ///         int x[] = { 1, 2, 3 };</a>
<a name="971"><span class="lineNum">     971 </span>            : /// \endcode</a>
<a name="972"><span class="lineNum">     972 </span>            : ///         note, the expression does not have to be a constant</a>
<a name="973"><span class="lineNum">     973 </span>            : /// \code</a>
<a name="974"><span class="lineNum">     974 </span>            : ///         int x[i*5];</a>
<a name="975"><span class="lineNum">     975 </span>            : /// \endcode</a>
<a name="976"><span class="lineNum">     976 </span>            : /// \post   return-value.empty() == false</a>
<a name="977"><span class="lineNum">     977 </span>            : /// \post   return-value[*] != NULL (no nullptr in the returned vector)</a>
<a name="978"><span class="lineNum">     978 </span>            : std::vector&lt;SgExpression*&gt;</a>
<a name="979"><span class="lineNum">     979 </span>            : get_C_array_dimensions(const SgArrayType&amp; arrtype);</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            : /// \brief  returns the array dimensions in an array as defined for arrtype</a>
<a name="982"><span class="lineNum">     982 </span>            : /// \param  arrtype the type of a C/C++ array</a>
<a name="983"><span class="lineNum">     983 </span>            : /// \param  varref  a reference to an array variable (the variable of type arrtype)</a>
<a name="984"><span class="lineNum">     984 </span>            : /// \return an array that contains an expression indicating each dimension's size.</a>
<a name="985"><span class="lineNum">     985 </span>            : ///         OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which</a>
<a name="986"><span class="lineNum">     986 </span>            : ///         becomes responsible for freeing the expressions).</a>
<a name="987"><span class="lineNum">     987 </span>            : ///         If the first array dimension was not specified an expression</a>
<a name="988"><span class="lineNum">     988 </span>            : ///         that indicates that size is generated.</a>
<a name="989"><span class="lineNum">     989 </span>            : /// \code</a>
<a name="990"><span class="lineNum">     990 </span>            : ///         int x[][3] = { 1, 2, 3, 4, 5, 6 };</a>
<a name="991"><span class="lineNum">     991 </span>            : /// \endcode</a>
<a name="992"><span class="lineNum">     992 </span>            : ///         the entry for the first dimension will be:</a>
<a name="993"><span class="lineNum">     993 </span>            : /// \code</a>
<a name="994"><span class="lineNum">     994 </span>            : ///         // 3 ... size of 2nd dimension</a>
<a name="995"><span class="lineNum">     995 </span>            : ///         sizeof(x) / (sizeof(int) * 3)</a>
<a name="996"><span class="lineNum">     996 </span>            : /// \endcode</a>
<a name="997"><span class="lineNum">     997 </span>            : /// \pre    arrtype is the array-type of varref</a>
<a name="998"><span class="lineNum">     998 </span>            : /// \post   return-value.empty() == false</a>
<a name="999"><span class="lineNum">     999 </span>            : /// \post   return-value[*] != NULL (no nullptr in the returned vector)</a>
<a name="1000"><span class="lineNum">    1000 </span>            : /// \post   !isSgNullExpression(return-value[*])</a>
<a name="1001"><span class="lineNum">    1001 </span>            : std::vector&lt;SgExpression*&gt;</a>
<a name="1002"><span class="lineNum">    1002 </span>            : get_C_array_dimensions(const SgArrayType&amp; arrtype, const SgVarRefExp&amp; varref);</a>
<a name="1003"><span class="lineNum">    1003 </span>            : </a>
<a name="1004"><span class="lineNum">    1004 </span>            : /// \overload</a>
<a name="1005"><span class="lineNum">    1005 </span>            : /// \note     see get_C_array_dimensions for SgVarRefExp for details.</a>
<a name="1006"><span class="lineNum">    1006 </span>            : /// \todo     make initname const</a>
<a name="1007"><span class="lineNum">    1007 </span>            : std::vector&lt;SgExpression*&gt;</a>
<a name="1008"><span class="lineNum">    1008 </span>            : get_C_array_dimensions(const SgArrayType&amp; arrtype, SgInitializedName&amp; initname);</a>
<a name="1009"><span class="lineNum">    1009 </span>            : </a>
<a name="1010"><span class="lineNum">    1010 </span>            : </a>
<a name="1011"><span class="lineNum">    1011 </span>            : //! Check if an expression is an array access (SgPntrArrRefExp). If so, return its name expression and subscripts if requested. Users can use convertRefToInitializedName() to get the possible name. It does not check if the expression is a top level SgPntrArrRefExp.</a>
<a name="1012"><span class="lineNum">    1012 </span>            : ROSE_DLL_API bool isArrayReference(SgExpression* ref, SgExpression** arrayNameExp=NULL, std::vector&lt;SgExpression*&gt;** subscripts=NULL);</a>
<a name="1013"><span class="lineNum">    1013 </span>            : </a>
<a name="1014"><span class="lineNum">    1014 </span>            : </a>
<a name="1015"><span class="lineNum">    1015 </span>            : //! Collect variable references in array types. The default NodeQuery::querySubTree() will miss variables referenced in array type's index list. e.g. double *buffer = new double[numItems] ;</a>
<a name="1016"><span class="lineNum">    1016 </span>            : ROSE_DLL_API int collectVariableReferencesInArrayTypes (SgLocatedNode* root, Rose_STL_Container&lt;SgNode*&gt; &amp; currentVarRefList);</a>
<a name="1017"><span class="lineNum">    1017 </span>            : //! Has a UPC shared type of any kinds (shared-to-shared, private-to-shared, shared-to-private, shared scalar/array)? An optional parameter, mod_type_out, stores the first SgModifierType with UPC access information.</a>
<a name="1018"><span class="lineNum">    1018 </span>            : /*!</a>
<a name="1019"><span class="lineNum">    1019 </span>            :  * Note: we classify private-to-shared as 'has shared' type for convenience here. It is indeed a private type in strict sense.</a>
<a name="1020"><span class="lineNum">    1020 </span>            :   AST graph for some examples:</a>
<a name="1021"><span class="lineNum">    1021 </span>            :     - shared scalar: SgModifierType --&gt;base type</a>
<a name="1022"><span class="lineNum">    1022 </span>            :     - shared array: SgArrayType --&gt; SgModiferType --&gt; base type</a>
<a name="1023"><span class="lineNum">    1023 </span>            :     - shared to shared: SgModifierType --&gt; SgPointerType --&gt; SgModifierType -&gt;SgTypeInt</a>
<a name="1024"><span class="lineNum">    1024 </span>            :     - shared to private: SgModifierType --&gt; SgPointerType --&gt; base type</a>
<a name="1025"><span class="lineNum">    1025 </span>            :     - private to shared: SgPointerType --&gt; SgModifierType --&gt; base type</a>
<a name="1026"><span class="lineNum">    1026 </span>            :  */</a>
<a name="1027"><span class="lineNum">    1027 </span>            : ROSE_DLL_API bool hasUpcSharedType(SgType* t, SgModifierType ** mod_type_out = NULL  );</a>
<a name="1028"><span class="lineNum">    1028 </span>            : </a>
<a name="1029"><span class="lineNum">    1029 </span>            : //! Check if a type is a UPC shared type, including shared array, shared pointers etc. Exclude private pointers to shared types. Optionally return the modifier type with the UPC shared property.</a>
<a name="1030"><span class="lineNum">    1030 </span>            : /*!</a>
<a name="1031"><span class="lineNum">    1031 </span>            :  * ROSE uses SgArrayType of SgModifierType to represent shared arrays, not SgModifierType points to SgArrayType. Also typedef may cause a chain of nodes before reach the actual SgModifierType with UPC shared property.</a>
<a name="1032"><span class="lineNum">    1032 </span>            :  */</a>
<a name="1033"><span class="lineNum">    1033 </span>            : ROSE_DLL_API bool isUpcSharedType(SgType* t, SgModifierType ** mod_type_out = NULL);</a>
<a name="1034"><span class="lineNum">    1034 </span>            : </a>
<a name="1035"><span class="lineNum">    1035 </span>            : //! Check if a modifier type is a UPC shared type.</a>
<a name="1036"><span class="lineNum">    1036 </span>            : ROSE_DLL_API bool isUpcSharedModifierType (SgModifierType* mod_type);</a>
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<a name="1038"><span class="lineNum">    1038 </span>            : //! Check if an array type is a UPC shared type. ROSE AST represents a UPC shared array as regular array of elements of UPC shared Modifier Type. Not directly a UPC shared Modifier Type of an array.</a>
<a name="1039"><span class="lineNum">    1039 </span>            : ROSE_DLL_API bool isUpcSharedArrayType (SgArrayType* array_type);</a>
<a name="1040"><span class="lineNum">    1040 </span>            : </a>
<a name="1041"><span class="lineNum">    1041 </span>            : //! Check if a shared UPC type is strict memory consistency or not. Return false if it is relaxed. (So isUpcRelaxedSharedModifierType() is not necessary.)</a>
<a name="1042"><span class="lineNum">    1042 </span>            : ROSE_DLL_API bool isUpcStrictSharedModifierType(SgModifierType* mode_type);</a>
<a name="1043"><span class="lineNum">    1043 </span>            : </a>
<a name="1044"><span class="lineNum">    1044 </span>            : //! Get the block size of a UPC shared modifier type</a>
<a name="1045"><span class="lineNum">    1045 </span>            : ROSE_DLL_API size_t getUpcSharedBlockSize(SgModifierType* mod_type);</a>
<a name="1046"><span class="lineNum">    1046 </span>            : </a>
<a name="1047"><span class="lineNum">    1047 </span>            : //! Get the block size of a UPC shared type, including Modifier types and array of modifier types (shared arrays)</a>
<a name="1048"><span class="lineNum">    1048 </span>            : ROSE_DLL_API size_t getUpcSharedBlockSize(SgType* t);</a>
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<a name="1050"><span class="lineNum">    1050 </span>            : //! Is UPC phase-less shared type? Phase-less means block size of the first SgModifierType with UPC information is 1 or 0/unspecified. Also return false if the type is not a UPC shared type.</a>
<a name="1051"><span class="lineNum">    1051 </span>            : ROSE_DLL_API bool isUpcPhaseLessSharedType (SgType* t);</a>
<a name="1052"><span class="lineNum">    1052 </span>            : </a>
<a name="1053"><span class="lineNum">    1053 </span>            : //! Is a UPC private-to-shared pointer?  SgPointerType comes first compared to SgModifierType with UPC information. Input type must be any of UPC shared types first.</a>
<a name="1054"><span class="lineNum">    1054 </span>            : ROSE_DLL_API bool isUpcPrivateToSharedType(SgType* t);</a>
<a name="1055"><span class="lineNum">    1055 </span>            : </a>
<a name="1056"><span class="lineNum">    1056 </span>            : //! Is a UPC array with dimension of X*THREADS</a>
<a name="1057"><span class="lineNum">    1057 </span>            : ROSE_DLL_API bool isUpcArrayWithThreads(SgArrayType* t);</a>
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<a name="1059"><span class="lineNum">    1059 </span>            : //! Lookup a named type based on its name, bottomup searching from a specified scope. Note name collison might be allowed for c (not C++) between typedef and enum/struct. Only the first matched named type will be returned in this case. typedef is returned as it is, not the base type it actually refers to.</a>
<a name="1060"><span class="lineNum">    1060 </span>            : ROSE_DLL_API SgType* lookupNamedTypeInParentScopes(const std::string&amp; type_name, SgScopeStatement* scope=NULL);</a>
<a name="1061"><span class="lineNum">    1061 </span>            : </a>
<a name="1062"><span class="lineNum">    1062 </span>            : // DQ (7/22/2014): Added support for comparing expression types in actual arguments with those expected from the formal function parameter types.</a>
<a name="1063"><span class="lineNum">    1063 </span>            : //! Get the type of the associated argument expression from the function type.</a>
<a name="1064"><span class="lineNum">    1064 </span>            : ROSE_DLL_API SgType* getAssociatedTypeFromFunctionTypeList(SgExpression* actual_argument_expression);</a>
<a name="1065"><span class="lineNum">    1065 </span>            : </a>
<a name="1066"><span class="lineNum">    1066 </span>            : //! Verify that 2 SgTemplateArgument are equivalent (same type, same expression, or same template declaration)</a>
<a name="1067"><span class="lineNum">    1067 </span>            : ROSE_DLL_API bool templateArgumentEquivalence(SgTemplateArgument * arg1, SgTemplateArgument * arg2);</a>
<a name="1068"><span class="lineNum">    1068 </span>            : </a>
<a name="1069"><span class="lineNum">    1069 </span>            : //! Verify that 2 SgTemplateArgumentPtrList are equivalent.</a>
<a name="1070"><span class="lineNum">    1070 </span>            : ROSE_DLL_API bool templateArgumentListEquivalence(const SgTemplateArgumentPtrList &amp; list1, const SgTemplateArgumentPtrList &amp; list2);</a>
<a name="1071"><span class="lineNum">    1071 </span>            : </a>
<a name="1072"><span class="lineNum">    1072 </span>            : //! Test for equivalence of types independent of access permissions (private or protected modes for members of classes).</a>
<a name="1073"><span class="lineNum">    1073 </span>            : ROSE_DLL_API bool isEquivalentType (const SgType* lhs, const SgType* rhs);</a>
<a name="1074"><span class="lineNum">    1074 </span>            : </a>
<a name="1075"><span class="lineNum">    1075 </span>            : //! Find the function type matching a function signature plus a given return type</a>
<a name="1076"><span class="lineNum">    1076 </span>            : ROSE_DLL_API SgFunctionType* findFunctionType (SgType* return_type, SgFunctionParameterTypeList* typeList);</a>
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<a name="1078"><span class="lineNum">    1078 </span>            : //! Test if two types are equivalent SgFunctionType nodes. This is necessary for template function types</a>
<a name="1079"><span class="lineNum">    1079 </span>            : //! They may differ in one SgTemplateType pointer but identical otherwise.</a>
<a name="1080"><span class="lineNum">    1080 </span>            : ROSE_DLL_API bool isEquivalentFunctionType (const SgFunctionType* lhs, const SgFunctionType* rhs);</a>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<a name="1082"><span class="lineNum">    1082 </span>            : //@}</a>
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<a name="1084"><span class="lineNum">    1084 </span>            : //------------------------------------------------------------------------</a>
<a name="1085"><span class="lineNum">    1085 </span>            : //@{</a>
<a name="1086"><span class="lineNum">    1086 </span>            : /*! @name Loop handling</a>
<a name="1087"><span class="lineNum">    1087 </span>            :   \brief</a>
<a name="1088"><span class="lineNum">    1088 </span>            : */</a>
<a name="1089"><span class="lineNum">    1089 </span>            : </a>
<a name="1090"><span class="lineNum">    1090 </span>            : // by Jeremiah</a>
<a name="1091"><span class="lineNum">    1091 </span>            : //! Add a step statement to the end of a loop body</a>
<a name="1092"><span class="lineNum">    1092 </span>            : //! Add a new label to the end of the loop, with the step statement after</a>
<a name="1093"><span class="lineNum">    1093 </span>            : //! it; then change all continue statements in the old loop body into</a>
<a name="1094"><span class="lineNum">    1094 </span>            : //! jumps to the label</a>
<a name="1095"><span class="lineNum">    1095 </span>            : //!</a>
<a name="1096"><span class="lineNum">    1096 </span>            : //! For example:</a>
<a name="1097"><span class="lineNum">    1097 </span>            : //! while (a &lt; 5) {if (a &lt; -3) continue;} (adding &quot;a++&quot; to end) becomes</a>
<a name="1098"><span class="lineNum">    1098 </span>            : //! while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;}</a>
<a name="1099"><span class="lineNum">    1099 </span>            : ROSE_DLL_API void addStepToLoopBody(SgScopeStatement* loopStmt, SgStatement* step);</a>
<a name="1100"><span class="lineNum">    1100 </span>            : </a>
<a name="1101"><span class="lineNum">    1101 </span>            : ROSE_DLL_API void moveForStatementIncrementIntoBody(SgForStatement* f);</a>
<a name="1102"><span class="lineNum">    1102 </span>            : ROSE_DLL_API void convertForToWhile(SgForStatement* f);</a>
<a name="1103"><span class="lineNum">    1103 </span>            : ROSE_DLL_API void convertAllForsToWhiles(SgNode* top);</a>
<a name="1104"><span class="lineNum">    1104 </span>            : //! Change continue statements in a given block of code to gotos to a label</a>
<a name="1105"><span class="lineNum">    1105 </span>            : ROSE_DLL_API void changeContinuesToGotos(SgStatement* stmt, SgLabelStatement* label);</a>
<a name="1106"><span class="lineNum">    1106 </span>            : </a>
<a name="1107"><span class="lineNum">    1107 </span>            : //!Return the loop index variable for a for loop</a>
<a name="1108"><span class="lineNum">    1108 </span>            : ROSE_DLL_API SgInitializedName* getLoopIndexVariable(SgNode* loop);</a>
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<a name="1110"><span class="lineNum">    1110 </span>            : //!Check if a SgInitializedName is used as a loop index within a AST subtree</a>
<a name="1111"><span class="lineNum">    1111 </span>            : //! This function will use a bottom-up traverse starting from the subtree_root to find all enclosing loops and check if ivar is used as an index for either of them.</a>
<a name="1112"><span class="lineNum">    1112 </span>            : ROSE_DLL_API bool isLoopIndexVariable(SgInitializedName* ivar, SgNode* subtree_root);</a>
<a name="1113"><span class="lineNum">    1113 </span>            : </a>
<a name="1114"><span class="lineNum">    1114 </span>            : //! Check if a for loop uses C99 style initialization statement with multiple expressions like for (int i=0, j=0; ..) or for (i=0,j=0;...)</a>
<a name="1115"><span class="lineNum">    1115 </span>            : /*!</a>
<a name="1116"><span class="lineNum">    1116 </span>            :    for (int i=0, j=0; ..) is stored as two variable declarations under SgForInitStatement's init_stmt member</a>
<a name="1117"><span class="lineNum">    1117 </span>            :    for (i=0,j=0;...) is stored as a single expression statement, with comma expression (i=0,j=0).</a>
<a name="1118"><span class="lineNum">    1118 </span>            : */</a>
<a name="1119"><span class="lineNum">    1119 </span>            : ROSE_DLL_API bool hasMultipleInitStatmentsOrExpressions (SgForStatement* for_loop);</a>
<a name="1120"><span class="lineNum">    1120 </span>            : </a>
<a name="1121"><span class="lineNum">    1121 </span>            : //! Routines to get and set the body of a loop</a>
<a name="1122"><span class="lineNum">    1122 </span>            : ROSE_DLL_API SgStatement* getLoopBody(SgScopeStatement* loop);</a>
<a name="1123"><span class="lineNum">    1123 </span>            : </a>
<a name="1124"><span class="lineNum">    1124 </span>            : ROSE_DLL_API void setLoopBody(SgScopeStatement* loop, SgStatement* body);</a>
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<a name="1126"><span class="lineNum">    1126 </span>            : //! Routines to get the condition of a loop. It recognize While-loop, For-loop, and Do-While-loop</a>
<a name="1127"><span class="lineNum">    1127 </span>            : ROSE_DLL_API SgStatement* getLoopCondition(SgScopeStatement* loop);</a>
<a name="1128"><span class="lineNum">    1128 </span>            : </a>
<a name="1129"><span class="lineNum">    1129 </span>            : //! Set the condition statement of a loop, including While-loop, For-loop, and Do-While-loop.</a>
<a name="1130"><span class="lineNum">    1130 </span>            : ROSE_DLL_API void setLoopCondition(SgScopeStatement* loop, SgStatement* cond);</a>
<a name="1131"><span class="lineNum">    1131 </span>            : </a>
<a name="1132"><span class="lineNum">    1132 </span>            : //! Check if a for-loop has a canonical form, return loop index, bounds, step, and body if requested</a>
<a name="1133"><span class="lineNum">    1133 </span>            : //!</a>
<a name="1134"><span class="lineNum">    1134 </span>            : //! A canonical form is defined as : one initialization statement, a test expression, and an increment expression , loop index variable should be of an integer type.  IsInclusiveUpperBound is true when &lt;= or &gt;= is used for loop condition</a>
<a name="1135"><span class="lineNum">    1135 </span>            : ROSE_DLL_API bool isCanonicalForLoop(SgNode* loop, SgInitializedName** ivar=NULL, SgExpression** lb=NULL, SgExpression** ub=NULL, SgExpression** step=NULL, SgStatement** body=NULL, bool *hasIncrementalIterationSpace = NULL, bool* isInclusiveUpperBound = NULL);</a>
<a name="1136"><span class="lineNum">    1136 </span>            : </a>
<a name="1137"><span class="lineNum">    1137 </span>            : //! Check if a Fortran Do loop has a complete canonical form: Do I=1, 10, 1</a>
<a name="1138"><span class="lineNum">    1138 </span>            : ROSE_DLL_API bool isCanonicalDoLoop(SgFortranDo* loop,SgInitializedName** ivar/*=NULL*/, SgExpression** lb/*=NULL*/, SgExpression** ub/*=NULL*/, SgExpression** step/*=NULL*/, SgStatement** body/*=NULL*/, bool *hasIncrementalIterationSpace/*= NULL*/, bool* isInclusiveUpperBound/*=NULL*/);</a>
<a name="1139"><span class="lineNum">    1139 </span>            : </a>
<a name="1140"><span class="lineNum">    1140 </span>            : //! Set the lower bound of a loop header for (i=lb; ...)</a>
<a name="1141"><span class="lineNum">    1141 </span>            : ROSE_DLL_API void setLoopLowerBound(SgNode* loop, SgExpression* lb);</a>
<a name="1142"><span class="lineNum">    1142 </span>            : </a>
<a name="1143"><span class="lineNum">    1143 </span>            : //! Set the upper bound of a loop header,regardless the condition expression type.  for (i=lb; i op up, ...)</a>
<a name="1144"><span class="lineNum">    1144 </span>            : ROSE_DLL_API void setLoopUpperBound(SgNode* loop, SgExpression* ub);</a>
<a name="1145"><span class="lineNum">    1145 </span>            : </a>
<a name="1146"><span class="lineNum">    1146 </span>            : //! Set the stride(step) of a loop 's incremental expression, regardless the expression types (i+=s; i= i+s, etc)</a>
<a name="1147"><span class="lineNum">    1147 </span>            : ROSE_DLL_API void setLoopStride(SgNode* loop, SgExpression* stride);</a>
<a name="1148"><span class="lineNum">    1148 </span>            : </a>
<a name="1149"><span class="lineNum">    1149 </span>            : </a>
<a name="1150"><span class="lineNum">    1150 </span>            : //! Normalize loop init stmt by promoting the single variable declaration statement outside of the for loop header's init statement, e.g. for (int i=0;) becomes int i_x; for (i_x=0;..) and rewrite the loop with the new index variable, if necessary</a>
<a name="1151"><span class="lineNum">    1151 </span>            : ROSE_DLL_API bool normalizeForLoopInitDeclaration(SgForStatement* loop);</a>
<a name="1152"><span class="lineNum">    1152 </span>            : </a>
<a name="1153"><span class="lineNum">    1153 </span>            : //! Undo the normalization of for loop's C99 init declaration. Previous record of normalization is used to ease the reverse transformation.</a>
<a name="1154"><span class="lineNum">    1154 </span>            : ROSE_DLL_API bool unnormalizeForLoopInitDeclaration(SgForStatement* loop);</a>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<a name="1156"><span class="lineNum">    1156 </span>            : //! Normalize a for loop, return true if successful. Generated constants will be fold by default.</a>
<a name="1157"><span class="lineNum">    1157 </span>            : //!</a>
<a name="1158"><span class="lineNum">    1158 </span>            : //! Translations are :</a>
<a name="1159"><span class="lineNum">    1159 </span>            : //!    For the init statement: for (int i=0;... ) becomes int i; for (i=0;..)</a>
<a name="1160"><span class="lineNum">    1160 </span>            : //!    For test expression:</a>
<a name="1161"><span class="lineNum">    1161 </span>            : //!           i&lt;x is normalized to i&lt;= (x-1) and</a>
<a name="1162"><span class="lineNum">    1162 </span>            : //!           i&gt;x is normalized to i&gt;= (x+1)</a>
<a name="1163"><span class="lineNum">    1163 </span>            : //!    For increment expression:</a>
<a name="1164"><span class="lineNum">    1164 </span>            : //!           i++ is normalized to i+=1 and</a>
<a name="1165"><span class="lineNum">    1165 </span>            : //!           i-- is normalized to i+=-1</a>
<a name="1166"><span class="lineNum">    1166 </span>            : //!           i-=s is normalized to i+= -s</a>
<a name="1167"><span class="lineNum">    1167 </span>            : ROSE_DLL_API bool forLoopNormalization(SgForStatement* loop, bool foldConstant = true);</a>
<a name="1168"><span class="lineNum">    1168 </span>            : </a>
<a name="1169"><span class="lineNum">    1169 </span>            : //! Normalize a for loop's test expression</a>
<a name="1170"><span class="lineNum">    1170 </span>            : //!           i&lt;x is normalized to i&lt;= (x-1) and</a>
<a name="1171"><span class="lineNum">    1171 </span>            : //!           i&gt;x is normalized to i&gt;= (x+1)</a>
<a name="1172"><span class="lineNum">    1172 </span>            : ROSE_DLL_API bool normalizeForLoopTest(SgForStatement* loop);</a>
<a name="1173"><span class="lineNum">    1173 </span>            : ROSE_DLL_API bool normalizeForLoopIncrement(SgForStatement* loop);</a>
<a name="1174"><span class="lineNum">    1174 </span>            : </a>
<a name="1175"><span class="lineNum">    1175 </span>            : //!Normalize a Fortran Do loop. Make the default increment expression (1) explicit</a>
<a name="1176"><span class="lineNum">    1176 </span>            : ROSE_DLL_API bool doLoopNormalization(SgFortranDo* loop);</a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            : //!  Unroll a target loop with a specified unrolling factor. It handles steps larger than 1 and adds a fringe loop if the iteration count is not evenly divisible by the unrolling factor.</a>
<a name="1179"><span class="lineNum">    1179 </span>            : ROSE_DLL_API bool loopUnrolling(SgForStatement* loop, size_t unrolling_factor);</a>
<a name="1180"><span class="lineNum">    1180 </span>            : </a>
<a name="1181"><span class="lineNum">    1181 </span>            : //! Interchange/permutate a n-level perfectly-nested loop rooted at 'loop' using a lexicographical order number within (0,depth!).</a>
<a name="1182"><span class="lineNum">    1182 </span>            : ROSE_DLL_API bool loopInterchange(SgForStatement* loop, size_t depth, size_t lexicoOrder);</a>
<a name="1183"><span class="lineNum">    1183 </span>            : </a>
<a name="1184"><span class="lineNum">    1184 </span>            : //! Tile the n-level (starting from 1) loop of a perfectly nested loop nest using tiling size s</a>
<a name="1185"><span class="lineNum">    1185 </span>            : ROSE_DLL_API bool loopTiling(SgForStatement* loopNest, size_t targetLevel, size_t tileSize);</a>
<a name="1186"><span class="lineNum">    1186 </span>            : </a>
<a name="1187"><span class="lineNum">    1187 </span>            : //Winnie Loop Collapsing</a>
<a name="1188"><span class="lineNum">    1188 </span>            : SgExprListExp * loopCollapsing(SgForStatement* target_loop, size_t collapsing_factor);</a>
<a name="1189"><span class="lineNum">    1189 </span>            : </a>
<a name="1190"><span class="lineNum">    1190 </span>            : bool getForLoopInformations(</a>
<a name="1191"><span class="lineNum">    1191 </span>            :   SgForStatement * for_loop,</a>
<a name="1192"><span class="lineNum">    1192 </span>            :   SgVariableSymbol * &amp; iterator,</a>
<a name="1193"><span class="lineNum">    1193 </span>            :   SgExpression * &amp; lower_bound,</a>
<a name="1194"><span class="lineNum">    1194 </span>            :   SgExpression * &amp; upper_bound,</a>
<a name="1195"><span class="lineNum">    1195 </span>            :   SgExpression * &amp; stride</a>
<a name="1196"><span class="lineNum">    1196 </span>            : );</a>
<a name="1197"><span class="lineNum">    1197 </span>            : </a>
<a name="1198"><span class="lineNum">    1198 </span>            : //@}</a>
<a name="1199"><span class="lineNum">    1199 </span>            : </a>
<a name="1200"><span class="lineNum">    1200 </span>            : //------------------------------------------------------------------------</a>
<a name="1201"><span class="lineNum">    1201 </span>            : //@{</a>
<a name="1202"><span class="lineNum">    1202 </span>            : /*! @name Topdown search</a>
<a name="1203"><span class="lineNum">    1203 </span>            :   \brief Top-down traversal from current node to find a node of a specified type</a>
<a name="1204"><span class="lineNum">    1204 </span>            : */</a>
<a name="1205"><span class="lineNum">    1205 </span>            : </a>
<a name="1206"><span class="lineNum">    1206 </span>            : //! Query a subtree to get all nodes of a given type, with an appropriate downcast.</a>
<a name="1207"><span class="lineNum">    1207 </span>            : template &lt;typename NodeType&gt;</a>
<a name="1208"><span class="lineNum">    1208 </span><span class="lineCov">         13 : std::vector&lt;NodeType*&gt; querySubTree(SgNode* top, VariantT variant = (VariantT)NodeType::static_variant)</span></a>
<a name="1209"><span class="lineNum">    1209 </span>            :    {</a>
<a name="1210"><span class="lineNum">    1210 </span>            : #if 0</a>
<a name="1211"><span class="lineNum">    1211 </span>            :      printf (&quot;Top of SageInterface::querySubTree() \n&quot;);</a>
<a name="1212"><span class="lineNum">    1212 </span>            : #endif</a>
<a name="1213"><span class="lineNum">    1213 </span>            : </a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineCov">         13 :      Rose_STL_Container&lt;SgNode*&gt; nodes = NodeQuery::querySubTree(top,variant);</span></a>
<a name="1215"><span class="lineNum">    1215 </span><span class="lineCov">         13 :      std::vector&lt;NodeType*&gt; result(nodes.size(), NULL);</span></a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineCov">         13 :      int count = 0;</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            : #if 0</a>
<a name="1218"><span class="lineNum">    1218 </span>            :      printf (&quot;In SageInterface::querySubTree(): before initialization loop \n&quot;);</a>
<a name="1219"><span class="lineNum">    1219 </span>            : #endif</a>
<a name="1220"><span class="lineNum">    1220 </span>            : </a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineCov">         72 :      for (Rose_STL_Container&lt;SgNode*&gt;::const_iterator i = nodes.begin(); i != nodes.end(); ++i, ++count)</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            :         {</a>
<a name="1223"><span class="lineNum">    1223 </span>            : #if 0</a>
<a name="1224"><span class="lineNum">    1224 </span>            :           printf (&quot;In SageInterface::querySubTree(): in loop: count = %d \n&quot;,count);</a>
<a name="1225"><span class="lineNum">    1225 </span>            : #endif</a>
<a name="1226"><span class="lineNum">    1226 </span><span class="lineCov">         59 :           NodeType* node = dynamic_cast&lt;NodeType*&gt;(*i);</span></a>
<a name="1227"><span class="lineNum">    1227 </span><span class="lineCov">         59 :           ROSE_ASSERT (node);</span></a>
<a name="1228"><span class="lineNum">    1228 </span><span class="lineCov">         59 :           result[count] = node;</span></a>
<a name="1229"><span class="lineNum">    1229 </span>            :         }</a>
<a name="1230"><span class="lineNum">    1230 </span>            : #if 0</a>
<a name="1231"><span class="lineNum">    1231 </span>            :      printf (&quot;Leaving SageInterface::querySubTree(): after initialization loop \n&quot;);</a>
<a name="1232"><span class="lineNum">    1232 </span>            : #endif</a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineCov">         13 :      return result;</span></a>
<a name="1235"><span class="lineNum">    1235 </span>            :    }</a>
<a name="1236"><span class="lineNum">    1236 </span>            :   /*! \brief Returns STL vector of SgFile IR node pointers.</a>
<a name="1237"><span class="lineNum">    1237 </span>            : </a>
<a name="1238"><span class="lineNum">    1238 </span>            :       Demonstrates use of restricted traversal over just SgFile IR nodes.</a>
<a name="1239"><span class="lineNum">    1239 </span>            :    */</a>
<a name="1240"><span class="lineNum">    1240 </span>            :     std::vector &lt; SgFile * &gt;generateFileList ();</a>
<a name="1241"><span class="lineNum">    1241 </span>            : </a>
<a name="1242"><span class="lineNum">    1242 </span>            : /** Get the current SgProject IR Node.</a>
<a name="1243"><span class="lineNum">    1243 </span>            :  *</a>
<a name="1244"><span class="lineNum">    1244 </span>            :  *  The library should never have more than one project and it asserts such.  If no project has been created yet then this</a>
<a name="1245"><span class="lineNum">    1245 </span>            :  *  function returns the null pointer. */</a>
<a name="1246"><span class="lineNum">    1246 </span>            : ROSE_DLL_API SgProject * getProject();</a>
<a name="1247"><span class="lineNum">    1247 </span>            : </a>
<a name="1248"><span class="lineNum">    1248 </span>            :   //! \return the project associated with a node</a>
<a name="1249"><span class="lineNum">    1249 </span>            :   SgProject * getProject(const SgNode * node);</a>
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<a name="1251"><span class="lineNum">    1251 </span>            : //! Query memory pools to grab SgNode of a specified type</a>
<a name="1252"><span class="lineNum">    1252 </span>            : template &lt;typename NodeType&gt;</a>
<a name="1253"><span class="lineNum">    1253 </span><span class="lineCov">         81 : static std::vector&lt;NodeType*&gt; getSgNodeListFromMemoryPool()</span></a>
<a name="1254"><span class="lineNum">    1254 </span>            : {</a>
<a name="1255"><span class="lineNum">    1255 </span>            :   // This function uses a memory pool traversal specific to the SgFile IR nodes</a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineCov">         81 :   class MyTraversal : public ROSE_VisitTraversal</span></a>
<a name="1257"><span class="lineNum">    1257 </span>            :   {</a>
<a name="1258"><span class="lineNum">    1258 </span>            :     public:</a>
<a name="1259"><span class="lineNum">    1259 </span>            :       std::vector&lt;NodeType*&gt; resultlist;</a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineCov">         81 :       void visit ( SgNode* node)</span></a>
<a name="1261"><span class="lineNum">    1261 </span>            :       {</a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineCov">         81 :         NodeType* result = dynamic_cast&lt;NodeType* &gt; (node);</span></a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineCov">         81 :         ROSE_ASSERT(result!= NULL);</span></a>
<a name="1264"><span class="lineNum">    1264 </span>            :         if (result!= NULL)</a>
<a name="1265"><span class="lineNum">    1265 </span>            :         {</a>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineCov">         81 :           resultlist.push_back(result);</span></a>
<a name="1267"><span class="lineNum">    1267 </span>            :         }</a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">         81 :       };</span></a>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineCov">        162 :       virtual ~MyTraversal() {}</span></a>
<a name="1270"><span class="lineNum">    1270 </span>            :   };</a>
<a name="1271"><span class="lineNum">    1271 </span>            : </a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineCov">        162 :   MyTraversal my_traversal;</span></a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineCov">         81 :   NodeType::traverseMemoryPoolNodes(my_traversal);</span></a>
<a name="1274"><span class="lineNum">    1274 </span><span class="lineCov">        162 :   return my_traversal.resultlist;</span></a>
<a name="1275"><span class="lineNum">    1275 </span>            : }</a>
<a name="1276"><span class="lineNum">    1276 </span>            : </a>
<a name="1277"><span class="lineNum">    1277 </span>            : </a>
<a name="1278"><span class="lineNum">    1278 </span>            : /*! \brief top-down traversal from current node to find the main() function declaration</a>
<a name="1279"><span class="lineNum">    1279 </span>            : */</a>
<a name="1280"><span class="lineNum">    1280 </span>            : ROSE_DLL_API SgFunctionDeclaration* findMain(SgNode* currentNode);</a>
<a name="1281"><span class="lineNum">    1281 </span>            : </a>
<a name="1282"><span class="lineNum">    1282 </span>            : //! Find the last declaration statement within a scope (if any). This is often useful to decide where to insert another variable declaration statement. Pragma declarations are not treated as a declaration by default in this context.</a>
<a name="1283"><span class="lineNum">    1283 </span>            : SgStatement* findLastDeclarationStatement(SgScopeStatement * scope, bool includePragma = false);</a>
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<a name="1285"><span class="lineNum">    1285 </span>            :           //midend/programTransformation/partialRedundancyElimination/pre.h</a>
<a name="1286"><span class="lineNum">    1286 </span>            : //! Find referenced symbols within an expression</a>
<a name="1287"><span class="lineNum">    1287 </span>            : std::vector&lt;SgVariableSymbol*&gt; getSymbolsUsedInExpression(SgExpression* expr);</a>
<a name="1288"><span class="lineNum">    1288 </span>            : </a>
<a name="1289"><span class="lineNum">    1289 </span>            : //! Find break statements inside a particular statement, stopping at nested loops or switches</a>
<a name="1290"><span class="lineNum">    1290 </span>            : /*! loops or switch statements defines their own contexts for break</a>
<a name="1291"><span class="lineNum">    1291 </span>            :  statements.  The function will stop immediately if run on a loop or switch</a>
<a name="1292"><span class="lineNum">    1292 </span>            :  statement.  If fortranLabel is non-empty, breaks (EXITs) to that label within</a>
<a name="1293"><span class="lineNum">    1293 </span>            :  nested loops are included in the returned list.</a>
<a name="1294"><span class="lineNum">    1294 </span>            : */</a>
<a name="1295"><span class="lineNum">    1295 </span>            : std::vector&lt;SgBreakStmt*&gt; findBreakStmts(SgStatement* code, const std::string&amp; fortranLabel = &quot;&quot;);</a>
<a name="1296"><span class="lineNum">    1296 </span>            : </a>
<a name="1297"><span class="lineNum">    1297 </span>            : //! Find all continue statements inside a particular statement, stopping at nested loops</a>
<a name="1298"><span class="lineNum">    1298 </span>            : /*! Nested loops define their own contexts for continue statements.  The</a>
<a name="1299"><span class="lineNum">    1299 </span>            :  function will stop immediately if run on a loop</a>
<a name="1300"><span class="lineNum">    1300 </span>            :  statement.  If fortranLabel is non-empty, continues (CYCLEs) to that label</a>
<a name="1301"><span class="lineNum">    1301 </span>            :  within nested loops are included in the returned list.</a>
<a name="1302"><span class="lineNum">    1302 </span>            : */</a>
<a name="1303"><span class="lineNum">    1303 </span>            : std::vector&lt;SgContinueStmt*&gt; findContinueStmts(SgStatement* code, const std::string&amp; fortranLabel = &quot;&quot;);</a>
<a name="1304"><span class="lineNum">    1304 </span>            : std::vector&lt;SgGotoStatement*&gt; findGotoStmts(SgStatement* scope, SgLabelStatement* l);</a>
<a name="1305"><span class="lineNum">    1305 </span>            : std::vector&lt;SgStatement*&gt; getSwitchCases(SgSwitchStatement* sw);</a>
<a name="1306"><span class="lineNum">    1306 </span>            : </a>
<a name="1307"><span class="lineNum">    1307 </span>            : //! Collect all variable references in a subtree</a>
<a name="1308"><span class="lineNum">    1308 </span>            : void collectVarRefs(SgLocatedNode* root, std::vector&lt;SgVarRefExp* &gt;&amp; result);</a>
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<a name="1310"><span class="lineNum">    1310 </span>            :   //! Topdown traverse a subtree from root to find the first declaration given its name, scope (optional, can be NULL), and defining or nondefining flag.</a>
<a name="1311"><span class="lineNum">    1311 </span>            : template &lt;typename T&gt;</a>
<a name="1312"><span class="lineNum">    1312 </span><span class="lineCov">     442112 : T* findDeclarationStatement(SgNode* root, std::string name, SgScopeStatement* scope, bool isDefining)</span></a>
<a name="1313"><span class="lineNum">    1313 </span>            :    {</a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineCov">     442112 :      bool found = false;</span></a>
<a name="1315"><span class="lineNum">    1315 </span>            : </a>
<a name="1316"><span class="lineNum">    1316 </span>            : #if 0</a>
<a name="1317"><span class="lineNum">    1317 </span>            :      printf (&quot;In findDeclarationStatement(): root       = %p \n&quot;,root);</a>
<a name="1318"><span class="lineNum">    1318 </span>            :      printf (&quot;In findDeclarationStatement(): name       = %s \n&quot;,name.c_str());</a>
<a name="1319"><span class="lineNum">    1319 </span>            :      printf (&quot;In findDeclarationStatement(): scope      = %p \n&quot;,scope);</a>
<a name="1320"><span class="lineNum">    1320 </span>            :      printf (&quot;In findDeclarationStatement(): isDefining = %s \n&quot;,isDefining ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1321"><span class="lineNum">    1321 </span>            : #endif</a>
<a name="1322"><span class="lineNum">    1322 </span>            : </a>
<a name="1323"><span class="lineNum">    1323 </span>            :   // Do we really want a NULL pointer to be acceptable input to this function?</a>
<a name="1324"><span class="lineNum">    1324 </span>            :   // Maybe we should have an assertion that it is non-null?</a>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineCov">     442112 :      if (!root) return NULL;</span></a>
<a name="1326"><span class="lineNum">    1326 </span>            : </a>
<a name="1327"><span class="lineNum">    1327 </span><span class="lineCov">     299605 :      T* decl = dynamic_cast&lt;T*&gt;(root);</span></a>
<a name="1328"><span class="lineNum">    1328 </span>            : </a>
<a name="1329"><span class="lineNum">    1329 </span>            : #if 0</a>
<a name="1330"><span class="lineNum">    1330 </span>            :      printf (&quot;In findDeclarationStatement(): decl       = %p \n&quot;,decl);</a>
<a name="1331"><span class="lineNum">    1331 </span>            : #endif</a>
<a name="1332"><span class="lineNum">    1332 </span>            : </a>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineCov">     299605 :      if (decl != NULL)</span></a>
<a name="1334"><span class="lineNum">    1334 </span>            :         {</a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineCov">      30577 :           if (scope)</span></a>
<a name="1336"><span class="lineNum">    1336 </span>            :              {</a>
<a name="1337"><span class="lineNum">    1337 </span><span class="lineNoCov">          0 :                if ((decl-&gt;get_scope() == scope) &amp;&amp; (decl-&gt;search_for_symbol_from_symbol_table()-&gt;get_name() == name))</span></a>
<a name="1338"><span class="lineNum">    1338 </span>            :                   {</a>
<a name="1339"><span class="lineNum">    1339 </span>            :                     found = true;</a>
<a name="1340"><span class="lineNum">    1340 </span>            :                   }</a>
<a name="1341"><span class="lineNum">    1341 </span>            :              }</a>
<a name="1342"><span class="lineNum">    1342 </span>            :             else // Liao 2/9/2010. We should allow NULL scope</a>
<a name="1343"><span class="lineNum">    1343 </span>            :              {</a>
<a name="1344"><span class="lineNum">    1344 </span>            : #if 0</a>
<a name="1345"><span class="lineNum">    1345 </span>            :             // DQ (12/6/2016): Include this into the debugging code to aboid compiler warning about unused variable.</a>
<a name="1346"><span class="lineNum">    1346 </span>            :                SgSymbol* symbol = decl-&gt;search_for_symbol_from_symbol_table();</a>
<a name="1347"><span class="lineNum">    1347 </span>            :                printf (&quot;In findDeclarationStatement(): decl-&gt;search_for_symbol_from_symbol_table() = %p \n&quot;,symbol);</a>
<a name="1348"><span class="lineNum">    1348 </span>            :                printf (&quot;In findDeclarationStatement(): decl-&gt;search_for_symbol_from_symbol_table()-&gt;get_name() = %s \n&quot;,symbol-&gt;get_name().str());</a>
<a name="1349"><span class="lineNum">    1349 </span>            : #endif</a>
<a name="1350"><span class="lineNum">    1350 </span><span class="lineCov">      30577 :                if (decl-&gt;search_for_symbol_from_symbol_table()-&gt;get_name() == name)</span></a>
<a name="1351"><span class="lineNum">    1351 </span>            :                   {</a>
<a name="1352"><span class="lineNum">    1352 </span>            :                     found = true;</a>
<a name="1353"><span class="lineNum">    1353 </span>            :                   }</a>
<a name="1354"><span class="lineNum">    1354 </span>            :              }</a>
<a name="1355"><span class="lineNum">    1355 </span>            :         }</a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span>            :      if (found)</a>
<a name="1358"><span class="lineNum">    1358 </span>            :         {</a>
<a name="1359"><span class="lineNum">    1359 </span><span class="lineCov">          4 :           if (isDefining)</span></a>
<a name="1360"><span class="lineNum">    1360 </span>            :              {</a>
<a name="1361"><span class="lineNum">    1361 </span>            : #if 0</a>
<a name="1362"><span class="lineNum">    1362 </span>            :                printf (&quot;In findDeclarationStatement(): decl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,decl-&gt;get_firstNondefiningDeclaration());</a>
<a name="1363"><span class="lineNum">    1363 </span>            :                printf (&quot;In findDeclarationStatement(): decl-&gt;get_definingDeclaration()         = %p \n&quot;,decl-&gt;get_definingDeclaration());</a>
<a name="1364"><span class="lineNum">    1364 </span>            : #endif</a>
<a name="1365"><span class="lineNum">    1365 </span><span class="lineCov">          2 :                ROSE_ASSERT (decl-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="1366"><span class="lineNum">    1366 </span>            : #if 0</a>
<a name="1367"><span class="lineNum">    1367 </span>            :                printf (&quot;In findDeclarationStatement(): returing decl-&gt;get_definingDeclaration() = %p \n&quot;,decl-&gt;get_definingDeclaration());</a>
<a name="1368"><span class="lineNum">    1368 </span>            : #endif</a>
<a name="1369"><span class="lineNum">    1369 </span><span class="lineCov">          2 :                return dynamic_cast&lt;T*&gt; (decl-&gt;get_definingDeclaration());</span></a>
<a name="1370"><span class="lineNum">    1370 </span>            :              }</a>
<a name="1371"><span class="lineNum">    1371 </span>            :             else</a>
<a name="1372"><span class="lineNum">    1372 </span>            :              {</a>
<a name="1373"><span class="lineNum">    1373 </span>            : #if 0</a>
<a name="1374"><span class="lineNum">    1374 </span>            :                printf (&quot;In findDeclarationStatement(): returing decl = %p \n&quot;,decl);</a>
<a name="1375"><span class="lineNum">    1375 </span>            : #endif</a>
<a name="1376"><span class="lineNum">    1376 </span>            :                return decl;</a>
<a name="1377"><span class="lineNum">    1377 </span>            :              }</a>
<a name="1378"><span class="lineNum">    1378 </span>            :         }</a>
<a name="1379"><span class="lineNum">    1379 </span>            : </a>
<a name="1380"><span class="lineNum">    1380 </span><span class="lineCov">     741713 :      std::vector&lt;SgNode*&gt; children = root-&gt;get_traversalSuccessorContainer();</span></a>
<a name="1381"><span class="lineNum">    1381 </span>            : </a>
<a name="1382"><span class="lineNum">    1382 </span>            : #if 0</a>
<a name="1383"><span class="lineNum">    1383 </span>            :      printf (&quot;In findDeclarationStatement(): children.size() = %zu \n&quot;,children.size());</a>
<a name="1384"><span class="lineNum">    1384 </span>            : #endif</a>
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<a name="1386"><span class="lineNum">    1386 </span>            :   // DQ (4/10/2016): Note that if we are searching for a function member that has it's defining</a>
<a name="1387"><span class="lineNum">    1387 </span>            :   // declaration defined outside of the class then it will not be found in the child list.</a>
<a name="1388"><span class="lineNum">    1388 </span><span class="lineCov">     741696 :      for (std::vector&lt;SgNode*&gt;::const_iterator i = children.begin(); i != children.end(); ++i)</span></a>
<a name="1389"><span class="lineNum">    1389 </span>            :         {</a>
<a name="1390"><span class="lineNum">    1390 </span><span class="lineCov">     884216 :           T* target = findDeclarationStatement&lt;T&gt; (*i,name,scope,isDefining);</span></a>
<a name="1391"><span class="lineNum">    1391 </span>            : </a>
<a name="1392"><span class="lineNum">    1392 </span><span class="lineCov">     442108 :           if (target)</span></a>
<a name="1393"><span class="lineNum">    1393 </span>            :              {</a>
<a name="1394"><span class="lineNum">    1394 </span><span class="lineCov">         13 :                return target;</span></a>
<a name="1395"><span class="lineNum">    1395 </span>            :              }</a>
<a name="1396"><span class="lineNum">    1396 </span>            :         }</a>
<a name="1397"><span class="lineNum">    1397 </span>            : </a>
<a name="1398"><span class="lineNum">    1398 </span>            :      return NULL;</a>
<a name="1399"><span class="lineNum">    1399 </span>            :    }</a>
<a name="1400"><span class="lineNum">    1400 </span>            : //! Topdown traverse a subtree from root to find the first function declaration matching the given name, scope (optional, can be NULL), and defining or nondefining flag. This is an instantiation of findDeclarationStatement&lt;T&gt;.</a>
<a name="1401"><span class="lineNum">    1401 </span>            :   SgFunctionDeclaration* findFunctionDeclaration(SgNode* root, std::string name, SgScopeStatement* scope, bool isDefining);</a>
<a name="1402"><span class="lineNum">    1402 </span>            : </a>
<a name="1403"><span class="lineNum">    1403 </span>            : #if 0 //TODO</a>
<a name="1404"><span class="lineNum">    1404 </span>            :   // 1. preorder traversal from current SgNode till find next SgNode of type V_SgXXX</a>
<a name="1405"><span class="lineNum">    1405 </span>            :   //    until reach the end node</a>
<a name="1406"><span class="lineNum">    1406 </span>            :   SgNode* getNextSgNode( const SgNode* astSourceNode, VariantT=V_SgNode, SgNode* astEndNode=NULL);</a>
<a name="1407"><span class="lineNum">    1407 </span>            : </a>
<a name="1408"><span class="lineNum">    1408 </span>            :   // 2. return all nodes of type VariantT following the source node</a>
<a name="1409"><span class="lineNum">    1409 </span>            :   std::vector&lt;SgNode*&gt; getAllNextSgNode( const SgNode* astSourceNode, VariantT=V_SgNode, SgNode* astEndNode=NULL);</a>
<a name="1410"><span class="lineNum">    1410 </span>            : #endif</a>
<a name="1411"><span class="lineNum">    1411 </span>            : </a>
<a name="1412"><span class="lineNum">    1412 </span>            : //@}</a>
<a name="1413"><span class="lineNum">    1413 </span>            : </a>
<a name="1414"><span class="lineNum">    1414 </span>            : //------------------------------------------------------------------------</a>
<a name="1415"><span class="lineNum">    1415 </span>            : //@{</a>
<a name="1416"><span class="lineNum">    1416 </span>            : /*! @name Bottom up search</a>
<a name="1417"><span class="lineNum">    1417 </span>            :   \brief Backwards traverse through the AST to find a node, findEnclosingXXX()</a>
<a name="1418"><span class="lineNum">    1418 </span>            : */</a>
<a name="1419"><span class="lineNum">    1419 </span>            : // remember to put const to all arguments.</a>
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<a name="1421"><span class="lineNum">    1421 </span>            : </a>
<a name="1422"><span class="lineNum">    1422 </span>            : /** Find a node by type using upward traversal.</a>
<a name="1423"><span class="lineNum">    1423 </span>            :  *</a>
<a name="1424"><span class="lineNum">    1424 </span>            :  *  Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant</a>
<a name="1425"><span class="lineNum">    1425 </span>            :  *  ancestors, to find the first node matching the specified or derived type.  If @p includingSelf is true then the</a>
<a name="1426"><span class="lineNum">    1426 </span>            :  *  starting node, @p astNode, is returned if its type matches, otherwise the search starts at the parent of @p astNode.</a>
<a name="1427"><span class="lineNum">    1427 </span>            :  *</a>
<a name="1428"><span class="lineNum">    1428 </span>            :  *  For the purposes of this function, the parent (P) of an SgDeclarationStatement node (N) is considered to be the first</a>
<a name="1429"><span class="lineNum">    1429 </span>            :  *  non-defining declaration of N if N has both a defining declaration and a first non-defining declaration and the defining</a>
<a name="1430"><span class="lineNum">    1430 </span>            :  *  declaration is different than the first non-defining declaration.</a>
<a name="1431"><span class="lineNum">    1431 </span>            :  *</a>
<a name="1432"><span class="lineNum">    1432 </span>            :  *  If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.</a>
<a name="1433"><span class="lineNum">    1433 </span>            :  *</a>
<a name="1434"><span class="lineNum">    1434 </span>            :  *  If @p astNode is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot</a>
<a name="1435"><span class="lineNum">    1435 </span>            :  *  be an enclosing node of the specified type. */</a>
<a name="1436"><span class="lineNum">    1436 </span>            : template &lt;typename NodeType&gt;</a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">    8104928 : NodeType* getEnclosingNode(const SgNode* astNode, const bool includingSelf = false)</span></a>
<a name="1438"><span class="lineNum">    1438 </span>            :    {</a>
<a name="1439"><span class="lineNum">    1439 </span>            : #define DEBUG_GET_ENCLOSING_NODE 0</a>
<a name="1440"><span class="lineNum">    1440 </span>            : </a>
<a name="1441"><span class="lineNum">    1441 </span>            : #if 1 /* TOP_LEVEL_IF */</a>
<a name="1442"><span class="lineNum">    1442 </span>            :   // DQ (12/31/2019): This version does not detect a cycle that Robb's version detects in processing Cxx11_tests/test2016_23.C.</a>
<a name="1443"><span class="lineNum">    1443 </span>            :   // This will have to be investigated seperately from the issue I am working on currently.</a>
<a name="1444"><span class="lineNum">    1444 </span>            : </a>
<a name="1445"><span class="lineNum">    1445 </span>            :   // DQ (10/20/2012): This is the older version of this implementation.  Until I am sure that</a>
<a name="1446"><span class="lineNum">    1446 </span>            :   // the newer version (below) is what we want to use I will resolve this conflict by keeping</a>
<a name="1447"><span class="lineNum">    1447 </span>            :   // the previous version in place.</a>
<a name="1448"><span class="lineNum">    1448 </span>            : </a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineCov">    8104928 :      if (nullptr == astNode)</span></a>
<a name="1450"><span class="lineNum">    1450 </span>            :         {</a>
<a name="1451"><span class="lineNum">    1451 </span>            :           return nullptr;</a>
<a name="1452"><span class="lineNum">    1452 </span>            :         }</a>
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<a name="1454"><span class="lineNum">    1454 </span><span class="lineCov">    8104928 :      if ( (includingSelf ) &amp;&amp; (dynamic_cast&lt;const NodeType*&gt;(astNode)) )</span></a>
<a name="1455"><span class="lineNum">    1455 </span>            :         {</a>
<a name="1456"><span class="lineNum">    1456 </span>            :           return const_cast&lt;NodeType*&gt;(dynamic_cast&lt;const NodeType*&gt; (astNode));</a>
<a name="1457"><span class="lineNum">    1457 </span>            :         }</a>
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<a name="1459"><span class="lineNum">    1459 </span>            :   // DQ (3/5/2012): Check for reference to self...</a>
<a name="1460"><span class="lineNum">    1460 </span><span class="lineCov">    7997730 :      ROSE_ASSERT(astNode-&gt;get_parent() != astNode);</span></a>
<a name="1461"><span class="lineNum">    1461 </span>            : </a>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineCov">    7997730 :      SgNode* parent = astNode-&gt;get_parent();</span></a>
<a name="1463"><span class="lineNum">    1463 </span>            : </a>
<a name="1464"><span class="lineNum">    1464 </span>            :   // DQ (3/5/2012): Check for loops that will cause infinite loops.</a>
<a name="1465"><span class="lineNum">    1465 </span><span class="lineCov">    7997730 :      SgNode* previouslySeenParent = parent;</span></a>
<a name="1466"><span class="lineNum">    1466 </span><span class="lineCov">    7997730 :      bool foundCycle = false;</span></a>
<a name="1467"><span class="lineNum">    1467 </span><span class="lineCov">    7997730 :      int counter = 0;</span></a>
<a name="1468"><span class="lineNum">    1468 </span>            : </a>
<a name="1469"><span class="lineNum">    1469 </span>            : #if DEBUG_GET_ENCLOSING_NODE</a>
<a name="1470"><span class="lineNum">    1470 </span>            :      printf (&quot;In getEnclosingNode(): previouslySeenParent = %p = %s \n&quot;,previouslySeenParent,previouslySeenParent-&gt;class_name().c_str());</a>
<a name="1471"><span class="lineNum">    1471 </span>            : #endif</a>
<a name="1472"><span class="lineNum">    1472 </span>            : </a>
<a name="1473"><span class="lineNum">    1473 </span><span class="lineCov">   25529195 :      while ( (foundCycle == false) &amp;&amp; (parent != nullptr) &amp;&amp; (!dynamic_cast&lt;const NodeType*&gt;(parent)) )</span></a>
<a name="1474"><span class="lineNum">    1474 </span>            :         {</a>
<a name="1475"><span class="lineNum">    1475 </span><span class="lineCov">   17531435 :           ROSE_ASSERT(parent-&gt;get_parent() != parent);</span></a>
<a name="1476"><span class="lineNum">    1476 </span>            : </a>
<a name="1477"><span class="lineNum">    1477 </span>            : #if DEBUG_GET_ENCLOSING_NODE</a>
<a name="1478"><span class="lineNum">    1478 </span>            :           printf (&quot; --- parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="1479"><span class="lineNum">    1479 </span>            :           printf (&quot; --- --- parent-&gt;get_parent() = %p = %s \n&quot;,parent-&gt;get_parent(),parent-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1480"><span class="lineNum">    1480 </span>            : #endif</a>
<a name="1481"><span class="lineNum">    1481 </span>            : </a>
<a name="1482"><span class="lineNum">    1482 </span>            : #if 1</a>
<a name="1483"><span class="lineNum">    1483 </span>            :        // DQ (1/8/2020): ROSE-82 (on RZ) This limit needs to be larger and increasing it to 500 was enough</a>
<a name="1484"><span class="lineNum">    1484 </span>            :        // for a specific code with a long chain of if-then-else nesting, So to make this sufficent for more</a>
<a name="1485"><span class="lineNum">    1485 </span>            :        // general code we have increased the lomit to 100,000.  Note that 50 was not enough for real code,</a>
<a name="1486"><span class="lineNum">    1486 </span>            :        // but was enough for our regression tests.</a>
<a name="1487"><span class="lineNum">    1487 </span>            :        // DQ (12/30/2019): This is added to support detection of infinite loops over parent pointers.</a>
<a name="1488"><span class="lineNum">    1488 </span>            :        // if (counter &gt;= 500)</a>
<a name="1489"><span class="lineNum">    1489 </span><span class="lineCov">   17531435 :           if (counter &gt;= 100000)</span></a>
<a name="1490"><span class="lineNum">    1490 </span>            :              {</a>
<a name="1491"><span class="lineNum">    1491 </span><span class="lineNoCov">          0 :                printf (&quot;Exiting: In getEnclosingNode(): loop limit exceeded: counter = %d \n&quot;,counter);</span></a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1493"><span class="lineNum">    1493 </span>            :              }</a>
<a name="1494"><span class="lineNum">    1494 </span>            : #endif</a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineCov">   17531435 :           parent = parent-&gt;get_parent();</span></a>
<a name="1496"><span class="lineNum">    1496 </span>            : </a>
<a name="1497"><span class="lineNum">    1497 </span>            :        // DQ (3/5/2012): Check for loops that will cause infinite loops.</a>
<a name="1498"><span class="lineNum">    1498 </span>            :        // ROSE_ASSERT(parent != previouslySeenParent);</a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">   17531435 :           if (parent == previouslySeenParent)</span></a>
<a name="1500"><span class="lineNum">    1500 </span>            :              {</a>
<a name="1501"><span class="lineNum">    1501 </span><span class="lineNoCov">          0 :                foundCycle = true;</span></a>
<a name="1502"><span class="lineNum">    1502 </span>            :              }</a>
<a name="1503"><span class="lineNum">    1503 </span><span class="lineCov">   17531435 :           counter++;</span></a>
<a name="1504"><span class="lineNum">    1504 </span>            : </a>
<a name="1505"><span class="lineNum">    1505 </span>            :         }</a>
<a name="1506"><span class="lineNum">    1506 </span>            : </a>
<a name="1507"><span class="lineNum">    1507 </span>            : #if DEBUG_GET_ENCLOSING_NODE</a>
<a name="1508"><span class="lineNum">    1508 </span>            :      printf (&quot;previouslySeenParent = %p = %s \n&quot;,previouslySeenParent,previouslySeenParent-&gt;class_name().c_str());</a>
<a name="1509"><span class="lineNum">    1509 </span>            : #endif</a>
<a name="1510"><span class="lineNum">    1510 </span>            : </a>
<a name="1511"><span class="lineNum">    1511 </span><span class="lineCov">    7997730 :      parent = previouslySeenParent;</span></a>
<a name="1512"><span class="lineNum">    1512 </span>            : </a>
<a name="1513"><span class="lineNum">    1513 </span><span class="lineCov">    7997730 :      SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(parent);</span></a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">    7997730 :      if (declarationStatement != nullptr)</span></a>
<a name="1515"><span class="lineNum">    1515 </span>            :         {</a>
<a name="1516"><span class="lineNum">    1516 </span>            : #if 0</a>
<a name="1517"><span class="lineNum">    1517 </span>            :           printf (&quot;Found a SgDeclarationStatement \n&quot;);</a>
<a name="1518"><span class="lineNum">    1518 </span>            : #endif</a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineCov">      65668 :           SgDeclarationStatement* definingDeclaration         = declarationStatement-&gt;get_definingDeclaration();</span></a>
<a name="1520"><span class="lineNum">    1520 </span><span class="lineCov">      65668 :           SgDeclarationStatement* firstNondefiningDeclaration = declarationStatement-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="1521"><span class="lineNum">    1521 </span>            : </a>
<a name="1522"><span class="lineNum">    1522 </span>            : #if 0</a>
<a name="1523"><span class="lineNum">    1523 </span>            :           printf (&quot; --- declarationStatement         = %p \n&quot;,declarationStatement);</a>
<a name="1524"><span class="lineNum">    1524 </span>            :           printf (&quot; --- definingDeclaration          = %p \n&quot;,definingDeclaration);</a>
<a name="1525"><span class="lineNum">    1525 </span>            :           if (definingDeclaration != NULL &amp;&amp; definingDeclaration-&gt;get_parent() != NULL)</a>
<a name="1526"><span class="lineNum">    1526 </span>            :                printf (&quot; --- definingDeclaration -&gt;get_parent()         = %p = %s \n&quot;,definingDeclaration-&gt;get_parent(),definingDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1527"><span class="lineNum">    1527 </span>            :           printf (&quot; --- firstNondefiningDeclaration  = %p \n&quot;,firstNondefiningDeclaration);</a>
<a name="1528"><span class="lineNum">    1528 </span>            :           if (firstNondefiningDeclaration != NULL &amp;&amp; firstNondefiningDeclaration-&gt;get_parent() != NULL)</a>
<a name="1529"><span class="lineNum">    1529 </span>            :                printf (&quot; --- firstNondefiningDeclaration -&gt;get_parent() = %p = %s \n&quot;,firstNondefiningDeclaration-&gt;get_parent(),firstNondefiningDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="1530"><span class="lineNum">    1530 </span>            : #endif</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">      65668 :           if (definingDeclaration != nullptr &amp;&amp; declarationStatement != firstNondefiningDeclaration)</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :              {</a>
<a name="1533"><span class="lineNum">    1533 </span>            : #if 0</a>
<a name="1534"><span class="lineNum">    1534 </span>            :                printf (&quot;Found a nondefining declaration so use the non-defining declaration instead \n&quot;);</a>
<a name="1535"><span class="lineNum">    1535 </span>            : #endif</a>
<a name="1536"><span class="lineNum">    1536 </span>            :             // DQ (10/19/2012): Use the defining declaration instead.</a>
<a name="1537"><span class="lineNum">    1537 </span>            :             // parent = firstNondefiningDeclaration;</a>
<a name="1538"><span class="lineNum">    1538 </span><span class="lineNoCov">          0 :                parent = definingDeclaration;</span></a>
<a name="1539"><span class="lineNum">    1539 </span>            :              }</a>
<a name="1540"><span class="lineNum">    1540 </span>            :         }</a>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<a name="1542"><span class="lineNum">    1542 </span>            : #if 0</a>
<a name="1543"><span class="lineNum">    1543 </span>            :      printf (&quot;reset: previouslySeenParent = %p = %s \n&quot;,previouslySeenParent,previouslySeenParent-&gt;class_name().c_str());</a>
<a name="1544"><span class="lineNum">    1544 </span>            : #endif</a>
<a name="1545"><span class="lineNum">    1545 </span>            : </a>
<a name="1546"><span class="lineNum">    1546 </span>            :   // DQ (10/19/2012): This branch is just to document the cycle that was previously detected, it is for</a>
<a name="1547"><span class="lineNum">    1547 </span>            :   // debugging only. Thus it ony make sense for it to be executed when &quot;(foundCycle == true)&quot;.  However,</a>
<a name="1548"><span class="lineNum">    1548 </span>            :   // this will have to be revisited later since it appears clear that it is a problem for the binary analysis</a>
<a name="1549"><span class="lineNum">    1549 </span>            :   // work when it is visited for this case.  Since the cycle is detected, but there is no assertion on the</a>
<a name="1550"><span class="lineNum">    1550 </span>            :   // cycle, we don't exit when a cycle is identified (which is the point of the code below).</a>
<a name="1551"><span class="lineNum">    1551 </span>            :   // Note also that I have fixed the code (above and below) to only chase pointers through defining</a>
<a name="1552"><span class="lineNum">    1552 </span>            :   // declarations (where they exist), this is important since non-defining declarations can be almost</a>
<a name="1553"><span class="lineNum">    1553 </span>            :   // anywhere (and thus chasing them can make it appear that there are cycles where there are none</a>
<a name="1554"><span class="lineNum">    1554 </span>            :   // (I think); test2012_234.C demonstrates an example of this.</a>
<a name="1555"><span class="lineNum">    1555 </span>            :   // DQ (10/9/2012): Robb has suggested this change to fix the binary analysis work.</a>
<a name="1556"><span class="lineNum">    1556 </span>            :   // if (foundCycle == true)</a>
<a name="1557"><span class="lineNum">    1557 </span><span class="lineCov">    7997730 :      if (foundCycle == false)</span></a>
<a name="1558"><span class="lineNum">    1558 </span>            :         {</a>
<a name="1559"><span class="lineNum">    1559 </span>            : </a>
<a name="1560"><span class="lineNum">    1560 </span>            : </a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineCov">   25529195 :           while ( (parent != nullptr) &amp;&amp; (!dynamic_cast&lt;const NodeType*&gt;(parent)) )</span></a>
<a name="1562"><span class="lineNum">    1562 </span>            :              {</a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineCov">   17531435 :                ROSE_ASSERT(parent-&gt;get_parent() != parent);</span></a>
<a name="1564"><span class="lineNum">    1564 </span>            : #if 0</a>
<a name="1565"><span class="lineNum">    1565 </span>            :                printf (&quot;In getEnclosingNode() (2nd try): parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="1566"><span class="lineNum">    1566 </span>            :                if (parent-&gt;get_file_info() != NULL)</a>
<a name="1567"><span class="lineNum">    1567 </span>            :                     parent-&gt;get_file_info()-&gt;display(&quot;In getEnclosingNode() (2nd try): debug&quot;);</a>
<a name="1568"><span class="lineNum">    1568 </span>            : #endif</a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">   17531435 :                SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(parent);</span></a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineCov">   17531435 :                if (declarationStatement != nullptr)</span></a>
<a name="1571"><span class="lineNum">    1571 </span>            :                   {</a>
<a name="1572"><span class="lineNum">    1572 </span>            : #if DEBUG_GET_ENCLOSING_NODE</a>
<a name="1573"><span class="lineNum">    1573 </span>            :                     printf (&quot;Found a SgDeclarationStatement \n&quot;);</a>
<a name="1574"><span class="lineNum">    1574 </span>            : #endif</a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">     131488 :                     SgDeclarationStatement* definingDeclaration         = declarationStatement-&gt;get_definingDeclaration();</span></a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineCov">     131488 :                     SgDeclarationStatement* firstNondefiningDeclaration = declarationStatement-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="1577"><span class="lineNum">    1577 </span><span class="lineCov">     131488 :                     if (definingDeclaration != nullptr &amp;&amp; declarationStatement != firstNondefiningDeclaration)</span></a>
<a name="1578"><span class="lineNum">    1578 </span>            :                        {</a>
<a name="1579"><span class="lineNum">    1579 </span>            : #if 0</a>
<a name="1580"><span class="lineNum">    1580 </span>            :                          printf (&quot;Found a nondefining declaration so use the firstNondefining declaration instead \n&quot;);</a>
<a name="1581"><span class="lineNum">    1581 </span>            : #endif</a>
<a name="1582"><span class="lineNum">    1582 </span>            :                       // DQ (10/19/2012): Use the defining declaration instead.</a>
<a name="1583"><span class="lineNum">    1583 </span>            :                       // parent = firstNondefiningDeclaration;</a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineCov">      24993 :                          parent = definingDeclaration;</span></a>
<a name="1585"><span class="lineNum">    1585 </span>            :                        }</a>
<a name="1586"><span class="lineNum">    1586 </span>            :                   }</a>
<a name="1587"><span class="lineNum">    1587 </span>            : </a>
<a name="1588"><span class="lineNum">    1588 </span><span class="lineCov">   17531435 :                parent = parent-&gt;get_parent();</span></a>
<a name="1589"><span class="lineNum">    1589 </span>            : </a>
<a name="1590"><span class="lineNum">    1590 </span>            : #if 1</a>
<a name="1591"><span class="lineNum">    1591 </span>            :             // DQ (3/5/2012): Check for loops that will cause infinite loops.</a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineCov">   17531435 :                ROSE_ASSERT(parent != previouslySeenParent);</span></a>
<a name="1593"><span class="lineNum">    1593 </span>            : #else</a>
<a name="1594"><span class="lineNum">    1594 </span>            :                printf (&quot;WARNING::WARNING::WARNING commented out assertion for parent != previouslySeenParent \n&quot;);</a>
<a name="1595"><span class="lineNum">    1595 </span>            :                if (parent == previouslySeenParent)</a>
<a name="1596"><span class="lineNum">    1596 </span>            :                     break;</a>
<a name="1597"><span class="lineNum">    1597 </span>            : #endif</a>
<a name="1598"><span class="lineNum">    1598 </span>            :              }</a>
<a name="1599"><span class="lineNum">    1599 </span>            :         }</a>
<a name="1600"><span class="lineNum">    1600 </span>            : </a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineCov">    7997730 :      return const_cast&lt;NodeType*&gt;(dynamic_cast&lt;const NodeType*&gt; (parent));</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            : #else /* TOP_LEVEL_IF */</a>
<a name="1603"><span class="lineNum">    1603 </span>            :   // DQ (10/20/2012): Using Robb's newer version with my modification to use the definingDeclaration rather than firstNondefiningDeclaration (below).</a>
<a name="1604"><span class="lineNum">    1604 </span>            : </a>
<a name="1605"><span class="lineNum">    1605 </span>            :        // Find the parent of specified type, but watch out for cycles in the ancestry (which would cause an infinite loop).</a>
<a name="1606"><span class="lineNum">    1606 </span>            :        // Cast away const because isSg* functions aren't defined for const node pointers; and our return is not const.</a>
<a name="1607"><span class="lineNum">    1607 </span>            :        SgNode *node = const_cast&lt;SgNode*&gt;(!astNode || includingSelf ? astNode : astNode-&gt;get_parent());</a>
<a name="1608"><span class="lineNum">    1608 </span>            :        std::set&lt;const SgNode*&gt; seen; // nodes we've seen, in order to detect cycles</a>
<a name="1609"><span class="lineNum">    1609 </span>            :        while (node) {</a>
<a name="1610"><span class="lineNum">    1610 </span>            :            if (NodeType *found = dynamic_cast&lt;NodeType*&gt;(node))</a>
<a name="1611"><span class="lineNum">    1611 </span>            :                return found;</a>
<a name="1612"><span class="lineNum">    1612 </span>            : </a>
<a name="1613"><span class="lineNum">    1613 </span>            :         // FIXME: Cycle detection could be moved elsewhere so we don't need to do it on every call. [RPM 2012-10-09]</a>
<a name="1614"><span class="lineNum">    1614 </span>            :         // DQ (12/30/2019): Provide more detail in error message.</a>
<a name="1615"><span class="lineNum">    1615 </span>            :            if (seen.insert(node).second == false)</a>
<a name="1616"><span class="lineNum">    1616 </span>            :              {</a>
<a name="1617"><span class="lineNum">    1617 </span>            :                printf (&quot;Error: node is already in set and defines a cycle: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="1618"><span class="lineNum">    1618 </span>            :                std::set&lt;const SgNode*&gt;::const_iterator i = seen.begin();</a>
<a name="1619"><span class="lineNum">    1619 </span>            :                while (i != seen.end())</a>
<a name="1620"><span class="lineNum">    1620 </span>            :                  {</a>
<a name="1621"><span class="lineNum">    1621 </span>            :                    const SgNode* element = *i;</a>
<a name="1622"><span class="lineNum">    1622 </span>            :                    printf (&quot; --- seen element: element = %p = %s \n&quot;,element,element-&gt;class_name().c_str());</a>
<a name="1623"><span class="lineNum">    1623 </span>            :                    i++;</a>
<a name="1624"><span class="lineNum">    1624 </span>            :                  }</a>
<a name="1625"><span class="lineNum">    1625 </span>            : </a>
<a name="1626"><span class="lineNum">    1626 </span>            :                printf (&quot;Exiting after error! \n&quot;);</a>
<a name="1627"><span class="lineNum">    1627 </span>            :                ROSE_ABORT();</a>
<a name="1628"><span class="lineNum">    1628 </span>            :              }</a>
<a name="1629"><span class="lineNum">    1629 </span>            :            // ROSE_ASSERT(seen.insert(node).second);</a>
<a name="1630"><span class="lineNum">    1630 </span>            : </a>
<a name="1631"><span class="lineNum">    1631 </span>            :            // Traverse to parent (declaration statements are a special case)</a>
<a name="1632"><span class="lineNum">    1632 </span>            :            if (SgDeclarationStatement *declarationStatement = isSgDeclarationStatement(node)) {</a>
<a name="1633"><span class="lineNum">    1633 </span>            :                SgDeclarationStatement *definingDeclaration = declarationStatement-&gt;get_definingDeclaration();</a>
<a name="1634"><span class="lineNum">    1634 </span>            :                SgDeclarationStatement *firstNondefiningDeclaration = declarationStatement-&gt;get_firstNondefiningDeclaration();</a>
<a name="1635"><span class="lineNum">    1635 </span>            :                if (definingDeclaration &amp;&amp; firstNondefiningDeclaration &amp;&amp; declarationStatement != firstNondefiningDeclaration) {</a>
<a name="1636"><span class="lineNum">    1636 </span>            :                 // DQ (10/19/2012): Use the defining declaration instead.</a>
<a name="1637"><span class="lineNum">    1637 </span>            :                 // node = firstNondefiningDeclaration;</a>
<a name="1638"><span class="lineNum">    1638 </span>            :                    node = definingDeclaration;</a>
<a name="1639"><span class="lineNum">    1639 </span>            :                }</a>
<a name="1640"><span class="lineNum">    1640 </span>            :            } else {</a>
<a name="1641"><span class="lineNum">    1641 </span>            :                node = node-&gt;get_parent();</a>
<a name="1642"><span class="lineNum">    1642 </span>            :            }</a>
<a name="1643"><span class="lineNum">    1643 </span>            :        }</a>
<a name="1644"><span class="lineNum">    1644 </span>            :        return NULL;</a>
<a name="1645"><span class="lineNum">    1645 </span>            : #endif /* TOP_LEVEL_IF */</a>
<a name="1646"><span class="lineNum">    1646 </span>            :    }</a>
<a name="1647"><span class="lineNum">    1647 </span>            : </a>
<a name="1648"><span class="lineNum">    1648 </span>            :   //! Find enclosing source file node</a>
<a name="1649"><span class="lineNum">    1649 </span>            :   ROSE_DLL_API SgSourceFile* getEnclosingSourceFile(SgNode* n, const bool includingSelf=false);</a>
<a name="1650"><span class="lineNum">    1650 </span>            : </a>
<a name="1651"><span class="lineNum">    1651 </span>            :   //! Get the closest scope from astNode. Return astNode if it is already a scope.</a>
<a name="1652"><span class="lineNum">    1652 </span>            :   ROSE_DLL_API SgScopeStatement* getScope(const SgNode* astNode);</a>
<a name="1653"><span class="lineNum">    1653 </span>            : </a>
<a name="1654"><span class="lineNum">    1654 </span>            :   //! Get the enclosing scope from a node n</a>
<a name="1655"><span class="lineNum">    1655 </span>            :   ROSE_DLL_API SgScopeStatement* getEnclosingScope(SgNode* n, const bool includingSelf=false);</a>
<a name="1656"><span class="lineNum">    1656 </span>            : </a>
<a name="1657"><span class="lineNum">    1657 </span>            :   //! Traverse back through a node's parents to find the enclosing global scope</a>
<a name="1658"><span class="lineNum">    1658 </span>            :   ROSE_DLL_API SgGlobal* getGlobalScope( const SgNode* astNode);</a>
<a name="1659"><span class="lineNum">    1659 </span>            : </a>
<a name="1660"><span class="lineNum">    1660 </span>            :  // DQ (12/7/2020): This is supporting the recognition of functions in header files from two different AST.</a>
<a name="1661"><span class="lineNum">    1661 </span>            :  //! This is supporting the recognition of functions in header files from two different ASTs</a>
<a name="1662"><span class="lineNum">    1662 </span>            :   ROSE_DLL_API bool hasSameGlobalScope ( SgStatement* statement_1, SgStatement* statement_2 );</a>
<a name="1663"><span class="lineNum">    1663 </span>            : </a>
<a name="1664"><span class="lineNum">    1664 </span>            :   //! Find the function definition</a>
<a name="1665"><span class="lineNum">    1665 </span>            :   ROSE_DLL_API SgFunctionDefinition* getEnclosingProcedure(SgNode* n, const bool includingSelf=false);</a>
<a name="1666"><span class="lineNum">    1666 </span>            : </a>
<a name="1667"><span class="lineNum">    1667 </span>            :   ROSE_DLL_API SgFunctionDefinition* getEnclosingFunctionDefinition(SgNode* astNode, const bool includingSelf=false);</a>
<a name="1668"><span class="lineNum">    1668 </span>            : </a>
<a name="1669"><span class="lineNum">    1669 </span>            :   //! Find the closest enclosing statement, including the given node</a>
<a name="1670"><span class="lineNum">    1670 </span>            :   ROSE_DLL_API SgStatement* getEnclosingStatement(SgNode* n);</a>
<a name="1671"><span class="lineNum">    1671 </span>            : </a>
<a name="1672"><span class="lineNum">    1672 </span>            :   //! Find the closest switch outside a given statement (normally used for case and default statements)</a>
<a name="1673"><span class="lineNum">    1673 </span>            :   ROSE_DLL_API SgSwitchStatement* findEnclosingSwitch(SgStatement* s);</a>
<a name="1674"><span class="lineNum">    1674 </span>            : </a>
<a name="1675"><span class="lineNum">    1675 </span>            :   //! Find enclosing OpenMP clause body statement from s. If s is already one, return it directly.</a>
<a name="1676"><span class="lineNum">    1676 </span>            :   ROSE_DLL_API SgUpirFieldBodyStatement* findEnclosingUpirFieldBodyStatement(SgStatement* s);</a>
<a name="1677"><span class="lineNum">    1677 </span>            : </a>
<a name="1678"><span class="lineNum">    1678 </span>            :   //! Find the closest loop outside the given statement; if fortranLabel is not empty, the Fortran label of the loop must be equal to it</a>
<a name="1679"><span class="lineNum">    1679 </span>            :   ROSE_DLL_API SgScopeStatement* findEnclosingLoop(SgStatement* s, const std::string&amp; fortranLabel = &quot;&quot;, bool stopOnSwitches = false);</a>
<a name="1680"><span class="lineNum">    1680 </span>            : </a>
<a name="1681"><span class="lineNum">    1681 </span>            :   //! Find the enclosing function declaration, including its derived instances like isSgProcedureHeaderStatement, isSgProgramHeaderStatement, and isSgMemberFunctionDeclaration.</a>
<a name="1682"><span class="lineNum">    1682 </span>            :   ROSE_DLL_API SgFunctionDeclaration * getEnclosingFunctionDeclaration (SgNode * astNode, const bool includingSelf=false);</a>
<a name="1683"><span class="lineNum">    1683 </span>            :    //roseSupport/utility_functions.h</a>
<a name="1684"><span class="lineNum">    1684 </span>            :   //! get the SgFile node from current node</a>
<a name="1685"><span class="lineNum">    1685 </span>            :   ROSE_DLL_API SgFile* getEnclosingFileNode (SgNode* astNode );</a>
<a name="1686"><span class="lineNum">    1686 </span>            : </a>
<a name="1687"><span class="lineNum">    1687 </span>            :   //! Get the initializer containing an expression if it is within an initializer.</a>
<a name="1688"><span class="lineNum">    1688 </span>            :   ROSE_DLL_API SgInitializer* getInitializerOfExpression(SgExpression* n);</a>
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<a name="1690"><span class="lineNum">    1690 </span>            :   //! Get the closest class definition enclosing the specified AST node,</a>
<a name="1691"><span class="lineNum">    1691 </span>            :   ROSE_DLL_API SgClassDefinition* getEnclosingClassDefinition(SgNode* astnode, const bool includingSelf=false);</a>
<a name="1692"><span class="lineNum">    1692 </span>            : </a>
<a name="1693"><span class="lineNum">    1693 </span>            :   //! Get the closest class declaration enclosing the specified AST node,</a>
<a name="1694"><span class="lineNum">    1694 </span>            :   ROSE_DLL_API SgClassDeclaration* getEnclosingClassDeclaration( SgNode* astNode );</a>
<a name="1695"><span class="lineNum">    1695 </span>            : </a>
<a name="1696"><span class="lineNum">    1696 </span>            :   // DQ (2/7/2019): Adding support for name qualification of variable references associated with SgPointerMemberType function parameters.</a>
<a name="1697"><span class="lineNum">    1697 </span>            :   //! Get the enclosing SgExprListExp (used as part of function argument index evaluation in subexpressions).</a>
<a name="1698"><span class="lineNum">    1698 </span>            :   ROSE_DLL_API SgExprListExp* getEnclosingExprListExp(SgNode* astNode, const bool includingSelf = false);</a>
<a name="1699"><span class="lineNum">    1699 </span>            : </a>
<a name="1700"><span class="lineNum">    1700 </span>            :   // DQ (2/7/2019): Need a function to return when an expression is in an expression subtree.</a>
<a name="1701"><span class="lineNum">    1701 </span>            :   // This is part of index evaluation ofr expressions in function argument lists, but likely usefule elsewhere as well.</a>
<a name="1702"><span class="lineNum">    1702 </span>            :   ROSE_DLL_API bool isInSubTree(SgExpression* subtree, SgExpression* exp);</a>
<a name="1703"><span class="lineNum">    1703 </span>            : </a>
<a name="1704"><span class="lineNum">    1704 </span>            :   // DQ (2/7/2019): Need a function to return the SgFunctionDeclaration from a SgFunctionCallExp.</a>
<a name="1705"><span class="lineNum">    1705 </span>            :   ROSE_DLL_API SgFunctionDeclaration* getFunctionDeclaration ( SgFunctionCallExp* functionCallExp );</a>
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<a name="1707"><span class="lineNum">    1707 </span>            :   // DQ (2/17/2019): Generalizing this support for SgVarRefExp and SgMemberFunctionRefExp nodes.</a>
<a name="1708"><span class="lineNum">    1708 </span>            :   // DQ (2/8/2019): Adding support for detecting when to use added name qualification for pointer-to-member expressions.</a>
<a name="1709"><span class="lineNum">    1709 </span>            :   ROSE_DLL_API bool isDataMemberReference(SgVarRefExp* varRefExp);</a>
<a name="1710"><span class="lineNum">    1710 </span>            :   // ROSE_DLL_API bool isAddressTaken(SgVarRefExp* varRefExp);</a>
<a name="1711"><span class="lineNum">    1711 </span>            :   ROSE_DLL_API bool isAddressTaken(SgExpression* refExp);</a>
<a name="1712"><span class="lineNum">    1712 </span>            : </a>
<a name="1713"><span class="lineNum">    1713 </span>            :   // DQ (2/17/2019): Adding support for detecting when to use added name qualification for membr function references.</a>
<a name="1714"><span class="lineNum">    1714 </span>            :   ROSE_DLL_API bool isMemberFunctionMemberReference(SgMemberFunctionRefExp* memberFunctionRefExp);</a>
<a name="1715"><span class="lineNum">    1715 </span>            : </a>
<a name="1716"><span class="lineNum">    1716 </span>            :   // DQ (2/15/2019): Adding support for detecting which class a member reference is being made from.</a>
<a name="1717"><span class="lineNum">    1717 </span>            :   // ROSE_DLL_API SgClassType* getClassTypeForDataMemberReference(SgVarRefExp* varRefExp);</a>
<a name="1718"><span class="lineNum">    1718 </span>            :   // ROSE_DLL_API std::list&lt;SgClassType*&gt; getClassTypeChainForDataMemberReference(SgVarRefExp* varRefExp);</a>
<a name="1719"><span class="lineNum">    1719 </span>            :   ROSE_DLL_API std::list&lt;SgClassType*&gt; getClassTypeChainForMemberReference(SgExpression* refExp);</a>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<a name="1721"><span class="lineNum">    1721 </span>            :   ROSE_DLL_API std::set&lt;SgNode*&gt; getFrontendSpecificNodes();</a>
<a name="1722"><span class="lineNum">    1722 </span>            : </a>
<a name="1723"><span class="lineNum">    1723 </span>            :   // DQ (2/17/2019): Display the shared nodes in the AST for debugging.</a>
<a name="1724"><span class="lineNum">    1724 </span>            :   ROSE_DLL_API void outputSharedNodes( SgNode* node );</a>
<a name="1725"><span class="lineNum">    1725 </span>            : </a>
<a name="1726"><span class="lineNum">    1726 </span>            :   // DQ (10/31/2020): Added function to help debug edits to statements in scopes.</a>
<a name="1727"><span class="lineNum">    1727 </span>            :   ROSE_DLL_API void displayScope(SgScopeStatement* scope);</a>
<a name="1728"><span class="lineNum">    1728 </span>            : </a>
<a name="1729"><span class="lineNum">    1729 </span>            : // TODO</a>
<a name="1730"><span class="lineNum">    1730 </span>            : #if 0</a>
<a name="1731"><span class="lineNum">    1731 </span>            :    SgNode * getEnclosingSgNode(SgNode* source,VariantT, SgNode* endNode=NULL);</a>
<a name="1732"><span class="lineNum">    1732 </span>            :    std::vector&lt;SgNode *&gt;  getAllEnclosingSgNode(SgNode* source,VariantT, SgNode* endNode=NULL);</a>
<a name="1733"><span class="lineNum">    1733 </span>            :    SgVariableDeclaration* findVariableDeclaratin( const string&amp; varname)</a>
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<a name="1735"><span class="lineNum">    1735 </span>            :    SgClassDeclaration* getEnclosingClassDeclaration( const SgNode* astNode);</a>
<a name="1736"><span class="lineNum">    1736 </span>            : </a>
<a name="1737"><span class="lineNum">    1737 </span>            :    // e.g. for some expression, find its parent statement</a>
<a name="1738"><span class="lineNum">    1738 </span>            :    SgStatement* getEnclosingStatement(const SgNode* astNode);</a>
<a name="1739"><span class="lineNum">    1739 </span>            : </a>
<a name="1740"><span class="lineNum">    1740 </span>            :    SgSwitchStatement* getEnclosingSwitch(SgStatement* s);</a>
<a name="1741"><span class="lineNum">    1741 </span>            :    SgModuleStatement* getEnclosingModuleStatement( const SgNode* astNode);</a>
<a name="1742"><span class="lineNum">    1742 </span>            : </a>
<a name="1743"><span class="lineNum">    1743 </span>            :   // used to build a variable reference for compiler generated code in current scope</a>
<a name="1744"><span class="lineNum">    1744 </span>            :    SgSymbol * findReachingDefinition (SgScopeStatement* startScope, SgName &amp;name);</a>
<a name="1745"><span class="lineNum">    1745 </span>            : #endif</a>
<a name="1746"><span class="lineNum">    1746 </span>            : //@}</a>
<a name="1747"><span class="lineNum">    1747 </span>            : </a>
<a name="1748"><span class="lineNum">    1748 </span>            : //------------------------------------------------------------------------</a>
<a name="1749"><span class="lineNum">    1749 </span>            : //@{</a>
<a name="1750"><span class="lineNum">    1750 </span>            : /*! @name AST Walk and Traversal</a>
<a name="1751"><span class="lineNum">    1751 </span>            :   \brief</a>
<a name="1752"><span class="lineNum">    1752 </span>            : */</a>
<a name="1753"><span class="lineNum">    1753 </span>            :   // Liao, 1/9/2008</a>
<a name="1754"><span class="lineNum">    1754 </span>            :   /*!</a>
<a name="1755"><span class="lineNum">    1755 </span>            :         \brief return the first global scope under current project</a>
<a name="1756"><span class="lineNum">    1756 </span>            :   */</a>
<a name="1757"><span class="lineNum">    1757 </span>            :   ROSE_DLL_API SgGlobal * getFirstGlobalScope(SgProject *project);</a>
<a name="1758"><span class="lineNum">    1758 </span>            : </a>
<a name="1759"><span class="lineNum">    1759 </span>            :   /*!</a>
<a name="1760"><span class="lineNum">    1760 </span>            :         \brief get the last statement within a scope, return NULL if it does not exit</a>
<a name="1761"><span class="lineNum">    1761 </span>            :   */</a>
<a name="1762"><span class="lineNum">    1762 </span>            :   ROSE_DLL_API SgStatement* getLastStatement(SgScopeStatement *scope);</a>
<a name="1763"><span class="lineNum">    1763 </span>            : </a>
<a name="1764"><span class="lineNum">    1764 </span>            :   //! Get the first statement within a scope, return NULL if it does not exist. Skip compiler-generated statement by default. Count transformation-generated ones, but excluding those which are not to be outputted in unparsers.</a>
<a name="1765"><span class="lineNum">    1765 </span>            :   ROSE_DLL_API SgStatement* getFirstStatement(SgScopeStatement *scope,bool includingCompilerGenerated=false);</a>
<a name="1766"><span class="lineNum">    1766 </span>            :     //!Find the first defining function declaration statement in a scope</a>
<a name="1767"><span class="lineNum">    1767 </span>            :   ROSE_DLL_API SgFunctionDeclaration* findFirstDefiningFunctionDecl(SgScopeStatement* scope);</a>
<a name="1768"><span class="lineNum">    1768 </span>            : </a>
<a name="1769"><span class="lineNum">    1769 </span>            : //! Get next statement within the same scope of current statement</a>
<a name="1770"><span class="lineNum">    1770 </span>            :   ROSE_DLL_API SgStatement* getNextStatement(SgStatement * currentStmt);</a>
<a name="1771"><span class="lineNum">    1771 </span>            : </a>
<a name="1772"><span class="lineNum">    1772 </span>            : //! Get previous statement of the current statement. It may return a previous statement of a parent scope by default (climbOutScope is true), otherwise only a previous statement of the same scope is returned.</a>
<a name="1773"><span class="lineNum">    1773 </span>            :   ROSE_DLL_API SgStatement* getPreviousStatement(SgStatement * currentStmt, bool climbOutScope = true);</a>
<a name="1774"><span class="lineNum">    1774 </span>            : #if 0 //TODO</a>
<a name="1775"><span class="lineNum">    1775 </span>            :   // preorder traversal from current SgNode till find next SgNode of type V_SgXXX</a>
<a name="1776"><span class="lineNum">    1776 </span>            :   SgNode* getNextSgNode( const SgNode* currentNode, VariantT=V_SgNode);</a>
<a name="1777"><span class="lineNum">    1777 </span>            : #endif</a>
<a name="1778"><span class="lineNum">    1778 </span>            : </a>
<a name="1779"><span class="lineNum">    1779 </span>            :   // DQ (11/15/2018): Adding support for traversals over the include file tree.</a>
<a name="1780"><span class="lineNum">    1780 </span>            :   //! return path prefix for subtree of include files.</a>
<a name="1781"><span class="lineNum">    1781 </span>            :   void listHeaderFiles ( SgIncludeFile* includeFile );</a>
<a name="1782"><span class="lineNum">    1782 </span>            : </a>
<a name="1783"><span class="lineNum">    1783 </span>            : </a>
<a name="1784"><span class="lineNum">    1784 </span>            : //@}</a>
<a name="1785"><span class="lineNum">    1785 </span>            : </a>
<a name="1786"><span class="lineNum">    1786 </span>            : //------------------------------------------------------------------------</a>
<a name="1787"><span class="lineNum">    1787 </span>            : //@{</a>
<a name="1788"><span class="lineNum">    1788 </span>            : /*! @name AST Comparison</a>
<a name="1789"><span class="lineNum">    1789 </span>            :   \brief Compare AST nodes, subtree, etc</a>
<a name="1790"><span class="lineNum">    1790 </span>            : */</a>
<a name="1791"><span class="lineNum">    1791 </span>            :   //! Check if a SgIntVal node has a given value</a>
<a name="1792"><span class="lineNum">    1792 </span>            :  ROSE_DLL_API bool isEqualToIntConst(SgExpression* e, int value);</a>
<a name="1793"><span class="lineNum">    1793 </span>            : </a>
<a name="1794"><span class="lineNum">    1794 </span>            :  //! Check if two function declarations refer to the same one. Two function declarations are the same when they are a) identical, b) same name in C c) same qualified named and mangled name in C++. A nondefining (prototype) declaration and a defining declaration of a same function are treated as the same.</a>
<a name="1795"><span class="lineNum">    1795 </span>            :  /*!</a>
<a name="1796"><span class="lineNum">    1796 </span>            :   * There is a similar function bool compareFunctionDeclarations(SgFunctionDeclaration *f1, SgFunctionDeclaration *f2) from Classhierarchy.C</a>
<a name="1797"><span class="lineNum">    1797 </span>            :   */</a>
<a name="1798"><span class="lineNum">    1798 </span>            :  ROSE_DLL_API bool isSameFunction(SgFunctionDeclaration* func1, SgFunctionDeclaration* func2);</a>
<a name="1799"><span class="lineNum">    1799 </span>            : </a>
<a name="1800"><span class="lineNum">    1800 </span>            :  //! Check if a statement is the last statement within its closed scope</a>
<a name="1801"><span class="lineNum">    1801 </span>            :  ROSE_DLL_API bool isLastStatement(SgStatement* stmt);</a>
<a name="1802"><span class="lineNum">    1802 </span>            : </a>
<a name="1803"><span class="lineNum">    1803 </span>            : //@}</a>
<a name="1804"><span class="lineNum">    1804 </span>            : </a>
<a name="1805"><span class="lineNum">    1805 </span>            : //------------------------------------------------------------------------</a>
<a name="1806"><span class="lineNum">    1806 </span>            : //@{</a>
<a name="1807"><span class="lineNum">    1807 </span>            : /*! @name AST insert, removal, and replacement</a>
<a name="1808"><span class="lineNum">    1808 </span>            :   \brief Add, remove,and replace AST</a>
<a name="1809"><span class="lineNum">    1809 </span>            : </a>
<a name="1810"><span class="lineNum">    1810 </span>            :   scope-&gt;append_statement(), exprListExp-&gt;append_expression() etc. are not enough to handle side effect of parent pointers, symbol tables, preprocessing info, defining/nondefining pointers etc.</a>
<a name="1811"><span class="lineNum">    1811 </span>            : */</a>
<a name="1812"><span class="lineNum">    1812 </span>            : </a>
<a name="1813"><span class="lineNum">    1813 </span>            : #if 1</a>
<a name="1814"><span class="lineNum">    1814 </span>            : struct DeferredTransformation</a>
<a name="1815"><span class="lineNum">    1815 </span>            :    {</a>
<a name="1816"><span class="lineNum">    1816 </span>            :   // DQ (11/19/2020): We need to expand the use of this to cover deffered transformations of common SageInterface transformations (e.g. replaceStatement).</a>
<a name="1817"><span class="lineNum">    1817 </span>            :   // So I needed to move this out of being specific to the outliner and make it more generally data structure in the SageInterface.</a>
<a name="1818"><span class="lineNum">    1818 </span>            : </a>
<a name="1819"><span class="lineNum">    1819 </span>            :   // DQ (11/15/2020): Need to add the concept of deffered transformation to cover replaceStatement operations.</a>
<a name="1820"><span class="lineNum">    1820 </span>            : </a>
<a name="1821"><span class="lineNum">    1821 </span>            :   // DQ (8/7/2019): Store data required to support defering the transformation to insert the outlined function prototypes</a>
<a name="1822"><span class="lineNum">    1822 </span>            :   // into class declaration (when this is required to support the outlined function's access to protected or private data members).</a>
<a name="1823"><span class="lineNum">    1823 </span>            :   // This is part of an optimization to support the optimization of header file unparsing (limiting the overhead of supporting any</a>
<a name="1824"><span class="lineNum">    1824 </span>            :   // header file to just focus on the few (typically one) header file that would have to be unparsed.</a>
<a name="1825"><span class="lineNum">    1825 </span>            : </a>
<a name="1826"><span class="lineNum">    1826 </span>            :      enum TransformationKind</a>
<a name="1827"><span class="lineNum">    1827 </span>            :         {</a>
<a name="1828"><span class="lineNum">    1828 </span>            :        // DQ (11/22/2020): Might need to also add SageInterface::addDefaultConstructorIfRequired() and SageStatement::insert_statment()</a>
<a name="1829"><span class="lineNum">    1829 </span>            :        // to support the processStatements.C transforamtions to pre-process the AST (return expressions and variable initializations).</a>
<a name="1830"><span class="lineNum">    1830 </span>            :           e_error,</a>
<a name="1831"><span class="lineNum">    1831 </span>            :           e_default,</a>
<a name="1832"><span class="lineNum">    1832 </span>            :           e_outliner,</a>
<a name="1833"><span class="lineNum">    1833 </span>            :           e_replaceStatement,</a>
<a name="1834"><span class="lineNum">    1834 </span>            :           e_removeStatement,</a>
<a name="1835"><span class="lineNum">    1835 </span>            :           e_replaceDefiningFunctionDeclarationWithFunctionPrototype,</a>
<a name="1836"><span class="lineNum">    1836 </span>            :           e_last</a>
<a name="1837"><span class="lineNum">    1837 </span>            :         };</a>
<a name="1838"><span class="lineNum">    1838 </span>            : </a>
<a name="1839"><span class="lineNum">    1839 </span>            :      TransformationKind deferredTransformationKind;</a>
<a name="1840"><span class="lineNum">    1840 </span>            : </a>
<a name="1841"><span class="lineNum">    1841 </span>            :   // DQ (12/12/2020): Adding a string label so that we can name the different kinds of transformations.</a>
<a name="1842"><span class="lineNum">    1842 </span>            :   // E.g. moving pattern matched function from header file to dynamic library, vs. replacing function</a>
<a name="1843"><span class="lineNum">    1843 </span>            :   // definitions in the dynamic library file with function prototypes.</a>
<a name="1844"><span class="lineNum">    1844 </span>            :      std::string transformationLabel;</a>
<a name="1845"><span class="lineNum">    1845 </span>            : </a>
<a name="1846"><span class="lineNum">    1846 </span>            :   // Remove sets statementToRemove, replace sets statementToRemove and StatementToAdd.</a>
<a name="1847"><span class="lineNum">    1847 </span>            :      SgStatement* statementToRemove;</a>
<a name="1848"><span class="lineNum">    1848 </span>            :      SgStatement* statementToAdd;</a>
<a name="1849"><span class="lineNum">    1849 </span>            : </a>
<a name="1850"><span class="lineNum">    1850 </span>            :      SgClassDefinition* class_definition;</a>
<a name="1851"><span class="lineNum">    1851 </span>            :      SgDeclarationStatement* target_class_member;</a>
<a name="1852"><span class="lineNum">    1852 </span>            :      SgDeclarationStatement* new_function_prototype;</a>
<a name="1853"><span class="lineNum">    1853 </span>            : </a>
<a name="1854"><span class="lineNum">    1854 </span>            :      typedef std::set&lt;SgClassDefinition *&gt; ClassDefSet_t;</a>
<a name="1855"><span class="lineNum">    1855 </span>            :      ClassDefSet_t targetClasses;</a>
<a name="1856"><span class="lineNum">    1856 </span>            : </a>
<a name="1857"><span class="lineNum">    1857 </span>            :      typedef std::vector&lt;SgFunctionDeclaration *&gt; FuncDeclList_t;</a>
<a name="1858"><span class="lineNum">    1858 </span>            :      FuncDeclList_t targetFriends;</a>
<a name="1859"><span class="lineNum">    1859 </span>            : </a>
<a name="1860"><span class="lineNum">    1860 </span>            :   // DQ (2/28/2021): Adding support for outlining where it involves building up pre-transformations.</a>
<a name="1861"><span class="lineNum">    1861 </span>            :   // For example, in the code segregation, we build a conditiona around the interval of statements</a>
<a name="1862"><span class="lineNum">    1862 </span>            :   // that we are outlining. This conditional is used to overwrite the first statement in the interval</a>
<a name="1863"><span class="lineNum">    1863 </span>            :   // list.  Because we don't want to transform the AST until after the outlining, we need so save the</a>
<a name="1864"><span class="lineNum">    1864 </span>            :   // whole interval so that we, after the outlining, remove the statements in the interval after that</a>
<a name="1865"><span class="lineNum">    1865 </span>            :   // first statement.</a>
<a name="1866"><span class="lineNum">    1866 </span>            :      typedef std::vector&lt;SgStatement*&gt; IntervalType;</a>
<a name="1867"><span class="lineNum">    1867 </span>            :      IntervalType statementInterval;</a>
<a name="1868"><span class="lineNum">    1868 </span>            :      SgStatement* locationToOverwriteWithTransformation;</a>
<a name="1869"><span class="lineNum">    1869 </span>            :      SgStatement* transformationToOverwriteFirstStatementInInterval;</a>
<a name="1870"><span class="lineNum">    1870 </span>            :      SgBasicBlock* blockOfStatementsToOutline;</a>
<a name="1871"><span class="lineNum">    1871 </span>            : </a>
<a name="1872"><span class="lineNum">    1872 </span>            :   // DQ (12/5/2019): Added ROSE_DLL_API prefix for Windows support (too all of these functions).</a>
<a name="1873"><span class="lineNum">    1873 </span>            :      ROSE_DLL_API DeferredTransformation();</a>
<a name="1874"><span class="lineNum">    1874 </span>            :      ROSE_DLL_API DeferredTransformation(SgClassDefinition* class_definition, SgDeclarationStatement* target_class_member, SgDeclarationStatement* new_function_prototype);</a>
<a name="1875"><span class="lineNum">    1875 </span>            :      ROSE_DLL_API DeferredTransformation (const DeferredTransformation&amp; X); //! Copy constructor.</a>
<a name="1876"><span class="lineNum">    1876 </span>            :      ROSE_DLL_API ~DeferredTransformation (void); //! Shallow; does not delete fields.</a>
<a name="1877"><span class="lineNum">    1877 </span>            : </a>
<a name="1878"><span class="lineNum">    1878 </span>            :      ROSE_DLL_API DeferredTransformation &amp; operator= (const DeferredTransformation&amp; X); //! operator=()</a>
<a name="1879"><span class="lineNum">    1879 </span>            : </a>
<a name="1880"><span class="lineNum">    1880 </span>            :   // DQ (11/20/20): static function to generate specialized version of deferred transformation object.</a>
<a name="1881"><span class="lineNum">    1881 </span>            :      static ROSE_DLL_API DeferredTransformation replaceDefiningFunctionDeclarationWithFunctionPrototype( SgFunctionDeclaration* functionDeclaration );</a>
<a name="1882"><span class="lineNum">    1882 </span>            :      static ROSE_DLL_API DeferredTransformation replaceStatement(SgStatement* oldStmt, SgStatement* newStmt, bool movePreprocessinInfo = false);</a>
<a name="1883"><span class="lineNum">    1883 </span>            : </a>
<a name="1884"><span class="lineNum">    1884 </span>            :      static ROSE_DLL_API std::string outputDeferredTransformationKind(const TransformationKind &amp; kind);</a>
<a name="1885"><span class="lineNum">    1885 </span>            :      ROSE_DLL_API void display ( std::string label ) const;</a>
<a name="1886"><span class="lineNum">    1886 </span>            : </a>
<a name="1887"><span class="lineNum">    1887 </span>            :    };</a>
<a name="1888"><span class="lineNum">    1888 </span>            : #endif</a>
<a name="1889"><span class="lineNum">    1889 </span>            : </a>
<a name="1890"><span class="lineNum">    1890 </span>            : </a>
<a name="1891"><span class="lineNum">    1891 </span>            : // DQ (2/24/2009): Simple function to delete an AST subtree (used in outlining).</a>
<a name="1892"><span class="lineNum">    1892 </span>            : //! Function to delete AST subtree's nodes only, users must take care of any dangling pointers, symbols or types that result.</a>
<a name="1893"><span class="lineNum">    1893 </span>            : ROSE_DLL_API void deleteAST(SgNode* node);</a>
<a name="1894"><span class="lineNum">    1894 </span>            : </a>
<a name="1895"><span class="lineNum">    1895 </span>            : //! Special purpose function for deleting AST expression tress containing valid original expression trees in constant folded expressions (for internal use only).</a>
<a name="1896"><span class="lineNum">    1896 </span>            : ROSE_DLL_API void deleteExpressionTreeWithOriginalExpressionSubtrees(SgNode* root);</a>
<a name="1897"><span class="lineNum">    1897 </span>            : </a>
<a name="1898"><span class="lineNum">    1898 </span>            : // DQ (2/25/2009): Added new function to support outliner.</a>
<a name="1899"><span class="lineNum">    1899 </span>            : //! Move statements in first block to the second block (preserves order and rebuilds the symbol table).</a>
<a name="1900"><span class="lineNum">    1900 </span>            : ROSE_DLL_API void moveStatementsBetweenBlocks ( SgBasicBlock* sourceBlock, SgBasicBlock* targetBlock );</a>
<a name="1901"><span class="lineNum">    1901 </span>            : </a>
<a name="1902"><span class="lineNum">    1902 </span>            : //! Move statements between C++ namespace's definitions</a>
<a name="1903"><span class="lineNum">    1903 </span>            : ROSE_DLL_API void moveStatementsBetweenBlocks ( SgNamespaceDefinitionStatement* sourceBlock, SgNamespaceDefinitionStatement* targetBlock );</a>
<a name="1904"><span class="lineNum">    1904 </span>            : </a>
<a name="1905"><span class="lineNum">    1905 </span>            : //!  Check if a function declaration is a C++11 lambda function</a>
<a name="1906"><span class="lineNum">    1906 </span>            : ROSE_DLL_API bool isLambdaFunction (SgFunctionDeclaration* func);</a>
<a name="1907"><span class="lineNum">    1907 </span>            : </a>
<a name="1908"><span class="lineNum">    1908 </span>            : //! check if a variable reference is this-&gt;a[i] inside of a lambda function</a>
<a name="1909"><span class="lineNum">    1909 </span>            : ROSE_DLL_API bool isLambdaCapturedVariable (SgVarRefExp* varRef);</a>
<a name="1910"><span class="lineNum">    1910 </span>            : </a>
<a name="1911"><span class="lineNum">    1911 </span>            : //! Move a variable declaration to a new scope, handle symbol, special scopes like For loop, etc.</a>
<a name="1912"><span class="lineNum">    1912 </span>            : ROSE_DLL_API void moveVariableDeclaration(SgVariableDeclaration* decl, SgScopeStatement* target_scope);</a>
<a name="1913"><span class="lineNum">    1913 </span>            : //! Append a statement to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.</a>
<a name="1914"><span class="lineNum">    1914 </span>            : ROSE_DLL_API void appendStatement(SgStatement *stmt, SgScopeStatement* scope=NULL);</a>
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<a name="1916"><span class="lineNum">    1916 </span>            : //! Append a statement to the end of SgForInitStatement</a>
<a name="1917"><span class="lineNum">    1917 </span>            : ROSE_DLL_API void appendStatement(SgStatement *stmt, SgForInitStatement* for_init_stmt);</a>
<a name="1918"><span class="lineNum">    1918 </span>            : </a>
<a name="1919"><span class="lineNum">    1919 </span>            : //! Append a list of statements to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.</a>
<a name="1920"><span class="lineNum">    1920 </span>            : ROSE_DLL_API void appendStatementList(const std::vector&lt;SgStatement*&gt;&amp; stmt, SgScopeStatement* scope=NULL);</a>
<a name="1921"><span class="lineNum">    1921 </span>            : </a>
<a name="1922"><span class="lineNum">    1922 </span>            : // DQ (2/6/2009): Added function to support outlining into separate file.</a>
<a name="1923"><span class="lineNum">    1923 </span>            : //! Append a copy ('decl') of a function ('original_statement') into a 'scope', include any referenced declarations required if the scope is within a compiler generated file. All referenced declarations, including those from headers, are inserted if excludeHeaderFiles is set to true (the new file will not have any headers).</a>
<a name="1924"><span class="lineNum">    1924 </span>            : ROSE_DLL_API void appendStatementWithDependentDeclaration( SgDeclarationStatement* decl, SgGlobal* scope, SgStatement* original_statement, bool excludeHeaderFiles );</a>
<a name="1925"><span class="lineNum">    1925 </span>            : </a>
<a name="1926"><span class="lineNum">    1926 </span>            : //! Prepend a statement to the beginning of the current scope, handling side</a>
<a name="1927"><span class="lineNum">    1927 </span>            : //! effects as appropriate</a>
<a name="1928"><span class="lineNum">    1928 </span>            : ROSE_DLL_API void prependStatement(SgStatement *stmt, SgScopeStatement* scope=NULL);</a>
<a name="1929"><span class="lineNum">    1929 </span>            : </a>
<a name="1930"><span class="lineNum">    1930 </span>            : //! Prepend a statement to the beginning of SgForInitStatement</a>
<a name="1931"><span class="lineNum">    1931 </span>            : ROSE_DLL_API void prependStatement(SgStatement *stmt, SgForInitStatement* for_init_stmt);</a>
<a name="1932"><span class="lineNum">    1932 </span>            : </a>
<a name="1933"><span class="lineNum">    1933 </span>            : //! prepend a list of statements to the beginning of the current scope,</a>
<a name="1934"><span class="lineNum">    1934 </span>            : //! handling side effects as appropriate</a>
<a name="1935"><span class="lineNum">    1935 </span>            : ROSE_DLL_API void prependStatementList(const std::vector&lt;SgStatement*&gt;&amp; stmt, SgScopeStatement* scope=NULL);</a>
<a name="1936"><span class="lineNum">    1936 </span>            : </a>
<a name="1937"><span class="lineNum">    1937 </span>            : //! Check if a scope statement has a simple children statement list</a>
<a name="1938"><span class="lineNum">    1938 </span>            : //! so insert additional statements under the scope is straightforward and unambiguous .</a>
<a name="1939"><span class="lineNum">    1939 </span>            : //! for example, SgBasicBlock has a simple statement list while IfStmt does not.</a>
<a name="1940"><span class="lineNum">    1940 </span>            : ROSE_DLL_API bool  hasSimpleChildrenList (SgScopeStatement* scope);</a>
<a name="1941"><span class="lineNum">    1941 </span>            : </a>
<a name="1942"><span class="lineNum">    1942 </span>            : //! Insert a statement before or after the target statement within the target's scope. Move around preprocessing info automatically</a>
<a name="1943"><span class="lineNum">    1943 </span>            : ROSE_DLL_API void insertStatement(SgStatement *targetStmt, SgStatement* newStmt, bool insertBefore= true, bool autoMovePreprocessingInfo = true);</a>
<a name="1944"><span class="lineNum">    1944 </span>            : </a>
<a name="1945"><span class="lineNum">    1945 </span>            : //! Insert a list of statements before or after the target statement within the</a>
<a name="1946"><span class="lineNum">    1946 </span>            : //target's scope</a>
<a name="1947"><span class="lineNum">    1947 </span>            : ROSE_DLL_API void insertStatementList(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmts, bool insertBefore= true);</a>
<a name="1948"><span class="lineNum">    1948 </span>            : </a>
<a name="1949"><span class="lineNum">    1949 </span>            : //! Insert a statement before a target statement</a>
<a name="1950"><span class="lineNum">    1950 </span>            : ROSE_DLL_API void insertStatementBefore(SgStatement *targetStmt, SgStatement* newStmt, bool autoMovePreprocessingInfo = true);</a>
<a name="1951"><span class="lineNum">    1951 </span>            : </a>
<a name="1952"><span class="lineNum">    1952 </span>            : //! Insert a list of statements before a target statement</a>
<a name="1953"><span class="lineNum">    1953 </span>            : ROSE_DLL_API void insertStatementListBefore(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmts);</a>
<a name="1954"><span class="lineNum">    1954 </span>            : </a>
<a name="1955"><span class="lineNum">    1955 </span>            : //! Insert a statement after a target statement, Move around preprocessing info automatically by default</a>
<a name="1956"><span class="lineNum">    1956 </span>            : ROSE_DLL_API void insertStatementAfter(SgStatement *targetStmt, SgStatement* newStmt, bool autoMovePreprocessingInfo = true);</a>
<a name="1957"><span class="lineNum">    1957 </span>            : </a>
<a name="1958"><span class="lineNum">    1958 </span>            : //! Insert a list of statements after a target statement</a>
<a name="1959"><span class="lineNum">    1959 </span>            : ROSE_DLL_API void insertStatementListAfter(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmt);</a>
<a name="1960"><span class="lineNum">    1960 </span>            : </a>
<a name="1961"><span class="lineNum">    1961 </span>            : //! Insert a statement after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found</a>
<a name="1962"><span class="lineNum">    1962 </span>            : ROSE_DLL_API void insertStatementAfterLastDeclaration(SgStatement* stmt, SgScopeStatement* scope);</a>
<a name="1963"><span class="lineNum">    1963 </span>            : </a>
<a name="1964"><span class="lineNum">    1964 </span>            : //! Insert a list of statements after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found</a>
<a name="1965"><span class="lineNum">    1965 </span>            : ROSE_DLL_API void insertStatementAfterLastDeclaration(std::vector&lt;SgStatement*&gt; stmt_list, SgScopeStatement* scope);</a>
<a name="1966"><span class="lineNum">    1966 </span>            : </a>
<a name="1967"><span class="lineNum">    1967 </span>            : //! Insert a statement before the first non-declaration statement in a scope.  If the scope has no non-declaration statements</a>
<a name="1968"><span class="lineNum">    1968 </span>            : //  then the statement is inserted at the end of the scope.</a>
<a name="1969"><span class="lineNum">    1969 </span>            : ROSE_DLL_API void insertStatementBeforeFirstNonDeclaration(SgStatement *newStmt, SgScopeStatement *scope,</a>
<a name="1970"><span class="lineNum">    1970 </span>            :                                                            bool movePreprocessingInfo=true);</a>
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<a name="1972"><span class="lineNum">    1972 </span>            : //! Insert statements before the first non-declaration statement in a scope.  If the scope has no non-declaration statements</a>
<a name="1973"><span class="lineNum">    1973 </span>            : //then the new statements are inserted at the end of the scope.</a>
<a name="1974"><span class="lineNum">    1974 </span>            : ROSE_DLL_API void insertStatementListBeforeFirstNonDeclaration(const std::vector&lt;SgStatement*&gt; &amp;newStmts, SgScopeStatement *scope);</a>
<a name="1975"><span class="lineNum">    1975 </span>            : </a>
<a name="1976"><span class="lineNum">    1976 </span>            : // DQ (11/21/2018): We need to sometimes insert something after the last statement of the collection from rose_edg_required_macros_and_functions.h.</a>
<a name="1977"><span class="lineNum">    1977 </span>            : ROSE_DLL_API SgStatement* lastFrontEndSpecificStatement( SgGlobal* globalScope );</a>
<a name="1978"><span class="lineNum">    1978 </span>            : </a>
<a name="1979"><span class="lineNum">    1979 </span>            : //! Remove a statement from its attach point of the AST. Automatically keep its associated preprocessing information at the original place after the removal. The statement is still in memory and it is up to the users to decide if the removed one will be inserted somewhere else or released from memory (deleteAST()).</a>
<a name="1980"><span class="lineNum">    1980 </span>            : ROSE_DLL_API void removeStatement(SgStatement* stmt, bool autoRelocatePreprocessingInfo = true);</a>
<a name="1981"><span class="lineNum">    1981 </span>            : </a>
<a name="1982"><span class="lineNum">    1982 </span>            : //! Deep delete a sub AST tree. It uses postorder traversal to delete each child node. Users must take care of any dangling pointers, symbols or types that result. This is identical to deleteAST()</a>
<a name="1983"><span class="lineNum">    1983 </span>            : ROSE_DLL_API void deepDelete(SgNode* root);</a>
<a name="1984"><span class="lineNum">    1984 </span>            : </a>
<a name="1985"><span class="lineNum">    1985 </span>            : //! Replace a statement with another. Move preprocessing information from oldStmt to newStmt if requested.</a>
<a name="1986"><span class="lineNum">    1986 </span>            : ROSE_DLL_API void replaceStatement(SgStatement* oldStmt, SgStatement* newStmt, bool movePreprocessinInfo = false);</a>
<a name="1987"><span class="lineNum">    1987 </span>            : </a>
<a name="1988"><span class="lineNum">    1988 </span>            : //! Replace an anchor node with a specified pattern subtree with optional SgVariantExpression. All SgVariantExpression in the pattern will be replaced with copies of the anchor node.</a>
<a name="1989"><span class="lineNum">    1989 </span>            : ROSE_DLL_API SgNode* replaceWithPattern (SgNode * anchor, SgNode* new_pattern);</a>
<a name="1990"><span class="lineNum">    1990 </span>            : </a>
<a name="1991"><span class="lineNum">    1991 </span>            : //! Replace all variable references to an old symbol in a scope to being references to a new symbol.</a>
<a name="1992"><span class="lineNum">    1992 </span>            : // Essentially replace variable a with b.</a>
<a name="1993"><span class="lineNum">    1993 </span>            : ROSE_DLL_API void replaceVariableReferences(SgVariableSymbol* old_sym, SgVariableSymbol* new_sym, SgScopeStatement * scope );</a>
<a name="1994"><span class="lineNum">    1994 </span>            : </a>
<a name="1995"><span class="lineNum">    1995 </span>            : // DQ (11/12/2018): Adding test to avoid issues that we can't test for in the unparsing of header files using the token based unparsing.</a>
<a name="1996"><span class="lineNum">    1996 </span>            : //! If header file unparsing and token-based unparsing are used, then some statements in header files</a>
<a name="1997"><span class="lineNum">    1997 </span>            : //! used with the same name and different include syntax can't be transformed. This is currently because</a>
<a name="1998"><span class="lineNum">    1998 </span>            : //! there is no way to generally test the resulting transformed code generated by ROSE.</a>
<a name="1999"><span class="lineNum">    1999 </span>            : ROSE_DLL_API bool statementCanBeTransformed(SgStatement* stmt);</a>
<a name="2000"><span class="lineNum">    2000 </span>            : </a>
<a name="2001"><span class="lineNum">    2001 </span>            : </a>
<a name="2002"><span class="lineNum">    2002 </span>            : /** Given an expression, generates a temporary variable whose initializer optionally evaluates</a>
<a name="2003"><span class="lineNum">    2003 </span>            : * that expression. Then, the var reference expression returned can be used instead of the original</a>
<a name="2004"><span class="lineNum">    2004 </span>            : * expression. The temporary variable created can be reassigned to the expression by the returned SgAssignOp;</a>
<a name="2005"><span class="lineNum">    2005 </span>            : * this can be used when the expression the variable represents needs to be evaluated. NOTE: This handles</a>
<a name="2006"><span class="lineNum">    2006 </span>            : * reference types correctly by using pointer types for the temporary.</a>
<a name="2007"><span class="lineNum">    2007 </span>            : * @param expression Expression which will be replaced by a variable</a>
<a name="2008"><span class="lineNum">    2008 </span>            : * @param scope scope in which the temporary variable will be generated</a>
<a name="2009"><span class="lineNum">    2009 </span>            : * @param reEvaluate an assignment op to reevaluate the expression. Leave NULL if not needed</a>
<a name="2010"><span class="lineNum">    2010 </span>            : * @return declaration of the temporary variable, and a a variable reference expression to use instead of</a>
<a name="2011"><span class="lineNum">    2011 </span>            : * the original expression. */</a>
<a name="2012"><span class="lineNum">    2012 </span>            : std::pair&lt;SgVariableDeclaration*, SgExpression* &gt; createTempVariableForExpression(SgExpression* expression,</a>
<a name="2013"><span class="lineNum">    2013 </span>            :         SgScopeStatement* scope, bool initializeInDeclaration, SgAssignOp** reEvaluate = NULL);</a>
<a name="2014"><span class="lineNum">    2014 </span>            : </a>
<a name="2015"><span class="lineNum">    2015 </span>            : /*  This function creates a temporary variable for a given expression in the given scope</a>
<a name="2016"><span class="lineNum">    2016 </span>            :    This is different from SageInterface::createTempVariableForExpression in that it does not</a>
<a name="2017"><span class="lineNum">    2017 </span>            :    try to be smart to create pointers to reference types and so on. The tempt is initialized to expression.</a>
<a name="2018"><span class="lineNum">    2018 </span>            :    The caller is responsible for setting the parent of SgVariableDeclaration since buildVariableDeclaration</a>
<a name="2019"><span class="lineNum">    2019 </span>            :    may not set_parent() when the scope stack is empty. See programTransformation/extractFunctionArgumentsNormalization/ExtractFunctionArguments.C for sample usage.</a>
<a name="2020"><span class="lineNum">    2020 </span>            :    @param expression Expression which will be replaced by a variable</a>
<a name="2021"><span class="lineNum">    2021 </span>            :    @param scope scope in which the temporary variable will be generated</a>
<a name="2022"><span class="lineNum">    2022 </span>            : */</a>
<a name="2023"><span class="lineNum">    2023 </span>            : </a>
<a name="2024"><span class="lineNum">    2024 </span>            : std::pair&lt;SgVariableDeclaration*, SgExpression*&gt; createTempVariableAndReferenceForExpression</a>
<a name="2025"><span class="lineNum">    2025 </span>            :     (SgExpression* expression, SgScopeStatement* scope);</a>
<a name="2026"><span class="lineNum">    2026 </span>            : </a>
<a name="2027"><span class="lineNum">    2027 </span>            : //! Append an argument to SgFunctionParameterList, transparently set parent,scope, and symbols for arguments when possible</a>
<a name="2028"><span class="lineNum">    2028 </span>            : /*! We recommend to build SgFunctionParameterList before building a function declaration</a>
<a name="2029"><span class="lineNum">    2029 </span>            :  However, it is still allowed to append new arguments for existing function declarations.</a>
<a name="2030"><span class="lineNum">    2030 </span>            :  \todo function type , function symbol also need attention.</a>
<a name="2031"><span class="lineNum">    2031 </span>            : */</a>
<a name="2032"><span class="lineNum">    2032 </span>            : ROSE_DLL_API SgVariableSymbol* appendArg(SgFunctionParameterList *, SgInitializedName*);</a>
<a name="2033"><span class="lineNum">    2033 </span>            : //!Prepend an argument to SgFunctionParameterList</a>
<a name="2034"><span class="lineNum">    2034 </span>            : ROSE_DLL_API SgVariableSymbol* prependArg(SgFunctionParameterList *, SgInitializedName*);</a>
<a name="2035"><span class="lineNum">    2035 </span>            : </a>
<a name="2036"><span class="lineNum">    2036 </span>            : //! Append an expression to a SgExprListExp, set the parent pointer also</a>
<a name="2037"><span class="lineNum">    2037 </span>            : ROSE_DLL_API void appendExpression(SgExprListExp *, SgExpression*);</a>
<a name="2038"><span class="lineNum">    2038 </span>            : </a>
<a name="2039"><span class="lineNum">    2039 </span>            : //! Append an expression list to a SgExprListExp, set the parent pointers also</a>
<a name="2040"><span class="lineNum">    2040 </span>            : ROSE_DLL_API void appendExpressionList(SgExprListExp *, const std::vector&lt;SgExpression*&gt;&amp;);</a>
<a name="2041"><span class="lineNum">    2041 </span>            : </a>
<a name="2042"><span class="lineNum">    2042 </span>            : //! Set parameter list for a function declaration, considering existing parameter list etc.</a>
<a name="2043"><span class="lineNum">    2043 </span>            : template &lt;class actualFunction&gt;</a>
<a name="2044"><span class="lineNum">    2044 </span><span class="lineCov">    1180451 : void setParameterList(actualFunction *func,SgFunctionParameterList *paralist) {</span></a>
<a name="2045"><span class="lineNum">    2045 </span>            : </a>
<a name="2046"><span class="lineNum">    2046 </span>            :   // TODO consider the difference between C++ and Fortran</a>
<a name="2047"><span class="lineNum">    2047 </span>            :   // fixup the scope of arguments,no symbols for nondefining function declaration's arguments</a>
<a name="2048"><span class="lineNum">    2048 </span>            : </a>
<a name="2049"><span class="lineNum">    2049 </span>            :   // DQ (11/25/2011): templated function so that we can handle both</a>
<a name="2050"><span class="lineNum">    2050 </span>            :   // SgFunctionDeclaration and SgTemplateFunctionDeclaration (and their associated member</a>
<a name="2051"><span class="lineNum">    2051 </span>            :   // function derived classes).</a>
<a name="2052"><span class="lineNum">    2052 </span>            : </a>
<a name="2053"><span class="lineNum">    2053 </span><span class="lineCov">    1180451 :      ROSE_ASSERT(func != NULL);</span></a>
<a name="2054"><span class="lineNum">    2054 </span><span class="lineCov">    1180451 :      ROSE_ASSERT(paralist != NULL);</span></a>
<a name="2055"><span class="lineNum">    2055 </span>            : </a>
<a name="2056"><span class="lineNum">    2056 </span>            : #if 0</a>
<a name="2057"><span class="lineNum">    2057 </span>            :   // At this point we don't have cerr and endl defined, so comment this code out.</a>
<a name="2058"><span class="lineNum">    2058 </span>            :   // Warn to users if a paralist is being shared</a>
<a name="2059"><span class="lineNum">    2059 </span>            :      if (paralist-&gt;get_parent() !=NULL)</a>
<a name="2060"><span class="lineNum">    2060 </span>            :         {</a>
<a name="2061"><span class="lineNum">    2061 </span>            :           cerr &lt;&lt; &quot;Waring! Setting a used SgFunctionParameterList to function: &quot;</a>
<a name="2062"><span class="lineNum">    2062 </span>            :                &lt;&lt; (func-&gt;get_name()).getString()&lt;&lt;endl</a>
<a name="2063"><span class="lineNum">    2063 </span>            :                &lt;&lt; &quot; Sharing parameter lists can corrupt symbol tables!&quot;&lt;&lt;endl</a>
<a name="2064"><span class="lineNum">    2064 </span>            :                &lt;&lt; &quot; Please use deepCopy() to get an exclusive parameter list for each function declaration!&quot;&lt;&lt;endl;</a>
<a name="2065"><span class="lineNum">    2065 </span>            :        // ROSE_ASSERT(false);</a>
<a name="2066"><span class="lineNum">    2066 </span>            :         }</a>
<a name="2067"><span class="lineNum">    2067 </span>            : #endif</a>
<a name="2068"><span class="lineNum">    2068 </span>            : </a>
<a name="2069"><span class="lineNum">    2069 </span>            :   // Liao,2/5/2008  constructor of SgFunctionDeclaration will automatically generate SgFunctionParameterList, so be cautious when set new paralist!!</a>
<a name="2070"><span class="lineNum">    2070 </span><span class="lineCov">    1180451 :      if (func-&gt;get_parameterList() != NULL)</span></a>
<a name="2071"><span class="lineNum">    2071 </span>            :         {</a>
<a name="2072"><span class="lineNum">    2072 </span><span class="lineCov">      19243 :           if (func-&gt;get_parameterList() != paralist)</span></a>
<a name="2073"><span class="lineNum">    2073 </span>            :              {</a>
<a name="2074"><span class="lineNum">    2074 </span><span class="lineCov">      19243 :                delete func-&gt;get_parameterList();</span></a>
<a name="2075"><span class="lineNum">    2075 </span>            :              }</a>
<a name="2076"><span class="lineNum">    2076 </span>            :         }</a>
<a name="2077"><span class="lineNum">    2077 </span>            : </a>
<a name="2078"><span class="lineNum">    2078 </span><span class="lineCov">    1180451 :      func-&gt;set_parameterList(paralist);</span></a>
<a name="2079"><span class="lineNum">    2079 </span><span class="lineCov">    1180451 :      paralist-&gt;set_parent(func);</span></a>
<a name="2080"><span class="lineNum">    2080 </span>            : </a>
<a name="2081"><span class="lineNum">    2081 </span>            :      {</a>
<a name="2082"><span class="lineNum">    2082 </span>            :         // DQ (5/15/2012): Need to set the declptr in each SgInitializedName IR node.</a>
<a name="2083"><span class="lineNum">    2083 </span>            :         // This is needed to support the AST Copy mechanism (at least). The files: test2005_150.C,</a>
<a name="2084"><span class="lineNum">    2084 </span>            :         // test2012_81.C and testcode2012_82.C demonstrate this problem.</a>
<a name="2085"><span class="lineNum">    2085 </span><span class="lineCov">    1180451 :       SgInitializedNamePtrList &amp; args = paralist-&gt;get_args();</span></a>
<a name="2086"><span class="lineNum">    2086 </span><span class="lineCov">    4373448 :        for (SgInitializedNamePtrList::iterator i = args.begin(); i != args.end(); i++)</span></a>
<a name="2087"><span class="lineNum">    2087 </span>            :         {</a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineCov">    3192997 :           (*i)-&gt;set_declptr(func);</span></a>
<a name="2089"><span class="lineNum">    2089 </span>            :         }</a>
<a name="2090"><span class="lineNum">    2090 </span>            :      }</a>
<a name="2091"><span class="lineNum">    2091 </span><span class="lineCov">    1180451 :    }</span></a>
<a name="2092"><span class="lineNum">    2092 </span>            : </a>
<a name="2093"><span class="lineNum">    2093 </span>            : //! Set a pragma of a pragma declaration. handle memory release for preexisting pragma, and set parent pointer.</a>
<a name="2094"><span class="lineNum">    2094 </span>            : ROSE_DLL_API void setPragma(SgPragmaDeclaration* decl, SgPragma *pragma);</a>
<a name="2095"><span class="lineNum">    2095 </span>            : </a>
<a name="2096"><span class="lineNum">    2096 </span>            :   //! Replace an expression with another, used for variable reference substitution and others. the old expression can be deleted (default case)  or kept.</a>
<a name="2097"><span class="lineNum">    2097 </span>            : ROSE_DLL_API void replaceExpression(SgExpression* oldExp, SgExpression* newExp, bool keepOldExp=false);</a>
<a name="2098"><span class="lineNum">    2098 </span>            : </a>
<a name="2099"><span class="lineNum">    2099 </span>            : //! Replace a given expression with a list of statements produced by a generator</a>
<a name="2100"><span class="lineNum">    2100 </span>            : ROSE_DLL_API void replaceExpressionWithStatement(SgExpression* from,</a>
<a name="2101"><span class="lineNum">    2101 </span>            :                                     SageInterface::StatementGenerator* to);</a>
<a name="2102"><span class="lineNum">    2102 </span>            : //! Similar to replaceExpressionWithStatement, but with more restrictions.</a>
<a name="2103"><span class="lineNum">    2103 </span>            : //! Assumptions: from is not within the test of a loop or ifStmt,  not currently traversing from or the statement it is in</a>
<a name="2104"><span class="lineNum">    2104 </span>            : ROSE_DLL_API void replaceSubexpressionWithStatement(SgExpression* from,</a>
<a name="2105"><span class="lineNum">    2105 </span>            :                                       SageInterface::StatementGenerator* to);</a>
<a name="2106"><span class="lineNum">    2106 </span>            : </a>
<a name="2107"><span class="lineNum">    2107 </span>            : //! Set operands for expressions with single operand, such as unary expressions. handle file info, lvalue, pointer downcasting, parent pointer etc.</a>
<a name="2108"><span class="lineNum">    2108 </span>            : ROSE_DLL_API void setOperand(SgExpression* target, SgExpression* operand);</a>
<a name="2109"><span class="lineNum">    2109 </span>            : </a>
<a name="2110"><span class="lineNum">    2110 </span>            : //!set left hand operand for binary expressions, transparently downcasting target expressions when necessary</a>
<a name="2111"><span class="lineNum">    2111 </span>            : ROSE_DLL_API void setLhsOperand(SgExpression* target, SgExpression* lhs);</a>
<a name="2112"><span class="lineNum">    2112 </span>            : </a>
<a name="2113"><span class="lineNum">    2113 </span>            : //!set left hand operand for binary expression</a>
<a name="2114"><span class="lineNum">    2114 </span>            : ROSE_DLL_API void setRhsOperand(SgExpression* target, SgExpression* rhs);</a>
<a name="2115"><span class="lineNum">    2115 </span>            : </a>
<a name="2116"><span class="lineNum">    2116 </span>            : //! Set original expression trees to NULL for SgValueExp or SgCastExp expressions, so you can change the value and have it unparsed correctly.</a>
<a name="2117"><span class="lineNum">    2117 </span>            : ROSE_DLL_API void removeAllOriginalExpressionTrees(SgNode* top);</a>
<a name="2118"><span class="lineNum">    2118 </span>            : </a>
<a name="2119"><span class="lineNum">    2119 </span>            : // DQ (1/25/2010): Added support for directories</a>
<a name="2120"><span class="lineNum">    2120 </span>            : //! Move file to be generated in a subdirectory (will be generated by the unparser).</a>
<a name="2121"><span class="lineNum">    2121 </span>            : ROSE_DLL_API void moveToSubdirectory ( std::string directoryName, SgFile* file );</a>
<a name="2122"><span class="lineNum">    2122 </span>            : </a>
<a name="2123"><span class="lineNum">    2123 </span>            : //! Supporting function to comment relocation in insertStatement() and removeStatement().</a>
<a name="2124"><span class="lineNum">    2124 </span>            : ROSE_DLL_API SgStatement* findSurroundingStatementFromSameFile(SgStatement* targetStmt, bool &amp; surroundingStatementPreceedsTargetStatement);</a>
<a name="2125"><span class="lineNum">    2125 </span>            : </a>
<a name="2126"><span class="lineNum">    2126 </span>            : //! Relocate comments and CPP directives from one statement to another.</a>
<a name="2127"><span class="lineNum">    2127 </span>            : ROSE_DLL_API void moveCommentsToNewStatement(SgStatement* sourceStatement, const std::vector&lt;int&gt; &amp; indexList, SgStatement* targetStatement, bool surroundingStatementPreceedsTargetStatement);</a>
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<a name="2129"><span class="lineNum">    2129 </span>            : // DQ (7/19/2015): This is required to support general unparsing of template instantations for the GNU g++</a>
<a name="2130"><span class="lineNum">    2130 </span>            : // compiler which does not permit name qualification to be used to support the expression of the namespace</a>
<a name="2131"><span class="lineNum">    2131 </span>            : // where a template instantiatoon would be places.  Such name qualification would also sometimes require</a>
<a name="2132"><span class="lineNum">    2132 </span>            : // global qualification which is also not allowed by the GNU g++ compiler.  These issues appear to be</a>
<a name="2133"><span class="lineNum">    2133 </span>            : // specific to the GNU compiler versions, at least versions 4.4 through 4.8.</a>
<a name="2134"><span class="lineNum">    2134 </span>            : //! Relocate the declaration to be explicitly represented in its associated namespace (required for some backend compilers to process template instantiations).</a>
<a name="2135"><span class="lineNum">    2135 </span>            : ROSE_DLL_API void moveDeclarationToAssociatedNamespace ( SgDeclarationStatement* declarationStatement );</a>
<a name="2136"><span class="lineNum">    2136 </span>            : </a>
<a name="2137"><span class="lineNum">    2137 </span>            : ROSE_DLL_API bool isTemplateInstantiationNode(SgNode* node);</a>
<a name="2138"><span class="lineNum">    2138 </span>            : </a>
<a name="2139"><span class="lineNum">    2139 </span>            : ROSE_DLL_API void wrapAllTemplateInstantiationsInAssociatedNamespaces(SgProject* root);</a>
<a name="2140"><span class="lineNum">    2140 </span>            : </a>
<a name="2141"><span class="lineNum">    2141 </span>            : // DQ (12/1/2015): Adding support for fixup internal data struuctures that have references to statements (e.g. macro expansions).</a>
<a name="2142"><span class="lineNum">    2142 </span>            : ROSE_DLL_API void resetInternalMapsForTargetStatement(SgStatement* sourceStatement);</a>
<a name="2143"><span class="lineNum">    2143 </span>            : </a>
<a name="2144"><span class="lineNum">    2144 </span>            : // DQ (6/7/2019): Add support for transforming function definitions to function prototypes in a subtree.</a>
<a name="2145"><span class="lineNum">    2145 </span>            : // We might have to make this specific to a file (only traversing the functions in that file).</a>
<a name="2146"><span class="lineNum">    2146 </span>            : /*!\brief XXX</a>
<a name="2147"><span class="lineNum">    2147 </span>            :  * This function operates on the new file used to support outlined function definitions.</a>
<a name="2148"><span class="lineNum">    2148 </span>            :  * We use a copy of the file where the code will be outlined FROM, so that if there are references to</a>
<a name="2149"><span class="lineNum">    2149 </span>            :  * declarations in the outlined code we can support the outpiled code with those references.  This</a>
<a name="2150"><span class="lineNum">    2150 </span>            :  * approach has the added advantage of also supporting the same include file tree as the original</a>
<a name="2151"><span class="lineNum">    2151 </span>            :  * file where the outlined code is being taken from.</a>
<a name="2152"><span class="lineNum">    2152 </span>            :  */</a>
<a name="2153"><span class="lineNum">    2153 </span>            : ROSE_DLL_API void convertFunctionDefinitionsToFunctionPrototypes(SgNode* node);</a>
<a name="2154"><span class="lineNum">    2154 </span>            : </a>
<a name="2155"><span class="lineNum">    2155 </span>            : // DQ (11/10/2019): Lower level support for convertFunctionDefinitionsToFunctionPrototypes().</a>
<a name="2156"><span class="lineNum">    2156 </span>            : // DQ (10/27/2020): Need to return the generated function prototype (incase we want to mark it for output or template unparsing from the AST).</a>
<a name="2157"><span class="lineNum">    2157 </span>            : // ROSE_DLL_API void replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration );</a>
<a name="2158"><span class="lineNum">    2158 </span>            : // ROSE_DLL_API SgDeclarationStatement* replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration );</a>
<a name="2159"><span class="lineNum">    2159 </span>            : ROSE_DLL_API SgFunctionDeclaration* replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration );</a>
<a name="2160"><span class="lineNum">    2160 </span>            : ROSE_DLL_API std::vector&lt;SgFunctionDeclaration*&gt; generateFunctionDefinitionsList(SgNode* node);</a>
<a name="2161"><span class="lineNum">    2161 </span>            : </a>
<a name="2162"><span class="lineNum">    2162 </span>            : // DQ (10/29/2020): build a function prototype for all but member functions outside of the class (except for template instantiations).</a>
<a name="2163"><span class="lineNum">    2163 </span>            : // The reason why member functions outside of the class are an exception is because they can not be used except in a class and there</a>
<a name="2164"><span class="lineNum">    2164 </span>            : // would already be one present for the code to compile.</a>
<a name="2165"><span class="lineNum">    2165 </span>            : ROSE_DLL_API SgFunctionDeclaration* buildFunctionPrototype ( SgFunctionDeclaration* functionDeclaration );</a>
<a name="2166"><span class="lineNum">    2166 </span>            : </a>
<a name="2167"><span class="lineNum">    2167 </span>            : </a>
<a name="2168"><span class="lineNum">    2168 </span>            : //@}</a>
<a name="2169"><span class="lineNum">    2169 </span>            : //------------------------------------------------------------------------</a>
<a name="2170"><span class="lineNum">    2170 </span>            : //@{</a>
<a name="2171"><span class="lineNum">    2171 </span>            : /*! @name AST repair, fix, and postprocessing.</a>
<a name="2172"><span class="lineNum">    2172 </span>            :   \brief Mostly used internally when some AST pieces are built without knowing their target</a>
<a name="2173"><span class="lineNum">    2173 </span>            :   scope/parent, especially during bottom-up construction of AST. The associated symbols,</a>
<a name="2174"><span class="lineNum">    2174 </span>            :    parent and scope  pointers cannot be set on construction then.</a>
<a name="2175"><span class="lineNum">    2175 </span>            :    A set of utility functions are provided to</a>
<a name="2176"><span class="lineNum">    2176 </span>            :    patch up scope, parent, symbol for them when the target scope/parent become know.</a>
<a name="2177"><span class="lineNum">    2177 </span>            : */</a>
<a name="2178"><span class="lineNum">    2178 </span>            : //! Connect variable reference to the right variable symbols when feasible, return the number of references being fixed.</a>
<a name="2179"><span class="lineNum">    2179 </span>            : /*! In AST translation, it is possible to build a variable reference before the variable</a>
<a name="2180"><span class="lineNum">    2180 </span>            :  is being declared. buildVarRefExp() will use fake initialized name and symbol as placeholders</a>
<a name="2181"><span class="lineNum">    2181 </span>            :  to get the work done. Users should call fixVariableReference() when AST is complete and all</a>
<a name="2182"><span class="lineNum">    2182 </span>            :  variable declarations are in place.</a>
<a name="2183"><span class="lineNum">    2183 </span>            : */</a>
<a name="2184"><span class="lineNum">    2184 </span>            : ROSE_DLL_API int fixVariableReferences(SgNode* root,  bool cleanUnusedSymbol=true);</a>
<a name="2185"><span class="lineNum">    2185 </span>            : </a>
<a name="2186"><span class="lineNum">    2186 </span>            : //!Patch up symbol, scope, and parent information when a SgVariableDeclaration's scope is known.</a>
<a name="2187"><span class="lineNum">    2187 </span>            : /*!</a>
<a name="2188"><span class="lineNum">    2188 </span>            : It is possible to build a variable declaration without knowing its scope information during bottom-up construction of AST, though top-down construction is recommended in general.</a>
<a name="2189"><span class="lineNum">    2189 </span>            : In this case, we have to patch up symbol table, scope and parent information when the scope is known. This function is usually used internally within appendStatment(), insertStatement().</a>
<a name="2190"><span class="lineNum">    2190 </span>            : */</a>
<a name="2191"><span class="lineNum">    2191 </span>            : ROSE_DLL_API void fixVariableDeclaration(SgVariableDeclaration* varDecl, SgScopeStatement* scope);</a>
<a name="2192"><span class="lineNum">    2192 </span>            : </a>
<a name="2193"><span class="lineNum">    2193 </span>            : //! Fix symbols, parent and scope pointers. Used internally within appendStatment(), insertStatement() etc when a struct declaration was built without knowing its target scope.</a>
<a name="2194"><span class="lineNum">    2194 </span>            : ROSE_DLL_API void fixStructDeclaration(SgClassDeclaration* structDecl, SgScopeStatement* scope);</a>
<a name="2195"><span class="lineNum">    2195 </span>            : //! Fix symbols, parent and scope pointers. Used internally within appendStatment(), insertStatement() etc when a class declaration was built without knowing its target scope.</a>
<a name="2196"><span class="lineNum">    2196 </span>            : ROSE_DLL_API void fixClassDeclaration(SgClassDeclaration* classDecl, SgScopeStatement* scope);</a>
<a name="2197"><span class="lineNum">    2197 </span>            : </a>
<a name="2198"><span class="lineNum">    2198 </span>            : //! Fix symbols, parent and scope pointers. Used internally within appendStatment(), insertStatement() etc when a namespace declaration was built without knowing its target scope.</a>
<a name="2199"><span class="lineNum">    2199 </span>            : ROSE_DLL_API void fixNamespaceDeclaration(SgNamespaceDeclarationStatement* structDecl, SgScopeStatement* scope);</a>
<a name="2200"><span class="lineNum">    2200 </span>            : </a>
<a name="2201"><span class="lineNum">    2201 </span>            : </a>
<a name="2202"><span class="lineNum">    2202 </span>            : //! Fix symbol table for SgLabelStatement. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL.</a>
<a name="2203"><span class="lineNum">    2203 </span>            : ROSE_DLL_API void fixLabelStatement(SgLabelStatement* label_stmt, SgScopeStatement* scope);</a>
<a name="2204"><span class="lineNum">    2204 </span>            : </a>
<a name="2205"><span class="lineNum">    2205 </span>            : //! Set a numerical label for a Fortran statement. The statement should have a enclosing function definition already. SgLabelSymbol and SgLabelRefExp are created transparently as needed.</a>
<a name="2206"><span class="lineNum">    2206 </span>            : ROSE_DLL_API void setFortranNumericLabel(SgStatement* stmt, int label_value,</a>
<a name="2207"><span class="lineNum">    2207 </span>            :                                          SgLabelSymbol::label_type_enum label_type=SgLabelSymbol::e_start_label_type,</a>
<a name="2208"><span class="lineNum">    2208 </span>            :                                          SgScopeStatement* label_scope=NULL);</a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span>            : //! Suggest next usable (non-conflicting) numeric label value for a Fortran function definition scope</a>
<a name="2211"><span class="lineNum">    2211 </span>            : ROSE_DLL_API int  suggestNextNumericLabel(SgFunctionDefinition* func_def);</a>
<a name="2212"><span class="lineNum">    2212 </span>            : </a>
<a name="2213"><span class="lineNum">    2213 </span>            : //! Fix the symbol table and set scope (only if scope in declaration is not already set).</a>
<a name="2214"><span class="lineNum">    2214 </span>            : ROSE_DLL_API void fixFunctionDeclaration(SgFunctionDeclaration* stmt, SgScopeStatement* scope);</a>
<a name="2215"><span class="lineNum">    2215 </span>            : </a>
<a name="2216"><span class="lineNum">    2216 </span>            : //! Fix the symbol table and set scope (only if scope in declaration is not already set).</a>
<a name="2217"><span class="lineNum">    2217 </span>            : ROSE_DLL_API void fixTemplateDeclaration(SgTemplateDeclaration* stmt, SgScopeStatement* scope);</a>
<a name="2218"><span class="lineNum">    2218 </span>            : </a>
<a name="2219"><span class="lineNum">    2219 </span>            : //! A wrapper containing fixes (fixVariableDeclaration(),fixStructDeclaration(), fixLabelStatement(), etc) for all kinds statements. Should be used before attaching the statement into AST.</a>
<a name="2220"><span class="lineNum">    2220 </span>            : ROSE_DLL_API void fixStatement(SgStatement* stmt, SgScopeStatement* scope);</a>
<a name="2221"><span class="lineNum">    2221 </span>            : </a>
<a name="2222"><span class="lineNum">    2222 </span>            : // DQ (6/11/2015): This reports the statements that are marked as transformed (used to debug the token-based unparsing).</a>
<a name="2223"><span class="lineNum">    2223 </span>            : //! This collects the statements that are marked as transformed (useful in debugging).</a>
<a name="2224"><span class="lineNum">    2224 </span>            : ROSE_DLL_API std::set&lt;SgStatement*&gt; collectTransformedStatements( SgNode* node );</a>
<a name="2225"><span class="lineNum">    2225 </span>            : </a>
<a name="2226"><span class="lineNum">    2226 </span>            : //! This collects the statements that are marked as modified (a flag automatically set by all set_* generated functions) (useful in debugging).</a>
<a name="2227"><span class="lineNum">    2227 </span>            : ROSE_DLL_API std::set&lt;SgStatement*&gt; collectModifiedStatements( SgNode* node );</a>
<a name="2228"><span class="lineNum">    2228 </span>            : </a>
<a name="2229"><span class="lineNum">    2229 </span>            : //! This collects the SgLocatedNodes that are marked as modified (a flag automatically set by all set_* generated functions) (useful in debugging).</a>
<a name="2230"><span class="lineNum">    2230 </span>            : ROSE_DLL_API std::set&lt;SgLocatedNode*&gt; collectModifiedLocatedNodes( SgNode* node );</a>
<a name="2231"><span class="lineNum">    2231 </span>            : </a>
<a name="2232"><span class="lineNum">    2232 </span>            : // DQ (6/5/2019): Use the previously constructed set (above) to reset the IR nodes to be marked as isModified.</a>
<a name="2233"><span class="lineNum">    2233 </span>            : //! Use the set of IR nodes and set the isModified flag in each IR node to true.</a>
<a name="2234"><span class="lineNum">    2234 </span>            : ROSE_DLL_API void resetModifiedLocatedNodes(const std::set&lt;SgLocatedNode*&gt; &amp; modifiedNodeSet);</a>
<a name="2235"><span class="lineNum">    2235 </span>            : </a>
<a name="2236"><span class="lineNum">    2236 </span>            : </a>
<a name="2237"><span class="lineNum">    2237 </span>            : // DQ (10/23/2018): Report nodes that are marked as modified.</a>
<a name="2238"><span class="lineNum">    2238 </span>            : ROSE_DLL_API void reportModifiedStatements(const std::string &amp; label, SgNode* node);</a>
<a name="2239"><span class="lineNum">    2239 </span>            : </a>
<a name="2240"><span class="lineNum">    2240 </span>            : // DQ (3/22/2019): Translate CPP directives from attached preprocessor information to CPP Directive Declaration IR nodes.</a>
<a name="2241"><span class="lineNum">    2241 </span>            : ROSE_DLL_API void translateToUseCppDeclarations( SgNode* n );</a>
<a name="2242"><span class="lineNum">    2242 </span>            : </a>
<a name="2243"><span class="lineNum">    2243 </span>            : ROSE_DLL_API void translateScopeToUseCppDeclarations( SgScopeStatement* scope );</a>
<a name="2244"><span class="lineNum">    2244 </span>            : </a>
<a name="2245"><span class="lineNum">    2245 </span>            : ROSE_DLL_API std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; translateStatementToUseCppDeclarations( SgStatement* statement, SgScopeStatement* scope);</a>
<a name="2246"><span class="lineNum">    2246 </span>            : ROSE_DLL_API void printOutComments ( SgLocatedNode* locatedNode );</a>
<a name="2247"><span class="lineNum">    2247 </span>            : ROSE_DLL_API bool skipTranslateToUseCppDeclaration( PreprocessingInfo* currentPreprocessingInfo );</a>
<a name="2248"><span class="lineNum">    2248 </span>            : </a>
<a name="2249"><span class="lineNum">    2249 </span>            : // DQ (12/2/2019): Debugging support.</a>
<a name="2250"><span class="lineNum">    2250 </span>            : ROSE_DLL_API void outputFileIds( SgNode* node );</a>
<a name="2251"><span class="lineNum">    2251 </span>            : </a>
<a name="2252"><span class="lineNum">    2252 </span>            : </a>
<a name="2253"><span class="lineNum">    2253 </span>            : //@}</a>
<a name="2254"><span class="lineNum">    2254 </span>            : </a>
<a name="2255"><span class="lineNum">    2255 </span>            : //! Update defining and nondefining links due to a newly introduced function declaration. Should be used after inserting the function into a scope.</a>
<a name="2256"><span class="lineNum">    2256 </span>            : /*! This function not only set the defining and nondefining links of the newly introduced</a>
<a name="2257"><span class="lineNum">    2257 </span>            :  *  function declaration inside a scope, but also update other same function declarations' links</a>
<a name="2258"><span class="lineNum">    2258 </span>            :  *  accordingly if there are any.</a>
<a name="2259"><span class="lineNum">    2259 </span>            :  *  Assumption: The function has already inserted/appended/prepended into the scope before calling this function.</a>
<a name="2260"><span class="lineNum">    2260 </span>            :  */</a>
<a name="2261"><span class="lineNum">    2261 </span>            : ROSE_DLL_API void updateDefiningNondefiningLinks(SgFunctionDeclaration* func, SgScopeStatement* scope);</a>
<a name="2262"><span class="lineNum">    2262 </span>            : </a>
<a name="2263"><span class="lineNum">    2263 </span>            : //------------------------------------------------------------------------</a>
<a name="2264"><span class="lineNum">    2264 </span>            : //@{</a>
<a name="2265"><span class="lineNum">    2265 </span>            : /*! @name Advanced AST transformations, analyses, and optimizations</a>
<a name="2266"><span class="lineNum">    2266 </span>            :   \brief Some complex but commonly used AST transformations.</a>
<a name="2267"><span class="lineNum">    2267 </span>            :   */</a>
<a name="2268"><span class="lineNum">    2268 </span>            : </a>
<a name="2269"><span class="lineNum">    2269 </span>            : //! Collect all read and write references within stmt, which can be a function, a scope statement, or a single statement. Note that a reference can be both read and written, like i++</a>
<a name="2270"><span class="lineNum">    2270 </span>            : ROSE_DLL_API bool</a>
<a name="2271"><span class="lineNum">    2271 </span>            : collectReadWriteRefs(SgStatement* stmt, std::vector&lt;SgNode*&gt;&amp; readRefs, std::vector&lt;SgNode*&gt;&amp; writeRefs, bool useCachedDefUse=false);</a>
<a name="2272"><span class="lineNum">    2272 </span>            : </a>
<a name="2273"><span class="lineNum">    2273 </span>            : //!Collect unique variables which are read or written within a statement. Note that a variable can be both read and written. The statement can be either of a function, a scope, or a single line statement. For accesses to members of aggregate data, we return the coarse grain aggregate mem obj by default.</a>
<a name="2274"><span class="lineNum">    2274 </span>            : ROSE_DLL_API bool collectReadWriteVariables(SgStatement* stmt, std::set&lt;SgInitializedName*&gt;&amp; readVars, std::set&lt;SgInitializedName*&gt;&amp; writeVars, bool coarseGrain=true);</a>
<a name="2275"><span class="lineNum">    2275 </span>            : </a>
<a name="2276"><span class="lineNum">    2276 </span>            : //!Collect read only variables within a statement. The statement can be either of a function, a scope, or a single line statement. For accesses to members of aggregate data, we return the coarse grain aggregate mem obj by default.</a>
<a name="2277"><span class="lineNum">    2277 </span>            : ROSE_DLL_API void collectReadOnlyVariables(SgStatement* stmt, std::set&lt;SgInitializedName*&gt;&amp; readOnlyVars, bool coarseGrain=true);</a>
<a name="2278"><span class="lineNum">    2278 </span>            : </a>
<a name="2279"><span class="lineNum">    2279 </span>            : //!Collect read only variable symbols within a statement. The statement can be either of a function, a scope, or a single line statement. For accesses to members of aggregate data, we return the coarse grain aggregate mem obj by default.</a>
<a name="2280"><span class="lineNum">    2280 </span>            : ROSE_DLL_API void collectReadOnlySymbols(SgStatement* stmt, std::set&lt;SgVariableSymbol*&gt;&amp; readOnlySymbols, bool coarseGrain=true);</a>
<a name="2281"><span class="lineNum">    2281 </span>            : </a>
<a name="2282"><span class="lineNum">    2282 </span>            : //! Check if a variable reference is used by its address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++</a>
<a name="2283"><span class="lineNum">    2283 </span>            : ROSE_DLL_API bool isUseByAddressVariableRef(SgVarRefExp* ref);</a>
<a name="2284"><span class="lineNum">    2284 </span>            : </a>
<a name="2285"><span class="lineNum">    2285 </span>            : //! Collect variable references involving use by address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++</a>
<a name="2286"><span class="lineNum">    2286 </span>            : ROSE_DLL_API void collectUseByAddressVariableRefs (const SgStatement* s, std::set&lt;SgVarRefExp* &gt;&amp; varSetB);</a>
<a name="2287"><span class="lineNum">    2287 </span>            : </a>
<a name="2288"><span class="lineNum">    2288 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="2289"><span class="lineNum">    2289 </span>            : //!Call liveness analysis on an entire project</a>
<a name="2290"><span class="lineNum">    2290 </span>            : ROSE_DLL_API LivenessAnalysis * call_liveness_analysis(SgProject* project, bool debug=false);</a>
<a name="2291"><span class="lineNum">    2291 </span>            : </a>
<a name="2292"><span class="lineNum">    2292 </span>            : //!get liveIn and liveOut variables for a for loop from liveness analysis result liv.</a>
<a name="2293"><span class="lineNum">    2293 </span>            : ROSE_DLL_API void getLiveVariables(LivenessAnalysis * liv, SgForStatement* loop, std::set&lt;SgInitializedName*&gt;&amp; liveIns, std::set&lt;SgInitializedName*&gt; &amp; liveOuts);</a>
<a name="2294"><span class="lineNum">    2294 </span>            : #endif</a>
<a name="2295"><span class="lineNum">    2295 </span>            : </a>
<a name="2296"><span class="lineNum">    2296 </span>            : //!Recognize and collect reduction variables and operations within a C/C++ loop, following OpenMP 3.0 specification for allowed reduction variable types and operation types.</a>
<a name="2297"><span class="lineNum">    2297 </span>            : ROSE_DLL_API void ReductionRecognition(SgForStatement* loop, std::set&lt; std::pair &lt;SgInitializedName*, OmpSupport::omp_construct_enum&gt; &gt; &amp; results);</a>
<a name="2298"><span class="lineNum">    2298 </span>            : </a>
<a name="2299"><span class="lineNum">    2299 </span>            : //! Constant folding an AST subtree rooted at 'r' (replacing its children with their constant values, if applicable). Please be advised that constant folding on floating point computation may decrease the accuracy of floating point computations!</a>
<a name="2300"><span class="lineNum">    2300 </span>            : /*! It is a wrapper function for ConstantFolding::constantFoldingOptimization(). Note that only r's children are replaced with their corresponding constant values, not the input SgNode r itself. You have to call this upon an expression's parent node if you want to fold the expression. */</a>
<a name="2301"><span class="lineNum">    2301 </span>            : ROSE_DLL_API void constantFolding(SgNode* r);</a>
<a name="2302"><span class="lineNum">    2302 </span>            : </a>
<a name="2303"><span class="lineNum">    2303 </span>            : //!Instrument(Add a statement, often a function call) into a function right before the return points, handle multiple return statements (with duplicated statement s) and return expressions with side effects. Return the number of statements inserted.</a>
<a name="2304"><span class="lineNum">    2304 </span>            : /*! Useful when adding a runtime library call to terminate the runtime system right before the end of a program, especially for OpenMP and UPC runtime systems. Return with complex expressions with side effects are rewritten using an additional assignment statement.</a>
<a name="2305"><span class="lineNum">    2305 </span>            :  */</a>
<a name="2306"><span class="lineNum">    2306 </span>            : ROSE_DLL_API int instrumentEndOfFunction(SgFunctionDeclaration * func, SgStatement* s);</a>
<a name="2307"><span class="lineNum">    2307 </span>            : </a>
<a name="2308"><span class="lineNum">    2308 </span>            : //! Remove jumps whose label is immediately after the jump.  Used to clean up inlined code fragments.</a>
<a name="2309"><span class="lineNum">    2309 </span>            : ROSE_DLL_API void removeJumpsToNextStatement(SgNode*);</a>
<a name="2310"><span class="lineNum">    2310 </span>            : </a>
<a name="2311"><span class="lineNum">    2311 </span>            : //! Remove labels which are not targets of any goto statements: its child statement is also removed by default.</a>
<a name="2312"><span class="lineNum">    2312 </span>            : ROSE_DLL_API void removeUnusedLabels(SgNode* top, bool keepChild =false);</a>
<a name="2313"><span class="lineNum">    2313 </span>            : </a>
<a name="2314"><span class="lineNum">    2314 </span>            : //! Find unused labels which are not targets of any goto statements</a>
<a name="2315"><span class="lineNum">    2315 </span>            : ROSE_DLL_API std::set&lt;SgLabelStatement*&gt; findUnusedLabels (SgNode* top);</a>
<a name="2316"><span class="lineNum">    2316 </span>            : </a>
<a name="2317"><span class="lineNum">    2317 </span>            : //! Remove consecutive labels</a>
<a name="2318"><span class="lineNum">    2318 </span>            : ROSE_DLL_API void removeConsecutiveLabels(SgNode* top);</a>
<a name="2319"><span class="lineNum">    2319 </span>            : </a>
<a name="2320"><span class="lineNum">    2320 </span>            : //! Merge a variable assignment statement into a matching variable declaration statement. Callers should make sure the merge is semantically correct (by not introducing compilation errors). This function simply does the merge transformation, without eligibility check.</a>
<a name="2321"><span class="lineNum">    2321 </span>            : /*!</a>
<a name="2322"><span class="lineNum">    2322 </span>            :  *  e.g.  int i;  i=10;  becomes int i=10;  the original i=10 will be deleted after the merge</a>
<a name="2323"><span class="lineNum">    2323 </span>            :  *  if success, return true, otherwise return false (e.g. variable declaration does not match or already has an initializer)</a>
<a name="2324"><span class="lineNum">    2324 </span>            :  *  The original assignment stmt will be removed by default</a>
<a name="2325"><span class="lineNum">    2325 </span>            :  *  This function is a bit ambiguous about the merge direction, to be phased out.</a>
<a name="2326"><span class="lineNum">    2326 </span>            :  */</a>
<a name="2327"><span class="lineNum">    2327 </span>            : ROSE_DLL_API bool mergeDeclarationAndAssignment (SgVariableDeclaration* decl, SgExprStatement* assign_stmt, bool removeAssignStmt = true);</a>
<a name="2328"><span class="lineNum">    2328 </span>            : </a>
<a name="2329"><span class="lineNum">    2329 </span>            : </a>
<a name="2330"><span class="lineNum">    2330 </span>            : //! Merge an assignment into its upstream declaration statement. Callers should make sure the merge is semantically correct.</a>
<a name="2331"><span class="lineNum">    2331 </span>            : ROSE_DLL_API bool mergeAssignmentWithDeclaration (SgExprStatement* assign_stmt, SgVariableDeclaration* decl, bool removeAssignStmt = true);</a>
<a name="2332"><span class="lineNum">    2332 </span>            : </a>
<a name="2333"><span class="lineNum">    2333 </span>            : //! Merge a declaration statement into a matching followed variable assignment. Callers should make sure the merge is semantically correct (by not introducing compilation errors). This function simply does the merge transformation, without eligibility check.</a>
<a name="2334"><span class="lineNum">    2334 </span>            : /*!</a>
<a name="2335"><span class="lineNum">    2335 </span>            :  *  e.g.  int i;  i=10;  becomes int i=10;  the original int i; will be deleted after the merge</a>
<a name="2336"><span class="lineNum">    2336 </span>            :  */</a>
<a name="2337"><span class="lineNum">    2337 </span>            : ROSE_DLL_API bool mergeDeclarationWithAssignment (SgVariableDeclaration* decl, SgExprStatement* assign_stmt);</a>
<a name="2338"><span class="lineNum">    2338 </span>            : </a>
<a name="2339"><span class="lineNum">    2339 </span>            : //! Split a variable declaration with an rhs assignment into two statements: a declaration and an assignment.</a>
<a name="2340"><span class="lineNum">    2340 </span>            : /*! Return the generated assignment statement, if any</a>
<a name="2341"><span class="lineNum">    2341 </span>            :  *  e.g.  int i =10;  becomes int i; i=10;</a>
<a name="2342"><span class="lineNum">    2342 </span>            :  *  This can be seen as a normalization of declarations</a>
<a name="2343"><span class="lineNum">    2343 </span>            :  */</a>
<a name="2344"><span class="lineNum">    2344 </span>            : ROSE_DLL_API SgExprStatement* splitVariableDeclaration (SgVariableDeclaration* decl);</a>
<a name="2345"><span class="lineNum">    2345 </span>            : </a>
<a name="2346"><span class="lineNum">    2346 </span>            : //! Split declarations within a scope into declarations and assignment statements, by default only top level declarations are considered. Return the number of declarations split.</a>
<a name="2347"><span class="lineNum">    2347 </span>            : ROSE_DLL_API int splitVariableDeclaration (SgScopeStatement* scope, bool topLevelOnly = true);</a>
<a name="2348"><span class="lineNum">    2348 </span>            : </a>
<a name="2349"><span class="lineNum">    2349 </span>            : //! Replace an expression with a temporary variable and an assignment statement</a>
<a name="2350"><span class="lineNum">    2350 </span>            : /*!</a>
<a name="2351"><span class="lineNum">    2351 </span>            :  Add a new temporary variable to contain the value of 'from'.</a>
<a name="2352"><span class="lineNum">    2352 </span>            :  Change reference to 'from' to use this new variable.</a>
<a name="2353"><span class="lineNum">    2353 </span>            :  Assumptions: (1)'from' is not within the test of a loop or 'if';</a>
<a name="2354"><span class="lineNum">    2354 </span>            :               (2)not currently traversing 'from' or the statement it is in.</a>
<a name="2355"><span class="lineNum">    2355 </span>            :  Return value: the new temp variable declaration's assign initializer containing the from expression.</a>
<a name="2356"><span class="lineNum">    2356 </span>            :  */</a>
<a name="2357"><span class="lineNum">    2357 </span>            :  ROSE_DLL_API SgAssignInitializer* splitExpression(SgExpression* from, std::string newName = &quot;&quot;);</a>
<a name="2358"><span class="lineNum">    2358 </span>            : </a>
<a name="2359"><span class="lineNum">    2359 </span>            : //! Split long expressions into blocks of statements</a>
<a name="2360"><span class="lineNum">    2360 </span>            : ROSE_DLL_API void splitExpressionIntoBasicBlock(SgExpression* expr);</a>
<a name="2361"><span class="lineNum">    2361 </span>            : </a>
<a name="2362"><span class="lineNum">    2362 </span>            : //! Remove labeled goto statements</a>
<a name="2363"><span class="lineNum">    2363 </span>            : ROSE_DLL_API void removeLabeledGotos(SgNode* top);</a>
<a name="2364"><span class="lineNum">    2364 </span>            : </a>
<a name="2365"><span class="lineNum">    2365 </span>            : //! If the given statement contains any break statements in its body, add a new label below the statement and change the breaks into gotos to that new label.</a>
<a name="2366"><span class="lineNum">    2366 </span>            : ROSE_DLL_API void changeBreakStatementsToGotos(SgStatement* loopOrSwitch);</a>
<a name="2367"><span class="lineNum">    2367 </span>            : </a>
<a name="2368"><span class="lineNum">    2368 </span>            : //! Check if the body of a 'for' statement is a SgBasicBlock, create one if not.</a>
<a name="2369"><span class="lineNum">    2369 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfFor(SgForStatement* fs);</a>
<a name="2370"><span class="lineNum">    2370 </span>            : </a>
<a name="2371"><span class="lineNum">    2371 </span>            : //! Check if the body of a 'upc_forall' statement is a SgBasicBlock, create one if not.</a>
<a name="2372"><span class="lineNum">    2372 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfUpcForAll(SgUpcForAllStatement* fs);</a>
<a name="2373"><span class="lineNum">    2373 </span>            : </a>
<a name="2374"><span class="lineNum">    2374 </span>            : //! Check if the body of a 'while' statement is a SgBasicBlock, create one if not.</a>
<a name="2375"><span class="lineNum">    2375 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfWhile(SgWhileStmt* ws);</a>
<a name="2376"><span class="lineNum">    2376 </span>            : </a>
<a name="2377"><span class="lineNum">    2377 </span>            : //! Check if the body of a 'do .. while' statement is a SgBasicBlock, create one if not.</a>
<a name="2378"><span class="lineNum">    2378 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfDoWhile(SgDoWhileStmt* ws);</a>
<a name="2379"><span class="lineNum">    2379 </span>            : </a>
<a name="2380"><span class="lineNum">    2380 </span>            : //! Check if the body of a 'switch' statement is a SgBasicBlock, create one if not.</a>
<a name="2381"><span class="lineNum">    2381 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfSwitch(SgSwitchStatement* ws);</a>
<a name="2382"><span class="lineNum">    2382 </span>            : </a>
<a name="2383"><span class="lineNum">    2383 </span>            : //! Check if the body of a 'case option' statement is a SgBasicBlock, create one if not.</a>
<a name="2384"><span class="lineNum">    2384 </span>            : SgBasicBlock* ensureBasicBlockAsBodyOfCaseOption(SgCaseOptionStmt* cs);</a>
<a name="2385"><span class="lineNum">    2385 </span>            : </a>
<a name="2386"><span class="lineNum">    2386 </span>            : //! Check if the body of a 'default option' statement is a SgBasicBlock, create one if not.</a>
<a name="2387"><span class="lineNum">    2387 </span>            : SgBasicBlock* ensureBasicBlockAsBodyOfDefaultOption(SgDefaultOptionStmt * cs);</a>
<a name="2388"><span class="lineNum">    2388 </span>            : </a>
<a name="2389"><span class="lineNum">    2389 </span>            : //! Check if the true body of a 'if' statement is a SgBasicBlock, create one if not.</a>
<a name="2390"><span class="lineNum">    2390 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsTrueBodyOfIf(SgIfStmt* ifs);</a>
<a name="2391"><span class="lineNum">    2391 </span>            : </a>
<a name="2392"><span class="lineNum">    2392 </span>            : //! Check if the false body of a 'if' statement is a SgBasicBlock, create one if not when the flag is true.</a>
<a name="2393"><span class="lineNum">    2393 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsFalseBodyOfIf(SgIfStmt* ifs, bool createEmptyBody = true);</a>
<a name="2394"><span class="lineNum">    2394 </span>            : </a>
<a name="2395"><span class="lineNum">    2395 </span>            : //! Check if the body of a 'catch' statement is a SgBasicBlock, create one if not.</a>
<a name="2396"><span class="lineNum">    2396 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfCatch(SgCatchOptionStmt* cos);</a>
<a name="2397"><span class="lineNum">    2397 </span>            : </a>
<a name="2398"><span class="lineNum">    2398 </span>            : //! Check if the body of a SgUpirBodyStatement is a SgBasicBlock, create one if not</a>
<a name="2399"><span class="lineNum">    2399 </span>            : ROSE_DLL_API SgBasicBlock* ensureBasicBlockAsBodyOfOmpBodyStmt(SgUpirBodyStatement* ompbodyStmt);</a>
<a name="2400"><span class="lineNum">    2400 </span>            : </a>
<a name="2401"><span class="lineNum">    2401 </span>            : // DQ (1/18/2015): This is added to support better quality token-based unparsing.</a>
<a name="2402"><span class="lineNum">    2402 </span>            : //! Remove unused basic block IR nodes added as part of normalization.</a>
<a name="2403"><span class="lineNum">    2403 </span>            : ROSE_DLL_API void cleanupNontransformedBasicBlockNode();</a>
<a name="2404"><span class="lineNum">    2404 </span>            : </a>
<a name="2405"><span class="lineNum">    2405 </span>            : // DQ (1/18/2015): This is added to support better quality token-based unparsing.</a>
<a name="2406"><span class="lineNum">    2406 </span>            : //! Record where normalization have been done so that we can preform denormalizations as required for the token-based unparsing to generate minimal diffs.</a>
<a name="2407"><span class="lineNum">    2407 </span>            : ROSE_DLL_API void recordNormalizations(SgStatement* s);</a>
<a name="2408"><span class="lineNum">    2408 </span>            : </a>
<a name="2409"><span class="lineNum">    2409 </span>            : //! Check if a statement is a (true or false) body of a container-like parent, such as For, Upc_forall, Do-while,</a>
<a name="2410"><span class="lineNum">    2410 </span>            : //! switch, If, Catch, OmpBodyStmt, etc</a>
<a name="2411"><span class="lineNum">    2411 </span>            : bool isBodyStatement (SgStatement* s);</a>
<a name="2412"><span class="lineNum">    2412 </span>            : </a>
<a name="2413"><span class="lineNum">    2413 </span>            : //! Fix up ifs, loops, while, switch, Catch, UpirBodyStatement, etc. to have blocks as body components. It also adds an empty else body to if statements that don't have them.</a>
<a name="2414"><span class="lineNum">    2414 </span>            : void changeAllBodiesToBlocks(SgNode* top, bool createEmptyBody = true);</a>
<a name="2415"><span class="lineNum">    2415 </span>            : </a>
<a name="2416"><span class="lineNum">    2416 </span>            : // The same as changeAllBodiesToBlocks(SgNode* top). Phased out.</a>
<a name="2417"><span class="lineNum">    2417 </span>            : //void changeAllLoopBodiesToBlocks(SgNode* top);</a>
<a name="2418"><span class="lineNum">    2418 </span>            : </a>
<a name="2419"><span class="lineNum">    2419 </span>            : //! Make a single statement body to be a basic block. Its parent is if, while, catch, or upc_forall etc.</a>
<a name="2420"><span class="lineNum">    2420 </span>            : SgBasicBlock * makeSingleStatementBodyToBlock(SgStatement* singleStmt);</a>
<a name="2421"><span class="lineNum">    2421 </span>            : </a>
<a name="2422"><span class="lineNum">    2422 </span>            : #if 0</a>
<a name="2423"><span class="lineNum">    2423 </span>            : /**  If s is the body of a loop, catch, or if statement and is already a basic block,</a>
<a name="2424"><span class="lineNum">    2424 </span>            :  *   s is returned unmodified. Otherwise generate a SgBasicBlock between s and its parent</a>
<a name="2425"><span class="lineNum">    2425 </span>            :  *   (a loop, catch, or if statement, etc). */</a>
<a name="2426"><span class="lineNum">    2426 </span>            : SgLocatedNode* ensureBasicBlockAsParent(SgStatement* s);</a>
<a name="2427"><span class="lineNum">    2427 </span>            : #endif</a>
<a name="2428"><span class="lineNum">    2428 </span>            : </a>
<a name="2429"><span class="lineNum">    2429 </span>            : //! Get the constant value from a constant integer expression; abort on</a>
<a name="2430"><span class="lineNum">    2430 </span>            : //! everything else.  Note that signed long longs are converted to unsigned.</a>
<a name="2431"><span class="lineNum">    2431 </span>            : unsigned long long getIntegerConstantValue(SgValueExp* expr);</a>
<a name="2432"><span class="lineNum">    2432 </span>            : </a>
<a name="2433"><span class="lineNum">    2433 </span>            : //! Get a statement's dependent declarations which declares the types used in the statement. The returned vector of declaration statements are sorted according to their appearance order in the original AST. Any reference to a class or template class from a namespace will treated as a reference to the enclosing namespace.</a>
<a name="2434"><span class="lineNum">    2434 </span>            : std::vector&lt;SgDeclarationStatement*&gt; getDependentDeclarations (SgStatement* stmt );</a>
<a name="2435"><span class="lineNum">    2435 </span>            : </a>
<a name="2436"><span class="lineNum">    2436 </span>            : </a>
<a name="2437"><span class="lineNum">    2437 </span>            : //! Insert an expression (new_exp )before another expression (anchor_exp) has possible side effects, without changing the original semantics. This is achieved by using a comma operator: (new_exp, anchor_exp). The comma operator is returned.</a>
<a name="2438"><span class="lineNum">    2438 </span>            : SgCommaOpExp *insertBeforeUsingCommaOp (SgExpression* new_exp, SgExpression* anchor_exp);</a>
<a name="2439"><span class="lineNum">    2439 </span>            : </a>
<a name="2440"><span class="lineNum">    2440 </span>            : //! Insert an expression (new_exp ) after another expression (anchor_exp) has possible side effects, without changing the original semantics. This is done by using two comma operators:  type T1; ... ((T1 = anchor_exp, new_exp),T1) )... , where T1 is a temp variable saving the possible side effect of anchor_exp. The top level comma op exp is returned. The reference to T1 in T1 = anchor_exp is saved in temp_ref.</a>
<a name="2441"><span class="lineNum">    2441 </span>            : SgCommaOpExp *insertAfterUsingCommaOp (SgExpression* new_exp, SgExpression* anchor_exp, SgStatement** temp_decl = NULL, SgVarRefExp** temp_ref = NULL);</a>
<a name="2442"><span class="lineNum">    2442 </span>            : </a>
<a name="2443"><span class="lineNum">    2443 </span>            : </a>
<a name="2444"><span class="lineNum">    2444 </span>            : /// \brief   moves the body of a function f to a new function f`;</a>
<a name="2445"><span class="lineNum">    2445 </span>            : ///          f's body is replaced with code that forwards the call to f`.</a>
<a name="2446"><span class="lineNum">    2446 </span>            : /// \return  a pair indicating the statement containing the call of f`</a>
<a name="2447"><span class="lineNum">    2447 </span>            : ///          and an initialized name refering to the temporary variable</a>
<a name="2448"><span class="lineNum">    2448 </span>            : ///          holding the result of f`. In case f returns void</a>
<a name="2449"><span class="lineNum">    2449 </span>            : ///          the initialized name is NULL.</a>
<a name="2450"><span class="lineNum">    2450 </span>            : /// \param   definingDeclaration the defining function declaration of f</a>
<a name="2451"><span class="lineNum">    2451 </span>            : /// \param   newName the name of function f`</a>
<a name="2452"><span class="lineNum">    2452 </span>            : /// \details f's new body becomes { f`(...); } and { int res = f`(...); return res; }</a>
<a name="2453"><span class="lineNum">    2453 </span>            : ///          for functions returning void and a value, respectively.</a>
<a name="2454"><span class="lineNum">    2454 </span>            : ///          two function declarations are inserted in f's enclosing scope</a>
<a name="2455"><span class="lineNum">    2455 </span>            : /// \code</a>
<a name="2456"><span class="lineNum">    2456 </span>            : ///          result_type f`(...);                       &lt;--- (1)</a>
<a name="2457"><span class="lineNum">    2457 </span>            : ///          result_type f (...) { forward call to f` }</a>
<a name="2458"><span class="lineNum">    2458 </span>            : ///          result_type f`(...) { original code }      &lt;--- (2)</a>
<a name="2459"><span class="lineNum">    2459 </span>            : /// \endcode</a>
<a name="2460"><span class="lineNum">    2460 </span>            : ///          Calls to f are not updated, thus in the transformed code all</a>
<a name="2461"><span class="lineNum">    2461 </span>            : ///          calls will continue calling f (this is also true for</a>
<a name="2462"><span class="lineNum">    2462 </span>            : ///          recursive function calls from within the body of f`).</a>
<a name="2463"><span class="lineNum">    2463 </span>            : ///          After the function has created the wrapper,</a>
<a name="2464"><span class="lineNum">    2464 </span>            : ///          definingDeclaration becomes the wrapper function</a>
<a name="2465"><span class="lineNum">    2465 </span>            : ///          The definition of f` is the next entry in the</a>
<a name="2466"><span class="lineNum">    2466 </span>            : ///          statement list; the forward declaration of f` is the previous</a>
<a name="2467"><span class="lineNum">    2467 </span>            : ///          entry in the statement list.</a>
<a name="2468"><span class="lineNum">    2468 </span>            : /// \pre     definingDeclaration must be a defining declaration of a</a>
<a name="2469"><span class="lineNum">    2469 </span>            : ///          free standing function.</a>
<a name="2470"><span class="lineNum">    2470 </span>            : ///          typeid(SgFunctionDeclaration) == typeid(definingDeclaration)</a>
<a name="2471"><span class="lineNum">    2471 </span>            : ///          i.e., this function is NOT implemented for class member functions,</a>
<a name="2472"><span class="lineNum">    2472 </span>            : ///          template functions, procedures, etc.</a>
<a name="2473"><span class="lineNum">    2473 </span>            : std::pair&lt;SgStatement*, SgInitializedName*&gt;</a>
<a name="2474"><span class="lineNum">    2474 </span>            : wrapFunction(SgFunctionDeclaration&amp; definingDeclaration, SgName newName);</a>
<a name="2475"><span class="lineNum">    2475 </span>            : </a>
<a name="2476"><span class="lineNum">    2476 </span>            : /// \overload</a>
<a name="2477"><span class="lineNum">    2477 </span>            : /// \tparam  NameGen functor that generates a new name based on the old name.</a>
<a name="2478"><span class="lineNum">    2478 </span>            : ///          interface: SgName nameGen(const SgName&amp;)</a>
<a name="2479"><span class="lineNum">    2479 </span>            : /// \param   nameGen name generator</a>
<a name="2480"><span class="lineNum">    2480 </span>            : /// \brief   see wrapFunction for details</a>
<a name="2481"><span class="lineNum">    2481 </span>            : template &lt;class NameGen&gt;</a>
<a name="2482"><span class="lineNum">    2482 </span>            : std::pair&lt;SgStatement*, SgInitializedName*&gt;</a>
<a name="2483"><span class="lineNum">    2483 </span>            : wrapFunction(SgFunctionDeclaration&amp; definingDeclaration, NameGen nameGen)</a>
<a name="2484"><span class="lineNum">    2484 </span>            : {</a>
<a name="2485"><span class="lineNum">    2485 </span>            :   return wrapFunction(definingDeclaration, nameGen(definingDeclaration.get_name()));</a>
<a name="2486"><span class="lineNum">    2486 </span>            : }</a>
<a name="2487"><span class="lineNum">    2487 </span>            : </a>
<a name="2488"><span class="lineNum">    2488 </span>            : /// \brief convenience function that returns the first initialized name in a</a>
<a name="2489"><span class="lineNum">    2489 </span>            : ///        list of variable declarations.</a>
<a name="2490"><span class="lineNum">    2490 </span>            : SgInitializedName&amp; getFirstVariable(SgVariableDeclaration&amp; vardecl);</a>
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<a name="2492"><span class="lineNum">    2492 </span>            : </a>
<a name="2493"><span class="lineNum">    2493 </span>            : //@}</a>
<a name="2494"><span class="lineNum">    2494 </span>            : </a>
<a name="2495"><span class="lineNum">    2495 </span>            : // DQ (6/7/2012): Unclear where this function should go...</a>
<a name="2496"><span class="lineNum">    2496 </span>            :   bool hasTemplateSyntax( const SgName &amp; name );</a>
<a name="2497"><span class="lineNum">    2497 </span>            : </a>
<a name="2498"><span class="lineNum">    2498 </span>            : #if 0</a>
<a name="2499"><span class="lineNum">    2499 </span>            : </a>
<a name="2500"><span class="lineNum">    2500 </span>            : //------------------------AST dump, stringify-----------------------------</a>
<a name="2501"><span class="lineNum">    2501 </span>            : //------------------------------------------------------------------------</a>
<a name="2502"><span class="lineNum">    2502 </span>            :   std::string buildOperatorString ( SgNode* astNode ); //transformationSupport.h</a>
<a name="2503"><span class="lineNum">    2503 </span>            : </a>
<a name="2504"><span class="lineNum">    2504 </span>            :   // do we need these?</a>
<a name="2505"><span class="lineNum">    2505 </span>            :   std::string dump_node(const SgNode* astNode);</a>
<a name="2506"><span class="lineNum">    2506 </span>            :   std::string dump_tree(const SgNode* astNode);</a>
<a name="2507"><span class="lineNum">    2507 </span>            : </a>
<a name="2508"><span class="lineNum">    2508 </span>            :   // or a friendly version of  unparseToString(), as a memeber function</a>
<a name="2509"><span class="lineNum">    2509 </span>            :   std::string SgNode::toString(bool asSubTree=true); // dump node or subtree</a>
<a name="2510"><span class="lineNum">    2510 </span>            : </a>
<a name="2511"><span class="lineNum">    2511 </span>            : //----------------------------AST comparison------------------------------</a>
<a name="2512"><span class="lineNum">    2512 </span>            : //------------------------------------------------------------------------</a>
<a name="2513"><span class="lineNum">    2513 </span>            : // How to get generic functions for comparison?</a>
<a name="2514"><span class="lineNum">    2514 </span>            :   bool isNodeEqual(SgNode* node1, SgNode* node2); //?</a>
<a name="2515"><span class="lineNum">    2515 </span>            :   bool isTreeEqual(SgNode* tree1, SgNode* tree2);</a>
<a name="2516"><span class="lineNum">    2516 </span>            : </a>
<a name="2517"><span class="lineNum">    2517 </span>            :         //! Are two expressions equal (using a deep comparison)?</a>
<a name="2518"><span class="lineNum">    2518 </span>            :   bool expressionTreeEqual(SgExpression*, SgExpression*);</a>
<a name="2519"><span class="lineNum">    2519 </span>            :         //! Are corresponding expressions in two lists equal (using a deep comparison)?</a>
<a name="2520"><span class="lineNum">    2520 </span>            :   bool expressionTreeEqualStar(const SgExpressionPtrList&amp;,</a>
<a name="2521"><span class="lineNum">    2521 </span>            :                              const SgExpressionPtrList&amp;);</a>
<a name="2522"><span class="lineNum">    2522 </span>            : </a>
<a name="2523"><span class="lineNum">    2523 </span>            : //----------------------AST verfication/repair----------------------------</a>
<a name="2524"><span class="lineNum">    2524 </span>            : //------------------------------------------------------------------------</a>
<a name="2525"><span class="lineNum">    2525 </span>            : // sanity check of AST subtree, any suggestions?</a>
<a name="2526"><span class="lineNum">    2526 </span>            : //  TODO</a>
<a name="2527"><span class="lineNum">    2527 </span>            :     verifySgNode(SgNode* node, bool subTree=true);</a>
<a name="2528"><span class="lineNum">    2528 </span>            :   //src/midend/astDiagnostics/AstConsistencyTests.h</a>
<a name="2529"><span class="lineNum">    2529 </span>            :   // AstTests::runAllTests(SgProject * )</a>
<a name="2530"><span class="lineNum">    2530 </span>            : </a>
<a name="2531"><span class="lineNum">    2531 </span>            :   //src/midend/astUtil/astInterface/AstInterface.h.C</a>
<a name="2532"><span class="lineNum">    2532 </span>            :   //FixSgProject(SgProject &amp;project)</a>
<a name="2533"><span class="lineNum">    2533 </span>            :   //FixSgTree(SgNode* r)</a>
<a name="2534"><span class="lineNum">    2534 </span>            : </a>
<a name="2535"><span class="lineNum">    2535 </span>            :   //src/frontend/SageIII/astPostProcessing</a>
<a name="2536"><span class="lineNum">    2536 </span>            :   //AstPostProcessing(SgNode * node)</a>
<a name="2537"><span class="lineNum">    2537 </span>            : </a>
<a name="2538"><span class="lineNum">    2538 </span>            : //--------------------------AST modification------------------------------</a>
<a name="2539"><span class="lineNum">    2539 </span>            : //------------------------------------------------------------------------</a>
<a name="2540"><span class="lineNum">    2540 </span>            : // any operations changing AST tree, including</a>
<a name="2541"><span class="lineNum">    2541 </span>            : // insert, copy, delete(remove), replace</a>
<a name="2542"><span class="lineNum">    2542 </span>            : </a>
<a name="2543"><span class="lineNum">    2543 </span>            :   // insert before or after some point, argument list is consistent with LowLevelRewrite</a>
<a name="2544"><span class="lineNum">    2544 </span>            :   void insertAst(SgNode* targetPosition, SgNode* newNode, bool insertBefore=true);</a>
<a name="2545"><span class="lineNum">    2545 </span>            : </a>
<a name="2546"><span class="lineNum">    2546 </span>            :   // previous examples</a>
<a name="2547"><span class="lineNum">    2547 </span>            :   //void myStatementInsert(SgStatement* target,...)</a>
<a name="2548"><span class="lineNum">    2548 </span>            :   // void AstInterfaceBase::InsertStmt(AstNodePtr const &amp; orig, AstNodePtr const &amp;n, bool insertbefore, bool extractfromBasicBlock)</a>
<a name="2549"><span class="lineNum">    2549 </span>            : </a>
<a name="2550"><span class="lineNum">    2550 </span>            :   // copy</a>
<a name="2551"><span class="lineNum">    2551 </span>            :   // copy children of one basic block to another basic block</a>
<a name="2552"><span class="lineNum">    2552 </span>            :   //void appendStatementCopy (const SgBasicBlock* a, SgBasicBlock* b);</a>
<a name="2553"><span class="lineNum">    2553 </span>            :   void copyStatements (const SgBasicBlock* src, SgBasicBlock* dst);</a>
<a name="2554"><span class="lineNum">    2554 </span>            : </a>
<a name="2555"><span class="lineNum">    2555 </span>            :   // delete (remove) a node or a whole subtree</a>
<a name="2556"><span class="lineNum">    2556 </span>            :   void removeSgNode(SgNode* targetNode); // need this?</a>
<a name="2557"><span class="lineNum">    2557 </span>            :   void removeSgNodeTree(SgNode* subtree); // need this?</a>
<a name="2558"><span class="lineNum">    2558 </span>            : </a>
<a name="2559"><span class="lineNum">    2559 </span>            :   void removeStatement( SgStatement* targetStmt);</a>
<a name="2560"><span class="lineNum">    2560 </span>            : </a>
<a name="2561"><span class="lineNum">    2561 </span>            :   //Move = delete + insert</a>
<a name="2562"><span class="lineNum">    2562 </span>            :   void moveAst (SgNode* src, SgNode* target); // need this?</a>
<a name="2563"><span class="lineNum">    2563 </span>            :       // similar to</a>
<a name="2564"><span class="lineNum">    2564 </span>            :   void moveStatements (SgBasicBlock* src, SgBasicBlock* target);</a>
<a name="2565"><span class="lineNum">    2565 </span>            : </a>
<a name="2566"><span class="lineNum">    2566 </span>            :   // replace= delete old + insert new (via building or copying)</a>
<a name="2567"><span class="lineNum">    2567 </span>            : </a>
<a name="2568"><span class="lineNum">    2568 </span>            : // DQ (1/25/2010): This does not appear to exist as a definition anywhere in ROSE.</a>
<a name="2569"><span class="lineNum">    2569 </span>            : // void replaceAst(SgNode* oldNode, SgNode* newNode);</a>
<a name="2570"><span class="lineNum">    2570 </span>            : </a>
<a name="2571"><span class="lineNum">    2571 </span>            :    //void replaceChild(SgNode* parent, SgNode* from, SgNode* to);</a>
<a name="2572"><span class="lineNum">    2572 </span>            :    //bool AstInterface::ReplaceAst( const AstNodePtr&amp; orig, const AstNodePtr&amp; n)</a>
<a name="2573"><span class="lineNum">    2573 </span>            : </a>
<a name="2574"><span class="lineNum">    2574 </span>            : //--------------------------AST transformations---------------------------</a>
<a name="2575"><span class="lineNum">    2575 </span>            : //------------------------------------------------------------------------</a>
<a name="2576"><span class="lineNum">    2576 </span>            : // Advanced AST modifications through basic AST modifications</a>
<a name="2577"><span class="lineNum">    2577 </span>            : // Might not be included in AST utitlity list, but listed here for the record.</a>
<a name="2578"><span class="lineNum">    2578 </span>            : </a>
<a name="2579"><span class="lineNum">    2579 </span>            :   // extract statements/content from a scope</a>
<a name="2580"><span class="lineNum">    2580 </span>            :   void flattenBlocks(SgNode* n);</a>
<a name="2581"><span class="lineNum">    2581 </span>            : </a>
<a name="2582"><span class="lineNum">    2582 </span>            :   //src/midend/astInlining/inlinerSupport.h</a>
<a name="2583"><span class="lineNum">    2583 </span>            :   void renameVariables(SgNode* n);</a>
<a name="2584"><span class="lineNum">    2584 </span>            :   void renameLabels(SgNode* n, SgFunctionDefinition* enclosingFunctionDefinition);</a>
<a name="2585"><span class="lineNum">    2585 </span>            : </a>
<a name="2586"><span class="lineNum">    2586 </span>            :   void simpleCopyAndConstantPropagation(SgNode* top);</a>
<a name="2587"><span class="lineNum">    2587 </span>            :   void changeAllMembersToPublic(SgNode* n);</a>
<a name="2588"><span class="lineNum">    2588 </span>            : </a>
<a name="2589"><span class="lineNum">    2589 </span>            :   void removeVariableDeclaration(SgInitializedName* initname);</a>
<a name="2590"><span class="lineNum">    2590 </span>            : </a>
<a name="2591"><span class="lineNum">    2591 </span>            :   //! Convert something like &quot;int a = foo();&quot; into &quot;int a; a = foo();&quot;</a>
<a name="2592"><span class="lineNum">    2592 </span>            :   SgAssignOp* convertInitializerIntoAssignment(SgAssignInitializer* init);</a>
<a name="2593"><span class="lineNum">    2593 </span>            : </a>
<a name="2594"><span class="lineNum">    2594 </span>            :   //! Rewrites a while or for loop so that the official test is changed to</a>
<a name="2595"><span class="lineNum">    2595 </span>            :   //! &quot;true&quot; and what had previously been the test is now an if-break</a>
<a name="2596"><span class="lineNum">    2596 </span>            :   //! combination (with an inverted condition) at the beginning of the loop</a>
<a name="2597"><span class="lineNum">    2597 </span>            :   //! body</a>
<a name="2598"><span class="lineNum">    2598 </span>            :   void pushTestIntoBody(LoopStatement* loopStmt);</a>
<a name="2599"><span class="lineNum">    2599 </span>            : </a>
<a name="2600"><span class="lineNum">    2600 </span>            :   //programTransformation/finiteDifferencing/finiteDifferencing.h</a>
<a name="2601"><span class="lineNum">    2601 </span>            :   //! Move variables declared in a for statement to just outside that statement.</a>
<a name="2602"><span class="lineNum">    2602 </span>            :   void moveForDeclaredVariables(SgNode* root);</a>
<a name="2603"><span class="lineNum">    2603 </span>            : </a>
<a name="2604"><span class="lineNum">    2604 </span>            : //------------------------ Is/Has functions ------------------------------</a>
<a name="2605"><span class="lineNum">    2605 </span>            : //------------------------------------------------------------------------</a>
<a name="2606"><span class="lineNum">    2606 </span>            : // misc. boolean functions</a>
<a name="2607"><span class="lineNum">    2607 </span>            : // some of them could moved to SgXXX class as a member function</a>
<a name="2608"><span class="lineNum">    2608 </span>            : </a>
<a name="2609"><span class="lineNum">    2609 </span>            :   bool isOverloaded (SgFunctionDeclaration * functionDeclaration);</a>
<a name="2610"><span class="lineNum">    2610 </span>            : </a>
<a name="2611"><span class="lineNum">    2611 </span>            :   bool isSwitchCond (const SgStatement* s);</a>
<a name="2612"><span class="lineNum">    2612 </span>            :   bool isIfCond (const SgStatement* s);</a>
<a name="2613"><span class="lineNum">    2613 </span>            :   bool isWhileCond (const SgStatement* s);</a>
<a name="2614"><span class="lineNum">    2614 </span>            :   bool isStdNamespace (const SgScopeStatement* scope);</a>
<a name="2615"><span class="lineNum">    2615 </span>            :   bool isTemplateInst (const SgDeclarationStatement* decl);</a>
<a name="2616"><span class="lineNum">    2616 </span>            : </a>
<a name="2617"><span class="lineNum">    2617 </span>            : </a>
<a name="2618"><span class="lineNum">    2618 </span>            :   bool isCtor (const SgFunctionDeclaration* func);</a>
<a name="2619"><span class="lineNum">    2619 </span>            :   bool isDtor (const SgFunctionDeclaration* func);</a>
<a name="2620"><span class="lineNum">    2620 </span>            : </a>
<a name="2621"><span class="lineNum">    2621 </span>            :    // src/midend/astInlining/typeTraits.h</a>
<a name="2622"><span class="lineNum">    2622 </span>            :   bool hasTrivialDestructor(SgType* t);</a>
<a name="2623"><span class="lineNum">    2623 </span>            :   ROSE_DLL_API bool isNonconstReference(SgType* t);</a>
<a name="2624"><span class="lineNum">    2624 </span>            :   ROSE_DLL_API bool isReferenceType(SgType* t);</a>
<a name="2625"><span class="lineNum">    2625 </span>            : </a>
<a name="2626"><span class="lineNum">    2626 </span>            :   //  generic ones, or move to the SgXXX class as a member function</a>
<a name="2627"><span class="lineNum">    2627 </span>            : </a>
<a name="2628"><span class="lineNum">    2628 </span>            :   bool isConst(SgNode* node); // const type, variable, function, etc.</a>
<a name="2629"><span class="lineNum">    2629 </span>            :   // .... and more</a>
<a name="2630"><span class="lineNum">    2630 </span>            : </a>
<a name="2631"><span class="lineNum">    2631 </span>            :   bool isConstType (const SgType* type);</a>
<a name="2632"><span class="lineNum">    2632 </span>            :   bool isConstFunction (const SgFunctionDeclaration* decl);</a>
<a name="2633"><span class="lineNum">    2633 </span>            : </a>
<a name="2634"><span class="lineNum">    2634 </span>            : </a>
<a name="2635"><span class="lineNum">    2635 </span>            :   bool isMemberVariable(const SgInitializedName &amp; var);</a>
<a name="2636"><span class="lineNum">    2636 </span>            :   //bool isMemberVariable(const SgNode&amp; in);</a>
<a name="2637"><span class="lineNum">    2637 </span>            : </a>
<a name="2638"><span class="lineNum">    2638 </span>            :   bool isPrototypeInScope (SgScopeStatement * scope,</a>
<a name="2639"><span class="lineNum">    2639 </span>            :                            SgFunctionDeclaration * functionDeclaration,</a>
<a name="2640"><span class="lineNum">    2640 </span>            :                            SgDeclarationStatement * startingAtDeclaration);</a>
<a name="2641"><span class="lineNum">    2641 </span>            : </a>
<a name="2642"><span class="lineNum">    2642 </span>            :   bool MayRedefined(SgExpression* expr, SgNode* root);</a>
<a name="2643"><span class="lineNum">    2643 </span>            :   // bool isPotentiallyModified(SgExpression* expr, SgNode* root); // inlinderSupport.h</a>
<a name="2644"><span class="lineNum">    2644 </span>            :   bool hasAddressTaken(SgExpression* expr, SgNode* root);</a>
<a name="2645"><span class="lineNum">    2645 </span>            : </a>
<a name="2646"><span class="lineNum">    2646 </span>            :   //src/midend/astInlining/inlinerSupport.C</a>
<a name="2647"><span class="lineNum">    2647 </span>            :      // can also classified as topdown search</a>
<a name="2648"><span class="lineNum">    2648 </span>            :   bool containsVariableReference(SgNode* root, SgInitializedName* var);</a>
<a name="2649"><span class="lineNum">    2649 </span>            : </a>
<a name="2650"><span class="lineNum">    2650 </span>            :   bool isDeclarationOf(SgVariableDeclaration* decl, SgInitializedName* var);</a>
<a name="2651"><span class="lineNum">    2651 </span>            :   bool isPotentiallyModifiedDuringLifeOf(SgBasicBlock* sc,</a>
<a name="2652"><span class="lineNum">    2652 </span>            :                                        SgInitializedName* toCheck,</a>
<a name="2653"><span class="lineNum">    2653 </span>            :                                        SgInitializedName* lifetime)</a>
<a name="2654"><span class="lineNum">    2654 </span>            :   //src/midend/programTransformation/partialRedundancyElimination/pre.h</a>
<a name="2655"><span class="lineNum">    2655 </span>            :   bool anyOfListPotentiallyModifiedIn(const std::vector&lt;SgVariableSymbol*&gt;&amp; syms, SgNode* n);</a>
<a name="2656"><span class="lineNum">    2656 </span>            : </a>
<a name="2657"><span class="lineNum">    2657 </span>            : //------------------------ loop handling ---------------------------------</a>
<a name="2658"><span class="lineNum">    2658 </span>            : //------------------------------------------------------------------------</a>
<a name="2659"><span class="lineNum">    2659 </span>            :   //get and set loop control expressions</a>
<a name="2660"><span class="lineNum">    2660 </span>            :   // 0: init expr, 1: condition expr, 2: stride expr</a>
<a name="2661"><span class="lineNum">    2661 </span>            : </a>
<a name="2662"><span class="lineNum">    2662 </span>            :   SgExpression* getForLoopTripleValues(int valuetype,SgForStatement* forstmt );</a>
<a name="2663"><span class="lineNum">    2663 </span>            :   int setForLoopTripleValues(int valuetype,SgForStatement* forstmt, SgExpression* exp);</a>
<a name="2664"><span class="lineNum">    2664 </span>            : </a>
<a name="2665"><span class="lineNum">    2665 </span>            :   bool isLoopIndexVarRef(SgForStatement* forstmt, SgVarRefExp *varref);</a>
<a name="2666"><span class="lineNum">    2666 </span>            :   SgInitializedName * getLoopIndexVar(SgForStatement* forstmt);</a>
<a name="2667"><span class="lineNum">    2667 </span>            : </a>
<a name="2668"><span class="lineNum">    2668 </span>            : //------------------------expressions-------------------------------------</a>
<a name="2669"><span class="lineNum">    2669 </span>            : //------------------------------------------------------------------------</a>
<a name="2670"><span class="lineNum">    2670 </span>            :   //src/midend/programTransformation/partialRedundancyElimination/pre.h</a>
<a name="2671"><span class="lineNum">    2671 </span>            :   int countComputationsOfExpressionIn(SgExpression* expr, SgNode* root);</a>
<a name="2672"><span class="lineNum">    2672 </span>            : </a>
<a name="2673"><span class="lineNum">    2673 </span>            :         //src/midend/astInlining/replaceExpressionWithStatement.h</a>
<a name="2674"><span class="lineNum">    2674 </span>            :   void replaceAssignmentStmtWithStatement(SgExprStatement* from, StatementGenerator* to);</a>
<a name="2675"><span class="lineNum">    2675 </span>            : </a>
<a name="2676"><span class="lineNum">    2676 </span>            :   void replaceSubexpressionWithStatement(SgExpression* from,</a>
<a name="2677"><span class="lineNum">    2677 </span>            :                                        StatementGenerator* to);</a>
<a name="2678"><span class="lineNum">    2678 </span>            :   SgExpression* getRootOfExpression(SgExpression* n);</a>
<a name="2679"><span class="lineNum">    2679 </span>            : </a>
<a name="2680"><span class="lineNum">    2680 </span>            : //--------------------------preprocessing info. -------------------------</a>
<a name="2681"><span class="lineNum">    2681 </span>            : //------------------------------------------------------------------------</a>
<a name="2682"><span class="lineNum">    2682 </span>            :   //! Removes all preprocessing information at a given position.</a>
<a name="2683"><span class="lineNum">    2683 </span>            :   void cutPreprocInfo (SgBasicBlock* b,</a>
<a name="2684"><span class="lineNum">    2684 </span>            :                        PreprocessingInfo::RelativePositionType pos,</a>
<a name="2685"><span class="lineNum">    2685 </span>            :                        AttachedPreprocessingInfoType&amp; save_buf);</a>
<a name="2686"><span class="lineNum">    2686 </span>            :   //! Pastes preprocessing information at the front of a statement.</a>
<a name="2687"><span class="lineNum">    2687 </span>            :   void pastePreprocInfoFront (AttachedPreprocessingInfoType&amp; save_buf,</a>
<a name="2688"><span class="lineNum">    2688 </span>            :                               SgStatement* s);</a>
<a name="2689"><span class="lineNum">    2689 </span>            :   //! Pastes preprocessing information at the back of a statement.</a>
<a name="2690"><span class="lineNum">    2690 </span>            :   void pastePreprocInfoBack (AttachedPreprocessingInfoType&amp; save_buf,</a>
<a name="2691"><span class="lineNum">    2691 </span>            :                              SgStatement* s);</a>
<a name="2692"><span class="lineNum">    2692 </span>            : </a>
<a name="2693"><span class="lineNum">    2693 </span>            :   /*!</a>
<a name="2694"><span class="lineNum">    2694 </span>            :    *  \brief Moves 'before' preprocessing information.</a>
<a name="2695"><span class="lineNum">    2695 </span>            :    *  Moves all preprocessing information attached 'before' the source</a>
<a name="2696"><span class="lineNum">    2696 </span>            :    *  statement to the front of the destination statement.</a>
<a name="2697"><span class="lineNum">    2697 </span>            :    */</a>
<a name="2698"><span class="lineNum">    2698 </span>            :   // a generic one for all</a>
<a name="2699"><span class="lineNum">    2699 </span>            :   /// void movePreprocessingInfo(src, dest, RelativePositionType);</a>
<a name="2700"><span class="lineNum">    2700 </span>            :   void moveBeforePreprocInfo (SgStatement* src, SgStatement* dest);</a>
<a name="2701"><span class="lineNum">    2701 </span>            :   void moveInsidePreprocInfo (SgBasicBlock* src, SgBasicBlock* dest);</a>
<a name="2702"><span class="lineNum">    2702 </span>            :   void moveAfterPreprocInfo (SgStatement* src, SgStatement* dest);</a>
<a name="2703"><span class="lineNum">    2703 </span>            : </a>
<a name="2704"><span class="lineNum">    2704 </span>            : //--------------------------------operator--------------------------------</a>
<a name="2705"><span class="lineNum">    2705 </span>            : //------------------------------------------------------------------------</a>
<a name="2706"><span class="lineNum">    2706 </span>            :   from transformationSupport.h, not sure if they should be included here</a>
<a name="2707"><span class="lineNum">    2707 </span>            :   /* return enum code for SAGE operators */</a>
<a name="2708"><span class="lineNum">    2708 </span>            :   operatorCodeType classifyOverloadedOperator(); // transformationSupport.h</a>
<a name="2709"><span class="lineNum">    2709 </span>            : </a>
<a name="2710"><span class="lineNum">    2710 </span>            :  /*! \brief generates a source code string from operator name.</a>
<a name="2711"><span class="lineNum">    2711 </span>            :     This function returns a string representing the elementwise operator (for primative types)</a>
<a name="2712"><span class="lineNum">    2712 </span>            :     that would be match that associated with the overloaded operator for a user-defined</a>
<a name="2713"><span class="lineNum">    2713 </span>            :     abstractions (e.g. identifyOperator(&quot;operator+()&quot;) returns &quot;+&quot;).</a>
<a name="2714"><span class="lineNum">    2714 </span>            :   */</a>
<a name="2715"><span class="lineNum">    2715 </span>            :   std::string stringifyOperator (std::string name);</a>
<a name="2716"><span class="lineNum">    2716 </span>            : </a>
<a name="2717"><span class="lineNum">    2717 </span>            : //--------------------------------macro ----------------------------------</a>
<a name="2718"><span class="lineNum">    2718 </span>            : //------------------------------------------------------------------------</a>
<a name="2719"><span class="lineNum">    2719 </span>            :   std::string buildMacro ( std::string s ); //transformationSupport.h</a>
<a name="2720"><span class="lineNum">    2720 </span>            : </a>
<a name="2721"><span class="lineNum">    2721 </span>            : //--------------------------------access functions---------------------------</a>
<a name="2722"><span class="lineNum">    2722 </span>            : //----------------------------------get/set sth.-----------------------------</a>
<a name="2723"><span class="lineNum">    2723 </span>            : // several categories:</a>
<a name="2724"><span class="lineNum">    2724 </span>            : * get/set a direct child/grandchild node or fields</a>
<a name="2725"><span class="lineNum">    2725 </span>            : * get/set a property flag value</a>
<a name="2726"><span class="lineNum">    2726 </span>            : * get a descendent child node using preorder searching</a>
<a name="2727"><span class="lineNum">    2727 </span>            : * get an ancestor node using bottomup/reverse searching</a>
<a name="2728"><span class="lineNum">    2728 </span>            : </a>
<a name="2729"><span class="lineNum">    2729 </span>            :         // SgName or string?</a>
<a name="2730"><span class="lineNum">    2730 </span>            :   std::string getFunctionName (SgFunctionCallExp* functionCallExp);</a>
<a name="2731"><span class="lineNum">    2731 </span>            :   std::string getFunctionTypeName ( SgFunctionCallExp* functionCallExpression );</a>
<a name="2732"><span class="lineNum">    2732 </span>            : </a>
<a name="2733"><span class="lineNum">    2733 </span>            :     // do we need them anymore? or existing member functions are enought?</a>
<a name="2734"><span class="lineNum">    2734 </span>            :     // a generic one:</a>
<a name="2735"><span class="lineNum">    2735 </span>            :    std::string get_name (const SgNode* node);</a>
<a name="2736"><span class="lineNum">    2736 </span>            :    std::string get_name (const SgDeclarationStatement * declaration);</a>
<a name="2737"><span class="lineNum">    2737 </span>            : </a>
<a name="2738"><span class="lineNum">    2738 </span>            :   // get/set some property: should moved to SgXXX as an inherent memeber function?</a>
<a name="2739"><span class="lineNum">    2739 </span>            :   // access modifier</a>
<a name="2740"><span class="lineNum">    2740 </span>            :   void  setExtern (SgFunctionDeclartion*)</a>
<a name="2741"><span class="lineNum">    2741 </span>            :   void  clearExtern()</a>
<a name="2742"><span class="lineNum">    2742 </span>            : </a>
<a name="2743"><span class="lineNum">    2743 </span>            :    // similarly for other declarations and other properties</a>
<a name="2744"><span class="lineNum">    2744 </span>            :   void setExtern (SgVariableDeclaration*)</a>
<a name="2745"><span class="lineNum">    2745 </span>            :   void setPublic()</a>
<a name="2746"><span class="lineNum">    2746 </span>            :   void setPrivate()</a>
<a name="2747"><span class="lineNum">    2747 </span>            : </a>
<a name="2748"><span class="lineNum">    2748 </span>            : #endif</a>
<a name="2749"><span class="lineNum">    2749 </span>            : </a>
<a name="2750"><span class="lineNum">    2750 </span>            : // DQ (1/23/2013): Added support for generated a set of source sequence entries.</a>
<a name="2751"><span class="lineNum">    2751 </span>            :    std::set&lt;unsigned int&gt; collectSourceSequenceNumbers( SgNode* astNode );</a>
<a name="2752"><span class="lineNum">    2752 </span>            : </a>
<a name="2753"><span class="lineNum">    2753 </span>            : //--------------------------------Type Traits (C++)---------------------------</a>
<a name="2754"><span class="lineNum">    2754 </span>            :       bool HasNoThrowAssign(const SgType * const inputType);</a>
<a name="2755"><span class="lineNum">    2755 </span>            :       bool HasNoThrowCopy(const SgType * const inputType);</a>
<a name="2756"><span class="lineNum">    2756 </span>            :       bool HasNoThrowConstructor(const SgType * const inputType);</a>
<a name="2757"><span class="lineNum">    2757 </span>            :       bool HasTrivialAssign(const SgType * const inputType);</a>
<a name="2758"><span class="lineNum">    2758 </span>            :       bool HasTrivialCopy(const SgType * const inputType);</a>
<a name="2759"><span class="lineNum">    2759 </span>            :       bool HasTrivialConstructor(const SgType * const inputType);</a>
<a name="2760"><span class="lineNum">    2760 </span>            :       bool HasTrivialDestructor(const SgType * const inputType);</a>
<a name="2761"><span class="lineNum">    2761 </span>            :       bool HasVirtualDestructor(const SgType * const inputType);</a>
<a name="2762"><span class="lineNum">    2762 </span>            :       bool IsBaseOf(const SgType * const inputBaseType, const SgType * const inputDerivedType);</a>
<a name="2763"><span class="lineNum">    2763 </span>            :       bool IsAbstract(const SgType * const inputType);</a>
<a name="2764"><span class="lineNum">    2764 </span>            :       //! strip off typedef and modifer types, then check if a type is a class type, excluding union type.</a>
<a name="2765"><span class="lineNum">    2765 </span>            :       bool IsClass(const SgType * const inputType);</a>
<a name="2766"><span class="lineNum">    2766 </span>            :       bool IsEmpty(const SgType * const inputType);</a>
<a name="2767"><span class="lineNum">    2767 </span>            :       bool IsEnum(const SgType * const inputType);</a>
<a name="2768"><span class="lineNum">    2768 </span>            :       bool IsPod(const SgType * const inputType);</a>
<a name="2769"><span class="lineNum">    2769 </span>            :       bool IsPolymorphic(const SgType * const inputType);</a>
<a name="2770"><span class="lineNum">    2770 </span>            :       bool IsStandardLayout(const SgType * const inputType);</a>
<a name="2771"><span class="lineNum">    2771 </span>            :       bool IsLiteralType(const SgType * const inputType);</a>
<a name="2772"><span class="lineNum">    2772 </span>            :       bool IsTrivial(const SgType * const inputType);</a>
<a name="2773"><span class="lineNum">    2773 </span>            :       bool IsUnion(const SgType * const inputType);</a>
<a name="2774"><span class="lineNum">    2774 </span>            :       SgType *  UnderlyingType(SgType *type);</a>
<a name="2775"><span class="lineNum">    2775 </span>            : </a>
<a name="2776"><span class="lineNum">    2776 </span>            : // DQ (3/2/2014): Added a new interface function (used in the snippet insertion support).</a>
<a name="2777"><span class="lineNum">    2777 </span>            : //   void supportForInitializedNameLists ( SgScopeStatement* scope, SgInitializedNamePtrList &amp; variableList );</a>
<a name="2778"><span class="lineNum">    2778 </span>            : </a>
<a name="2779"><span class="lineNum">    2779 </span>            : // DQ (3/4/2014): Added support for testing two trees for equivalents using the AST iterators.</a>
<a name="2780"><span class="lineNum">    2780 </span>            :    bool isStructurallyEquivalentAST( SgNode* tree1, SgNode* tree2 );</a>
<a name="2781"><span class="lineNum">    2781 </span>            : </a>
<a name="2782"><span class="lineNum">    2782 </span>            : // JP (10/14/24): Moved code to evaluate a const integer expression (like in array size definitions) to SageInterface</a>
<a name="2783"><span class="lineNum">    2783 </span>            :   /*! The datastructure is used as the return type for SageInterface::evaluateConstIntegerExpression(). One needs to always check whether hasValue_ is true before accessing value_ */</a>
<a name="2784"><span class="lineNum">    2784 </span>            :   struct const_int_expr_t {</a>
<a name="2785"><span class="lineNum">    2785 </span>            :     size_t value_;</a>
<a name="2786"><span class="lineNum">    2786 </span>            :     bool hasValue_;</a>
<a name="2787"><span class="lineNum">    2787 </span>            :   };</a>
<a name="2788"><span class="lineNum">    2788 </span>            :   /*! \brief The function tries to evaluate const integer expressions (such as are used in array dimension sizes). It follows variable symbols, and requires constness. */</a>
<a name="2789"><span class="lineNum">    2789 </span>            :   struct const_int_expr_t evaluateConstIntegerExpression(SgExpression *expr);</a>
<a name="2790"><span class="lineNum">    2790 </span>            : </a>
<a name="2791"><span class="lineNum">    2791 </span>            : // JP (9/17/14): Added function to test whether two SgType* are equivalent or not</a>
<a name="2792"><span class="lineNum">    2792 </span>            :    bool checkTypesAreEqual(SgType *typeA, SgType *typeB);</a>
<a name="2793"><span class="lineNum">    2793 </span>            : </a>
<a name="2794"><span class="lineNum">    2794 </span>            : </a>
<a name="2795"><span class="lineNum">    2795 </span>            : // DQ (8/31/2016): Making this a template function so that we can have it work with user defined filters.</a>
<a name="2796"><span class="lineNum">    2796 </span>            : //! This function detects template instantiations that are relevant when filters are used.</a>
<a name="2797"><span class="lineNum">    2797 </span>            : /*!</a>
<a name="2798"><span class="lineNum">    2798 </span>            :     EDG normalizes some in-class template functions and member functions to be redefined outside of a class. this causes the associated template instantiations</a>
<a name="2799"><span class="lineNum">    2799 </span>            :     to be declared outside of the class, and to be marked as compiler generated (since the compiler generated form outside of the class declaration).</a>
<a name="2800"><span class="lineNum">    2800 </span>            :     ROSE captures the function definitions, but in the new location (defined outside of the class declaration).  This can confuse some simple tests</a>
<a name="2801"><span class="lineNum">    2801 </span>            :     for template instantiations that are a part of definitions in a file, thus we have this function to detect this specific normalization.</a>
<a name="2802"><span class="lineNum">    2802 </span>            :  */</a>
<a name="2803"><span class="lineNum">    2803 </span>            : template &lt; class T &gt;</a>
<a name="2804"><span class="lineNum">    2804 </span>            : bool isTemplateInstantiationFromTemplateDeclarationSatisfyingFilter (SgFunctionDeclaration* function, T* filter )</a>
<a name="2805"><span class="lineNum">    2805 </span>            :    {</a>
<a name="2806"><span class="lineNum">    2806 </span>            :   // DQ (9/1/2016): This function is called in the Call graph generation to avoid filtering out EDG normalized</a>
<a name="2807"><span class="lineNum">    2807 </span>            :   // function template instnatiations (which come from normalized template functions and member functions).</a>
<a name="2808"><span class="lineNum">    2808 </span>            :   // Note that because of the EDG normailzation the membr function is moved outside of the class, and</a>
<a name="2809"><span class="lineNum">    2809 </span>            :   // thus marked as compiler generated.  However the template instantiations are always marked as compiler</a>
<a name="2810"><span class="lineNum">    2810 </span>            :   // generated (if not specializations) and so we want to include a template instantiation that is marked</a>
<a name="2811"><span class="lineNum">    2811 </span>            :   // as compiler generated, but is from a template declaration that satisfyied a specific user defined filter.</a>
<a name="2812"><span class="lineNum">    2812 </span>            :   // The complexity of this detection is isolated here, but knowing that it must be called is more complex.</a>
<a name="2813"><span class="lineNum">    2813 </span>            :   // This function is call in the CG.C file of tests/nonsmoke/functional/roseTests/programAnalysisTests/testCallGraphAnalysis.</a>
<a name="2814"><span class="lineNum">    2814 </span>            : </a>
<a name="2815"><span class="lineNum">    2815 </span>            :      bool retval = false;</a>
<a name="2816"><span class="lineNum">    2816 </span>            : </a>
<a name="2817"><span class="lineNum">    2817 </span>            : #define DEBUG_TEMPLATE_NORMALIZATION_DETECTION 0</a>
<a name="2818"><span class="lineNum">    2818 </span>            : </a>
<a name="2819"><span class="lineNum">    2819 </span>            : #if DEBUG_TEMPLATE_NORMALIZATION_DETECTION</a>
<a name="2820"><span class="lineNum">    2820 </span>            :      printf (&quot;In isNormalizedTemplateInstantiation(): function = %p = %s = %s \n&quot;,function,function-&gt;class_name().c_str(),function-&gt;get_name().str());</a>
<a name="2821"><span class="lineNum">    2821 </span>            : #endif</a>
<a name="2822"><span class="lineNum">    2822 </span>            : </a>
<a name="2823"><span class="lineNum">    2823 </span>            :   // Test for this to be a template instantation (in which case it was marked as</a>
<a name="2824"><span class="lineNum">    2824 </span>            :   // compiler generated but we may want to allow it to be used in the call graph,</a>
<a name="2825"><span class="lineNum">    2825 </span>            :   // if it's template was a part was defined in the current directory).</a>
<a name="2826"><span class="lineNum">    2826 </span>            :      SgTemplateInstantiationFunctionDecl*       templateInstantiationFunction       = isSgTemplateInstantiationFunctionDecl(function);</a>
<a name="2827"><span class="lineNum">    2827 </span>            :      SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(function);</a>
<a name="2828"><span class="lineNum">    2828 </span>            : </a>
<a name="2829"><span class="lineNum">    2829 </span>            :      if (templateInstantiationFunction != NULL)</a>
<a name="2830"><span class="lineNum">    2830 </span>            :         {</a>
<a name="2831"><span class="lineNum">    2831 </span>            :        // When the defining function has been normalized by EDG, only the non-defining declaration will have a source position.</a>
<a name="2832"><span class="lineNum">    2832 </span>            :           templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(templateInstantiationFunction-&gt;get_firstNondefiningDeclaration());</a>
<a name="2833"><span class="lineNum">    2833 </span>            :           SgTemplateFunctionDeclaration* templateFunctionDeclaration = templateInstantiationFunction-&gt;get_templateDeclaration();</a>
<a name="2834"><span class="lineNum">    2834 </span>            :           if (templateFunctionDeclaration != NULL)</a>
<a name="2835"><span class="lineNum">    2835 </span>            :              {</a>
<a name="2836"><span class="lineNum">    2836 </span>            :                retval = filter-&gt;operator()(templateFunctionDeclaration);</a>
<a name="2837"><span class="lineNum">    2837 </span>            :              }</a>
<a name="2838"><span class="lineNum">    2838 </span>            :             else</a>
<a name="2839"><span class="lineNum">    2839 </span>            :              {</a>
<a name="2840"><span class="lineNum">    2840 </span>            :              // Assume false.</a>
<a name="2841"><span class="lineNum">    2841 </span>            :              }</a>
<a name="2842"><span class="lineNum">    2842 </span>            : </a>
<a name="2843"><span class="lineNum">    2843 </span>            : #if DEBUG_TEMPLATE_NORMALIZATION_DETECTION</a>
<a name="2844"><span class="lineNum">    2844 </span>            :           printf (&quot;   --- case of templateInstantiationFunction: retval = %s \n&quot;,retval ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2845"><span class="lineNum">    2845 </span>            : #endif</a>
<a name="2846"><span class="lineNum">    2846 </span>            :         }</a>
<a name="2847"><span class="lineNum">    2847 </span>            :        else</a>
<a name="2848"><span class="lineNum">    2848 </span>            :         {</a>
<a name="2849"><span class="lineNum">    2849 </span>            :           if (templateInstantiationMemberFunction != NULL)</a>
<a name="2850"><span class="lineNum">    2850 </span>            :              {</a>
<a name="2851"><span class="lineNum">    2851 </span>            :             // When the defining function has been normalized by EDG, only the non-defining declaration will have a source position.</a>
<a name="2852"><span class="lineNum">    2852 </span>            :                templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(templateInstantiationMemberFunction-&gt;get_firstNondefiningDeclaration());</a>
<a name="2853"><span class="lineNum">    2853 </span>            :                SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = templateInstantiationMemberFunction-&gt;get_templateDeclaration();</a>
<a name="2854"><span class="lineNum">    2854 </span>            :                if (templateMemberFunctionDeclaration != NULL)</a>
<a name="2855"><span class="lineNum">    2855 </span>            :                   {</a>
<a name="2856"><span class="lineNum">    2856 </span>            :                     retval = filter-&gt;operator()(templateMemberFunctionDeclaration);</a>
<a name="2857"><span class="lineNum">    2857 </span>            :                   }</a>
<a name="2858"><span class="lineNum">    2858 </span>            :                  else</a>
<a name="2859"><span class="lineNum">    2859 </span>            :                   {</a>
<a name="2860"><span class="lineNum">    2860 </span>            :                  // Assume false.</a>
<a name="2861"><span class="lineNum">    2861 </span>            :                   }</a>
<a name="2862"><span class="lineNum">    2862 </span>            : </a>
<a name="2863"><span class="lineNum">    2863 </span>            : #if DEBUG_TEMPLATE_NORMALIZATION_DETECTION</a>
<a name="2864"><span class="lineNum">    2864 </span>            :                printf (&quot;   --- case of templateInstantiationMemberFunction: retval = %s \n&quot;,retval ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="2865"><span class="lineNum">    2865 </span>            : #endif</a>
<a name="2866"><span class="lineNum">    2866 </span>            :              }</a>
<a name="2867"><span class="lineNum">    2867 </span>            :         }</a>
<a name="2868"><span class="lineNum">    2868 </span>            : </a>
<a name="2869"><span class="lineNum">    2869 </span>            :      return retval;</a>
<a name="2870"><span class="lineNum">    2870 </span>            :    }</a>
<a name="2871"><span class="lineNum">    2871 </span>            : </a>
<a name="2872"><span class="lineNum">    2872 </span>            : void detectCycleInType(SgType * type, const std::string &amp; from);</a>
<a name="2873"><span class="lineNum">    2873 </span>            : </a>
<a name="2874"><span class="lineNum">    2874 </span>            : // DQ (7/14/2020): Debugging support.</a>
<a name="2875"><span class="lineNum">    2875 </span>            : void checkForInitializers( SgNode* node );</a>
<a name="2876"><span class="lineNum">    2876 </span>            : </a>
<a name="2877"><span class="lineNum">    2877 </span>            : void clearSharedGlobalScopes(SgProject * project);</a>
<a name="2878"><span class="lineNum">    2878 </span>            : </a>
<a name="2879"><span class="lineNum">    2879 </span>            : }// end of namespace</a>
<a name="2880"><span class="lineNum">    2880 </span>            : </a>
<a name="2881"><span class="lineNum">    2881 </span>            : #endif</a>
<a name="2882"><span class="lineNum">    2882 </span>            : </a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
