<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface/sageInterface.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface</a> - sageInterface.C<span style="font-size: 80%;"> (source / <a href="sageInterface.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3747</td>
            <td class="headerCovTableEntry">9258</td>
            <td class="headerCovTableEntryLo">40.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">251</td>
            <td class="headerCovTableEntry">483</td>
            <td class="headerCovTableEntryLo">52.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : </a>
<a name="2"><span class="lineNum">       2 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="3"><span class="lineNum">       3 </span>            : #include &quot;markLhsValues.h&quot;</a>
<a name="4"><span class="lineNum">       4 </span>            : #include &quot;fixupNames.h&quot;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &quot;FileUtility.h&quot;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;Sawyer/Message.h&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : #if ROSE_WITH_LIBHARU</a>
<a name="9"><span class="lineNum">       9 </span>            : #include &quot;AstPDFGeneration.h&quot;</a>
<a name="10"><span class="lineNum">      10 </span>            : #endif</a>
<a name="11"><span class="lineNum">      11 </span>            : </a>
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;SgNodeHelper.h&quot; //Markus's helper functions</a>
<a name="13"><span class="lineNum">      13 </span>            : </a>
<a name="14"><span class="lineNum">      14 </span>            : #include &quot;Rose/AST/Utils.h&quot;</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            : #include &quot;sageInterface.h&quot;</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &quot;replaceExpressionWithStatement.h&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;constantFolding.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : #endif</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : // DQ (10/14/2006): Added supporting help functions. tps commented out since it caused no compilation errors</a>
<a name="25"><span class="lineNum">      25 </span>            : //#include &quot;rewrite.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : // Liao 1/24/2008 : need access to scope stack sometimes</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &quot;sageBuilder.h&quot;</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : // DQ (3/14/2017): Try to comment this out since it is not tested (used in get_C_array_dimensions(),</a>
<a name="31"><span class="lineNum">      31 </span>            : // from midend/programTransformation/ompLowering/omp_lowering.cpp, but not tested).</a>
<a name="32"><span class="lineNum">      32 </span>            : // PP 01/06/2012 : need swap operations for wrapFunction implementation</a>
<a name="33"><span class="lineNum">      33 </span>            : // PP 05/30/2012 : need ancestor function</a>
<a name="34"><span class="lineNum">      34 </span>            : #include &quot;sageGeneric.h&quot;</a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : // PP 01/06/2012 : need convenience functors to interface STL</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &quot;sageFunctors.h&quot;</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="40"><span class="lineNum">      40 </span>            : // For reusing some code from Qing's loop optimizer</a>
<a name="41"><span class="lineNum">      41 </span>            : // Liao, 2/26/2009</a>
<a name="42"><span class="lineNum">      42 </span>            : #include &quot;AstInterface_ROSE.h&quot;</a>
<a name="43"><span class="lineNum">      43 </span>            : #include &quot;LoopTransformInterface.h&quot;</a>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<a name="45"><span class="lineNum">      45 </span>            : #include &quot;DepInfoAnal.h&quot; // for AnalyzeStmtRefs()</a>
<a name="46"><span class="lineNum">      46 </span>            : #include &quot;ArrayAnnot.h&quot;</a>
<a name="47"><span class="lineNum">      47 </span>            : #include &quot;ArrayInterface.h&quot;</a>
<a name="48"><span class="lineNum">      48 </span>            : </a>
<a name="49"><span class="lineNum">      49 </span>            : #include &quot;LoopUnroll.h&quot;</a>
<a name="50"><span class="lineNum">      50 </span>            : #include &quot;abstract_handle.h&quot;</a>
<a name="51"><span class="lineNum">      51 </span>            : #include &quot;roseAdapter.h&quot;</a>
<a name="52"><span class="lineNum">      52 </span>            : #endif</a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<a name="54"><span class="lineNum">      54 </span>            : #include &lt;boost/lexical_cast.hpp&gt;</a>
<a name="55"><span class="lineNum">      55 </span>            : #include &lt;boost/foreach.hpp&gt;</a>
<a name="56"><span class="lineNum">      56 </span>            : #include &lt;sstream&gt;</a>
<a name="57"><span class="lineNum">      57 </span>            : #include &lt;iostream&gt;</a>
<a name="58"><span class="lineNum">      58 </span>            : #include &lt;algorithm&gt; // for set operations</a>
<a name="59"><span class="lineNum">      59 </span>            : #include &lt;numeric&gt;   // for std::accumulate</a>
<a name="60"><span class="lineNum">      60 </span>            : #include &lt;map&gt;</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : // DQ (11/5/2019): Added to support SageInterface::statementCanBeTransformed().</a>
<a name="63"><span class="lineNum">      63 </span>            : namespace EDG_ROSE_Translation</a>
<a name="64"><span class="lineNum">      64 </span>            :    {</a>
<a name="65"><span class="lineNum">      65 </span>            :   // DQ (9/18/2018): Declare this map so that we can use it for the unparse header files option.</a>
<a name="66"><span class="lineNum">      66 </span>            : #if defined(ROSE_BUILD_CXX_LANGUAGE_SUPPORT) &amp;&amp; !defined(ROSE_USE_CLANG_FRONTEND)</a>
<a name="67"><span class="lineNum">      67 </span>            :   // DQ (12/11/2018): Use the definition in the EDG edgRose.C file if C/C++ support IS defined.</a>
<a name="68"><span class="lineNum">      68 </span>            :     extern std::map&lt;std::string, SgIncludeFile*&gt; edg_include_file_map;</a>
<a name="69"><span class="lineNum">      69 </span>            : #else</a>
<a name="70"><span class="lineNum">      70 </span>            :   // DQ (12/11/2018): Allow this to be the definition if C/C++ support is NOT defined.</a>
<a name="71"><span class="lineNum">      71 </span>            :     std::map&lt;std::string, SgIncludeFile*&gt; edg_include_file_map;</a>
<a name="72"><span class="lineNum">      72 </span>            : #endif</a>
<a name="73"><span class="lineNum">      73 </span>            :   }</a>
<a name="74"><span class="lineNum">      74 </span>            : </a>
<a name="75"><span class="lineNum">      75 </span>            : namespace sg</a>
<a name="76"><span class="lineNum">      76 </span>            : {</a>
<a name="77"><span class="lineNum">      77 </span>            :   [[noreturn]]</a>
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 :   void report_error(std::string desc, const char* file, size_t ln)</span></a>
<a name="79"><span class="lineNum">      79 </span>            :   {</a>
<a name="80"><span class="lineNum">      80 </span><span class="lineNoCov">          0 :     static const char* AT = &quot; at &quot;;</span></a>
<a name="81"><span class="lineNum">      81 </span><span class="lineNoCov">          0 :     static const char* SEP = &quot; : &quot;;</span></a>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<a name="83"><span class="lineNum">      83 </span><span class="lineNoCov">          0 :     if (file)</span></a>
<a name="84"><span class="lineNum">      84 </span>            :     {</a>
<a name="85"><span class="lineNum">      85 </span><span class="lineNoCov">          0 :       const std::string filename(file);</span></a>
<a name="86"><span class="lineNum">      86 </span><span class="lineNoCov">          0 :       const std::string num(conv&lt;std::string&gt;(ln));</span></a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :       desc.reserve(desc.size() + num.size() + filename.size() + std::strlen(AT) + std::strlen(SEP)+1);</span></a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span><span class="lineNoCov">          0 :       desc.append(AT);</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :       desc.append(filename);</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :       desc.append(SEP);</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :       desc.append(num);</span></a>
<a name="94"><span class="lineNum">      94 </span>            :     }</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :     {</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :       using namespace Rose::Diagnostics;</span></a>
<a name="98"><span class="lineNum">      98 </span>            : </a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :       mlog[FATAL] &lt;&lt; &quot;[abort] &quot; &lt;&lt; desc &lt;&lt; std::endl;</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="101"><span class="lineNum">     101 </span>            : </a>
<a name="102"><span class="lineNum">     102 </span>            :       //~ mlog[FATAL] &lt;&lt; &quot;[throw] &quot; &lt;&lt; desc &lt;&lt; std::endl;</a>
<a name="103"><span class="lineNum">     103 </span>            :       //~ throw std::runtime_error(desc);</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            :     //~ std::cerr &lt;&lt; &quot;[exit] [FATAL] &quot; &lt;&lt; desc &lt;&lt; std::endl;</a>
<a name="106"><span class="lineNum">     106 </span>            :     //~ std::exit(1);</a>
<a name="107"><span class="lineNum">     107 </span>            :     }</a>
<a name="108"><span class="lineNum">     108 </span>            :   }</a>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<a name="110"><span class="lineNum">     110 </span>            :   [[noreturn]]</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineNoCov">          0 :   void unexpected_node(const SgNode&amp; n, const char* file, size_t ln)</span></a>
<a name="112"><span class="lineNum">     112 </span>            :   {</a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :     static const std::string msg = &quot;assertion failed: unexpected node-type: &quot;;</span></a>
<a name="114"><span class="lineNum">     114 </span>            : </a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :     report_error(msg + typeid(n).name(), file, ln);</span></a>
<a name="116"><span class="lineNum">     116 </span>            :   }</a>
<a name="117"><span class="lineNum">     117 </span>            : }</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            : // DQ (12/1/2015): Added to support macro handling.</a>
<a name="120"><span class="lineNum">     120 </span>            : #include &quot;detectMacroOrIncludeFileExpansions.h&quot;</a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span>            : namespace SageInterface {</a>
<a name="123"><span class="lineNum">     123 </span>            :   template&lt;class T&gt; void setSourcePositionToDefault( T* node );</a>
<a name="124"><span class="lineNum">     124 </span>            : }</a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            : #ifdef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="127"><span class="lineNum">     127 </span>            :    #include &quot;transformationSupport.h&quot;</a>
<a name="128"><span class="lineNum">     128 </span>            : #endif</a>
<a name="129"><span class="lineNum">     129 </span>            : </a>
<a name="130"><span class="lineNum">     130 </span>            : // We need this so that USE_CMAKE will be seen (set via configure).</a>
<a name="131"><span class="lineNum">     131 </span>            : #include &quot;rose_config.h&quot;</a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            : // DQ (3/4/2014): We need this feature to support the function: isStructurallyEquivalentAST().</a>
<a name="134"><span class="lineNum">     134 </span>            : #include &quot;RoseAst.h&quot;</a>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<a name="137"><span class="lineNum">     137 </span>            : // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="138"><span class="lineNum">     138 </span>            : // The value of 0 allows the old implementation to be tested, and the value of 1 allows the new optimized implementation to be tested.</a>
<a name="139"><span class="lineNum">     139 </span>            : #define OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS 1</a>
<a name="140"><span class="lineNum">     140 </span>            : </a>
<a name="141"><span class="lineNum">     141 </span>            : //! C++ SageBuilder namespace specific state for storage of the source code position state (used to control how the source code positon is defined for IR nodes built within the SageBuilder interface).</a>
<a name="142"><span class="lineNum">     142 </span>            : extern SageBuilder::SourcePositionClassification SageBuilder::SourcePositionClassificationMode;</a>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<a name="144"><span class="lineNum">     144 </span>            : // DQ (3/21/2016): Added support for generateUniqueNameForUseAsIdentifier().</a>
<a name="145"><span class="lineNum">     145 </span>            : std::map&lt;std::string,int&gt;     SageInterface::local_name_collision_map;</a>
<a name="146"><span class="lineNum">     146 </span>            : std::map&lt;std::string,SgNode*&gt; SageInterface::local_name_to_node_map;</a>
<a name="147"><span class="lineNum">     147 </span>            : std::map&lt;SgNode*,std::string&gt; SageInterface::local_node_to_name_map;</a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            : typedef std::set&lt;SgLabelStatement*&gt; SgLabelStatementPtrSet;</a>
<a name="150"><span class="lineNum">     150 </span>            : </a>
<a name="151"><span class="lineNum">     151 </span>            : namespace SageInterface</a>
<a name="152"><span class="lineNum">     152 </span>            : {</a>
<a name="153"><span class="lineNum">     153 </span>            :     Transformation_Record trans_records;</a>
<a name="154"><span class="lineNum">     154 </span>            : }</a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span>            : // DQ (12/31/2005): This is OK if not declared in a header file</a>
<a name="157"><span class="lineNum">     157 </span>            : using namespace std;</a>
<a name="158"><span class="lineNum">     158 </span>            : using namespace Rose;</a>
<a name="159"><span class="lineNum">     159 </span>            : using namespace SageBuilder;</a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            : // Used by serialize() to collect all types visited</a>
<a name="162"><span class="lineNum">     162 </span>            : //std::set&lt;SgType*&gt; type_set;</a>
<a name="163"><span class="lineNum">     163 </span>            : // DQ (1/18/2015): Define this container locally in this file only.</a>
<a name="164"><span class="lineNum">     164 </span>            : namespace SageInterface</a>
<a name="165"><span class="lineNum">     165 </span>            :    {</a>
<a name="166"><span class="lineNum">     166 </span>            :   // DQ (1/18/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="167"><span class="lineNum">     167 </span>            :      vector&lt;SgBasicBlock*&gt; addedBasicBlockNodes;</a>
<a name="168"><span class="lineNum">     168 </span>            :    }</a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            : void</a>
<a name="171"><span class="lineNum">     171 </span><span class="lineCov">     676218 : SageInterface::DeclarationSets::addDeclaration(SgDeclarationStatement* decl)</span></a>
<a name="172"><span class="lineNum">     172 </span>            :    {</a>
<a name="173"><span class="lineNum">     173 </span>            :   // DQ (4/3/2014): This function either builds a new set or inserts declarations into an</a>
<a name="174"><span class="lineNum">     174 </span>            :   // existing set based on if a set defined by the key (firstNondefiningDeclaration) is present.</a>
<a name="175"><span class="lineNum">     175 </span><span class="lineCov">     676218 :      ROSE_ASSERT(decl != NULL);</span></a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span>            : #if 0</a>
<a name="178"><span class="lineNum">     178 </span>            :      printf (&quot;TOP of SageInterface::DeclarationSets::addDeclaration(): decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="179"><span class="lineNum">     179 </span>            : #endif</a>
<a name="180"><span class="lineNum">     180 </span>            : </a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">     676218 :      SgDeclarationStatement* firstNondefiningDeclaration = decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="182"><span class="lineNum">     182 </span>            : </a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">     676218 :      if (firstNondefiningDeclaration == NULL)</span></a>
<a name="184"><span class="lineNum">     184 </span>            :         {</a>
<a name="185"><span class="lineNum">     185 </span>            :        // It appears that some loop transformations (pass3.C) don't set the firstNondefiningDeclaration.</a>
<a name="186"><span class="lineNum">     186 </span>            : #if 0</a>
<a name="187"><span class="lineNum">     187 </span>            :           printf (&quot;WARNING: SageInterface::DeclarationSets::addDeclaration(): firstNondefiningDeclaration == NULL: decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="188"><span class="lineNum">     188 </span>            : #endif</a>
<a name="189"><span class="lineNum">     189 </span><span class="lineNoCov">          0 :           return;</span></a>
<a name="190"><span class="lineNum">     190 </span>            :         }</a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">     676218 :      ROSE_ASSERT(firstNondefiningDeclaration != NULL);</span></a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span><span class="lineCov">     676218 :      if (decl == firstNondefiningDeclaration)</span></a>
<a name="194"><span class="lineNum">     194 </span>            :         {</a>
<a name="195"><span class="lineNum">     195 </span>            : #if 0</a>
<a name="196"><span class="lineNum">     196 </span>            :           if (isSgTypedefDeclaration(decl) != NULL)</a>
<a name="197"><span class="lineNum">     197 </span>            :              {</a>
<a name="198"><span class="lineNum">     198 </span>            :                printf (&quot;TOP of SageInterface::DeclarationSets::addDeclaration(): decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="199"><span class="lineNum">     199 </span>            :              }</a>
<a name="200"><span class="lineNum">     200 </span>            : #endif</a>
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">    1140180 :           if (declarationMap.find(firstNondefiningDeclaration) == declarationMap.end())</span></a>
<a name="202"><span class="lineNum">     202 </span>            :              {</a>
<a name="203"><span class="lineNum">     203 </span>            : #if 0</a>
<a name="204"><span class="lineNum">     204 </span>            :                printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Add a set for decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="205"><span class="lineNum">     205 </span>            : #endif</a>
<a name="206"><span class="lineNum">     206 </span>            : #if 0</a>
<a name="207"><span class="lineNum">     207 </span>            :                if (isSgTypedefDeclaration(decl) != NULL)</a>
<a name="208"><span class="lineNum">     208 </span>            :                   {</a>
<a name="209"><span class="lineNum">     209 </span>            :                     printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Add a set for decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="210"><span class="lineNum">     210 </span>            :                   }</a>
<a name="211"><span class="lineNum">     211 </span>            : #endif</a>
<a name="212"><span class="lineNum">     212 </span>            :             // Add a new set.</a>
<a name="213"><span class="lineNum">     213 </span><span class="lineCov">     567783 :                declarationMap[decl] = new set&lt;SgDeclarationStatement*&gt;();</span></a>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">    1135570 :                ROSE_ASSERT (declarationMap.find(firstNondefiningDeclaration) != declarationMap.end());</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">     567783 :                ROSE_ASSERT(declarationMap[decl] != NULL);</span></a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span>            :             // Add a declaration to an existing set.</a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">     567783 :                declarationMap[firstNondefiningDeclaration]-&gt;insert(decl);</span></a>
<a name="220"><span class="lineNum">     220 </span>            :              }</a>
<a name="221"><span class="lineNum">     221 </span>            :             else</a>
<a name="222"><span class="lineNum">     222 </span>            :              {</a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">       4612 :                if (declarationMap[firstNondefiningDeclaration]-&gt;find(decl) == declarationMap[firstNondefiningDeclaration]-&gt;end())</span></a>
<a name="224"><span class="lineNum">     224 </span>            :                   {</a>
<a name="225"><span class="lineNum">     225 </span>            : #if 0</a>
<a name="226"><span class="lineNum">     226 </span>            :                     printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Add the declaration to the existing set: decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="227"><span class="lineNum">     227 </span>            : #endif</a>
<a name="228"><span class="lineNum">     228 </span>            : #if 0</a>
<a name="229"><span class="lineNum">     229 </span>            :                     if (isSgTypedefDeclaration(decl) != NULL)</a>
<a name="230"><span class="lineNum">     230 </span>            :                        {</a>
<a name="231"><span class="lineNum">     231 </span>            :                          printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Add the declaration to the existing set: decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="232"><span class="lineNum">     232 </span>            :                        }</a>
<a name="233"><span class="lineNum">     233 </span>            : #endif</a>
<a name="234"><span class="lineNum">     234 </span>            :                  // Add a declaration to an existing set.</a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">         51 :                     declarationMap[firstNondefiningDeclaration]-&gt;insert(decl);</span></a>
<a name="236"><span class="lineNum">     236 </span>            :                   }</a>
<a name="237"><span class="lineNum">     237 </span>            :                  else</a>
<a name="238"><span class="lineNum">     238 </span>            :                   {</a>
<a name="239"><span class="lineNum">     239 </span>            : #if 0</a>
<a name="240"><span class="lineNum">     240 </span>            :                     printf (&quot;WARNING: SageInterface::DeclarationSets::addDeclaration(): A set already exists for decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="241"><span class="lineNum">     241 </span>            : #endif</a>
<a name="242"><span class="lineNum">     242 </span>            :                  // DQ (4/5/2014): The case of SgFunctionParameterList fails only for boost examples (e.g. test2014_240.C).</a>
<a name="243"><span class="lineNum">     243 </span>            :                  // Problem uses are associated with SgTemplateInstantiationFunctionDecl IR nodes.</a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">       2255 :                     bool ignore_error = (isSgFunctionParameterList(decl) != NULL);</span></a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            :                  // DQ (4/17/2014): This is required for the EDG version 4.8 and I don't know why.</a>
<a name="247"><span class="lineNum">     247 </span>            :                  // Currently the priority is to pass our existing tests.</a>
<a name="248"><span class="lineNum">     248 </span>            :                  // An idea is that this is sharing introduced as a result of the use of default parameters.</a>
<a name="249"><span class="lineNum">     249 </span>            : </a>
<a name="250"><span class="lineNum">     250 </span>            : // DQ (2/5/2015): Comment out this constraint to make this a more general test to try out a new solution for the GNU 4.8.1 compiler. This works well!</a>
<a name="251"><span class="lineNum">     251 </span>            : // #if (BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER &gt; 6)</a>
<a name="252"><span class="lineNum">     252 </span>            : //                  ignore_error = ignore_error || (isSgTemplateInstantiationDecl(decl) != NULL);</a>
<a name="253"><span class="lineNum">     253 </span>            : // #else</a>
<a name="254"><span class="lineNum">     254 </span>            :                  // DQ (7/2/2014): I am seeing that this is required for a new application using GNU 4.4.7.</a>
<a name="255"><span class="lineNum">     255 </span>            :                  // It allows a boost issue specific to a revisited SgTypedefDeclaration pass, but I still</a>
<a name="256"><span class="lineNum">     256 </span>            :                  // don't understand the problem.  so this needs a better fix.</a>
<a name="257"><span class="lineNum">     257 </span>            :                  // ignore_error = ignore_error || (isSgTypedefDeclaration(decl) != NULL);</a>
<a name="258"><span class="lineNum">     258 </span>            :                  // ignore_error = ignore_error || (isSgTypedefDeclaration(decl) != NULL) || (isSgTemplateInstantiationDecl(decl) != NULL);</a>
<a name="259"><span class="lineNum">     259 </span>            : #if 0</a>
<a name="260"><span class="lineNum">     260 </span>            :                     bool isInTemplateDeclaration = ( (isSgTemplateClassDefinition(decl-&gt;get_parent()) != NULL) ||</a>
<a name="261"><span class="lineNum">     261 </span>            :                                                      (isSgTemplateFunctionDeclaration(decl-&gt;get_parent()) != NULL) ||</a>
<a name="262"><span class="lineNum">     262 </span>            :                                                      (isSgTemplateMemberFunctionDeclaration(decl-&gt;get_parent()) != NULL) ||</a>
<a name="263"><span class="lineNum">     263 </span>            :                                                      (decl-&gt;get_parent() != NULL &amp;&amp; isSgTemplateFunctionDeclaration(decl-&gt;get_parent()-&gt;get_parent()) != NULL) ||</a>
<a name="264"><span class="lineNum">     264 </span>            :                                                      (decl-&gt;get_parent() != NULL &amp;&amp; isSgTemplateMemberFunctionDeclaration(decl-&gt;get_parent()-&gt;get_parent()) != NULL) );</a>
<a name="265"><span class="lineNum">     265 </span>            : #else</a>
<a name="266"><span class="lineNum">     266 </span>            :                  // DQ (10/11/2015): We need a better test for if this is in a template class, function, member function, etc.</a>
<a name="267"><span class="lineNum">     267 </span>            :                  // SgFunctionDeclaration * getEnclosingFunctionDeclaration (SgNode * astNode, const bool includingSelf=false);</a>
<a name="268"><span class="lineNum">     268 </span><span class="lineCov">       2255 :                     SgFunctionDeclaration* enclosingFunction = getEnclosingFunctionDeclaration(decl);</span></a>
<a name="269"><span class="lineNum">     269 </span><span class="lineCov">       2255 :                     bool isInTemplateFunctionDeclaration = enclosingFunction != NULL &amp;&amp; (isSgTemplateMemberFunctionDeclaration(enclosingFunction) || isSgTemplateFunctionDeclaration(enclosingFunction));</span></a>
<a name="270"><span class="lineNum">     270 </span>            :                  // SgClassDeclaration* enclosingClass = getEnclosingClassDeclaration(decl);</a>
<a name="271"><span class="lineNum">     271 </span>            :                  // isInTemplateClassDeclaration = enclosingClass != NULL &amp;&amp; isSgTemplateClassDeclaration(decl);</a>
<a name="272"><span class="lineNum">     272 </span>            : </a>
<a name="273"><span class="lineNum">     273 </span>            :                  // Use short-circuit evaluation to improve performance.</a>
<a name="274"><span class="lineNum">     274 </span>            :                  // SgClassDefinition* enclosingClassDefinition = getEnclosingClassDefinition(decl);</a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">       2255 :                     SgClassDefinition* enclosingClassDefinition = isInTemplateFunctionDeclaration == true ? NULL : getEnclosingClassDefinition(decl);</span></a>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">       2255 :                     bool isInTemplateClassDefinition = enclosingClassDefinition != NULL &amp;&amp; isSgTemplateClassDefinition(enclosingClassDefinition);</span></a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">       2255 :                     bool isInTemplateDeclaration = isInTemplateFunctionDeclaration || isInTemplateClassDefinition;</span></a>
<a name="279"><span class="lineNum">     279 </span>            : #endif</a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">       2255 :                     ignore_error = ignore_error || (isSgTypedefDeclaration(decl) != NULL) || (isSgTemplateInstantiationDecl(decl) != NULL) || (isInTemplateDeclaration == true);</span></a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            :                  // DQ (2/5/2015): We need to ignore the case of un-named classes (or maybe those classes</a>
<a name="283"><span class="lineNum">     283 </span>            :                  // from unnamed classes with lambda member functions).  See test2015_13.C for an example.</a>
<a name="284"><span class="lineNum">     284 </span>            :                  // Or maybe these should have been added to the declarationMap in the front-end?</a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">       2255 :                     if (isSgClassDeclaration(decl) != NULL)</span></a>
<a name="286"><span class="lineNum">     286 </span>            :                        {</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineCov">         34 :                          ignore_error = ignore_error || (isSgClassDeclaration(decl)-&gt;get_isUnNamed() == true);</span></a>
<a name="288"><span class="lineNum">     288 </span>            :                        }</a>
<a name="289"><span class="lineNum">     289 </span>            : // #endif</a>
<a name="290"><span class="lineNum">     290 </span>            : </a>
<a name="291"><span class="lineNum">     291 </span><span class="lineCov">       2255 :                     if (ignore_error == true)</span></a>
<a name="292"><span class="lineNum">     292 </span>            :                        {</a>
<a name="293"><span class="lineNum">     293 </span>            : #if 0</a>
<a name="294"><span class="lineNum">     294 </span>            : #if (BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 4) &amp;&amp; (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER &gt; 6)</a>
<a name="295"><span class="lineNum">     295 </span>            :                          printf (&quot;Ignoring the error for a SgFunctionParameterList and SgTemplateInstantiationDecl \n&quot;);</a>
<a name="296"><span class="lineNum">     296 </span>            : #else</a>
<a name="297"><span class="lineNum">     297 </span>            :                          printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Ignoring the error for a SgFunctionParameterList \n&quot;);</a>
<a name="298"><span class="lineNum">     298 </span>            : #endif</a>
<a name="299"><span class="lineNum">     299 </span>            : #endif</a>
<a name="300"><span class="lineNum">     300 </span>            :                        }</a>
<a name="301"><span class="lineNum">     301 </span>            :                       else</a>
<a name="302"><span class="lineNum">     302 </span>            :                        {</a>
<a name="303"><span class="lineNum">     303 </span>            : #if 0</a>
<a name="304"><span class="lineNum">     304 </span>            :                          printf (&quot;declarationMap[firstNondefiningDeclaration]-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,declarationMap[firstNondefiningDeclaration]-&gt;size());</a>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<a name="306"><span class="lineNum">     306 </span>            :                          printf (&quot;decl                             = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="307"><span class="lineNum">     307 </span>            :                          printf (&quot;decl-&gt;get_parent()               = %p = %s = %s \n&quot;,decl-&gt;get_parent(),decl-&gt;get_parent()-&gt;class_name().c_str(),get_name(decl-&gt;get_parent()).c_str());</a>
<a name="308"><span class="lineNum">     308 </span>            :                          printf (&quot;decl-&gt;get_parent()-&gt;get_parent() = %p = %s = %s \n&quot;,decl-&gt;get_parent()-&gt;get_parent(),decl-&gt;get_parent()-&gt;get_parent()-&gt;class_name().c_str(),get_name(decl-&gt;get_parent()-&gt;get_parent()).c_str());</a>
<a name="309"><span class="lineNum">     309 </span>            : #endif</a>
<a name="310"><span class="lineNum">     310 </span>            : #if 0</a>
<a name="311"><span class="lineNum">     311 </span>            :                          SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(decl-&gt;get_parent()-&gt;get_parent());</a>
<a name="312"><span class="lineNum">     312 </span>            :                          if (namespaceDefinitionStatement != NULL)</a>
<a name="313"><span class="lineNum">     313 </span>            :                             {</a>
<a name="314"><span class="lineNum">     314 </span>            :                               namespaceDefinitionStatement-&gt;get_file_info()-&gt;display(&quot;namespaceDefinitionStatement: debug&quot;);</a>
<a name="315"><span class="lineNum">     315 </span>            :                             }</a>
<a name="316"><span class="lineNum">     316 </span>            : #endif</a>
<a name="317"><span class="lineNum">     317 </span>            : #if 0</a>
<a name="318"><span class="lineNum">     318 </span>            :                          if (isSgCtorInitializerList(decl) != NULL)</a>
<a name="319"><span class="lineNum">     319 </span>            :                             {</a>
<a name="320"><span class="lineNum">     320 </span>            :                               firstNondefiningDeclaration-&gt;get_parent()-&gt;get_file_info()-&gt;display(&quot;declarationMap.find(firstNondefiningDeclaration) != declarationMap.end(): firstNondefiningDeclaration-&gt;get_parent(): debug&quot;);</a>
<a name="321"><span class="lineNum">     321 </span>            :                               decl-&gt;get_parent()-&gt;get_file_info()-&gt;display(&quot;declarationMap.find(firstNondefiningDeclaration) != declarationMap.end(): decl-&gt;get_parent(): debug&quot;);</a>
<a name="322"><span class="lineNum">     322 </span>            :                             }</a>
<a name="323"><span class="lineNum">     323 </span>            : #endif</a>
<a name="324"><span class="lineNum">     324 </span>            : #if 0</a>
<a name="325"><span class="lineNum">     325 </span>            :                          firstNondefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;declarationMap.find(firstNondefiningDeclaration) != declarationMap.end(): firstNondefiningDeclaration: debug&quot;);</a>
<a name="326"><span class="lineNum">     326 </span>            :                          decl-&gt;get_file_info()-&gt;display(&quot;declarationMap.find(firstNondefiningDeclaration) != declarationMap.end(): decl: debug&quot;);</a>
<a name="327"><span class="lineNum">     327 </span>            : #endif</a>
<a name="328"><span class="lineNum">     328 </span>            :                       // DQ (2/5/2015): This is a problem for EDG 4.9 code using the GNU 4.8.1 compiler</a>
<a name="329"><span class="lineNum">     329 </span>            :                       // and maybe related to C++11 support (commented out assertion as a test).</a>
<a name="330"><span class="lineNum">     330 </span>            : #if 0</a>
<a name="331"><span class="lineNum">     331 </span>            :                          printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Can not ignore this error \n&quot;);</a>
<a name="332"><span class="lineNum">     332 </span>            :                          ROSE_ABORT();</a>
<a name="333"><span class="lineNum">     333 </span>            : #else</a>
<a name="334"><span class="lineNum">     334 </span>            :                       // DQ (5/22/2016): Comment out this assertion as a test (test of using new typeEquivalent test in the symbol handling and C++11 mode on testRoseHeaders_01.C with Boost 1.59.</a>
<a name="335"><span class="lineNum">     335 </span>            : #if 0</a>
<a name="336"><span class="lineNum">     336 </span>            :                          printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): I would like to ignore this for debugging! decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="337"><span class="lineNum">     337 </span>            : #endif</a>
<a name="338"><span class="lineNum">     338 </span>            : #endif</a>
<a name="339"><span class="lineNum">     339 </span>            :                        }</a>
<a name="340"><span class="lineNum">     340 </span>            :                   }</a>
<a name="341"><span class="lineNum">     341 </span>            :              }</a>
<a name="342"><span class="lineNum">     342 </span>            :         }</a>
<a name="343"><span class="lineNum">     343 </span>            :        else</a>
<a name="344"><span class="lineNum">     344 </span>            :         {</a>
<a name="345"><span class="lineNum">     345 </span>            :        // Add the declaration (make sure there is a set that exists).</a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">     212258 :           if (declarationMap.find(firstNondefiningDeclaration) != declarationMap.end())</span></a>
<a name="347"><span class="lineNum">     347 </span>            :              {</a>
<a name="348"><span class="lineNum">     348 </span>            :             // Make sure it does not already exist in the set.</a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">      78936 :                ROSE_ASSERT (declarationMap[firstNondefiningDeclaration] != NULL);</span></a>
<a name="350"><span class="lineNum">     350 </span>            : #if 0</a>
<a name="351"><span class="lineNum">     351 </span>            :                printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Add a declaration to an existing set for decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="352"><span class="lineNum">     352 </span>            : #endif</a>
<a name="353"><span class="lineNum">     353 </span>            :             // Add a declaration to an existing set.</a>
<a name="354"><span class="lineNum">     354 </span>            :             // ROSE_ASSERT (declarationMap[firstNondefiningDeclaration]-&gt;find(decl) == declarationMap[firstNondefiningDeclaration]-&gt;end());</a>
<a name="355"><span class="lineNum">     355 </span>            :             // declarationMap[firstNondefiningDeclaration]-&gt;insert(decl);</a>
<a name="356"><span class="lineNum">     356 </span><span class="lineCov">     157872 :                if (declarationMap[firstNondefiningDeclaration]-&gt;find(decl) == declarationMap[firstNondefiningDeclaration]-&gt;end())</span></a>
<a name="357"><span class="lineNum">     357 </span>            :                   {</a>
<a name="358"><span class="lineNum">     358 </span>            :                  // Add a declaration to an existing set.</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">     755154 :                     declarationMap[firstNondefiningDeclaration]-&gt;insert(decl);</span></a>
<a name="360"><span class="lineNum">     360 </span>            :                   }</a>
<a name="361"><span class="lineNum">     361 </span>            :                  else</a>
<a name="362"><span class="lineNum">     362 </span>            :                   {</a>
<a name="363"><span class="lineNum">     363 </span>            : #if 0</a>
<a name="364"><span class="lineNum">     364 </span>            :                     printf (&quot;This declaration is already in the set (skip adding it twice): decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="365"><span class="lineNum">     365 </span>            : #endif</a>
<a name="366"><span class="lineNum">     366 </span>            :                   }</a>
<a name="367"><span class="lineNum">     367 </span>            :              }</a>
<a name="368"><span class="lineNum">     368 </span>            :             else</a>
<a name="369"><span class="lineNum">     369 </span>            :              {</a>
<a name="370"><span class="lineNum">     370 </span>            :             // In this case the defining declaration might be the only declaration to be traversed and</a>
<a name="371"><span class="lineNum">     371 </span>            :             // so a set has not been built yet.</a>
<a name="372"><span class="lineNum">     372 </span>            : #if 0</a>
<a name="373"><span class="lineNum">     373 </span>            :                printf (&quot;In SageInterface::DeclarationSets::addDeclaration(): Adding set and declaration for the firstNondefiningDeclaration = %p = %s = %s \n&quot;,</a>
<a name="374"><span class="lineNum">     374 </span>            :                     firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str(),get_name(firstNondefiningDeclaration).c_str());</a>
<a name="375"><span class="lineNum">     375 </span>            : #endif</a>
<a name="376"><span class="lineNum">     376 </span>            : </a>
<a name="377"><span class="lineNum">     377 </span>            :             // DQ (4/5/2014): Just build the set and don't insert the firstNondefiningDeclaration.</a>
<a name="378"><span class="lineNum">     378 </span>            :             // If we were to do so then it would be an error to use the insert it later.</a>
<a name="379"><span class="lineNum">     379 </span>            :             // Note recursive call.</a>
<a name="380"><span class="lineNum">     380 </span>            :             // addDeclaration(firstNondefiningDeclaration);</a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">      27193 :                declarationMap[firstNondefiningDeclaration] = new set&lt;SgDeclarationStatement*&gt;();</span></a>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">      54386 :                ROSE_ASSERT (declarationMap.find(firstNondefiningDeclaration) != declarationMap.end());</span></a>
<a name="384"><span class="lineNum">     384 </span>            : </a>
<a name="385"><span class="lineNum">     385 </span>            :             // DQ (4/5/2014): We have to insert this since it is different from the firstNondefiningDeclaration.</a>
<a name="386"><span class="lineNum">     386 </span>            :             // Add the declaration to the existing set.</a>
<a name="387"><span class="lineNum">     387 </span><span class="lineCov">      27193 :                declarationMap[firstNondefiningDeclaration]-&gt;insert(decl);</span></a>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<a name="389"><span class="lineNum">     389 </span>            :             // DQ (4/5/2014): Added assertion.</a>
<a name="390"><span class="lineNum">     390 </span><span class="lineCov">      54386 :                ROSE_ASSERT(declarationMap[firstNondefiningDeclaration]-&gt;find(decl) != declarationMap[firstNondefiningDeclaration]-&gt;end());</span></a>
<a name="391"><span class="lineNum">     391 </span>            : #if 0</a>
<a name="392"><span class="lineNum">     392 </span>            :                printf (&quot;SageInterface::DeclarationSets::addDeclaration(): No set exists for the firstNondefiningDeclaration = %p = %s = %s \n&quot;,firstNondefiningDeclaration,firstNondefiningDeclaration-&gt;class_name().c_str(),get_name(firstNondefiningDeclaration).c_str());</a>
<a name="393"><span class="lineNum">     393 </span>            :                ROSE_ABORT();</a>
<a name="394"><span class="lineNum">     394 </span>            : #endif</a>
<a name="395"><span class="lineNum">     395 </span>            :              }</a>
<a name="396"><span class="lineNum">     396 </span>            :         }</a>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<a name="398"><span class="lineNum">     398 </span>            : #if 0</a>
<a name="399"><span class="lineNum">     399 </span>            :      printf (&quot;Leaving SageInterface::DeclarationSets::addDeclaration(): decl = %p = %s = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</a>
<a name="400"><span class="lineNum">     400 </span>            : #endif</a>
<a name="401"><span class="lineNum">     401 </span>            :    }</a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span>            : const std::set&lt;SgDeclarationStatement*&gt;*</a>
<a name="404"><span class="lineNum">     404 </span><span class="lineNoCov">          0 : SageInterface::DeclarationSets::getDeclarations(SgDeclarationStatement* decl)</span></a>
<a name="405"><span class="lineNum">     405 </span>            :    {</a>
<a name="406"><span class="lineNum">     406 </span>            :   // DQ (4/3/2014): This function returns the associated set of declarations.</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* firstNondefiningDeclaration = decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(declarationMap.find(firstNondefiningDeclaration) != declarationMap.end());</span></a>
<a name="410"><span class="lineNum">     410 </span>            : </a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :      const set&lt;SgDeclarationStatement*&gt;* declarationSet = declarationMap[firstNondefiningDeclaration];</span></a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span>            :   // return this-&gt;declarationMap[firstNondefiningDeclaration];</a>
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 :      return declarationSet;</span></a>
<a name="415"><span class="lineNum">     415 </span>            :    }</a>
<a name="416"><span class="lineNum">     416 </span>            : </a>
<a name="417"><span class="lineNum">     417 </span>            : std::map&lt;SgDeclarationStatement*,std::set&lt;SgDeclarationStatement*&gt;* &gt; &amp;</a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 : SageInterface::DeclarationSets::getDeclarationMap()</span></a>
<a name="419"><span class="lineNum">     419 </span>            :    {</a>
<a name="420"><span class="lineNum">     420 </span><span class="lineNoCov">          0 :      return declarationMap;</span></a>
<a name="421"><span class="lineNum">     421 </span>            :    }</a>
<a name="422"><span class="lineNum">     422 </span>            : </a>
<a name="423"><span class="lineNum">     423 </span>            : bool</a>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 : SageInterface::DeclarationSets::isLocatedInDefiningScope(SgDeclarationStatement* decl)</span></a>
<a name="425"><span class="lineNum">     425 </span>            :    {</a>
<a name="426"><span class="lineNum">     426 </span>            :   // DQ (4/7/2014): This function assumes that the input is a friend declaration.</a>
<a name="427"><span class="lineNum">     427 </span>            : </a>
<a name="428"><span class="lineNum">     428 </span>            :   // The existence of a declaration in a named scope (if a friend function) will cause</a>
<a name="429"><span class="lineNum">     429 </span>            :   // subsequent declarations to be qualified where name qualification is required.</a>
<a name="430"><span class="lineNum">     430 </span>            :   // A couple of issues:</a>
<a name="431"><span class="lineNum">     431 </span>            :   //    We likely need to keep track of the order of the declarations in the more</a>
<a name="432"><span class="lineNum">     432 </span>            :   //    complex cases because name qualification will be required after the declaration</a>
<a name="433"><span class="lineNum">     433 </span>            :   //    that appears in the named scope; but will not be required before the declaration in</a>
<a name="434"><span class="lineNum">     434 </span>            :   //    the named scope.</a>
<a name="435"><span class="lineNum">     435 </span>            : </a>
<a name="436"><span class="lineNum">     436 </span>            : #define DEBUG_LOCATED_IN_DEFINING_SCOPE 0</a>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<a name="438"><span class="lineNum">     438 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* firstNondefiningDeclaration = decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="439"><span class="lineNum">     439 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstNondefiningDeclaration != NULL);</span></a>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<a name="441"><span class="lineNum">     441 </span><span class="lineNoCov">          0 :      set&lt;SgDeclarationStatement*&gt;* declarationSet = declarationMap[firstNondefiningDeclaration];</span></a>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(declarationSet != NULL);</span></a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :      set&lt;SgDeclarationStatement*&gt;::iterator i = declarationSet-&gt;begin();</span></a>
<a name="445"><span class="lineNum">     445 </span>            : </a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :      bool isDefinedInNamedScope = false;</span></a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="449"><span class="lineNum">     449 </span>            :      printf (&quot;In DeclarationSets::isLocatedInDefiningScope(): decl = %p = %s \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="450"><span class="lineNum">     450 </span>            :      printf (&quot;   --- declarationSet-&gt;size()                        = %&quot; PRIuPTR &quot; \n&quot;,declarationSet-&gt;size());</a>
<a name="451"><span class="lineNum">     451 </span>            : #endif</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            :   // DQ (3/20/2016): this is reported by GNU as set but not used.</a>
<a name="454"><span class="lineNum">     454 </span>            :   // SgDeclarationStatement* associatedDeclaration = NULL;</a>
<a name="455"><span class="lineNum">     455 </span>            : </a>
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 :      while (isDefinedInNamedScope == false &amp;&amp; i != declarationSet-&gt;end())</span></a>
<a name="457"><span class="lineNum">     457 </span>            :         {</a>
<a name="458"><span class="lineNum">     458 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(*i != NULL);</span></a>
<a name="459"><span class="lineNum">     459 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="460"><span class="lineNum">     460 </span>            :           printf (&quot;   --- *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="461"><span class="lineNum">     461 </span>            : #endif</a>
<a name="462"><span class="lineNum">     462 </span>            :        // We want to know the structural position, not the semantic scope.</a>
<a name="463"><span class="lineNum">     463 </span><span class="lineNoCov">          0 :           SgScopeStatement* semantic_scope   = (*i)-&gt;get_scope();</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :           SgScopeStatement* structural_scope = isSgScopeStatement((*i)-&gt;get_parent());</span></a>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<a name="466"><span class="lineNum">     466 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="467"><span class="lineNum">     467 </span>            :           printf (&quot;   --- semantic_scope = %p = %s \n&quot;,semantic_scope,semantic_scope-&gt;class_name().c_str());</a>
<a name="468"><span class="lineNum">     468 </span>            :           printf (&quot;   --- structural_scope = %p = %s \n&quot;,structural_scope,structural_scope-&gt;class_name().c_str());</a>
<a name="469"><span class="lineNum">     469 </span>            : #endif</a>
<a name="470"><span class="lineNum">     470 </span>            :        // DQ (4/7/2014): If it is a member of a class then we don't consider the structural scope, else it makes a difference,</a>
<a name="471"><span class="lineNum">     471 </span><span class="lineNoCov">          0 :           SgScopeStatement* scope = isSgClassDefinition(semantic_scope) != NULL ? semantic_scope : structural_scope;</span></a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="475"><span class="lineNum">     475 </span>            :           printf (&quot;   --- scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="476"><span class="lineNum">     476 </span>            :           printf (&quot;   --- scope-&gt;isNamedScope() = %s \n&quot;,scope-&gt;isNamedScope() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="477"><span class="lineNum">     477 </span>            : #endif</a>
<a name="478"><span class="lineNum">     478 </span>            :        // if (scope-&gt;isNamedScope() == true)</a>
<a name="479"><span class="lineNum">     479 </span><span class="lineNoCov">          0 :           SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<a name="481"><span class="lineNum">     481 </span>            :        // Friend functions declared in the class definition are not meaningful for determining name qualification.</a>
<a name="482"><span class="lineNum">     482 </span>            :        // if (globalScope != NULL || scope-&gt;isNamedScope() == true)</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineNoCov">          0 :           if (globalScope != NULL || (scope-&gt;isNamedScope() == true &amp;&amp; isSgClassDefinition(structural_scope) == NULL) )</span></a>
<a name="484"><span class="lineNum">     484 </span>            :              {</a>
<a name="485"><span class="lineNum">     485 </span>            :             // Check if the function is output in the unparing, else it would not be defined.</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineNoCov">          0 :                bool willBeOutput = ((*i)-&gt;get_file_info()-&gt;isCompilerGenerated() == false ||</span></a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                       ((*i)-&gt;get_file_info()-&gt;isCompilerGenerated() &amp;&amp;</span></a>
<a name="488"><span class="lineNum">     488 </span><span class="lineNoCov">          0 :                                        (*i)-&gt;get_file_info()-&gt;isOutputInCodeGeneration()) );</span></a>
<a name="489"><span class="lineNum">     489 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="490"><span class="lineNum">     490 </span>            :                printf (&quot;   --- before: willBeOutput = %s \n&quot;,willBeOutput ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="491"><span class="lineNum">     491 </span>            : #endif</a>
<a name="492"><span class="lineNum">     492 </span>            :             // Being output only count when it is output where it is located structurally.</a>
<a name="493"><span class="lineNum">     493 </span><span class="lineNoCov">          0 :                willBeOutput = willBeOutput &amp;&amp; scope == structural_scope;</span></a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="496"><span class="lineNum">     496 </span>            :                printf (&quot;   --- after: willBeOutput = %s \n&quot;,willBeOutput ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="497"><span class="lineNum">     497 </span>            : #endif</a>
<a name="498"><span class="lineNum">     498 </span>            :             // DQ (3/20/2016): this is reported by GNU as set but not used.</a>
<a name="499"><span class="lineNum">     499 </span>            :             // associatedDeclaration = *i;</a>
<a name="500"><span class="lineNum">     500 </span>            : </a>
<a name="501"><span class="lineNum">     501 </span>            :             // isDefinedInNamedScope = true;</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineNoCov">          0 :                isDefinedInNamedScope = willBeOutput;</span></a>
<a name="503"><span class="lineNum">     503 </span>            :              }</a>
<a name="504"><span class="lineNum">     504 </span>            : </a>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="506"><span class="lineNum">     506 </span>            :         }</a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            : #if DEBUG_LOCATED_IN_DEFINING_SCOPE</a>
<a name="509"><span class="lineNum">     509 </span>            :      if (associatedDeclaration != NULL)</a>
<a name="510"><span class="lineNum">     510 </span>            :         {</a>
<a name="511"><span class="lineNum">     511 </span>            :           printf (&quot;Leaving DeclarationSets::isLocatedInDefiningScope(): associatedDeclaration = %p = %s \n&quot;,associatedDeclaration,associatedDeclaration-&gt;class_name().c_str());</a>
<a name="512"><span class="lineNum">     512 </span>            :         }</a>
<a name="513"><span class="lineNum">     513 </span>            :        else</a>
<a name="514"><span class="lineNum">     514 </span>            :         {</a>
<a name="515"><span class="lineNum">     515 </span>            :           printf (&quot;Leaving DeclarationSets::isLocatedInDefiningScope(): associatedDeclaration = %p \n&quot;,associatedDeclaration);</a>
<a name="516"><span class="lineNum">     516 </span>            :         }</a>
<a name="517"><span class="lineNum">     517 </span>            : #endif</a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span><span class="lineNoCov">          0 :      return isDefinedInNamedScope;</span></a>
<a name="520"><span class="lineNum">     520 </span>            :    }</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span>            : SageInterface::DeclarationSets*</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">         66 : SageInterface::buildDeclarationSets(SgNode* n)</span></a>
<a name="524"><span class="lineNum">     524 </span>            :    {</a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">         66 :      DeclarationSets* declarationSet = new DeclarationSets();</span></a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span><span class="lineNoCov">          0 :      class DeclarationSetTraversal : public AstSimpleProcessing</span></a>
<a name="528"><span class="lineNum">     528 </span>            :         {</a>
<a name="529"><span class="lineNum">     529 </span>            :           private:</a>
<a name="530"><span class="lineNum">     530 </span>            :                DeclarationSets* declarationSet;</a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span>            :           public:</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">        132 :                DeclarationSetTraversal(DeclarationSets* ds) : declarationSet(ds) {}</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">    1834030 :                void visit (SgNode* node)</span></a>
<a name="535"><span class="lineNum">     535 </span>            :                   {</a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">    1834030 :                     SgDeclarationStatement* decl = isSgDeclarationStatement(node);</span></a>
<a name="537"><span class="lineNum">     537 </span><span class="lineCov">    1834030 :                     if (decl != NULL)</span></a>
<a name="538"><span class="lineNum">     538 </span>            :                        {</a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">     676218 :                          declarationSet-&gt;addDeclaration(decl);</span></a>
<a name="540"><span class="lineNum">     540 </span>            :                        }</a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">    1834030 :                   }</span></a>
<a name="542"><span class="lineNum">     542 </span>            :         };</a>
<a name="543"><span class="lineNum">     543 </span>            : </a>
<a name="544"><span class="lineNum">     544 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">         66 :      DeclarationSetTraversal traversal(declarationSet);</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">         66 :      traversal.traverse(n, preorder);</span></a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">         66 :      return declarationSet;</span></a>
<a name="549"><span class="lineNum">     549 </span>            :    }</a>
<a name="550"><span class="lineNum">     550 </span>            : </a>
<a name="551"><span class="lineNum">     551 </span>            : int SageInterface::gensym_counter = 0;</a>
<a name="552"><span class="lineNum">     552 </span>            : // DQ: 09/23/03</a>
<a name="553"><span class="lineNum">     553 </span>            : // We require a global function for getting the string associated</a>
<a name="554"><span class="lineNum">     554 </span>            : // with the definition of a variant (which is a global enum).</a>
<a name="555"><span class="lineNum">     555 </span><span class="lineCov">     158473 : string getVariantName ( VariantT v )</span></a>
<a name="556"><span class="lineNum">     556 </span>            :    {</a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">     158473 :      ROSE_ASSERT( int(v) &lt; int(V_SgNumVariants));</span></a>
<a name="558"><span class="lineNum">     558 </span>            : </a>
<a name="559"><span class="lineNum">     559 </span>            :   // This code is far simpler (if the function is static)</a>
<a name="560"><span class="lineNum">     560 </span>            : </a>
<a name="561"><span class="lineNum">     561 </span>            :   // DQ (4/8/2004): Modified code to use new global list of sage</a>
<a name="562"><span class="lineNum">     562 </span>            :   // class names (simpler this way)</a>
<a name="563"><span class="lineNum">     563 </span>            :   // return string(SgTreeTraversal&lt;int,int&gt;::get_variantName(v));</a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">     158473 :      extern const char* roseGlobalVariantNameList[];</span></a>
<a name="565"><span class="lineNum">     565 </span><span class="lineCov">     158473 :      return string(roseGlobalVariantNameList[v]);</span></a>
<a name="566"><span class="lineNum">     566 </span>            :    }</a>
<a name="567"><span class="lineNum">     567 </span>            : </a>
<a name="568"><span class="lineNum">     568 </span>            : bool</a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">    4414710 : SageInterface::hasTemplateSyntax( const SgName &amp; name )</span></a>
<a name="570"><span class="lineNum">     570 </span>            :    {</a>
<a name="571"><span class="lineNum">     571 </span>            :   // DQ (6/7/2012): This refactors the test for template instantiation syntax in names used for classes, member functions, and functions</a>
<a name="572"><span class="lineNum">     572 </span><span class="lineCov">    4414710 :      bool usingTemplateSyntax = false;</span></a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">    4414710 :      string nameString = name.getString();</span></a>
<a name="574"><span class="lineNum">     574 </span>            : </a>
<a name="575"><span class="lineNum">     575 </span>            :   // DQ (6/7/2012): We need to avoid the identification of the &quot;operator&lt;()&quot; as valid template syntax.</a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">    4414710 :      usingTemplateSyntax = (nameString.find('&lt;') != string::npos) &amp;&amp; (nameString.find('&gt;') != string::npos);</span></a>
<a name="577"><span class="lineNum">     577 </span>            : </a>
<a name="578"><span class="lineNum">     578 </span>            :   // DQ (5/10/2016): Debugging case of C++11 using the Intel v16 compiler and it's associated mutex header file.</a>
<a name="579"><span class="lineNum">     579 </span>            :   // See Cxx11_tests/test2016_32.C for an example that demonstrates this problem.</a>
<a name="580"><span class="lineNum">     580 </span><span class="lineCov">    4414710 :      if (nameString == &quot;&lt;unnamed&gt;&quot;)</span></a>
<a name="581"><span class="lineNum">     581 </span>            :         {</a>
<a name="582"><span class="lineNum">     582 </span><span class="lineNoCov">          0 :           printf (&quot;In SageInterface::hasTemplateSyntax(): Identified case of name == &lt;unnamed&gt; \n&quot;);</span></a>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<a name="584"><span class="lineNum">     584 </span>            :           usingTemplateSyntax = false;</a>
<a name="585"><span class="lineNum">     585 </span>            :         }</a>
<a name="586"><span class="lineNum">     586 </span>            : </a>
<a name="587"><span class="lineNum">     587 </span>            :   // return (name.getString().find('&lt;') == string::npos);</a>
<a name="588"><span class="lineNum">     588 </span><span class="lineCov">    5677630 :      return usingTemplateSyntax;</span></a>
<a name="589"><span class="lineNum">     589 </span>            :    }</a>
<a name="590"><span class="lineNum">     590 </span>            : </a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            : void</a>
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">          1 : SageInterface::whereAmI(SgNode* node)</span></a>
<a name="595"><span class="lineNum">     595 </span>            :    {</a>
<a name="596"><span class="lineNum">     596 </span>            :   // DQ (2/12/2012): Refactoring disagnostic support for detecting where we are when something fails.</a>
<a name="597"><span class="lineNum">     597 </span>            : </a>
<a name="598"><span class="lineNum">     598 </span>            :   // This highest level node acceptable for us by this function is a SgGlobal (global scope).</a>
<a name="599"><span class="lineNum">     599 </span>            : </a>
<a name="600"><span class="lineNum">     600 </span><span class="lineCov">          1 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="601"><span class="lineNum">     601 </span>            : //     printf (&quot;Inside of SageInterface::whereAmI(node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span>            :   // Enforce that some IR nodes should not be acepted inputs.</a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">          1 :      ROSE_ASSERT(isSgFile(node)     == NULL);</span></a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">          1 :      ROSE_ASSERT(isSgFileList(node) == NULL);</span></a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">          1 :      ROSE_ASSERT(isSgProject(node)  == NULL);</span></a>
<a name="607"><span class="lineNum">     607 </span>            : </a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">          1 :      SgNode* parent = node-&gt;get_parent();</span></a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            :   // Don't traverse past the SgFile level.</a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">          6 :      while (parent != NULL &amp;&amp; isSgFileList(parent) == NULL)</span></a>
<a name="612"><span class="lineNum">     612 </span>            :         {</a>
<a name="613"><span class="lineNum">     613 </span>            :        // DQ (7/14/2019): These were commented out, but they are intended for debugging, so</a>
<a name="614"><span class="lineNum">     614 </span>            :        // if someone does not need thi output then the function should not have been called.</a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">          5 :           printf (&quot;--- parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</span></a>
<a name="616"><span class="lineNum">     616 </span>            : </a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">          5 :           ROSE_ASSERT(parent-&gt;get_file_info() != NULL);</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">          5 :           parent-&gt;get_file_info()-&gt;display(&quot;In SageInterface::whereAmI() diagnostics support&quot;);</span></a>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">          5 :           parent = parent-&gt;get_parent();</span></a>
<a name="621"><span class="lineNum">     621 </span>            :         }</a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">          1 :    }</span></a>
<a name="623"><span class="lineNum">     623 </span>            : </a>
<a name="624"><span class="lineNum">     624 </span>            : void</a>
<a name="625"><span class="lineNum">     625 </span><span class="lineCov">       5313 : SageInterface::initializeIfStmt(SgIfStmt *ifstmt, SgStatement* conditional, SgStatement * true_body, SgStatement * false_body)</span></a>
<a name="626"><span class="lineNum">     626 </span>            :    {</a>
<a name="627"><span class="lineNum">     627 </span>            :   // DQ (2/13/2012): Added new function to support proper initialization of a SgIfStmt that has already been built.</a>
<a name="628"><span class="lineNum">     628 </span>            :   // This is important when we have to build the scope ahead of the test becasue the text contains a simple</a>
<a name="629"><span class="lineNum">     629 </span>            :   // declaration (which must be put into the SgIfStmt scope).</a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            :   // SgIfStmt *ifstmt = new SgIfStmt(conditional, true_body, false_body);</a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">       5313 :      ROSE_ASSERT(ifstmt);</span></a>
<a name="633"><span class="lineNum">     633 </span>            : </a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">       5313 :      if (ifstmt-&gt;get_conditional() == NULL)</span></a>
<a name="635"><span class="lineNum">     635 </span><span class="lineCov">       5313 :           ifstmt-&gt;set_conditional(conditional);</span></a>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<a name="637"><span class="lineNum">     637 </span><span class="lineCov">       5313 :      if (ifstmt-&gt;get_true_body() == NULL)</span></a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">       5313 :           ifstmt-&gt;set_true_body(true_body);</span></a>
<a name="639"><span class="lineNum">     639 </span>            : </a>
<a name="640"><span class="lineNum">     640 </span><span class="lineCov">       5313 :      if (ifstmt-&gt;get_false_body() == NULL)</span></a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">       5313 :           ifstmt-&gt;set_false_body(false_body);</span></a>
<a name="642"><span class="lineNum">     642 </span>            : </a>
<a name="643"><span class="lineNum">     643 </span>            :   // Rasmussen (3/22/2020): Fixed setting case insensitivity</a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">       5313 :      if (is_language_case_insensitive())</span></a>
<a name="645"><span class="lineNum">     645 </span><span class="lineNoCov">          0 :          ifstmt-&gt;setCaseInsensitive(true);</span></a>
<a name="646"><span class="lineNum">     646 </span>            : </a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">       5313 :      setOneSourcePositionNull(ifstmt);</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">       5313 :      if (conditional) conditional-&gt;set_parent(ifstmt);</span></a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">       5313 :      if (true_body) true_body-&gt;set_parent(ifstmt);</span></a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">       5313 :      if (false_body) false_body-&gt;set_parent(ifstmt);</span></a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">       5313 :    }</span></a>
<a name="652"><span class="lineNum">     652 </span>            : </a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span>            : void</a>
<a name="655"><span class="lineNum">     655 </span><span class="lineNoCov">          0 : SageInterface::initializeSwitchStatement(SgSwitchStatement* switchStatement,SgStatement *item_selector,SgStatement *body)</span></a>
<a name="656"><span class="lineNum">     656 </span>            :    {</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(switchStatement != NULL);</span></a>
<a name="658"><span class="lineNum">     658 </span>            : </a>
<a name="659"><span class="lineNum">     659 </span>            :   // Rasmussen (3/22/2020): Fixed setting case insensitivity</a>
<a name="660"><span class="lineNum">     660 </span><span class="lineNoCov">          0 :      if (is_language_case_insensitive())</span></a>
<a name="661"><span class="lineNum">     661 </span><span class="lineNoCov">          0 :           switchStatement-&gt;setCaseInsensitive(true);</span></a>
<a name="662"><span class="lineNum">     662 </span>            : </a>
<a name="663"><span class="lineNum">     663 </span><span class="lineNoCov">          0 :      if (switchStatement-&gt;get_item_selector() == NULL)</span></a>
<a name="664"><span class="lineNum">     664 </span><span class="lineNoCov">          0 :           switchStatement-&gt;set_item_selector(item_selector);</span></a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span><span class="lineNoCov">          0 :      if (switchStatement-&gt;get_body() == NULL)</span></a>
<a name="667"><span class="lineNum">     667 </span><span class="lineNoCov">          0 :           switchStatement-&gt;set_body(body);</span></a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span><span class="lineNoCov">          0 :      setOneSourcePositionForTransformation(switchStatement);</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineNoCov">          0 :      if (item_selector != NULL)</span></a>
<a name="671"><span class="lineNum">     671 </span><span class="lineNoCov">          0 :           item_selector-&gt;set_parent(switchStatement);</span></a>
<a name="672"><span class="lineNum">     672 </span><span class="lineNoCov">          0 :      if (body != NULL)</span></a>
<a name="673"><span class="lineNum">     673 </span><span class="lineNoCov">          0 :           body-&gt;set_parent(switchStatement);</span></a>
<a name="674"><span class="lineNum">     674 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="675"><span class="lineNum">     675 </span>            : </a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span>            : void</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">        414 : SageInterface::initializeWhileStatement(SgWhileStmt* whileStatement, SgStatement *  condition, SgStatement *body, SgStatement *else_body)</span></a>
<a name="679"><span class="lineNum">     679 </span>            :    {</a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">        414 :      ROSE_ASSERT(whileStatement);</span></a>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<a name="682"><span class="lineNum">     682 </span>            :   // Rasmussen (3/22/2020): Fixed setting case insensitivity</a>
<a name="683"><span class="lineNum">     683 </span><span class="lineCov">        414 :      if (is_language_case_insensitive())</span></a>
<a name="684"><span class="lineNum">     684 </span><span class="lineNoCov">          0 :           whileStatement-&gt;setCaseInsensitive(true);</span></a>
<a name="685"><span class="lineNum">     685 </span>            : </a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">        414 :      if (whileStatement-&gt;get_condition() == NULL)</span></a>
<a name="687"><span class="lineNum">     687 </span><span class="lineCov">        414 :           whileStatement-&gt;set_condition(condition);</span></a>
<a name="688"><span class="lineNum">     688 </span><span class="lineCov">        414 :      if (whileStatement-&gt;get_body() == NULL)</span></a>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">        414 :           whileStatement-&gt;set_body(body);</span></a>
<a name="690"><span class="lineNum">     690 </span>            : </a>
<a name="691"><span class="lineNum">     691 </span>            :   // Python support.</a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">        414 :      if (whileStatement-&gt;get_else_body() == NULL)</span></a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">        414 :           whileStatement-&gt;set_else_body(else_body);</span></a>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<a name="695"><span class="lineNum">     695 </span><span class="lineCov">        414 :      setOneSourcePositionNull(whileStatement);</span></a>
<a name="696"><span class="lineNum">     696 </span><span class="lineCov">        414 :      if (condition) condition-&gt;set_parent(whileStatement);</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">        414 :      if (body) body-&gt;set_parent(whileStatement);</span></a>
<a name="698"><span class="lineNum">     698 </span>            : </a>
<a name="699"><span class="lineNum">     699 </span>            :   // DQ (8/10/2011): This is added by Michael to support a Python specific feature.</a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">        414 :      if (else_body != NULL)</span></a>
<a name="701"><span class="lineNum">     701 </span>            :         {</a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :           whileStatement-&gt;set_else_body(else_body);</span></a>
<a name="703"><span class="lineNum">     703 </span><span class="lineNoCov">          0 :           else_body-&gt;set_parent(whileStatement);</span></a>
<a name="704"><span class="lineNum">     704 </span>            :         }</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">        414 :    }</span></a>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span>            : </a>
<a name="709"><span class="lineNum">     709 </span>            : SgNamespaceDefinitionStatement*</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">      48495 : SageInterface::enclosingNamespaceScope( SgDeclarationStatement* declaration )</span></a>
<a name="711"><span class="lineNum">     711 </span>            :    {</a>
<a name="712"><span class="lineNum">     712 </span>            :   // DQ (11/4/2007): This function is used in the markTemplateInstantiationsForOutput.C</a>
<a name="713"><span class="lineNum">     713 </span>            : </a>
<a name="714"><span class="lineNum">     714 </span>            :   // This function returns the namespace associated with any declaration.</a>
<a name="715"><span class="lineNum">     715 </span>            :   // If the declaration is nested inside of other scopes this function</a>
<a name="716"><span class="lineNum">     716 </span>            :   // iterates through these scopes to get the the first namespace.</a>
<a name="717"><span class="lineNum">     717 </span>            :   // This is important for details of template handling, namely making sure</a>
<a name="718"><span class="lineNum">     718 </span>            :   // that the template specializations (generated by ROSE) are put into the</a>
<a name="719"><span class="lineNum">     719 </span>            :   // correct location (namespace) since stricted rules in gnu now enforce</a>
<a name="720"><span class="lineNum">     720 </span>            :   // these details.  If the declaration is not in a namespace as computed</a>
<a name="721"><span class="lineNum">     721 </span>            :   // in the chain of scopes then this function returns NULL.</a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span><span class="lineCov">      48495 :      ROSE_ASSERT(declaration != NULL);</span></a>
<a name="724"><span class="lineNum">     724 </span><span class="lineCov">      48495 :      SgScopeStatement* tempScope = declaration-&gt;get_scope();</span></a>
<a name="725"><span class="lineNum">     725 </span>            : </a>
<a name="726"><span class="lineNum">     726 </span>            :   // Loop back to the first namespace or stop at global scope (stop on either a namespace or the global scope)</a>
<a name="727"><span class="lineNum">     727 </span><span class="lineCov">      92060 :      while ( isSgNamespaceDefinitionStatement(tempScope) == NULL &amp;&amp; isSgGlobal(tempScope) == NULL )</span></a>
<a name="728"><span class="lineNum">     728 </span>            :         {</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">      43565 :           tempScope = tempScope-&gt;get_scope();</span></a>
<a name="730"><span class="lineNum">     730 </span><span class="lineCov">      43565 :           ROSE_ASSERT(tempScope != NULL);</span></a>
<a name="731"><span class="lineNum">     731 </span>            : #if 0</a>
<a name="732"><span class="lineNum">     732 </span>            :           printf (&quot;Iterating back through scopes: tempScope = %p = %s = %s \n&quot;,tempScope,tempScope-&gt;class_name().c_str(),SageInterface::get_name(tempScope).c_str());</a>
<a name="733"><span class="lineNum">     733 </span>            : #endif</a>
<a name="734"><span class="lineNum">     734 </span>            :         }</a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span><span class="lineCov">      48495 :      SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(tempScope);</span></a>
<a name="737"><span class="lineNum">     737 </span><span class="lineCov">      48495 :      return namespaceScope;</span></a>
<a name="738"><span class="lineNum">     738 </span>            :    }</a>
<a name="739"><span class="lineNum">     739 </span>            : </a>
<a name="740"><span class="lineNum">     740 </span>            : </a>
<a name="741"><span class="lineNum">     741 </span>            : SgDeclarationStatement*</a>
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 : SageInterface::getNonInstantiatonDeclarationForClass ( SgTemplateInstantiationMemberFunctionDecl* memberFunctionInstantiation )</span></a>
<a name="743"><span class="lineNum">     743 </span>            :    {</a>
<a name="744"><span class="lineNum">     744 </span>            :   // DQ (11/4/2007): This function is used in the markTemplateInstantiationsForOutput.C</a>
<a name="745"><span class="lineNum">     745 </span>            :   // DQ (11/4/2007): Get the associated declaration that will be in the original source code,</a>
<a name="746"><span class="lineNum">     746 </span>            :   // if it is part of a template instantiation then get the original template declaration.</a>
<a name="747"><span class="lineNum">     747 </span>            : </a>
<a name="748"><span class="lineNum">     748 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* parentDeclaration = NULL;</span></a>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<a name="750"><span class="lineNum">     750 </span><span class="lineNoCov">          0 :      SgScopeStatement* defn = memberFunctionInstantiation-&gt;get_class_scope();</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(defn != NULL);</span></a>
<a name="752"><span class="lineNum">     752 </span>            : </a>
<a name="753"><span class="lineNum">     753 </span>            :   // SgTemplateDeclaration* templateDeclaration = memberFunctionInstantiation-&gt;get_templateDeclaration();</a>
<a name="754"><span class="lineNum">     754 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* templateDeclaration = memberFunctionInstantiation-&gt;get_templateDeclaration();</span></a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(templateDeclaration != NULL);</span></a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span>            :   // If it is a template instatiation, then we have to find the temple declaration (not the template instantiation declaration), else we want the class declaration.</a>
<a name="758"><span class="lineNum">     758 </span><span class="lineNoCov">          0 :      SgClassDefinition* cdefn = isSgClassDefinition(defn);</span></a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :      SgDeclarationScope* nrscope = isSgDeclarationScope(defn);</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :      SgTemplateInstantiationDefn* templateInstatiationClassDefinition = isSgTemplateInstantiationDefn(defn);</span></a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :      if (templateInstatiationClassDefinition != NULL)</span></a>
<a name="762"><span class="lineNum">     762 </span>            :         {</a>
<a name="763"><span class="lineNum">     763 </span>            :        // This is the case of a template member function in a templated class (see test2005_172.C).</a>
<a name="764"><span class="lineNum">     764 </span><span class="lineNoCov">          0 :           SgTemplateInstantiationDefn* parentTemplateInstantiationDefinition = isSgTemplateInstantiationDefn(templateDeclaration-&gt;get_scope());</span></a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parentTemplateInstantiationDefinition != NULL);</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :           SgTemplateInstantiationDecl* parentTemplateInstantiationDeclaration = isSgTemplateInstantiationDecl(parentTemplateInstantiationDefinition-&gt;get_declaration());</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parentTemplateInstantiationDeclaration != NULL);</span></a>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<a name="769"><span class="lineNum">     769 </span><span class="lineNoCov">          0 :           parentDeclaration = parentTemplateInstantiationDeclaration-&gt;get_templateDeclaration();</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parentDeclaration != NULL);</span></a>
<a name="771"><span class="lineNum">     771 </span>            :         }</a>
<a name="772"><span class="lineNum">     772 </span><span class="lineNoCov">          0 :        else if (cdefn != NULL)</span></a>
<a name="773"><span class="lineNum">     773 </span>            :         {</a>
<a name="774"><span class="lineNum">     774 </span>            :        // This is the case of a template member function in a class definition (see test2005_168.C).</a>
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 :           parentDeclaration = cdefn-&gt;get_declaration();</span></a>
<a name="776"><span class="lineNum">     776 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parentDeclaration != NULL);</span></a>
<a name="777"><span class="lineNum">     777 </span>            :         }</a>
<a name="778"><span class="lineNum">     778 </span><span class="lineNoCov">          0 :        else if (nrscope != NULL)</span></a>
<a name="779"><span class="lineNum">     779 </span>            :         {</a>
<a name="780"><span class="lineNum">     780 </span><span class="lineNoCov">          0 :           parentDeclaration = isSgDeclarationStatement(nrscope-&gt;get_parent());</span></a>
<a name="781"><span class="lineNum">     781 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parentDeclaration != NULL);</span></a>
<a name="782"><span class="lineNum">     782 </span>            :         }</a>
<a name="783"><span class="lineNum">     783 </span>            :        else</a>
<a name="784"><span class="lineNum">     784 </span>            :         {</a>
<a name="785"><span class="lineNum">     785 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="786"><span class="lineNum">     786 </span>            :         }</a>
<a name="787"><span class="lineNum">     787 </span>            : </a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :       return parentDeclaration;</span></a>
<a name="789"><span class="lineNum">     789 </span>            :    }</a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span>            : //! Liao, 11/9/2009</a>
<a name="792"><span class="lineNum">     792 </span>            :   //! A better version for SgVariableDeclaration::set_baseTypeDefininingDeclaration(), handling all side effects automatically</a>
<a name="793"><span class="lineNum">     793 </span>            :   //! Used to have a struct declaration embedded into a variable declaration</a>
<a name="794"><span class="lineNum">     794 </span>            : void</a>
<a name="795"><span class="lineNum">     795 </span><span class="lineCov">          1 : SageInterface::setBaseTypeDefiningDeclaration(SgVariableDeclaration* var_decl, SgDeclarationStatement *base_decl)</span></a>
<a name="796"><span class="lineNum">     796 </span>            : {</a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">          1 :   ROSE_ASSERT (var_decl &amp;&amp; base_decl);</span></a>
<a name="798"><span class="lineNum">     798 </span>            : </a>
<a name="799"><span class="lineNum">     799 </span>            :   // try to remove it from the scope's declaration list</a>
<a name="800"><span class="lineNum">     800 </span>            :   // If the struct decl was previously inserted into its scope</a>
<a name="801"><span class="lineNum">     801 </span><span class="lineCov">          1 :   if (base_decl-&gt;get_parent() != NULL)</span></a>
<a name="802"><span class="lineNum">     802 </span>            :   {</a>
<a name="803"><span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (base_decl-&gt;get_scope() == base_decl-&gt;get_parent())</span></a>
<a name="804"><span class="lineNum">     804 </span>            :     {</a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :       SgStatementPtrList stmt_list = base_decl-&gt;get_scope()-&gt;generateStatementList();</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :       if (find(stmt_list.begin(), stmt_list.end(), base_decl) != stmt_list.end())</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 :         SageInterface::removeStatement(base_decl);</span></a>
<a name="808"><span class="lineNum">     808 </span>            :     }</a>
<a name="809"><span class="lineNum">     809 </span>            :   }</a>
<a name="810"><span class="lineNum">     810 </span><span class="lineCov">          1 :   base_decl-&gt;set_parent(var_decl);</span></a>
<a name="811"><span class="lineNum">     811 </span><span class="lineCov">          1 :   var_decl-&gt;set_baseTypeDefiningDeclaration(base_decl);</span></a>
<a name="812"><span class="lineNum">     812 </span>            : </a>
<a name="813"><span class="lineNum">     813 </span>            :   //Set an internal mangled name for the anonymous declaration, if necessary</a>
<a name="814"><span class="lineNum">     814 </span>            :   //  resetNamesInAST(); // this will trigger mangleNameMap.size() ==0 assertion.</a>
<a name="815"><span class="lineNum">     815 </span>            :   // We call resetEmptyNames directly instead.</a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">          2 :   ResetEmptyNames t1;</span></a>
<a name="817"><span class="lineNum">     817 </span><span class="lineCov">          1 :   t1.traverseMemoryPool();</span></a>
<a name="818"><span class="lineNum">     818 </span><span class="lineCov">          1 : }</span></a>
<a name="819"><span class="lineNum">     819 </span>            : </a>
<a name="820"><span class="lineNum">     820 </span>            : // DQ (11/4/2007): This looks for a forward temple member function declaration of matching name exists in the specified scope.</a>
<a name="821"><span class="lineNum">     821 </span>            : bool</a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">      10760 : SageInterface::isPrototypeInScope ( SgScopeStatement* scope, SgFunctionDeclaration* functionDeclaration, SgDeclarationStatement* startingAtDeclaration )</span></a>
<a name="823"><span class="lineNum">     823 </span>            :    {</a>
<a name="824"><span class="lineNum">     824 </span>            :   // DQ (11/3/2007): Look for an existing previously inserted (or existing) template member function declaration and only add one if we can't find it.</a>
<a name="825"><span class="lineNum">     825 </span>            : </a>
<a name="826"><span class="lineNum">     826 </span><span class="lineCov">      10760 :      bool foundExistingPrototype = false;</span></a>
<a name="827"><span class="lineNum">     827 </span>            : </a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">      10760 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">      10760 :      ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="830"><span class="lineNum">     830 </span><span class="lineCov">      10760 :      ROSE_ASSERT(startingAtDeclaration != NULL);</span></a>
<a name="831"><span class="lineNum">     831 </span>            : </a>
<a name="832"><span class="lineNum">     832 </span>            :   // TV (09/17/2018): ROSE-1378</a>
<a name="833"><span class="lineNum">     833 </span><span class="lineCov">      10760 :      if (isSgDeclarationScope(scope)) {</span></a>
<a name="834"><span class="lineNum">     834 </span><span class="lineCov">        279 :        printf(&quot;TODO: SgDeclarationScope handling in SageInterface::isPrototypeInScope see ROSE-1378\n&quot;);</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineCov">        279 :        return false;</span></a>
<a name="836"><span class="lineNum">     836 </span>            :      }</a>
<a name="837"><span class="lineNum">     837 </span>            : </a>
<a name="838"><span class="lineNum">     838 </span>            :   // These are the scopes for which get_declarationList() is properly defined.</a>
<a name="839"><span class="lineNum">     839 </span><span class="lineCov">      10481 :      ROSE_ASSERT(scope-&gt;containsOnlyDeclarations() == true);</span></a>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<a name="841"><span class="lineNum">     841 </span>            :   // Note that this is only defined for certain scopes, but we only want it for THOSE scopes</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">      10481 :      SgDeclarationStatementPtrList &amp; declarationList = scope-&gt;getDeclarationList();</span></a>
<a name="843"><span class="lineNum">     843 </span>            : </a>
<a name="844"><span class="lineNum">     844 </span>            :   // This is a simple way to restrict the evaluation (still linear, but jumps to initial position to start search).</a>
<a name="845"><span class="lineNum">     845 </span><span class="lineCov">      10481 :      SgDeclarationStatementPtrList::iterator startingLocation = find(declarationList.begin(),declarationList.end(),startingAtDeclaration);</span></a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span><span class="lineCov">      10481 :      if (startingLocation != declarationList.end())</span></a>
<a name="848"><span class="lineNum">     848 </span>            :         {</a>
<a name="849"><span class="lineNum">     849 </span>            : #if 0</a>
<a name="850"><span class="lineNum">     850 </span>            :           printf (&quot;startingLocation = %p = %s = %s \n&quot;,*startingLocation,(*startingLocation)-&gt;class_name().c_str(),SageInterface::get_name(*startingLocation).c_str());</a>
<a name="851"><span class="lineNum">     851 </span>            : #endif</a>
<a name="852"><span class="lineNum">     852 </span>            :        // printf (&quot;Found the startingLocation is the global scope, now check if we need to add a new declaration \n&quot;);</a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">       7352 :           SgDeclarationStatementPtrList::iterator i = startingLocation;</span></a>
<a name="854"><span class="lineNum">     854 </span><span class="lineCov">       7352 :           SgScopeStatement* targetScope = functionDeclaration-&gt;get_scope();</span></a>
<a name="855"><span class="lineNum">     855 </span><span class="lineCov">      14704 :           SgName targetName = functionDeclaration-&gt;get_name();</span></a>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<a name="857"><span class="lineNum">     857 </span><span class="lineCov">   15482000 :           while (i != declarationList.end())</span></a>
<a name="858"><span class="lineNum">     858 </span>            :              {</a>
<a name="859"><span class="lineNum">     859 </span>            :             // printf (&quot;i = %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),SageInterface::get_name(*i).c_str());</a>
<a name="860"><span class="lineNum">     860 </span>            : </a>
<a name="861"><span class="lineNum">     861 </span>            :             // Look for a prototype like what we want to insert, if we find it then we don't need to add a second one!</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineCov">   15476100 :                SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(*i);</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineCov">   15476100 :                if (templateMemberFunction != NULL)</span></a>
<a name="864"><span class="lineNum">     864 </span>            :                   {</a>
<a name="865"><span class="lineNum">     865 </span>            :                  // Check the name and the scope</a>
<a name="866"><span class="lineNum">     866 </span>            :                  // if (memberFunctionInstantiation-&gt;get_scope() == templateMemberFunction-&gt;get_scope())</a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">     780789 :                     if (targetScope == templateMemberFunction-&gt;get_scope())</span></a>
<a name="868"><span class="lineNum">     868 </span>            :                        {</a>
<a name="869"><span class="lineNum">     869 </span>            :                       // printf (&quot;Testing member function = %s against member function = %s \n&quot;,memberFunctionInstantiation-&gt;get_name().str(),templateMemberFunction-&gt;get_name().str());</a>
<a name="870"><span class="lineNum">     870 </span>            :                       // if (memberFunctionInstantiation-&gt;get_name() == templateMemberFunction-&gt;get_name())</a>
<a name="871"><span class="lineNum">     871 </span><span class="lineCov">       4159 :                          if (targetName == templateMemberFunction-&gt;get_name())</span></a>
<a name="872"><span class="lineNum">     872 </span>            :                             {</a>
<a name="873"><span class="lineNum">     873 </span>            :                            // Don't count the defining declaration which may be at the end of the global scope.</a>
<a name="874"><span class="lineNum">     874 </span><span class="lineCov">       1483 :                               if (templateMemberFunction-&gt;isForward() == true)</span></a>
<a name="875"><span class="lineNum">     875 </span>            :                                  {</a>
<a name="876"><span class="lineNum">     876 </span>            :                                    foundExistingPrototype = true;</a>
<a name="877"><span class="lineNum">     877 </span>            : </a>
<a name="878"><span class="lineNum">     878 </span>            :                                 // Exit the loop (optimization)</a>
<a name="879"><span class="lineNum">     879 </span>            :                                    break;</a>
<a name="880"><span class="lineNum">     880 </span>            :                                  }</a>
<a name="881"><span class="lineNum">     881 </span>            :                             }</a>
<a name="882"><span class="lineNum">     882 </span>            :                        }</a>
<a name="883"><span class="lineNum">     883 </span>            :                   }</a>
<a name="884"><span class="lineNum">     884 </span>            : </a>
<a name="885"><span class="lineNum">     885 </span><span class="lineCov">   15474600 :                i++;</span></a>
<a name="886"><span class="lineNum">     886 </span>            :              }</a>
<a name="887"><span class="lineNum">     887 </span>            :         }</a>
<a name="888"><span class="lineNum">     888 </span>            : </a>
<a name="889"><span class="lineNum">     889 </span>            :      return foundExistingPrototype;</a>
<a name="890"><span class="lineNum">     890 </span>            :    }</a>
<a name="891"><span class="lineNum">     891 </span>            : </a>
<a name="892"><span class="lineNum">     892 </span>            : bool</a>
<a name="893"><span class="lineNum">     893 </span><span class="lineCov">      10317 : SageInterface::isAncestor (SgNode* node1, SgNode* node2)</span></a>
<a name="894"><span class="lineNum">     894 </span>            :    {</a>
<a name="895"><span class="lineNum">     895 </span><span class="lineCov">      10317 :      ROSE_ASSERT(node1 &amp;&amp; node2);</span></a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span><span class="lineCov">      10317 :      SgNode* curnode = node2;</span></a>
<a name="898"><span class="lineNum">     898 </span><span class="lineCov">      10317 :      if (node1==node2)</span></a>
<a name="899"><span class="lineNum">     899 </span>            :         {</a>
<a name="900"><span class="lineNum">     900 </span>            :          return false;</a>
<a name="901"><span class="lineNum">     901 </span>            :         }</a>
<a name="902"><span class="lineNum">     902 </span>            : </a>
<a name="903"><span class="lineNum">     903 </span><span class="lineCov">      41244 :      do {</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineCov">      41244 :           curnode= curnode-&gt;get_parent();</span></a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">      41244 :         } while( (curnode!=NULL)&amp;&amp;(curnode!=node1));</span></a>
<a name="906"><span class="lineNum">     906 </span>            : </a>
<a name="907"><span class="lineNum">     907 </span><span class="lineCov">      10317 :      if (curnode==node1)</span></a>
<a name="908"><span class="lineNum">     908 </span>            :         {</a>
<a name="909"><span class="lineNum">     909 </span>            :           return true;</a>
<a name="910"><span class="lineNum">     910 </span>            :         }</a>
<a name="911"><span class="lineNum">     911 </span>            :        else</a>
<a name="912"><span class="lineNum">     912 </span>            :         {</a>
<a name="913"><span class="lineNum">     913 </span><span class="lineCov">      10305 :           return false;</span></a>
<a name="914"><span class="lineNum">     914 </span>            :         }</a>
<a name="915"><span class="lineNum">     915 </span>            :    }</a>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<a name="917"><span class="lineNum">     917 </span>            : bool</a>
<a name="918"><span class="lineNum">     918 </span><span class="lineNoCov">          0 : SageInterface::hasSameGlobalScope ( SgStatement* statement_1, SgStatement* statement_2 )</span></a>
<a name="919"><span class="lineNum">     919 </span>            :    {</a>
<a name="920"><span class="lineNum">     920 </span>            :   // DQ (12/7/2020): This is supporting the recognition of functions in header files from two different AST.</a>
<a name="921"><span class="lineNum">     921 </span>            : </a>
<a name="922"><span class="lineNum">     922 </span>            : #define DEBUG_HAS_SAME_SCOPE 0</a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            : #if DEBUG_HAS_SAME_SCOPE</a>
<a name="925"><span class="lineNum">     925 </span>            :      printf (&quot;In SageInterface::hasSameGlobalScope(): \n&quot;);</a>
<a name="926"><span class="lineNum">     926 </span>            :      printf (&quot; --- statement_1 = %p = %s \n&quot;,statement_1,statement_1-&gt;class_name().c_str());</a>
<a name="927"><span class="lineNum">     927 </span>            :      printf (&quot; --- statement_2 = %p = %s \n&quot;,statement_2,statement_2-&gt;class_name().c_str());</a>
<a name="928"><span class="lineNum">     928 </span>            : #endif</a>
<a name="929"><span class="lineNum">     929 </span>            : </a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :      bool includingSelf = true;</span></a>
<a name="931"><span class="lineNum">     931 </span><span class="lineNoCov">          0 :      SgGlobal* global_scope_1 = getEnclosingNode&lt;SgGlobal&gt;(statement_1,includingSelf);</span></a>
<a name="932"><span class="lineNum">     932 </span><span class="lineNoCov">          0 :      SgGlobal* global_scope_2 = getEnclosingNode&lt;SgGlobal&gt;(statement_2,includingSelf);</span></a>
<a name="933"><span class="lineNum">     933 </span>            : </a>
<a name="934"><span class="lineNum">     934 </span>            : #if DEBUG_HAS_SAME_SCOPE</a>
<a name="935"><span class="lineNum">     935 </span>            :      printf (&quot; --- global_scope_1 = %p = %s \n&quot;,global_scope_1,global_scope_1-&gt;class_name().c_str());</a>
<a name="936"><span class="lineNum">     936 </span>            :      SgSourceFile* sourcefile_1 = isSgSourceFile(global_scope_1-&gt;get_parent());</a>
<a name="937"><span class="lineNum">     937 </span>            :      printf (&quot; --- --- sourcefile_1 = %p filename = %s \n&quot;,sourcefile_1,sourcefile_1-&gt;getFileName().c_str());</a>
<a name="938"><span class="lineNum">     938 </span>            : </a>
<a name="939"><span class="lineNum">     939 </span>            :      printf (&quot; --- global_scope_2 = %p = %s \n&quot;,global_scope_2,global_scope_2-&gt;class_name().c_str());</a>
<a name="940"><span class="lineNum">     940 </span>            :      SgSourceFile* sourcefile_2 = isSgSourceFile(global_scope_2-&gt;get_parent());</a>
<a name="941"><span class="lineNum">     941 </span>            :      printf (&quot; --- --- sourcefile_2 = %p filename = %s \n&quot;,sourcefile_2,sourcefile_2-&gt;getFileName().c_str());</a>
<a name="942"><span class="lineNum">     942 </span>            : #endif</a>
<a name="943"><span class="lineNum">     943 </span>            : </a>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 :      bool returnResult = (global_scope_1 == global_scope_2);</span></a>
<a name="945"><span class="lineNum">     945 </span>            : </a>
<a name="946"><span class="lineNum">     946 </span>            : #if DEBUG_HAS_SAME_SCOPE</a>
<a name="947"><span class="lineNum">     947 </span>            :      printf (&quot;Leaving SageInterface::hasSameGlobalScope(): returning: %s \n&quot;,returnResult ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="948"><span class="lineNum">     948 </span>            : #endif</a>
<a name="949"><span class="lineNum">     949 </span>            : </a>
<a name="950"><span class="lineNum">     950 </span><span class="lineNoCov">          0 :      return returnResult;</span></a>
<a name="951"><span class="lineNum">     951 </span>            :    }</a>
<a name="952"><span class="lineNum">     952 </span>            : </a>
<a name="953"><span class="lineNum">     953 </span>            : </a>
<a name="954"><span class="lineNum">     954 </span>            : std::vector&lt;SgNode*&gt;</a>
<a name="955"><span class="lineNum">     955 </span><span class="lineNoCov">          0 : SageInterface::astIntersection ( SgNode* original, SgNode* copy, SgCopyHelp* help )</span></a>
<a name="956"><span class="lineNum">     956 </span>            :    {</a>
<a name="957"><span class="lineNum">     957 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; intersectionSet;</span></a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            :   // Collect all the IR nodes for the original AST</a>
<a name="960"><span class="lineNum">     960 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; AST_original = NodeQuery::querySubTree (original,V_SgNode);</span></a>
<a name="961"><span class="lineNum">     961 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; AST_copy     = NodeQuery::querySubTree (copy,V_SgNode);</span></a>
<a name="962"><span class="lineNum">     962 </span>            : </a>
<a name="963"><span class="lineNum">     963 </span><span class="lineNoCov">          0 :      int AST_original_size = AST_original.size();</span></a>
<a name="964"><span class="lineNum">     964 </span><span class="lineNoCov">          0 :      int AST_copy_size     = AST_copy.size();</span></a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 :      if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="967"><span class="lineNum">     967 </span>            :         {</a>
<a name="968"><span class="lineNum">     968 </span><span class="lineNoCov">          0 :           printf (&quot;Original AST size         = %d \n&quot;,AST_original_size);</span></a>
<a name="969"><span class="lineNum">     969 </span><span class="lineNoCov">          0 :           printf (&quot;Copy of original AST size = %d \n&quot;,AST_copy_size);</span></a>
<a name="970"><span class="lineNum">     970 </span>            :         }</a>
<a name="971"><span class="lineNum">     971 </span>            : </a>
<a name="972"><span class="lineNum">     972 </span><span class="lineNoCov">          0 :      int differenceInSizes = AST_original_size - AST_copy_size;</span></a>
<a name="973"><span class="lineNum">     973 </span><span class="lineNoCov">          0 :      if (differenceInSizes == 0)</span></a>
<a name="974"><span class="lineNum">     974 </span>            :         {</a>
<a name="975"><span class="lineNum">     975 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="976"><span class="lineNum">     976 </span><span class="lineNoCov">          0 :                printf (&quot;Copied AST is the SAME size as the original (size = %d) \n&quot;,AST_original_size);</span></a>
<a name="977"><span class="lineNum">     977 </span>            :         }</a>
<a name="978"><span class="lineNum">     978 </span>            :        else</a>
<a name="979"><span class="lineNum">     979 </span>            :         {</a>
<a name="980"><span class="lineNum">     980 </span><span class="lineNoCov">          0 :           printf (&quot;Warning: Copied AST and the original are DIFFERENT sizes (original size = %d copyied size = %d) \n&quot;,AST_original_size,AST_copy_size);</span></a>
<a name="981"><span class="lineNum">     981 </span>            :         }</a>
<a name="982"><span class="lineNum">     982 </span>            : </a>
<a name="983"><span class="lineNum">     983 </span>            :   // Compute the intersection (reference in the copy that point to the origal AST).</a>
<a name="984"><span class="lineNum">     984 </span>            :   // std::set&lt;SgNode*&gt; AST_set_original = AST_original;</a>
<a name="985"><span class="lineNum">     985 </span><span class="lineNoCov">          0 :      std::set&lt;SgNode*&gt; AST_set_original;</span></a>
<a name="986"><span class="lineNum">     986 </span><span class="lineNoCov">          0 :      for (int i = 0; i &lt; AST_original_size; i++)</span></a>
<a name="987"><span class="lineNum">     987 </span>            :         {</a>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 :           AST_set_original.insert(AST_original[i]);</span></a>
<a name="989"><span class="lineNum">     989 </span>            :         }</a>
<a name="990"><span class="lineNum">     990 </span>            : </a>
<a name="991"><span class="lineNum">     991 </span><span class="lineNoCov">          0 :      std::set&lt;SgNode*&gt; AST_set_copy;</span></a>
<a name="992"><span class="lineNum">     992 </span><span class="lineNoCov">          0 :      for (int i = 0; i &lt; AST_copy_size; i++)</span></a>
<a name="993"><span class="lineNum">     993 </span>            :         {</a>
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 :           AST_set_copy.insert(AST_copy[i]);</span></a>
<a name="995"><span class="lineNum">     995 </span>            :         }</a>
<a name="996"><span class="lineNum">     996 </span>            : </a>
<a name="997"><span class="lineNum">     997 </span><span class="lineNoCov">          0 :      int size = AST_original_size;</span></a>
<a name="998"><span class="lineNum">     998 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; intersectionList(size);</span></a>
<a name="999"><span class="lineNum">     999 </span>            : </a>
<a name="1000"><span class="lineNum">    1000 </span>            :   // Is there a better way to do this? Build scratch space and then use the different between begin() and end to build another vector.</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt;::iterator end = set_intersection(AST_set_original.begin(),AST_set_original.end(),AST_set_copy.begin(),AST_set_copy.end(),intersectionList.begin());</span></a>
<a name="1002"><span class="lineNum">    1002 </span>            : </a>
<a name="1003"><span class="lineNum">    1003 </span>            :   // Build a new vector from the relevant elements of the intersectionList scratch space.</a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; meaningIntersectionList = std::vector&lt;SgNode*&gt;(intersectionList.begin(),end);</span></a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineNoCov">          0 :      std::vector&lt;SgNode*&gt; deleteList;</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineNoCov">          0 :      for (int i = 0; i &lt; (int)meaningIntersectionList.size(); i++)</span></a>
<a name="1007"><span class="lineNum">    1007 </span>            :         {</a>
<a name="1008"><span class="lineNum">    1008 </span>            :        // printf (&quot;     (before removing types) meaningIntersectionList[%d] = %p = %s \n&quot;,i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 :           if (meaningIntersectionList[i] != NULL &amp;&amp; isSgType(meaningIntersectionList[i]) != NULL)</span></a>
<a name="1010"><span class="lineNum">    1010 </span>            :              {</a>
<a name="1011"><span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                deleteList.push_back(meaningIntersectionList[i]);</span></a>
<a name="1012"><span class="lineNum">    1012 </span>            :              }</a>
<a name="1013"><span class="lineNum">    1013 </span>            :         }</a>
<a name="1014"><span class="lineNum">    1014 </span>            : </a>
<a name="1015"><span class="lineNum">    1015 </span>            :   // Remove the types since they are allowed to be shared...</a>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineNoCov">          0 :      if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineNoCov">          0 :           printf (&quot;Remove the types that are allowed to be shared: deleteList.size() = %ld \n&quot;,(long)deleteList.size());</span></a>
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<a name="1019"><span class="lineNum">    1019 </span><span class="lineNoCov">          0 :      for (std::vector&lt;SgNode*&gt;::iterator i = deleteList.begin(); i != deleteList.end(); i++)</span></a>
<a name="1020"><span class="lineNum">    1020 </span>            :         {</a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineNoCov">          0 :           meaningIntersectionList.erase(find(meaningIntersectionList.begin(),meaningIntersectionList.end(),*i));</span></a>
<a name="1022"><span class="lineNum">    1022 </span>            :         }</a>
<a name="1023"><span class="lineNum">    1023 </span>            : </a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineNoCov">          0 :      if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           printf (&quot;After removing the types there are meaningIntersectionList.size() = %ld \n&quot;,(long)meaningIntersectionList.size());</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<a name="1027"><span class="lineNum">    1027 </span><span class="lineNoCov">          0 :      for (int i = 0; i &lt; (int)meaningIntersectionList.size(); i++)</span></a>
<a name="1028"><span class="lineNum">    1028 </span>            :         {</a>
<a name="1029"><span class="lineNum">    1029 </span>            :        // printf (&quot;     meaningIntersectionList[%d] = %p = %s \n&quot;,i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineNoCov">          0 :           printf (&quot;     meaningIntersectionList[%d] = %p = %s = %s \n&quot;,i,meaningIntersectionList[i],meaningIntersectionList[i]-&gt;class_name().c_str(),get_name(meaningIntersectionList[i]).c_str());</span></a>
<a name="1031"><span class="lineNum">    1031 </span>            :         }</a>
<a name="1032"><span class="lineNum">    1032 </span>            : </a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineNoCov">          0 :      int unmatchedIRnodes = 0;</span></a>
<a name="1034"><span class="lineNum">    1034 </span><span class="lineNoCov">          0 :      if (help != NULL)</span></a>
<a name="1035"><span class="lineNum">    1035 </span>            :         {</a>
<a name="1036"><span class="lineNum">    1036 </span><span class="lineNoCov">          0 :           std::vector&lt;SgNode*&gt; tmp_AST_original; // = AST_original;</span></a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineNoCov">          0 :           std::vector&lt;SgNode*&gt; tmp_AST_copy; //     = AST_copy;</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            : </a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineNoCov">          0 :           int AST_original_size = AST_original.size();</span></a>
<a name="1040"><span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           for (int j = 0; j &lt; AST_original_size; j++)</span></a>
<a name="1041"><span class="lineNum">    1041 </span>            :              {</a>
<a name="1042"><span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                if (AST_original[j] != NULL &amp;&amp; isSgType(AST_original[j]) == NULL)</span></a>
<a name="1043"><span class="lineNum">    1043 </span>            :                   {</a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                     tmp_AST_original.push_back(AST_original[j]);</span></a>
<a name="1045"><span class="lineNum">    1045 </span>            :                   }</a>
<a name="1046"><span class="lineNum">    1046 </span>            :              }</a>
<a name="1047"><span class="lineNum">    1047 </span>            : </a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineNoCov">          0 :           int AST_copy_size = AST_copy.size();</span></a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineNoCov">          0 :           for (int j = 0; j &lt; AST_copy_size; j++)</span></a>
<a name="1050"><span class="lineNum">    1050 </span>            :              {</a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                if (AST_copy[j] != NULL &amp;&amp; isSgType(AST_copy[j]) == NULL)</span></a>
<a name="1052"><span class="lineNum">    1052 </span>            :                   {</a>
<a name="1053"><span class="lineNum">    1053 </span><span class="lineNoCov">          0 :                     tmp_AST_copy.push_back(AST_copy[j]);</span></a>
<a name="1054"><span class="lineNum">    1054 </span>            :                   }</a>
<a name="1055"><span class="lineNum">    1055 </span>            :              }</a>
<a name="1056"><span class="lineNum">    1056 </span>            : </a>
<a name="1057"><span class="lineNum">    1057 </span><span class="lineNoCov">          0 :           std::vector&lt;SgNode*&gt; deleteList_original;</span></a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineNoCov">          0 :           std::vector&lt;SgNode*&gt; deleteList_copy;</span></a>
<a name="1059"><span class="lineNum">    1059 </span><span class="lineNoCov">          0 :           for (int j = 0; j &lt; (int)tmp_AST_original.size(); j++)</span></a>
<a name="1060"><span class="lineNum">    1060 </span>            :              {</a>
<a name="1061"><span class="lineNum">    1061 </span>            :             // printf (&quot;     (before removing types) meaningIntersectionList[%d] = %p = %s \n&quot;,i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]-&gt;class_name().c_str() : &quot;NULL&quot;);</a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineNoCov">          0 :                SgCopyHelp::copiedNodeMapTypeIterator i = help-&gt;get_copiedNodeMap().find(tmp_AST_original[j]);</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            :             // printf (&quot;SgCopyHelp::copiedNodeMapTypeIterator i != help-&gt;get_copiedNodeMap().end() = %s \n&quot;,i != help-&gt;get_copiedNodeMap().end() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="1064"><span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                if (i != help-&gt;get_copiedNodeMap().end())</span></a>
<a name="1065"><span class="lineNum">    1065 </span>            :                   {</a>
<a name="1066"><span class="lineNum">    1066 </span>            :                  // Matched up an original IR node with it's copy</a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                     SgNode* associated_node_copy = i-&gt;second;</span></a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(associated_node_copy != NULL);</span></a>
<a name="1069"><span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                     deleteList_original.push_back(tmp_AST_original[j]);</span></a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                     deleteList_copy.push_back(associated_node_copy);</span></a>
<a name="1071"><span class="lineNum">    1071 </span>            : #if 0</a>
<a name="1072"><span class="lineNum">    1072 </span>            :                  // printf (&quot;Original IR node = %p = %s copy = %p \n&quot;,tmp_AST_original[j],tmp_AST_original[j]-&gt;class_name().c_str(),associated_node_copy);</a>
<a name="1073"><span class="lineNum">    1073 </span>            :                     SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(tmp_AST_original[j]);</a>
<a name="1074"><span class="lineNum">    1074 </span>            :                     SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction_copy = isSgTemplateInstantiationMemberFunctionDecl(associated_node_copy);</a>
<a name="1075"><span class="lineNum">    1075 </span>            :                     if (templateMemberFunction != NULL)</a>
<a name="1076"><span class="lineNum">    1076 </span>            :                        {</a>
<a name="1077"><span class="lineNum">    1077 </span>            :                          printf (&quot;In SageInterface::astIntersection(): Found a SgTemplateInstantiationMemberFunctionDecl = %p copy = %p \n&quot;,templateMemberFunction,associated_node_copy);</a>
<a name="1078"><span class="lineNum">    1078 </span>            :                       // templateMemberFunction-&gt;get_startOfConstruct()-&gt;display(&quot;original: debug&quot;);</a>
<a name="1079"><span class="lineNum">    1079 </span>            :                       // templateMemberFunction_copy-&gt;get_startOfConstruct()-&gt;display(&quot;copy: debug&quot;);</a>
<a name="1080"><span class="lineNum">    1080 </span>            :                        }</a>
<a name="1081"><span class="lineNum">    1081 </span>            : #endif</a>
<a name="1082"><span class="lineNum">    1082 </span>            :                   }</a>
<a name="1083"><span class="lineNum">    1083 </span>            :              }</a>
<a name="1084"><span class="lineNum">    1084 </span>            : </a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineNoCov">          0 :           int deleteList_original_size = deleteList_original.size();</span></a>
<a name="1086"><span class="lineNum">    1086 </span><span class="lineNoCov">          0 :           for (int j = 0; j &lt; deleteList_original_size; j++)</span></a>
<a name="1087"><span class="lineNum">    1087 </span>            :              {</a>
<a name="1088"><span class="lineNum">    1088 </span>            :             // tmp_AST_original.erase(find(tmp_AST_original.begin(),tmp_AST_original.end(),deleteList_original[j]));</a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineNoCov">          0 :                std::vector&lt;SgNode*&gt;::iterator k = find(tmp_AST_original.begin(),tmp_AST_original.end(),deleteList_original[j]);</span></a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineNoCov">          0 :                if (k != tmp_AST_original.end())</span></a>
<a name="1091"><span class="lineNum">    1091 </span>            :                   {</a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineNoCov">          0 :                     tmp_AST_original.erase(k);</span></a>
<a name="1093"><span class="lineNum">    1093 </span>            :                   }</a>
<a name="1094"><span class="lineNum">    1094 </span>            :              }</a>
<a name="1095"><span class="lineNum">    1095 </span>            : </a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineNoCov">          0 :                printf (&quot;IR nodes different between the original AST and the copy of the AST = %&quot; PRIuPTR &quot; \n&quot;,tmp_AST_original.size());</span></a>
<a name="1098"><span class="lineNum">    1098 </span>            : </a>
<a name="1099"><span class="lineNum">    1099 </span><span class="lineNoCov">          0 :           for (int j = 0; j &lt; (int)tmp_AST_original.size(); j++)</span></a>
<a name="1100"><span class="lineNum">    1100 </span>            :              {</a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                printf (&quot;non matched IR node = %p = %s = %s \n&quot;,tmp_AST_original[j],tmp_AST_original[j]-&gt;class_name().c_str(),get_name(tmp_AST_original[j]).c_str());</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            :             // tmp_AST_original[j]-&gt;get_startOfConstruct()-&gt;display(&quot;debug&quot;);</a>
<a name="1103"><span class="lineNum">    1103 </span>            :              }</a>
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<a name="1105"><span class="lineNum">    1105 </span><span class="lineNoCov">          0 :           unmatchedIRnodes = (int)tmp_AST_original.size();</span></a>
<a name="1106"><span class="lineNum">    1106 </span>            :         }</a>
<a name="1107"><span class="lineNum">    1107 </span>            : </a>
<a name="1108"><span class="lineNum">    1108 </span>            :   // DQ (11/2/2007): Make this an error now!</a>
<a name="1109"><span class="lineNum">    1109 </span><span class="lineNoCov">          0 :      if (differenceInSizes != 0)</span></a>
<a name="1110"><span class="lineNum">    1110 </span>            :         {</a>
<a name="1111"><span class="lineNum">    1111 </span><span class="lineNoCov">          0 :           SgProject* originalProject = isSgProject(original);</span></a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineNoCov">          0 :           if (originalProject != NULL)</span></a>
<a name="1113"><span class="lineNum">    1113 </span>            :              {</a>
<a name="1114"><span class="lineNum">    1114 </span><span class="lineNoCov">          0 :                printf (&quot;In %s Copied AST and the original are DIFFERENT sizes (original size = %d copyied size = %d) IR nodes different = %d \n&quot;,</span></a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                     (*originalProject)[0]-&gt;get_sourceFileNameWithoutPath().c_str(),AST_original_size,AST_copy_size,unmatchedIRnodes);</span></a>
<a name="1116"><span class="lineNum">    1116 </span>            :              }</a>
<a name="1117"><span class="lineNum">    1117 </span>            : </a>
<a name="1118"><span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           if (unmatchedIRnodes &gt; 0)</span></a>
<a name="1119"><span class="lineNum">    1119 </span>            :              {</a>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                printf (&quot;Make this an error under stricter testing \n&quot;);</span></a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1122"><span class="lineNum">    1122 </span>            :              }</a>
<a name="1123"><span class="lineNum">    1123 </span>            :         }</a>
<a name="1124"><span class="lineNum">    1124 </span>            : </a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineNoCov">          0 :      return intersectionSet;</span></a>
<a name="1126"><span class="lineNum">    1126 </span>            :    }</a>
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<a name="1128"><span class="lineNum">    1128 </span>            : // AJ (10/21/2004): Added support for changing the symbol name associated with an SgInitializedName</a>
<a name="1129"><span class="lineNum">    1129 </span>            : // by updating the symbol table</a>
<a name="1130"><span class="lineNum">    1130 </span>            : int</a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineNoCov">          0 : SageInterface::set_name ( SgInitializedName *initializedNameNode, SgName new_name )</span></a>
<a name="1132"><span class="lineNum">    1132 </span>            :    {</a>
<a name="1133"><span class="lineNum">    1133 </span>            :   // find the appropriate symbol table, delete the symbol</a>
<a name="1134"><span class="lineNum">    1134 </span>            :   // with the old name and add a symbol with the new name.</a>
<a name="1135"><span class="lineNum">    1135 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(initializedNameNode != NULL);</span></a>
<a name="1136"><span class="lineNum">    1136 </span>            : </a>
<a name="1137"><span class="lineNum">    1137 </span>            : #define DEBUG_SET_NAME 0</a>
<a name="1138"><span class="lineNum">    1138 </span>            : </a>
<a name="1139"><span class="lineNum">    1139 </span>            :   // SgNode * node = this;</a>
<a name="1140"><span class="lineNum">    1140 </span>            : #if DEBUG_SET_NAME</a>
<a name="1141"><span class="lineNum">    1141 </span>            :      printf (&quot;In SageInterface::set_name(): initializedNameNode = %p name = %s new_name = %s \n&quot;,initializedNameNode,initializedNameNode-&gt;get_name().str(),new_name.str());</a>
<a name="1142"><span class="lineNum">    1142 </span>            : #endif</a>
<a name="1143"><span class="lineNum">    1143 </span>            : </a>
<a name="1144"><span class="lineNum">    1144 </span>            : #if 0</a>
<a name="1145"><span class="lineNum">    1145 </span>            :   // DQ (12/9/2004): This should likely call the get_scope function (which is more robust than traversing</a>
<a name="1146"><span class="lineNum">    1146 </span>            :   // parents, there is a reason why we are forced to include the scope explicitly on some IR nodes,</a>
<a name="1147"><span class="lineNum">    1147 </span>            :   // see test2004_133.C for details).</a>
<a name="1148"><span class="lineNum">    1148 </span>            :      while((node!=NULL) &amp;&amp; ( isSgScopeStatement(node)==NULL))</a>
<a name="1149"><span class="lineNum">    1149 </span>            :           node = node-&gt;get_parent();</a>
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<a name="1151"><span class="lineNum">    1151 </span>            :      ROSE_ASSERT(node!=NULL);</a>
<a name="1152"><span class="lineNum">    1152 </span>            : </a>
<a name="1153"><span class="lineNum">    1153 </span>            :      SgScopeStatement * scope_stmt = isSgScopeStatement(node);</a>
<a name="1154"><span class="lineNum">    1154 </span>            : #else</a>
<a name="1155"><span class="lineNum">    1155 </span><span class="lineNoCov">          0 :      SgScopeStatement *scope_stmt = initializedNameNode-&gt;get_scope();</span></a>
<a name="1156"><span class="lineNum">    1156 </span>            : #endif</a>
<a name="1157"><span class="lineNum">    1157 </span>            : </a>
<a name="1158"><span class="lineNum">    1158 </span>            :   // DQ (2/4/2021): Adding support for enum values (in SgEnumDeclarations).</a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineNoCov">          0 :      if (isSgEnumDeclaration(initializedNameNode-&gt;get_parent()) != NULL)</span></a>
<a name="1160"><span class="lineNum">    1160 </span>            :         {</a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(scope_stmt != NULL);</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineNoCov">          0 :           printf (&quot;scope_stmt = %p = %s \n&quot;,scope_stmt,scope_stmt-&gt;class_name().c_str());</span></a>
<a name="1163"><span class="lineNum">    1163 </span>            : #if 0</a>
<a name="1164"><span class="lineNum">    1164 </span>            :           printf (&quot;Detected isSgEnumDeclaration as parent: exiting as a test in SageInterface::set_name() \n&quot;);</a>
<a name="1165"><span class="lineNum">    1165 </span>            :           ROSE_ASSERT(false);</a>
<a name="1166"><span class="lineNum">    1166 </span>            : #endif</a>
<a name="1167"><span class="lineNum">    1167 </span>            :         }</a>
<a name="1168"><span class="lineNum">    1168 </span>            : </a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope_stmt != NULL);</span></a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope_stmt-&gt;get_symbol_table() != NULL);</span></a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope_stmt-&gt;get_symbol_table()-&gt;get_table() != NULL);</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            : </a>
<a name="1173"><span class="lineNum">    1173 </span><span class="lineNoCov">          0 :      SgDeclarationStatement * parent_declaration = initializedNameNode-&gt;get_declaration();</span></a>
<a name="1174"><span class="lineNum">    1174 </span>            : </a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(parent_declaration != NULL);</span></a>
<a name="1176"><span class="lineNum">    1176 </span>            : </a>
<a name="1177"><span class="lineNum">    1177 </span>            :   // Find the symbols associated with p_name</a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 :      std::pair&lt;SgSymbolTable::hash_iterator,SgSymbolTable::hash_iterator&gt; pair_it = scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;equal_range(initializedNameNode-&gt;get_name());</span></a>
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<a name="1180"><span class="lineNum">    1180 </span><span class="lineNoCov">          0 :      SgSymbolTable::hash_iterator found_it = scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;end();</span></a>
<a name="1181"><span class="lineNum">    1181 </span>            : </a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineNoCov">          0 :      for (SgSymbolTable::hash_iterator it = pair_it.first; it != pair_it.second; ++it)</span></a>
<a name="1183"><span class="lineNum">    1183 </span>            :         {</a>
<a name="1184"><span class="lineNum">    1184 </span>            : #if DEBUG_SET_NAME</a>
<a name="1185"><span class="lineNum">    1185 </span>            :           printf (&quot;Looking for symbol in scope = %p = %s \n&quot;,scope_stmt,scope_stmt-&gt;class_name().c_str());</a>
<a name="1186"><span class="lineNum">    1186 </span>            :           printf (&quot; --- *it = %p = %s \n&quot;,(*it).second,(*it).second-&gt;class_name().c_str());</a>
<a name="1187"><span class="lineNum">    1187 </span>            : #endif</a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineNoCov">          0 :           switch(parent_declaration-&gt;variantT())</span></a>
<a name="1189"><span class="lineNum">    1189 </span>            :              {</a>
<a name="1190"><span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                case V_SgFunctionParameterList:</span></a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                case V_SgVariableDeclaration:</span></a>
<a name="1192"><span class="lineNum">    1192 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1193"><span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                     if (isSgVariableSymbol((*it).second) != NULL)</span></a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                          found_it = it;</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            :                     break;</a>
<a name="1196"><span class="lineNum">    1196 </span>            :                   }</a>
<a name="1197"><span class="lineNum">    1197 </span>            : </a>
<a name="1198"><span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                case V_SgClassDeclaration:</span></a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1200"><span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                     if (isSgClassSymbol((*it).second) != NULL)</span></a>
<a name="1201"><span class="lineNum">    1201 </span><span class="lineNoCov">          0 :                          found_it = it;</span></a>
<a name="1202"><span class="lineNum">    1202 </span>            :                     break;</a>
<a name="1203"><span class="lineNum">    1203 </span>            :                   }</a>
<a name="1204"><span class="lineNum">    1204 </span>            : </a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                case V_SgFunctionDeclaration:</span></a>
<a name="1206"><span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                     if (isSgFunctionSymbol((*it).second) != NULL)</span></a>
<a name="1208"><span class="lineNum">    1208 </span><span class="lineNoCov">          0 :                          found_it = it;</span></a>
<a name="1209"><span class="lineNum">    1209 </span>            :                     break;</a>
<a name="1210"><span class="lineNum">    1210 </span>            :                   }</a>
<a name="1211"><span class="lineNum">    1211 </span>            : </a>
<a name="1212"><span class="lineNum">    1212 </span>            :             // DQ (2/4/2021): Adding support for enum values (in SgEnumDeclarations).</a>
<a name="1213"><span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                case V_SgEnumDeclaration:</span></a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1215"><span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                     if (isSgEnumFieldSymbol((*it).second) != NULL)</span></a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                          found_it = it;</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            :                     break;</a>
<a name="1218"><span class="lineNum">    1218 </span>            :                   }</a>
<a name="1219"><span class="lineNum">    1219 </span>            : </a>
<a name="1220"><span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1222"><span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                     printf (&quot;Default reached in switch in SageInterface::set_name() \n&quot;);</span></a>
<a name="1223"><span class="lineNum">    1223 </span>            :                   }</a>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineNoCov">          0 :              };</span></a>
<a name="1225"><span class="lineNum">    1225 </span>            :         }</a>
<a name="1226"><span class="lineNum">    1226 </span>            : </a>
<a name="1227"><span class="lineNum">    1227 </span>            :   // there is no Variable, Class or Function symbol associated with p_name</a>
<a name="1228"><span class="lineNum">    1228 </span><span class="lineNoCov">          0 :      if (found_it == scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;end())</span></a>
<a name="1229"><span class="lineNum">    1229 </span>            :         {</a>
<a name="1230"><span class="lineNum">    1230 </span><span class="lineNoCov">          0 :           printf (&quot;Warning: There is no Variable, Class, Function, or EnumValue symbol associated with p_name \n&quot;);</span></a>
<a name="1231"><span class="lineNum">    1231 </span><span class="lineNoCov">          0 :           return 0;</span></a>
<a name="1232"><span class="lineNum">    1232 </span>            :         }</a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span>            :   // DQ (11/12/2018): In general, this can't be tested if we permit it to be transformed.</a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineNoCov">          0 :      if (statementCanBeTransformed(parent_declaration) == false)</span></a>
<a name="1236"><span class="lineNum">    1236 </span>            :         {</a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: SageInterface::set_name(): This statement can not be transformed because it is part of a header file specific more then once with different include file syntax \n&quot;);</span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineNoCov">          0 :           return 0;</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            :         }</a>
<a name="1240"><span class="lineNum">    1240 </span>            :        else</a>
<a name="1241"><span class="lineNum">    1241 </span>            :         {</a>
<a name="1242"><span class="lineNum">    1242 </span>            : #if DEBUG_SET_NAME</a>
<a name="1243"><span class="lineNum">    1243 </span>            :           printf (&quot;In SageInterface::set_name(): This statement can be transformed! parent_declaration = %p = %s \n&quot;,parent_declaration,get_name(parent_declaration).c_str());</a>
<a name="1244"><span class="lineNum">    1244 </span>            : #endif</a>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<a name="1246"><span class="lineNum">    1246 </span>            : #if 0</a>
<a name="1247"><span class="lineNum">    1247 </span>            :        // DQ (11/12/2018): Initial test problem should not permit a transformation!</a>
<a name="1248"><span class="lineNum">    1248 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1249"><span class="lineNum">    1249 </span>            :           ROSE_ABORT();</a>
<a name="1250"><span class="lineNum">    1250 </span>            : #endif</a>
<a name="1251"><span class="lineNum">    1251 </span>            :         }</a>
<a name="1252"><span class="lineNum">    1252 </span>            : </a>
<a name="1253"><span class="lineNum">    1253 </span><span class="lineNoCov">          0 :      SgSymbol * associated_symbol = (*found_it).second;</span></a>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<a name="1255"><span class="lineNum">    1255 </span>            :   // erase the name from there</a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineNoCov">          0 :      scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;erase(found_it);</span></a>
<a name="1257"><span class="lineNum">    1257 </span>            : </a>
<a name="1258"><span class="lineNum">    1258 </span>            :   // insert the new_name in the symbol table</a>
<a name="1259"><span class="lineNum">    1259 </span>            : // CH (4/9/2010): Use boost::unordered instead</a>
<a name="1260"><span class="lineNum">    1260 </span>            : //#ifdef _MSCx_VER</a>
<a name="1261"><span class="lineNum">    1261 </span>            : #if 0</a>
<a name="1262"><span class="lineNum">    1262 </span>            :   // DQ (11/28/2009): Unclear if this code is a problem (testing).</a>
<a name="1263"><span class="lineNum">    1263 </span>            : </a>
<a name="1264"><span class="lineNum">    1264 </span>            : // CH (4/7/2010): It seems that the following code can be compiled under MSVC 9.0</a>
<a name="1265"><span class="lineNum">    1265 </span>            : //#pragma message (&quot;WARNING: this code does not apprear to compile with MSVC.&quot;)</a>
<a name="1266"><span class="lineNum">    1266 </span>            : //       printf (&quot;ERROR: this code does not apprear to compile with MSVC. \n&quot;);</a>
<a name="1267"><span class="lineNum">    1267 </span>            : //       ROSE_ASSERT(false);</a>
<a name="1268"><span class="lineNum">    1268 </span>            :      found_it = scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;insert(pair&lt;SgName,SgSymbol*&gt; ( new_name,associated_symbol));</a>
<a name="1269"><span class="lineNum">    1269 </span>            : #else</a>
<a name="1270"><span class="lineNum">    1270 </span><span class="lineNoCov">          0 :      found_it = scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;insert(pair&lt;SgName,SgSymbol*&gt; ( new_name,associated_symbol));</span></a>
<a name="1271"><span class="lineNum">    1271 </span>            : #endif</a>
<a name="1272"><span class="lineNum">    1272 </span>            :   // if insertion failed</a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineNoCov">          0 :      if (found_it == scope_stmt-&gt;get_symbol_table()-&gt;get_table()-&gt;end())</span></a>
<a name="1274"><span class="lineNum">    1274 </span>            :         {</a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineNoCov">          0 :           printf (&quot;Warning: insertion of new symbol failed \n&quot;);</span></a>
<a name="1276"><span class="lineNum">    1276 </span><span class="lineNoCov">          0 :           return 0;</span></a>
<a name="1277"><span class="lineNum">    1277 </span>            :         }</a>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<a name="1279"><span class="lineNum">    1279 </span>            : #if DEBUG_SET_NAME</a>
<a name="1280"><span class="lineNum">    1280 </span>            :   // Set the p_name to the new_name</a>
<a name="1281"><span class="lineNum">    1281 </span>            :      printf (&quot;Reset initializedNameNode-&gt;get_name() = %s to new_name = %s \n&quot;,initializedNameNode-&gt;get_name().str(),new_name.str());</a>
<a name="1282"><span class="lineNum">    1282 </span>            : #endif</a>
<a name="1283"><span class="lineNum">    1283 </span>            : </a>
<a name="1284"><span class="lineNum">    1284 </span>            :   // p_name = new_name;</a>
<a name="1285"><span class="lineNum">    1285 </span><span class="lineNoCov">          0 :      initializedNameNode-&gt;set_name(new_name);</span></a>
<a name="1286"><span class="lineNum">    1286 </span>            : </a>
<a name="1287"><span class="lineNum">    1287 </span>            :   // DQ (11/30/2018): Mark the enclosing statement as modified, so that it will be recognized</a>
<a name="1288"><span class="lineNum">    1288 </span>            :   // in the header file unparsing as being a header file that should be unparsed.</a>
<a name="1289"><span class="lineNum">    1289 </span><span class="lineNoCov">          0 :      SgStatement* enclosingStatement = getEnclosingStatement(initializedNameNode);</span></a>
<a name="1290"><span class="lineNum">    1290 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(enclosingStatement != NULL);</span></a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineNoCov">          0 :      enclosingStatement-&gt;set_isModified(true);</span></a>
<a name="1292"><span class="lineNum">    1292 </span><span class="lineNoCov">          0 :      enclosingStatement-&gt;setTransformation();</span></a>
<a name="1293"><span class="lineNum">    1293 </span>            : </a>
<a name="1294"><span class="lineNum">    1294 </span>            :   // Invalidate the p_iterator, p_no_name and p_name data members in the Symbol table</a>
<a name="1295"><span class="lineNum">    1295 </span>            : </a>
<a name="1296"><span class="lineNum">    1296 </span>            : #if 1</a>
<a name="1297"><span class="lineNum">    1297 </span>            :   // Search the AST for references to this SgInitializedName (SgVarRefExp), check if the symbol matches</a>
<a name="1298"><span class="lineNum">    1298 </span>            :   // (we can do this since we only reused the exisitng symbol), and mark those expressions as modified.</a>
<a name="1299"><span class="lineNum">    1299 </span><span class="lineNoCov">          0 :      class RoseVisitor : public ROSE_VisitTraversal</span></a>
<a name="1300"><span class="lineNum">    1300 </span>            :         {</a>
<a name="1301"><span class="lineNum">    1301 </span>            :           public:</a>
<a name="1302"><span class="lineNum">    1302 </span>            :                int counter;</a>
<a name="1303"><span class="lineNum">    1303 </span>            :                SgSymbol* symbol;</a>
<a name="1304"><span class="lineNum">    1304 </span>            : </a>
<a name="1305"><span class="lineNum">    1305 </span>            :            //! Required traversal function</a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            :                   {</a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineNoCov">          0 :                     SgVarRefExp*      varRefExp      = isSgVarRefExp(node);</span></a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineNoCov">          0 :                     SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);</span></a>
<a name="1310"><span class="lineNum">    1310 </span>            : </a>
<a name="1311"><span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(varRefExp      != NULL);</span></a>
<a name="1312"><span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="1313"><span class="lineNum">    1313 </span>            : </a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                     if (varRefExp-&gt;get_symbol() == variableSymbol)</span></a>
<a name="1315"><span class="lineNum">    1315 </span>            :                        {</a>
<a name="1316"><span class="lineNum">    1316 </span>            : #if DEBUG_SET_NAME</a>
<a name="1317"><span class="lineNum">    1317 </span>            :                          printf (&quot;In SageInterface::set_name(): Found associated SgVarRefExp varRefExp = %p to symbol associated_symbol = %p \n&quot;,varRefExp,variableSymbol);</a>
<a name="1318"><span class="lineNum">    1318 </span>            : #endif</a>
<a name="1319"><span class="lineNum">    1319 </span>            : #if 0</a>
<a name="1320"><span class="lineNum">    1320 </span>            :                          printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1321"><span class="lineNum">    1321 </span>            :                          ROSE_ABORT();</a>
<a name="1322"><span class="lineNum">    1322 </span>            : #endif</a>
<a name="1323"><span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                          varRefExp-&gt;set_isModified(true);</span></a>
<a name="1324"><span class="lineNum">    1324 </span><span class="lineNoCov">          0 :                          varRefExp-&gt;setTransformation();</span></a>
<a name="1325"><span class="lineNum">    1325 </span>            : </a>
<a name="1326"><span class="lineNum">    1326 </span>            :                       // DQ (4/23/2021): I think it is a problem that the statement is not marked as a transformation so that we know how to handle it with the token-based unparsing.</a>
<a name="1327"><span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                          SgStatement* associatedStatement = getEnclosingStatement(varRefExp);</span></a>
<a name="1328"><span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(associatedStatement != NULL);</span></a>
<a name="1329"><span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                          associatedStatement-&gt;setTransformation();</span></a>
<a name="1330"><span class="lineNum">    1330 </span>            : </a>
<a name="1331"><span class="lineNum">    1331 </span>            : #if 0</a>
<a name="1332"><span class="lineNum">    1332 </span>            :                       // DQ (11/13/2018): Mark the statement associated with this SgVarRefExp (see test9 in UnparseHeaders_tests).</a>
<a name="1333"><span class="lineNum">    1333 </span>            :                          SgStatement* associatedStatement = getEnclosingStatement(varRefExp);</a>
<a name="1334"><span class="lineNum">    1334 </span>            :                          ROSE_ASSERT(associatedStatement != NULL);</a>
<a name="1335"><span class="lineNum">    1335 </span>            :                       // associatedStatement-&gt;set_isModified(true);</a>
<a name="1336"><span class="lineNum">    1336 </span>            :                       // associatedStatement-&gt;set_containsTransformation(true);</a>
<a name="1337"><span class="lineNum">    1337 </span>            :                          associatedStatement-&gt;setTransformation();</a>
<a name="1338"><span class="lineNum">    1338 </span>            : #endif</a>
<a name="1339"><span class="lineNum">    1339 </span>            :                        }</a>
<a name="1340"><span class="lineNum">    1340 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="1341"><span class="lineNum">    1341 </span>            : </a>
<a name="1342"><span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                RoseVisitor(SgSymbol* symbol_parmeter) : counter(0), symbol(symbol_parmeter)</span></a>
<a name="1343"><span class="lineNum">    1343 </span>            :                  {</a>
<a name="1344"><span class="lineNum">    1344 </span>            : #if 0</a>
<a name="1345"><span class="lineNum">    1345 </span>            :                    printf (&quot;roseVisitor::visit: counter %4d node = %s \n&quot;,counter,symbol_parmeter-&gt;class_name().c_str());</a>
<a name="1346"><span class="lineNum">    1346 </span>            : #endif</a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineNoCov">          0 :                    counter++;</span></a>
<a name="1348"><span class="lineNum">    1348 </span>            :                  }</a>
<a name="1349"><span class="lineNum">    1349 </span>            :         };</a>
<a name="1350"><span class="lineNum">    1350 </span>            : </a>
<a name="1351"><span class="lineNum">    1351 </span>            :   // RoseVisitor visitor;</a>
<a name="1352"><span class="lineNum">    1352 </span>            :   // visitor.traverseMemoryPool();</a>
<a name="1353"><span class="lineNum">    1353 </span><span class="lineNoCov">          0 :      RoseVisitor t1(associated_symbol);</span></a>
<a name="1354"><span class="lineNum">    1354 </span><span class="lineNoCov">          0 :      SgVarRefExp::traverseMemoryPoolNodes(t1);</span></a>
<a name="1355"><span class="lineNum">    1355 </span>            : #endif</a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span>            : #if DEBUG_SET_NAME</a>
<a name="1358"><span class="lineNum">    1358 </span>            :      printf (&quot;Leaving SageInterface::set_name(): initializedNameNode = %p name = %s new_name = %s (return 1) \n&quot;,initializedNameNode,initializedNameNode-&gt;get_name().str(),new_name.str());</a>
<a name="1359"><span class="lineNum">    1359 </span>            : #endif</a>
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<a name="1361"><span class="lineNum">    1361 </span>            :   // DQ (4/23/2021): I think that we should be returning zero for no error</a>
<a name="1362"><span class="lineNum">    1362 </span>            :   // and one for an error, this function appears to have this detail reversed.</a>
<a name="1363"><span class="lineNum">    1363 </span><span class="lineNoCov">          0 :      return 1;</span></a>
<a name="1364"><span class="lineNum">    1364 </span>            :    }</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            : </a>
<a name="1367"><span class="lineNum">    1367 </span>            : void</a>
<a name="1368"><span class="lineNum">    1368 </span><span class="lineNoCov">          0 : SageInterface::listHeaderFiles ( SgIncludeFile* includeFile )</span></a>
<a name="1369"><span class="lineNum">    1369 </span>            :    {</a>
<a name="1370"><span class="lineNum">    1370 </span><span class="lineNoCov">          0 :      printf (&quot;In SageInterface::listHeaderFiles(): includeFile filename = %s \n&quot;,includeFile-&gt;get_filename().str());</span></a>
<a name="1371"><span class="lineNum">    1371 </span>            : </a>
<a name="1372"><span class="lineNum">    1372 </span>            :   // Preorder traversal to uniquely name specific declarations (SgClassDeclaration and SgFunctionDeclaration IR nodes).</a>
<a name="1373"><span class="lineNum">    1373 </span><span class="lineNoCov">          0 :      class PrefixTraversal : public AstSimpleProcessing</span></a>
<a name="1374"><span class="lineNum">    1374 </span>            :         {</a>
<a name="1375"><span class="lineNum">    1375 </span>            :           public:</a>
<a name="1376"><span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="1377"><span class="lineNum">    1377 </span>            :                   {</a>
<a name="1378"><span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                     printf (&quot;In listHeaderFiles visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="1379"><span class="lineNum">    1379 </span><span class="lineNoCov">          0 :                     SgIncludeFile* includeFile = isSgIncludeFile(node);</span></a>
<a name="1380"><span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                     if (includeFile != NULL)</span></a>
<a name="1381"><span class="lineNum">    1381 </span>            :                        {</a>
<a name="1382"><span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                          printf (&quot;include file: filename = %s \n&quot;,includeFile-&gt;get_filename().str());</span></a>
<a name="1383"><span class="lineNum">    1383 </span>            :                        }</a>
<a name="1384"><span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="1385"><span class="lineNum">    1385 </span>            :         };</a>
<a name="1386"><span class="lineNum">    1386 </span>            : </a>
<a name="1387"><span class="lineNum">    1387 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="1388"><span class="lineNum">    1388 </span><span class="lineNoCov">          0 :      PrefixTraversal traversal;</span></a>
<a name="1389"><span class="lineNum">    1389 </span><span class="lineNoCov">          0 :      traversal.traverse(includeFile, preorder);</span></a>
<a name="1390"><span class="lineNum">    1390 </span>            : </a>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="1392"><span class="lineNum">    1392 </span>            : </a>
<a name="1393"><span class="lineNum">    1393 </span>            : </a>
<a name="1394"><span class="lineNum">    1394 </span>            : namespace</a>
<a name="1395"><span class="lineNum">    1395 </span>            : {</a>
<a name="1396"><span class="lineNum">    1396 </span>            :   template &lt;class SageDecl&gt;</a>
<a name="1397"><span class="lineNum">    1397 </span>            :   std::string genericGetName(SageDecl* dcl)</a>
<a name="1398"><span class="lineNum">    1398 </span>            :   {</a>
<a name="1399"><span class="lineNum">    1399 </span>            :     ROSE_ASSERT(dcl);</a>
<a name="1400"><span class="lineNum">    1400 </span>            :     return dcl-&gt;get_name();</a>
<a name="1401"><span class="lineNum">    1401 </span>            :   }</a>
<a name="1402"><span class="lineNum">    1402 </span>            : }</a>
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<a name="1404"><span class="lineNum">    1404 </span>            : </a>
<a name="1405"><span class="lineNum">    1405 </span>            : </a>
<a name="1406"><span class="lineNum">    1406 </span>            : </a>
<a name="1407"><span class="lineNum">    1407 </span>            : string</a>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineNoCov">          0 : SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive )</span></a>
<a name="1409"><span class="lineNum">    1409 </span>            :    {</a>
<a name="1410"><span class="lineNum">    1410 </span><span class="lineNoCov">          0 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="1411"><span class="lineNum">    1411 </span>            : </a>
<a name="1412"><span class="lineNum">    1412 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(directive != NULL);</span></a>
<a name="1413"><span class="lineNum">    1413 </span>            : </a>
<a name="1414"><span class="lineNum">    1414 </span><span class="lineNoCov">          0 :      name = directive-&gt;class_name();</span></a>
<a name="1415"><span class="lineNum">    1415 </span>            : </a>
<a name="1416"><span class="lineNum">    1416 </span>            : #if 1</a>
<a name="1417"><span class="lineNum">    1417 </span>            :   // I don't think we need this code now!</a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineNoCov">          0 :      switch (directive-&gt;variantT())</span></a>
<a name="1419"><span class="lineNum">    1419 </span>            :         {</a>
<a name="1420"><span class="lineNum">    1420 </span>            :        // Separate out these cases...</a>
<a name="1421"><span class="lineNum">    1421 </span><span class="lineNoCov">          0 :           case V_SgIncludeDirectiveStatement:</span></a>
<a name="1422"><span class="lineNum">    1422 </span><span class="lineNoCov">          0 :           case V_SgDefineDirectiveStatement:</span></a>
<a name="1423"><span class="lineNum">    1423 </span><span class="lineNoCov">          0 :           case V_SgUndefDirectiveStatement:</span></a>
<a name="1424"><span class="lineNum">    1424 </span><span class="lineNoCov">          0 :           case V_SgIfdefDirectiveStatement:</span></a>
<a name="1425"><span class="lineNum">    1425 </span><span class="lineNoCov">          0 :           case V_SgIfndefDirectiveStatement:</span></a>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineNoCov">          0 :           case V_SgDeadIfDirectiveStatement:</span></a>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineNoCov">          0 :           case V_SgIfDirectiveStatement:</span></a>
<a name="1428"><span class="lineNum">    1428 </span><span class="lineNoCov">          0 :           case V_SgElseDirectiveStatement:</span></a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineNoCov">          0 :           case V_SgElseifDirectiveStatement:</span></a>
<a name="1430"><span class="lineNum">    1430 </span><span class="lineNoCov">          0 :           case V_SgLineDirectiveStatement:</span></a>
<a name="1431"><span class="lineNum">    1431 </span><span class="lineNoCov">          0 :           case V_SgWarningDirectiveStatement:</span></a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineNoCov">          0 :           case V_SgErrorDirectiveStatement:</span></a>
<a name="1433"><span class="lineNum">    1433 </span><span class="lineNoCov">          0 :           case V_SgEmptyDirectiveStatement:</span></a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1435"><span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                name = directive-&gt;class_name();</span></a>
<a name="1436"><span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1437"><span class="lineNum">    1437 </span>            :              }</a>
<a name="1438"><span class="lineNum">    1438 </span>            : </a>
<a name="1439"><span class="lineNum">    1439 </span>            :        // case ClinkageDeclarationStatement:</a>
<a name="1440"><span class="lineNum">    1440 </span><span class="lineNoCov">          0 :           case V_SgClinkageStartStatement:</span></a>
<a name="1441"><span class="lineNum">    1441 </span><span class="lineNoCov">          0 :           case V_SgClinkageEndStatement:</span></a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1443"><span class="lineNum">    1443 </span><span class="lineNoCov">          0 :                name = directive-&gt;class_name();</span></a>
<a name="1444"><span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1445"><span class="lineNum">    1445 </span>            :              }</a>
<a name="1446"><span class="lineNum">    1446 </span>            : </a>
<a name="1447"><span class="lineNum">    1447 </span><span class="lineNoCov">          0 :           case V_SgFortranIncludeLine:</span></a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                name = directive-&gt;class_name();</span></a>
<a name="1450"><span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1451"><span class="lineNum">    1451 </span>            :              }</a>
<a name="1452"><span class="lineNum">    1452 </span>            : </a>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="1454"><span class="lineNum">    1454 </span>            :             // name = &quot;default name (default case reached: not handled)&quot;;</a>
<a name="1455"><span class="lineNum">    1455 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: default case reached in SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive ), directive = %p = %s \n&quot;,</span></a>
<a name="1456"><span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                     directive,directive-&gt;class_name().c_str());</span></a>
<a name="1457"><span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1458"><span class="lineNum">    1458 </span>            : #if 0 // [Robb Matzke 2021-03-24]: unreachable</a>
<a name="1459"><span class="lineNum">    1459 </span>            :                name = &quot;directive_default_name_case_reached_not_handled&quot;;</a>
<a name="1460"><span class="lineNum">    1460 </span>            :                break;</a>
<a name="1461"><span class="lineNum">    1461 </span>            : #endif</a>
<a name="1462"><span class="lineNum">    1462 </span>            :         }</a>
<a name="1463"><span class="lineNum">    1463 </span>            : #endif</a>
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<a name="1465"><span class="lineNum">    1465 </span><span class="lineNoCov">          0 :      return name;</span></a>
<a name="1466"><span class="lineNum">    1466 </span>            :    }</a>
<a name="1467"><span class="lineNum">    1467 </span>            : </a>
<a name="1468"><span class="lineNum">    1468 </span>            : string</a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineCov">     130660 : SageInterface::get_name ( const SgDeclarationStatement* declaration )</span></a>
<a name="1470"><span class="lineNum">    1470 </span>            :    {</a>
<a name="1471"><span class="lineNum">    1471 </span><span class="lineCov">     261320 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="1472"><span class="lineNum">    1472 </span>            : </a>
<a name="1473"><span class="lineNum">    1473 </span><span class="lineCov">     130660 :      ROSE_ASSERT(declaration != NULL);</span></a>
<a name="1474"><span class="lineNum">    1474 </span>            : </a>
<a name="1475"><span class="lineNum">    1475 </span>            :   // DQ (11/23/2008): Handle the case of a Cpp directive...</a>
<a name="1476"><span class="lineNum">    1476 </span><span class="lineCov">     130660 :      const SgC_PreprocessorDirectiveStatement* directive = isSgC_PreprocessorDirectiveStatement(declaration);</span></a>
<a name="1477"><span class="lineNum">    1477 </span><span class="lineCov">     130660 :      if (directive != NULL)</span></a>
<a name="1478"><span class="lineNum">    1478 </span>            :         {</a>
<a name="1479"><span class="lineNum">    1479 </span><span class="lineNoCov">          0 :           return SageInterface::get_name (directive);</span></a>
<a name="1480"><span class="lineNum">    1480 </span>            :         }</a>
<a name="1481"><span class="lineNum">    1481 </span>            : </a>
<a name="1482"><span class="lineNum">    1482 </span><span class="lineCov">     130660 :      switch (declaration-&gt;variantT())</span></a>
<a name="1483"><span class="lineNum">    1483 </span>            :         {</a>
<a name="1484"><span class="lineNum">    1484 </span>            :        // DQ (12/28/2011): Added seperate support for new design of template IR nodes.</a>
<a name="1485"><span class="lineNum">    1485 </span>            :        // DQ (12/4/2011): Added support for template declarations in the AST.</a>
<a name="1486"><span class="lineNum">    1486 </span><span class="lineCov">         59 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="1487"><span class="lineNum">    1487 </span><span class="lineCov">         59 :                name = isSgTemplateMemberFunctionDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1488"><span class="lineNum">    1488 </span><span class="lineCov">         59 :                break;</span></a>
<a name="1489"><span class="lineNum">    1489 </span>            : </a>
<a name="1490"><span class="lineNum">    1490 </span>            :        // DQ (12/28/2011): Added seperate support for new design of template IR nodes.</a>
<a name="1491"><span class="lineNum">    1491 </span><span class="lineCov">          2 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineCov">          2 :                name = isSgTemplateFunctionDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1493"><span class="lineNum">    1493 </span><span class="lineCov">          2 :                break;</span></a>
<a name="1494"><span class="lineNum">    1494 </span>            : </a>
<a name="1495"><span class="lineNum">    1495 </span>            :        // DQ (12/28/2011): Added seperate support for new design of template IR nodes.</a>
<a name="1496"><span class="lineNum">    1496 </span>            :        // DQ (6/11/2011): Added support for new template IR nodes.</a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineCov">      20716 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">      20716 :                name = isSgTemplateClassDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">      20716 :                break;</span></a>
<a name="1500"><span class="lineNum">    1500 </span>            : </a>
<a name="1501"><span class="lineNum">    1501 </span><span class="lineNoCov">          0 :           case V_SgTemplateDeclaration:</span></a>
<a name="1502"><span class="lineNum">    1502 </span><span class="lineNoCov">          0 :                name = isSgTemplateDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1503"><span class="lineNum">    1503 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1504"><span class="lineNum">    1504 </span>            : </a>
<a name="1505"><span class="lineNum">    1505 </span>            :        // DQ (2/10/2007): Use the get_templateName() instead of combining this with the case V_SgClassDeclaration</a>
<a name="1506"><span class="lineNum">    1506 </span><span class="lineCov">      11855 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="1507"><span class="lineNum">    1507 </span><span class="lineCov">      11855 :                name = isSgTemplateInstantiationDecl(declaration)-&gt;get_templateName().str();</span></a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">      11855 :                break;</span></a>
<a name="1509"><span class="lineNum">    1509 </span>            : </a>
<a name="1510"><span class="lineNum">    1510 </span><span class="lineCov">      12075 :           case V_SgClassDeclaration:</span></a>
<a name="1511"><span class="lineNum">    1511 </span><span class="lineCov">      12075 :           case V_SgDerivedTypeStatement:</span></a>
<a name="1512"><span class="lineNum">    1512 </span><span class="lineCov">      12075 :                name = isSgClassDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1513"><span class="lineNum">    1513 </span><span class="lineCov">      12075 :                break;</span></a>
<a name="1514"><span class="lineNum">    1514 </span>            : </a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineCov">          1 :           case V_SgEnumDeclaration:</span></a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineCov">          1 :                name = isSgEnumDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1517"><span class="lineNum">    1517 </span><span class="lineCov">          1 :                break;</span></a>
<a name="1518"><span class="lineNum">    1518 </span>            : </a>
<a name="1519"><span class="lineNum">    1519 </span>            :        // DQ (11/5/2014): Adding support for template typedef declarations (C++11 feature).</a>
<a name="1520"><span class="lineNum">    1520 </span><span class="lineNoCov">          0 :           case V_SgTemplateInstantiationTypedefDeclaration:</span></a>
<a name="1521"><span class="lineNum">    1521 </span>            :        // DQ (11/3/2014): Adding support for template typedef declarations (C++11 feature).</a>
<a name="1522"><span class="lineNum">    1522 </span><span class="lineNoCov">          0 :           case V_SgTemplateTypedefDeclaration:</span></a>
<a name="1523"><span class="lineNum">    1523 </span><span class="lineNoCov">          0 :           case V_SgTypedefDeclaration:</span></a>
<a name="1524"><span class="lineNum">    1524 </span><span class="lineNoCov">          0 :                name = isSgTypedefDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            : </a>
<a name="1527"><span class="lineNum">    1527 </span><span class="lineCov">         15 :           case V_SgFunctionDeclaration:</span></a>
<a name="1528"><span class="lineNum">    1528 </span><span class="lineCov">         15 :           case V_SgProgramHeaderStatement:</span></a>
<a name="1529"><span class="lineNum">    1529 </span><span class="lineCov">         15 :           case V_SgProcedureHeaderStatement:</span></a>
<a name="1530"><span class="lineNum">    1530 </span><span class="lineCov">         15 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">         15 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="1532"><span class="lineNum">    1532 </span><span class="lineCov">         15 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="1533"><span class="lineNum">    1533 </span><span class="lineCov">         15 :                name = isSgFunctionDeclaration(declaration)-&gt;get_name().str();</span></a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineCov">         15 :                break;</span></a>
<a name="1535"><span class="lineNum">    1535 </span>            : </a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineCov">      85935 :           case V_SgNamespaceDeclarationStatement:</span></a>
<a name="1537"><span class="lineNum">    1537 </span><span class="lineCov">      85935 :                name = isSgNamespaceDeclarationStatement(declaration)-&gt;get_name().str();</span></a>
<a name="1538"><span class="lineNum">    1538 </span><span class="lineCov">      85935 :                break;</span></a>
<a name="1539"><span class="lineNum">    1539 </span>            : </a>
<a name="1540"><span class="lineNum">    1540 </span>            :        // DQ (2/12/2006): Added support to get name of SgFunctionParameterList</a>
<a name="1541"><span class="lineNum">    1541 </span><span class="lineNoCov">          0 :           case V_SgFunctionParameterList:</span></a>
<a name="1542"><span class="lineNum">    1542 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1543"><span class="lineNum">    1543 </span>            :             // Parents should be set prior to calling these functions (if not we might have to implement that case)</a>
<a name="1544"><span class="lineNum">    1544 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(declaration-&gt;get_parent() != NULL);</span></a>
<a name="1545"><span class="lineNum">    1545 </span>            : </a>
<a name="1546"><span class="lineNum">    1546 </span><span class="lineNoCov">          0 :                if (SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration-&gt;get_parent()))</span></a>
<a name="1547"><span class="lineNum">    1547 </span>            :                {</a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineNoCov">          0 :                  name = get_name(functionDeclaration);</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            :                }</a>
<a name="1550"><span class="lineNum">    1550 </span><span class="lineNoCov">          0 :                else if (SgScopeStatement* scopeStmt = isSgScopeStatement(declaration-&gt;get_parent()))</span></a>
<a name="1551"><span class="lineNum">    1551 </span>            :                {</a>
<a name="1552"><span class="lineNum">    1552 </span><span class="lineNoCov">          0 :                  name = get_name(scopeStmt);</span></a>
<a name="1553"><span class="lineNum">    1553 </span>            :                }</a>
<a name="1554"><span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                else ROSE_ABORT();</span></a>
<a name="1555"><span class="lineNum">    1555 </span>            : </a>
<a name="1556"><span class="lineNum">    1556 </span><span class="lineNoCov">          0 :                name += &quot;_parameter_list_&quot;;</span></a>
<a name="1557"><span class="lineNum">    1557 </span>            :                break;</a>
<a name="1558"><span class="lineNum">    1558 </span>            :              }</a>
<a name="1559"><span class="lineNum">    1559 </span>            : </a>
<a name="1560"><span class="lineNum">    1560 </span>            :        // DQ (2/10/2012): Added support for template variable declarations (using base class support).</a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineCov">          2 :           case V_SgTemplateVariableDeclaration:</span></a>
<a name="1562"><span class="lineNum">    1562 </span>            : </a>
<a name="1563"><span class="lineNum">    1563 </span>            :        // DQ (3/8/2006): Implemented case for variable declaration (forgot this case)</a>
<a name="1564"><span class="lineNum">    1564 </span><span class="lineCov">          2 :           case V_SgVariableDeclaration:</span></a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineCov">          2 :              {</span></a>
<a name="1566"><span class="lineNum">    1566 </span>            :             // DQ (2/11/2007): Modified to return names that can be used as variables (required</a>
<a name="1567"><span class="lineNum">    1567 </span>            :             // because we use this mechanism to generate names for unnamed structs and enums).</a>
<a name="1568"><span class="lineNum">    1568 </span><span class="lineCov">          2 :                name = &quot;_variable_declaration_&quot;;</span></a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">          2 :                const SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(declaration);</span></a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineCov">          2 :                ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="1571"><span class="lineNum">    1571 </span><span class="lineCov">          2 :                SgInitializedNamePtrList::const_iterator i = variableDeclaration-&gt;get_variables().begin();</span></a>
<a name="1572"><span class="lineNum">    1572 </span>            : </a>
<a name="1573"><span class="lineNum">    1573 </span>            :             // Make sure that we have at least one variable in the list</a>
<a name="1574"><span class="lineNum">    1574 </span><span class="lineCov">          2 :                ROSE_ASSERT(i != variableDeclaration-&gt;get_variables().end());</span></a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">          2 :                do {</span></a>
<a name="1576"><span class="lineNum">    1576 </span>            :                  // name += string(&quot; &quot;) + string((*i)-&gt;get_name().str());</a>
<a name="1577"><span class="lineNum">    1577 </span><span class="lineCov">          4 :                     name += string((*i)-&gt;get_name().str());</span></a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineCov">          2 :                     i++;</span></a>
<a name="1579"><span class="lineNum">    1579 </span>            :                   }</a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineCov">          2 :                while (i != variableDeclaration-&gt;get_variables().end());</span></a>
<a name="1581"><span class="lineNum">    1581 </span>            :                break;</a>
<a name="1582"><span class="lineNum">    1582 </span>            :              }</a>
<a name="1583"><span class="lineNum">    1583 </span>            : </a>
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<a name="1585"><span class="lineNum">    1585 </span>            :        // DQ (3/8/2006): Implemented case for variable declaration (forgot this case)</a>
<a name="1586"><span class="lineNum">    1586 </span><span class="lineNoCov">          0 :           case V_SgVariableDefinition:</span></a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1588"><span class="lineNum">    1588 </span>            :             // DQ (2/11/2007): Modified to return names that can be used as variables (required</a>
<a name="1589"><span class="lineNum">    1589 </span>            :             // because we use this mechanism to generate names for unnamed structs and enums).</a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineNoCov">          0 :                name = &quot;_variable_definition_&quot;;</span></a>
<a name="1591"><span class="lineNum">    1591 </span><span class="lineNoCov">          0 :                const SgVariableDefinition* variableDefinition = isSgVariableDefinition(declaration);</span></a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(variableDefinition != NULL);</span></a>
<a name="1593"><span class="lineNum">    1593 </span>            : </a>
<a name="1594"><span class="lineNum">    1594 </span>            :             // define this in terms of the associated SgInitializedName</a>
<a name="1595"><span class="lineNum">    1595 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(variableDefinition-&gt;get_vardefn() != NULL);</span></a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineNoCov">          0 :                name += get_name(variableDefinition-&gt;get_vardefn());</span></a>
<a name="1597"><span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1598"><span class="lineNum">    1598 </span>            :              }</a>
<a name="1599"><span class="lineNum">    1599 </span>            : </a>
<a name="1600"><span class="lineNum">    1600 </span>            :        // DQ (3/17/2006): Implemented case for pragma declaration (forgot this case)</a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineNoCov">          0 :           case V_SgPragmaDeclaration:</span></a>
<a name="1602"><span class="lineNum">    1602 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineNoCov">          0 :                name = &quot;_pragma_declaration_&quot;;</span></a>
<a name="1604"><span class="lineNum">    1604 </span><span class="lineNoCov">          0 :                const SgPragmaDeclaration* pragmaDeclaration = isSgPragmaDeclaration(declaration);</span></a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(pragmaDeclaration != NULL);</span></a>
<a name="1606"><span class="lineNum">    1606 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(pragmaDeclaration-&gt;get_pragma() != NULL);</span></a>
<a name="1607"><span class="lineNum">    1607 </span><span class="lineNoCov">          0 :                name += get_name(pragmaDeclaration-&gt;get_pragma());</span></a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1609"><span class="lineNum">    1609 </span>            :              }</a>
<a name="1610"><span class="lineNum">    1610 </span>            : </a>
<a name="1611"><span class="lineNum">    1611 </span>            :        // DQ (4/15/2007): Implemented case for using directive statement (forgot this case)</a>
<a name="1612"><span class="lineNum">    1612 </span><span class="lineNoCov">          0 :           case V_SgUsingDirectiveStatement:</span></a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                name = &quot;_using_directive_statement_&quot;;</span></a>
<a name="1615"><span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                const SgUsingDirectiveStatement* usingDeclaration = isSgUsingDirectiveStatement(declaration);</span></a>
<a name="1616"><span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(usingDeclaration != NULL);</span></a>
<a name="1617"><span class="lineNum">    1617 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(usingDeclaration-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="1618"><span class="lineNum">    1618 </span><span class="lineNoCov">          0 :                name += get_name(usingDeclaration-&gt;get_namespaceDeclaration());</span></a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1620"><span class="lineNum">    1620 </span>            :              }</a>
<a name="1621"><span class="lineNum">    1621 </span>            : </a>
<a name="1622"><span class="lineNum">    1622 </span>            :        // DQ (6/20/2007): Added new case!</a>
<a name="1623"><span class="lineNum">    1623 </span><span class="lineNoCov">          0 :           case V_SgNamespaceAliasDeclarationStatement:</span></a>
<a name="1624"><span class="lineNum">    1624 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1625"><span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                name = &quot;_namespace_alias_directive_statement_&quot;;</span></a>
<a name="1626"><span class="lineNum">    1626 </span><span class="lineNoCov">          0 :                const SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);</span></a>
<a name="1627"><span class="lineNum">    1627 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceAliasDeclaration != NULL);</span></a>
<a name="1628"><span class="lineNum">    1628 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceAliasDeclaration-&gt;get_name().is_null() == false);</span></a>
<a name="1629"><span class="lineNum">    1629 </span><span class="lineNoCov">          0 :                name += namespaceAliasDeclaration-&gt;get_name();</span></a>
<a name="1630"><span class="lineNum">    1630 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1631"><span class="lineNum">    1631 </span>            :              }</a>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<a name="1633"><span class="lineNum">    1633 </span>            :        // DQ (6/20/2007): Added new case!</a>
<a name="1634"><span class="lineNum">    1634 </span><span class="lineNoCov">          0 :           case V_SgUsingDeclarationStatement:</span></a>
<a name="1635"><span class="lineNum">    1635 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1636"><span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                name = &quot;_using_declaration_statement_&quot;;</span></a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineNoCov">          0 :                const SgUsingDeclarationStatement* usingDeclaration = isSgUsingDeclarationStatement(declaration);</span></a>
<a name="1638"><span class="lineNum">    1638 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(usingDeclaration != NULL);</span></a>
<a name="1639"><span class="lineNum">    1639 </span><span class="lineNoCov">          0 :                if (usingDeclaration-&gt;get_declaration() != NULL)</span></a>
<a name="1640"><span class="lineNum">    1640 </span>            :                   {</a>
<a name="1641"><span class="lineNum">    1641 </span><span class="lineNoCov">          0 :                     name += get_name(usingDeclaration-&gt;get_declaration());</span></a>
<a name="1642"><span class="lineNum">    1642 </span>            :                   }</a>
<a name="1643"><span class="lineNum">    1643 </span>            :                  else</a>
<a name="1644"><span class="lineNum">    1644 </span>            :                   {</a>
<a name="1645"><span class="lineNum">    1645 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(usingDeclaration-&gt;get_initializedName() != NULL);</span></a>
<a name="1646"><span class="lineNum">    1646 </span><span class="lineNoCov">          0 :                     name += get_name(usingDeclaration-&gt;get_initializedName());</span></a>
<a name="1647"><span class="lineNum">    1647 </span>            :                   }</a>
<a name="1648"><span class="lineNum">    1648 </span>            :                break;</a>
<a name="1649"><span class="lineNum">    1649 </span>            :              }</a>
<a name="1650"><span class="lineNum">    1650 </span>            : </a>
<a name="1651"><span class="lineNum">    1651 </span>            :        // DQ (6/20/2007): Added new case!</a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineNoCov">          0 :           case V_SgTemplateInstantiationDirectiveStatement:</span></a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineNoCov">          0 :                name = &quot;_template_instantiation_directive_statement_&quot;;</span></a>
<a name="1655"><span class="lineNum">    1655 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(declaration != NULL);</span></a>
<a name="1656"><span class="lineNum">    1656 </span><span class="lineNoCov">          0 :                const SgTemplateInstantiationDirectiveStatement* templateInstantiationDirective = isSgTemplateInstantiationDirectiveStatement(declaration);</span></a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateInstantiationDirective != NULL);</span></a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateInstantiationDirective-&gt;get_declaration() != NULL);</span></a>
<a name="1659"><span class="lineNum">    1659 </span>            : #if 0</a>
<a name="1660"><span class="lineNum">    1660 </span>            :                printf (&quot;declaration-&gt;get_declaration() = %p = %s \n&quot;,templateInstantiationDirective-&gt;get_declaration(),templateInstantiationDirective-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="1661"><span class="lineNum">    1661 </span>            : #endif</a>
<a name="1662"><span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                name += get_name(templateInstantiationDirective-&gt;get_declaration());</span></a>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1664"><span class="lineNum">    1664 </span>            :              }</a>
<a name="1665"><span class="lineNum">    1665 </span>            : </a>
<a name="1666"><span class="lineNum">    1666 </span><span class="lineNoCov">          0 :           case V_SgCtorInitializerList:</span></a>
<a name="1667"><span class="lineNum">    1667 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineNoCov">          0 :                name = &quot;_ctor_list_&quot;;</span></a>
<a name="1669"><span class="lineNum">    1669 </span><span class="lineNoCov">          0 :                const SgCtorInitializerList* ctorDeclaration = isSgCtorInitializerList(declaration);</span></a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(ctorDeclaration != NULL);</span></a>
<a name="1671"><span class="lineNum">    1671 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(ctorDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineNoCov">          0 :                name += get_name(ctorDeclaration-&gt;get_parent());</span></a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1674"><span class="lineNum">    1674 </span>            :              }</a>
<a name="1675"><span class="lineNum">    1675 </span>            : </a>
<a name="1676"><span class="lineNum">    1676 </span>            :        // DQ (8/9/2007): Added case for SgAsmStmt</a>
<a name="1677"><span class="lineNum">    1677 </span><span class="lineNoCov">          0 :           case V_SgAsmStmt:</span></a>
<a name="1678"><span class="lineNum">    1678 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1679"><span class="lineNum">    1679 </span><span class="lineNoCov">          0 :                name = &quot;_asm_stmt_&quot;;</span></a>
<a name="1680"><span class="lineNum">    1680 </span><span class="lineNoCov">          0 :                const SgAsmStmt* asmStatement = isSgAsmStmt(declaration);</span></a>
<a name="1681"><span class="lineNum">    1681 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(asmStatement != NULL);</span></a>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(asmStatement-&gt;get_parent() != NULL);</span></a>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgAsmStmt*&gt;(asmStatement));</span></a>
<a name="1684"><span class="lineNum">    1684 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1685"><span class="lineNum">    1685 </span>            :              }</a>
<a name="1686"><span class="lineNum">    1686 </span>            : </a>
<a name="1687"><span class="lineNum">    1687 </span>            :        // DQ (8/22/2007): Added case for SgImplicitStatement</a>
<a name="1688"><span class="lineNum">    1688 </span><span class="lineNoCov">          0 :           case V_SgImplicitStatement:</span></a>
<a name="1689"><span class="lineNum">    1689 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1690"><span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_implicit_&quot;;</span></a>
<a name="1691"><span class="lineNum">    1691 </span><span class="lineNoCov">          0 :                const SgImplicitStatement* implicitStatement = isSgImplicitStatement(declaration);</span></a>
<a name="1692"><span class="lineNum">    1692 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(implicitStatement != NULL);</span></a>
<a name="1693"><span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(implicitStatement-&gt;get_parent() != NULL);</span></a>
<a name="1694"><span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgImplicitStatement*&gt;(implicitStatement));</span></a>
<a name="1695"><span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1696"><span class="lineNum">    1696 </span>            :              }</a>
<a name="1697"><span class="lineNum">    1697 </span>            : </a>
<a name="1698"><span class="lineNum">    1698 </span>            :        // DQ (8/22/2007): Added case for SgNamelistStatement</a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineNoCov">          0 :           case V_SgNamelistStatement:</span></a>
<a name="1700"><span class="lineNum">    1700 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_namelist_&quot;;</span></a>
<a name="1702"><span class="lineNum">    1702 </span><span class="lineNoCov">          0 :                const SgNamelistStatement* namelistStatement = isSgNamelistStatement(declaration);</span></a>
<a name="1703"><span class="lineNum">    1703 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namelistStatement != NULL);</span></a>
<a name="1704"><span class="lineNum">    1704 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namelistStatement-&gt;get_parent() != NULL);</span></a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgNamelistStatement*&gt;(namelistStatement));</span></a>
<a name="1706"><span class="lineNum">    1706 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1707"><span class="lineNum">    1707 </span>            :              }</a>
<a name="1708"><span class="lineNum">    1708 </span>            : </a>
<a name="1709"><span class="lineNum">    1709 </span>            :        // DQ (11/21/2007): Added case for SgEquivalenceStatement</a>
<a name="1710"><span class="lineNum">    1710 </span><span class="lineNoCov">          0 :           case V_SgEquivalenceStatement:</span></a>
<a name="1711"><span class="lineNum">    1711 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1712"><span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_equivalence_&quot;;</span></a>
<a name="1713"><span class="lineNum">    1713 </span><span class="lineNoCov">          0 :                const SgEquivalenceStatement* equivalenceStatement = isSgEquivalenceStatement(declaration);</span></a>
<a name="1714"><span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(equivalenceStatement != NULL);</span></a>
<a name="1715"><span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(equivalenceStatement-&gt;get_parent() != NULL);</span></a>
<a name="1716"><span class="lineNum">    1716 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgEquivalenceStatement*&gt;(equivalenceStatement));</span></a>
<a name="1717"><span class="lineNum">    1717 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1718"><span class="lineNum">    1718 </span>            :              }</a>
<a name="1719"><span class="lineNum">    1719 </span>            : </a>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<a name="1721"><span class="lineNum">    1721 </span>            :        // DQ (11/21/2007): Added case for SgCommonBlock</a>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineNoCov">          0 :           case V_SgCommonBlock:</span></a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1724"><span class="lineNum">    1724 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_common_block_&quot;;</span></a>
<a name="1725"><span class="lineNum">    1725 </span><span class="lineNoCov">          0 :                const SgCommonBlock* commonBlockStatement = isSgCommonBlock(declaration);</span></a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(commonBlockStatement != NULL);</span></a>
<a name="1727"><span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(commonBlockStatement-&gt;get_parent() != NULL);</span></a>
<a name="1728"><span class="lineNum">    1728 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgCommonBlock*&gt;(commonBlockStatement));</span></a>
<a name="1729"><span class="lineNum">    1729 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1730"><span class="lineNum">    1730 </span>            :              }</a>
<a name="1731"><span class="lineNum">    1731 </span>            : </a>
<a name="1732"><span class="lineNum">    1732 </span>            :        // DQ (11/21/2007): Added case for SgImportStatement</a>
<a name="1733"><span class="lineNum">    1733 </span><span class="lineNoCov">          0 :           case V_SgImportStatement:</span></a>
<a name="1734"><span class="lineNum">    1734 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1735"><span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_import_stmt_&quot;;</span></a>
<a name="1736"><span class="lineNum">    1736 </span><span class="lineNoCov">          0 :                const SgImportStatement* importStatement = isSgImportStatement(declaration);</span></a>
<a name="1737"><span class="lineNum">    1737 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(importStatement != NULL);</span></a>
<a name="1738"><span class="lineNum">    1738 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(importStatement-&gt;get_parent() != NULL);</span></a>
<a name="1739"><span class="lineNum">    1739 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgImportStatement*&gt;(importStatement));</span></a>
<a name="1740"><span class="lineNum">    1740 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1741"><span class="lineNum">    1741 </span>            :              }</a>
<a name="1742"><span class="lineNum">    1742 </span>            : </a>
<a name="1743"><span class="lineNum">    1743 </span>            :        // DQ (11/21/2007): Added case for SgFormatStatement</a>
<a name="1744"><span class="lineNum">    1744 </span><span class="lineNoCov">          0 :           case V_SgFormatStatement:</span></a>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1746"><span class="lineNum">    1746 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_format_stmt_&quot;;</span></a>
<a name="1747"><span class="lineNum">    1747 </span><span class="lineNoCov">          0 :                const SgFormatStatement* formatStatement = isSgFormatStatement(declaration);</span></a>
<a name="1748"><span class="lineNum">    1748 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(formatStatement != NULL);</span></a>
<a name="1749"><span class="lineNum">    1749 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(formatStatement-&gt;get_parent() != NULL);</span></a>
<a name="1750"><span class="lineNum">    1750 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgFormatStatement*&gt;(formatStatement));</span></a>
<a name="1751"><span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1752"><span class="lineNum">    1752 </span>            :              }</a>
<a name="1753"><span class="lineNum">    1753 </span>            : </a>
<a name="1754"><span class="lineNum">    1754 </span>            :        // DQ (12/27/2007): Added case for SgModuleStatement</a>
<a name="1755"><span class="lineNum">    1755 </span><span class="lineNoCov">          0 :           case V_SgModuleStatement:</span></a>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1757"><span class="lineNum">    1757 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_module_stmt_&quot;;</span></a>
<a name="1758"><span class="lineNum">    1758 </span><span class="lineNoCov">          0 :                const SgModuleStatement* moduleStatement = isSgModuleStatement(declaration);</span></a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(moduleStatement != NULL);</span></a>
<a name="1760"><span class="lineNum">    1760 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(moduleStatement-&gt;get_parent() != NULL);</span></a>
<a name="1761"><span class="lineNum">    1761 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgModuleStatement*&gt;(moduleStatement));</span></a>
<a name="1762"><span class="lineNum">    1762 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1763"><span class="lineNum">    1763 </span>            :              }</a>
<a name="1764"><span class="lineNum">    1764 </span>            : </a>
<a name="1765"><span class="lineNum">    1765 </span>            :        // DQ (12/27/2007): Added case for SgUseStatement</a>
<a name="1766"><span class="lineNum">    1766 </span><span class="lineNoCov">          0 :           case V_SgUseStatement:</span></a>
<a name="1767"><span class="lineNum">    1767 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1768"><span class="lineNum">    1768 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_use_stmt_&quot;;</span></a>
<a name="1769"><span class="lineNum">    1769 </span><span class="lineNoCov">          0 :                const SgUseStatement* useStatement = isSgUseStatement(declaration);</span></a>
<a name="1770"><span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(useStatement != NULL);</span></a>
<a name="1771"><span class="lineNum">    1771 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(useStatement-&gt;get_parent() != NULL);</span></a>
<a name="1772"><span class="lineNum">    1772 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgUseStatement*&gt;(useStatement));</span></a>
<a name="1773"><span class="lineNum">    1773 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1774"><span class="lineNum">    1774 </span>            :              }</a>
<a name="1775"><span class="lineNum">    1775 </span>            : </a>
<a name="1776"><span class="lineNum">    1776 </span>            :        // DQ (12/28/2007): Added case for SgContainsStatement</a>
<a name="1777"><span class="lineNum">    1777 </span><span class="lineNoCov">          0 :           case V_SgContainsStatement:</span></a>
<a name="1778"><span class="lineNum">    1778 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1779"><span class="lineNum">    1779 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_contains_stmt_&quot;;</span></a>
<a name="1780"><span class="lineNum">    1780 </span><span class="lineNoCov">          0 :                const SgContainsStatement* containsStatement = isSgContainsStatement(declaration);</span></a>
<a name="1781"><span class="lineNum">    1781 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(containsStatement != NULL);</span></a>
<a name="1782"><span class="lineNum">    1782 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(containsStatement-&gt;get_parent() != NULL);</span></a>
<a name="1783"><span class="lineNum">    1783 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgContainsStatement*&gt;(containsStatement));</span></a>
<a name="1784"><span class="lineNum">    1784 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1785"><span class="lineNum">    1785 </span>            :              }</a>
<a name="1786"><span class="lineNum">    1786 </span>            : </a>
<a name="1787"><span class="lineNum">    1787 </span>            :        // DQ (1/20/2008): Added case for SgEntryStatement</a>
<a name="1788"><span class="lineNum">    1788 </span><span class="lineNoCov">          0 :           case V_SgEntryStatement:</span></a>
<a name="1789"><span class="lineNum">    1789 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1790"><span class="lineNum">    1790 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_entry_stmt_&quot;;</span></a>
<a name="1791"><span class="lineNum">    1791 </span><span class="lineNoCov">          0 :                const SgEntryStatement* entryStatement = isSgEntryStatement(declaration);</span></a>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(entryStatement != NULL);</span></a>
<a name="1793"><span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(entryStatement-&gt;get_parent() != NULL);</span></a>
<a name="1794"><span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgEntryStatement*&gt;(entryStatement));</span></a>
<a name="1795"><span class="lineNum">    1795 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1796"><span class="lineNum">    1796 </span>            :              }</a>
<a name="1797"><span class="lineNum">    1797 </span>            : </a>
<a name="1798"><span class="lineNum">    1798 </span>            :        // DQ (1/23/2008): Added case for SgAttributeSpecificationStatement</a>
<a name="1799"><span class="lineNum">    1799 </span><span class="lineNoCov">          0 :           case V_SgAttributeSpecificationStatement:</span></a>
<a name="1800"><span class="lineNum">    1800 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1801"><span class="lineNum">    1801 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_attribute_specification_stmt_&quot;;</span></a>
<a name="1802"><span class="lineNum">    1802 </span><span class="lineNoCov">          0 :                const SgAttributeSpecificationStatement* statement = isSgAttributeSpecificationStatement(declaration);</span></a>
<a name="1803"><span class="lineNum">    1803 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement != NULL);</span></a>
<a name="1804"><span class="lineNum">    1804 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement-&gt;get_parent() != NULL);</span></a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgAttributeSpecificationStatement*&gt;(statement));</span></a>
<a name="1806"><span class="lineNum">    1806 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1807"><span class="lineNum">    1807 </span>            :              }</a>
<a name="1808"><span class="lineNum">    1808 </span>            : </a>
<a name="1809"><span class="lineNum">    1809 </span><span class="lineNoCov">          0 :            case V_SgInterfaceStatement:</span></a>
<a name="1810"><span class="lineNum">    1810 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1811"><span class="lineNum">    1811 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_interface_stmt_&quot;;</span></a>
<a name="1812"><span class="lineNum">    1812 </span><span class="lineNoCov">          0 :                const SgInterfaceStatement* statement = isSgInterfaceStatement(declaration);</span></a>
<a name="1813"><span class="lineNum">    1813 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement != NULL);</span></a>
<a name="1814"><span class="lineNum">    1814 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement-&gt;get_parent() != NULL);</span></a>
<a name="1815"><span class="lineNum">    1815 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgInterfaceStatement*&gt;(statement));</span></a>
<a name="1816"><span class="lineNum">    1816 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1817"><span class="lineNum">    1817 </span>            :              }</a>
<a name="1818"><span class="lineNum">    1818 </span>            : </a>
<a name="1819"><span class="lineNum">    1819 </span><span class="lineNoCov">          0 :            case V_SgFortranIncludeLine:</span></a>
<a name="1820"><span class="lineNum">    1820 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1821"><span class="lineNum">    1821 </span><span class="lineNoCov">          0 :                name = &quot;_fortran_include_line_stmt_&quot;;</span></a>
<a name="1822"><span class="lineNum">    1822 </span><span class="lineNoCov">          0 :                const SgFortranIncludeLine* statement = isSgFortranIncludeLine(declaration);</span></a>
<a name="1823"><span class="lineNum">    1823 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement != NULL);</span></a>
<a name="1824"><span class="lineNum">    1824 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement-&gt;get_parent() != NULL);</span></a>
<a name="1825"><span class="lineNum">    1825 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgFortranIncludeLine*&gt;(statement));</span></a>
<a name="1826"><span class="lineNum">    1826 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1827"><span class="lineNum">    1827 </span>            :              }</a>
<a name="1828"><span class="lineNum">    1828 </span>            : </a>
<a name="1829"><span class="lineNum">    1829 </span>            :        // DQ (1/21/2018): Added case for C++11 SgStaticAssertionDeclaration</a>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineNoCov">          0 :           case V_SgStaticAssertionDeclaration:</span></a>
<a name="1831"><span class="lineNum">    1831 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1832"><span class="lineNum">    1832 </span><span class="lineNoCov">          0 :                name = &quot;_static_assertion_declaration_stmt_&quot;;</span></a>
<a name="1833"><span class="lineNum">    1833 </span><span class="lineNoCov">          0 :                const SgStaticAssertionDeclaration* statement = isSgStaticAssertionDeclaration(declaration);</span></a>
<a name="1834"><span class="lineNum">    1834 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement != NULL);</span></a>
<a name="1835"><span class="lineNum">    1835 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement-&gt;get_parent() != NULL);</span></a>
<a name="1836"><span class="lineNum">    1836 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(const_cast&lt;SgStaticAssertionDeclaration*&gt;(statement));</span></a>
<a name="1837"><span class="lineNum">    1837 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1838"><span class="lineNum">    1838 </span>            :              }</a>
<a name="1839"><span class="lineNum">    1839 </span>            : </a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineNoCov">          0 :           case V_SgNonrealDecl:</span></a>
<a name="1841"><span class="lineNum">    1841 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1842"><span class="lineNum">    1842 </span><span class="lineNoCov">          0 :                const SgNonrealDecl * nrdecl = isSgNonrealDecl(declaration);</span></a>
<a name="1843"><span class="lineNum">    1843 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nrdecl != NULL);</span></a>
<a name="1844"><span class="lineNum">    1844 </span><span class="lineNoCov">          0 :                name = nrdecl-&gt;get_name();</span></a>
<a name="1845"><span class="lineNum">    1845 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1846"><span class="lineNum">    1846 </span>            :              }</a>
<a name="1847"><span class="lineNum">    1847 </span>            : </a>
<a name="1848"><span class="lineNum">    1848 </span>            :        // DQ (3/26/2019): Adding support for new declaration.</a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineNoCov">          0 :           case V_SgEmptyDeclaration:</span></a>
<a name="1850"><span class="lineNum">    1850 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="1851"><span class="lineNum">    1851 </span><span class="lineNoCov">          0 :                const SgEmptyDeclaration * emptyDeclaration = isSgEmptyDeclaration(declaration);</span></a>
<a name="1852"><span class="lineNum">    1852 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(emptyDeclaration != NULL);</span></a>
<a name="1853"><span class="lineNum">    1853 </span><span class="lineNoCov">          0 :                name = string(&quot;emptyDeclaration&quot;) + StringUtility::numberToString(const_cast&lt;SgDeclarationStatement*&gt;(declaration));</span></a>
<a name="1854"><span class="lineNum">    1854 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1855"><span class="lineNum">    1855 </span>            :              }</a>
<a name="1856"><span class="lineNum">    1856 </span>            :        // Note that the case for SgVariableDeclaration is not implemented</a>
<a name="1857"><span class="lineNum">    1857 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="1858"><span class="lineNum">    1858 </span>            :             // name = &quot;default name (default case reached: not handled)&quot;;</a>
<a name="1859"><span class="lineNum">    1859 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: default case reached in SageInterface::get_name ( const SgDeclarationStatement* declaration ), declaration = %p = %s \n&quot;,</span></a>
<a name="1860"><span class="lineNum">    1860 </span><span class="lineNoCov">          0 :                     declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="1861"><span class="lineNum">    1861 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1862"><span class="lineNum">    1862 </span>            : #if 0 // [Robb Matzke 2021-03-24]: unreachable</a>
<a name="1863"><span class="lineNum">    1863 </span>            :                name = &quot;default_name_case_reached_not_handled&quot;;</a>
<a name="1864"><span class="lineNum">    1864 </span>            :                break;</a>
<a name="1865"><span class="lineNum">    1865 </span>            : #endif</a>
<a name="1866"><span class="lineNum">    1866 </span>            :         }</a>
<a name="1867"><span class="lineNum">    1867 </span>            : </a>
<a name="1868"><span class="lineNum">    1868 </span><span class="lineCov">     261320 :      return name;</span></a>
<a name="1869"><span class="lineNum">    1869 </span>            :    }</a>
<a name="1870"><span class="lineNum">    1870 </span>            : </a>
<a name="1871"><span class="lineNum">    1871 </span>            : string</a>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineCov">     248241 : SageInterface::get_name ( const SgScopeStatement* scope )</span></a>
<a name="1873"><span class="lineNum">    1873 </span>            :    {</a>
<a name="1874"><span class="lineNum">    1874 </span><span class="lineCov">     248241 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="1875"><span class="lineNum">    1875 </span>            : </a>
<a name="1876"><span class="lineNum">    1876 </span><span class="lineCov">     248241 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="1877"><span class="lineNum">    1877 </span>            : </a>
<a name="1878"><span class="lineNum">    1878 </span><span class="lineCov">     248241 :      switch (scope-&gt;variantT())</span></a>
<a name="1879"><span class="lineNum">    1879 </span>            :         {</a>
<a name="1880"><span class="lineNum">    1880 </span>            :        // DQ (6/11/2011): Added support for new template IR nodes.</a>
<a name="1881"><span class="lineNum">    1881 </span><span class="lineCov">      20716 :           case V_SgTemplateClassDefinition:</span></a>
<a name="1882"><span class="lineNum">    1882 </span><span class="lineCov">      20716 :                name = get_name(isSgTemplateClassDefinition(scope)-&gt;get_declaration());</span></a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineCov">      20716 :                break;</span></a>
<a name="1884"><span class="lineNum">    1884 </span>            : </a>
<a name="1885"><span class="lineNum">    1885 </span><span class="lineCov">      23929 :           case V_SgClassDefinition:</span></a>
<a name="1886"><span class="lineNum">    1886 </span><span class="lineCov">      23929 :           case V_SgTemplateInstantiationDefn:</span></a>
<a name="1887"><span class="lineNum">    1887 </span><span class="lineCov">      23929 :                name = get_name(isSgClassDefinition(scope)-&gt;get_declaration());</span></a>
<a name="1888"><span class="lineNum">    1888 </span><span class="lineCov">      23929 :                break;</span></a>
<a name="1889"><span class="lineNum">    1889 </span>            : </a>
<a name="1890"><span class="lineNum">    1890 </span>            :        // DQ (9/8/2012): Added missing case for SgTemplateFunctionDefinition.</a>
<a name="1891"><span class="lineNum">    1891 </span><span class="lineNoCov">          0 :           case V_SgTemplateFunctionDefinition:</span></a>
<a name="1892"><span class="lineNum">    1892 </span><span class="lineNoCov">          0 :           case V_SgFunctionDefinition:</span></a>
<a name="1893"><span class="lineNum">    1893 </span><span class="lineNoCov">          0 :                name = get_name(isSgFunctionDefinition(scope)-&gt;get_declaration());</span></a>
<a name="1894"><span class="lineNum">    1894 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="1895"><span class="lineNum">    1895 </span>            : </a>
<a name="1896"><span class="lineNum">    1896 </span><span class="lineCov">      85933 :           case V_SgNamespaceDefinitionStatement:</span></a>
<a name="1897"><span class="lineNum">    1897 </span><span class="lineCov">      85933 :                name = get_name(isSgNamespaceDefinitionStatement(scope)-&gt;get_namespaceDeclaration());</span></a>
<a name="1898"><span class="lineNum">    1898 </span><span class="lineCov">      85933 :                break;</span></a>
<a name="1899"><span class="lineNum">    1899 </span>            : </a>
<a name="1900"><span class="lineNum">    1900 </span>            :        // DQ (7/18/2017): Added support for the new declaration scope.</a>
<a name="1901"><span class="lineNum">    1901 </span><span class="lineCov">     117663 :           case V_SgDeclarationScope:</span></a>
<a name="1902"><span class="lineNum">    1902 </span>            : </a>
<a name="1903"><span class="lineNum">    1903 </span>            :        // DQ (11/30/2007): Added more fortran support.</a>
<a name="1904"><span class="lineNum">    1904 </span><span class="lineCov">     117663 :           case V_SgAssociateStatement:</span></a>
<a name="1905"><span class="lineNum">    1905 </span><span class="lineCov">     117663 :           case V_SgBasicBlock:</span></a>
<a name="1906"><span class="lineNum">    1906 </span><span class="lineCov">     117663 :           case V_SgCatchOptionStmt:</span></a>
<a name="1907"><span class="lineNum">    1907 </span><span class="lineCov">     117663 :           case V_SgDoWhileStmt:</span></a>
<a name="1908"><span class="lineNum">    1908 </span><span class="lineCov">     117663 :           case V_SgForStatement:</span></a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineCov">     117663 :           case V_SgGlobal:</span></a>
<a name="1910"><span class="lineNum">    1910 </span><span class="lineCov">     117663 :           case V_SgIfStmt:</span></a>
<a name="1911"><span class="lineNum">    1911 </span><span class="lineCov">     117663 :           case V_SgSwitchStatement:</span></a>
<a name="1912"><span class="lineNum">    1912 </span><span class="lineCov">     117663 :           case V_SgWhileStmt:</span></a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineCov">     117663 :           case V_SgFortranDo:</span></a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineCov">     117663 :           case V_SgForAllStatement:</span></a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineCov">     117663 :           case V_SgRangeBasedForStatement:</span></a>
<a name="1916"><span class="lineNum">    1916 </span><span class="lineCov">     117663 :                name = StringUtility::numberToString(const_cast&lt;SgScopeStatement*&gt;(scope));</span></a>
<a name="1917"><span class="lineNum">    1917 </span><span class="lineCov">     117663 :                break;</span></a>
<a name="1918"><span class="lineNum">    1918 </span>            : </a>
<a name="1919"><span class="lineNum">    1919 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="1920"><span class="lineNum">    1920 </span><span class="lineNoCov">          0 :                printf (&quot;Error: undefined case (SgScopeStatement) in SageInterface::get_name(): node = %s \n&quot;,scope-&gt;class_name().c_str());</span></a>
<a name="1921"><span class="lineNum">    1921 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="1922"><span class="lineNum">    1922 </span>            :         }</a>
<a name="1923"><span class="lineNum">    1923 </span>            : </a>
<a name="1924"><span class="lineNum">    1924 </span><span class="lineCov">     248241 :      return name;</span></a>
<a name="1925"><span class="lineNum">    1925 </span>            :    }</a>
<a name="1926"><span class="lineNum">    1926 </span>            : </a>
<a name="1927"><span class="lineNum">    1927 </span>            : string</a>
<a name="1928"><span class="lineNum">    1928 </span><span class="lineNoCov">          0 : SageInterface::get_name ( const SgStatement* stmt )</span></a>
<a name="1929"><span class="lineNum">    1929 </span>            :    {</a>
<a name="1930"><span class="lineNum">    1930 </span><span class="lineNoCov">          0 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="1931"><span class="lineNum">    1931 </span>            : </a>
<a name="1932"><span class="lineNum">    1932 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(stmt != NULL);</span></a>
<a name="1933"><span class="lineNum">    1933 </span>            : </a>
<a name="1934"><span class="lineNum">    1934 </span><span class="lineNoCov">          0 :      const SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);</span></a>
<a name="1935"><span class="lineNum">    1935 </span><span class="lineNoCov">          0 :      if (declaration != NULL)</span></a>
<a name="1936"><span class="lineNum">    1936 </span>            :         {</a>
<a name="1937"><span class="lineNum">    1937 </span><span class="lineNoCov">          0 :           name = get_name(declaration);</span></a>
<a name="1938"><span class="lineNum">    1938 </span>            :         }</a>
<a name="1939"><span class="lineNum">    1939 </span>            :        else</a>
<a name="1940"><span class="lineNum">    1940 </span>            :         {</a>
<a name="1941"><span class="lineNum">    1941 </span><span class="lineNoCov">          0 :           const SgScopeStatement* scope = isSgScopeStatement(stmt);</span></a>
<a name="1942"><span class="lineNum">    1942 </span><span class="lineNoCov">          0 :           if (scope != NULL)</span></a>
<a name="1943"><span class="lineNum">    1943 </span>            :              {</a>
<a name="1944"><span class="lineNum">    1944 </span><span class="lineNoCov">          0 :                name = get_name(scope);</span></a>
<a name="1945"><span class="lineNum">    1945 </span>            :              }</a>
<a name="1946"><span class="lineNum">    1946 </span>            :             else</a>
<a name="1947"><span class="lineNum">    1947 </span>            :              {</a>
<a name="1948"><span class="lineNum">    1948 </span>            : #if 0</a>
<a name="1949"><span class="lineNum">    1949 </span>            :             // DQ (9/5/2005): I think this is good enough for the more general case</a>
<a name="1950"><span class="lineNum">    1950 </span>            :                name = stmt-&gt;class_name();</a>
<a name="1951"><span class="lineNum">    1951 </span>            : #else</a>
<a name="1952"><span class="lineNum">    1952 </span>            :             // DQ (10/25/2007): This is better since it names the SgLabelStatement case</a>
<a name="1953"><span class="lineNum">    1953 </span><span class="lineNoCov">          0 :                switch (stmt-&gt;variantT())</span></a>
<a name="1954"><span class="lineNum">    1954 </span>            :                   {</a>
<a name="1955"><span class="lineNum">    1955 </span>            : #if 0</a>
<a name="1956"><span class="lineNum">    1956 </span>            :                     case V_SgBreakStmt:</a>
<a name="1957"><span class="lineNum">    1957 </span>            :                     case V_SgCaseOptionStmt:</a>
<a name="1958"><span class="lineNum">    1958 </span>            :                     case V_SgCatchStatementSeq:</a>
<a name="1959"><span class="lineNum">    1959 </span>            :                     case V_SgClinkageStartStatement:</a>
<a name="1960"><span class="lineNum">    1960 </span>            :                     case V_SgContinueStmt:</a>
<a name="1961"><span class="lineNum">    1961 </span>            :                     case V_SgDefaultOptionStmt:</a>
<a name="1962"><span class="lineNum">    1962 </span>            :                     case V_SgExprStmt:</a>
<a name="1963"><span class="lineNum">    1963 </span>            :                     case V_SgForInitStmt:</a>
<a name="1964"><span class="lineNum">    1964 </span>            :                     case V_SgFunctionTypeTable:</a>
<a name="1965"><span class="lineNum">    1965 </span>            :                     case V_SgGotoStatement:</a>
<a name="1966"><span class="lineNum">    1966 </span>            :                     case V_SgReturnStmt:</a>
<a name="1967"><span class="lineNum">    1967 </span>            :                     case V_SgSpawnStmt:</a>
<a name="1968"><span class="lineNum">    1968 </span>            :                     case V_SgTryStmt:</a>
<a name="1969"><span class="lineNum">    1969 </span>            :                          name = stmt-&gt;class_name();</a>
<a name="1970"><span class="lineNum">    1970 </span>            :                          break;</a>
<a name="1971"><span class="lineNum">    1971 </span>            : #endif</a>
<a name="1972"><span class="lineNum">    1972 </span><span class="lineNoCov">          0 :                     case V_SgLabelStatement:</span></a>
<a name="1973"><span class="lineNum">    1973 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="1974"><span class="lineNum">    1974 </span><span class="lineNoCov">          0 :                          const SgLabelStatement* labelStatement = isSgLabelStatement(stmt);</span></a>
<a name="1975"><span class="lineNum">    1975 </span><span class="lineNoCov">          0 :                          name = labelStatement-&gt;get_label().str();</span></a>
<a name="1976"><span class="lineNum">    1976 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="1977"><span class="lineNum">    1977 </span>            :                        }</a>
<a name="1978"><span class="lineNum">    1978 </span>            : </a>
<a name="1979"><span class="lineNum">    1979 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="1980"><span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="1981"><span class="lineNum">    1981 </span>            :                       // printf (&quot;Default reached in switch \n&quot;);</a>
<a name="1982"><span class="lineNum">    1982 </span>            :                       // name = &quot;default name&quot;;</a>
<a name="1983"><span class="lineNum">    1983 </span><span class="lineNoCov">          0 :                          name = stmt-&gt;class_name();</span></a>
<a name="1984"><span class="lineNum">    1984 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="1985"><span class="lineNum">    1985 </span>            :                        }</a>
<a name="1986"><span class="lineNum">    1986 </span>            :                   }</a>
<a name="1987"><span class="lineNum">    1987 </span>            : #endif</a>
<a name="1988"><span class="lineNum">    1988 </span>            :              }</a>
<a name="1989"><span class="lineNum">    1989 </span>            :         }</a>
<a name="1990"><span class="lineNum">    1990 </span>            : </a>
<a name="1991"><span class="lineNum">    1991 </span><span class="lineNoCov">          0 :      return name;</span></a>
<a name="1992"><span class="lineNum">    1992 </span>            :    }</a>
<a name="1993"><span class="lineNum">    1993 </span>            : </a>
<a name="1994"><span class="lineNum">    1994 </span>            : string</a>
<a name="1995"><span class="lineNum">    1995 </span><span class="lineCov">       4189 : SageInterface::get_name ( const SgSupport* node )</span></a>
<a name="1996"><span class="lineNum">    1996 </span>            :    {</a>
<a name="1997"><span class="lineNum">    1997 </span>            :   // This function is useful for debugging</a>
<a name="1998"><span class="lineNum">    1998 </span>            :   // This is the most general case of a function to return a name for an IR node.</a>
<a name="1999"><span class="lineNum">    1999 </span><span class="lineCov">       4189 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="2000"><span class="lineNum">    2000 </span>            : </a>
<a name="2001"><span class="lineNum">    2001 </span><span class="lineCov">       4189 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="2002"><span class="lineNum">    2002 </span>            : </a>
<a name="2003"><span class="lineNum">    2003 </span><span class="lineCov">       4189 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="2004"><span class="lineNum">    2004 </span>            : </a>
<a name="2005"><span class="lineNum">    2005 </span><span class="lineCov">       4189 :      switch (node-&gt;variantT())</span></a>
<a name="2006"><span class="lineNum">    2006 </span>            :         {</a>
<a name="2007"><span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           case V_SgInitializedName:</span></a>
<a name="2008"><span class="lineNum">    2008 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2009"><span class="lineNum">    2009 </span><span class="lineNoCov">          0 :                const SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="2010"><span class="lineNum">    2010 </span><span class="lineNoCov">          0 :                if (initializedName != NULL)</span></a>
<a name="2011"><span class="lineNum">    2011 </span>            :                   {</a>
<a name="2012"><span class="lineNum">    2012 </span><span class="lineNoCov">          0 :                     name = initializedName-&gt;get_name().str();</span></a>
<a name="2013"><span class="lineNum">    2013 </span>            :                   }</a>
<a name="2014"><span class="lineNum">    2014 </span>            :                break;</a>
<a name="2015"><span class="lineNum">    2015 </span>            :              }</a>
<a name="2016"><span class="lineNum">    2016 </span>            : #if 1</a>
<a name="2017"><span class="lineNum">    2017 </span>            :        // DQ (3/17/2006): Implemented case for pragma declaration (forgot this case)</a>
<a name="2018"><span class="lineNum">    2018 </span><span class="lineNoCov">          0 :           case V_SgPragma:</span></a>
<a name="2019"><span class="lineNum">    2019 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2020"><span class="lineNum">    2020 </span><span class="lineNoCov">          0 :                name = &quot;_pragma_string_&quot;;</span></a>
<a name="2021"><span class="lineNum">    2021 </span><span class="lineNoCov">          0 :                const SgPragma* pragma = isSgPragma(node);</span></a>
<a name="2022"><span class="lineNum">    2022 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(pragma != NULL);</span></a>
<a name="2023"><span class="lineNum">    2023 </span><span class="lineNoCov">          0 :                name += pragma-&gt;get_pragma();</span></a>
<a name="2024"><span class="lineNum">    2024 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2025"><span class="lineNum">    2025 </span>            :              }</a>
<a name="2026"><span class="lineNum">    2026 </span>            : #endif</a>
<a name="2027"><span class="lineNum">    2027 </span>            : </a>
<a name="2028"><span class="lineNum">    2028 </span>            :        // DQ (5/31/2007): Implemented case for SgProject</a>
<a name="2029"><span class="lineNum">    2029 </span><span class="lineNoCov">          0 :           case V_SgProject:</span></a>
<a name="2030"><span class="lineNum">    2030 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2031"><span class="lineNum">    2031 </span><span class="lineNoCov">          0 :                name = &quot;_project_&quot;;</span></a>
<a name="2032"><span class="lineNum">    2032 </span>            :                break;</a>
<a name="2033"><span class="lineNum">    2033 </span>            :              }</a>
<a name="2034"><span class="lineNum">    2034 </span>            : </a>
<a name="2035"><span class="lineNum">    2035 </span>            :        // DQ (5/31/2007): Implemented case for SgFile</a>
<a name="2036"><span class="lineNum">    2036 </span>            :        // case V_SgFile:</a>
<a name="2037"><span class="lineNum">    2037 </span><span class="lineNoCov">          0 :           case V_SgSourceFile:</span></a>
<a name="2038"><span class="lineNum">    2038 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2039"><span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                name = &quot;_file_&quot;;</span></a>
<a name="2040"><span class="lineNum">    2040 </span>            : </a>
<a name="2041"><span class="lineNum">    2041 </span>            :             // DQ (3/1/2009): Added support to include the file name.</a>
<a name="2042"><span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                const SgFile* file = isSgFile(node);</span></a>
<a name="2043"><span class="lineNum">    2043 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(file != NULL);</span></a>
<a name="2044"><span class="lineNum">    2044 </span>            : </a>
<a name="2045"><span class="lineNum">    2045 </span><span class="lineNoCov">          0 :                name += file-&gt;getFileName();</span></a>
<a name="2046"><span class="lineNum">    2046 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2047"><span class="lineNum">    2047 </span>            :              }</a>
<a name="2048"><span class="lineNum">    2048 </span>            : </a>
<a name="2049"><span class="lineNum">    2049 </span>            :        // DQ (5/31/2007): Implemented case for SgSymbolTable</a>
<a name="2050"><span class="lineNum">    2050 </span><span class="lineNoCov">          0 :           case V_SgSymbolTable:</span></a>
<a name="2051"><span class="lineNum">    2051 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2052"><span class="lineNum">    2052 </span><span class="lineNoCov">          0 :                name = &quot;_symbol_table_&quot;;</span></a>
<a name="2053"><span class="lineNum">    2053 </span>            :                break;</a>
<a name="2054"><span class="lineNum">    2054 </span>            :              }</a>
<a name="2055"><span class="lineNum">    2055 </span>            : </a>
<a name="2056"><span class="lineNum">    2056 </span>            :        // DQ (5/31/2007): Implemented case for SgStorageModifier</a>
<a name="2057"><span class="lineNum">    2057 </span><span class="lineNoCov">          0 :           case V_SgStorageModifier:</span></a>
<a name="2058"><span class="lineNum">    2058 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2059"><span class="lineNum">    2059 </span><span class="lineNoCov">          0 :                name = &quot;_storage_modifier_&quot;;</span></a>
<a name="2060"><span class="lineNum">    2060 </span>            :                break;</a>
<a name="2061"><span class="lineNum">    2061 </span>            :              }</a>
<a name="2062"><span class="lineNum">    2062 </span>            : </a>
<a name="2063"><span class="lineNum">    2063 </span>            : </a>
<a name="2064"><span class="lineNum">    2064 </span>            :        // DQ (5/31/2007): Implemented case for Sg_File_Info</a>
<a name="2065"><span class="lineNum">    2065 </span><span class="lineNoCov">          0 :           case V_Sg_File_Info:</span></a>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2067"><span class="lineNum">    2067 </span><span class="lineNoCov">          0 :                name = &quot;_file_info_&quot;;</span></a>
<a name="2068"><span class="lineNum">    2068 </span>            :                break;</a>
<a name="2069"><span class="lineNum">    2069 </span>            :              }</a>
<a name="2070"><span class="lineNum">    2070 </span>            : </a>
<a name="2071"><span class="lineNum">    2071 </span>            :        // DQ (8/7/2007): Implemented case for SgTemplateArgument</a>
<a name="2072"><span class="lineNum">    2072 </span><span class="lineNoCov">          0 :           case V_SgTemplateArgument:</span></a>
<a name="2073"><span class="lineNum">    2073 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2074"><span class="lineNum">    2074 </span><span class="lineNoCov">          0 :                name = &quot;_template_argument_&quot;;</span></a>
<a name="2075"><span class="lineNum">    2075 </span><span class="lineNoCov">          0 :                const SgTemplateArgument* templateArgument = isSgTemplateArgument(node);</span></a>
<a name="2076"><span class="lineNum">    2076 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateArgument != NULL);</span></a>
<a name="2077"><span class="lineNum">    2077 </span><span class="lineNoCov">          0 :                switch(templateArgument-&gt;get_argumentType())</span></a>
<a name="2078"><span class="lineNum">    2078 </span>            :                   {</a>
<a name="2079"><span class="lineNum">    2079 </span><span class="lineNoCov">          0 :                     case SgTemplateArgument::type_argument:</span></a>
<a name="2080"><span class="lineNum">    2080 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2081"><span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                          SgType* t = templateArgument-&gt;get_type();</span></a>
<a name="2082"><span class="lineNum">    2082 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(t != NULL);</span></a>
<a name="2083"><span class="lineNum">    2083 </span><span class="lineNoCov">          0 :                          name += get_name(t);</span></a>
<a name="2084"><span class="lineNum">    2084 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="2085"><span class="lineNum">    2085 </span>            :                        }</a>
<a name="2086"><span class="lineNum">    2086 </span>            : </a>
<a name="2087"><span class="lineNum">    2087 </span><span class="lineNoCov">          0 :                     case SgTemplateArgument::nontype_argument:</span></a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2089"><span class="lineNum">    2089 </span><span class="lineNoCov">          0 :                          SgExpression* t = templateArgument-&gt;get_expression();</span></a>
<a name="2090"><span class="lineNum">    2090 </span>            : </a>
<a name="2091"><span class="lineNum">    2091 </span>            :                       // DQ (8/11/2013): Adding support for including an initializedName instead of an expression (for template parameters used as expressions).</a>
<a name="2092"><span class="lineNum">    2092 </span>            :                       // ROSE_ASSERT(t != NULL);</a>
<a name="2093"><span class="lineNum">    2093 </span>            :                       // name += get_name(t);</a>
<a name="2094"><span class="lineNum">    2094 </span><span class="lineNoCov">          0 :                          if (t != NULL)</span></a>
<a name="2095"><span class="lineNum">    2095 </span>            :                             {</a>
<a name="2096"><span class="lineNum">    2096 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(templateArgument-&gt;get_initializedName() == NULL);</span></a>
<a name="2097"><span class="lineNum">    2097 </span><span class="lineNoCov">          0 :                               name += get_name(t);</span></a>
<a name="2098"><span class="lineNum">    2098 </span>            :                             }</a>
<a name="2099"><span class="lineNum">    2099 </span>            :                            else</a>
<a name="2100"><span class="lineNum">    2100 </span>            :                             {</a>
<a name="2101"><span class="lineNum">    2101 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(t == NULL);</span></a>
<a name="2102"><span class="lineNum">    2102 </span><span class="lineNoCov">          0 :                               SgInitializedName* initializedName = templateArgument-&gt;get_initializedName();</span></a>
<a name="2103"><span class="lineNum">    2103 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="2104"><span class="lineNum">    2104 </span>            : </a>
<a name="2105"><span class="lineNum">    2105 </span><span class="lineNoCov">          0 :                               name += get_name(initializedName);</span></a>
<a name="2106"><span class="lineNum">    2106 </span>            :                             }</a>
<a name="2107"><span class="lineNum">    2107 </span>            :                          break;</a>
<a name="2108"><span class="lineNum">    2108 </span>            :                        }</a>
<a name="2109"><span class="lineNum">    2109 </span>            : </a>
<a name="2110"><span class="lineNum">    2110 </span><span class="lineNoCov">          0 :                     case SgTemplateArgument::template_template_argument:</span></a>
<a name="2111"><span class="lineNum">    2111 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2112"><span class="lineNum">    2112 </span>            :                       // SgTemplateDeclaration* t = templateArgument-&gt;get_templateDeclaration();</a>
<a name="2113"><span class="lineNum">    2113 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* t = templateArgument-&gt;get_templateDeclaration();</span></a>
<a name="2114"><span class="lineNum">    2114 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(t != NULL);</span></a>
<a name="2115"><span class="lineNum">    2115 </span><span class="lineNoCov">          0 :                          name += get_name(t);</span></a>
<a name="2116"><span class="lineNum">    2116 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="2117"><span class="lineNum">    2117 </span>            :                        }</a>
<a name="2118"><span class="lineNum">    2118 </span>            : </a>
<a name="2119"><span class="lineNum">    2119 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="2120"><span class="lineNum">    2120 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2121"><span class="lineNum">    2121 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default case reached in switch on templateArgument-&gt;get_argumentType() \n&quot;);</span></a>
<a name="2122"><span class="lineNum">    2122 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="2123"><span class="lineNum">    2123 </span>            :                        }</a>
<a name="2124"><span class="lineNum">    2124 </span>            :                   }</a>
<a name="2125"><span class="lineNum">    2125 </span>            :                break;</a>
<a name="2126"><span class="lineNum">    2126 </span>            :              }</a>
<a name="2127"><span class="lineNum">    2127 </span>            : </a>
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<a name="2129"><span class="lineNum">    2129 </span>            :        // DQ (8/7/2007): Implemented case for SgTemplateArgument</a>
<a name="2130"><span class="lineNum">    2130 </span><span class="lineCov">       4189 :           case V_SgTypeModifier:</span></a>
<a name="2131"><span class="lineNum">    2131 </span><span class="lineCov">       4189 :              {</span></a>
<a name="2132"><span class="lineNum">    2132 </span><span class="lineCov">       4189 :                const SgTypeModifier* typeModifier = isSgTypeModifier(node);</span></a>
<a name="2133"><span class="lineNum">    2133 </span><span class="lineCov">       4189 :                ROSE_ASSERT(typeModifier != NULL);</span></a>
<a name="2134"><span class="lineNum">    2134 </span><span class="lineCov">       4189 :                name = &quot;_type_modifier_&quot; + typeModifier-&gt;displayString();</span></a>
<a name="2135"><span class="lineNum">    2135 </span><span class="lineCov">       4189 :                break;</span></a>
<a name="2136"><span class="lineNum">    2136 </span>            :              }</a>
<a name="2137"><span class="lineNum">    2137 </span>            : </a>
<a name="2138"><span class="lineNum">    2138 </span>            :        // DQ (11/19/2007): Implemented case for SgNameGroup</a>
<a name="2139"><span class="lineNum">    2139 </span><span class="lineNoCov">          0 :           case V_SgNameGroup:</span></a>
<a name="2140"><span class="lineNum">    2140 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2141"><span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                const SgNameGroup* nameGroup = isSgNameGroup(node);</span></a>
<a name="2142"><span class="lineNum">    2142 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nameGroup != NULL);</span></a>
<a name="2143"><span class="lineNum">    2143 </span><span class="lineNoCov">          0 :                name = &quot;_name_group_&quot; + nameGroup-&gt;get_group_name();</span></a>
<a name="2144"><span class="lineNum">    2144 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2145"><span class="lineNum">    2145 </span>            :              }</a>
<a name="2146"><span class="lineNum">    2146 </span>            : </a>
<a name="2147"><span class="lineNum">    2147 </span>            :        // DQ (11/20/2007): Implemented case for Fortran data statement support</a>
<a name="2148"><span class="lineNum">    2148 </span><span class="lineNoCov">          0 :           case V_SgDataStatementGroup:</span></a>
<a name="2149"><span class="lineNum">    2149 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2150"><span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                const SgDataStatementGroup* dataGroup = isSgDataStatementGroup(node);</span></a>
<a name="2151"><span class="lineNum">    2151 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(dataGroup != NULL);</span></a>
<a name="2152"><span class="lineNum">    2152 </span><span class="lineNoCov">          0 :                name = &quot;_data_statement_group_&quot;;</span></a>
<a name="2153"><span class="lineNum">    2153 </span>            :                break;</a>
<a name="2154"><span class="lineNum">    2154 </span>            :              }</a>
<a name="2155"><span class="lineNum">    2155 </span>            : </a>
<a name="2156"><span class="lineNum">    2156 </span>            :        // DQ (11/20/2007): Implemented case for Fortran data statement support</a>
<a name="2157"><span class="lineNum">    2157 </span><span class="lineNoCov">          0 :           case V_SgDataStatementObject:</span></a>
<a name="2158"><span class="lineNum">    2158 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2159"><span class="lineNum">    2159 </span><span class="lineNoCov">          0 :                const SgDataStatementObject* dataObject = isSgDataStatementObject(node);</span></a>
<a name="2160"><span class="lineNum">    2160 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(dataObject != NULL);</span></a>
<a name="2161"><span class="lineNum">    2161 </span><span class="lineNoCov">          0 :                name = &quot;_data_statement_object_&quot;;</span></a>
<a name="2162"><span class="lineNum">    2162 </span>            :                break;</a>
<a name="2163"><span class="lineNum">    2163 </span>            :              }</a>
<a name="2164"><span class="lineNum">    2164 </span>            : </a>
<a name="2165"><span class="lineNum">    2165 </span>            :        // DQ (11/20/2007): Implemented case for Fortran data statement support</a>
<a name="2166"><span class="lineNum">    2166 </span><span class="lineNoCov">          0 :           case V_SgDataStatementValue:</span></a>
<a name="2167"><span class="lineNum">    2167 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2168"><span class="lineNum">    2168 </span><span class="lineNoCov">          0 :                const SgDataStatementValue* dataValue = isSgDataStatementValue(node);</span></a>
<a name="2169"><span class="lineNum">    2169 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(dataValue != NULL);</span></a>
<a name="2170"><span class="lineNum">    2170 </span><span class="lineNoCov">          0 :                name = &quot;_data_statement_value_&quot;;</span></a>
<a name="2171"><span class="lineNum">    2171 </span>            :                break;</a>
<a name="2172"><span class="lineNum">    2172 </span>            :              }</a>
<a name="2173"><span class="lineNum">    2173 </span>            : </a>
<a name="2174"><span class="lineNum">    2174 </span>            :        // DQ (11/19/2007): Implemented case for SgCommonBlock</a>
<a name="2175"><span class="lineNum">    2175 </span><span class="lineNoCov">          0 :           case V_SgCommonBlockObject:</span></a>
<a name="2176"><span class="lineNum">    2176 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2177"><span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                const SgCommonBlockObject* commonBlockObject = isSgCommonBlockObject(node);</span></a>
<a name="2178"><span class="lineNum">    2178 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(commonBlockObject != NULL);</span></a>
<a name="2179"><span class="lineNum">    2179 </span><span class="lineNoCov">          0 :                name = &quot;_common_block_object_&quot; + commonBlockObject-&gt;get_block_name();</span></a>
<a name="2180"><span class="lineNum">    2180 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2181"><span class="lineNum">    2181 </span>            :              }</a>
<a name="2182"><span class="lineNum">    2182 </span>            : </a>
<a name="2183"><span class="lineNum">    2183 </span>            :        // DQ (12/23/2007): Added support for repeat_specification</a>
<a name="2184"><span class="lineNum">    2184 </span><span class="lineNoCov">          0 :           case V_SgFormatItem:</span></a>
<a name="2185"><span class="lineNum">    2185 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2186"><span class="lineNum">    2186 </span><span class="lineNoCov">          0 :                const SgFormatItem* formatItem = isSgFormatItem(node);</span></a>
<a name="2187"><span class="lineNum">    2187 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(formatItem != NULL);</span></a>
<a name="2188"><span class="lineNum">    2188 </span><span class="lineNoCov">          0 :                name = &quot;_format_item_&quot;;</span></a>
<a name="2189"><span class="lineNum">    2189 </span>            :                break;</a>
<a name="2190"><span class="lineNum">    2190 </span>            :              }</a>
<a name="2191"><span class="lineNum">    2191 </span>            : </a>
<a name="2192"><span class="lineNum">    2192 </span>            :        // DQ (12/23/2007): Added support for repeat_specification</a>
<a name="2193"><span class="lineNum">    2193 </span><span class="lineNoCov">          0 :           case V_SgFormatItemList:</span></a>
<a name="2194"><span class="lineNum">    2194 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2195"><span class="lineNum">    2195 </span><span class="lineNoCov">          0 :                const SgFormatItemList* formatItemList = isSgFormatItemList(node);</span></a>
<a name="2196"><span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(formatItemList != NULL);</span></a>
<a name="2197"><span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                name = &quot;_format_item_list_&quot;;</span></a>
<a name="2198"><span class="lineNum">    2198 </span>            :                break;</a>
<a name="2199"><span class="lineNum">    2199 </span>            :              }</a>
<a name="2200"><span class="lineNum">    2200 </span>            : </a>
<a name="2201"><span class="lineNum">    2201 </span>            :        // DQ (12/23/2007): Added support for repeat_specification</a>
<a name="2202"><span class="lineNum">    2202 </span><span class="lineNoCov">          0 :           case V_SgRenamePair:</span></a>
<a name="2203"><span class="lineNum">    2203 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2204"><span class="lineNum">    2204 </span><span class="lineNoCov">          0 :                const SgRenamePair* renamePair = isSgRenamePair(node);</span></a>
<a name="2205"><span class="lineNum">    2205 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(renamePair != NULL);</span></a>
<a name="2206"><span class="lineNum">    2206 </span><span class="lineNoCov">          0 :                name = renamePair-&gt;get_local_name() + &quot;__&quot; + renamePair-&gt;get_use_name() + &quot;_rename_pair_&quot;;</span></a>
<a name="2207"><span class="lineNum">    2207 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2208"><span class="lineNum">    2208 </span>            :              }</a>
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<a name="2210"><span class="lineNum">    2210 </span>            :        // DQ (12/2/2010): Implemented case for SgName</a>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineNoCov">          0 :           case V_SgName:</span></a>
<a name="2212"><span class="lineNum">    2212 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2213"><span class="lineNum">    2213 </span><span class="lineNoCov">          0 :                const SgName* name_node = isSgName(node);</span></a>
<a name="2214"><span class="lineNum">    2214 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(name_node != NULL);</span></a>
<a name="2215"><span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                name = &quot;_name_&quot; + name_node-&gt;getString();</span></a>
<a name="2216"><span class="lineNum">    2216 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2217"><span class="lineNum">    2217 </span>            :              }</a>
<a name="2218"><span class="lineNum">    2218 </span>            : </a>
<a name="2219"><span class="lineNum">    2219 </span>            :        // DQ (8/8/2013): Implemented case for SgTemplateParameter</a>
<a name="2220"><span class="lineNum">    2220 </span><span class="lineNoCov">          0 :           case V_SgTemplateParameter:</span></a>
<a name="2221"><span class="lineNum">    2221 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineNoCov">          0 :                const SgTemplateParameter* template_parameter_node = isSgTemplateParameter(node);</span></a>
<a name="2223"><span class="lineNum">    2223 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(template_parameter_node != NULL);</span></a>
<a name="2224"><span class="lineNum">    2224 </span><span class="lineNoCov">          0 :                name = &quot;_template_parameter_&quot;;</span></a>
<a name="2225"><span class="lineNum">    2225 </span>            : </a>
<a name="2226"><span class="lineNum">    2226 </span><span class="lineNoCov">          0 :                switch(template_parameter_node-&gt;get_parameterType())</span></a>
<a name="2227"><span class="lineNum">    2227 </span>            :                   {</a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineNoCov">          0 :                     case SgTemplateParameter::type_parameter:</span></a>
<a name="2229"><span class="lineNum">    2229 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2230"><span class="lineNum">    2230 </span><span class="lineNoCov">          0 :                          name += &quot;type_parameter_&quot;;</span></a>
<a name="2231"><span class="lineNum">    2231 </span>            :                          break;</a>
<a name="2232"><span class="lineNum">    2232 </span>            :                        }</a>
<a name="2233"><span class="lineNum">    2233 </span>            : </a>
<a name="2234"><span class="lineNum">    2234 </span><span class="lineNoCov">          0 :                     case SgTemplateParameter::nontype_parameter:</span></a>
<a name="2235"><span class="lineNum">    2235 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2236"><span class="lineNum">    2236 </span><span class="lineNoCov">          0 :                          name += &quot;nontype_parameter_&quot;;</span></a>
<a name="2237"><span class="lineNum">    2237 </span>            : #if 1</a>
<a name="2238"><span class="lineNum">    2238 </span><span class="lineNoCov">          0 :                          name += template_parameter_node-&gt;unparseToString();</span></a>
<a name="2239"><span class="lineNum">    2239 </span>            : #else</a>
<a name="2240"><span class="lineNum">    2240 </span>            :                          if (template_parameter_node-&gt;get_expression() != NULL)</a>
<a name="2241"><span class="lineNum">    2241 </span>            :                             {</a>
<a name="2242"><span class="lineNum">    2242 </span>            :                               name += template_parameter_node-&gt;get_expression()-&gt;unparseToString();</a>
<a name="2243"><span class="lineNum">    2243 </span>            :                             }</a>
<a name="2244"><span class="lineNum">    2244 </span>            :                            else</a>
<a name="2245"><span class="lineNum">    2245 </span>            :                             {</a>
<a name="2246"><span class="lineNum">    2246 </span>            :                               ROSE_ASSERT(template_parameter_node-&gt;get_initializedName() != NULL);</a>
<a name="2247"><span class="lineNum">    2247 </span>            : </a>
<a name="2248"><span class="lineNum">    2248 </span>            :                            // DQ (8/8/2013): This does not handle the case of &quot;template &lt;void (foo::*M)()&gt; void test() {}&quot;</a>
<a name="2249"><span class="lineNum">    2249 </span>            :                            // since what is unparsed is: &quot;_template_parameter_nontype_parameter_M&quot;</a>
<a name="2250"><span class="lineNum">    2250 </span>            :                            // instead of a string to represent what is in &quot;void (foo::*M)()&quot;</a>
<a name="2251"><span class="lineNum">    2251 </span>            :                            // and differentiate it from: &quot;int foo::*M&quot; in: &quot;template &lt;void (foo::*M)()&gt; void test() {}&quot;</a>
<a name="2252"><span class="lineNum">    2252 </span>            :                               name += template_parameter_node-&gt;get_initializedName()-&gt;unparseToString();</a>
<a name="2253"><span class="lineNum">    2253 </span>            :                             }</a>
<a name="2254"><span class="lineNum">    2254 </span>            : #endif</a>
<a name="2255"><span class="lineNum">    2255 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="2256"><span class="lineNum">    2256 </span>            :                        }</a>
<a name="2257"><span class="lineNum">    2257 </span>            : </a>
<a name="2258"><span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                     case SgTemplateParameter::template_parameter:</span></a>
<a name="2259"><span class="lineNum">    2259 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2260"><span class="lineNum">    2260 </span><span class="lineNoCov">          0 :                          name += &quot;template_parameter_&quot;;</span></a>
<a name="2261"><span class="lineNum">    2261 </span>            :                          break;</a>
<a name="2262"><span class="lineNum">    2262 </span>            :                        }</a>
<a name="2263"><span class="lineNum">    2263 </span>            : </a>
<a name="2264"><span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="2265"><span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="2266"><span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached \n&quot;);</span></a>
<a name="2267"><span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="2268"><span class="lineNum">    2268 </span>            :                        }</a>
<a name="2269"><span class="lineNum">    2269 </span>            :                   }</a>
<a name="2270"><span class="lineNum">    2270 </span>            :                break;</a>
<a name="2271"><span class="lineNum">    2271 </span>            :              }</a>
<a name="2272"><span class="lineNum">    2272 </span>            : </a>
<a name="2273"><span class="lineNum">    2273 </span>            :        // DQ (1/21/2019): Implemented case for SgBaseClass</a>
<a name="2274"><span class="lineNum">    2274 </span><span class="lineNoCov">          0 :           case V_SgBaseClass:</span></a>
<a name="2275"><span class="lineNum">    2275 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                const SgBaseClass* base_class_node = isSgBaseClass(node);</span></a>
<a name="2277"><span class="lineNum">    2277 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(base_class_node != NULL);</span></a>
<a name="2278"><span class="lineNum">    2278 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(base_class_node-&gt;get_base_class() != NULL);</span></a>
<a name="2279"><span class="lineNum">    2279 </span>            : </a>
<a name="2280"><span class="lineNum">    2280 </span>            :             // Add the access modifier to the output.</a>
<a name="2281"><span class="lineNum">    2281 </span><span class="lineNoCov">          0 :                string access = &quot;&quot;;</span></a>
<a name="2282"><span class="lineNum">    2282 </span><span class="lineNoCov">          0 :                const SgBaseClassModifier* baseClassModifier = base_class_node-&gt;get_baseClassModifier();</span></a>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(baseClassModifier != NULL);</span></a>
<a name="2284"><span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                access = baseClassModifier-&gt;displayString();</span></a>
<a name="2285"><span class="lineNum">    2285 </span>            : </a>
<a name="2286"><span class="lineNum">    2286 </span><span class="lineNoCov">          0 :                name = &quot;_base_class_&quot; + access + &quot;_&quot; + get_name(base_class_node-&gt;get_base_class());</span></a>
<a name="2287"><span class="lineNum">    2287 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2288"><span class="lineNum">    2288 </span>            :              }</a>
<a name="2289"><span class="lineNum">    2289 </span>            : </a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2292"><span class="lineNum">    2292 </span><span class="lineNoCov">          0 :                printf (&quot;Default reached in switch for SgSupport IR node = %s \n&quot;,node-&gt;class_name().c_str());</span></a>
<a name="2293"><span class="lineNum">    2293 </span><span class="lineNoCov">          0 :                name = &quot;default name&quot;;</span></a>
<a name="2294"><span class="lineNum">    2294 </span>            :             // ROSE_ASSERT(false);</a>
<a name="2295"><span class="lineNum">    2295 </span>            :                break;</a>
<a name="2296"><span class="lineNum">    2296 </span>            :              }</a>
<a name="2297"><span class="lineNum">    2297 </span>            :         }</a>
<a name="2298"><span class="lineNum">    2298 </span>            : </a>
<a name="2299"><span class="lineNum">    2299 </span><span class="lineCov">       4189 :      return name;</span></a>
<a name="2300"><span class="lineNum">    2300 </span>            :    }</a>
<a name="2301"><span class="lineNum">    2301 </span>            : </a>
<a name="2302"><span class="lineNum">    2302 </span>            : </a>
<a name="2303"><span class="lineNum">    2303 </span>            : string</a>
<a name="2304"><span class="lineNum">    2304 </span><span class="lineCov">         42 : SageInterface::get_name ( const SgSymbol* symbol )</span></a>
<a name="2305"><span class="lineNum">    2305 </span>            :    {</a>
<a name="2306"><span class="lineNum">    2306 </span>            :   // This function is useful for debugging</a>
<a name="2307"><span class="lineNum">    2307 </span>            :   // This is the most general case of a function to return a name for an IR node.</a>
<a name="2308"><span class="lineNum">    2308 </span><span class="lineCov">         42 :      ROSE_ASSERT(symbol != NULL);</span></a>
<a name="2309"><span class="lineNum">    2309 </span>            : </a>
<a name="2310"><span class="lineNum">    2310 </span><span class="lineCov">         42 :      string aliasSymbolPrefix = &quot;&quot;;</span></a>
<a name="2311"><span class="lineNum">    2311 </span><span class="lineCov">         42 :      if (isSgAliasSymbol(symbol) != NULL)</span></a>
<a name="2312"><span class="lineNum">    2312 </span>            :         {</a>
<a name="2313"><span class="lineNum">    2313 </span><span class="lineNoCov">          0 :           aliasSymbolPrefix = &quot;_ALIAS&quot;;</span></a>
<a name="2314"><span class="lineNum">    2314 </span>            :         }</a>
<a name="2315"><span class="lineNum">    2315 </span>            : </a>
<a name="2316"><span class="lineNum">    2316 </span>            :   // printf (&quot;In SageInterface::get_name(): symbol-&gt;get_symbol_basis() = %p = %s \n&quot;,symbol-&gt;get_symbol_basis(),symbol-&gt;get_symbol_basis()-&gt;class_name().c_str());</a>
<a name="2317"><span class="lineNum">    2317 </span>            :   // printf (&quot;In SageInterface::get_name(): symbol-&gt;get_declaration() = %p = %s \n&quot;,symbol-&gt;get_declaration(),symbol-&gt;get_declaration()-&gt;class_name().c_str());</a>
<a name="2318"><span class="lineNum">    2318 </span>            : </a>
<a name="2319"><span class="lineNum">    2319 </span>            :   // This is a call to the &quot;get_name()&quot; virtual function</a>
<a name="2320"><span class="lineNum">    2320 </span><span class="lineCov">         42 :      return symbol-&gt;get_name() + aliasSymbolPrefix + &quot;_symbol_&quot;;</span></a>
<a name="2321"><span class="lineNum">    2321 </span>            :    }</a>
<a name="2322"><span class="lineNum">    2322 </span>            : </a>
<a name="2323"><span class="lineNum">    2323 </span>            : string</a>
<a name="2324"><span class="lineNum">    2324 </span><span class="lineCov">      62672 : SageInterface::get_name ( const SgType* type )</span></a>
<a name="2325"><span class="lineNum">    2325 </span>            :    {</a>
<a name="2326"><span class="lineNum">    2326 </span>            :   // This function is useful for debugging</a>
<a name="2327"><span class="lineNum">    2327 </span>            :   // This is the most general case of a function to return a name for an IR node.</a>
<a name="2328"><span class="lineNum">    2328 </span><span class="lineCov">      62672 :      ROSE_ASSERT(type != NULL);</span></a>
<a name="2329"><span class="lineNum">    2329 </span>            : </a>
<a name="2330"><span class="lineNum">    2330 </span><span class="lineCov">      62672 :      string returnName;</span></a>
<a name="2331"><span class="lineNum">    2331 </span>            : </a>
<a name="2332"><span class="lineNum">    2332 </span><span class="lineCov">      62672 :      const SgNamedType* namedType = isSgNamedType(type);</span></a>
<a name="2333"><span class="lineNum">    2333 </span><span class="lineCov">      62672 :      if (namedType != NULL)</span></a>
<a name="2334"><span class="lineNum">    2334 </span>            :         {</a>
<a name="2335"><span class="lineNum">    2335 </span><span class="lineCov">      21590 :           returnName = &quot;named_type_&quot;;</span></a>
<a name="2336"><span class="lineNum">    2336 </span><span class="lineCov">      21590 :           returnName = namedType-&gt;get_name().getString();</span></a>
<a name="2337"><span class="lineNum">    2337 </span>            :         }</a>
<a name="2338"><span class="lineNum">    2338 </span>            :        else</a>
<a name="2339"><span class="lineNum">    2339 </span>            :         {</a>
<a name="2340"><span class="lineNum">    2340 </span><span class="lineCov">      41082 :           switch(type-&gt;variantT())</span></a>
<a name="2341"><span class="lineNum">    2341 </span>            :              {</a>
<a name="2342"><span class="lineNum">    2342 </span><span class="lineCov">       5588 :                case V_SgPointerType:</span></a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineCov">       5588 :                   {</span></a>
<a name="2344"><span class="lineNum">    2344 </span><span class="lineCov">       5588 :                     const SgPointerType* pointerType = isSgPointerType(type);</span></a>
<a name="2345"><span class="lineNum">    2345 </span><span class="lineCov">       5588 :                     returnName = &quot;pointer_to_&quot;;</span></a>
<a name="2346"><span class="lineNum">    2346 </span><span class="lineCov">      11176 :                     returnName += get_name(pointerType-&gt;get_base_type());</span></a>
<a name="2347"><span class="lineNum">    2347 </span><span class="lineCov">       5588 :                     break;</span></a>
<a name="2348"><span class="lineNum">    2348 </span>            :                   }</a>
<a name="2349"><span class="lineNum">    2349 </span>            : </a>
<a name="2350"><span class="lineNum">    2350 </span><span class="lineCov">       1997 :                case V_SgReferenceType:</span></a>
<a name="2351"><span class="lineNum">    2351 </span><span class="lineCov">       1997 :                   {</span></a>
<a name="2352"><span class="lineNum">    2352 </span><span class="lineCov">       1997 :                     const SgReferenceType* referenceType = isSgReferenceType(type);</span></a>
<a name="2353"><span class="lineNum">    2353 </span><span class="lineCov">       1997 :                     returnName = &quot;reference_to_&quot;;</span></a>
<a name="2354"><span class="lineNum">    2354 </span><span class="lineCov">       3994 :                     returnName += get_name(referenceType-&gt;get_base_type());</span></a>
<a name="2355"><span class="lineNum">    2355 </span><span class="lineCov">       1997 :                     break;</span></a>
<a name="2356"><span class="lineNum">    2356 </span>            :                   }</a>
<a name="2357"><span class="lineNum">    2357 </span>            : </a>
<a name="2358"><span class="lineNum">    2358 </span><span class="lineCov">        153 :                case V_SgArrayType:</span></a>
<a name="2359"><span class="lineNum">    2359 </span><span class="lineCov">        153 :                   {</span></a>
<a name="2360"><span class="lineNum">    2360 </span><span class="lineCov">        153 :                     const SgArrayType* arrayType = isSgArrayType(type);</span></a>
<a name="2361"><span class="lineNum">    2361 </span><span class="lineCov">        153 :                     returnName = &quot;array_of_&quot;;</span></a>
<a name="2362"><span class="lineNum">    2362 </span><span class="lineCov">        306 :                     returnName += get_name(arrayType-&gt;get_base_type());</span></a>
<a name="2363"><span class="lineNum">    2363 </span><span class="lineCov">        153 :                     break;</span></a>
<a name="2364"><span class="lineNum">    2364 </span>            :                   }</a>
<a name="2365"><span class="lineNum">    2365 </span>            : </a>
<a name="2366"><span class="lineNum">    2366 </span><span class="lineCov">       4189 :                case V_SgModifierType:</span></a>
<a name="2367"><span class="lineNum">    2367 </span><span class="lineCov">       4189 :                   {</span></a>
<a name="2368"><span class="lineNum">    2368 </span><span class="lineCov">       4189 :                     const SgModifierType* modifierType = isSgModifierType(type);</span></a>
<a name="2369"><span class="lineNum">    2369 </span><span class="lineCov">       4189 :                     returnName = get_name(&amp;(modifierType-&gt;get_typeModifier()));</span></a>
<a name="2370"><span class="lineNum">    2370 </span><span class="lineCov">       8378 :                     returnName += get_name(modifierType-&gt;get_base_type());</span></a>
<a name="2371"><span class="lineNum">    2371 </span><span class="lineCov">       4189 :                     break;</span></a>
<a name="2372"><span class="lineNum">    2372 </span>            :                   }</a>
<a name="2373"><span class="lineNum">    2373 </span>            : </a>
<a name="2374"><span class="lineNum">    2374 </span>            :             // DQ (8/26/2012): Added case to support template declaration work.</a>
<a name="2375"><span class="lineNum">    2375 </span><span class="lineNoCov">          0 :                case V_SgTemplateType:</span></a>
<a name="2376"><span class="lineNum">    2376 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="2377"><span class="lineNum">    2377 </span><span class="lineNoCov">          0 :                     const SgTemplateType* templateType = isSgTemplateType(type);</span></a>
<a name="2378"><span class="lineNum">    2378 </span><span class="lineNoCov">          0 :                     returnName = &quot;templateType_&quot;;</span></a>
<a name="2379"><span class="lineNum">    2379 </span><span class="lineNoCov">          0 :                     returnName += templateType-&gt;get_name();</span></a>
<a name="2380"><span class="lineNum">    2380 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="2381"><span class="lineNum">    2381 </span>            :                   }</a>
<a name="2382"><span class="lineNum">    2382 </span>            : </a>
<a name="2383"><span class="lineNum">    2383 </span><span class="lineCov">      29155 :                default:</span></a>
<a name="2384"><span class="lineNum">    2384 </span><span class="lineCov">      29155 :                   {</span></a>
<a name="2385"><span class="lineNum">    2385 </span><span class="lineCov">      29155 :                     returnName = type-&gt;class_name();</span></a>
<a name="2386"><span class="lineNum">    2386 </span>            :                   }</a>
<a name="2387"><span class="lineNum">    2387 </span>            :              }</a>
<a name="2388"><span class="lineNum">    2388 </span>            :         }</a>
<a name="2389"><span class="lineNum">    2389 </span>            : </a>
<a name="2390"><span class="lineNum">    2390 </span><span class="lineCov">      62672 :      return returnName;</span></a>
<a name="2391"><span class="lineNum">    2391 </span>            :    }</a>
<a name="2392"><span class="lineNum">    2392 </span>            : </a>
<a name="2393"><span class="lineNum">    2393 </span>            : string</a>
<a name="2394"><span class="lineNum">    2394 </span><span class="lineNoCov">          0 : SageInterface::get_name ( const SgExpression* expr )</span></a>
<a name="2395"><span class="lineNum">    2395 </span>            :    {</a>
<a name="2396"><span class="lineNum">    2396 </span><span class="lineNoCov">          0 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="2397"><span class="lineNum">    2397 </span>            : </a>
<a name="2398"><span class="lineNum">    2398 </span>            :   // ROSE_ASSERT(expr != NULL);</a>
<a name="2399"><span class="lineNum">    2399 </span><span class="lineNoCov">          0 :      switch(expr-&gt;variantT())</span></a>
<a name="2400"><span class="lineNum">    2400 </span>            :         {</a>
<a name="2401"><span class="lineNum">    2401 </span><span class="lineNoCov">          0 :           case V_SgVarRefExp:</span></a>
<a name="2402"><span class="lineNum">    2402 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2403"><span class="lineNum">    2403 </span><span class="lineNoCov">          0 :                const SgVarRefExp* varRef = isSgVarRefExp(expr);</span></a>
<a name="2404"><span class="lineNum">    2404 </span><span class="lineNoCov">          0 :                name = &quot;var_ref_of_&quot;;</span></a>
<a name="2405"><span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(varRef != NULL);</span></a>
<a name="2406"><span class="lineNum">    2406 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(varRef-&gt;get_symbol() != NULL);</span></a>
<a name="2407"><span class="lineNum">    2407 </span><span class="lineNoCov">          0 :                name += varRef-&gt;get_symbol()-&gt;get_name();</span></a>
<a name="2408"><span class="lineNum">    2408 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2409"><span class="lineNum">    2409 </span>            :              }</a>
<a name="2410"><span class="lineNum">    2410 </span>            : </a>
<a name="2411"><span class="lineNum">    2411 </span>            :        // DQ (2/2/2011): Added case to support fortran use of label references in alternate return parameters.</a>
<a name="2412"><span class="lineNum">    2412 </span><span class="lineNoCov">          0 :           case V_SgLabelRefExp:</span></a>
<a name="2413"><span class="lineNum">    2413 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2414"><span class="lineNum">    2414 </span><span class="lineNoCov">          0 :                const SgLabelRefExp* labelRef = isSgLabelRefExp(expr);</span></a>
<a name="2415"><span class="lineNum">    2415 </span><span class="lineNoCov">          0 :                name = &quot;label_ref_of_&quot;;</span></a>
<a name="2416"><span class="lineNum">    2416 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(labelRef != NULL);</span></a>
<a name="2417"><span class="lineNum">    2417 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(labelRef-&gt;get_symbol() != NULL);</span></a>
<a name="2418"><span class="lineNum">    2418 </span><span class="lineNoCov">          0 :                name += labelRef-&gt;get_symbol()-&gt;get_name();</span></a>
<a name="2419"><span class="lineNum">    2419 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2420"><span class="lineNum">    2420 </span>            :              }</a>
<a name="2421"><span class="lineNum">    2421 </span>            : </a>
<a name="2422"><span class="lineNum">    2422 </span><span class="lineNoCov">          0 :           case V_SgPntrArrRefExp:</span></a>
<a name="2423"><span class="lineNum">    2423 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2424"><span class="lineNum">    2424 </span><span class="lineNoCov">          0 :                const SgPntrArrRefExp* arrayRef = isSgPntrArrRefExp(expr);</span></a>
<a name="2425"><span class="lineNum">    2425 </span><span class="lineNoCov">          0 :                name = &quot;array_ref_of_&quot;;</span></a>
<a name="2426"><span class="lineNum">    2426 </span><span class="lineNoCov">          0 :                name += get_name(arrayRef-&gt;get_lhs_operand());</span></a>
<a name="2427"><span class="lineNum">    2427 </span><span class="lineNoCov">          0 :                name += &quot;_at_&quot;;</span></a>
<a name="2428"><span class="lineNum">    2428 </span><span class="lineNoCov">          0 :                name += get_name(arrayRef-&gt;get_rhs_operand());</span></a>
<a name="2429"><span class="lineNum">    2429 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2430"><span class="lineNum">    2430 </span>            :              }</a>
<a name="2431"><span class="lineNum">    2431 </span>            : </a>
<a name="2432"><span class="lineNum">    2432 </span><span class="lineNoCov">          0 :           case V_SgFunctionCallExp:</span></a>
<a name="2433"><span class="lineNum">    2433 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2434"><span class="lineNum">    2434 </span><span class="lineNoCov">          0 :                const SgFunctionCallExp* functionCall = isSgFunctionCallExp(expr);</span></a>
<a name="2435"><span class="lineNum">    2435 </span><span class="lineNoCov">          0 :                name = &quot;function_call_&quot;;</span></a>
<a name="2436"><span class="lineNum">    2436 </span><span class="lineNoCov">          0 :                name += get_name(functionCall-&gt;get_function());</span></a>
<a name="2437"><span class="lineNum">    2437 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2438"><span class="lineNum">    2438 </span>            :              }</a>
<a name="2439"><span class="lineNum">    2439 </span>            : </a>
<a name="2440"><span class="lineNum">    2440 </span><span class="lineNoCov">          0 :           case V_SgFunctionRefExp:</span></a>
<a name="2441"><span class="lineNum">    2441 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2442"><span class="lineNum">    2442 </span><span class="lineNoCov">          0 :                const SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(expr);</span></a>
<a name="2443"><span class="lineNum">    2443 </span><span class="lineNoCov">          0 :                name = &quot;function_ref_&quot;;</span></a>
<a name="2444"><span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                name += functionRefExp-&gt;get_symbol()-&gt;get_name();</span></a>
<a name="2445"><span class="lineNum">    2445 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2446"><span class="lineNum">    2446 </span>            :              }</a>
<a name="2447"><span class="lineNum">    2447 </span>            : </a>
<a name="2448"><span class="lineNum">    2448 </span>            :        // DQ (4/19/2013): Added support for SgMemberFunctionRefExp.</a>
<a name="2449"><span class="lineNum">    2449 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionRefExp:</span></a>
<a name="2450"><span class="lineNum">    2450 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2451"><span class="lineNum">    2451 </span><span class="lineNoCov">          0 :                const SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(expr);</span></a>
<a name="2452"><span class="lineNum">    2452 </span><span class="lineNoCov">          0 :                name = &quot;member_function_ref_&quot;;</span></a>
<a name="2453"><span class="lineNum">    2453 </span><span class="lineNoCov">          0 :                name += memberFunctionRefExp-&gt;get_symbol()-&gt;get_name();</span></a>
<a name="2454"><span class="lineNum">    2454 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2455"><span class="lineNum">    2455 </span>            :              }</a>
<a name="2456"><span class="lineNum">    2456 </span>            : </a>
<a name="2457"><span class="lineNum">    2457 </span><span class="lineNoCov">          0 :           case V_SgIntVal:</span></a>
<a name="2458"><span class="lineNum">    2458 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2459"><span class="lineNum">    2459 </span><span class="lineNoCov">          0 :                const SgIntVal* valueExp = isSgIntVal(expr);</span></a>
<a name="2460"><span class="lineNum">    2460 </span><span class="lineNoCov">          0 :                name = &quot;integer_value_exp_&quot;;</span></a>
<a name="2461"><span class="lineNum">    2461 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(valueExp-&gt;get_value());</span></a>
<a name="2462"><span class="lineNum">    2462 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2463"><span class="lineNum">    2463 </span>            :              }</a>
<a name="2464"><span class="lineNum">    2464 </span>            : </a>
<a name="2465"><span class="lineNum">    2465 </span><span class="lineNoCov">          0 :           case V_SgStringVal:</span></a>
<a name="2466"><span class="lineNum">    2466 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2467"><span class="lineNum">    2467 </span><span class="lineNoCov">          0 :                const SgStringVal* valueExp = isSgStringVal(expr);</span></a>
<a name="2468"><span class="lineNum">    2468 </span><span class="lineNoCov">          0 :                name = &quot;string_value_exp_&quot;;</span></a>
<a name="2469"><span class="lineNum">    2469 </span><span class="lineNoCov">          0 :                name += valueExp-&gt;get_value();</span></a>
<a name="2470"><span class="lineNum">    2470 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2471"><span class="lineNum">    2471 </span>            :              }</a>
<a name="2472"><span class="lineNum">    2472 </span>            : </a>
<a name="2473"><span class="lineNum">    2473 </span><span class="lineNoCov">          0 :           case V_SgSubscriptExpression:</span></a>
<a name="2474"><span class="lineNum">    2474 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2475"><span class="lineNum">    2475 </span><span class="lineNoCov">          0 :                const SgSubscriptExpression* subscriptExpression = isSgSubscriptExpression(expr);</span></a>
<a name="2476"><span class="lineNum">    2476 </span><span class="lineNoCov">          0 :                name = &quot;subscript_exp_&quot;;</span></a>
<a name="2477"><span class="lineNum">    2477 </span>            :             // name += StringUtility::numberToString(subscriptExpression-&gt;get_lowerBound());</a>
<a name="2478"><span class="lineNum">    2478 </span><span class="lineNoCov">          0 :                name += get_name(subscriptExpression-&gt;get_lowerBound());</span></a>
<a name="2479"><span class="lineNum">    2479 </span><span class="lineNoCov">          0 :                name += &quot;_&quot;;</span></a>
<a name="2480"><span class="lineNum">    2480 </span>            :             // name += StringUtility::numberToString(subscriptExpression-&gt;get_upperBound());</a>
<a name="2481"><span class="lineNum">    2481 </span><span class="lineNoCov">          0 :                name += get_name(subscriptExpression-&gt;get_upperBound());</span></a>
<a name="2482"><span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                name += &quot;_&quot;;</span></a>
<a name="2483"><span class="lineNum">    2483 </span>            :             // name += StringUtility::numberToString(subscriptExpression-&gt;get_stride());</a>
<a name="2484"><span class="lineNum">    2484 </span><span class="lineNoCov">          0 :                name += get_name(subscriptExpression-&gt;get_stride());</span></a>
<a name="2485"><span class="lineNum">    2485 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2486"><span class="lineNum">    2486 </span>            :              }</a>
<a name="2487"><span class="lineNum">    2487 </span>            : </a>
<a name="2488"><span class="lineNum">    2488 </span><span class="lineNoCov">          0 :           case V_SgNullExpression:</span></a>
<a name="2489"><span class="lineNum">    2489 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2490"><span class="lineNum">    2490 </span><span class="lineNoCov">          0 :                name = &quot;null_expression&quot;;</span></a>
<a name="2491"><span class="lineNum">    2491 </span>            :                break;</a>
<a name="2492"><span class="lineNum">    2492 </span>            :              }</a>
<a name="2493"><span class="lineNum">    2493 </span>            : </a>
<a name="2494"><span class="lineNum">    2494 </span>            :        // DQ (1/17/2011): Added support for SgExprListExp (to support debugging).</a>
<a name="2495"><span class="lineNum">    2495 </span><span class="lineNoCov">          0 :           case V_SgExprListExp:</span></a>
<a name="2496"><span class="lineNum">    2496 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2497"><span class="lineNum">    2497 </span><span class="lineNoCov">          0 :                const SgExprListExp* exprListExp = isSgExprListExp(expr);</span></a>
<a name="2498"><span class="lineNum">    2498 </span><span class="lineNoCov">          0 :                name = &quot;expr_list_exp_&quot;;</span></a>
<a name="2499"><span class="lineNum">    2499 </span><span class="lineNoCov">          0 :                for (size_t i = 0; i &lt; exprListExp-&gt;get_expressions().size(); i++)</span></a>
<a name="2500"><span class="lineNum">    2500 </span>            :                   {</a>
<a name="2501"><span class="lineNum">    2501 </span><span class="lineNoCov">          0 :                     name += get_name(exprListExp-&gt;get_expressions()[i]);</span></a>
<a name="2502"><span class="lineNum">    2502 </span>            :                   }</a>
<a name="2503"><span class="lineNum">    2503 </span>            :                break;</a>
<a name="2504"><span class="lineNum">    2504 </span>            :              }</a>
<a name="2505"><span class="lineNum">    2505 </span>            : </a>
<a name="2506"><span class="lineNum">    2506 </span>            :        // DQ (1/31/2011): Added to support Fortran debugging.</a>
<a name="2507"><span class="lineNum">    2507 </span><span class="lineNoCov">          0 :           case V_SgActualArgumentExpression:</span></a>
<a name="2508"><span class="lineNum">    2508 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2509"><span class="lineNum">    2509 </span><span class="lineNoCov">          0 :                const SgActualArgumentExpression* actualArgExp = isSgActualArgumentExpression(expr);</span></a>
<a name="2510"><span class="lineNum">    2510 </span><span class="lineNoCov">          0 :                name = &quot;actual_arg_exp_name_&quot;;</span></a>
<a name="2511"><span class="lineNum">    2511 </span><span class="lineNoCov">          0 :                name += actualArgExp-&gt;get_argument_name();</span></a>
<a name="2512"><span class="lineNum">    2512 </span><span class="lineNoCov">          0 :                name = &quot;_exp_&quot;;</span></a>
<a name="2513"><span class="lineNum">    2513 </span><span class="lineNoCov">          0 :                name += get_name(actualArgExp-&gt;get_expression());</span></a>
<a name="2514"><span class="lineNum">    2514 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2515"><span class="lineNum">    2515 </span>            :              }</a>
<a name="2516"><span class="lineNum">    2516 </span>            : </a>
<a name="2517"><span class="lineNum">    2517 </span>            :        // DQ (7/25/2012): Added support for new template IR nodes.</a>
<a name="2518"><span class="lineNum">    2518 </span><span class="lineNoCov">          0 :           case V_SgTemplateParameterVal:</span></a>
<a name="2519"><span class="lineNum">    2519 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2520"><span class="lineNum">    2520 </span><span class="lineNoCov">          0 :                const SgTemplateParameterVal* valueExp = isSgTemplateParameterVal(expr);</span></a>
<a name="2521"><span class="lineNum">    2521 </span><span class="lineNoCov">          0 :                name = &quot;template_parameter_value_expression_number_&quot;;</span></a>
<a name="2522"><span class="lineNum">    2522 </span>            :             // name += valueExp-&gt;get_value();</a>
<a name="2523"><span class="lineNum">    2523 </span>            :             // name += get_name(valueExp);</a>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineNoCov">          0 :                name += StringUtility::numberToString(valueExp-&gt;get_template_parameter_position());</span></a>
<a name="2525"><span class="lineNum">    2525 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2526"><span class="lineNum">    2526 </span>            :              }</a>
<a name="2527"><span class="lineNum">    2527 </span>            : </a>
<a name="2528"><span class="lineNum">    2528 </span>            :        // DQ (4/19/2013): Added support for SgDotExp.</a>
<a name="2529"><span class="lineNum">    2529 </span><span class="lineNoCov">          0 :           case V_SgDotExp:</span></a>
<a name="2530"><span class="lineNum">    2530 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2531"><span class="lineNum">    2531 </span><span class="lineNoCov">          0 :                const SgDotExp* dotExp = isSgDotExp(expr);</span></a>
<a name="2532"><span class="lineNum">    2532 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(dotExp != NULL);</span></a>
<a name="2533"><span class="lineNum">    2533 </span>            : </a>
<a name="2534"><span class="lineNum">    2534 </span><span class="lineNoCov">          0 :                name = &quot;_dot_exp_lhs_&quot;;</span></a>
<a name="2535"><span class="lineNum">    2535 </span><span class="lineNoCov">          0 :                name += get_name(dotExp-&gt;get_lhs_operand());</span></a>
<a name="2536"><span class="lineNum">    2536 </span><span class="lineNoCov">          0 :                name += &quot;_dot_exp_rhs_&quot;;</span></a>
<a name="2537"><span class="lineNum">    2537 </span><span class="lineNoCov">          0 :                name += get_name(dotExp-&gt;get_rhs_operand());</span></a>
<a name="2538"><span class="lineNum">    2538 </span>            :             // name += StringUtility::numberToString(valueExp-&gt;get_template_parameter_position());</a>
<a name="2539"><span class="lineNum">    2539 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2540"><span class="lineNum">    2540 </span>            :              }</a>
<a name="2541"><span class="lineNum">    2541 </span>            : </a>
<a name="2542"><span class="lineNum">    2542 </span>            :         // DQ (9/3/2014): Added support for C++11 lambda expressions.</a>
<a name="2543"><span class="lineNum">    2543 </span><span class="lineNoCov">          0 :            case V_SgLambdaExp:</span></a>
<a name="2544"><span class="lineNum">    2544 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2545"><span class="lineNum">    2545 </span><span class="lineNoCov">          0 :                const SgLambdaExp* lambdaExp = isSgLambdaExp(expr);</span></a>
<a name="2546"><span class="lineNum">    2546 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (lambdaExp != NULL);</span></a>
<a name="2547"><span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                name = &quot;lambda_expression_&quot;;</span></a>
<a name="2548"><span class="lineNum">    2548 </span>            :                break;</a>
<a name="2549"><span class="lineNum">    2549 </span>            :              }</a>
<a name="2550"><span class="lineNum">    2550 </span>            : </a>
<a name="2551"><span class="lineNum">    2551 </span>            :        // DQ (1/3/2020): Added support for SgThisExp.</a>
<a name="2552"><span class="lineNum">    2552 </span><span class="lineNoCov">          0 :           case V_SgThisExp:</span></a>
<a name="2553"><span class="lineNum">    2553 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2554"><span class="lineNum">    2554 </span><span class="lineNoCov">          0 :                const SgThisExp* thisExp = isSgThisExp(expr);</span></a>
<a name="2555"><span class="lineNum">    2555 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(thisExp != NULL);</span></a>
<a name="2556"><span class="lineNum">    2556 </span>            : </a>
<a name="2557"><span class="lineNum">    2557 </span><span class="lineNoCov">          0 :                name = &quot;_this_exp_for_&quot;;</span></a>
<a name="2558"><span class="lineNum">    2558 </span>            : </a>
<a name="2559"><span class="lineNum">    2559 </span><span class="lineNoCov">          0 :                SgClassSymbol* classSymbol = thisExp-&gt;get_class_symbol();</span></a>
<a name="2560"><span class="lineNum">    2560 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="2561"><span class="lineNum">    2561 </span>            :             // name += get_name(classSymbol-&gt;get_name());</a>
<a name="2562"><span class="lineNum">    2562 </span>            :             // string class_name = classSymbol-&gt;get_name();</a>
<a name="2563"><span class="lineNum">    2563 </span>            :             // name += class_name;</a>
<a name="2564"><span class="lineNum">    2564 </span><span class="lineNoCov">          0 :                name += classSymbol-&gt;get_name();</span></a>
<a name="2565"><span class="lineNum">    2565 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2566"><span class="lineNum">    2566 </span>            :              }</a>
<a name="2567"><span class="lineNum">    2567 </span>            : </a>
<a name="2568"><span class="lineNum">    2568 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="2569"><span class="lineNum">    2569 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2570"><span class="lineNum">    2570 </span>            :             // Nothing to do for other IR nodes</a>
<a name="2571"><span class="lineNum">    2571 </span>            : #if 0</a>
<a name="2572"><span class="lineNum">    2572 </span>            :             // DQ (7/25/2012): Make this an error.</a>
<a name="2573"><span class="lineNum">    2573 </span>            :                printf (&quot;Note: default reached in get_name() expr = %p = %s \n&quot;,expr,expr-&gt;class_name().c_str());</a>
<a name="2574"><span class="lineNum">    2574 </span>            :                ROSE_ABORT();</a>
<a name="2575"><span class="lineNum">    2575 </span>            : #endif</a>
<a name="2576"><span class="lineNum">    2576 </span>            :             // DQ (4/8/2010): define something specific to this function to make debugging more clear.</a>
<a name="2577"><span class="lineNum">    2577 </span>            :             // printf (&quot;Note: default reached in get_name() expr = %p = %s \n&quot;,expr,expr-&gt;class_name().c_str());</a>
<a name="2578"><span class="lineNum">    2578 </span>            :               // name = &quot;undefined_expression_name&quot;;</a>
<a name="2579"><span class="lineNum">    2579 </span><span class="lineNoCov">          0 :                name = expr-&gt;class_name() + &quot;_undef_name&quot;;</span></a>
<a name="2580"><span class="lineNum">    2580 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2581"><span class="lineNum">    2581 </span>            :              }</a>
<a name="2582"><span class="lineNum">    2582 </span>            :         }</a>
<a name="2583"><span class="lineNum">    2583 </span>            : </a>
<a name="2584"><span class="lineNum">    2584 </span><span class="lineNoCov">          0 :      return name;</span></a>
<a name="2585"><span class="lineNum">    2585 </span>            :    }</a>
<a name="2586"><span class="lineNum">    2586 </span>            : </a>
<a name="2587"><span class="lineNum">    2587 </span>            : string</a>
<a name="2588"><span class="lineNum">    2588 </span><span class="lineCov">         67 : SageInterface::get_name ( const SgLocatedNodeSupport* node )</span></a>
<a name="2589"><span class="lineNum">    2589 </span>            :    {</a>
<a name="2590"><span class="lineNum">    2590 </span>            :   // This function is useful for debugging</a>
<a name="2591"><span class="lineNum">    2591 </span>            :   // This is the most general case of a function to return a name for an IR node.</a>
<a name="2592"><span class="lineNum">    2592 </span><span class="lineCov">         67 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="2593"><span class="lineNum">    2593 </span>            : </a>
<a name="2594"><span class="lineNum">    2594 </span><span class="lineCov">         67 :      string returnName;</span></a>
<a name="2595"><span class="lineNum">    2595 </span>            : </a>
<a name="2596"><span class="lineNum">    2596 </span><span class="lineCov">         67 :      switch(node-&gt;variantT())</span></a>
<a name="2597"><span class="lineNum">    2597 </span>            :         {</a>
<a name="2598"><span class="lineNum">    2598 </span><span class="lineNoCov">          0 :           case V_SgRenamePair:</span></a>
<a name="2599"><span class="lineNum">    2599 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2600"><span class="lineNum">    2600 </span><span class="lineNoCov">          0 :                const SgRenamePair* n = isSgRenamePair(node);</span></a>
<a name="2601"><span class="lineNum">    2601 </span><span class="lineNoCov">          0 :                returnName = &quot;rename_pair_&quot;;</span></a>
<a name="2602"><span class="lineNum">    2602 </span><span class="lineNoCov">          0 :                returnName += n-&gt;get_local_name().str();</span></a>
<a name="2603"><span class="lineNum">    2603 </span><span class="lineNoCov">          0 :                returnName += &quot;_from_&quot;;</span></a>
<a name="2604"><span class="lineNum">    2604 </span><span class="lineNoCov">          0 :                returnName += n-&gt;get_use_name().str();</span></a>
<a name="2605"><span class="lineNum">    2605 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="2606"><span class="lineNum">    2606 </span>            :              }</a>
<a name="2607"><span class="lineNum">    2607 </span>            : </a>
<a name="2608"><span class="lineNum">    2608 </span><span class="lineCov">         67 :           case V_SgInitializedName:</span></a>
<a name="2609"><span class="lineNum">    2609 </span><span class="lineCov">         67 :              {</span></a>
<a name="2610"><span class="lineNum">    2610 </span><span class="lineCov">         67 :                const SgInitializedName* n = isSgInitializedName(node);</span></a>
<a name="2611"><span class="lineNum">    2611 </span><span class="lineCov">         67 :                ROSE_ASSERT (n != NULL);</span></a>
<a name="2612"><span class="lineNum">    2612 </span><span class="lineCov">         67 :                returnName = &quot;initialized_name_&quot;;</span></a>
<a name="2613"><span class="lineNum">    2613 </span><span class="lineCov">         67 :                returnName += n-&gt;get_name().str();</span></a>
<a name="2614"><span class="lineNum">    2614 </span><span class="lineCov">         67 :                break;</span></a>
<a name="2615"><span class="lineNum">    2615 </span>            :              }</a>
<a name="2616"><span class="lineNum">    2616 </span>            : </a>
<a name="2617"><span class="lineNum">    2617 </span>            :         // DQ (9/3/2014): Added support for C++11 lambda expressions.</a>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineNoCov">          0 :            case V_SgLambdaCapture:</span></a>
<a name="2619"><span class="lineNum">    2619 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2620"><span class="lineNum">    2620 </span><span class="lineNoCov">          0 :                const SgLambdaCapture* n = isSgLambdaCapture(node);</span></a>
<a name="2621"><span class="lineNum">    2621 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (n != NULL);</span></a>
<a name="2622"><span class="lineNum">    2622 </span><span class="lineNoCov">          0 :                returnName = &quot;lambda_capture_&quot;;</span></a>
<a name="2623"><span class="lineNum">    2623 </span>            :             // returnName += n-&gt;get_name().str();</a>
<a name="2624"><span class="lineNum">    2624 </span>            :                break;</a>
<a name="2625"><span class="lineNum">    2625 </span>            :              }</a>
<a name="2626"><span class="lineNum">    2626 </span>            : </a>
<a name="2627"><span class="lineNum">    2627 </span>            : #if 0</a>
<a name="2628"><span class="lineNum">    2628 </span>            :           case V_SgInterfaceBody:</a>
<a name="2629"><span class="lineNum">    2629 </span>            :              {</a>
<a name="2630"><span class="lineNum">    2630 </span>            :                const SgInterfaceBody* n = isSgInterfaceBody(node);</a>
<a name="2631"><span class="lineNum">    2631 </span>            :                returnName = &quot;interface_body&quot;;</a>
<a name="2632"><span class="lineNum">    2632 </span>            :                break;</a>
<a name="2633"><span class="lineNum">    2633 </span>            :              }</a>
<a name="2634"><span class="lineNum">    2634 </span>            : #endif</a>
<a name="2635"><span class="lineNum">    2635 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="2636"><span class="lineNum">    2636 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="2637"><span class="lineNum">    2637 </span><span class="lineNoCov">          0 :                returnName = node-&gt;class_name();</span></a>
<a name="2638"><span class="lineNum">    2638 </span>            :              }</a>
<a name="2639"><span class="lineNum">    2639 </span>            :         }</a>
<a name="2640"><span class="lineNum">    2640 </span>            : </a>
<a name="2641"><span class="lineNum">    2641 </span><span class="lineCov">         67 :      return returnName;</span></a>
<a name="2642"><span class="lineNum">    2642 </span>            :    }</a>
<a name="2643"><span class="lineNum">    2643 </span>            : </a>
<a name="2644"><span class="lineNum">    2644 </span>            : string</a>
<a name="2645"><span class="lineNum">    2645 </span><span class="lineCov">        109 : SageInterface::get_name ( const SgNode* node )</span></a>
<a name="2646"><span class="lineNum">    2646 </span>            :    {</a>
<a name="2647"><span class="lineNum">    2647 </span>            :   // This function is useful for debugging</a>
<a name="2648"><span class="lineNum">    2648 </span>            :   // This is the most general case of a function to return a name for an IR node.</a>
<a name="2649"><span class="lineNum">    2649 </span>            :   // Later this function will handle expressions, etc.</a>
<a name="2650"><span class="lineNum">    2650 </span>            : </a>
<a name="2651"><span class="lineNum">    2651 </span><span class="lineCov">        109 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="2652"><span class="lineNum">    2652 </span>            : </a>
<a name="2653"><span class="lineNum">    2653 </span><span class="lineCov">        109 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="2654"><span class="lineNum">    2654 </span>            : </a>
<a name="2655"><span class="lineNum">    2655 </span><span class="lineCov">        109 :      const SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="2656"><span class="lineNum">    2656 </span><span class="lineCov">        109 :      if (locatedNode != NULL)</span></a>
<a name="2657"><span class="lineNum">    2657 </span>            :         {</a>
<a name="2658"><span class="lineNum">    2658 </span><span class="lineCov">         67 :           const SgStatement* statement = isSgStatement(node);</span></a>
<a name="2659"><span class="lineNum">    2659 </span><span class="lineCov">         67 :           if (statement != NULL)</span></a>
<a name="2660"><span class="lineNum">    2660 </span>            :              {</a>
<a name="2661"><span class="lineNum">    2661 </span><span class="lineNoCov">          0 :                name = get_name(statement);</span></a>
<a name="2662"><span class="lineNum">    2662 </span>            :              }</a>
<a name="2663"><span class="lineNum">    2663 </span>            :             else</a>
<a name="2664"><span class="lineNum">    2664 </span>            :              {</a>
<a name="2665"><span class="lineNum">    2665 </span><span class="lineCov">         67 :                const SgExpression* expression = isSgExpression(node);</span></a>
<a name="2666"><span class="lineNum">    2666 </span><span class="lineCov">         67 :                if (expression != NULL)</span></a>
<a name="2667"><span class="lineNum">    2667 </span>            :                   {</a>
<a name="2668"><span class="lineNum">    2668 </span><span class="lineNoCov">          0 :                     name = get_name(expression);</span></a>
<a name="2669"><span class="lineNum">    2669 </span>            :                   }</a>
<a name="2670"><span class="lineNum">    2670 </span>            :                  else</a>
<a name="2671"><span class="lineNum">    2671 </span>            :                   {</a>
<a name="2672"><span class="lineNum">    2672 </span><span class="lineCov">         67 :                     const SgLocatedNodeSupport* locatedNodeSupport = isSgLocatedNodeSupport(node);</span></a>
<a name="2673"><span class="lineNum">    2673 </span><span class="lineCov">         67 :                     if (locatedNodeSupport != NULL)</span></a>
<a name="2674"><span class="lineNum">    2674 </span>            :                        {</a>
<a name="2675"><span class="lineNum">    2675 </span><span class="lineCov">         67 :                          name = get_name(locatedNodeSupport);</span></a>
<a name="2676"><span class="lineNum">    2676 </span>            :                        }</a>
<a name="2677"><span class="lineNum">    2677 </span>            :                       else</a>
<a name="2678"><span class="lineNum">    2678 </span>            :                        {</a>
<a name="2679"><span class="lineNum">    2679 </span><span class="lineNoCov">          0 :                          const SgToken* token = isSgToken(node);</span></a>
<a name="2680"><span class="lineNum">    2680 </span><span class="lineNoCov">          0 :                          if (token != NULL)</span></a>
<a name="2681"><span class="lineNum">    2681 </span>            :                             {</a>
<a name="2682"><span class="lineNum">    2682 </span><span class="lineNoCov">          0 :                               name = get_name(token);</span></a>
<a name="2683"><span class="lineNum">    2683 </span>            :                             }</a>
<a name="2684"><span class="lineNum">    2684 </span>            :                            else</a>
<a name="2685"><span class="lineNum">    2685 </span>            :                             {</a>
<a name="2686"><span class="lineNum">    2686 </span><span class="lineNoCov">          0 :                               printf (&quot;Unknown SgLocatedNode = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="2688"><span class="lineNum">    2688 </span>            :                             }</a>
<a name="2689"><span class="lineNum">    2689 </span>            :                        }</a>
<a name="2690"><span class="lineNum">    2690 </span>            :                   }</a>
<a name="2691"><span class="lineNum">    2691 </span>            :              }</a>
<a name="2692"><span class="lineNum">    2692 </span>            :         }</a>
<a name="2693"><span class="lineNum">    2693 </span>            :        else</a>
<a name="2694"><span class="lineNum">    2694 </span>            :         {</a>
<a name="2695"><span class="lineNum">    2695 </span><span class="lineCov">         42 :           const SgSupport* supportNode = isSgSupport(node);</span></a>
<a name="2696"><span class="lineNum">    2696 </span><span class="lineCov">         42 :           if (supportNode != NULL)</span></a>
<a name="2697"><span class="lineNum">    2697 </span>            :              {</a>
<a name="2698"><span class="lineNum">    2698 </span><span class="lineNoCov">          0 :                name = get_name(supportNode);</span></a>
<a name="2699"><span class="lineNum">    2699 </span>            :              }</a>
<a name="2700"><span class="lineNum">    2700 </span>            :             else</a>
<a name="2701"><span class="lineNum">    2701 </span>            :              {</a>
<a name="2702"><span class="lineNum">    2702 </span>            :             // DQ (9/21/2005): I think this is good enough for the more general case (for now)</a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">         42 :                const SgSymbol* symbol = isSgSymbol(node);</span></a>
<a name="2704"><span class="lineNum">    2704 </span><span class="lineCov">         42 :                if (symbol != NULL)</span></a>
<a name="2705"><span class="lineNum">    2705 </span>            :                   {</a>
<a name="2706"><span class="lineNum">    2706 </span><span class="lineCov">         42 :                     name = get_name(symbol);</span></a>
<a name="2707"><span class="lineNum">    2707 </span>            :                   }</a>
<a name="2708"><span class="lineNum">    2708 </span>            :                  else</a>
<a name="2709"><span class="lineNum">    2709 </span>            :                   {</a>
<a name="2710"><span class="lineNum">    2710 </span>            :                  // DQ (8/7/2007): Added support to get names of types (usefult for SgNamedType objects).</a>
<a name="2711"><span class="lineNum">    2711 </span><span class="lineNoCov">          0 :                     const SgType* type = isSgType(node);</span></a>
<a name="2712"><span class="lineNum">    2712 </span><span class="lineNoCov">          0 :                     if (type != NULL)</span></a>
<a name="2713"><span class="lineNum">    2713 </span>            :                        {</a>
<a name="2714"><span class="lineNum">    2714 </span><span class="lineNoCov">          0 :                          name = get_name(type);</span></a>
<a name="2715"><span class="lineNum">    2715 </span>            :                        }</a>
<a name="2716"><span class="lineNum">    2716 </span>            :                       else</a>
<a name="2717"><span class="lineNum">    2717 </span>            :                        {</a>
<a name="2718"><span class="lineNum">    2718 </span><span class="lineNoCov">          0 :                          name = node-&gt;class_name();</span></a>
<a name="2719"><span class="lineNum">    2719 </span>            :                        }</a>
<a name="2720"><span class="lineNum">    2720 </span>            :                   }</a>
<a name="2721"><span class="lineNum">    2721 </span>            :              }</a>
<a name="2722"><span class="lineNum">    2722 </span>            :         }</a>
<a name="2723"><span class="lineNum">    2723 </span>            : </a>
<a name="2724"><span class="lineNum">    2724 </span><span class="lineCov">        109 :      return name;</span></a>
<a name="2725"><span class="lineNum">    2725 </span>            :    }</a>
<a name="2726"><span class="lineNum">    2726 </span>            : </a>
<a name="2727"><span class="lineNum">    2727 </span>            : </a>
<a name="2728"><span class="lineNum">    2728 </span>            : string</a>
<a name="2729"><span class="lineNum">    2729 </span><span class="lineNoCov">          0 : SageInterface::get_name ( const SgToken* token )</span></a>
<a name="2730"><span class="lineNum">    2730 </span>            :    {</a>
<a name="2731"><span class="lineNum">    2731 </span>            :   // This function is useful for debugging</a>
<a name="2732"><span class="lineNum">    2732 </span><span class="lineNoCov">          0 :      string name = &quot;undefined_name&quot;;</span></a>
<a name="2733"><span class="lineNum">    2733 </span>            : </a>
<a name="2734"><span class="lineNum">    2734 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(token != NULL);</span></a>
<a name="2735"><span class="lineNum">    2735 </span><span class="lineNoCov">          0 :      name = token-&gt;get_lexeme_string();</span></a>
<a name="2736"><span class="lineNum">    2736 </span>            : </a>
<a name="2737"><span class="lineNum">    2737 </span>            :   // Handle special cases</a>
<a name="2738"><span class="lineNum">    2738 </span><span class="lineNoCov">          0 :      if (name == &quot; &quot;)</span></a>
<a name="2739"><span class="lineNum">    2739 </span><span class="lineNoCov">          0 :         name = &quot;&lt;space&gt;&quot;;</span></a>
<a name="2740"><span class="lineNum">    2740 </span><span class="lineNoCov">          0 :      else if (name == &quot;\n&quot;)</span></a>
<a name="2741"><span class="lineNum">    2741 </span><span class="lineNoCov">          0 :         name = &quot;&lt;eol&gt;&quot;;</span></a>
<a name="2742"><span class="lineNum">    2742 </span><span class="lineNoCov">          0 :      else if (name == &quot;\t&quot;)</span></a>
<a name="2743"><span class="lineNum">    2743 </span><span class="lineNoCov">          0 :         name = &quot;&lt;tab&gt;&quot;;</span></a>
<a name="2744"><span class="lineNum">    2744 </span>            : </a>
<a name="2745"><span class="lineNum">    2745 </span><span class="lineNoCov">          0 :      return name;</span></a>
<a name="2746"><span class="lineNum">    2746 </span>            :    }</a>
<a name="2747"><span class="lineNum">    2747 </span>            : </a>
<a name="2748"><span class="lineNum">    2748 </span>            : </a>
<a name="2749"><span class="lineNum">    2749 </span>            : void</a>
<a name="2750"><span class="lineNum">    2750 </span><span class="lineCov">          1 : SageInterface::reset_name_collision_map()</span></a>
<a name="2751"><span class="lineNum">    2751 </span>            :    {</a>
<a name="2752"><span class="lineNum">    2752 </span><span class="lineCov">          1 :      local_name_collision_map.clear();</span></a>
<a name="2753"><span class="lineNum">    2753 </span><span class="lineCov">          1 :      local_name_to_node_map.clear();</span></a>
<a name="2754"><span class="lineNum">    2754 </span><span class="lineCov">          1 :      local_node_to_name_map.clear();</span></a>
<a name="2755"><span class="lineNum">    2755 </span><span class="lineCov">          1 :    }</span></a>
<a name="2756"><span class="lineNum">    2756 </span>            : </a>
<a name="2757"><span class="lineNum">    2757 </span>            : </a>
<a name="2758"><span class="lineNum">    2758 </span>            : string</a>
<a name="2759"><span class="lineNum">    2759 </span><span class="lineCov">      61060 : SageInterface::generateUniqueNameForUseAsIdentifier_support ( SgDeclarationStatement* declaration )</span></a>
<a name="2760"><span class="lineNum">    2760 </span>            :    {</a>
<a name="2761"><span class="lineNum">    2761 </span>            :   // DQ (3/20/2016): Adding support for generating a unique name from a declaration that</a>
<a name="2762"><span class="lineNum">    2762 </span>            :   // can be used as an identifier.  This functionality is used in the DSL infrastructure</a>
<a name="2763"><span class="lineNum">    2763 </span>            :   // support (refactored to this location in ROSE).  The point of this mechanism is that</a>
<a name="2764"><span class="lineNum">    2764 </span>            :   // unlike mangled names that are compressed in a way that allows them to only be used</a>
<a name="2765"><span class="lineNum">    2765 </span>            :   // within a single translation unit, names generated by this function can be used across</a>
<a name="2766"><span class="lineNum">    2766 </span>            :   // multiple translation units. These names are also easier to interprete in debugging</a>
<a name="2767"><span class="lineNum">    2767 </span>            :   // (since they explicitly contain the scope, function name, and coding to interprete</a>
<a name="2768"><span class="lineNum">    2768 </span>            :   // function overloading.</a>
<a name="2769"><span class="lineNum">    2769 </span>            : </a>
<a name="2770"><span class="lineNum">    2770 </span>            :   // At present it only supports class declarations, and function declarations (all others</a>
<a name="2771"><span class="lineNum">    2771 </span>            :   // are trapped as errors).</a>
<a name="2772"><span class="lineNum">    2772 </span>            : </a>
<a name="2773"><span class="lineNum">    2773 </span>            :   // Name collision testing, it might be that this should be external to this function.</a>
<a name="2774"><span class="lineNum">    2774 </span>            :   // static std::map&lt;std::string,int&gt; dsl_attribute_name_collision_map;</a>
<a name="2775"><span class="lineNum">    2775 </span>            :   // static std::map&lt;std::string,int&gt; local_name_collision_map;</a>
<a name="2776"><span class="lineNum">    2776 </span>            : </a>
<a name="2777"><span class="lineNum">    2777 </span><span class="lineCov">      61060 :      string s;</span></a>
<a name="2778"><span class="lineNum">    2778 </span>            : </a>
<a name="2779"><span class="lineNum">    2779 </span>            :   // string scope = SageInterface::get_name(classDeclaration-&gt;get_scope());</a>
<a name="2780"><span class="lineNum">    2780 </span><span class="lineCov">      61060 :      string scope = isSgGlobal(declaration-&gt;get_scope()) == NULL ? SageInterface::get_name(declaration-&gt;get_scope()) : &quot;global&quot;;</span></a>
<a name="2781"><span class="lineNum">    2781 </span>            : </a>
<a name="2782"><span class="lineNum">    2782 </span><span class="lineCov">      61060 :      switch (declaration-&gt;variantT())</span></a>
<a name="2783"><span class="lineNum">    2783 </span>            :         {</a>
<a name="2784"><span class="lineNum">    2784 </span><span class="lineCov">       2362 :           case V_SgClassDeclaration:</span></a>
<a name="2785"><span class="lineNum">    2785 </span><span class="lineCov">       2362 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="2786"><span class="lineNum">    2786 </span>            :        // case V_SgTemplateInstantiationDecl:</a>
<a name="2787"><span class="lineNum">    2787 </span><span class="lineCov">       2362 :              {</span></a>
<a name="2788"><span class="lineNum">    2788 </span><span class="lineCov">       2362 :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);</span></a>
<a name="2789"><span class="lineNum">    2789 </span><span class="lineCov">       2362 :                ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="2790"><span class="lineNum">    2790 </span>            : </a>
<a name="2791"><span class="lineNum">    2791 </span><span class="lineCov">       4724 :                string type_name = classDeclaration-&gt;get_name();</span></a>
<a name="2792"><span class="lineNum">    2792 </span>            : #if 0</a>
<a name="2793"><span class="lineNum">    2793 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier_support(): case class or template type: type_name = %s \n&quot;,type_name.c_str());</a>
<a name="2794"><span class="lineNum">    2794 </span>            : #endif</a>
<a name="2795"><span class="lineNum">    2795 </span><span class="lineCov">       7086 :                string className = string(&quot;scope_&quot;) + scope + &quot;_type_name_&quot; + type_name;</span></a>
<a name="2796"><span class="lineNum">    2796 </span>            : #if 0</a>
<a name="2797"><span class="lineNum">    2797 </span>            :                printf (&quot;classDeclaration-&gt;get_scope() = %p = %s scope = %s \n&quot;,classDeclaration-&gt;get_scope(),classDeclaration-&gt;get_scope()-&gt;class_name().c_str(),scope.c_str());</a>
<a name="2798"><span class="lineNum">    2798 </span>            : #endif</a>
<a name="2799"><span class="lineNum">    2799 </span><span class="lineCov">       2362 :                s = className;</span></a>
<a name="2800"><span class="lineNum">    2800 </span><span class="lineCov">       2362 :                break;</span></a>
<a name="2801"><span class="lineNum">    2801 </span>            :              }</a>
<a name="2802"><span class="lineNum">    2802 </span>            : </a>
<a name="2803"><span class="lineNum">    2803 </span>            :        // DQ (3/29/2016): Seperate out the case of the SgTemplateInstantiationDecl.</a>
<a name="2804"><span class="lineNum">    2804 </span><span class="lineCov">       2327 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="2805"><span class="lineNum">    2805 </span><span class="lineCov">       2327 :              {</span></a>
<a name="2806"><span class="lineNum">    2806 </span><span class="lineCov">       2327 :                SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(declaration);</span></a>
<a name="2807"><span class="lineNum">    2807 </span><span class="lineCov">       2327 :                ROSE_ASSERT(templateInstantiationDeclaration != NULL);</span></a>
<a name="2808"><span class="lineNum">    2808 </span>            : </a>
<a name="2809"><span class="lineNum">    2809 </span>            :             // Note that we can't use the mangled name because they might not be unique across multiple translation units if seperately compiled).</a>
<a name="2810"><span class="lineNum">    2810 </span>            :             // string type_name = templateInstantiationDeclaration-&gt;get_name();</a>
<a name="2811"><span class="lineNum">    2811 </span>            :             // string type_name = templateInstantiationDeclaration-&gt;get_mangled_name();</a>
<a name="2812"><span class="lineNum">    2812 </span>            :             // string type_name = templateInstantiationDeclaration-&gt;get_templateName();</a>
<a name="2813"><span class="lineNum">    2813 </span><span class="lineCov">       4654 :                string type_name = templateInstantiationDeclaration-&gt;get_name();</span></a>
<a name="2814"><span class="lineNum">    2814 </span>            : #if 0</a>
<a name="2815"><span class="lineNum">    2815 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier_support(): case SgTemplateInstantiationDecl: type_name = %s \n&quot;,type_name.c_str());</a>
<a name="2816"><span class="lineNum">    2816 </span>            : #endif</a>
<a name="2817"><span class="lineNum">    2817 </span><span class="lineCov">       6981 :                string className = string(&quot;scope_&quot;) + scope + &quot;_type_name_&quot; + type_name;</span></a>
<a name="2818"><span class="lineNum">    2818 </span>            : </a>
<a name="2819"><span class="lineNum">    2819 </span>            :             // Note that trimSpaces is defined in the name mangling support.</a>
<a name="2820"><span class="lineNum">    2820 </span>            :             // string compressedClassName = trimSpaces(className);</a>
<a name="2821"><span class="lineNum">    2821 </span>            :             // string compressedClassName = SageInterface::get_name(templateInstantiationDeclaration);</a>
<a name="2822"><span class="lineNum">    2822 </span>            :             // ROSE_UTIL_API std::string copyEdit(const std::string&amp; inputString, const std::string &amp; oldToken, const std::string &amp; newToken);</a>
<a name="2823"><span class="lineNum">    2823 </span>            : </a>
<a name="2824"><span class="lineNum">    2824 </span>            :             // We need to turn this template instatiation name into a name that can be used as a C++ identifier.</a>
<a name="2825"><span class="lineNum">    2825 </span><span class="lineCov">       6981 :                string compressedClassName = StringUtility::copyEdit(className,&quot; &quot;,&quot;&quot;);</span></a>
<a name="2826"><span class="lineNum">    2826 </span><span class="lineCov">       4654 :                compressedClassName = StringUtility::copyEdit(compressedClassName,&quot;&lt;&quot;,&quot;_abs_&quot;);</span></a>
<a name="2827"><span class="lineNum">    2827 </span><span class="lineCov">       4654 :                compressedClassName = StringUtility::copyEdit(compressedClassName,&quot;&gt;&quot;,&quot;_abe_&quot;);</span></a>
<a name="2828"><span class="lineNum">    2828 </span><span class="lineCov">       4654 :                compressedClassName = StringUtility::copyEdit(compressedClassName,&quot;,&quot;,&quot;_comma_&quot;);</span></a>
<a name="2829"><span class="lineNum">    2829 </span><span class="lineCov">       4654 :                compressedClassName = StringUtility::copyEdit(compressedClassName,&quot;*&quot;,&quot;_star_&quot;);</span></a>
<a name="2830"><span class="lineNum">    2830 </span><span class="lineCov">       4654 :                compressedClassName = StringUtility::copyEdit(compressedClassName,&quot;&amp;&quot;,&quot;_ref_&quot;);</span></a>
<a name="2831"><span class="lineNum">    2831 </span>            : #if 0</a>
<a name="2832"><span class="lineNum">    2832 </span>            :                printf (&quot;className = %s compressedClassName = %s \n&quot;,className.c_str(),compressedClassName.c_str());</a>
<a name="2833"><span class="lineNum">    2833 </span>            : #endif</a>
<a name="2834"><span class="lineNum">    2834 </span>            : #if 0</a>
<a name="2835"><span class="lineNum">    2835 </span>            :                printf (&quot;templateInstantiationDeclaration-&gt;get_scope() = %p = %s scope = %s \n&quot;,</a>
<a name="2836"><span class="lineNum">    2836 </span>            :                     templateInstantiationDeclaration-&gt;get_scope(),templateInstantiationDeclaration-&gt;get_scope()-&gt;class_name().c_str(),scope.c_str());</a>
<a name="2837"><span class="lineNum">    2837 </span>            : #endif</a>
<a name="2838"><span class="lineNum">    2838 </span>            :             // s = className;</a>
<a name="2839"><span class="lineNum">    2839 </span><span class="lineCov">       2327 :                s = compressedClassName;</span></a>
<a name="2840"><span class="lineNum">    2840 </span>            : #if 0</a>
<a name="2841"><span class="lineNum">    2841 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2842"><span class="lineNum">    2842 </span>            :                ROSE_ABORT();</a>
<a name="2843"><span class="lineNum">    2843 </span>            : #endif</a>
<a name="2844"><span class="lineNum">    2844 </span><span class="lineCov">       2327 :                break;</span></a>
<a name="2845"><span class="lineNum">    2845 </span>            :              }</a>
<a name="2846"><span class="lineNum">    2846 </span>            : </a>
<a name="2847"><span class="lineNum">    2847 </span><span class="lineCov">      11272 :           case V_SgFunctionDeclaration:</span></a>
<a name="2848"><span class="lineNum">    2848 </span><span class="lineCov">      11272 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="2849"><span class="lineNum">    2849 </span><span class="lineCov">      11272 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="2850"><span class="lineNum">    2850 </span><span class="lineCov">      11272 :              {</span></a>
<a name="2851"><span class="lineNum">    2851 </span><span class="lineCov">      11272 :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration);</span></a>
<a name="2852"><span class="lineNum">    2852 </span><span class="lineCov">      11272 :                ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="2853"><span class="lineNum">    2853 </span>            : #if 0</a>
<a name="2854"><span class="lineNum">    2854 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier_support(): case SgFunctionDeclaration: not implemented \n&quot;);</a>
<a name="2855"><span class="lineNum">    2855 </span>            : #endif</a>
<a name="2856"><span class="lineNum">    2856 </span>            :             // We might at some point want the qualified name.</a>
<a name="2857"><span class="lineNum">    2857 </span><span class="lineCov">      22544 :                string original_name = functionDeclaration-&gt;get_name();</span></a>
<a name="2858"><span class="lineNum">    2858 </span>            : </a>
<a name="2859"><span class="lineNum">    2859 </span><span class="lineCov">      33816 :                string function_name_part = mangleFunctionName(original_name,&quot;return_type&quot;);</span></a>
<a name="2860"><span class="lineNum">    2860 </span><span class="lineCov">      33816 :                string function_name  = string(&quot;scope_&quot;) + scope + &quot;_function_name_&quot; + function_name_part;</span></a>
<a name="2861"><span class="lineNum">    2861 </span>            : </a>
<a name="2862"><span class="lineNum">    2862 </span>            :             // DQ (3/16/2016): Detect name collisions so that we can</a>
<a name="2863"><span class="lineNum">    2863 </span>            :             // std::map&lt;std::string,int&gt; dsl_attribute_name_collision_map;</a>
<a name="2864"><span class="lineNum">    2864 </span><span class="lineCov">      11272 :                if (local_name_collision_map.find(function_name) == local_name_collision_map.end())</span></a>
<a name="2865"><span class="lineNum">    2865 </span>            :                   {</a>
<a name="2866"><span class="lineNum">    2866 </span><span class="lineCov">       3505 :                     local_name_collision_map.insert(pair&lt;string,int&gt;(function_name,0));</span></a>
<a name="2867"><span class="lineNum">    2867 </span>            :                   }</a>
<a name="2868"><span class="lineNum">    2868 </span>            :                  else</a>
<a name="2869"><span class="lineNum">    2869 </span>            :                   {</a>
<a name="2870"><span class="lineNum">    2870 </span><span class="lineCov">       7767 :                     local_name_collision_map[function_name]++;</span></a>
<a name="2871"><span class="lineNum">    2871 </span>            : </a>
<a name="2872"><span class="lineNum">    2872 </span><span class="lineCov">       7767 :                     int count = local_name_collision_map[function_name];</span></a>
<a name="2873"><span class="lineNum">    2873 </span>            : #if 0</a>
<a name="2874"><span class="lineNum">    2874 </span>            :                     printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): Collision count = %d \n&quot;,count);</a>
<a name="2875"><span class="lineNum">    2875 </span>            : #endif</a>
<a name="2876"><span class="lineNum">    2876 </span><span class="lineCov">      15534 :                     function_name += StringUtility::numberToString(count);</span></a>
<a name="2877"><span class="lineNum">    2877 </span>            :                   }</a>
<a name="2878"><span class="lineNum">    2878 </span>            : </a>
<a name="2879"><span class="lineNum">    2879 </span><span class="lineCov">      11272 :                s = function_name;</span></a>
<a name="2880"><span class="lineNum">    2880 </span>            : #if 0</a>
<a name="2881"><span class="lineNum">    2881 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): case SgFunctionDeclaration: Exiting as a test! \n&quot;);</a>
<a name="2882"><span class="lineNum">    2882 </span>            :                ROSE_ABORT();</a>
<a name="2883"><span class="lineNum">    2883 </span>            : #endif</a>
<a name="2884"><span class="lineNum">    2884 </span><span class="lineCov">      11272 :                break;</span></a>
<a name="2885"><span class="lineNum">    2885 </span>            :              }</a>
<a name="2886"><span class="lineNum">    2886 </span>            : </a>
<a name="2887"><span class="lineNum">    2887 </span><span class="lineCov">      10250 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="2888"><span class="lineNum">    2888 </span><span class="lineCov">      10250 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="2889"><span class="lineNum">    2889 </span><span class="lineCov">      10250 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="2890"><span class="lineNum">    2890 </span><span class="lineCov">      10250 :              {</span></a>
<a name="2891"><span class="lineNum">    2891 </span><span class="lineCov">      10250 :                SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(declaration);</span></a>
<a name="2892"><span class="lineNum">    2892 </span><span class="lineCov">      10250 :                ROSE_ASSERT(memberFunctionDeclaration != NULL);</span></a>
<a name="2893"><span class="lineNum">    2893 </span>            : #if 0</a>
<a name="2894"><span class="lineNum">    2894 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier_support(): case SgMemberFunctionDeclaration: not implemented \n&quot;);</a>
<a name="2895"><span class="lineNum">    2895 </span>            : #endif</a>
<a name="2896"><span class="lineNum">    2896 </span>            :             // We might at some point want the qualified name.</a>
<a name="2897"><span class="lineNum">    2897 </span><span class="lineCov">      20500 :                string original_name = memberFunctionDeclaration-&gt;get_name();</span></a>
<a name="2898"><span class="lineNum">    2898 </span>            : </a>
<a name="2899"><span class="lineNum">    2899 </span>            :             // string member_function_name = memberFunctionDeclaration-&gt;get_mangled_name();</a>
<a name="2900"><span class="lineNum">    2900 </span>            :             // string member_function_name = memberFunctionDeclaration-&gt;get_qualified_name();</a>
<a name="2901"><span class="lineNum">    2901 </span>            :             // string member_function_name = SageInterface::get_name(memberFunctionDeclaration);</a>
<a name="2902"><span class="lineNum">    2902 </span>            :             // string member_function_scope = SageInterface::get_name(memberFunctionDeclaration-&gt;get_scope());</a>
<a name="2903"><span class="lineNum">    2903 </span><span class="lineCov">      30750 :                string member_function_name_part = mangleFunctionName(original_name,&quot;return_type&quot;);</span></a>
<a name="2904"><span class="lineNum">    2904 </span>            :             // string member_function_name  = string(&quot;scope_&quot;) + member_function_scope + &quot;_function_name_&quot; + member_function_name_part;</a>
<a name="2905"><span class="lineNum">    2905 </span><span class="lineCov">      30750 :                string member_function_name  = string(&quot;scope_&quot;) + scope + &quot;_member_function_name_&quot; + member_function_name_part;</span></a>
<a name="2906"><span class="lineNum">    2906 </span>            : </a>
<a name="2907"><span class="lineNum">    2907 </span>            :             // DQ (3/16/2016): Detect name collisions so that we can</a>
<a name="2908"><span class="lineNum">    2908 </span>            :             // std::map&lt;std::string,int&gt; dsl_attribute_name_collision_map;</a>
<a name="2909"><span class="lineNum">    2909 </span><span class="lineCov">      10250 :                if (local_name_collision_map.find(member_function_name) == local_name_collision_map.end())</span></a>
<a name="2910"><span class="lineNum">    2910 </span>            :                   {</a>
<a name="2911"><span class="lineNum">    2911 </span><span class="lineCov">       1063 :                     local_name_collision_map.insert(pair&lt;string,int&gt;(member_function_name,0));</span></a>
<a name="2912"><span class="lineNum">    2912 </span>            :                   }</a>
<a name="2913"><span class="lineNum">    2913 </span>            :                  else</a>
<a name="2914"><span class="lineNum">    2914 </span>            :                   {</a>
<a name="2915"><span class="lineNum">    2915 </span><span class="lineCov">       9187 :                     local_name_collision_map[member_function_name]++;</span></a>
<a name="2916"><span class="lineNum">    2916 </span>            : </a>
<a name="2917"><span class="lineNum">    2917 </span><span class="lineCov">       9187 :                     int count = local_name_collision_map[member_function_name];</span></a>
<a name="2918"><span class="lineNum">    2918 </span>            : #if 0</a>
<a name="2919"><span class="lineNum">    2919 </span>            :                     printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): Collision count = %d \n&quot;,count);</a>
<a name="2920"><span class="lineNum">    2920 </span>            : #endif</a>
<a name="2921"><span class="lineNum">    2921 </span><span class="lineCov">      18374 :                     member_function_name += StringUtility::numberToString(count);</span></a>
<a name="2922"><span class="lineNum">    2922 </span>            :                   }</a>
<a name="2923"><span class="lineNum">    2923 </span>            : </a>
<a name="2924"><span class="lineNum">    2924 </span><span class="lineCov">      10250 :                s = member_function_name;</span></a>
<a name="2925"><span class="lineNum">    2925 </span>            : #if 0</a>
<a name="2926"><span class="lineNum">    2926 </span>            :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): case SgMemberFunctionDeclaration: Exiting as a test! \n&quot;);</a>
<a name="2927"><span class="lineNum">    2927 </span>            :                ROSE_ABORT();</a>
<a name="2928"><span class="lineNum">    2928 </span>            : #endif</a>
<a name="2929"><span class="lineNum">    2929 </span><span class="lineCov">      10250 :                break;</span></a>
<a name="2930"><span class="lineNum">    2930 </span>            :              }</a>
<a name="2931"><span class="lineNum">    2931 </span>            : </a>
<a name="2932"><span class="lineNum">    2932 </span><span class="lineCov">      34849 :           default:</span></a>
<a name="2933"><span class="lineNum">    2933 </span><span class="lineCov">      34849 :              {</span></a>
<a name="2934"><span class="lineNum">    2934 </span><span class="lineCov">      64124 :                printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): Unsupported declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="2935"><span class="lineNum">    2935 </span>            : //               ROSE_ASSERT(false);</a>
<a name="2936"><span class="lineNum">    2936 </span>            :              }</a>
<a name="2937"><span class="lineNum">    2937 </span>            :         }</a>
<a name="2938"><span class="lineNum">    2938 </span>            : </a>
<a name="2939"><span class="lineNum">    2939 </span>            : #if 0</a>
<a name="2940"><span class="lineNum">    2940 </span>            :      printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): s = %s \n&quot;,s.c_str());</a>
<a name="2941"><span class="lineNum">    2941 </span>            : #endif</a>
<a name="2942"><span class="lineNum">    2942 </span>            : #if 0</a>
<a name="2943"><span class="lineNum">    2943 </span>            :      if (s != &quot;&quot;)</a>
<a name="2944"><span class="lineNum">    2944 </span>            :         {</a>
<a name="2945"><span class="lineNum">    2945 </span>            :           printf (&quot;In SageInterface::generateUniqueNameForUseAsIdentifier(): s = %s \n&quot;,s.c_str());</a>
<a name="2946"><span class="lineNum">    2946 </span>            :         }</a>
<a name="2947"><span class="lineNum">    2947 </span>            : #endif</a>
<a name="2948"><span class="lineNum">    2948 </span>            : </a>
<a name="2949"><span class="lineNum">    2949 </span>            : #if 0</a>
<a name="2950"><span class="lineNum">    2950 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="2951"><span class="lineNum">    2951 </span>            :      ROSE_ABORT();</a>
<a name="2952"><span class="lineNum">    2952 </span>            : #endif</a>
<a name="2953"><span class="lineNum">    2953 </span>            : </a>
<a name="2954"><span class="lineNum">    2954 </span><span class="lineCov">      66117 :      return s;</span></a>
<a name="2955"><span class="lineNum">    2955 </span>            :    }</a>
<a name="2956"><span class="lineNum">    2956 </span>            : </a>
<a name="2957"><span class="lineNum">    2957 </span>            : // Generate unique name for use as a class name for the generated attribute classes.</a>
<a name="2958"><span class="lineNum">    2958 </span>            : // std::string AttributeGeneratorTraversal::generateUniqueNameForUseAsIdentifier ( SgDeclarationStatement* declaration )</a>
<a name="2959"><span class="lineNum">    2959 </span>            : // std::string AttributeGeneratorTraversal::generateUniqueName ( SgDeclarationStatement* declaration )</a>
<a name="2960"><span class="lineNum">    2960 </span>            : std::string</a>
<a name="2961"><span class="lineNum">    2961 </span><span class="lineCov">      10761 : SageInterface::generateUniqueNameForUseAsIdentifier ( SgDeclarationStatement* declaration )</span></a>
<a name="2962"><span class="lineNum">    2962 </span>            :    {</a>
<a name="2963"><span class="lineNum">    2963 </span>            :   // DQ (3/21/2016): The support for unique name generation for use across translation</a>
<a name="2964"><span class="lineNum">    2964 </span>            :   // units is not refactored into the SageInterface.</a>
<a name="2965"><span class="lineNum">    2965 </span>            :   // string s = SageInterface::generateUniqueNameForUseAsIdentifier(declaration);</a>
<a name="2966"><span class="lineNum">    2966 </span><span class="lineCov">      10761 :      string s;</span></a>
<a name="2967"><span class="lineNum">    2967 </span>            : </a>
<a name="2968"><span class="lineNum">    2968 </span>            : #if 0</a>
<a name="2969"><span class="lineNum">    2969 </span>            :      printf (&quot;In generateUniqueNameForUseAsIdentifier(): evaluating declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="2970"><span class="lineNum">    2970 </span>            : #endif</a>
<a name="2971"><span class="lineNum">    2971 </span>            : </a>
<a name="2972"><span class="lineNum">    2972 </span><span class="lineCov">      10761 :      ROSE_ASSERT(local_node_to_name_map.empty() == false);</span></a>
<a name="2973"><span class="lineNum">    2973 </span><span class="lineCov">      10761 :      ROSE_ASSERT(local_name_to_node_map.empty() == false);</span></a>
<a name="2974"><span class="lineNum">    2974 </span>            : </a>
<a name="2975"><span class="lineNum">    2975 </span><span class="lineCov">      21522 :      if (SageInterface::local_node_to_name_map.find(declaration) != SageInterface::local_node_to_name_map.end())</span></a>
<a name="2976"><span class="lineNum">    2976 </span>            :         {</a>
<a name="2977"><span class="lineNum">    2977 </span><span class="lineCov">       9507 :           s = SageInterface::local_node_to_name_map[declaration];</span></a>
<a name="2978"><span class="lineNum">    2978 </span>            :         }</a>
<a name="2979"><span class="lineNum">    2979 </span>            :        else</a>
<a name="2980"><span class="lineNum">    2980 </span>            :         {</a>
<a name="2981"><span class="lineNum">    2981 </span><span class="lineCov">       1254 :           SgDeclarationStatement* definingDeclaration = declaration-&gt;get_definingDeclaration();</span></a>
<a name="2982"><span class="lineNum">    2982 </span><span class="lineCov">       1254 :           if (definingDeclaration != NULL)</span></a>
<a name="2983"><span class="lineNum">    2983 </span>            :              {</a>
<a name="2984"><span class="lineNum">    2984 </span>            : #if 0</a>
<a name="2985"><span class="lineNum">    2985 </span>            :                printf (&quot;In generateUniqueName(): Using the defining declaration = %p since %p was not in the map \n&quot;,definingDeclaration,declaration);</a>
<a name="2986"><span class="lineNum">    2986 </span>            : #endif</a>
<a name="2987"><span class="lineNum">    2987 </span>            :             // s = generateUniqueName(definingDeclaration);</a>
<a name="2988"><span class="lineNum">    2988 </span><span class="lineCov">       1178 :                s = generateUniqueNameForUseAsIdentifier_support(definingDeclaration);</span></a>
<a name="2989"><span class="lineNum">    2989 </span>            :              }</a>
<a name="2990"><span class="lineNum">    2990 </span>            :             else</a>
<a name="2991"><span class="lineNum">    2991 </span>            :              {</a>
<a name="2992"><span class="lineNum">    2992 </span>            :             // Note that builtin functions will not have a defining declaration.</a>
<a name="2993"><span class="lineNum">    2993 </span><span class="lineCov">         76 :                printf (&quot;Warning: defining declaration not in SageInterface::local_node_to_name_map: declaration = %p = %s using name = %s \n&quot;,</span></a>
<a name="2994"><span class="lineNum">    2994 </span><span class="lineCov">        152 :                     declaration,declaration-&gt;class_name().c_str(),SageInterface::get_name(declaration).c_str());</span></a>
<a name="2995"><span class="lineNum">    2995 </span>            :             // ROSE_ASSERT(false);</a>
<a name="2996"><span class="lineNum">    2996 </span>            : </a>
<a name="2997"><span class="lineNum">    2997 </span>            :             // If there is no defining declaration then go ahead and use the non-defining one.</a>
<a name="2998"><span class="lineNum">    2998 </span>            :             // s = SageInterface::get_name(declaration);</a>
<a name="2999"><span class="lineNum">    2999 </span><span class="lineCov">         76 :                SgDeclarationStatement* nondefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="3000"><span class="lineNum">    3000 </span><span class="lineCov">         76 :                ROSE_ASSERT(nondefiningDeclaration != NULL);</span></a>
<a name="3001"><span class="lineNum">    3001 </span><span class="lineCov">         76 :                s = generateUniqueNameForUseAsIdentifier_support(nondefiningDeclaration);</span></a>
<a name="3002"><span class="lineNum">    3002 </span>            :              }</a>
<a name="3003"><span class="lineNum">    3003 </span>            :         }</a>
<a name="3004"><span class="lineNum">    3004 </span>            : </a>
<a name="3005"><span class="lineNum">    3005 </span>            : #if 0</a>
<a name="3006"><span class="lineNum">    3006 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3007"><span class="lineNum">    3007 </span>            :      ROSE_ABORT();</a>
<a name="3008"><span class="lineNum">    3008 </span>            : #endif</a>
<a name="3009"><span class="lineNum">    3009 </span>            : </a>
<a name="3010"><span class="lineNum">    3010 </span><span class="lineCov">      10761 :      return s;</span></a>
<a name="3011"><span class="lineNum">    3011 </span>            :    }</a>
<a name="3012"><span class="lineNum">    3012 </span>            : </a>
<a name="3013"><span class="lineNum">    3013 </span>            : </a>
<a name="3014"><span class="lineNum">    3014 </span>            : void</a>
<a name="3015"><span class="lineNum">    3015 </span><span class="lineCov">          1 : SageInterface::computeUniqueNameForUseAsIdentifier( SgNode* astNode )</span></a>
<a name="3016"><span class="lineNum">    3016 </span>            :    {</a>
<a name="3017"><span class="lineNum">    3017 </span><span class="lineCov">          1 :      ROSE_ASSERT(astNode != NULL);</span></a>
<a name="3018"><span class="lineNum">    3018 </span>            : </a>
<a name="3019"><span class="lineNum">    3019 </span><span class="lineCov">          1 :      ROSE_ASSERT(local_name_collision_map.empty() == true);</span></a>
<a name="3020"><span class="lineNum">    3020 </span><span class="lineCov">          1 :      ROSE_ASSERT(local_name_to_node_map.empty() == true);</span></a>
<a name="3021"><span class="lineNum">    3021 </span><span class="lineCov">          1 :      ROSE_ASSERT(local_node_to_name_map.empty() == true);</span></a>
<a name="3022"><span class="lineNum">    3022 </span>            : </a>
<a name="3023"><span class="lineNum">    3023 </span>            :   // Preorder traversal to uniquely name specific declarations (SgClassDeclaration and SgFunctionDeclaration IR nodes).</a>
<a name="3024"><span class="lineNum">    3024 </span><span class="lineCov">          1 :      class UniqueNameTraversal : public AstSimpleProcessing</span></a>
<a name="3025"><span class="lineNum">    3025 </span>            :         {</a>
<a name="3026"><span class="lineNum">    3026 </span>            :           public:</a>
<a name="3027"><span class="lineNum">    3027 </span><span class="lineCov">      98920 :                void visit (SgNode* node)</span></a>
<a name="3028"><span class="lineNum">    3028 </span>            :                   {</a>
<a name="3029"><span class="lineNum">    3029 </span><span class="lineCov">      98920 :                     SgDeclarationStatement* decl = isSgDeclarationStatement(node);</span></a>
<a name="3030"><span class="lineNum">    3030 </span><span class="lineCov">      98920 :                     if (decl != NULL)</span></a>
<a name="3031"><span class="lineNum">    3031 </span>            :                        {</a>
<a name="3032"><span class="lineNum">    3032 </span><span class="lineCov">      29349 :                          SgClassDeclaration* classDeclaration       = isSgClassDeclaration(decl);</span></a>
<a name="3033"><span class="lineNum">    3033 </span><span class="lineCov">      29349 :                          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(decl);</span></a>
<a name="3034"><span class="lineNum">    3034 </span><span class="lineCov">      29349 :                          if (classDeclaration != NULL || functionDeclaration != NULL)</span></a>
<a name="3035"><span class="lineNum">    3035 </span>            :                             {</a>
<a name="3036"><span class="lineNum">    3036 </span><span class="lineCov">      22622 :                               string s = generateUniqueNameForUseAsIdentifier_support(decl);</span></a>
<a name="3037"><span class="lineNum">    3037 </span><span class="lineCov">      11311 :                               local_name_to_node_map.insert(pair&lt;string,SgNode*&gt;(s,decl));</span></a>
<a name="3038"><span class="lineNum">    3038 </span><span class="lineCov">      22622 :                               local_node_to_name_map.insert(pair&lt;SgNode*,string&gt;(decl,s));</span></a>
<a name="3039"><span class="lineNum">    3039 </span>            :                             }</a>
<a name="3040"><span class="lineNum">    3040 </span>            :                        }</a>
<a name="3041"><span class="lineNum">    3041 </span><span class="lineCov">      98920 :                   }</span></a>
<a name="3042"><span class="lineNum">    3042 </span>            :         };</a>
<a name="3043"><span class="lineNum">    3043 </span>            : </a>
<a name="3044"><span class="lineNum">    3044 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="3045"><span class="lineNum">    3045 </span><span class="lineCov">          1 :      UniqueNameTraversal traversal;</span></a>
<a name="3046"><span class="lineNum">    3046 </span><span class="lineCov">          1 :      traversal.traverse(astNode, preorder);</span></a>
<a name="3047"><span class="lineNum">    3047 </span><span class="lineCov">          1 :    }</span></a>
<a name="3048"><span class="lineNum">    3048 </span>            : </a>
<a name="3049"><span class="lineNum">    3049 </span>            : </a>
<a name="3050"><span class="lineNum">    3050 </span>            : </a>
<a name="3051"><span class="lineNum">    3051 </span>            : SgMemberFunctionDeclaration*</a>
<a name="3052"><span class="lineNum">    3052 </span><span class="lineNoCov">          0 : SageInterface::getDefaultConstructor( SgClassDeclaration* classDeclaration )</span></a>
<a name="3053"><span class="lineNum">    3053 </span>            :    {</a>
<a name="3054"><span class="lineNum">    3054 </span><span class="lineNoCov">          0 :      SgMemberFunctionDeclaration* defaultConstructor = NULL;</span></a>
<a name="3055"><span class="lineNum">    3055 </span>            : </a>
<a name="3056"><span class="lineNum">    3056 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="3057"><span class="lineNum">    3057 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* definingDeclaration = classDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="3058"><span class="lineNum">    3058 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(definingDeclaration != NULL);</span></a>
<a name="3059"><span class="lineNum">    3059 </span><span class="lineNoCov">          0 :      SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclaration);</span></a>
<a name="3060"><span class="lineNum">    3060 </span>            : </a>
<a name="3061"><span class="lineNum">    3061 </span>            :   // Note that not all class declarations have to have a defining declaration (e.g. &quot;~int()&quot;</a>
<a name="3062"><span class="lineNum">    3062 </span>            :   // would be associated with a class declaration but no definition would exist).</a>
<a name="3063"><span class="lineNum">    3063 </span><span class="lineNoCov">          0 :      if (definingClassDeclaration != NULL)</span></a>
<a name="3064"><span class="lineNum">    3064 </span>            :         {</a>
<a name="3065"><span class="lineNum">    3065 </span><span class="lineNoCov">          0 :           SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="3066"><span class="lineNum">    3066 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="3067"><span class="lineNum">    3067 </span>            : </a>
<a name="3068"><span class="lineNum">    3068 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList::iterator i = classDefinition-&gt;get_members().begin();</span></a>
<a name="3069"><span class="lineNum">    3069 </span><span class="lineNoCov">          0 :           while ( i != classDefinition-&gt;get_members().end() )</span></a>
<a name="3070"><span class="lineNum">    3070 </span>            :              {</a>
<a name="3071"><span class="lineNum">    3071 </span>            :             // Check the parent pointer to make sure it is properly set</a>
<a name="3072"><span class="lineNum">    3072 </span><span class="lineNoCov">          0 :                ROSE_ASSERT( (*i)-&gt;get_parent() != NULL);</span></a>
<a name="3073"><span class="lineNum">    3073 </span><span class="lineNoCov">          0 :                ROSE_ASSERT( (*i)-&gt;get_parent() == classDefinition);</span></a>
<a name="3074"><span class="lineNum">    3074 </span>            : </a>
<a name="3075"><span class="lineNum">    3075 </span><span class="lineNoCov">          0 :                SgMemberFunctionDeclaration* memberFunction = isSgMemberFunctionDeclaration(*i);</span></a>
<a name="3076"><span class="lineNum">    3076 </span><span class="lineNoCov">          0 :                if (memberFunction != NULL)</span></a>
<a name="3077"><span class="lineNum">    3077 </span>            :                   {</a>
<a name="3078"><span class="lineNum">    3078 </span>            :                  // printf (&quot;memberFunction = %p = %s \n&quot;,memberFunction,memberFunction-&gt;get_name().str());</a>
<a name="3079"><span class="lineNum">    3079 </span><span class="lineNoCov">          0 :                     if ( memberFunction-&gt;get_specialFunctionModifier().isConstructor() == true )</span></a>
<a name="3080"><span class="lineNum">    3080 </span><span class="lineNoCov">          0 :                        defaultConstructor = memberFunction;</span></a>
<a name="3081"><span class="lineNum">    3081 </span>            :                   }</a>
<a name="3082"><span class="lineNum">    3082 </span>            : </a>
<a name="3083"><span class="lineNum">    3083 </span>            :             // iterate through the class members</a>
<a name="3084"><span class="lineNum">    3084 </span><span class="lineNoCov">          0 :                i++;</span></a>
<a name="3085"><span class="lineNum">    3085 </span>            :              }</a>
<a name="3086"><span class="lineNum">    3086 </span>            :         }</a>
<a name="3087"><span class="lineNum">    3087 </span>            : </a>
<a name="3088"><span class="lineNum">    3088 </span>            :   // This should be true for the specific case that we are currently debugging!</a>
<a name="3089"><span class="lineNum">    3089 </span>            :   // ROSE_ASSERT(defaultConstructor != NULL);</a>
<a name="3090"><span class="lineNum">    3090 </span>            : </a>
<a name="3091"><span class="lineNum">    3091 </span><span class="lineNoCov">          0 :      return defaultConstructor;</span></a>
<a name="3092"><span class="lineNum">    3092 </span>            :    }</a>
<a name="3093"><span class="lineNum">    3093 </span>            : </a>
<a name="3094"><span class="lineNum">    3094 </span>            : SgMemberFunctionDeclaration*</a>
<a name="3095"><span class="lineNum">    3095 </span><span class="lineCov">          8 : SageInterface::getDefaultDestructor( SgClassDeclaration* classDeclaration )</span></a>
<a name="3096"><span class="lineNum">    3096 </span>            :    {</a>
<a name="3097"><span class="lineNum">    3097 </span><span class="lineCov">          8 :      SgMemberFunctionDeclaration* defaultDestructor = NULL;</span></a>
<a name="3098"><span class="lineNum">    3098 </span>            : </a>
<a name="3099"><span class="lineNum">    3099 </span><span class="lineCov">          8 :      ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="3100"><span class="lineNum">    3100 </span><span class="lineCov">          8 :      SgDeclarationStatement* definingDeclaration = classDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="3101"><span class="lineNum">    3101 </span><span class="lineCov">          8 :      if (definingDeclaration != NULL)</span></a>
<a name="3102"><span class="lineNum">    3102 </span>            :         {</a>
<a name="3103"><span class="lineNum">    3103 </span><span class="lineCov">          8 :           ROSE_ASSERT(definingDeclaration != NULL);</span></a>
<a name="3104"><span class="lineNum">    3104 </span><span class="lineCov">          8 :           SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclaration);</span></a>
<a name="3105"><span class="lineNum">    3105 </span>            : </a>
<a name="3106"><span class="lineNum">    3106 </span>            :        // Note that not all class declarations have to have a defining declaration (e.g. &quot;~int()&quot;</a>
<a name="3107"><span class="lineNum">    3107 </span>            :        // would be associated with a class declaration but no definition would exist).</a>
<a name="3108"><span class="lineNum">    3108 </span><span class="lineCov">          8 :           if (definingClassDeclaration != NULL)</span></a>
<a name="3109"><span class="lineNum">    3109 </span>            :              {</a>
<a name="3110"><span class="lineNum">    3110 </span><span class="lineCov">          8 :                SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="3111"><span class="lineNum">    3111 </span><span class="lineCov">          8 :                ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="3112"><span class="lineNum">    3112 </span>            : </a>
<a name="3113"><span class="lineNum">    3113 </span><span class="lineCov">          8 :                SgDeclarationStatementPtrList::iterator i = classDefinition-&gt;get_members().begin();</span></a>
<a name="3114"><span class="lineNum">    3114 </span><span class="lineCov">        516 :                while ( i != classDefinition-&gt;get_members().end() )</span></a>
<a name="3115"><span class="lineNum">    3115 </span>            :                   {</a>
<a name="3116"><span class="lineNum">    3116 </span>            :                  // Check the parent pointer to make sure it is properly set</a>
<a name="3117"><span class="lineNum">    3117 </span><span class="lineCov">        508 :                     SgNode* i_parent = (*i)-&gt;get_parent();</span></a>
<a name="3118"><span class="lineNum">    3118 </span><span class="lineCov">        508 :                     ROSE_ASSERT(i_parent != NULL);</span></a>
<a name="3119"><span class="lineNum">    3119 </span>            : </a>
<a name="3120"><span class="lineNum">    3120 </span>            :                  // DQ (11/1/2005): Note that a template instantiation can have a parent which is the</a>
<a name="3121"><span class="lineNum">    3121 </span>            :                  // variable which forced it's instantiation.  Since it does not really exist in the</a>
<a name="3122"><span class="lineNum">    3122 </span>            :                  // source code explicitly (it is compiler generated) this is as reasonable as anything else.</a>
<a name="3123"><span class="lineNum">    3123 </span>            :                  // if ( i_parent != classDefinition &amp;&amp; isSgVariableDeclaration(i_parent) == NULL)</a>
<a name="3124"><span class="lineNum">    3124 </span><span class="lineCov">        508 :                     if ( i_parent != classDefinition )</span></a>
<a name="3125"><span class="lineNum">    3125 </span>            :                        {</a>
<a name="3126"><span class="lineNum">    3126 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: (*i)-&gt;get_parent() = %p = %s \n&quot;,i_parent,i_parent-&gt;class_name().c_str());</span></a>
<a name="3127"><span class="lineNum">    3127 </span><span class="lineNoCov">          0 :                          printf (&quot;(*i) = %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),(*i)-&gt;unparseToString().c_str());</span></a>
<a name="3128"><span class="lineNum">    3128 </span><span class="lineNoCov">          0 :                          (*i)-&gt;get_file_info()-&gt;display(&quot;Called from SageInterface::getDefaultDestructor: debug&quot;);</span></a>
<a name="3129"><span class="lineNum">    3129 </span>            :                        }</a>
<a name="3130"><span class="lineNum">    3130 </span><span class="lineCov">        508 :                     ROSE_ASSERT( i_parent == classDefinition);</span></a>
<a name="3131"><span class="lineNum">    3131 </span>            :                  // ROSE_ASSERT( i_parent == classDefinition || isSgVariableDeclaration(i_parent) != NULL);</a>
<a name="3132"><span class="lineNum">    3132 </span>            : </a>
<a name="3133"><span class="lineNum">    3133 </span><span class="lineCov">        508 :                     SgMemberFunctionDeclaration* memberFunction = isSgMemberFunctionDeclaration(*i);</span></a>
<a name="3134"><span class="lineNum">    3134 </span><span class="lineCov">        508 :                     if (memberFunction != NULL)</span></a>
<a name="3135"><span class="lineNum">    3135 </span>            :                        {</a>
<a name="3136"><span class="lineNum">    3136 </span>            :                       // printf (&quot;memberFunction = %p = %s \n&quot;,memberFunction,memberFunction-&gt;get_name().str());</a>
<a name="3137"><span class="lineNum">    3137 </span><span class="lineCov">        416 :                          if ( memberFunction-&gt;get_specialFunctionModifier().isDestructor() == true )</span></a>
<a name="3138"><span class="lineNum">    3138 </span><span class="lineCov">          4 :                             defaultDestructor = memberFunction;</span></a>
<a name="3139"><span class="lineNum">    3139 </span>            :                        }</a>
<a name="3140"><span class="lineNum">    3140 </span>            : </a>
<a name="3141"><span class="lineNum">    3141 </span>            :                  // iterate through the class members</a>
<a name="3142"><span class="lineNum">    3142 </span><span class="lineCov">        508 :                     i++;</span></a>
<a name="3143"><span class="lineNum">    3143 </span>            :                   }</a>
<a name="3144"><span class="lineNum">    3144 </span>            :              }</a>
<a name="3145"><span class="lineNum">    3145 </span>            :         }</a>
<a name="3146"><span class="lineNum">    3146 </span>            : </a>
<a name="3147"><span class="lineNum">    3147 </span>            :   // This should be true for the specific case that we are currently debugging!</a>
<a name="3148"><span class="lineNum">    3148 </span>            :   // ROSE_ASSERT(defaultDestructor != NULL);</a>
<a name="3149"><span class="lineNum">    3149 </span>            : </a>
<a name="3150"><span class="lineNum">    3150 </span><span class="lineCov">          8 :      return defaultDestructor;</span></a>
<a name="3151"><span class="lineNum">    3151 </span>            :    }</a>
<a name="3152"><span class="lineNum">    3152 </span>            : </a>
<a name="3153"><span class="lineNum">    3153 </span>            : </a>
<a name="3154"><span class="lineNum">    3154 </span>            : </a>
<a name="3155"><span class="lineNum">    3155 </span>            : bool</a>
<a name="3156"><span class="lineNum">    3156 </span><span class="lineNoCov">          0 : SageInterface::addDefaultConstructorIfRequired ( SgClassType* classType, int physical_file_id /* = Sg_File_Info::TRANSFORMATION_FILE_ID */ )</span></a>
<a name="3157"><span class="lineNum">    3157 </span>            :    {</a>
<a name="3158"><span class="lineNum">    3158 </span>            :   // DQ (11/9/2020): Added function to support adding a default constructor definition to a class</a>
<a name="3159"><span class="lineNum">    3159 </span>            :   // if it does not have a default constructor, but has any other constructor that would prevent</a>
<a name="3160"><span class="lineNum">    3160 </span>            :   // a compiler generated default constructor from being generated by the compiler.</a>
<a name="3161"><span class="lineNum">    3161 </span>            : </a>
<a name="3162"><span class="lineNum">    3162 </span>            :   // Note the physical_file_id is so that it can be marked to be unparsed when header file unparsing is active.</a>
<a name="3163"><span class="lineNum">    3163 </span>            : </a>
<a name="3164"><span class="lineNum">    3164 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classType != NULL);</span></a>
<a name="3165"><span class="lineNum">    3165 </span>            : </a>
<a name="3166"><span class="lineNum">    3166 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="3167"><span class="lineNum">    3167 </span>            : </a>
<a name="3168"><span class="lineNum">    3168 </span>            :   // To setup this transformation we need to see if there is a default constructor in the associated class.</a>
<a name="3169"><span class="lineNum">    3169 </span><span class="lineNoCov">          0 :      SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="3170"><span class="lineNum">    3170 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="3171"><span class="lineNum">    3171 </span><span class="lineNoCov">          0 :      SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="3172"><span class="lineNum">    3172 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="3173"><span class="lineNum">    3173 </span><span class="lineNoCov">          0 :      SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="3174"><span class="lineNum">    3174 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="3175"><span class="lineNum">    3175 </span>            : </a>
<a name="3176"><span class="lineNum">    3176 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList &amp; declarationList = classDefinition-&gt;get_members();</span></a>
<a name="3177"><span class="lineNum">    3177 </span>            : </a>
<a name="3178"><span class="lineNum">    3178 </span><span class="lineNoCov">          0 :      bool foundConstructor        = false;</span></a>
<a name="3179"><span class="lineNum">    3179 </span><span class="lineNoCov">          0 :      bool foundDefaultConstructor = false;</span></a>
<a name="3180"><span class="lineNum">    3180 </span>            : </a>
<a name="3181"><span class="lineNum">    3181 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList::iterator i = declarationList.begin();</span></a>
<a name="3182"><span class="lineNum">    3182 </span><span class="lineNoCov">          0 :      while (i != declarationList.end())</span></a>
<a name="3183"><span class="lineNum">    3183 </span>            :         {</a>
<a name="3184"><span class="lineNum">    3184 </span><span class="lineNoCov">          0 :           SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(*i);</span></a>
<a name="3185"><span class="lineNum">    3185 </span><span class="lineNoCov">          0 :           if (memberFunctionDeclaration != NULL)</span></a>
<a name="3186"><span class="lineNum">    3186 </span>            :              {</a>
<a name="3187"><span class="lineNum">    3187 </span><span class="lineNoCov">          0 :                bool isConstructor = memberFunctionDeclaration-&gt;get_specialFunctionModifier().isConstructor();</span></a>
<a name="3188"><span class="lineNum">    3188 </span><span class="lineNoCov">          0 :                if (isConstructor == true)</span></a>
<a name="3189"><span class="lineNum">    3189 </span>            :                   {</a>
<a name="3190"><span class="lineNum">    3190 </span><span class="lineNoCov">          0 :                     foundConstructor = true;</span></a>
<a name="3191"><span class="lineNum">    3191 </span>            : #if 0</a>
<a name="3192"><span class="lineNum">    3192 </span>            :                     printf (&quot;Found a constructor! \n&quot;);</a>
<a name="3193"><span class="lineNum">    3193 </span>            : #endif</a>
<a name="3194"><span class="lineNum">    3194 </span><span class="lineNoCov">          0 :                     SgFunctionParameterList* functionParameterList = memberFunctionDeclaration-&gt;get_parameterList();</span></a>
<a name="3195"><span class="lineNum">    3195 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionParameterList != NULL);</span></a>
<a name="3196"><span class="lineNum">    3196 </span><span class="lineNoCov">          0 :                     foundDefaultConstructor = (functionParameterList-&gt;get_args().size() == 0);</span></a>
<a name="3197"><span class="lineNum">    3197 </span>            : #if 0</a>
<a name="3198"><span class="lineNum">    3198 </span>            :                     if (foundDefaultConstructor == true)</a>
<a name="3199"><span class="lineNum">    3199 </span>            :                        {</a>
<a name="3200"><span class="lineNum">    3200 </span>            :                          printf (&quot;Found a default constructor! \n&quot;);</a>
<a name="3201"><span class="lineNum">    3201 </span>            :                        }</a>
<a name="3202"><span class="lineNum">    3202 </span>            : #endif</a>
<a name="3203"><span class="lineNum">    3203 </span>            :                   }</a>
<a name="3204"><span class="lineNum">    3204 </span>            :              }</a>
<a name="3205"><span class="lineNum">    3205 </span>            : </a>
<a name="3206"><span class="lineNum">    3206 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="3207"><span class="lineNum">    3207 </span>            :         }</a>
<a name="3208"><span class="lineNum">    3208 </span>            : </a>
<a name="3209"><span class="lineNum">    3209 </span>            : #if 0</a>
<a name="3210"><span class="lineNum">    3210 </span>            :      printf (&quot;foundConstructor        = %s \n&quot;,foundConstructor ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3211"><span class="lineNum">    3211 </span>            :      printf (&quot;foundDefaultConstructor = %s \n&quot;,foundDefaultConstructor ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3212"><span class="lineNum">    3212 </span>            : #endif</a>
<a name="3213"><span class="lineNum">    3213 </span>            : </a>
<a name="3214"><span class="lineNum">    3214 </span><span class="lineNoCov">          0 :      if (foundConstructor == true)</span></a>
<a name="3215"><span class="lineNum">    3215 </span>            :         {</a>
<a name="3216"><span class="lineNum">    3216 </span>            :        // Since there is at least one constructor, we can't rely on compiler generated constructors.</a>
<a name="3217"><span class="lineNum">    3217 </span>            : #if 0</a>
<a name="3218"><span class="lineNum">    3218 </span>            :           printf (&quot;Since there is at least one constructor, we can't rely on compiler generated constructors \n&quot;);</a>
<a name="3219"><span class="lineNum">    3219 </span>            : #endif</a>
<a name="3220"><span class="lineNum">    3220 </span><span class="lineNoCov">          0 :           if (foundDefaultConstructor == true)</span></a>
<a name="3221"><span class="lineNum">    3221 </span>            :              {</a>
<a name="3222"><span class="lineNum">    3222 </span>            :             // We can use the existing default constructor.</a>
<a name="3223"><span class="lineNum">    3223 </span>            : #if 0</a>
<a name="3224"><span class="lineNum">    3224 </span>            :                printf (&quot;We can use the existing default constructor (no need to build one) \n&quot;);</a>
<a name="3225"><span class="lineNum">    3225 </span>            : #endif</a>
<a name="3226"><span class="lineNum">    3226 </span>            :              }</a>
<a name="3227"><span class="lineNum">    3227 </span>            :             else</a>
<a name="3228"><span class="lineNum">    3228 </span>            :              {</a>
<a name="3229"><span class="lineNum">    3229 </span>            :             // We don't have a default constructor, so we need to build one explicitly, and insert it into the class definition.</a>
<a name="3230"><span class="lineNum">    3230 </span>            : #if 0</a>
<a name="3231"><span class="lineNum">    3231 </span>            :                printf (&quot;########################################################### \n&quot;);</a>
<a name="3232"><span class="lineNum">    3232 </span>            :                printf (&quot;Need to build a default constructor in the associated class \n&quot;);</a>
<a name="3233"><span class="lineNum">    3233 </span>            : #endif</a>
<a name="3234"><span class="lineNum">    3234 </span><span class="lineNoCov">          0 :                SgMemberFunctionDeclaration* constructorDeclaration = SageBuilder::buildDefaultConstructor(classType);</span></a>
<a name="3235"><span class="lineNum">    3235 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(constructorDeclaration != NULL);</span></a>
<a name="3236"><span class="lineNum">    3236 </span>            : #if 0</a>
<a name="3237"><span class="lineNum">    3237 </span>            :                printf (&quot; --- constructorDeclaration = %p = %s name = %s \n&quot;,constructorDeclaration,constructorDeclaration-&gt;class_name().c_str(),constructorDeclaration-&gt;get_name().str());</a>
<a name="3238"><span class="lineNum">    3238 </span>            : #endif</a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (constructorDeclaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true);</span></a>
<a name="3240"><span class="lineNum">    3240 </span>            : </a>
<a name="3241"><span class="lineNum">    3241 </span><span class="lineNoCov">          0 :                classDefinition-&gt;prepend_statement(constructorDeclaration);</span></a>
<a name="3242"><span class="lineNum">    3242 </span>            : </a>
<a name="3243"><span class="lineNum">    3243 </span>            :             // constructorDeclaration-&gt;set_parent(classDefinition);</a>
<a name="3244"><span class="lineNum">    3244 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(constructorDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="3245"><span class="lineNum">    3245 </span>            : </a>
<a name="3246"><span class="lineNum">    3246 </span>            :             // int physical_file_id = variableDeclaration-&gt;get_startOfConstruct()-&gt;get_physical_file_id();</a>
<a name="3247"><span class="lineNum">    3247 </span><span class="lineNoCov">          0 :                markSubtreeToBeUnparsed(constructorDeclaration,physical_file_id);</span></a>
<a name="3248"><span class="lineNum">    3248 </span>            : </a>
<a name="3249"><span class="lineNum">    3249 </span>            :                returnValue = true;</a>
<a name="3250"><span class="lineNum">    3250 </span>            : #if 0</a>
<a name="3251"><span class="lineNum">    3251 </span>            :                constructorDeclaration-&gt;get_startOfConstruct()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="3252"><span class="lineNum">    3252 </span>            :                constructorDeclaration-&gt;get_endOfConstruct  ()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="3253"><span class="lineNum">    3253 </span>            : </a>
<a name="3254"><span class="lineNum">    3254 </span>            :             // We also need to set the source position of the function definition, else the</a>
<a name="3255"><span class="lineNum">    3255 </span>            :             // function declaration will not be output.</a>
<a name="3256"><span class="lineNum">    3256 </span>            :                ROSE_ASSERT(constructorDeclaration-&gt;get_definition() != NULL);</a>
<a name="3257"><span class="lineNum">    3257 </span>            :                ROSE_ASSERT(constructorDeclaration-&gt;get_definition()-&gt;get_startOfConstruct() != NULL);</a>
<a name="3258"><span class="lineNum">    3258 </span>            :                ROSE_ASSERT(constructorDeclaration-&gt;get_definition()-&gt;get_endOfConstruct() != NULL);</a>
<a name="3259"><span class="lineNum">    3259 </span>            :                constructorDeclaration-&gt;get_definition()-&gt;get_startOfConstruct()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="3260"><span class="lineNum">    3260 </span>            :                constructorDeclaration-&gt;get_definition()-&gt;get_endOfConstruct  ()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="3261"><span class="lineNum">    3261 </span>            : #endif</a>
<a name="3262"><span class="lineNum">    3262 </span>            : #if 0</a>
<a name="3263"><span class="lineNum">    3263 </span>            :                printf (&quot;DONE: Need to build a default constructor in the associated class \n&quot;);</a>
<a name="3264"><span class="lineNum">    3264 </span>            :                printf (&quot;################################################################# \n&quot;);</a>
<a name="3265"><span class="lineNum">    3265 </span>            : #endif</a>
<a name="3266"><span class="lineNum">    3266 </span>            : #if 0</a>
<a name="3267"><span class="lineNum">    3267 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3268"><span class="lineNum">    3268 </span>            :                ROSE_ABORT();</a>
<a name="3269"><span class="lineNum">    3269 </span>            : #endif</a>
<a name="3270"><span class="lineNum">    3270 </span>            :              }</a>
<a name="3271"><span class="lineNum">    3271 </span>            :         }</a>
<a name="3272"><span class="lineNum">    3272 </span>            :        else</a>
<a name="3273"><span class="lineNum">    3273 </span>            :         {</a>
<a name="3274"><span class="lineNum">    3274 </span>            :        // No constructors found, so we don't need to add an explicit default constructor.</a>
<a name="3275"><span class="lineNum">    3275 </span>            : #if 0</a>
<a name="3276"><span class="lineNum">    3276 </span>            :           printf (&quot;No constructors found, so we don't need to add an explicit default constructor \n&quot;);</a>
<a name="3277"><span class="lineNum">    3277 </span>            : #endif</a>
<a name="3278"><span class="lineNum">    3278 </span>            :         }</a>
<a name="3279"><span class="lineNum">    3279 </span>            : </a>
<a name="3280"><span class="lineNum">    3280 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="3281"><span class="lineNum">    3281 </span>            :    }</a>
<a name="3282"><span class="lineNum">    3282 </span>            : </a>
<a name="3283"><span class="lineNum">    3283 </span>            : </a>
<a name="3284"><span class="lineNum">    3284 </span>            : </a>
<a name="3285"><span class="lineNum">    3285 </span>            : </a>
<a name="3286"><span class="lineNum">    3286 </span>            : void</a>
<a name="3287"><span class="lineNum">    3287 </span><span class="lineCov">          1 : SageInterface::outputGlobalFunctionTypeSymbolTable()</span></a>
<a name="3288"><span class="lineNum">    3288 </span>            :    {</a>
<a name="3289"><span class="lineNum">    3289 </span>            :   // DQ (6/27/2005): This function outputs the global table of function type symbols</a>
<a name="3290"><span class="lineNum">    3290 </span>            :   // it is built during the EDG/Sage translation phase, and it built initially with</a>
<a name="3291"><span class="lineNum">    3291 </span>            :   // the EDG names of all instantiated templates.  At a later phase (incomplete at</a>
<a name="3292"><span class="lineNum">    3292 </span>            :   // the moment) the AST fixup rebuilds the table to use the modified template names</a>
<a name="3293"><span class="lineNum">    3293 </span>            :   // (that is mangled names built from the modified template names used in Sage III).</a>
<a name="3294"><span class="lineNum">    3294 </span>            : </a>
<a name="3295"><span class="lineNum">    3295 </span>            :   // DQ (1/31/2006): Modified to build all types in the memory pools</a>
<a name="3296"><span class="lineNum">    3296 </span>            :   // extern SgFunctionTypeTable Sgfunc_type_table;</a>
<a name="3297"><span class="lineNum">    3297 </span>            :   // Sgfunc_type_table.print_functypetable();</a>
<a name="3298"><span class="lineNum">    3298 </span><span class="lineCov">          1 :      ROSE_ASSERT(SgNode::get_globalFunctionTypeTable() != NULL);</span></a>
<a name="3299"><span class="lineNum">    3299 </span><span class="lineCov">          1 :      SgNode::get_globalFunctionTypeTable()-&gt;print_functypetable();</span></a>
<a name="3300"><span class="lineNum">    3300 </span><span class="lineCov">          1 :    }</span></a>
<a name="3301"><span class="lineNum">    3301 </span>            : </a>
<a name="3302"><span class="lineNum">    3302 </span>            : void</a>
<a name="3303"><span class="lineNum">    3303 </span><span class="lineCov">          1 : SageInterface::outputLocalSymbolTables ( SgNode* node )</span></a>
<a name="3304"><span class="lineNum">    3304 </span>            :    {</a>
<a name="3305"><span class="lineNum">    3305 </span>            :   // This simplifies how the traversal is called!</a>
<a name="3306"><span class="lineNum">    3306 </span><span class="lineCov">          1 :      OutputLocalSymbolTables astTraversal;</span></a>
<a name="3307"><span class="lineNum">    3307 </span>            : </a>
<a name="3308"><span class="lineNum">    3308 </span>            :   // I think the default should be preorder so that the interfaces would be more uniform</a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">          1 :      astTraversal.traverse(node,preorder);</span></a>
<a name="3310"><span class="lineNum">    3310 </span><span class="lineCov">          1 :    }</span></a>
<a name="3311"><span class="lineNum">    3311 </span>            : </a>
<a name="3312"><span class="lineNum">    3312 </span>            : void</a>
<a name="3313"><span class="lineNum">    3313 </span><span class="lineCov">          9 : SageInterface::OutputLocalSymbolTables::visit ( SgNode* node )</span></a>
<a name="3314"><span class="lineNum">    3314 </span>            :    {</a>
<a name="3315"><span class="lineNum">    3315 </span>            :   // DQ (6/27/2005): Output the local symbol table from each scope.</a>
<a name="3316"><span class="lineNum">    3316 </span>            :   // printf (&quot;node = %s \n&quot;,node-&gt;sage_class_name());</a>
<a name="3317"><span class="lineNum">    3317 </span>            : </a>
<a name="3318"><span class="lineNum">    3318 </span>            : #if 0</a>
<a name="3319"><span class="lineNum">    3319 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="3320"><span class="lineNum">    3320 </span>            :      ROSE_ABORT();</a>
<a name="3321"><span class="lineNum">    3321 </span>            : #endif</a>
<a name="3322"><span class="lineNum">    3322 </span>            : </a>
<a name="3323"><span class="lineNum">    3323 </span><span class="lineCov">          9 :      SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="3324"><span class="lineNum">    3324 </span><span class="lineCov">          9 :      if (scope != NULL)</span></a>
<a name="3325"><span class="lineNum">    3325 </span>            :         {</a>
<a name="3326"><span class="lineNum">    3326 </span>            :        // SgSymbolTable* symbolTable = scope-&gt;get_symbol_table();</a>
<a name="3327"><span class="lineNum">    3327 </span>            :        // ROSE_ASSERT(symbolTable != NULL);</a>
<a name="3328"><span class="lineNum">    3328 </span>            : </a>
<a name="3329"><span class="lineNum">    3329 </span><span class="lineCov">          2 :           printf (&quot;Symbol Table from %p = %s at: \n&quot;,scope,scope-&gt;sage_class_name());</span></a>
<a name="3330"><span class="lineNum">    3330 </span><span class="lineCov">          2 :           scope-&gt;get_file_info()-&gt;display(&quot;Symbol Table Location (Called from SageInterface::OutputLocalSymbolTables::visit())&quot;);</span></a>
<a name="3331"><span class="lineNum">    3331 </span>            :        // symbolTable-&gt;print(&quot;Called from SageInterface::OutputLocalSymbolTables::visit()&quot;);</a>
<a name="3332"><span class="lineNum">    3332 </span><span class="lineCov">          4 :           scope-&gt;print_symboltable(&quot;Called from SageInterface::OutputLocalSymbolTables::visit()&quot;);</span></a>
<a name="3333"><span class="lineNum">    3333 </span>            :         }</a>
<a name="3334"><span class="lineNum">    3334 </span><span class="lineCov">          9 :    }</span></a>
<a name="3335"><span class="lineNum">    3335 </span>            : </a>
<a name="3336"><span class="lineNum">    3336 </span>            : #if 0</a>
<a name="3337"><span class="lineNum">    3337 </span>            : // DQ (8/28/2005): This is already a member function of the SgFunctionDeclaration</a>
<a name="3338"><span class="lineNum">    3338 </span>            : // (so that it can handle template functions and member functions)</a>
<a name="3339"><span class="lineNum">    3339 </span>            : </a>
<a name="3340"><span class="lineNum">    3340 </span>            : // DQ (8/27/2005):</a>
<a name="3341"><span class="lineNum">    3341 </span>            : bool</a>
<a name="3342"><span class="lineNum">    3342 </span>            : SageInterface::isTemplateMemberFunction( SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration )</a>
<a name="3343"><span class="lineNum">    3343 </span>            :    {</a>
<a name="3344"><span class="lineNum">    3344 </span>            :   // This function determines if the member function is associated with a template</a>
<a name="3345"><span class="lineNum">    3345 </span>            :   // or just a template class (where it is a normal non-template member function).</a>
<a name="3346"><span class="lineNum">    3346 </span>            : </a>
<a name="3347"><span class="lineNum">    3347 </span>            :      bool result = false;</a>
<a name="3348"><span class="lineNum">    3348 </span>            : </a>
<a name="3349"><span class="lineNum">    3349 </span>            :      result = memberFunctionDeclaration-&gt;isTemplateFunction();</a>
<a name="3350"><span class="lineNum">    3350 </span>            : </a>
<a name="3351"><span class="lineNum">    3351 </span>            :      return result;</a>
<a name="3352"><span class="lineNum">    3352 </span>            :    }</a>
<a name="3353"><span class="lineNum">    3353 </span>            : #endif</a>
<a name="3354"><span class="lineNum">    3354 </span>            : </a>
<a name="3355"><span class="lineNum">    3355 </span>            : // DQ (8/27/2005):</a>
<a name="3356"><span class="lineNum">    3356 </span>            : bool</a>
<a name="3357"><span class="lineNum">    3357 </span><span class="lineCov">       1783 : SageInterface::templateDefinitionIsInClass( SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration )</span></a>
<a name="3358"><span class="lineNum">    3358 </span>            :    {</a>
<a name="3359"><span class="lineNum">    3359 </span>            :   // This function determines if the template declaration associated withthis member function instantiation is</a>
<a name="3360"><span class="lineNum">    3360 </span>            :   // defined in the class or outside of the class.</a>
<a name="3361"><span class="lineNum">    3361 </span>            : </a>
<a name="3362"><span class="lineNum">    3362 </span><span class="lineCov">       1783 :      bool result = false;</span></a>
<a name="3363"><span class="lineNum">    3363 </span>            : </a>
<a name="3364"><span class="lineNum">    3364 </span>            : #if 0</a>
<a name="3365"><span class="lineNum">    3365 </span>            :   // Check if this is a template or non-template member function</a>
<a name="3366"><span class="lineNum">    3366 </span>            :      if (isTemplateMemberFunction(memberFunctionDeclaration) == true)</a>
<a name="3367"><span class="lineNum">    3367 </span>            :         {</a>
<a name="3368"><span class="lineNum">    3368 </span>            :           SgTemplateDeclaration* templateDeclaration = memberFunctionDeclaration-&gt;get_templateDeclaration();</a>
<a name="3369"><span class="lineNum">    3369 </span>            :           printf (&quot;templateDeclaration = %p parent of templateDeclaration = %p \n&quot;,templateDeclaration,templateDeclaration-&gt;get_parent());</a>
<a name="3370"><span class="lineNum">    3370 </span>            : </a>
<a name="3371"><span class="lineNum">    3371 </span>            :        // SgTemplateInstantiationDecl* classTemplateInstantiation = memberFunctionDeclaration-&gt;get_class_scope()-&gt;get_declaration();</a>
<a name="3372"><span class="lineNum">    3372 </span>            :           SgClassDeclaration* classDeclaration = memberFunctionDeclaration-&gt;get_class_scope()-&gt;get_declaration();</a>
<a name="3373"><span class="lineNum">    3373 </span>            :           ROSE_ASSERT(classDeclaration != NULL);</a>
<a name="3374"><span class="lineNum">    3374 </span>            :           SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(classDeclaration);</a>
<a name="3375"><span class="lineNum">    3375 </span>            : </a>
<a name="3376"><span class="lineNum">    3376 </span>            :           if (classTemplateInstantiation != NULL)</a>
<a name="3377"><span class="lineNum">    3377 </span>            :              {</a>
<a name="3378"><span class="lineNum">    3378 </span>            :                SgTemplateDeclaration* classTemplateDeclaration = classTemplateInstantiation-&gt;get_templateDeclaration();</a>
<a name="3379"><span class="lineNum">    3379 </span>            :                if (classTemplateDeclaration != NULL &amp;&amp; classTemplateDeclaration != templateDeclaration)</a>
<a name="3380"><span class="lineNum">    3380 </span>            :                   {</a>
<a name="3381"><span class="lineNum">    3381 </span>            :                     result = true;</a>
<a name="3382"><span class="lineNum">    3382 </span>            :                   }</a>
<a name="3383"><span class="lineNum">    3383 </span>            :              }</a>
<a name="3384"><span class="lineNum">    3384 </span>            :         }</a>
<a name="3385"><span class="lineNum">    3385 </span>            : #endif</a>
<a name="3386"><span class="lineNum">    3386 </span>            : </a>
<a name="3387"><span class="lineNum">    3387 </span>            :   // Alternative approach</a>
<a name="3388"><span class="lineNum">    3388 </span>            :   // SgTemplateDeclaration* templateDeclaration = memberFunctionDeclaration-&gt;get_templateDeclaration();</a>
<a name="3389"><span class="lineNum">    3389 </span><span class="lineCov">       1783 :      SgDeclarationStatement* templateDeclaration = memberFunctionDeclaration-&gt;get_templateDeclaration();</span></a>
<a name="3390"><span class="lineNum">    3390 </span>            : //     printf (&quot;In templateDefinitionIsInClass(): templateDeclaration = %p parent of templateDeclaration = %p = %s \n&quot;,templateDeclaration,</a>
<a name="3391"><span class="lineNum">    3391 </span>            : //          templateDeclaration-&gt;get_parent(),templateDeclaration-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="3392"><span class="lineNum">    3392 </span>            : </a>
<a name="3393"><span class="lineNum">    3393 </span><span class="lineCov">       1783 :     if (templateDeclaration != NULL &amp;&amp; templateDeclaration-&gt;get_parent() != NULL)</span></a>
<a name="3394"><span class="lineNum">    3394 </span>            :     {</a>
<a name="3395"><span class="lineNum">    3395 </span><span class="lineCov">       1783 :       SgScopeStatement* parentScope = isSgScopeStatement(templateDeclaration-&gt;get_parent());</span></a>
<a name="3396"><span class="lineNum">    3396 </span><span class="lineCov">       1783 :       if (isSgClassDefinition(parentScope) != NULL)</span></a>
<a name="3397"><span class="lineNum">    3397 </span>            :          {</a>
<a name="3398"><span class="lineNum">    3398 </span><span class="lineCov">       1783 :            result = true;</span></a>
<a name="3399"><span class="lineNum">    3399 </span>            :          }</a>
<a name="3400"><span class="lineNum">    3400 </span>            :     }</a>
<a name="3401"><span class="lineNum">    3401 </span>            : </a>
<a name="3402"><span class="lineNum">    3402 </span><span class="lineCov">       1783 :      return result;</span></a>
<a name="3403"><span class="lineNum">    3403 </span>            :    }</a>
<a name="3404"><span class="lineNum">    3404 </span>            : #if 0</a>
<a name="3405"><span class="lineNum">    3405 </span>            : SgDeclarationStatement*</a>
<a name="3406"><span class="lineNum">    3406 </span>            : generateUniqueDeclaration ( SgDeclarationStatement* declaration )</a>
<a name="3407"><span class="lineNum">    3407 </span>            :    {</a>
<a name="3408"><span class="lineNum">    3408 </span>            :   // DQ (10/11/2007): This is no longer used.</a>
<a name="3409"><span class="lineNum">    3409 </span>            :      printf (&quot;Error: This is no longer used. \n&quot;);</a>
<a name="3410"><span class="lineNum">    3410 </span>            :      ROSE_ABORT();</a>
<a name="3411"><span class="lineNum">    3411 </span>            : </a>
<a name="3412"><span class="lineNum">    3412 </span>            :   // Get the defining or first non-defining declaration so that we can use it as a key to know</a>
<a name="3413"><span class="lineNum">    3413 </span>            :   // when we have found the same function. So we don't count a redundant forward declaration</a>
<a name="3414"><span class="lineNum">    3414 </span>            :   // found outside of the class as matching the first non-defining declaration or the defining</a>
<a name="3415"><span class="lineNum">    3415 </span>            :   // declaration in the class by mistake. All declarations share the same firstNondefining</a>
<a name="3416"><span class="lineNum">    3416 </span>            :   // declaration and defining declaration so either could be a key declaration, but there are</a>
<a name="3417"><span class="lineNum">    3417 </span>            :   // times when either one of then (but not both) can be NULL (function defined withouth forward</a>
<a name="3418"><span class="lineNum">    3418 </span>            :   // declaration or not defined at all).</a>
<a name="3419"><span class="lineNum">    3419 </span>            :      SgDeclarationStatement* firstNondefiningDeclaration = declaration-&gt;get_firstNondefiningDeclaration();</a>
<a name="3420"><span class="lineNum">    3420 </span>            :      SgDeclarationStatement* definingDeclaration         = declaration-&gt;get_definingDeclaration();</a>
<a name="3421"><span class="lineNum">    3421 </span>            :      SgDeclarationStatement* keyDeclaration = NULL;</a>
<a name="3422"><span class="lineNum">    3422 </span>            :      if (firstNondefiningDeclaration != NULL)</a>
<a name="3423"><span class="lineNum">    3423 </span>            :           keyDeclaration = firstNondefiningDeclaration;</a>
<a name="3424"><span class="lineNum">    3424 </span>            :        else</a>
<a name="3425"><span class="lineNum">    3425 </span>            :           keyDeclaration = definingDeclaration;</a>
<a name="3426"><span class="lineNum">    3426 </span>            :      ROSE_ASSERT(keyDeclaration != NULL);</a>
<a name="3427"><span class="lineNum">    3427 </span>            : </a>
<a name="3428"><span class="lineNum">    3428 </span>            :      return keyDeclaration;</a>
<a name="3429"><span class="lineNum">    3429 </span>            :    }</a>
<a name="3430"><span class="lineNum">    3430 </span>            : #endif</a>
<a name="3431"><span class="lineNum">    3431 </span>            : //! Extract a SgPragmaDeclaration's leading keyword . For example &quot;#pragma omp parallel&quot; has a keyword of &quot;omp&quot;.</a>
<a name="3432"><span class="lineNum">    3432 </span><span class="lineNoCov">          0 : std::string SageInterface::extractPragmaKeyword(const SgPragmaDeclaration *pragmaDeclaration)</span></a>
<a name="3433"><span class="lineNum">    3433 </span>            : {</a>
<a name="3434"><span class="lineNum">    3434 </span><span class="lineNoCov">          0 :   string pragmaString = pragmaDeclaration-&gt;get_pragma()-&gt;get_pragma();</span></a>
<a name="3435"><span class="lineNum">    3435 </span><span class="lineNoCov">          0 :   istringstream istr(pragmaString);</span></a>
<a name="3436"><span class="lineNum">    3436 </span><span class="lineNoCov">          0 :   std::string key;</span></a>
<a name="3437"><span class="lineNum">    3437 </span><span class="lineNoCov">          0 :   istr &gt;&gt; key;</span></a>
<a name="3438"><span class="lineNum">    3438 </span><span class="lineNoCov">          0 :   return key;</span></a>
<a name="3439"><span class="lineNum">    3439 </span>            : }</a>
<a name="3440"><span class="lineNum">    3440 </span>            : </a>
<a name="3441"><span class="lineNum">    3441 </span>            : //! Check if a node is SgOmp*Statement</a>
<a name="3442"><span class="lineNum">    3442 </span>            : // TODO: move all Omp*statement under a parent SgOmpStatement</a>
<a name="3443"><span class="lineNum">    3443 </span><span class="lineNoCov">          0 : bool SageInterface::isOmpStatement(SgNode* n)</span></a>
<a name="3444"><span class="lineNum">    3444 </span>            : {</a>
<a name="3445"><span class="lineNum">    3445 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (n != NULL);</span></a>
<a name="3446"><span class="lineNum">    3446 </span><span class="lineNoCov">          0 :   bool result = false;</span></a>
<a name="3447"><span class="lineNum">    3447 </span><span class="lineNoCov">          0 :   if (isSgOmpBarrierStatement(n)||</span></a>
<a name="3448"><span class="lineNum">    3448 </span><span class="lineNoCov">          0 :       isSgUpirBodyStatement(n)||</span></a>
<a name="3449"><span class="lineNum">    3449 </span><span class="lineNoCov">          0 :       isSgOmpDeclareSimdStatement(n) ||</span></a>
<a name="3450"><span class="lineNum">    3450 </span><span class="lineNoCov">          0 :       isSgOmpFlushStatement(n)||</span></a>
<a name="3451"><span class="lineNum">    3451 </span><span class="lineNoCov">          0 :       isSgOmpThreadprivateStatement(n)||</span></a>
<a name="3452"><span class="lineNum">    3452 </span><span class="lineNoCov">          0 :       isSgOmpTaskwaitStatement(n) )</span></a>
<a name="3453"><span class="lineNum">    3453 </span>            :     result = true;</a>
<a name="3454"><span class="lineNum">    3454 </span>            : </a>
<a name="3455"><span class="lineNum">    3455 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="3456"><span class="lineNum">    3456 </span>            : </a>
<a name="3457"><span class="lineNum">    3457 </span>            : }</a>
<a name="3458"><span class="lineNum">    3458 </span>            : // DQ (8/28/2005):</a>
<a name="3459"><span class="lineNum">    3459 </span>            : bool</a>
<a name="3460"><span class="lineNum">    3460 </span><span class="lineCov">       5125 : SageInterface::isOverloaded ( SgFunctionDeclaration* functionDeclaration )</span></a>
<a name="3461"><span class="lineNum">    3461 </span>            :    {</a>
<a name="3462"><span class="lineNum">    3462 </span>            :   // This function looks for any other function that might overload the input function.</a>
<a name="3463"><span class="lineNum">    3463 </span>            :   // for member functions we only look in the scope where the member function is defined.</a>
<a name="3464"><span class="lineNum">    3464 </span>            :   // for non-member functions we look only in the scope where the function is declared.</a>
<a name="3465"><span class="lineNum">    3465 </span>            : </a>
<a name="3466"><span class="lineNum">    3466 </span>            :   // Note that there are scenarios where this approach of searching only these locations</a>
<a name="3467"><span class="lineNum">    3467 </span>            :   // might not catch an overloaded function.</a>
<a name="3468"><span class="lineNum">    3468 </span>            :   //     * member functions:</a>
<a name="3469"><span class="lineNum">    3469 </span>            :   //         - overloaded functions might be declared in base classes</a>
<a name="3470"><span class="lineNum">    3470 </span>            :   //     * non-member functions:</a>
<a name="3471"><span class="lineNum">    3471 </span>            :   //         - function declarations might be friend functions in classes</a>
<a name="3472"><span class="lineNum">    3472 </span>            :   //         - functions might be declared in differen namespace definitions</a>
<a name="3473"><span class="lineNum">    3473 </span>            :   //              (SgNamespaceDefinitionStatement), since a namespace in re-entrant</a>
<a name="3474"><span class="lineNum">    3474 </span>            :   //              and can have many namespace declarations and definitions.</a>
<a name="3475"><span class="lineNum">    3475 </span>            : </a>
<a name="3476"><span class="lineNum">    3476 </span>            :   // bool result = false;</a>
<a name="3477"><span class="lineNum">    3477 </span><span class="lineCov">       5125 :      int counter = 0;</span></a>
<a name="3478"><span class="lineNum">    3478 </span>            : </a>
<a name="3479"><span class="lineNum">    3479 </span><span class="lineCov">       5125 :      SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="3480"><span class="lineNum">    3480 </span><span class="lineCov">       5125 :      if (memberFunctionDeclaration != NULL)</span></a>
<a name="3481"><span class="lineNum">    3481 </span>            :         {</a>
<a name="3482"><span class="lineNum">    3482 </span>            :        // This is a member function declaration</a>
<a name="3483"><span class="lineNum">    3483 </span>            : </a>
<a name="3484"><span class="lineNum">    3484 </span>            :        // DQ (10/11/2007): Fix this to NOT use the generateUniqueDeclaration() function.</a>
<a name="3485"><span class="lineNum">    3485 </span>            :        // Generate a key to use for comparision (avoids false positives)</a>
<a name="3486"><span class="lineNum">    3486 </span>            :        // SgMemberFunctionDeclaration* keyDeclaration = isSgMemberFunctionDeclaration(generateUniqueDeclaration(functionDeclaration));</a>
<a name="3487"><span class="lineNum">    3487 </span>            :        // ROSE_ASSERT(keyDeclaration != NULL);</a>
<a name="3488"><span class="lineNum">    3488 </span>            : </a>
<a name="3489"><span class="lineNum">    3489 </span><span class="lineCov">       5125 :           SgScopeStatement * scope = memberFunctionDeclaration-&gt;get_scope();</span></a>
<a name="3490"><span class="lineNum">    3490 </span><span class="lineCov">       5125 :           ROSE_ASSERT(scope != NULL);</span></a>
<a name="3491"><span class="lineNum">    3491 </span>            : </a>
<a name="3492"><span class="lineNum">    3492 </span>            :        // TV (09/17/2018): ROSE-1378</a>
<a name="3493"><span class="lineNum">    3493 </span><span class="lineCov">       5125 :           if (isSgDeclarationScope(scope)) {</span></a>
<a name="3494"><span class="lineNum">    3494 </span><span class="lineCov">        279 :             printf(&quot;TODO SageInterface::isOverloaded case when scope is SgDeclarationScope. See ROSE-1378.\n&quot;);</span></a>
<a name="3495"><span class="lineNum">    3495 </span><span class="lineCov">        279 :             return false;</span></a>
<a name="3496"><span class="lineNum">    3496 </span>            :           }</a>
<a name="3497"><span class="lineNum">    3497 </span>            : </a>
<a name="3498"><span class="lineNum">    3498 </span>            :        // Get the class definition</a>
<a name="3499"><span class="lineNum">    3499 </span><span class="lineCov">       4846 :           SgClassDefinition* classDefinition =</span></a>
<a name="3500"><span class="lineNum">    3500 </span><span class="lineCov">       4846 :                isSgClassDefinition(memberFunctionDeclaration-&gt;get_scope());</span></a>
<a name="3501"><span class="lineNum">    3501 </span><span class="lineCov">       4846 :           ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="3502"><span class="lineNum">    3502 </span>            : </a>
<a name="3503"><span class="lineNum">    3503 </span>            :        // Get the class declaration associated with the class definition</a>
<a name="3504"><span class="lineNum">    3504 </span><span class="lineCov">       4846 :           SgClassDeclaration* classDeclaration = isSgClassDeclaration(classDefinition-&gt;get_declaration());</span></a>
<a name="3505"><span class="lineNum">    3505 </span><span class="lineCov">       4846 :           ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="3506"><span class="lineNum">    3506 </span>            : </a>
<a name="3507"><span class="lineNum">    3507 </span>            :        // Get the list of member declarations in the class</a>
<a name="3508"><span class="lineNum">    3508 </span><span class="lineCov">       4846 :           SgDeclarationStatementPtrList &amp; memberList = classDefinition-&gt;get_members();</span></a>
<a name="3509"><span class="lineNum">    3509 </span>            : #if 0</a>
<a name="3510"><span class="lineNum">    3510 </span>            :        // DQ (10/11/2007): Fix this function better by checking for more than one member function declaration in the class definition.</a>
<a name="3511"><span class="lineNum">    3511 </span>            :           printf (&quot;   memberList.size() = %&quot; PRIuPTR &quot; \n&quot;,memberList.size());</a>
<a name="3512"><span class="lineNum">    3512 </span>            : #endif</a>
<a name="3513"><span class="lineNum">    3513 </span><span class="lineCov">     237864 :           for (SgDeclarationStatementPtrList::iterator i = memberList.begin(); i != memberList.end(); i++)</span></a>
<a name="3514"><span class="lineNum">    3514 </span>            :              {</a>
<a name="3515"><span class="lineNum">    3515 </span>            : #if 0</a>
<a name="3516"><span class="lineNum">    3516 </span>            :                printf (&quot;   counter = %d declaration = %p = %s \n&quot;,counter,*i,(*i)-&gt;class_name().c_str());</a>
<a name="3517"><span class="lineNum">    3517 </span>            : #endif</a>
<a name="3518"><span class="lineNum">    3518 </span><span class="lineCov">     235466 :                SgMemberFunctionDeclaration* tempMemberFunction = isSgMemberFunctionDeclaration(*i);</span></a>
<a name="3519"><span class="lineNum">    3519 </span><span class="lineCov">     235466 :                SgTemplateDeclaration* tempTemplateDeclaration  = isSgTemplateDeclaration(*i);</span></a>
<a name="3520"><span class="lineNum">    3520 </span>            : </a>
<a name="3521"><span class="lineNum">    3521 </span>            :             // Member functions could be overloaded</a>
<a name="3522"><span class="lineNum">    3522 </span><span class="lineCov">     235466 :                if (tempMemberFunction != NULL)</span></a>
<a name="3523"><span class="lineNum">    3523 </span>            :                   {</a>
<a name="3524"><span class="lineNum">    3524 </span>            : #if 0</a>
<a name="3525"><span class="lineNum">    3525 </span>            :                  // DQ (10/11/2007): This is a problem for where s member function prototype from outside the class is checked to be an ovverloaded function.</a>
<a name="3526"><span class="lineNum">    3526 </span>            :                  // Check using the key declaration</a>
<a name="3527"><span class="lineNum">    3527 </span>            :                     if ( keyDeclaration == generateUniqueDeclaration(tempMemberFunction) )</a>
<a name="3528"><span class="lineNum">    3528 </span>            :                        {</a>
<a name="3529"><span class="lineNum">    3529 </span>            : #if 0</a>
<a name="3530"><span class="lineNum">    3530 </span>            :                          printf (&quot;Skipping the case of keyDeclaration == generateUniqueDeclaration(tempMemberFunction) = %p \n&quot;,keyDeclaration);</a>
<a name="3531"><span class="lineNum">    3531 </span>            : #endif</a>
<a name="3532"><span class="lineNum">    3532 </span>            :                          continue;</a>
<a name="3533"><span class="lineNum">    3533 </span>            :                        }</a>
<a name="3534"><span class="lineNum">    3534 </span>            : #endif</a>
<a name="3535"><span class="lineNum">    3535 </span><span class="lineCov">     179788 :                     ROSE_ASSERT(tempMemberFunction-&gt;get_name() != &quot;&quot;);</span></a>
<a name="3536"><span class="lineNum">    3536 </span>            : #if 0</a>
<a name="3537"><span class="lineNum">    3537 </span>            :                     printf (&quot;      tempMemberFunction = (name) %s = (qualified) %s \n&quot;,</a>
<a name="3538"><span class="lineNum">    3538 </span>            :                               tempMemberFunction-&gt;get_name().str(),</a>
<a name="3539"><span class="lineNum">    3539 </span>            :                               tempMemberFunction-&gt;get_qualified_name().str());</a>
<a name="3540"><span class="lineNum">    3540 </span>            : #endif</a>
<a name="3541"><span class="lineNum">    3541 </span><span class="lineCov">     179788 :                     if (tempMemberFunction-&gt;get_name() == memberFunctionDeclaration-&gt;get_name())</span></a>
<a name="3542"><span class="lineNum">    3542 </span>            :                        {</a>
<a name="3543"><span class="lineNum">    3543 </span>            : #if 0</a>
<a name="3544"><span class="lineNum">    3544 </span>            :                          printf (&quot;      Found a matching overloaded member function! \n&quot;);</a>
<a name="3545"><span class="lineNum">    3545 </span>            : #endif</a>
<a name="3546"><span class="lineNum">    3546 </span>            :                       // result = true;</a>
<a name="3547"><span class="lineNum">    3547 </span><span class="lineCov">       7161 :                          counter++;</span></a>
<a name="3548"><span class="lineNum">    3548 </span>            :                        }</a>
<a name="3549"><span class="lineNum">    3549 </span>            :                   }</a>
<a name="3550"><span class="lineNum">    3550 </span>            :                  else</a>
<a name="3551"><span class="lineNum">    3551 </span>            :                   {</a>
<a name="3552"><span class="lineNum">    3552 </span>            :                  // Or templates could be overloaded, but nothing else.</a>
<a name="3553"><span class="lineNum">    3553 </span><span class="lineCov">      55678 :                     if (tempTemplateDeclaration != NULL)</span></a>
<a name="3554"><span class="lineNum">    3554 </span>            :                        {</a>
<a name="3555"><span class="lineNum">    3555 </span>            :                       // If this is a template declaration, it could be a template</a>
<a name="3556"><span class="lineNum">    3556 </span>            :                       // declaration for an overloaded member function of the same name.</a>
<a name="3557"><span class="lineNum">    3557 </span>            : #if 0</a>
<a name="3558"><span class="lineNum">    3558 </span>            :                       // printf (&quot;keyDeclaration-&gt;get_name() = %s \n&quot;,keyDeclaration-&gt;get_name().str());</a>
<a name="3559"><span class="lineNum">    3559 </span>            :                          printf (&quot;tempTemplateDeclaration-&gt;get_name() = %s \n&quot;,tempTemplateDeclaration-&gt;get_name().str());</a>
<a name="3560"><span class="lineNum">    3560 </span>            : #endif</a>
<a name="3561"><span class="lineNum">    3561 </span>            :                       // if (keyDeclaration-&gt;get_name() == tempTemplateDeclaration-&gt;get_name())</a>
<a name="3562"><span class="lineNum">    3562 </span><span class="lineNoCov">          0 :                          if (memberFunctionDeclaration-&gt;get_name() == tempTemplateDeclaration-&gt;get_name())</span></a>
<a name="3563"><span class="lineNum">    3563 </span>            :                             {</a>
<a name="3564"><span class="lineNum">    3564 </span>            : #if 0</a>
<a name="3565"><span class="lineNum">    3565 </span>            :                               printf (&quot;      Found a matching overloaded member function! \n&quot;);</a>
<a name="3566"><span class="lineNum">    3566 </span>            : #endif</a>
<a name="3567"><span class="lineNum">    3567 </span>            :                            // result = true;</a>
<a name="3568"><span class="lineNum">    3568 </span><span class="lineNoCov">          0 :                               counter++;</span></a>
<a name="3569"><span class="lineNum">    3569 </span>            :                             }</a>
<a name="3570"><span class="lineNum">    3570 </span>            :                        }</a>
<a name="3571"><span class="lineNum">    3571 </span>            :                       else</a>
<a name="3572"><span class="lineNum">    3572 </span>            :                        {</a>
<a name="3573"><span class="lineNum">    3573 </span>            :                        // DQ (10/12/2007): Could friend functions defined in a class be overloaded?  Need to check this!</a>
<a name="3574"><span class="lineNum">    3574 </span><span class="lineCov">      55678 :                           if (functionDeclaration-&gt;variantT() == V_SgFunctionDeclaration)</span></a>
<a name="3575"><span class="lineNum">    3575 </span>            :                              {</a>
<a name="3576"><span class="lineNum">    3576 </span><span class="lineNoCov">          0 :                                printf (&quot;In SageInterface::isOverloaded(): could friend functions be overloaded in a class? \n&quot;);</span></a>
<a name="3577"><span class="lineNum">    3577 </span>            :                              }</a>
<a name="3578"><span class="lineNum">    3578 </span>            :                        }</a>
<a name="3579"><span class="lineNum">    3579 </span>            :                   }</a>
<a name="3580"><span class="lineNum">    3580 </span>            : </a>
<a name="3581"><span class="lineNum">    3581 </span>            :             // If we have detected two, so we have an overloaded function.</a>
<a name="3582"><span class="lineNum">    3582 </span><span class="lineCov">     235466 :                if (counter &gt; 1)</span></a>
<a name="3583"><span class="lineNum">    3583 </span>            :                     break;</a>
<a name="3584"><span class="lineNum">    3584 </span>            :              }</a>
<a name="3585"><span class="lineNum">    3585 </span>            :         }</a>
<a name="3586"><span class="lineNum">    3586 </span>            :        else</a>
<a name="3587"><span class="lineNum">    3587 </span>            :         {</a>
<a name="3588"><span class="lineNum">    3588 </span>            :        // This is a non-member function declaration</a>
<a name="3589"><span class="lineNum">    3589 </span><span class="lineNoCov">          0 :           printf (&quot;In SageInterface::isOverloaded(): case of non-member function not yet implemented! \n&quot;);</span></a>
<a name="3590"><span class="lineNum">    3590 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="3591"><span class="lineNum">    3591 </span>            :         }</a>
<a name="3592"><span class="lineNum">    3592 </span>            : </a>
<a name="3593"><span class="lineNum">    3593 </span>            :   // DQ (10/11/2007): Fixup to use the counter and consider more than 1 function with the same name an overloaded member function.</a>
<a name="3594"><span class="lineNum">    3594 </span>            :   // This might be a problem for friend functions, so test this separately.</a>
<a name="3595"><span class="lineNum">    3595 </span>            :   // return result;</a>
<a name="3596"><span class="lineNum">    3596 </span><span class="lineCov">       4846 :      return (counter &gt; 1);</span></a>
<a name="3597"><span class="lineNum">    3597 </span>            :    }</a>
<a name="3598"><span class="lineNum">    3598 </span>            : </a>
<a name="3599"><span class="lineNum">    3599 </span>            : </a>
<a name="3600"><span class="lineNum">    3600 </span>            : </a>
<a name="3601"><span class="lineNum">    3601 </span>            : </a>
<a name="3602"><span class="lineNum">    3602 </span>            : SgTemplateInstantiationMemberFunctionDecl*</a>
<a name="3603"><span class="lineNum">    3603 </span><span class="lineNoCov">          0 : SageInterface::buildForwardFunctionDeclaration ( SgTemplateInstantiationMemberFunctionDecl* memberFunctionInstantiation )</span></a>
<a name="3604"><span class="lineNum">    3604 </span>            :    {</a>
<a name="3605"><span class="lineNum">    3605 </span>            :   // DQ (9/6/2005): This function builds a copy of the input function for the</a>
<a name="3606"><span class="lineNum">    3606 </span>            :   // construction of a forward declaration of the function. Required in the</a>
<a name="3607"><span class="lineNum">    3607 </span>            :   // instantiated functions definition is to be output as a specialization by ROSE.</a>
<a name="3608"><span class="lineNum">    3608 </span>            :   // Since the shallow copy mechanism will cause IR nodes to be shared, we have</a>
<a name="3609"><span class="lineNum">    3609 </span>            :   // to fix it up with deep copies of the parameter list and the CtorInitializerList.</a>
<a name="3610"><span class="lineNum">    3610 </span>            : </a>
<a name="3611"><span class="lineNum">    3611 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionInstantiation != NULL);</span></a>
<a name="3612"><span class="lineNum">    3612 </span>            : </a>
<a name="3613"><span class="lineNum">    3613 </span>            : #if 0</a>
<a name="3614"><span class="lineNum">    3614 </span>            :     printf (&quot;buildForwardFunctionDeclaration: Member function = %p = %s = definition = %p \n&quot;,</a>
<a name="3615"><span class="lineNum">    3615 </span>            :           memberFunctionInstantiation,</a>
<a name="3616"><span class="lineNum">    3616 </span>            :           memberFunctionInstantiation-&gt;get_name().str(),</a>
<a name="3617"><span class="lineNum">    3617 </span>            :           memberFunctionInstantiation-&gt;get_definition());</a>
<a name="3618"><span class="lineNum">    3618 </span>            :     memberFunctionInstantiation-&gt;get_file_info()-&gt;display(&quot;memberFunctionInstantiation: debug&quot;);</a>
<a name="3619"><span class="lineNum">    3619 </span>            : #endif</a>
<a name="3620"><span class="lineNum">    3620 </span>            : </a>
<a name="3621"><span class="lineNum">    3621 </span>            :   // This is a better implementation using a derived class from SgCopyHelp to control the</a>
<a name="3622"><span class="lineNum">    3622 </span>            :   // copying process (skipping the copy of any function definition).  This is a variable</a>
<a name="3623"><span class="lineNum">    3623 </span>            :   // declaration with an explicitly declared class type.</a>
<a name="3624"><span class="lineNum">    3624 </span><span class="lineNoCov">          0 :      class NondefiningFunctionDeclarationCopyType : public SgCopyHelp</span></a>
<a name="3625"><span class="lineNum">    3625 </span>            :         {</a>
<a name="3626"><span class="lineNum">    3626 </span>            :        // DQ (9/26/2005): This class demonstrates the use of the copy mechanism</a>
<a name="3627"><span class="lineNum">    3627 </span>            :        // within Sage III (originally designed and implemented by Qing Yi).</a>
<a name="3628"><span class="lineNum">    3628 </span>            :        // One problem with it is that there is no context information permitted.</a>
<a name="3629"><span class="lineNum">    3629 </span>            : </a>
<a name="3630"><span class="lineNum">    3630 </span>            :           public:</a>
<a name="3631"><span class="lineNum">    3631 </span><span class="lineNoCov">          0 :                virtual SgNode *copyAst(const SgNode *n)</span></a>
<a name="3632"><span class="lineNum">    3632 </span>            :                   {</a>
<a name="3633"><span class="lineNum">    3633 </span>            :                  // If still NULL after switch then make the copy</a>
<a name="3634"><span class="lineNum">    3634 </span><span class="lineNoCov">          0 :                     SgNode* returnValue = NULL;</span></a>
<a name="3635"><span class="lineNum">    3635 </span>            : </a>
<a name="3636"><span class="lineNum">    3636 </span><span class="lineNoCov">          0 :                     switch(n-&gt;variantT())</span></a>
<a name="3637"><span class="lineNum">    3637 </span>            :                        {</a>
<a name="3638"><span class="lineNum">    3638 </span>            :                       // DQ (10/21/2007): Now that s bug is fixed in the SgDeclarationStatement::fixupCopy()</a>
<a name="3639"><span class="lineNum">    3639 </span>            :                       // member function, I think we might not need this case.</a>
<a name="3640"><span class="lineNum">    3640 </span>            : </a>
<a name="3641"><span class="lineNum">    3641 </span>            :                       // Don't copy the associated non-defining declaration when building a function prototype!</a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 :                          case V_SgFunctionDeclaration:</span></a>
<a name="3643"><span class="lineNum">    3643 </span><span class="lineNoCov">          0 :                          case V_SgMemberFunctionDeclaration:</span></a>
<a name="3644"><span class="lineNum">    3644 </span><span class="lineNoCov">          0 :                          case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="3645"><span class="lineNum">    3645 </span><span class="lineNoCov">          0 :                          case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="3646"><span class="lineNum">    3646 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="3647"><span class="lineNum">    3647 </span>            :                            // printf (&quot;Skip copying an associated non-defining declaration if it is present \n&quot;);</a>
<a name="3648"><span class="lineNum">    3648 </span><span class="lineNoCov">          0 :                               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(n);</span></a>
<a name="3649"><span class="lineNum">    3649 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="3650"><span class="lineNum">    3650 </span><span class="lineNoCov">          0 :                               if (functionDeclaration == functionDeclaration-&gt;get_definingDeclaration())</span></a>
<a name="3651"><span class="lineNum">    3651 </span>            :                                  {</a>
<a name="3652"><span class="lineNum">    3652 </span>            :                                 // This is the defining declaration (make a shallow copy)</a>
<a name="3653"><span class="lineNum">    3653 </span>            :                                 // printf (&quot;In NondefiningFunctionDeclarationCopyType::copyAst(): This is the DEFINING declaration! \n&quot;);</a>
<a name="3654"><span class="lineNum">    3654 </span>            :                                 // return const_cast&lt;SgNode *&gt;(n);</a>
<a name="3655"><span class="lineNum">    3655 </span>            :                                    returnValue = const_cast&lt;SgNode *&gt;(n);</a>
<a name="3656"><span class="lineNum">    3656 </span>            :                                  }</a>
<a name="3657"><span class="lineNum">    3657 </span>            :                                 else</a>
<a name="3658"><span class="lineNum">    3658 </span>            :                                  {</a>
<a name="3659"><span class="lineNum">    3659 </span>            :                                 // This is the non-defining declaration where we want to make a deep copy.</a>
<a name="3660"><span class="lineNum">    3660 </span>            :                                 // printf (&quot;In NondefiningFunctionDeclarationCopyType::copyAst(): This is the NONDEFINING declaration! \n&quot;);</a>
<a name="3661"><span class="lineNum">    3661 </span>            :                                  }</a>
<a name="3662"><span class="lineNum">    3662 </span>            : </a>
<a name="3663"><span class="lineNum">    3663 </span>            :                               break;</a>
<a name="3664"><span class="lineNum">    3664 </span>            :                             }</a>
<a name="3665"><span class="lineNum">    3665 </span>            : </a>
<a name="3666"><span class="lineNum">    3666 </span>            :                       // Don't copy the function definitions (roughly the body of the function)</a>
<a name="3667"><span class="lineNum">    3667 </span><span class="lineNoCov">          0 :                          case V_SgFunctionDefinition:</span></a>
<a name="3668"><span class="lineNum">    3668 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="3669"><span class="lineNum">    3669 </span><span class="lineNoCov">          0 :                               printf (&quot;Skip copying the function definition if it is present \n&quot;);</span></a>
<a name="3670"><span class="lineNum">    3670 </span>            :                            // return const_cast&lt;SgNode *&gt;(n);</a>
<a name="3671"><span class="lineNum">    3671 </span><span class="lineNoCov">          0 :                               returnValue = const_cast&lt;SgNode *&gt;(n);</span></a>
<a name="3672"><span class="lineNum">    3672 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="3673"><span class="lineNum">    3673 </span>            :                             }</a>
<a name="3674"><span class="lineNum">    3674 </span>            : </a>
<a name="3675"><span class="lineNum">    3675 </span>            :                          default:</a>
<a name="3676"><span class="lineNum">    3676 </span>            :                             {</a>
<a name="3677"><span class="lineNum">    3677 </span>            :                            // Nothing to do here</a>
<a name="3678"><span class="lineNum">    3678 </span>            :                               break;</a>
<a name="3679"><span class="lineNum">    3679 </span>            :                             }</a>
<a name="3680"><span class="lineNum">    3680 </span>            :                        }</a>
<a name="3681"><span class="lineNum">    3681 </span>            : </a>
<a name="3682"><span class="lineNum">    3682 </span>            :                  // return n-&gt;copy(*this);</a>
<a name="3683"><span class="lineNum">    3683 </span>            : </a>
<a name="3684"><span class="lineNum">    3684 </span>            :                  // If not set at this point then make the copy!</a>
<a name="3685"><span class="lineNum">    3685 </span>            :                     if (returnValue == NULL)</a>
<a name="3686"><span class="lineNum">    3686 </span><span class="lineNoCov">          0 :                          returnValue = n-&gt;copy(*this);</span></a>
<a name="3687"><span class="lineNum">    3687 </span>            : </a>
<a name="3688"><span class="lineNum">    3688 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(returnValue != NULL);</span></a>
<a name="3689"><span class="lineNum">    3689 </span><span class="lineNoCov">          0 :                     return returnValue;</span></a>
<a name="3690"><span class="lineNum">    3690 </span>            :                   }</a>
<a name="3691"><span class="lineNum">    3691 </span><span class="lineNoCov">          0 :         } nondefiningFunctionDeclarationCopy;</span></a>
<a name="3692"><span class="lineNum">    3692 </span>            : </a>
<a name="3693"><span class="lineNum">    3693 </span>            :   // DQ (10/20/2007): The more accurate copy mechanism now builds us a defining declaration to go with the non-defining declaration!</a>
<a name="3694"><span class="lineNum">    3694 </span>            :   // This is because we have to remove the pointers from non-defining declaration to the definition (which should be pointed to ONLY by the defining declaration!</a>
<a name="3695"><span class="lineNum">    3695 </span>            :   // delete copyOfMemberFunction-&gt;get_definingDeclaration();</a>
<a name="3696"><span class="lineNum">    3696 </span><span class="lineNoCov">          0 :      if (memberFunctionInstantiation-&gt;get_definition() != NULL)</span></a>
<a name="3697"><span class="lineNum">    3697 </span>            :         {</a>
<a name="3698"><span class="lineNum">    3698 </span><span class="lineNoCov">          0 :           printf (&quot;\n\nNEED TO REMOVE POINTERS IN THE NON-DEFINING DECLARATION TO THE SgClassDefinition objects. \n&quot;);</span></a>
<a name="3699"><span class="lineNum">    3699 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="3700"><span class="lineNum">    3700 </span>            : </a>
<a name="3701"><span class="lineNum">    3701 </span>            :        // If we see the assertion above fail then we might want to use this code:</a>
<a name="3702"><span class="lineNum">    3702 </span>            :           ROSE_ASSERT( memberFunctionInstantiation != memberFunctionInstantiation-&gt;get_definingDeclaration() );</a>
<a name="3703"><span class="lineNum">    3703 </span>            :           memberFunctionInstantiation-&gt;set_definition(NULL);</a>
<a name="3704"><span class="lineNum">    3704 </span>            :         }</a>
<a name="3705"><span class="lineNum">    3705 </span><span class="lineNoCov">          0 :      SgNode* copyOfMemberFunctionNode = memberFunctionInstantiation-&gt;copy(nondefiningFunctionDeclarationCopy);</span></a>
<a name="3706"><span class="lineNum">    3706 </span><span class="lineNoCov">          0 :      SgTemplateInstantiationMemberFunctionDecl* copyOfMemberFunction = static_cast&lt;SgTemplateInstantiationMemberFunctionDecl*&gt;(copyOfMemberFunctionNode);</span></a>
<a name="3707"><span class="lineNum">    3707 </span>            : </a>
<a name="3708"><span class="lineNum">    3708 </span>            :   // printf (&quot;\n\nHOW DO WE KNOW WHEN TO NOT COPY THE DEFINING DECLARATION SO THAT WE CAN JUST BUILD A FUNCTION PROTOTYPE! \n&quot;);</a>
<a name="3709"><span class="lineNum">    3709 </span>            :   // ROSE_ASSERT(false);</a>
<a name="3710"><span class="lineNum">    3710 </span>            : </a>
<a name="3711"><span class="lineNum">    3711 </span>            : #if 0</a>
<a name="3712"><span class="lineNum">    3712 </span>            :      printf (&quot;copyOfMemberFunction-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,copyOfMemberFunction-&gt;get_firstNondefiningDeclaration());</a>
<a name="3713"><span class="lineNum">    3713 </span>            : #endif</a>
<a name="3714"><span class="lineNum">    3714 </span>            :   // DQ (10/11/2007): The copy function sets the firstNondefiningDeclaration to itself if in the original declaration it had the</a>
<a name="3715"><span class="lineNum">    3715 </span>            :   // firstNondefiningDeclaration set to itself, this is incorrect in the case where we only make a copy of function declaration,</a>
<a name="3716"><span class="lineNum">    3716 </span>            :   // and causes the symbol table tests for get_declaration_associated_with_symbol() to fail because it uses the</a>
<a name="3717"><span class="lineNum">    3717 </span>            :   // firstNondefiningDeclaration which is not the one associated with the symbol in the parent scope. So reset the</a>
<a name="3718"><span class="lineNum">    3718 </span>            :   // firstNondefiningDeclaration in the copy of the member function.</a>
<a name="3719"><span class="lineNum">    3719 </span><span class="lineNoCov">          0 :      copyOfMemberFunction-&gt;set_firstNondefiningDeclaration(memberFunctionInstantiation-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="3720"><span class="lineNum">    3720 </span>            : </a>
<a name="3721"><span class="lineNum">    3721 </span>            : #if 0</a>
<a name="3722"><span class="lineNum">    3722 </span>            :      printf (&quot;memberFunctionInstantiation-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,memberFunctionInstantiation-&gt;get_firstNondefiningDeclaration());</a>
<a name="3723"><span class="lineNum">    3723 </span>            : </a>
<a name="3724"><span class="lineNum">    3724 </span>            :      printf (&quot;copyOfMemberFunction-&gt;isForward()        = %s \n&quot;,copyOfMemberFunction-&gt;isForward() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3725"><span class="lineNum">    3725 </span>            :      printf (&quot;memberFunctionInstantiation-&gt;isForward() = %s \n&quot;,memberFunctionInstantiation-&gt;isForward() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3726"><span class="lineNum">    3726 </span>            : #endif</a>
<a name="3727"><span class="lineNum">    3727 </span>            : #if 0</a>
<a name="3728"><span class="lineNum">    3728 </span>            :      printf (&quot;memberFunctionInstantiation-&gt;isSpecialization()        = %s \n&quot;,memberFunctionInstantiation-&gt;isSpecialization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3729"><span class="lineNum">    3729 </span>            :      printf (&quot;copyOfMemberFunctionNode = %p = %s = %s memberFunctionInstantiation-&gt;isSpecialization() = %s \n&quot;,</a>
<a name="3730"><span class="lineNum">    3730 </span>            :           copyOfMemberFunction,copyOfMemberFunction-&gt;class_name().c_str(),SageInterface::get_name(copyOfMemberFunction).c_str(),copyOfMemberFunction-&gt;isSpecialization() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3731"><span class="lineNum">    3731 </span>            :      copyOfMemberFunction-&gt;get_file_info()-&gt;display(&quot;copyOfMemberFunction: debug&quot;);</a>
<a name="3732"><span class="lineNum">    3732 </span>            : #endif</a>
<a name="3733"><span class="lineNum">    3733 </span>            : </a>
<a name="3734"><span class="lineNum">    3734 </span>            :   // Make sure that we have the same number of arguments on the copy that we build</a>
<a name="3735"><span class="lineNum">    3735 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionInstantiation-&gt;get_args().size() == copyOfMemberFunction-&gt;get_args().size());</span></a>
<a name="3736"><span class="lineNum">    3736 </span>            : </a>
<a name="3737"><span class="lineNum">    3737 </span>            :   // DQ (11/5/2007): Additional tests</a>
<a name="3738"><span class="lineNum">    3738 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionInstantiation-&gt;get_startOfConstruct()-&gt;isOutputInCodeGeneration() == copyOfMemberFunction-&gt;get_startOfConstruct()-&gt;isOutputInCodeGeneration());</span></a>
<a name="3739"><span class="lineNum">    3739 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(memberFunctionInstantiation-&gt;get_startOfConstruct()-&gt;isCompilerGenerated() == copyOfMemberFunction-&gt;get_startOfConstruct()-&gt;isCompilerGenerated());</span></a>
<a name="3740"><span class="lineNum">    3740 </span>            : </a>
<a name="3741"><span class="lineNum">    3741 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(copyOfMemberFunction != NULL);</span></a>
<a name="3742"><span class="lineNum">    3742 </span><span class="lineNoCov">          0 :      return copyOfMemberFunction;</span></a>
<a name="3743"><span class="lineNum">    3743 </span>            :    }</a>
<a name="3744"><span class="lineNum">    3744 </span>            : </a>
<a name="3745"><span class="lineNum">    3745 </span>            : </a>
<a name="3746"><span class="lineNum">    3746 </span>            : void</a>
<a name="3747"><span class="lineNum">    3747 </span><span class="lineNoCov">          0 : supportForBaseTypeDefiningDeclaration ( SgSymbolTable* symbolTable, SgDeclarationStatement* declarationForType )</span></a>
<a name="3748"><span class="lineNum">    3748 </span>            :    {</a>
<a name="3749"><span class="lineNum">    3749 </span>            :   // DQ (10/14/2007): Supporting function for</a>
<a name="3750"><span class="lineNum">    3750 </span>            : </a>
<a name="3751"><span class="lineNum">    3751 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(declarationForType != NULL);</span></a>
<a name="3752"><span class="lineNum">    3752 </span>            : </a>
<a name="3753"><span class="lineNum">    3753 </span>            :   // DQ (11/7/2007): Added more cases...</a>
<a name="3754"><span class="lineNum">    3754 </span><span class="lineNoCov">          0 :      switch(declarationForType-&gt;variantT())</span></a>
<a name="3755"><span class="lineNum">    3755 </span>            :         {</a>
<a name="3756"><span class="lineNum">    3756 </span>            :        // DQ (12/26/2012): Added support for templates.</a>
<a name="3757"><span class="lineNum">    3757 </span><span class="lineNoCov">          0 :           case V_SgTemplateInstantiationDecl:</span></a>
<a name="3758"><span class="lineNum">    3758 </span><span class="lineNoCov">          0 :           case V_SgTemplateClassDeclaration:</span></a>
<a name="3759"><span class="lineNum">    3759 </span>            : </a>
<a name="3760"><span class="lineNum">    3760 </span><span class="lineNoCov">          0 :           case V_SgClassDeclaration:</span></a>
<a name="3761"><span class="lineNum">    3761 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3762"><span class="lineNum">    3762 </span><span class="lineNoCov">          0 :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(declarationForType);</span></a>
<a name="3763"><span class="lineNum">    3763 </span>            :             // SgSymbol* symbol = new SgClassSymbol(classDeclaration);</a>
<a name="3764"><span class="lineNum">    3764 </span><span class="lineNoCov">          0 :                SgSymbol* symbol = NULL;</span></a>
<a name="3765"><span class="lineNum">    3765 </span><span class="lineNoCov">          0 :                if (isSgTemplateClassDeclaration(declarationForType) != NULL)</span></a>
<a name="3766"><span class="lineNum">    3766 </span>            :                   {</a>
<a name="3767"><span class="lineNum">    3767 </span><span class="lineNoCov">          0 :                     symbol = new SgTemplateClassSymbol(classDeclaration);</span></a>
<a name="3768"><span class="lineNum">    3768 </span>            :                   }</a>
<a name="3769"><span class="lineNum">    3769 </span>            :                  else</a>
<a name="3770"><span class="lineNum">    3770 </span>            :                   {</a>
<a name="3771"><span class="lineNum">    3771 </span><span class="lineNoCov">          0 :                     symbol = new SgClassSymbol(classDeclaration);</span></a>
<a name="3772"><span class="lineNum">    3772 </span>            :                   }</a>
<a name="3773"><span class="lineNum">    3773 </span>            : </a>
<a name="3774"><span class="lineNum">    3774 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3775"><span class="lineNum">    3775 </span><span class="lineNoCov">          0 :                SgName name = classDeclaration-&gt;get_name();</span></a>
<a name="3776"><span class="lineNum">    3776 </span><span class="lineNoCov">          0 :                symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3777"><span class="lineNum">    3777 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3778"><span class="lineNum">    3778 </span>            :              }</a>
<a name="3779"><span class="lineNum">    3779 </span>            : </a>
<a name="3780"><span class="lineNum">    3780 </span><span class="lineNoCov">          0 :           case V_SgEnumDeclaration:</span></a>
<a name="3781"><span class="lineNum">    3781 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineNoCov">          0 :                SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(declarationForType);</span></a>
<a name="3783"><span class="lineNum">    3783 </span><span class="lineNoCov">          0 :                SgSymbol* symbol = new SgEnumSymbol(enumDeclaration);</span></a>
<a name="3784"><span class="lineNum">    3784 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3785"><span class="lineNum">    3785 </span><span class="lineNoCov">          0 :                SgName name = enumDeclaration-&gt;get_name();</span></a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineNoCov">          0 :                symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3787"><span class="lineNum">    3787 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3788"><span class="lineNum">    3788 </span>            :              }</a>
<a name="3789"><span class="lineNum">    3789 </span>            : </a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineNoCov">          0 :           case V_SgFunctionDeclaration:</span></a>
<a name="3791"><span class="lineNum">    3791 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declarationForType);</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineNoCov">          0 :                SgSymbol* symbol = new SgFunctionSymbol(functionDeclaration);</span></a>
<a name="3794"><span class="lineNum">    3794 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3795"><span class="lineNum">    3795 </span><span class="lineNoCov">          0 :                SgName name = functionDeclaration-&gt;get_name();</span></a>
<a name="3796"><span class="lineNum">    3796 </span><span class="lineNoCov">          0 :                symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3797"><span class="lineNum">    3797 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3798"><span class="lineNum">    3798 </span>            :              }</a>
<a name="3799"><span class="lineNum">    3799 </span>            : </a>
<a name="3800"><span class="lineNum">    3800 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="3801"><span class="lineNum">    3801 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3802"><span class="lineNum">    3802 </span><span class="lineNoCov">          0 :                SgMemberFunctionDeclaration* functionDeclaration = isSgMemberFunctionDeclaration(declarationForType);</span></a>
<a name="3803"><span class="lineNum">    3803 </span><span class="lineNoCov">          0 :                SgSymbol* symbol = new SgMemberFunctionSymbol(functionDeclaration);</span></a>
<a name="3804"><span class="lineNum">    3804 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3805"><span class="lineNum">    3805 </span>            : </a>
<a name="3806"><span class="lineNum">    3806 </span>            :             // printf (&quot;In supportForBaseTypeDefiningDeclaration(): symbol = %p = %s = %s \n&quot;,symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(symbol).c_str());</a>
<a name="3807"><span class="lineNum">    3807 </span>            : </a>
<a name="3808"><span class="lineNum">    3808 </span><span class="lineNoCov">          0 :                SgName name = functionDeclaration-&gt;get_name();</span></a>
<a name="3809"><span class="lineNum">    3809 </span><span class="lineNoCov">          0 :                symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="3811"><span class="lineNum">    3811 </span>            :              }</a>
<a name="3812"><span class="lineNum">    3812 </span>            : </a>
<a name="3813"><span class="lineNum">    3813 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="3814"><span class="lineNum">    3814 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="3815"><span class="lineNum">    3815 </span><span class="lineNoCov">          0 :                printf (&quot;Default reached in evaluation of typedef inner definition = %p = %s and building a symbol for it for the symbol table \n&quot;,declarationForType,declarationForType-&gt;class_name().c_str());</span></a>
<a name="3816"><span class="lineNum">    3816 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="3817"><span class="lineNum">    3817 </span>            :              }</a>
<a name="3818"><span class="lineNum">    3818 </span>            :         }</a>
<a name="3819"><span class="lineNum">    3819 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="3820"><span class="lineNum">    3820 </span>            : </a>
<a name="3821"><span class="lineNum">    3821 </span>            : </a>
<a name="3822"><span class="lineNum">    3822 </span>            : void</a>
<a name="3823"><span class="lineNum">    3823 </span><span class="lineCov">          2 : supportForVariableLists ( SgScopeStatement* scope, SgSymbolTable* symbolTable, SgInitializedNamePtrList &amp; variableList )</span></a>
<a name="3824"><span class="lineNum">    3824 </span>            :    {</a>
<a name="3825"><span class="lineNum">    3825 </span>            :   // DQ (11/1/2007): Added supporting function to refactor code.</a>
<a name="3826"><span class="lineNum">    3826 </span><span class="lineCov">          2 :      SgInitializedNamePtrList::iterator i = variableList.begin();</span></a>
<a name="3827"><span class="lineNum">    3827 </span><span class="lineCov">          6 :      while (i != variableList.end())</span></a>
<a name="3828"><span class="lineNum">    3828 </span>            :         {</a>
<a name="3829"><span class="lineNum">    3829 </span><span class="lineCov">          4 :           SgInitializedName* variable = *i;</span></a>
<a name="3830"><span class="lineNum">    3830 </span><span class="lineCov">          4 :           ROSE_ASSERT(variable != NULL);</span></a>
<a name="3831"><span class="lineNum">    3831 </span><span class="lineCov">          4 :           if (variable-&gt;get_scope() == scope)</span></a>
<a name="3832"><span class="lineNum">    3832 </span>            :              {</a>
<a name="3833"><span class="lineNum">    3833 </span>            :             // printf (&quot;Scopes match, OK! \n&quot;);</a>
<a name="3834"><span class="lineNum">    3834 </span>            :              }</a>
<a name="3835"><span class="lineNum">    3835 </span>            :             else</a>
<a name="3836"><span class="lineNum">    3836 </span>            :              {</a>
<a name="3837"><span class="lineNum">    3837 </span><span class="lineNoCov">          0 :                if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="3838"><span class="lineNum">    3838 </span>            :                   {</a>
<a name="3839"><span class="lineNum">    3839 </span><span class="lineNoCov">          0 :                     printf (&quot;WARNING: Scopes do NOT match! variable = %p = %s (could this be a static variable, or has the symbol table been setup before the scopes have been set?) \n&quot;,variable,variable-&gt;get_name().str());</span></a>
<a name="3840"><span class="lineNum">    3840 </span>            :                   }</a>
<a name="3841"><span class="lineNum">    3841 </span>            :              }</a>
<a name="3842"><span class="lineNum">    3842 </span>            : </a>
<a name="3843"><span class="lineNum">    3843 </span><span class="lineCov">          4 :           SgSymbol* symbol = new SgVariableSymbol(variable);</span></a>
<a name="3844"><span class="lineNum">    3844 </span><span class="lineCov">          4 :           ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3845"><span class="lineNum">    3845 </span><span class="lineCov">          8 :           SgName name = variable-&gt;get_name();</span></a>
<a name="3846"><span class="lineNum">    3846 </span><span class="lineCov">          4 :           symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3847"><span class="lineNum">    3847 </span>            : </a>
<a name="3848"><span class="lineNum">    3848 </span><span class="lineCov">          4 :           i++;</span></a>
<a name="3849"><span class="lineNum">    3849 </span>            :         }</a>
<a name="3850"><span class="lineNum">    3850 </span><span class="lineCov">          2 :    }</span></a>
<a name="3851"><span class="lineNum">    3851 </span>            : #if 0</a>
<a name="3852"><span class="lineNum">    3852 </span>            : // DQ (3/2/2014): Added a new interface function (used in the snippet insertion support).</a>
<a name="3853"><span class="lineNum">    3853 </span>            : void</a>
<a name="3854"><span class="lineNum">    3854 </span>            : SageInterface::supportForInitializedNameLists ( SgScopeStatement* scope, SgInitializedNamePtrList &amp; variableList )</a>
<a name="3855"><span class="lineNum">    3855 </span>            :    {</a>
<a name="3856"><span class="lineNum">    3856 </span>            :      SgSymbolTable* symbolTable = scope-&gt;get_symbol_table();</a>
<a name="3857"><span class="lineNum">    3857 </span>            :      ROSE_ASSERT(symbolTable != NULL);</a>
<a name="3858"><span class="lineNum">    3858 </span>            : </a>
<a name="3859"><span class="lineNum">    3859 </span>            :      supportForVariableLists(scope,symbolTable,variableList);</a>
<a name="3860"><span class="lineNum">    3860 </span>            :    }</a>
<a name="3861"><span class="lineNum">    3861 </span>            : #endif</a>
<a name="3862"><span class="lineNum">    3862 </span>            : </a>
<a name="3863"><span class="lineNum">    3863 </span>            : void</a>
<a name="3864"><span class="lineNum">    3864 </span><span class="lineNoCov">          0 : supportForVariableDeclarations ( SgScopeStatement* scope, SgSymbolTable* symbolTable, SgVariableDeclaration* variableDeclaration )</span></a>
<a name="3865"><span class="lineNum">    3865 </span>            :    {</a>
<a name="3866"><span class="lineNum">    3866 </span>            :   // DQ (10/24/2007): Added supporting function to refactor code.</a>
<a name="3867"><span class="lineNum">    3867 </span><span class="lineNoCov">          0 :      SgInitializedNamePtrList &amp; variableList = variableDeclaration-&gt;get_variables();</span></a>
<a name="3868"><span class="lineNum">    3868 </span>            : #if 1</a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineNoCov">          0 :      supportForVariableLists(scope,symbolTable,variableList);</span></a>
<a name="3870"><span class="lineNum">    3870 </span>            : #else</a>
<a name="3871"><span class="lineNum">    3871 </span>            :      SgInitializedNamePtrList::iterator i = variableList.begin();</a>
<a name="3872"><span class="lineNum">    3872 </span>            :      while ( i != variableList.end() )</a>
<a name="3873"><span class="lineNum">    3873 </span>            :         {</a>
<a name="3874"><span class="lineNum">    3874 </span>            :           SgInitializedName* variable = *i;</a>
<a name="3875"><span class="lineNum">    3875 </span>            :           ROSE_ASSERT(variable != NULL);</a>
<a name="3876"><span class="lineNum">    3876 </span>            : </a>
<a name="3877"><span class="lineNum">    3877 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="3878"><span class="lineNum">    3878 </span>            : </a>
<a name="3879"><span class="lineNum">    3879 </span>            :        // DQ (10/20/2007): static data members declared outside the class scope don't generate symbols.</a>
<a name="3880"><span class="lineNum">    3880 </span>            :        // if (variable-&gt;get_prev_decl_item() != NULL)</a>
<a name="3881"><span class="lineNum">    3881 </span>            :           if (variable-&gt;get_scope() == scope)</a>
<a name="3882"><span class="lineNum">    3882 </span>            :              {</a>
<a name="3883"><span class="lineNum">    3883 </span>            :                SgSymbol* symbol = new SgVariableSymbol(variable);</a>
<a name="3884"><span class="lineNum">    3884 </span>            :                ROSE_ASSERT(symbol != NULL);</a>
<a name="3885"><span class="lineNum">    3885 </span>            : </a>
<a name="3886"><span class="lineNum">    3886 </span>            :             // printf (&quot;In SageInterface::rebuildSymbolTable() variable = %p building a new SgVariableSymbol = %p \n&quot;,variable,symbol);</a>
<a name="3887"><span class="lineNum">    3887 </span>            : </a>
<a name="3888"><span class="lineNum">    3888 </span>            :                SgName name = variable-&gt;get_name();</a>
<a name="3889"><span class="lineNum">    3889 </span>            :                symbolTable-&gt;insert(name,symbol);</a>
<a name="3890"><span class="lineNum">    3890 </span>            :              }</a>
<a name="3891"><span class="lineNum">    3891 </span>            :             else</a>
<a name="3892"><span class="lineNum">    3892 </span>            :              {</a>
<a name="3893"><span class="lineNum">    3893 </span>            :             // I think there is nothing to do in this case</a>
<a name="3894"><span class="lineNum">    3894 </span>            :             // printf (&quot;In SageInterface::rebuildSymbolTable() This variable has a scope inconsistant with the symbol table: variable-&gt;get_scope() = %p scope = %p \n&quot;,variable-&gt;get_scope(),scope);</a>
<a name="3895"><span class="lineNum">    3895 </span>            :              }</a>
<a name="3896"><span class="lineNum">    3896 </span>            : </a>
<a name="3897"><span class="lineNum">    3897 </span>            : #error &quot;DEAD CODE&quot;</a>
<a name="3898"><span class="lineNum">    3898 </span>            : </a>
<a name="3899"><span class="lineNum">    3899 </span>            :           i++;</a>
<a name="3900"><span class="lineNum">    3900 </span>            :         }</a>
<a name="3901"><span class="lineNum">    3901 </span>            : #endif</a>
<a name="3902"><span class="lineNum">    3902 </span>            : </a>
<a name="3903"><span class="lineNum">    3903 </span>            :   // DQ (10/13/2007): Need to look into variable declarations to see if there are defining declaration</a>
<a name="3904"><span class="lineNum">    3904 </span>            :   // that also force symbols to be built in the current scope!</a>
<a name="3905"><span class="lineNum">    3905 </span>            :   // ROSE_ASSERT(derivedDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == false);</a>
<a name="3906"><span class="lineNum">    3906 </span><span class="lineNoCov">          0 :      if (variableDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)</span></a>
<a name="3907"><span class="lineNum">    3907 </span>            :         {</a>
<a name="3908"><span class="lineNum">    3908 </span>            :        // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.</a>
<a name="3909"><span class="lineNum">    3909 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="3910"><span class="lineNum">    3910 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(variableDeclaration-&gt;get_baseTypeDefiningDeclaration() != NULL);</span></a>
<a name="3911"><span class="lineNum">    3911 </span><span class="lineNoCov">          0 :           supportForBaseTypeDefiningDeclaration ( symbolTable, variableDeclaration-&gt;get_baseTypeDefiningDeclaration() );</span></a>
<a name="3912"><span class="lineNum">    3912 </span>            :         }</a>
<a name="3913"><span class="lineNum">    3913 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="3914"><span class="lineNum">    3914 </span>            : </a>
<a name="3915"><span class="lineNum">    3915 </span>            : void</a>
<a name="3916"><span class="lineNum">    3916 </span><span class="lineCov">          2 : supportForLabelStatements ( SgScopeStatement* scope, SgSymbolTable* symbolTable )</span></a>
<a name="3917"><span class="lineNum">    3917 </span>            :    {</a>
<a name="3918"><span class="lineNum">    3918 </span>            :   // Update the symbol table in SgFunctionDefinition with all the labels in the function.</a>
<a name="3919"><span class="lineNum">    3919 </span>            : </a>
<a name="3920"><span class="lineNum">    3920 </span><span class="lineCov">          2 :      std::vector&lt;SgNode*&gt; labelList = NodeQuery::querySubTree (scope,V_SgLabelStatement);</span></a>
<a name="3921"><span class="lineNum">    3921 </span>            : </a>
<a name="3922"><span class="lineNum">    3922 </span><span class="lineCov">          2 :      int numberOfLabels = labelList.size();</span></a>
<a name="3923"><span class="lineNum">    3923 </span><span class="lineCov">          2 :      for (int i=0; i &lt; numberOfLabels; i++)</span></a>
<a name="3924"><span class="lineNum">    3924 </span>            :         {</a>
<a name="3925"><span class="lineNum">    3925 </span><span class="lineNoCov">          0 :           SgLabelStatement* labelStatement = isSgLabelStatement(labelList[i]);</span></a>
<a name="3926"><span class="lineNum">    3926 </span>            : </a>
<a name="3927"><span class="lineNum">    3927 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(labelStatement != NULL);</span></a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(labelStatement-&gt;get_scope() == scope);</span></a>
<a name="3929"><span class="lineNum">    3929 </span>            : </a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineNoCov">          0 :           SgSymbol* symbol = new SgLabelSymbol(labelStatement);</span></a>
<a name="3931"><span class="lineNum">    3931 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbol != NULL);</span></a>
<a name="3932"><span class="lineNum">    3932 </span>            : </a>
<a name="3933"><span class="lineNum">    3933 </span>            :        // printf (&quot;In SageInterface::rebuildSymbolTable() labelStatement = %p building a new SgLabelSymbol = %p \n&quot;,labelStatement,symbol);</a>
<a name="3934"><span class="lineNum">    3934 </span>            : </a>
<a name="3935"><span class="lineNum">    3935 </span><span class="lineNoCov">          0 :           SgName name = labelStatement-&gt;get_name();</span></a>
<a name="3936"><span class="lineNum">    3936 </span><span class="lineNoCov">          0 :           symbolTable-&gt;insert(name,symbol);</span></a>
<a name="3937"><span class="lineNum">    3937 </span>            :         }</a>
<a name="3938"><span class="lineNum">    3938 </span><span class="lineCov">          2 :    }</span></a>
<a name="3939"><span class="lineNum">    3939 </span>            : </a>
<a name="3940"><span class="lineNum">    3940 </span>            : </a>
<a name="3941"><span class="lineNum">    3941 </span>            : void</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineCov">         19 : SageInterface::rebuildSymbolTable ( SgScopeStatement* scope )</span></a>
<a name="3943"><span class="lineNum">    3943 </span>            :    {</a>
<a name="3944"><span class="lineNum">    3944 </span>            :   // This function is called from the implementation of the copy member functions.</a>
<a name="3945"><span class="lineNum">    3945 </span>            : </a>
<a name="3946"><span class="lineNum">    3946 </span><span class="lineCov">         19 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="3947"><span class="lineNum">    3947 </span>            : #if 0</a>
<a name="3948"><span class="lineNum">    3948 </span>            :      printf (&quot;In SageInterface::rebuildSymbolTable(): Symbol Table from %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="3949"><span class="lineNum">    3949 </span>            : #endif</a>
<a name="3950"><span class="lineNum">    3950 </span>            : #if 0</a>
<a name="3951"><span class="lineNum">    3951 </span>            :      printf (&quot;Exiting as a test \n&quot;);</a>
<a name="3952"><span class="lineNum">    3952 </span>            :      ROSE_ABORT();</a>
<a name="3953"><span class="lineNum">    3953 </span>            : #endif</a>
<a name="3954"><span class="lineNum">    3954 </span>            : </a>
<a name="3955"><span class="lineNum">    3955 </span><span class="lineCov">         19 :      SgSymbolTable* symbolTable = scope-&gt;get_symbol_table();</span></a>
<a name="3956"><span class="lineNum">    3956 </span>            : </a>
<a name="3957"><span class="lineNum">    3957 </span><span class="lineCov">         19 :      if (symbolTable != NULL)</span></a>
<a name="3958"><span class="lineNum">    3958 </span>            :         {</a>
<a name="3959"><span class="lineNum">    3959 </span>            :        // This must be an empty symbol table!</a>
<a name="3960"><span class="lineNum">    3960 </span><span class="lineCov">         19 :           if (symbolTable-&gt;size() != 0)</span></a>
<a name="3961"><span class="lineNum">    3961 </span>            :              {</a>
<a name="3962"><span class="lineNum">    3962 </span><span class="lineNoCov">          0 :                printf (&quot;symbolTable-&gt;size() = %d \n&quot;,symbolTable-&gt;size());</span></a>
<a name="3963"><span class="lineNum">    3963 </span>            :              }</a>
<a name="3964"><span class="lineNum">    3964 </span><span class="lineCov">         19 :           ROSE_ASSERT(symbolTable-&gt;size() == 0);</span></a>
<a name="3965"><span class="lineNum">    3965 </span>            : #if 0</a>
<a name="3966"><span class="lineNum">    3966 </span>            :           printf (&quot;Symbol Table from %p = %s of size = %&quot; PRIuPTR &quot; \n&quot;,scope,scope-&gt;class_name().c_str(),symbolTable-&gt;size());</a>
<a name="3967"><span class="lineNum">    3967 </span>            :           symbolTable-&gt;print(&quot;Called from SageInterface::rebuildSymbolTable()&quot;);</a>
<a name="3968"><span class="lineNum">    3968 </span>            : #endif</a>
<a name="3969"><span class="lineNum">    3969 </span>            :         }</a>
<a name="3970"><span class="lineNum">    3970 </span>            :        else</a>
<a name="3971"><span class="lineNum">    3971 </span>            :         {</a>
<a name="3972"><span class="lineNum">    3972 </span>            : #if 0</a>
<a name="3973"><span class="lineNum">    3973 </span>            :           printf (&quot;In SageInterface::rebuildSymbolTable(): No symbol table found \n&quot;);</a>
<a name="3974"><span class="lineNum">    3974 </span>            : #endif</a>
<a name="3975"><span class="lineNum">    3975 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbolTable == NULL);</span></a>
<a name="3976"><span class="lineNum">    3976 </span>            : </a>
<a name="3977"><span class="lineNum">    3977 </span>            :        // DQ (10/8/2007): Build a new symbol table if there was not already one built.</a>
<a name="3978"><span class="lineNum">    3978 </span><span class="lineNoCov">          0 :           symbolTable = new SgSymbolTable();</span></a>
<a name="3979"><span class="lineNum">    3979 </span>            : </a>
<a name="3980"><span class="lineNum">    3980 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="3981"><span class="lineNum">    3981 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbolTable-&gt;get_table() != NULL);</span></a>
<a name="3982"><span class="lineNum">    3982 </span>            : </a>
<a name="3983"><span class="lineNum">    3983 </span>            :        // DQ (2/16/2006): Set this parent directly (now tested)</a>
<a name="3984"><span class="lineNum">    3984 </span><span class="lineNoCov">          0 :           symbolTable-&gt;set_parent(scope);</span></a>
<a name="3985"><span class="lineNum">    3985 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(symbolTable-&gt;get_parent() != NULL);</span></a>
<a name="3986"><span class="lineNum">    3986 </span>            : </a>
<a name="3987"><span class="lineNum">    3987 </span><span class="lineNoCov">          0 :           scope-&gt;set_symbol_table(symbolTable);</span></a>
<a name="3988"><span class="lineNum">    3988 </span>            :         }</a>
<a name="3989"><span class="lineNum">    3989 </span>            : </a>
<a name="3990"><span class="lineNum">    3990 </span>            :   // DQ (10/8/2007): If there is already a symbol table then don't over write it. This fixes copies generated with more than one symbol table.</a>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineCov">         19 :      ROSE_ASSERT(scope-&gt;get_symbol_table() != NULL);</span></a>
<a name="3992"><span class="lineNum">    3992 </span><span class="lineCov">         19 :      ROSE_ASSERT(scope-&gt;get_symbol_table()-&gt;get_table() != NULL);</span></a>
<a name="3993"><span class="lineNum">    3993 </span>            : </a>
<a name="3994"><span class="lineNum">    3994 </span>            :   // This implements SgScopeStatement specific details (e.g function declarations have parameters and their declaration causes variable</a>
<a name="3995"><span class="lineNum">    3995 </span>            :   // symbols to be placed into the SgFunctionDefinition scope (but only for defining declarations).</a>
<a name="3996"><span class="lineNum">    3996 </span><span class="lineCov">         19 :      switch(scope-&gt;variantT())</span></a>
<a name="3997"><span class="lineNum">    3997 </span>            :         {</a>
<a name="3998"><span class="lineNum">    3998 </span><span class="lineCov">          2 :           case V_SgForStatement:</span></a>
<a name="3999"><span class="lineNum">    3999 </span><span class="lineCov">          2 :              {</span></a>
<a name="4000"><span class="lineNum">    4000 </span>            :             // These scopes have their symbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).</a>
<a name="4001"><span class="lineNum">    4001 </span>            :             // printf (&quot;Symbol tables could contain symbols outside of the inclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4002"><span class="lineNum">    4002 </span>            : </a>
<a name="4003"><span class="lineNum">    4003 </span><span class="lineCov">          2 :                SgForStatement* forStatement = isSgForStatement(scope);</span></a>
<a name="4004"><span class="lineNum">    4004 </span>            : </a>
<a name="4005"><span class="lineNum">    4005 </span><span class="lineCov">          2 :                SgStatementPtrList::iterator i = forStatement-&gt;get_init_stmt().begin();</span></a>
<a name="4006"><span class="lineNum">    4006 </span>            : </a>
<a name="4007"><span class="lineNum">    4007 </span>            :             // printf (&quot;i != forStatement-&gt;get_init_stmt().end() = %s \n&quot;,i != forStatement-&gt;get_init_stmt().end() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4008"><span class="lineNum">    4008 </span>            : </a>
<a name="4009"><span class="lineNum">    4009 </span><span class="lineCov">          4 :                while (i != forStatement-&gt;get_init_stmt().end())</span></a>
<a name="4010"><span class="lineNum">    4010 </span>            :                   {</a>
<a name="4011"><span class="lineNum">    4011 </span>            :                  // printf (&quot;For statement initialization list: *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="4012"><span class="lineNum">    4012 </span><span class="lineCov">          2 :                     SgVariableDeclaration* variableDeclarationInitializer = isSgVariableDeclaration(*i);</span></a>
<a name="4013"><span class="lineNum">    4013 </span><span class="lineCov">          2 :                     if (variableDeclarationInitializer != NULL)</span></a>
<a name="4014"><span class="lineNum">    4014 </span>            :                        {</a>
<a name="4015"><span class="lineNum">    4015 </span>            :                       // There is a variable declaration in the conditional, it needs to be added to the symbol table.</a>
<a name="4016"><span class="lineNum">    4016 </span>            :                       // printf (&quot;There is a variable declaration in the for statement initializer, it needs to be added to the symbol table scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4017"><span class="lineNum">    4017 </span>            :                       // ROSE_ASSERT(false);</a>
<a name="4018"><span class="lineNum">    4018 </span><span class="lineNoCov">          0 :                          supportForVariableDeclarations ( scope, symbolTable, variableDeclarationInitializer );</span></a>
<a name="4019"><span class="lineNum">    4019 </span>            :                        }</a>
<a name="4020"><span class="lineNum">    4020 </span>            : </a>
<a name="4021"><span class="lineNum">    4021 </span><span class="lineCov">          2 :                     i++;</span></a>
<a name="4022"><span class="lineNum">    4022 </span>            :                   }</a>
<a name="4023"><span class="lineNum">    4023 </span>            : </a>
<a name="4024"><span class="lineNum">    4024 </span><span class="lineCov">          2 :                SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(forStatement-&gt;get_test());</span></a>
<a name="4025"><span class="lineNum">    4025 </span><span class="lineCov">          2 :                if (variableDeclarationCondition != NULL)</span></a>
<a name="4026"><span class="lineNum">    4026 </span>            :                   {</a>
<a name="4027"><span class="lineNum">    4027 </span>            :                  // There is a variable declaration in the conditional, it needs to be added to the symbol table.</a>
<a name="4028"><span class="lineNum">    4028 </span>            :                  // printf (&quot;There is a variable declaration in the for statement test, it needs to be added to the symbol table scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4029"><span class="lineNum">    4029 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="4030"><span class="lineNum">    4030 </span><span class="lineNoCov">          0 :                     supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );</span></a>
<a name="4031"><span class="lineNum">    4031 </span>            :                   }</a>
<a name="4032"><span class="lineNum">    4032 </span>            : </a>
<a name="4033"><span class="lineNum">    4033 </span>            :                return;</a>
<a name="4034"><span class="lineNum">    4034 </span>            :                break;</a>
<a name="4035"><span class="lineNum">    4035 </span>            :              }</a>
<a name="4036"><span class="lineNum">    4036 </span>            : </a>
<a name="4037"><span class="lineNum">    4037 </span>            :        // DQ (12/23/2012): Added support for templates.</a>
<a name="4038"><span class="lineNum">    4038 </span><span class="lineCov">          2 :           case V_SgTemplateFunctionDefinition:</span></a>
<a name="4039"><span class="lineNum">    4039 </span>            : </a>
<a name="4040"><span class="lineNum">    4040 </span><span class="lineCov">          2 :           case V_SgFunctionDefinition:</span></a>
<a name="4041"><span class="lineNum">    4041 </span><span class="lineCov">          2 :              {</span></a>
<a name="4042"><span class="lineNum">    4042 </span>            :             // These scopes have their symbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).</a>
<a name="4043"><span class="lineNum">    4043 </span>            :             // printf (&quot;Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4044"><span class="lineNum">    4044 </span>            : </a>
<a name="4045"><span class="lineNum">    4045 </span>            :             // DQ (10/8/2007): If this is a SgFunctionDefinition, then include the parameters in the SgFunctionDeclaration.</a>
<a name="4046"><span class="lineNum">    4046 </span><span class="lineCov">          2 :                SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(scope);</span></a>
<a name="4047"><span class="lineNum">    4047 </span><span class="lineCov">          2 :                if (functionDefinition != NULL)</span></a>
<a name="4048"><span class="lineNum">    4048 </span>            :                   {</a>
<a name="4049"><span class="lineNum">    4049 </span><span class="lineCov">          2 :                     SgFunctionDeclaration* functionDeclaration = functionDefinition-&gt;get_declaration();</span></a>
<a name="4050"><span class="lineNum">    4050 </span>            :                  // printf (&quot;In SageInterface::rebuildSymbolTable(): functionDefinition = %p functionDeclaration = %p \n&quot;,functionDefinition,functionDeclaration);</a>
<a name="4051"><span class="lineNum">    4051 </span>            : </a>
<a name="4052"><span class="lineNum">    4052 </span>            :                  // DQ (10/8/2007): It turns out that this is always NULL, because the parent of the functionDeclaration has not yet been set in the copy mechanism!</a>
<a name="4053"><span class="lineNum">    4053 </span><span class="lineCov">          2 :                     if (functionDeclaration != NULL)</span></a>
<a name="4054"><span class="lineNum">    4054 </span>            :                        {</a>
<a name="4055"><span class="lineNum">    4055 </span>            :                       // DQ (3/28/2014): After a call with Philippe, this Java specific issues is fixed and we don't seem to see this problem any more.</a>
<a name="4056"><span class="lineNum">    4056 </span><span class="lineCov">          2 :                          if (functionDeclaration-&gt;isForward() == true)</span></a>
<a name="4057"><span class="lineNum">    4057 </span>            :                             {</a>
<a name="4058"><span class="lineNum">    4058 </span><span class="lineNoCov">          0 :                               printf (&quot;ERROR: functionDeclaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</span></a>
<a name="4059"><span class="lineNum">    4059 </span><span class="lineNoCov">          0 :                               printf (&quot;   --- functionDeclaration (get_name())   = %s \n&quot;,get_name(functionDeclaration).c_str());</span></a>
<a name="4060"><span class="lineNum">    4060 </span><span class="lineNoCov">          0 :                               printf (&quot;   --- functionDeclaration (mangled name) = %s \n&quot;,functionDeclaration-&gt;get_mangled_name().str());</span></a>
<a name="4061"><span class="lineNum">    4061 </span><span class="lineNoCov">          0 :                               SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="4062"><span class="lineNum">    4062 </span><span class="lineNoCov">          0 :                               if (memberFunctionDeclaration != NULL)</span></a>
<a name="4063"><span class="lineNum">    4063 </span>            :                                  {</a>
<a name="4064"><span class="lineNum">    4064 </span><span class="lineNoCov">          0 :                                    printf (&quot;memberFunctionDeclaration != NULL \n&quot;);</span></a>
<a name="4065"><span class="lineNum">    4065 </span>            :                                  }</a>
<a name="4066"><span class="lineNum">    4066 </span>            :                             }</a>
<a name="4067"><span class="lineNum">    4067 </span><span class="lineCov">          2 :                          ROSE_ASSERT(functionDeclaration-&gt;isForward() == false);</span></a>
<a name="4068"><span class="lineNum">    4068 </span><span class="lineCov">          2 :                          SgInitializedNamePtrList &amp; argumentList = functionDeclaration-&gt;get_args();</span></a>
<a name="4069"><span class="lineNum">    4069 </span><span class="lineCov">          2 :                          supportForVariableLists(scope,symbolTable,argumentList);</span></a>
<a name="4070"><span class="lineNum">    4070 </span>            :                        }</a>
<a name="4071"><span class="lineNum">    4071 </span>            :                       else</a>
<a name="4072"><span class="lineNum">    4072 </span>            :                        {</a>
<a name="4073"><span class="lineNum">    4073 </span>            :                       // This happens in the copy function because the function definition is copied from the SgFunctionDeclaration</a>
<a name="4074"><span class="lineNum">    4074 </span>            :                       // and only after the copy is made is the parent of the definition set to be the function declaration.  Thus</a>
<a name="4075"><span class="lineNum">    4075 </span>            :                       // the get_declaration() member function returns NULL.</a>
<a name="4076"><span class="lineNum">    4076 </span>            :                       // printf (&quot;There is no function declaration associated with this function definition! \n&quot;);</a>
<a name="4077"><span class="lineNum">    4077 </span>            :                       // ROSE_ASSERT(functionDeclaration-&gt;isForward() == true);</a>
<a name="4078"><span class="lineNum">    4078 </span>            :                        }</a>
<a name="4079"><span class="lineNum">    4079 </span>            :                   }</a>
<a name="4080"><span class="lineNum">    4080 </span>            : </a>
<a name="4081"><span class="lineNum">    4081 </span>            :             // DQ (10/25/2007): Label symbols are now places into the SgFunctionDefinition (they have to be collected from the function).</a>
<a name="4082"><span class="lineNum">    4082 </span><span class="lineCov">          2 :                supportForLabelStatements(scope,symbolTable);</span></a>
<a name="4083"><span class="lineNum">    4083 </span>            : </a>
<a name="4084"><span class="lineNum">    4084 </span>            :                return;</a>
<a name="4085"><span class="lineNum">    4085 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4086"><span class="lineNum">    4086 </span>            :              }</a>
<a name="4087"><span class="lineNum">    4087 </span>            : </a>
<a name="4088"><span class="lineNum">    4088 </span><span class="lineNoCov">          0 :           case V_SgIfStmt:</span></a>
<a name="4089"><span class="lineNum">    4089 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4090"><span class="lineNum">    4090 </span>            :             // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).</a>
<a name="4091"><span class="lineNum">    4091 </span>            :             // printf (&quot;Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4092"><span class="lineNum">    4092 </span>            : </a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineNoCov">          0 :                SgIfStmt* ifStatement = isSgIfStmt(scope);</span></a>
<a name="4094"><span class="lineNum">    4094 </span><span class="lineNoCov">          0 :                SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(ifStatement-&gt;get_conditional());</span></a>
<a name="4095"><span class="lineNum">    4095 </span><span class="lineNoCov">          0 :                if (variableDeclarationCondition != NULL)</span></a>
<a name="4096"><span class="lineNum">    4096 </span>            :                   {</a>
<a name="4097"><span class="lineNum">    4097 </span>            :                  // There is a variable declaration in the conditional, it needs to be added to the symbol table.</a>
<a name="4098"><span class="lineNum">    4098 </span>            :                  // printf (&quot;There is a variable declaration in the conditional, it needs to be added to the symbol table \n&quot;);</a>
<a name="4099"><span class="lineNum">    4099 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="4100"><span class="lineNum">    4100 </span><span class="lineNoCov">          0 :                     supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );</span></a>
<a name="4101"><span class="lineNum">    4101 </span>            :                   }</a>
<a name="4102"><span class="lineNum">    4102 </span>            :                return;</a>
<a name="4103"><span class="lineNum">    4103 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4104"><span class="lineNum">    4104 </span>            :              }</a>
<a name="4105"><span class="lineNum">    4105 </span>            : </a>
<a name="4106"><span class="lineNum">    4106 </span><span class="lineNoCov">          0 :           case V_SgSwitchStatement:</span></a>
<a name="4107"><span class="lineNum">    4107 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4108"><span class="lineNum">    4108 </span>            :             // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).</a>
<a name="4109"><span class="lineNum">    4109 </span>            :             // printf (&quot;Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4110"><span class="lineNum">    4110 </span>            : </a>
<a name="4111"><span class="lineNum">    4111 </span><span class="lineNoCov">          0 :                SgSwitchStatement* switchStatement = isSgSwitchStatement(scope);</span></a>
<a name="4112"><span class="lineNum">    4112 </span><span class="lineNoCov">          0 :                SgVariableDeclaration* variableDeclarationSelector = isSgVariableDeclaration(switchStatement-&gt;get_item_selector());</span></a>
<a name="4113"><span class="lineNum">    4113 </span><span class="lineNoCov">          0 :                if (variableDeclarationSelector != NULL)</span></a>
<a name="4114"><span class="lineNum">    4114 </span>            :                   {</a>
<a name="4115"><span class="lineNum">    4115 </span>            :                  // There is a variable declaration in the conditional, it needs to be added to the symbol table.</a>
<a name="4116"><span class="lineNum">    4116 </span>            :                  // printf (&quot;There is a variable declaration in the item selector of the switch statement, it needs to be added to the symbol table \n&quot;);</a>
<a name="4117"><span class="lineNum">    4117 </span>            : </a>
<a name="4118"><span class="lineNum">    4118 </span><span class="lineNoCov">          0 :                     supportForVariableDeclarations ( scope, symbolTable, variableDeclarationSelector );</span></a>
<a name="4119"><span class="lineNum">    4119 </span>            :                   }</a>
<a name="4120"><span class="lineNum">    4120 </span>            :                return;</a>
<a name="4121"><span class="lineNum">    4121 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4122"><span class="lineNum">    4122 </span>            :              }</a>
<a name="4123"><span class="lineNum">    4123 </span>            : </a>
<a name="4124"><span class="lineNum">    4124 </span><span class="lineNoCov">          0 :           case V_SgWhileStmt:</span></a>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4126"><span class="lineNum">    4126 </span>            :             // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).</a>
<a name="4127"><span class="lineNum">    4127 </span>            :             // commented out like for others, otherwise show up each time a While is being copied. Liao, 1/31/2008</a>
<a name="4128"><span class="lineNum">    4128 </span>            :             // printf (&quot;Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4129"><span class="lineNum">    4129 </span>            : </a>
<a name="4130"><span class="lineNum">    4130 </span><span class="lineNoCov">          0 :                SgWhileStmt* whileStatement = isSgWhileStmt(scope);</span></a>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineNoCov">          0 :                SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(whileStatement-&gt;get_condition());</span></a>
<a name="4132"><span class="lineNum">    4132 </span><span class="lineNoCov">          0 :                if (variableDeclarationCondition != NULL)</span></a>
<a name="4133"><span class="lineNum">    4133 </span>            :                   {</a>
<a name="4134"><span class="lineNum">    4134 </span>            :                  // There is a variable declaration in the conditional, it needs to be added to the symbol table.</a>
<a name="4135"><span class="lineNum">    4135 </span>            :                  // printf (&quot;There is a variable declaration in the while statement condition, it needs to be added to the symbol table \n&quot;);</a>
<a name="4136"><span class="lineNum">    4136 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="4137"><span class="lineNum">    4137 </span>            : </a>
<a name="4138"><span class="lineNum">    4138 </span><span class="lineNoCov">          0 :                     supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );</span></a>
<a name="4139"><span class="lineNum">    4139 </span>            :                   }</a>
<a name="4140"><span class="lineNum">    4140 </span>            :                return;</a>
<a name="4141"><span class="lineNum">    4141 </span>            :                break;</a>
<a name="4142"><span class="lineNum">    4142 </span>            :              }</a>
<a name="4143"><span class="lineNum">    4143 </span>            : </a>
<a name="4144"><span class="lineNum">    4144 </span>            :           case V_SgCatchOptionStmt:</a>
<a name="4145"><span class="lineNum">    4145 </span>            :           case V_SgDoWhileStmt:</a>
<a name="4146"><span class="lineNum">    4146 </span>            :              {</a>
<a name="4147"><span class="lineNum">    4147 </span>            :             // These scopes contain a SgBasicBlock as a data member and the scope is held there.</a>
<a name="4148"><span class="lineNum">    4148 </span>            :             // printf (&quot;Symbol tables can must be computed by the enclosed body scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4149"><span class="lineNum">    4149 </span>            :                return;</a>
<a name="4150"><span class="lineNum">    4150 </span><span class="lineCov">         15 :                break;</span></a>
<a name="4151"><span class="lineNum">    4151 </span>            :              }</a>
<a name="4152"><span class="lineNum">    4152 </span>            : </a>
<a name="4153"><span class="lineNum">    4153 </span>            :        // DQ (12/24/2012): Added support for templates.</a>
<a name="4154"><span class="lineNum">    4154 </span><span class="lineCov">         15 :           case V_SgTemplateClassDefinition:</span></a>
<a name="4155"><span class="lineNum">    4155 </span>            : </a>
<a name="4156"><span class="lineNum">    4156 </span><span class="lineCov">         15 :           case V_SgBasicBlock:</span></a>
<a name="4157"><span class="lineNum">    4157 </span><span class="lineCov">         15 :           case V_SgClassDefinition:</span></a>
<a name="4158"><span class="lineNum">    4158 </span><span class="lineCov">         15 :           case V_SgTemplateInstantiationDefn:</span></a>
<a name="4159"><span class="lineNum">    4159 </span><span class="lineCov">         15 :           case V_SgGlobal:</span></a>
<a name="4160"><span class="lineNum">    4160 </span><span class="lineCov">         15 :           case V_SgNamespaceDefinitionStatement:</span></a>
<a name="4161"><span class="lineNum">    4161 </span><span class="lineCov">         15 :           case V_SgFortranDo: // Liao 12/19/2008, My understanding is that Fortran do loop header does not introduce new symbols like  a C/C++ for loop does</span></a>
<a name="4162"><span class="lineNum">    4162 </span><span class="lineCov">         15 :              {</span></a>
<a name="4163"><span class="lineNum">    4163 </span>            :             // printf (&quot;Used the list of statements/declarations that are held deirectly by this scope \n&quot;);</a>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineCov">         15 :                break;</span></a>
<a name="4165"><span class="lineNum">    4165 </span>            :              }</a>
<a name="4166"><span class="lineNum">    4166 </span>            : </a>
<a name="4167"><span class="lineNum">    4167 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="4168"><span class="lineNum">    4168 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4169"><span class="lineNum">    4169 </span><span class="lineNoCov">          0 :                printf (&quot;Default reached in SageInterface::rebuildSymbolTable() scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="4170"><span class="lineNum">    4170 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4171"><span class="lineNum">    4171 </span>            :              }</a>
<a name="4172"><span class="lineNum">    4172 </span>            :         }</a>
<a name="4173"><span class="lineNum">    4173 </span>            : </a>
<a name="4174"><span class="lineNum">    4174 </span>            : #if 0</a>
<a name="4175"><span class="lineNum">    4175 </span>            :      printf (&quot;In SageInterface::rebuildSymbolTable(): fixup declarations in Symbol Table from %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4176"><span class="lineNum">    4176 </span>            : #endif</a>
<a name="4177"><span class="lineNum">    4177 </span>            : </a>
<a name="4178"><span class="lineNum">    4178 </span>            :   // Generate a copy of the statement list (this is simpler than handling the cases of a</a>
<a name="4179"><span class="lineNum">    4179 </span>            :   // declaration list and a statement list separately for the scopes that contain one or the other.</a>
<a name="4180"><span class="lineNum">    4180 </span><span class="lineCov">         30 :      SgStatementPtrList statementList = scope-&gt;generateStatementList();</span></a>
<a name="4181"><span class="lineNum">    4181 </span>            : </a>
<a name="4182"><span class="lineNum">    4182 </span>            :   // Loop through the statements and for each declaration build a symbol and add it to the symbol table</a>
<a name="4183"><span class="lineNum">    4183 </span><span class="lineCov">         48 :      for (SgStatementPtrList::iterator i = statementList.begin(); i != statementList.end(); i++)</span></a>
<a name="4184"><span class="lineNum">    4184 </span>            :         {</a>
<a name="4185"><span class="lineNum">    4185 </span>            :        // At some point we should move this mechanism in to a factory patterns for SgSymbol</a>
<a name="4186"><span class="lineNum">    4186 </span>            : </a>
<a name="4187"><span class="lineNum">    4187 </span>            :        // printf (&quot;Iterating through the declaration in this scope ... %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</a>
<a name="4188"><span class="lineNum">    4188 </span>            : </a>
<a name="4189"><span class="lineNum">    4189 </span><span class="lineCov">         33 :           SgDeclarationStatement* declaration = isSgDeclarationStatement(*i);</span></a>
<a name="4190"><span class="lineNum">    4190 </span><span class="lineCov">         33 :           if (declaration != NULL)</span></a>
<a name="4191"><span class="lineNum">    4191 </span>            :              {</a>
<a name="4192"><span class="lineNum">    4192 </span>            :             // DQ (11/7/2007): Where there can be multiple declaration (e.g. function declarations with prototypes) only use one of them.</a>
<a name="4193"><span class="lineNum">    4193 </span><span class="lineCov">         18 :                bool useThisDeclaration = (declaration-&gt;get_firstNondefiningDeclaration() == declaration) ||</span></a>
<a name="4194"><span class="lineNum">    4194 </span><span class="lineNoCov">          0 :                                          ( (declaration-&gt;get_firstNondefiningDeclaration() == NULL) &amp;&amp; (declaration-&gt;get_definingDeclaration() == declaration) );</span></a>
<a name="4195"><span class="lineNum">    4195 </span>            : </a>
<a name="4196"><span class="lineNum">    4196 </span><span class="lineCov">         36 :                list&lt;SgSymbol*&gt; symbolList;</span></a>
<a name="4197"><span class="lineNum">    4197 </span><span class="lineCov">         18 :                switch(declaration-&gt;variantT())</span></a>
<a name="4198"><span class="lineNum">    4198 </span>            :                   {</a>
<a name="4199"><span class="lineNum">    4199 </span><span class="lineNoCov">          0 :                     case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="4200"><span class="lineNum">    4200 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4201"><span class="lineNum">    4201 </span><span class="lineNoCov">          0 :                          SgTemplateInstantiationMemberFunctionDecl* derivedDeclaration = isSgTemplateInstantiationMemberFunctionDecl(declaration);</span></a>
<a name="4202"><span class="lineNum">    4202 </span>            :                       // DQ (11/6/2007): Don't build a symbol for the defining declaration defined in another scope and put the resulting symbol into the wrong scope</a>
<a name="4203"><span class="lineNum">    4203 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4204"><span class="lineNum">    4204 </span>            :                             {</a>
<a name="4205"><span class="lineNum">    4205 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);</span></a>
<a name="4206"><span class="lineNum">    4206 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4207"><span class="lineNum">    4207 </span>            : </a>
<a name="4208"><span class="lineNum">    4208 </span>            :                            // printf (&quot;In rebuildSymbolTable: symbol = %p = %s = %s \n&quot;,symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(symbol).c_str());</a>
<a name="4209"><span class="lineNum">    4209 </span>            : </a>
<a name="4210"><span class="lineNum">    4210 </span>            :                            // printf (&quot;SgTemplateInstantiationMemberFunctionDecl: scope = %p derivedDeclaration = %p = %s inserting a symbol = %p \n&quot;,scope,derivedDeclaration,get_name(derivedDeclaration).c_str(),symbol);</a>
<a name="4211"><span class="lineNum">    4211 </span>            : </a>
<a name="4212"><span class="lineNum">    4212 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4213"><span class="lineNum">    4213 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4214"><span class="lineNum">    4214 </span>            :                             }</a>
<a name="4215"><span class="lineNum">    4215 </span>            :                            else</a>
<a name="4216"><span class="lineNum">    4216 </span>            :                             {</a>
<a name="4217"><span class="lineNum">    4217 </span>            :                            // printf (&quot;SgTemplateInstantiationMemberFunctionDecl: scope = %p derivedDeclaration = %p = %s didn't match the scope \n&quot;,scope,derivedDeclaration,get_name(derivedDeclaration).c_str());</a>
<a name="4218"><span class="lineNum">    4218 </span>            : </a>
<a name="4219"><span class="lineNum">    4219 </span>            :                            // These IR nodes might only exist as a template declaration and thus not be structureally present in their scope.</a>
<a name="4220"><span class="lineNum">    4220 </span>            :                            // So we would never traverse them in the correct scope and so never build sysmbols for them and add the symbols</a>
<a name="4221"><span class="lineNum">    4221 </span>            :                            // to the correct symbol table.  This is a fundamental problem.  So we have to try to add these sorts of symbols</a>
<a name="4222"><span class="lineNum">    4222 </span>            :                            // to the scope were they belong.</a>
<a name="4223"><span class="lineNum">    4223 </span><span class="lineNoCov">          0 :                               SgScopeStatement* derivedDeclarationScope = derivedDeclaration-&gt;get_scope();</span></a>
<a name="4224"><span class="lineNum">    4224 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(derivedDeclarationScope != NULL);</span></a>
<a name="4225"><span class="lineNum">    4225 </span>            : </a>
<a name="4226"><span class="lineNum">    4226 </span>            :                            // If this is a copy then it would be nice to make sure that the scope has been properly set.</a>
<a name="4227"><span class="lineNum">    4227 </span>            :                            // Check this by looking for the associated template declaration in the scope.</a>
<a name="4228"><span class="lineNum">    4228 </span>            :                            // SgTemplateDeclaration* templateDeclaration = derivedDeclaration-&gt;get_templateDeclaration();</a>
<a name="4229"><span class="lineNum">    4229 </span>            :                            // SgDeclarationStatement* templateDeclaration = derivedDeclaration-&gt;get_templateDeclaration();</a>
<a name="4230"><span class="lineNum">    4230 </span><span class="lineNoCov">          0 :                               SgTemplateMemberFunctionDeclaration* templateDeclaration = derivedDeclaration-&gt;get_templateDeclaration();</span></a>
<a name="4231"><span class="lineNum">    4231 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(templateDeclaration != NULL);</span></a>
<a name="4232"><span class="lineNum">    4232 </span>            :                            // SgTemplateSymbol* templateSymbol = derivedDeclarationScope-&gt;lookup_template_symbol(templateDeclaration-&gt;get_name());</a>
<a name="4233"><span class="lineNum">    4233 </span>            : </a>
<a name="4234"><span class="lineNum">    4234 </span>            :                            // DQ (8/13/2013): Fixed the interface to avoid use of lookup_template_symbol() (removed).</a>
<a name="4235"><span class="lineNum">    4235 </span>            :                            // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="4236"><span class="lineNum">    4236 </span>            :                            // In this case these are unavailable from this point.</a>
<a name="4237"><span class="lineNum">    4237 </span>            :                            // SgTemplateSymbol* templateSymbol = derivedDeclarationScope-&gt;lookup_template_symbol(templateDeclaration-&gt;get_template_name());</a>
<a name="4238"><span class="lineNum">    4238 </span>            :                            // SgTemplateSymbol* templateSymbol = derivedDeclarationScope-&gt;lookup_template_symbol(templateDeclaration-&gt;get_template_name(),NULL,NULL);</a>
<a name="4239"><span class="lineNum">    4239 </span><span class="lineNoCov">          0 :                               SgType* functionType                               = templateDeclaration-&gt;get_type();</span></a>
<a name="4240"><span class="lineNum">    4240 </span><span class="lineNoCov">          0 :                               SgTemplateParameterPtrList &amp; templateParameterList = templateDeclaration-&gt;get_templateParameters();</span></a>
<a name="4241"><span class="lineNum">    4241 </span>            :                            // SgTemplateMemberFunctionSymbol* templateSymbol     = derivedDeclarationScope-&gt;lookup_template_symbol(templateDeclaration-&gt;get_template_name(),NULL,NULL);</a>
<a name="4242"><span class="lineNum">    4242 </span><span class="lineNoCov">          0 :                               SgTemplateMemberFunctionSymbol* templateSymbol     = derivedDeclarationScope-&gt;lookup_template_member_function_symbol(templateDeclaration-&gt;get_template_name(),functionType,&amp;templateParameterList);</span></a>
<a name="4243"><span class="lineNum">    4243 </span><span class="lineNoCov">          0 :                               if (templateSymbol != NULL)</span></a>
<a name="4244"><span class="lineNum">    4244 </span>            :                                  {</a>
<a name="4245"><span class="lineNum">    4245 </span>            :                                 // The symbol is not present, so we have to build one and add it.</a>
<a name="4246"><span class="lineNum">    4246 </span>            : #if 0</a>
<a name="4247"><span class="lineNum">    4247 </span>            :                                    printf (&quot;Building a symbol for derivedDeclaration = %p = %s to an alternative symbol table in derivedDeclarationScope = %p \n&quot;,</a>
<a name="4248"><span class="lineNum">    4248 </span>            :                                         derivedDeclaration,get_name(derivedDeclaration).c_str(),derivedDeclarationScope);</a>
<a name="4249"><span class="lineNum">    4249 </span>            : #endif</a>
<a name="4250"><span class="lineNum">    4250 </span><span class="lineNoCov">          0 :                                    SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);</span></a>
<a name="4251"><span class="lineNum">    4251 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4252"><span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                                    SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4253"><span class="lineNum">    4253 </span><span class="lineNoCov">          0 :                                    derivedDeclarationScope-&gt;insert_symbol(name,symbol);</span></a>
<a name="4254"><span class="lineNum">    4254 </span>            :                                  }</a>
<a name="4255"><span class="lineNum">    4255 </span>            :                                 else</a>
<a name="4256"><span class="lineNum">    4256 </span>            :                                  {</a>
<a name="4257"><span class="lineNum">    4257 </span>            :                                 // printf (&quot;The symbol was already present in the derivedDeclarationScope = %p \n&quot;,derivedDeclarationScope);</a>
<a name="4258"><span class="lineNum">    4258 </span>            :                                  }</a>
<a name="4259"><span class="lineNum">    4259 </span>            :                             }</a>
<a name="4260"><span class="lineNum">    4260 </span>            :                          break;</a>
<a name="4261"><span class="lineNum">    4261 </span>            :                        }</a>
<a name="4262"><span class="lineNum">    4262 </span>            : </a>
<a name="4263"><span class="lineNum">    4263 </span>            :                  // DQ (12/26/2012): Added support for templates.</a>
<a name="4264"><span class="lineNum">    4264 </span><span class="lineNoCov">          0 :                     case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="4265"><span class="lineNum">    4265 </span>            : </a>
<a name="4266"><span class="lineNum">    4266 </span><span class="lineNoCov">          0 :                     case V_SgMemberFunctionDeclaration:</span></a>
<a name="4267"><span class="lineNum">    4267 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4268"><span class="lineNum">    4268 </span><span class="lineNoCov">          0 :                          SgMemberFunctionDeclaration* derivedDeclaration = isSgMemberFunctionDeclaration(declaration);</span></a>
<a name="4269"><span class="lineNum">    4269 </span>            : </a>
<a name="4270"><span class="lineNum">    4270 </span>            :                       // DQ (11/6/2007): Don't build a symbol for the defining declaration defined in another scope and put the resulting symbol into the wrong scope</a>
<a name="4271"><span class="lineNum">    4271 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4272"><span class="lineNum">    4272 </span>            :                             {</a>
<a name="4273"><span class="lineNum">    4273 </span>            :                            // SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);</a>
<a name="4274"><span class="lineNum">    4274 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = NULL;</span></a>
<a name="4275"><span class="lineNum">    4275 </span><span class="lineNoCov">          0 :                               if (isSgTemplateFunctionDeclaration(declaration) != NULL)</span></a>
<a name="4276"><span class="lineNum">    4276 </span><span class="lineNoCov">          0 :                                    symbol = new SgTemplateMemberFunctionSymbol(derivedDeclaration);</span></a>
<a name="4277"><span class="lineNum">    4277 </span>            :                                 else</a>
<a name="4278"><span class="lineNum">    4278 </span><span class="lineNoCov">          0 :                                    symbol = new SgMemberFunctionSymbol(derivedDeclaration);</span></a>
<a name="4279"><span class="lineNum">    4279 </span>            : </a>
<a name="4280"><span class="lineNum">    4280 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4281"><span class="lineNum">    4281 </span>            : </a>
<a name="4282"><span class="lineNum">    4282 </span>            :                            // printf (&quot;In rebuildSymbolTable: symbol = %p = %s = %s \n&quot;,symbol,symbol-&gt;class_name().c_str(),SageInterface::get_name(symbol).c_str());</a>
<a name="4283"><span class="lineNum">    4283 </span>            : </a>
<a name="4284"><span class="lineNum">    4284 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4285"><span class="lineNum">    4285 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4286"><span class="lineNum">    4286 </span>            :                             }</a>
<a name="4287"><span class="lineNum">    4287 </span>            :                            else</a>
<a name="4288"><span class="lineNum">    4288 </span>            :                             {</a>
<a name="4289"><span class="lineNum">    4289 </span>            :                            // This happens when a defining declaration is located outside of the class where it is associated.</a>
<a name="4290"><span class="lineNum">    4290 </span>            :                            // printf (&quot;SgMemberFunctionDeclaration: scope = %p derivedDeclaration = %p = %s didn't match the scope \n&quot;,scope,derivedDeclaration,get_name(derivedDeclaration).c_str());</a>
<a name="4291"><span class="lineNum">    4291 </span>            :                             }</a>
<a name="4292"><span class="lineNum">    4292 </span>            :                          break;</a>
<a name="4293"><span class="lineNum">    4293 </span>            :                        }</a>
<a name="4294"><span class="lineNum">    4294 </span>            : </a>
<a name="4295"><span class="lineNum">    4295 </span>            :                  // DQ (2/26/2009): These have to be reformatted from where someone removed the formatting previously.</a>
<a name="4296"><span class="lineNum">    4296 </span><span class="lineNoCov">          0 :                     case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="4297"><span class="lineNum">    4297 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4298"><span class="lineNum">    4298 </span><span class="lineNoCov">          0 :                          SgTemplateInstantiationFunctionDecl* derivedDeclaration = isSgTemplateInstantiationFunctionDecl(declaration);</span></a>
<a name="4299"><span class="lineNum">    4299 </span>            :                       // DQ (10/21/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)</a>
<a name="4300"><span class="lineNum">    4300 </span>            :                       // if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="4301"><span class="lineNum">    4301 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4302"><span class="lineNum">    4302 </span>            :                             {</a>
<a name="4303"><span class="lineNum">    4303 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = new SgFunctionSymbol(derivedDeclaration);</span></a>
<a name="4304"><span class="lineNum">    4304 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4305"><span class="lineNum">    4305 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4306"><span class="lineNum">    4306 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4307"><span class="lineNum">    4307 </span>            :                             }</a>
<a name="4308"><span class="lineNum">    4308 </span>            :                            else</a>
<a name="4309"><span class="lineNum">    4309 </span>            :                             {</a>
<a name="4310"><span class="lineNum">    4310 </span><span class="lineNoCov">          0 :                               if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</span></a>
<a name="4311"><span class="lineNum">    4311 </span>            :                                  {</a>
<a name="4312"><span class="lineNum">    4312 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4313"><span class="lineNum">    4313 </span>            :                                    printf (&quot;Shouldn't this be a friend declaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4314"><span class="lineNum">    4314 </span>            : #endif</a>
<a name="4315"><span class="lineNum">    4315 </span>            :                                  }</a>
<a name="4316"><span class="lineNum">    4316 </span>            :                             }</a>
<a name="4317"><span class="lineNum">    4317 </span>            : </a>
<a name="4318"><span class="lineNum">    4318 </span>            :                          break;</a>
<a name="4319"><span class="lineNum">    4319 </span>            :                        }</a>
<a name="4320"><span class="lineNum">    4320 </span>            : </a>
<a name="4321"><span class="lineNum">    4321 </span>            :                  // DQ (12/24/2012): Added support for templates.</a>
<a name="4322"><span class="lineNum">    4322 </span><span class="lineNoCov">          0 :                     case V_SgTemplateFunctionDeclaration:</span></a>
<a name="4323"><span class="lineNum">    4323 </span>            : </a>
<a name="4324"><span class="lineNum">    4324 </span><span class="lineNoCov">          0 :                     case V_SgFunctionDeclaration:</span></a>
<a name="4325"><span class="lineNum">    4325 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4326"><span class="lineNum">    4326 </span><span class="lineNoCov">          0 :                          SgFunctionDeclaration* derivedDeclaration = isSgFunctionDeclaration(declaration);</span></a>
<a name="4327"><span class="lineNum">    4327 </span>            : </a>
<a name="4328"><span class="lineNum">    4328 </span>            :                       // DQ (10/20/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)</a>
<a name="4329"><span class="lineNum">    4329 </span>            :                       // if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="4330"><span class="lineNum">    4330 </span>            : </a>
<a name="4331"><span class="lineNum">    4331 </span><span class="lineNoCov">          0 :                          if (useThisDeclaration == true)</span></a>
<a name="4332"><span class="lineNum">    4332 </span>            :                             {</a>
<a name="4333"><span class="lineNum">    4333 </span><span class="lineNoCov">          0 :                               if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4334"><span class="lineNum">    4334 </span>            :                                  {</a>
<a name="4335"><span class="lineNum">    4335 </span>            :                                 // DQ (12/24/2012): Added support for templates.</a>
<a name="4336"><span class="lineNum">    4336 </span>            :                                 // SgSymbol* symbol = new SgFunctionSymbol(derivedDeclaration);</a>
<a name="4337"><span class="lineNum">    4337 </span><span class="lineNoCov">          0 :                                    SgSymbol* symbol = NULL;</span></a>
<a name="4338"><span class="lineNum">    4338 </span><span class="lineNoCov">          0 :                                    if (isSgTemplateFunctionDeclaration(declaration) != NULL)</span></a>
<a name="4339"><span class="lineNum">    4339 </span><span class="lineNoCov">          0 :                                         symbol = new SgTemplateFunctionSymbol(derivedDeclaration);</span></a>
<a name="4340"><span class="lineNum">    4340 </span>            :                                      else</a>
<a name="4341"><span class="lineNum">    4341 </span><span class="lineNoCov">          0 :                                         symbol = new SgFunctionSymbol(derivedDeclaration);</span></a>
<a name="4342"><span class="lineNum">    4342 </span>            : </a>
<a name="4343"><span class="lineNum">    4343 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4344"><span class="lineNum">    4344 </span><span class="lineNoCov">          0 :                                    SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4345"><span class="lineNum">    4345 </span><span class="lineNoCov">          0 :                                    symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4346"><span class="lineNum">    4346 </span>            :                                  }</a>
<a name="4347"><span class="lineNum">    4347 </span>            :                                 else</a>
<a name="4348"><span class="lineNum">    4348 </span>            :                                  {</a>
<a name="4349"><span class="lineNum">    4349 </span><span class="lineNoCov">          0 :                                    if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</span></a>
<a name="4350"><span class="lineNum">    4350 </span>            :                                       {</a>
<a name="4351"><span class="lineNum">    4351 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4352"><span class="lineNum">    4352 </span>            :                                         printf (&quot;Shouldn't this be a friend declaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4353"><span class="lineNum">    4353 </span>            : #endif</a>
<a name="4354"><span class="lineNum">    4354 </span>            :                                       }</a>
<a name="4355"><span class="lineNum">    4355 </span>            :                                  }</a>
<a name="4356"><span class="lineNum">    4356 </span>            :                             }</a>
<a name="4357"><span class="lineNum">    4357 </span>            :                          break;</a>
<a name="4358"><span class="lineNum">    4358 </span>            :                        }</a>
<a name="4359"><span class="lineNum">    4359 </span>            : </a>
<a name="4360"><span class="lineNum">    4360 </span>            :                  // DQ (12/28/2012): Adding support for templates.</a>
<a name="4361"><span class="lineNum">    4361 </span><span class="lineCov">         18 :                     case V_SgTemplateVariableDeclaration:</span></a>
<a name="4362"><span class="lineNum">    4362 </span>            : </a>
<a name="4363"><span class="lineNum">    4363 </span><span class="lineCov">         18 :                     case V_SgVariableDeclaration:</span></a>
<a name="4364"><span class="lineNum">    4364 </span><span class="lineCov">         18 :                        {</span></a>
<a name="4365"><span class="lineNum">    4365 </span><span class="lineCov">         18 :                          SgVariableDeclaration* derivedDeclaration = isSgVariableDeclaration(declaration);</span></a>
<a name="4366"><span class="lineNum">    4366 </span><span class="lineCov">         18 :                          SgInitializedNamePtrList &amp; variableList = derivedDeclaration-&gt;get_variables();</span></a>
<a name="4367"><span class="lineNum">    4367 </span><span class="lineCov">         18 :                          SgInitializedNamePtrList::iterator i = variableList.begin();</span></a>
<a name="4368"><span class="lineNum">    4368 </span><span class="lineCov">         36 :                          while ( i != variableList.end() )</span></a>
<a name="4369"><span class="lineNum">    4369 </span>            :                             {</a>
<a name="4370"><span class="lineNum">    4370 </span><span class="lineCov">         18 :                               SgInitializedName* variable = *i;</span></a>
<a name="4371"><span class="lineNum">    4371 </span><span class="lineCov">         18 :                               ROSE_ASSERT(variable != NULL);</span></a>
<a name="4372"><span class="lineNum">    4372 </span>            : </a>
<a name="4373"><span class="lineNum">    4373 </span>            :                            // DQ (10/20/2007): static data members declared outside the class scope don't generate symbols.</a>
<a name="4374"><span class="lineNum">    4374 </span>            :                            // if (variable-&gt;get_prev_decl_item() != NULL)</a>
<a name="4375"><span class="lineNum">    4375 </span><span class="lineCov">         18 :                               if (variable-&gt;get_scope() == scope)</span></a>
<a name="4376"><span class="lineNum">    4376 </span>            :                                  {</a>
<a name="4377"><span class="lineNum">    4377 </span><span class="lineCov">         18 :                                    SgSymbol* symbol = new SgVariableSymbol(variable);</span></a>
<a name="4378"><span class="lineNum">    4378 </span><span class="lineCov">         18 :                                    ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4379"><span class="lineNum">    4379 </span>            : </a>
<a name="4380"><span class="lineNum">    4380 </span>            :                                 // printf (&quot;In SageInterface::rebuildSymbolTable() variable = %p building a new SgVariableSymbol = %p \n&quot;,variable,symbol);</a>
<a name="4381"><span class="lineNum">    4381 </span>            : </a>
<a name="4382"><span class="lineNum">    4382 </span><span class="lineCov">         36 :                                    SgName name = variable-&gt;get_name();</span></a>
<a name="4383"><span class="lineNum">    4383 </span><span class="lineCov">         18 :                                    symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4384"><span class="lineNum">    4384 </span>            :                                  }</a>
<a name="4385"><span class="lineNum">    4385 </span>            :                                 else</a>
<a name="4386"><span class="lineNum">    4386 </span>            :                                  {</a>
<a name="4387"><span class="lineNum">    4387 </span>            :                                 // I think there is nothing to do in this case</a>
<a name="4388"><span class="lineNum">    4388 </span>            :                                 // printf (&quot;In SageInterface::rebuildSymbolTable() This variable has a scope inconsistant with the symbol table: variable-&gt;get_scope() = %p scope = %p \n&quot;,variable-&gt;get_scope(),scope);</a>
<a name="4389"><span class="lineNum">    4389 </span>            :                                  }</a>
<a name="4390"><span class="lineNum">    4390 </span>            : </a>
<a name="4391"><span class="lineNum">    4391 </span><span class="lineCov">         18 :                               i++;</span></a>
<a name="4392"><span class="lineNum">    4392 </span>            :                             }</a>
<a name="4393"><span class="lineNum">    4393 </span>            : </a>
<a name="4394"><span class="lineNum">    4394 </span>            :                       // DQ (10/13/2007): Need to look into variable declarations to see if there are defining declaration</a>
<a name="4395"><span class="lineNum">    4395 </span>            :                       // that also force symbols to be built in the current scope!</a>
<a name="4396"><span class="lineNum">    4396 </span>            :                       // ROSE_ASSERT(derivedDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == false);</a>
<a name="4397"><span class="lineNum">    4397 </span><span class="lineCov">         18 :                          if (derivedDeclaration-&gt;get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)</span></a>
<a name="4398"><span class="lineNum">    4398 </span>            :                             {</a>
<a name="4399"><span class="lineNum">    4399 </span>            :                            // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.</a>
<a name="4400"><span class="lineNum">    4400 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="4401"><span class="lineNum">    4401 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(derivedDeclaration-&gt;get_baseTypeDefiningDeclaration() != NULL);</span></a>
<a name="4402"><span class="lineNum">    4402 </span><span class="lineNoCov">          0 :                               supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration-&gt;get_baseTypeDefiningDeclaration() );</span></a>
<a name="4403"><span class="lineNum">    4403 </span>            :                             }</a>
<a name="4404"><span class="lineNum">    4404 </span>            : </a>
<a name="4405"><span class="lineNum">    4405 </span>            :                       // ROSE_ASSERT(symbolList.empty() == false);</a>
<a name="4406"><span class="lineNum">    4406 </span>            :                          break;</a>
<a name="4407"><span class="lineNum">    4407 </span>            :                        }</a>
<a name="4408"><span class="lineNum">    4408 </span>            : </a>
<a name="4409"><span class="lineNum">    4409 </span><span class="lineNoCov">          0 :                     case V_SgTemplateInstantiationDecl:</span></a>
<a name="4410"><span class="lineNum">    4410 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4411"><span class="lineNum">    4411 </span><span class="lineNoCov">          0 :                          SgTemplateInstantiationDecl* derivedDeclaration = isSgTemplateInstantiationDecl(declaration);</span></a>
<a name="4412"><span class="lineNum">    4412 </span>            : #if 1</a>
<a name="4413"><span class="lineNum">    4413 </span>            :                       // printf (&quot;case SgTemplateInstantiationDecl: derivedDeclaration name = %s derivedDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,</a>
<a name="4414"><span class="lineNum">    4414 </span>            :                       //      derivedDeclaration-&gt;get_name().str(),derivedDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4415"><span class="lineNum">    4415 </span>            : </a>
<a name="4416"><span class="lineNum">    4416 </span>            :                       // if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="4417"><span class="lineNum">    4417 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4418"><span class="lineNum">    4418 </span>            :                             {</a>
<a name="4419"><span class="lineNum">    4419 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);</span></a>
<a name="4420"><span class="lineNum">    4420 </span>            :                            // printf (&quot;Inserting SgClassSymbol = %p into scope = %p = %s \n&quot;,symbol,scope,scope-&gt;class_name().c_str());</a>
<a name="4421"><span class="lineNum">    4421 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4422"><span class="lineNum">    4422 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4423"><span class="lineNum">    4423 </span>            : #if 0</a>
<a name="4424"><span class="lineNum">    4424 </span>            :                            // DQ (10/21/2007): The scopes should match</a>
<a name="4425"><span class="lineNum">    4425 </span>            :                               if (scope != derivedDeclaration-&gt;get_scope())</a>
<a name="4426"><span class="lineNum">    4426 </span>            :                                  {</a>
<a name="4427"><span class="lineNum">    4427 </span>            :                                    printf (&quot;Error: scopes don't match for derivedDeclaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4428"><span class="lineNum">    4428 </span>            :                                  }</a>
<a name="4429"><span class="lineNum">    4429 </span>            :                               ROSE_ASSERT(scope == derivedDeclaration-&gt;get_scope());</a>
<a name="4430"><span class="lineNum">    4430 </span>            : #endif</a>
<a name="4431"><span class="lineNum">    4431 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4432"><span class="lineNum">    4432 </span>            :                             }</a>
<a name="4433"><span class="lineNum">    4433 </span>            :                            else</a>
<a name="4434"><span class="lineNum">    4434 </span>            :                             {</a>
<a name="4435"><span class="lineNum">    4435 </span>            :                            // printf (&quot;SgTemplateInstantiationDecl: scope = %p derivedDeclaration = %p = %s didn't match the scope \n&quot;,scope,derivedDeclaration,get_name(derivedDeclaration).c_str());</a>
<a name="4436"><span class="lineNum">    4436 </span>            : </a>
<a name="4437"><span class="lineNum">    4437 </span><span class="lineNoCov">          0 :                               if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</span></a>
<a name="4438"><span class="lineNum">    4438 </span>            :                                  {</a>
<a name="4439"><span class="lineNum">    4439 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4440"><span class="lineNum">    4440 </span>            :                                    printf (&quot;Shouldn't this be a friend declaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4441"><span class="lineNum">    4441 </span>            : #endif</a>
<a name="4442"><span class="lineNum">    4442 </span>            :                                  }</a>
<a name="4443"><span class="lineNum">    4443 </span>            :                             }</a>
<a name="4444"><span class="lineNum">    4444 </span>            : #else</a>
<a name="4445"><span class="lineNum">    4445 </span>            :                          SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);</a>
<a name="4446"><span class="lineNum">    4446 </span>            :                          ROSE_ASSERT(symbol != NULL);</a>
<a name="4447"><span class="lineNum">    4447 </span>            :                          SgName name = derivedDeclaration-&gt;get_name();</a>
<a name="4448"><span class="lineNum">    4448 </span>            :                          symbolTable-&gt;insert(name,symbol);</a>
<a name="4449"><span class="lineNum">    4449 </span>            : #endif</a>
<a name="4450"><span class="lineNum">    4450 </span>            :                          break;</a>
<a name="4451"><span class="lineNum">    4451 </span>            :                        }</a>
<a name="4452"><span class="lineNum">    4452 </span>            : </a>
<a name="4453"><span class="lineNum">    4453 </span>            : </a>
<a name="4454"><span class="lineNum">    4454 </span>            :                  // DQ (12/24/2012): Added support for templates.</a>
<a name="4455"><span class="lineNum">    4455 </span><span class="lineNoCov">          0 :                     case V_SgTemplateClassDeclaration:</span></a>
<a name="4456"><span class="lineNum">    4456 </span>            : </a>
<a name="4457"><span class="lineNum">    4457 </span><span class="lineNoCov">          0 :                     case V_SgClassDeclaration:</span></a>
<a name="4458"><span class="lineNum">    4458 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4459"><span class="lineNum">    4459 </span><span class="lineNoCov">          0 :                          SgClassDeclaration* derivedDeclaration = isSgClassDeclaration(declaration);</span></a>
<a name="4460"><span class="lineNum">    4460 </span>            : #if 1</a>
<a name="4461"><span class="lineNum">    4461 </span>            :                       // printf (&quot;case SgClassDeclaration: derivedDeclaration name = %s derivedDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,</a>
<a name="4462"><span class="lineNum">    4462 </span>            :                       //      derivedDeclaration-&gt;get_name().str(),derivedDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4463"><span class="lineNum">    4463 </span>            :                       // if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="4464"><span class="lineNum">    4464 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4465"><span class="lineNum">    4465 </span>            :                             {</a>
<a name="4466"><span class="lineNum">    4466 </span>            :                            // SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);</a>
<a name="4467"><span class="lineNum">    4467 </span><span class="lineNoCov">          0 :                                SgSymbol* symbol = NULL;</span></a>
<a name="4468"><span class="lineNum">    4468 </span><span class="lineNoCov">          0 :                                    if (isSgTemplateClassDeclaration(declaration) != NULL)</span></a>
<a name="4469"><span class="lineNum">    4469 </span><span class="lineNoCov">          0 :                                         symbol = new SgTemplateClassSymbol(derivedDeclaration);</span></a>
<a name="4470"><span class="lineNum">    4470 </span>            :                                      else</a>
<a name="4471"><span class="lineNum">    4471 </span><span class="lineNoCov">          0 :                                         symbol = new SgClassSymbol(derivedDeclaration);</span></a>
<a name="4472"><span class="lineNum">    4472 </span>            : </a>
<a name="4473"><span class="lineNum">    4473 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4474"><span class="lineNum">    4474 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4475"><span class="lineNum">    4475 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4476"><span class="lineNum">    4476 </span>            :                             }</a>
<a name="4477"><span class="lineNum">    4477 </span>            :                            else</a>
<a name="4478"><span class="lineNum">    4478 </span>            :                             {</a>
<a name="4479"><span class="lineNum">    4479 </span><span class="lineNoCov">          0 :                               if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</span></a>
<a name="4480"><span class="lineNum">    4480 </span>            :                                  {</a>
<a name="4481"><span class="lineNum">    4481 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4482"><span class="lineNum">    4482 </span>            :                                    printf (&quot;Shouldn't this be a friend declaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4483"><span class="lineNum">    4483 </span>            : #endif</a>
<a name="4484"><span class="lineNum">    4484 </span>            :                                  }</a>
<a name="4485"><span class="lineNum">    4485 </span>            :                             }</a>
<a name="4486"><span class="lineNum">    4486 </span>            : #else</a>
<a name="4487"><span class="lineNum">    4487 </span>            :                          SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);</a>
<a name="4488"><span class="lineNum">    4488 </span>            :                          ROSE_ASSERT(symbol != NULL);</a>
<a name="4489"><span class="lineNum">    4489 </span>            :                          SgName name = derivedDeclaration-&gt;get_name();</a>
<a name="4490"><span class="lineNum">    4490 </span>            :                          symbolTable-&gt;insert(name,symbol);</a>
<a name="4491"><span class="lineNum">    4491 </span>            : #endif</a>
<a name="4492"><span class="lineNum">    4492 </span>            :                          break;</a>
<a name="4493"><span class="lineNum">    4493 </span>            :                        }</a>
<a name="4494"><span class="lineNum">    4494 </span>            : </a>
<a name="4495"><span class="lineNum">    4495 </span><span class="lineNoCov">          0 :                     case V_SgEnumDeclaration:</span></a>
<a name="4496"><span class="lineNum">    4496 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4497"><span class="lineNum">    4497 </span><span class="lineNoCov">          0 :                          SgEnumDeclaration* derivedDeclaration = isSgEnumDeclaration(declaration);</span></a>
<a name="4498"><span class="lineNum">    4498 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(derivedDeclaration != NULL);</span></a>
<a name="4499"><span class="lineNum">    4499 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = new SgEnumSymbol(derivedDeclaration);</span></a>
<a name="4500"><span class="lineNum">    4500 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4501"><span class="lineNum">    4501 </span><span class="lineNoCov">          0 :                          SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4502"><span class="lineNum">    4502 </span><span class="lineNoCov">          0 :                          symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4503"><span class="lineNum">    4503 </span>            : </a>
<a name="4504"><span class="lineNum">    4504 </span>            :                       // DQ (10/18/2007): Fixed construction of symbol tabel to include enum fields.</a>
<a name="4505"><span class="lineNum">    4505 </span><span class="lineNoCov">          0 :                          SgInitializedNamePtrList &amp; enumFieldList = derivedDeclaration-&gt;get_enumerators();</span></a>
<a name="4506"><span class="lineNum">    4506 </span><span class="lineNoCov">          0 :                          SgInitializedNamePtrList::iterator i     = enumFieldList.begin();</span></a>
<a name="4507"><span class="lineNum">    4507 </span>            : </a>
<a name="4508"><span class="lineNum">    4508 </span>            :                       // Iterate over enum fields and add each one to the symbol table.</a>
<a name="4509"><span class="lineNum">    4509 </span><span class="lineNoCov">          0 :                          while (i != enumFieldList.end())</span></a>
<a name="4510"><span class="lineNum">    4510 </span>            :                             {</a>
<a name="4511"><span class="lineNum">    4511 </span><span class="lineNoCov">          0 :                               SgSymbol* enum_field_symbol = new SgEnumFieldSymbol(*i);</span></a>
<a name="4512"><span class="lineNum">    4512 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(enum_field_symbol != NULL);</span></a>
<a name="4513"><span class="lineNum">    4513 </span><span class="lineNoCov">          0 :                               SgName enum_field_name = (*i)-&gt;get_name();</span></a>
<a name="4514"><span class="lineNum">    4514 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(enum_field_name,enum_field_symbol);</span></a>
<a name="4515"><span class="lineNum">    4515 </span>            : </a>
<a name="4516"><span class="lineNum">    4516 </span><span class="lineNoCov">          0 :                               i++;</span></a>
<a name="4517"><span class="lineNum">    4517 </span>            :                             }</a>
<a name="4518"><span class="lineNum">    4518 </span>            : </a>
<a name="4519"><span class="lineNum">    4519 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="4520"><span class="lineNum">    4520 </span>            :                        }</a>
<a name="4521"><span class="lineNum">    4521 </span>            : </a>
<a name="4522"><span class="lineNum">    4522 </span>            : </a>
<a name="4523"><span class="lineNum">    4523 </span>            :                  // DQ (2/18/2017): Added support for C++11 SgTemplateTypedefDeclaration.</a>
<a name="4524"><span class="lineNum">    4524 </span><span class="lineNoCov">          0 :                     case V_SgTemplateTypedefDeclaration:</span></a>
<a name="4525"><span class="lineNum">    4525 </span>            : </a>
<a name="4526"><span class="lineNum">    4526 </span><span class="lineNoCov">          0 :                     case V_SgTypedefDeclaration:</span></a>
<a name="4527"><span class="lineNum">    4527 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4528"><span class="lineNum">    4528 </span><span class="lineNoCov">          0 :                          SgTypedefDeclaration* derivedDeclaration = isSgTypedefDeclaration(declaration);</span></a>
<a name="4529"><span class="lineNum">    4529 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = new SgTypedefSymbol(derivedDeclaration);</span></a>
<a name="4530"><span class="lineNum">    4530 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4531"><span class="lineNum">    4531 </span><span class="lineNoCov">          0 :                          SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4532"><span class="lineNum">    4532 </span><span class="lineNoCov">          0 :                          symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4533"><span class="lineNum">    4533 </span>            : #if 0</a>
<a name="4534"><span class="lineNum">    4534 </span>            :                          printf (&quot;In SageInterface::rebuildSymbolTable(): case of SgTypedefDeclaration \n&quot;);</a>
<a name="4535"><span class="lineNum">    4535 </span>            : #endif</a>
<a name="4536"><span class="lineNum">    4536 </span>            :                       // DQ (10/13/2007): Need to look into typedefs to see if there are defining declaration</a>
<a name="4537"><span class="lineNum">    4537 </span>            :                       // that also force symbols to be built in the current scope!</a>
<a name="4538"><span class="lineNum">    4538 </span>            :                       // ROSE_ASSERT(derivedDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() == false);</a>
<a name="4539"><span class="lineNum">    4539 </span><span class="lineNoCov">          0 :                          if (derivedDeclaration-&gt;get_typedefBaseTypeContainsDefiningDeclaration() == true)</span></a>
<a name="4540"><span class="lineNum">    4540 </span>            :                             {</a>
<a name="4541"><span class="lineNum">    4541 </span>            :                            // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.</a>
<a name="4542"><span class="lineNum">    4542 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="4543"><span class="lineNum">    4543 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(derivedDeclaration-&gt;get_baseTypeDefiningDeclaration() != NULL);</span></a>
<a name="4544"><span class="lineNum">    4544 </span>            : #if 0</a>
<a name="4545"><span class="lineNum">    4545 </span>            :                               printf (&quot;In SageInterface::rebuildSymbolTable(): case of SgTypedefDeclaration: typedefBaseTypeContainsDefiningDeclaration == true calling supportForBaseTypeDefiningDeclaration() \n&quot;);</a>
<a name="4546"><span class="lineNum">    4546 </span>            : #endif</a>
<a name="4547"><span class="lineNum">    4547 </span><span class="lineNoCov">          0 :                               supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration-&gt;get_baseTypeDefiningDeclaration() );</span></a>
<a name="4548"><span class="lineNum">    4548 </span>            :                             }</a>
<a name="4549"><span class="lineNum">    4549 </span>            :                            else</a>
<a name="4550"><span class="lineNum">    4550 </span>            :                             {</a>
<a name="4551"><span class="lineNum">    4551 </span>            :                            // DQ (11/7/2007): If the typedef has a definition (e.g. function pointer) then build a symbol.</a>
<a name="4552"><span class="lineNum">    4552 </span><span class="lineNoCov">          0 :                               SgDeclarationStatement* declaration = derivedDeclaration-&gt;get_declaration();</span></a>
<a name="4553"><span class="lineNum">    4553 </span><span class="lineNoCov">          0 :                               if (declaration != NULL)</span></a>
<a name="4554"><span class="lineNum">    4554 </span>            :                                  {</a>
<a name="4555"><span class="lineNum">    4555 </span>            : #if 0</a>
<a name="4556"><span class="lineNum">    4556 </span>            :                                    printf (&quot;In SageInterface::rebuildSymbolTable(): case of SgTypedefDeclaration: typedefBaseTypeContainsDefiningDeclaration == false calling supportForBaseTypeDefiningDeclaration() \n&quot;);</a>
<a name="4557"><span class="lineNum">    4557 </span>            : #endif</a>
<a name="4558"><span class="lineNum">    4558 </span>            :                                 // DQ (12/27/2012): Debugging the support for copytest_2007_40_cpp.C (we don't want to build this symbol since it is associated with an outer scope).</a>
<a name="4559"><span class="lineNum">    4559 </span>            :                                 // supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration-&gt;get_declaration() );</a>
<a name="4560"><span class="lineNum">    4560 </span>            : </a>
<a name="4561"><span class="lineNum">    4561 </span><span class="lineNoCov">          0 :                                    printf (&quot;In SageInterface::rebuildSymbolTable(): case of SgTypedefDeclaration: typedefBaseTypeContainsDefiningDeclaration == false: skipping call to supportForBaseTypeDefiningDeclaration() \n&quot;);</span></a>
<a name="4562"><span class="lineNum">    4562 </span>            :                                  }</a>
<a name="4563"><span class="lineNum">    4563 </span>            :                             }</a>
<a name="4564"><span class="lineNum">    4564 </span>            : #if 0</a>
<a name="4565"><span class="lineNum">    4565 </span>            :                          printf (&quot;In SageInterface::rebuildSymbolTable(): Leaving case of SgTypedefDeclaration \n&quot;);</a>
<a name="4566"><span class="lineNum">    4566 </span>            : #endif</a>
<a name="4567"><span class="lineNum">    4567 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="4568"><span class="lineNum">    4568 </span>            :                        }</a>
<a name="4569"><span class="lineNum">    4569 </span>            : </a>
<a name="4570"><span class="lineNum">    4570 </span><span class="lineNoCov">          0 :                     case V_SgTemplateDeclaration:</span></a>
<a name="4571"><span class="lineNum">    4571 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4572"><span class="lineNum">    4572 </span><span class="lineNoCov">          0 :                          SgTemplateDeclaration* derivedDeclaration = isSgTemplateDeclaration(declaration);</span></a>
<a name="4573"><span class="lineNum">    4573 </span>            : #if 1</a>
<a name="4574"><span class="lineNum">    4574 </span>            :                       // DQ (10/21/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)</a>
<a name="4575"><span class="lineNum">    4575 </span>            : #if 0</a>
<a name="4576"><span class="lineNum">    4576 </span>            :                          printf (&quot;case V_SgTemplateDeclaration: derivedDeclaration               = %p \n&quot;,derivedDeclaration);</a>
<a name="4577"><span class="lineNum">    4577 </span>            :                          printf (&quot;case V_SgTemplateDeclaration: derivedDeclaration-&gt;get_declarationModifier().isFriend() = %s \n&quot;,derivedDeclaration-&gt;get_declarationModifier().isFriend() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4578"><span class="lineNum">    4578 </span>            :                          printf (&quot;case V_SgTemplateDeclaration: derivedDeclaration-&gt;get_name()   = %s \n&quot;,derivedDeclaration-&gt;get_name().str());</a>
<a name="4579"><span class="lineNum">    4579 </span>            :                          printf (&quot;case V_SgTemplateDeclaration: derivedDeclaration-&gt;get_string() = %s \n&quot;,derivedDeclaration-&gt;get_string().str());</a>
<a name="4580"><span class="lineNum">    4580 </span>            : #endif</a>
<a name="4581"><span class="lineNum">    4581 </span>            :                       // if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</a>
<a name="4582"><span class="lineNum">    4582 </span><span class="lineNoCov">          0 :                          if (scope == derivedDeclaration-&gt;get_scope())</span></a>
<a name="4583"><span class="lineNum">    4583 </span>            :                             {</a>
<a name="4584"><span class="lineNum">    4584 </span>            :                            // printf (&quot;Building symbol for SgTemplateDeclaration: derivedDeclaration = %p for symbol table in scope = %p \n&quot;,derivedDeclaration,scope);</a>
<a name="4585"><span class="lineNum">    4585 </span><span class="lineNoCov">          0 :                               SgSymbol* symbol = new SgTemplateSymbol(derivedDeclaration);</span></a>
<a name="4586"><span class="lineNum">    4586 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4587"><span class="lineNum">    4587 </span><span class="lineNoCov">          0 :                               SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4588"><span class="lineNum">    4588 </span><span class="lineNoCov">          0 :                               symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4589"><span class="lineNum">    4589 </span>            :                             }</a>
<a name="4590"><span class="lineNum">    4590 </span>            :                            else</a>
<a name="4591"><span class="lineNum">    4591 </span>            :                             {</a>
<a name="4592"><span class="lineNum">    4592 </span><span class="lineNoCov">          0 :                               if (derivedDeclaration-&gt;get_declarationModifier().isFriend() == false)</span></a>
<a name="4593"><span class="lineNum">    4593 </span>            :                                  {</a>
<a name="4594"><span class="lineNum">    4594 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="4595"><span class="lineNum">    4595 </span>            :                                    printf (&quot;Shouldn't this be a friend declaration = %p = %s \n&quot;,derivedDeclaration,derivedDeclaration-&gt;class_name().c_str());</a>
<a name="4596"><span class="lineNum">    4596 </span>            : #endif</a>
<a name="4597"><span class="lineNum">    4597 </span>            :                                  }</a>
<a name="4598"><span class="lineNum">    4598 </span>            :                             }</a>
<a name="4599"><span class="lineNum">    4599 </span>            : #else</a>
<a name="4600"><span class="lineNum">    4600 </span>            :                          SgTemplateDeclaration* derivedDeclaration = isSgTemplateDeclaration(declaration);</a>
<a name="4601"><span class="lineNum">    4601 </span>            :                          SgSymbol* symbol = new SgTemplateSymbol(derivedDeclaration);</a>
<a name="4602"><span class="lineNum">    4602 </span>            :                          ROSE_ASSERT(symbol != NULL);</a>
<a name="4603"><span class="lineNum">    4603 </span>            :                          SgName name = derivedDeclaration-&gt;get_name();</a>
<a name="4604"><span class="lineNum">    4604 </span>            :                          symbolTable-&gt;insert(name,symbol);</a>
<a name="4605"><span class="lineNum">    4605 </span>            : #endif</a>
<a name="4606"><span class="lineNum">    4606 </span>            :                          break;</a>
<a name="4607"><span class="lineNum">    4607 </span>            :                        }</a>
<a name="4608"><span class="lineNum">    4608 </span>            : </a>
<a name="4609"><span class="lineNum">    4609 </span>            :                  // Does this cause a symbol to be built?  Seems that it should,</a>
<a name="4610"><span class="lineNum">    4610 </span>            :                  // unless we always reference the non-aliased symbol (reuse it)!</a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineNoCov">          0 :                     case V_SgNamespaceAliasDeclarationStatement:</span></a>
<a name="4612"><span class="lineNum">    4612 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4613"><span class="lineNum">    4613 </span><span class="lineNoCov">          0 :                          SgNamespaceAliasDeclarationStatement* aliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);</span></a>
<a name="4614"><span class="lineNum">    4614 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(aliasDeclaration != NULL);</span></a>
<a name="4615"><span class="lineNum">    4615 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(aliasDeclaration-&gt;get_namespaceDeclaration() != NULL);</span></a>
<a name="4616"><span class="lineNum">    4616 </span>            : </a>
<a name="4617"><span class="lineNum">    4617 </span><span class="lineNoCov">          0 :                          SgNamespaceDeclarationStatement* derivedDeclaration = isSgNamespaceDeclarationStatement(aliasDeclaration-&gt;get_namespaceDeclaration());</span></a>
<a name="4618"><span class="lineNum">    4618 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(derivedDeclaration != NULL);</span></a>
<a name="4619"><span class="lineNum">    4619 </span>            : </a>
<a name="4620"><span class="lineNum">    4620 </span>            :                       // The constructor for the SgNamespaceSymbol is disturbingly different from the rest of the constructors.</a>
<a name="4621"><span class="lineNum">    4621 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = new SgNamespaceSymbol(derivedDeclaration-&gt;get_name(),derivedDeclaration);</span></a>
<a name="4622"><span class="lineNum">    4622 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4623"><span class="lineNum">    4623 </span><span class="lineNoCov">          0 :                          SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4624"><span class="lineNum">    4624 </span><span class="lineNoCov">          0 :                          symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4625"><span class="lineNum">    4625 </span>            :                       // symbolList.push_back(symbol);</a>
<a name="4626"><span class="lineNum">    4626 </span>            :                       // ROSE_ASSERT(symbolList.empty() == false);</a>
<a name="4627"><span class="lineNum">    4627 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="4628"><span class="lineNum">    4628 </span>            :                        }</a>
<a name="4629"><span class="lineNum">    4629 </span>            : </a>
<a name="4630"><span class="lineNum">    4630 </span>            :                  // Does this cause a symbol to be built?  Seems that it should,</a>
<a name="4631"><span class="lineNum">    4631 </span>            :                  // unless we always reference the non-aliased symbol (reuse it)!</a>
<a name="4632"><span class="lineNum">    4632 </span><span class="lineNoCov">          0 :                     case V_SgNamespaceDeclarationStatement:</span></a>
<a name="4633"><span class="lineNum">    4633 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4634"><span class="lineNum">    4634 </span><span class="lineNoCov">          0 :                          SgNamespaceDeclarationStatement* derivedDeclaration = isSgNamespaceDeclarationStatement(declaration);</span></a>
<a name="4635"><span class="lineNum">    4635 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(derivedDeclaration != NULL);</span></a>
<a name="4636"><span class="lineNum">    4636 </span>            : </a>
<a name="4637"><span class="lineNum">    4637 </span>            :                       // The constructor for the SgNamespaceSymbol is disturbingly different from the rest of the constructors.</a>
<a name="4638"><span class="lineNum">    4638 </span><span class="lineNoCov">          0 :                          SgSymbol* symbol = new SgNamespaceSymbol(derivedDeclaration-&gt;get_name(),derivedDeclaration);</span></a>
<a name="4639"><span class="lineNum">    4639 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbol != NULL);</span></a>
<a name="4640"><span class="lineNum">    4640 </span><span class="lineNoCov">          0 :                          SgName name = derivedDeclaration-&gt;get_name();</span></a>
<a name="4641"><span class="lineNum">    4641 </span><span class="lineNoCov">          0 :                          symbolTable-&gt;insert(name,symbol);</span></a>
<a name="4642"><span class="lineNum">    4642 </span>            :                       // symbolList.push_back(symbol);</a>
<a name="4643"><span class="lineNum">    4643 </span>            :                       // ROSE_ASSERT(symbolList.empty() == false);</a>
<a name="4644"><span class="lineNum">    4644 </span><span class="lineNoCov">          0 :                          break;</span></a>
<a name="4645"><span class="lineNum">    4645 </span>            :                        }</a>
<a name="4646"><span class="lineNum">    4646 </span>            : </a>
<a name="4647"><span class="lineNum">    4647 </span>            :                     case V_SgUsingDirectiveStatement:</a>
<a name="4648"><span class="lineNum">    4648 </span>            :                     case V_SgPragmaDeclaration:</a>
<a name="4649"><span class="lineNum">    4649 </span>            :                     case V_SgTemplateInstantiationDirectiveStatement:</a>
<a name="4650"><span class="lineNum">    4650 </span>            :                     case V_SgUsingDeclarationStatement:</a>
<a name="4651"><span class="lineNum">    4651 </span>            :                       {</a>
<a name="4652"><span class="lineNum">    4652 </span>            :                         // DQ (10/22/2005): Not sure if we have to worry about this declaration's appearance in the symbol table!</a>
<a name="4653"><span class="lineNum">    4653 </span>            : #if 0</a>
<a name="4654"><span class="lineNum">    4654 </span>            :                         printf (&quot;This declaration is ignored in rebuilding symbol table %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</a>
<a name="4655"><span class="lineNum">    4655 </span>            : #endif</a>
<a name="4656"><span class="lineNum">    4656 </span>            :                         break;</a>
<a name="4657"><span class="lineNum">    4657 </span>            :                       }</a>
<a name="4658"><span class="lineNum">    4658 </span>            : </a>
<a name="4659"><span class="lineNum">    4659 </span>            :                     case V_SgAsmStmt:</a>
<a name="4660"><span class="lineNum">    4660 </span>            :                       {</a>
<a name="4661"><span class="lineNum">    4661 </span>            :                         // DQ (8/13/2006): This is not really a declaration (I think).  This will be fixed later.</a>
<a name="4662"><span class="lineNum">    4662 </span>            : #if 0</a>
<a name="4663"><span class="lineNum">    4663 </span>            :                         printf (&quot;An ASM statement (SgAsmStmt) declaration is not really a declaration %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</a>
<a name="4664"><span class="lineNum">    4664 </span>            : #endif</a>
<a name="4665"><span class="lineNum">    4665 </span>            :                         break;</a>
<a name="4666"><span class="lineNum">    4666 </span>            :                       }</a>
<a name="4667"><span class="lineNum">    4667 </span>            : </a>
<a name="4668"><span class="lineNum">    4668 </span>            :                  // Cases where declations are not used or referenced and so symbols are not required!</a>
<a name="4669"><span class="lineNum">    4669 </span><span class="lineNoCov">          0 :                     case V_SgVariableDefinition:</span></a>
<a name="4670"><span class="lineNum">    4670 </span><span class="lineNoCov">          0 :                     case V_SgFunctionParameterList:</span></a>
<a name="4671"><span class="lineNum">    4671 </span><span class="lineNoCov">          0 :                     case V_SgCtorInitializerList:</span></a>
<a name="4672"><span class="lineNum">    4672 </span>            :                  // These are not referenced so they don't need a symbol!</a>
<a name="4673"><span class="lineNum">    4673 </span><span class="lineNoCov">          0 :                       {</span></a>
<a name="4674"><span class="lineNum">    4674 </span><span class="lineNoCov">          0 :                         printf (&quot;Special cases not handled %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</span></a>
<a name="4675"><span class="lineNum">    4675 </span><span class="lineNoCov">          0 :                         ROSE_ABORT();</span></a>
<a name="4676"><span class="lineNum">    4676 </span>            :                       }</a>
<a name="4677"><span class="lineNum">    4677 </span>            : </a>
<a name="4678"><span class="lineNum">    4678 </span>            :                   case V_SgStaticAssertionDeclaration:</a>
<a name="4679"><span class="lineNum">    4679 </span>            :                       {</a>
<a name="4680"><span class="lineNum">    4680 </span>            :                      // DQ (2/18/2017): This is not really a declaration (I think).  This will be fixed later.</a>
<a name="4681"><span class="lineNum">    4681 </span>            : #if 0</a>
<a name="4682"><span class="lineNum">    4682 </span>            :                         printf (&quot;A static assertion statement (SgStaticAssertionDeclaration) declaration is not really a declaration %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</a>
<a name="4683"><span class="lineNum">    4683 </span>            : #endif</a>
<a name="4684"><span class="lineNum">    4684 </span>            :                         break;</a>
<a name="4685"><span class="lineNum">    4685 </span>            :                       }</a>
<a name="4686"><span class="lineNum">    4686 </span>            :                   case V_SgFortranIncludeLine:</a>
<a name="4687"><span class="lineNum">    4687 </span>            :                           {</a>
<a name="4688"><span class="lineNum">    4688 </span>            :                                   //YYH (12/07/2022). Not declaration, but preprocessing directive,</a>
<a name="4689"><span class="lineNum">    4689 </span>            :                                   // and preprocessing directives are all declaration statement, check ROSETTA/src/statement.C.</a>
<a name="4690"><span class="lineNum">    4690 </span>            :                           break;</a>
<a name="4691"><span class="lineNum">    4691 </span>            :                           }</a>
<a name="4692"><span class="lineNum">    4692 </span>            : </a>
<a name="4693"><span class="lineNum">    4693 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="4694"><span class="lineNum">    4694 </span><span class="lineNoCov">          0 :                       {</span></a>
<a name="4695"><span class="lineNum">    4695 </span><span class="lineNoCov">          0 :                         printf (&quot;Error: Default reached in rebuildSymbolTable declaration = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</span></a>
<a name="4696"><span class="lineNum">    4696 </span><span class="lineNoCov">          0 :                         ROSE_ABORT();</span></a>
<a name="4697"><span class="lineNum">    4697 </span>            :                       }</a>
<a name="4698"><span class="lineNum">    4698 </span>            :                   }</a>
<a name="4699"><span class="lineNum">    4699 </span>            : </a>
<a name="4700"><span class="lineNum">    4700 </span><span class="lineCov">         18 :                ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="4701"><span class="lineNum">    4701 </span><span class="lineCov">         18 :                ROSE_ASSERT(symbolTable-&gt;get_table() != NULL);</span></a>
<a name="4702"><span class="lineNum">    4702 </span>            :              }</a>
<a name="4703"><span class="lineNum">    4703 </span>            :        // printf (&quot;DONE: Iterating through the declaration in this scope ... %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),get_name(*i).c_str());</a>
<a name="4704"><span class="lineNum">    4704 </span>            : </a>
<a name="4705"><span class="lineNum">    4705 </span>            :         }</a>
<a name="4706"><span class="lineNum">    4706 </span>            : </a>
<a name="4707"><span class="lineNum">    4707 </span><span class="lineCov">         15 :      ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="4708"><span class="lineNum">    4708 </span><span class="lineCov">         15 :      ROSE_ASSERT(symbolTable-&gt;get_table() != NULL);</span></a>
<a name="4709"><span class="lineNum">    4709 </span>            : </a>
<a name="4710"><span class="lineNum">    4710 </span>            : #if 0</a>
<a name="4711"><span class="lineNum">    4711 </span>            :      printf (&quot;Leaving SageInterface::rebuildSymbolTable(): fixup declarations in Symbol Table from %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4712"><span class="lineNum">    4712 </span>            : #endif</a>
<a name="4713"><span class="lineNum">    4713 </span>            : </a>
<a name="4714"><span class="lineNum">    4714 </span>            : #if 0</a>
<a name="4715"><span class="lineNum">    4715 </span>            :      printf (&quot;Symbol Table from %p = %s at: \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="4716"><span class="lineNum">    4716 </span>            :      scope-&gt;get_file_info()-&gt;display(&quot;Symbol Table Location&quot;);</a>
<a name="4717"><span class="lineNum">    4717 </span>            :      symbolTable-&gt;print(&quot;Called from SageInterface::rebuildSymbolTable()&quot;);</a>
<a name="4718"><span class="lineNum">    4718 </span>            : #endif</a>
<a name="4719"><span class="lineNum">    4719 </span>            :    }</a>
<a name="4720"><span class="lineNum">    4720 </span>            : </a>
<a name="4721"><span class="lineNum">    4721 </span>            : </a>
<a name="4722"><span class="lineNum">    4722 </span>            : // #ifndef USE_ROSE</a>
<a name="4723"><span class="lineNum">    4723 </span>            : </a>
<a name="4724"><span class="lineNum">    4724 </span>            : void</a>
<a name="4725"><span class="lineNum">    4725 </span><span class="lineCov">         19 : SageInterface::fixupReferencesToSymbols( const SgScopeStatement* this_scope,  SgScopeStatement* copy_scope, SgCopyHelp &amp; help )</span></a>
<a name="4726"><span class="lineNum">    4726 </span>            :    {</a>
<a name="4727"><span class="lineNum">    4727 </span>            :   // This function is called by the SageInterface::rebuildSymbolTable().</a>
<a name="4728"><span class="lineNum">    4728 </span>            :   // It resets references to old symbols to the new symbols (just built).</a>
<a name="4729"><span class="lineNum">    4729 </span>            :   // All pairs of old/new symbols are also saved in the object:</a>
<a name="4730"><span class="lineNum">    4730 </span>            :   //    SgCopyHelp::copiedNodeMapType copiedNodeMap</a>
<a name="4731"><span class="lineNum">    4731 </span>            : </a>
<a name="4732"><span class="lineNum">    4732 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="4733"><span class="lineNum">    4733 </span><span class="lineCov">         19 :      ROSE_ASSERT(this_scope != NULL);</span></a>
<a name="4734"><span class="lineNum">    4734 </span><span class="lineCov">         19 :      ROSE_ASSERT(copy_scope != NULL);</span></a>
<a name="4735"><span class="lineNum">    4735 </span>            : </a>
<a name="4736"><span class="lineNum">    4736 </span>            : #if 0</a>
<a name="4737"><span class="lineNum">    4737 </span>            :      printf (&quot;In fixupReferencesToSymbols(this_scope = %p = %s = %s, copy_scope = %p = %s = %s) \n&quot;,</a>
<a name="4738"><span class="lineNum">    4738 </span>            :           this_scope,this_scope-&gt;class_name().c_str(),get_name(this_scope).c_str(),</a>
<a name="4739"><span class="lineNum">    4739 </span>            :           copy_scope,copy_scope-&gt;class_name().c_str(),get_name(copy_scope).c_str());</a>
<a name="4740"><span class="lineNum">    4740 </span>            : #endif</a>
<a name="4741"><span class="lineNum">    4741 </span>            : </a>
<a name="4742"><span class="lineNum">    4742 </span><span class="lineCov">         19 :      SgSymbolTable* this_symbolTable = this_scope-&gt;get_symbol_table();</span></a>
<a name="4743"><span class="lineNum">    4743 </span><span class="lineCov">         19 :      SgSymbolTable* copy_symbolTable = copy_scope-&gt;get_symbol_table();</span></a>
<a name="4744"><span class="lineNum">    4744 </span>            : #if 0</a>
<a name="4745"><span class="lineNum">    4745 </span>            :      printf (&quot;Before fixup: this scope = %p = %s this_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,this_scope,this_scope-&gt;class_name().c_str(),this_symbolTable-&gt;get_table()-&gt;size());</a>
<a name="4746"><span class="lineNum">    4746 </span>            :      printf (&quot;Before fixup: copy scope = %p = %s copy_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,copy_scope,copy_scope-&gt;class_name().c_str(),copy_symbolTable-&gt;get_table()-&gt;size());</a>
<a name="4747"><span class="lineNum">    4747 </span>            : #endif</a>
<a name="4748"><span class="lineNum">    4748 </span>            : </a>
<a name="4749"><span class="lineNum">    4749 </span>            :   // DQ (3/4/2009): For now just output a warning, but this might be a more serious problem.</a>
<a name="4750"><span class="lineNum">    4750 </span>            :   // Since the symbol table size of the copy is larger than that of the original it might</a>
<a name="4751"><span class="lineNum">    4751 </span>            :   // be that a symbol is enterted twice by the copy mechanism.  If so I want to fix this.</a>
<a name="4752"><span class="lineNum">    4752 </span><span class="lineCov">         19 :      if (this_symbolTable-&gt;get_table()-&gt;size() != copy_symbolTable-&gt;get_table()-&gt;size())</span></a>
<a name="4753"><span class="lineNum">    4753 </span>            :         {</a>
<a name="4754"><span class="lineNum">    4754 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="4755"><span class="lineNum">    4755 </span>            :               {</a>
<a name="4756"><span class="lineNum">    4756 </span><span class="lineNoCov">          0 :                printf (&quot;Before fixup: this scope = %p = %s this_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,this_scope,this_scope-&gt;class_name().c_str(),this_symbolTable-&gt;get_table()-&gt;size());</span></a>
<a name="4757"><span class="lineNum">    4757 </span><span class="lineNoCov">          0 :                printf (&quot;Before fixup: copy scope = %p = %s copy_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,copy_scope,copy_scope-&gt;class_name().c_str(),copy_symbolTable-&gt;get_table()-&gt;size());</span></a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineNoCov">          0 :                printf (&quot;Warning the symbols tables in these different scopes are different sizes \n&quot;);</span></a>
<a name="4759"><span class="lineNum">    4759 </span>            :              }</a>
<a name="4760"><span class="lineNum">    4760 </span>            :         }</a>
<a name="4761"><span class="lineNum">    4761 </span>            :   // ROSE_ASSERT(this_symbolTable-&gt;get_table()-&gt;size() &lt;= copy_symbolTable-&gt;get_table()-&gt;size());</a>
<a name="4762"><span class="lineNum">    4762 </span>            : </a>
<a name="4763"><span class="lineNum">    4763 </span><span class="lineCov">         19 :      SgSymbolTable::hash_iterator i = this_symbolTable-&gt;get_table()-&gt;begin();</span></a>
<a name="4764"><span class="lineNum">    4764 </span>            : </a>
<a name="4765"><span class="lineNum">    4765 </span>            :   // This is used to fixup the AST by resetting references to IR nodes (leveraged from AST merge).</a>
<a name="4766"><span class="lineNum">    4766 </span><span class="lineCov">         19 :      std::map&lt;SgNode*, SgNode*&gt; replacementMap;</span></a>
<a name="4767"><span class="lineNum">    4767 </span><span class="lineCov">         19 :      int counter = 0;</span></a>
<a name="4768"><span class="lineNum">    4768 </span><span class="lineCov">         41 :      while (i != this_symbolTable-&gt;get_table()-&gt;end())</span></a>
<a name="4769"><span class="lineNum">    4769 </span>            :         {</a>
<a name="4770"><span class="lineNum">    4770 </span><span class="lineCov">         22 :           ROSE_ASSERT ( isSgSymbol( (*i).second ) != NULL );</span></a>
<a name="4771"><span class="lineNum">    4771 </span>            : </a>
<a name="4772"><span class="lineNum">    4772 </span><span class="lineCov">         44 :           SgName name     = (*i).first;</span></a>
<a name="4773"><span class="lineNum">    4773 </span>            :        // SgSymbol* symbol = isSgSymbol((*i).second);</a>
<a name="4774"><span class="lineNum">    4774 </span><span class="lineCov">         22 :           SgSymbol* symbol = (*i).second;</span></a>
<a name="4775"><span class="lineNum">    4775 </span><span class="lineCov">         22 :           ROSE_ASSERT ( symbol != NULL );</span></a>
<a name="4776"><span class="lineNum">    4776 </span>            : </a>
<a name="4777"><span class="lineNum">    4777 </span><span class="lineCov">         22 :           SgSymbol* associated_symbol = NULL;</span></a>
<a name="4778"><span class="lineNum">    4778 </span>            : #if 0</a>
<a name="4779"><span class="lineNum">    4779 </span>            :           printf (&quot;Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) = %p sage_class_name() = %s \n&quot;,counter,i-&gt;first.str(),i-&gt;second,i-&gt;second-&gt;class_name().c_str());</a>
<a name="4780"><span class="lineNum">    4780 </span>            : #endif</a>
<a name="4781"><span class="lineNum">    4781 </span>            :        // Look for the associated symbol in the copy_scope's symbol table.</a>
<a name="4782"><span class="lineNum">    4782 </span><span class="lineCov">         22 :           SgSymbolTable::hash_iterator associated_symbol_iterator = copy_symbolTable-&gt;get_table()-&gt;find(name);</span></a>
<a name="4783"><span class="lineNum">    4783 </span>            : </a>
<a name="4784"><span class="lineNum">    4784 </span>            :        // Note that this is a multi-map and for C++ a number of symbols can have the same name</a>
<a name="4785"><span class="lineNum">    4785 </span>            :        // (though not the same type of symbol) so we have to iterator over the symbols of the</a>
<a name="4786"><span class="lineNum">    4786 </span>            :        // same name so that we can identify the associated symbol.</a>
<a name="4787"><span class="lineNum">    4787 </span><span class="lineCov">         44 :           while (associated_symbol_iterator != copy_symbolTable-&gt;get_table()-&gt;end() &amp;&amp; associated_symbol_iterator-&gt;first == name)</span></a>
<a name="4788"><span class="lineNum">    4788 </span>            :              {</a>
<a name="4789"><span class="lineNum">    4789 </span><span class="lineCov">         22 :                if ( associated_symbol_iterator-&gt;second-&gt;variantT() == symbol-&gt;variantT() )</span></a>
<a name="4790"><span class="lineNum">    4790 </span>            :                   {</a>
<a name="4791"><span class="lineNum">    4791 </span><span class="lineCov">         22 :                     associated_symbol = associated_symbol_iterator-&gt;second;</span></a>
<a name="4792"><span class="lineNum">    4792 </span>            :                   }</a>
<a name="4793"><span class="lineNum">    4793 </span>            : </a>
<a name="4794"><span class="lineNum">    4794 </span><span class="lineCov">         22 :                associated_symbol_iterator++;</span></a>
<a name="4795"><span class="lineNum">    4795 </span>            :              }</a>
<a name="4796"><span class="lineNum">    4796 </span>            : </a>
<a name="4797"><span class="lineNum">    4797 </span><span class="lineCov">         22 :           if (associated_symbol != NULL)</span></a>
<a name="4798"><span class="lineNum">    4798 </span>            :              {</a>
<a name="4799"><span class="lineNum">    4799 </span><span class="lineCov">         22 :                ROSE_ASSERT ( associated_symbol != NULL );</span></a>
<a name="4800"><span class="lineNum">    4800 </span>            : </a>
<a name="4801"><span class="lineNum">    4801 </span>            :             // Check to make sure that this is correct</a>
<a name="4802"><span class="lineNum">    4802 </span><span class="lineCov">         22 :                ROSE_ASSERT(copy_scope-&gt;symbol_exists(associated_symbol) == true);</span></a>
<a name="4803"><span class="lineNum">    4803 </span>            : </a>
<a name="4804"><span class="lineNum">    4804 </span>            :             // Add the SgGlobal referenece to the replacementMap</a>
<a name="4805"><span class="lineNum">    4805 </span>            :             // replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(originalFileGlobalScope,scope));</a>
<a name="4806"><span class="lineNum">    4806 </span>            :             // DQ (23/1/2009): Find the reference to symbol and replace it with associated_symbol.</a>
<a name="4807"><span class="lineNum">    4807 </span><span class="lineCov">         22 :                replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(symbol,associated_symbol));</span></a>
<a name="4808"><span class="lineNum">    4808 </span>            : </a>
<a name="4809"><span class="lineNum">    4809 </span>            :             // DQ (3/1/2009): This is backwards</a>
<a name="4810"><span class="lineNum">    4810 </span>            :             // replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(associated_symbol,symbol));</a>
<a name="4811"><span class="lineNum">    4811 </span>            : </a>
<a name="4812"><span class="lineNum">    4812 </span>            :             // DQ (3/2/2009): accumulate the symbol pair into the SgCopyHelp object (to support the outliner).</a>
<a name="4813"><span class="lineNum">    4813 </span>            :             // Actually this should also improve the robustness of the outliner.</a>
<a name="4814"><span class="lineNum">    4814 </span><span class="lineCov">         22 :                help.get_copiedNodeMap().insert(pair&lt;const SgNode*,SgNode*&gt;(symbol,associated_symbol));</span></a>
<a name="4815"><span class="lineNum">    4815 </span>            :              }</a>
<a name="4816"><span class="lineNum">    4816 </span>            :             else</a>
<a name="4817"><span class="lineNum">    4817 </span>            :              {</a>
<a name="4818"><span class="lineNum">    4818 </span>            :             // DQ (3/4/2009): This case was broken out because copytest2007_14.C fails here.</a>
<a name="4819"><span class="lineNum">    4819 </span><span class="lineNoCov">          0 :                if (SgProject::get_verbose() &gt; 0)</span></a>
<a name="4820"><span class="lineNum">    4820 </span>            :                   {</a>
<a name="4821"><span class="lineNum">    4821 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) = %p sage_class_name() = %s \n&quot;,counter,i-&gt;first.str(),i-&gt;second,i-&gt;second-&gt;class_name().c_str());</span></a>
<a name="4822"><span class="lineNum">    4822 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: associated_symbol == NULL, need to investigate this (ignoring for now) \n&quot;);</span></a>
<a name="4823"><span class="lineNum">    4823 </span>            :                   }</a>
<a name="4824"><span class="lineNum">    4824 </span>            :              }</a>
<a name="4825"><span class="lineNum">    4825 </span>            : </a>
<a name="4826"><span class="lineNum">    4826 </span><span class="lineCov">         22 :           counter++;</span></a>
<a name="4827"><span class="lineNum">    4827 </span>            : </a>
<a name="4828"><span class="lineNum">    4828 </span><span class="lineCov">         22 :           i++;</span></a>
<a name="4829"><span class="lineNum">    4829 </span>            :         }</a>
<a name="4830"><span class="lineNum">    4830 </span>            : </a>
<a name="4831"><span class="lineNum">    4831 </span>            : #if 0</a>
<a name="4832"><span class="lineNum">    4832 </span>            :      printf (&quot;\n\n************************************************************\n&quot;);</a>
<a name="4833"><span class="lineNum">    4833 </span>            :      printf (&quot;fixupReferencesToSymbols(this_scope = %p copy_scope = %p = %s = %s): calling Utils::edgePointerReplacement() \n&quot;,this_scope,copy_scope,copy_scope-&gt;class_name().c_str(),get_name(copy_scope).c_str());</a>
<a name="4834"><span class="lineNum">    4834 </span>            : #endif</a>
<a name="4835"><span class="lineNum">    4835 </span>            : </a>
<a name="4836"><span class="lineNum">    4836 </span><span class="lineCov">         19 :      Rose::AST::Utils::edgePointerReplacement(copy_scope,replacementMap);</span></a>
<a name="4837"><span class="lineNum">    4837 </span>            : </a>
<a name="4838"><span class="lineNum">    4838 </span>            : #if 0</a>
<a name="4839"><span class="lineNum">    4839 </span>            :      printf (&quot;fixupReferencesToSymbols(): calling Utils::edgePointerReplacement(): DONE \n&quot;);</a>
<a name="4840"><span class="lineNum">    4840 </span>            :      printf (&quot;************************************************************\n\n&quot;);</a>
<a name="4841"><span class="lineNum">    4841 </span>            : </a>
<a name="4842"><span class="lineNum">    4842 </span>            :      printf (&quot;\n\n After replacementMapTraversal(): intermediateDeleteSet: \n&quot;);</a>
<a name="4843"><span class="lineNum">    4843 </span>            :      displaySet(intermediateDeleteSet,&quot;After Utils::edgePointerReplacement&quot;);</a>
<a name="4844"><span class="lineNum">    4844 </span>            : </a>
<a name="4845"><span class="lineNum">    4845 </span>            :      printf (&quot;After fixup: this_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,this_symbolTable-&gt;get_table()-&gt;size());</a>
<a name="4846"><span class="lineNum">    4846 </span>            :      printf (&quot;After fixup: copy_symbolTable-&gt;get_table()-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,copy_symbolTable-&gt;get_table()-&gt;size());</a>
<a name="4847"><span class="lineNum">    4847 </span>            : #endif</a>
<a name="4848"><span class="lineNum">    4848 </span>            : </a>
<a name="4849"><span class="lineNum">    4849 </span>            :   // DQ (3/1/2009): find a case where this code is tested.</a>
<a name="4850"><span class="lineNum">    4850 </span>            :   // ROSE_ASSERT(this_symbolTable-&gt;get_table()-&gt;size() == 0);</a>
<a name="4851"><span class="lineNum">    4851 </span>            :   // ROSE_ASSERT(isSgClassDefinition(copy_scope) == NULL);</a>
<a name="4852"><span class="lineNum">    4852 </span>            : #endif</a>
<a name="4853"><span class="lineNum">    4853 </span>            : </a>
<a name="4854"><span class="lineNum">    4854 </span>            : #if 0</a>
<a name="4855"><span class="lineNum">    4855 </span>            :      printf (&quot;Exiting as a test in fixupReferencesToSymbols() \n&quot;);</a>
<a name="4856"><span class="lineNum">    4856 </span>            :      ROSE_ABORT();</a>
<a name="4857"><span class="lineNum">    4857 </span>            : #endif</a>
<a name="4858"><span class="lineNum">    4858 </span><span class="lineCov">         19 :    }</span></a>
<a name="4859"><span class="lineNum">    4859 </span>            : </a>
<a name="4860"><span class="lineNum">    4860 </span>            : // #endif</a>
<a name="4861"><span class="lineNum">    4861 </span>            : </a>
<a name="4862"><span class="lineNum">    4862 </span>            : #ifndef USE_ROSE</a>
<a name="4863"><span class="lineNum">    4863 </span>            : </a>
<a name="4864"><span class="lineNum">    4864 </span>            : std::vector&lt;SgFile*&gt;</a>
<a name="4865"><span class="lineNum">    4865 </span><span class="lineNoCov">          0 : SageInterface::generateFileList()</span></a>
<a name="4866"><span class="lineNum">    4866 </span>            :    {</a>
<a name="4867"><span class="lineNum">    4867 </span>            :   // This function uses a memory pool traversal specific to the SgFile IR nodes</a>
<a name="4868"><span class="lineNum">    4868 </span><span class="lineNoCov">          0 :      class FileTraversal : public ROSE_VisitTraversal</span></a>
<a name="4869"><span class="lineNum">    4869 </span>            :         {</a>
<a name="4870"><span class="lineNum">    4870 </span>            :           public:</a>
<a name="4871"><span class="lineNum">    4871 </span>            :                vector&lt;SgFile*&gt; fileList;</a>
<a name="4872"><span class="lineNum">    4872 </span><span class="lineNoCov">          0 :                void visit ( SgNode* node)</span></a>
<a name="4873"><span class="lineNum">    4873 </span>            :                   {</a>
<a name="4874"><span class="lineNum">    4874 </span><span class="lineNoCov">          0 :                     SgFile* file = isSgFile(node);</span></a>
<a name="4875"><span class="lineNum">    4875 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(file != NULL);</span></a>
<a name="4876"><span class="lineNum">    4876 </span><span class="lineNoCov">          0 :                     if (file != NULL)</span></a>
<a name="4877"><span class="lineNum">    4877 </span>            :                        {</a>
<a name="4878"><span class="lineNum">    4878 </span><span class="lineNoCov">          0 :                          fileList.push_back(file);</span></a>
<a name="4879"><span class="lineNum">    4879 </span>            :                        }</a>
<a name="4880"><span class="lineNum">    4880 </span><span class="lineNoCov">          0 :                   };</span></a>
<a name="4881"><span class="lineNum">    4881 </span>            : </a>
<a name="4882"><span class="lineNum">    4882 </span><span class="lineNoCov">          0 :               virtual ~FileTraversal() {}</span></a>
<a name="4883"><span class="lineNum">    4883 </span>            :         };</a>
<a name="4884"><span class="lineNum">    4884 </span>            : </a>
<a name="4885"><span class="lineNum">    4885 </span><span class="lineNoCov">          0 :      FileTraversal fileTraversal;</span></a>
<a name="4886"><span class="lineNum">    4886 </span>            : </a>
<a name="4887"><span class="lineNum">    4887 </span>            :   // traverse just the SgFile nodes (both the SgSourceFile and SgBinaryComposite IR nodes)!</a>
<a name="4888"><span class="lineNum">    4888 </span>            :   // SgFile::visitRepresentativeNode(fileTraversal);</a>
<a name="4889"><span class="lineNum">    4889 </span><span class="lineNoCov">          0 :      SgSourceFile::traverseMemoryPoolNodes(fileTraversal);</span></a>
<a name="4890"><span class="lineNum">    4890 </span>            :   // This would alternatively traverse all IR nodes in thememory pool!</a>
<a name="4891"><span class="lineNum">    4891 </span>            :   // fileTraversal.traverseMemoryPool();</a>
<a name="4892"><span class="lineNum">    4892 </span>            : </a>
<a name="4893"><span class="lineNum">    4893 </span>            :   // TV (06/24/2013): This fail when calling SageBuilder::buildVariableDeclaration(...) without any file created.</a>
<a name="4894"><span class="lineNum">    4894 </span>            :   // DQ (10/11/2014): This is allowed to be empty (required for new aterm support).</a>
<a name="4895"><span class="lineNum">    4895 </span>            :   // ROSE_ASSERT(fileTraversal.fileList.empty() == false);</a>
<a name="4896"><span class="lineNum">    4896 </span>            : </a>
<a name="4897"><span class="lineNum">    4897 </span><span class="lineNoCov">          0 :      return fileTraversal.fileList;</span></a>
<a name="4898"><span class="lineNum">    4898 </span>            :    }</a>
<a name="4899"><span class="lineNum">    4899 </span>            : </a>
<a name="4900"><span class="lineNum">    4900 </span>            : #endif</a>
<a name="4901"><span class="lineNum">    4901 </span>            : </a>
<a name="4902"><span class="lineNum">    4902 </span>            : // #ifndef USE_ROSE</a>
<a name="4903"><span class="lineNum">    4903 </span>            : </a>
<a name="4904"><span class="lineNum">    4904 </span>            : // DQ (4/17/2015): I think this function should be removed since it interferes</a>
<a name="4905"><span class="lineNum">    4905 </span>            : // with the concept of having more than one SgProject node.</a>
<a name="4906"><span class="lineNum">    4906 </span>            : // This function uses a memory pool traversal specific to the SgProject IR nodes</a>
<a name="4907"><span class="lineNum">    4907 </span>            : SgProject*</a>
<a name="4908"><span class="lineNum">    4908 </span><span class="lineCov">         80 : SageInterface::getProject()</span></a>
<a name="4909"><span class="lineNum">    4909 </span>            : {</a>
<a name="4910"><span class="lineNum">    4910 </span>            : #if 0</a>
<a name="4911"><span class="lineNum">    4911 </span>            :   class ProjectTraversal : public ROSE_VisitTraversal</a>
<a name="4912"><span class="lineNum">    4912 </span>            :   {</a>
<a name="4913"><span class="lineNum">    4913 </span>            :     public:</a>
<a name="4914"><span class="lineNum">    4914 </span>            :       SgProject * project;</a>
<a name="4915"><span class="lineNum">    4915 </span>            :       void visit ( SgNode* node)</a>
<a name="4916"><span class="lineNum">    4916 </span>            :       {</a>
<a name="4917"><span class="lineNum">    4917 </span>            :         project = isSgProject(node);</a>
<a name="4918"><span class="lineNum">    4918 </span>            :         ROSE_ASSERT(project!= NULL);</a>
<a name="4919"><span class="lineNum">    4919 </span>            :       };</a>
<a name="4920"><span class="lineNum">    4920 </span>            :       virtual ~ProjectTraversal() {}</a>
<a name="4921"><span class="lineNum">    4921 </span>            :   };</a>
<a name="4922"><span class="lineNum">    4922 </span>            : </a>
<a name="4923"><span class="lineNum">    4923 </span>            :   ProjectTraversal projectTraversal;</a>
<a name="4924"><span class="lineNum">    4924 </span>            :   SgProject::visitRepresentativeNode(projectTraversal);</a>
<a name="4925"><span class="lineNum">    4925 </span>            :   return projectTraversal.project;</a>
<a name="4926"><span class="lineNum">    4926 </span>            : #endif</a>
<a name="4927"><span class="lineNum">    4927 </span><span class="lineCov">        160 :   std::vector&lt;SgProject* &gt; resultlist = getSgNodeListFromMemoryPool&lt;SgProject&gt;();</span></a>
<a name="4928"><span class="lineNum">    4928 </span><span class="lineCov">         80 :   if (resultlist.empty())</span></a>
<a name="4929"><span class="lineNum">    4929 </span>            :       return NULL;</a>
<a name="4930"><span class="lineNum">    4930 </span><span class="lineCov">         80 :   ROSE_ASSERT(resultlist.size()==1);</span></a>
<a name="4931"><span class="lineNum">    4931 </span><span class="lineCov">         80 :   return resultlist[0];</span></a>
<a name="4932"><span class="lineNum">    4932 </span>            : }</a>
<a name="4933"><span class="lineNum">    4933 </span>            : </a>
<a name="4934"><span class="lineNum">    4934 </span>            : SgProject*</a>
<a name="4935"><span class="lineNum">    4935 </span><span class="lineCov">    6638780 : SageInterface::getProject(const SgNode * node) {</span></a>
<a name="4936"><span class="lineNum">    4936 </span><span class="lineCov">    6638780 :     return getEnclosingNode&lt;SgProject&gt;(node, true /*includingSelf*/);</span></a>
<a name="4937"><span class="lineNum">    4937 </span>            : }</a>
<a name="4938"><span class="lineNum">    4938 </span>            : </a>
<a name="4939"><span class="lineNum">    4939 </span><span class="lineCov">      50745 : SgFunctionDeclaration* SageInterface::getDeclarationOfNamedFunction(SgExpression* func) {</span></a>
<a name="4940"><span class="lineNum">    4940 </span><span class="lineCov">      50745 :   SgFunctionDeclaration * ret = NULL;</span></a>
<a name="4941"><span class="lineNum">    4941 </span><span class="lineCov">      50745 :   if (isSgFunctionRefExp(func))</span></a>
<a name="4942"><span class="lineNum">    4942 </span>            :   {</a>
<a name="4943"><span class="lineNum">    4943 </span><span class="lineCov">        851 :     return isSgFunctionRefExp(func)-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="4944"><span class="lineNum">    4944 </span>            :   }</a>
<a name="4945"><span class="lineNum">    4945 </span><span class="lineCov">      49894 :   else if (isSgDotExp(func) || isSgArrowExp(func))</span></a>
<a name="4946"><span class="lineNum">    4946 </span>            :   {</a>
<a name="4947"><span class="lineNum">    4947 </span><span class="lineCov">       3627 :     SgExpression* func2 = isSgBinaryOp(func)-&gt;get_rhs_operand();</span></a>
<a name="4948"><span class="lineNum">    4948 </span><span class="lineCov">       3627 :     if (isSgMemberFunctionRefExp(func2))</span></a>
<a name="4949"><span class="lineNum">    4949 </span><span class="lineCov">        584 :       return isSgMemberFunctionRefExp(func2)-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="4950"><span class="lineNum">    4950 </span>            :     else</a>
<a name="4951"><span class="lineNum">    4951 </span>            :     {</a>
<a name="4952"><span class="lineNum">    4952 </span><span class="lineCov">       3763 :       cerr&lt;&lt;&quot;Warning in SageInterface::getDeclarationOfNamedFunction(): rhs operand of dot or arrow operations is not a member function, but a &quot;&lt;&lt;func2-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="4953"><span class="lineNum">    4953 </span>            :     }</a>
<a name="4954"><span class="lineNum">    4954 </span>            :   }</a>
<a name="4955"><span class="lineNum">    4955 </span>            : </a>
<a name="4956"><span class="lineNum">    4956 </span>            :   return ret;</a>
<a name="4957"><span class="lineNum">    4957 </span>            : }</a>
<a name="4958"><span class="lineNum">    4958 </span>            : </a>
<a name="4959"><span class="lineNum">    4959 </span><span class="lineNoCov">          0 : SgExpression* SageInterface::forallMaskExpression(SgForAllStatement* stmt) {</span></a>
<a name="4960"><span class="lineNum">    4960 </span><span class="lineNoCov">          0 :   SgExprListExp* el = stmt-&gt;get_forall_header();</span></a>
<a name="4961"><span class="lineNum">    4961 </span><span class="lineNoCov">          0 :   const SgExpressionPtrList&amp; ls = el-&gt;get_expressions();</span></a>
<a name="4962"><span class="lineNum">    4962 </span><span class="lineNoCov">          0 :   if (ls.empty()) return 0;</span></a>
<a name="4963"><span class="lineNum">    4963 </span><span class="lineNoCov">          0 :   if (isSgAssignOp(ls.back())) return 0;</span></a>
<a name="4964"><span class="lineNum">    4964 </span><span class="lineNoCov">          0 :   return ls.back();</span></a>
<a name="4965"><span class="lineNum">    4965 </span>            : }</a>
<a name="4966"><span class="lineNum">    4966 </span>            : </a>
<a name="4967"><span class="lineNum">    4967 </span>            : //Find all SgPntrArrRefExp under astNode, add the referenced dim_info SgVarRefExp (if any) into NodeList_t</a>
<a name="4968"><span class="lineNum">    4968 </span><span class="lineNoCov">          0 : void SageInterface::addVarRefExpFromArrayDimInfo(SgNode * astNode, Rose_STL_Container&lt;SgNode *&gt;&amp; NodeList_t)</span></a>
<a name="4969"><span class="lineNum">    4969 </span>            : {</a>
<a name="4970"><span class="lineNum">    4970 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (astNode != NULL);</span></a>
<a name="4971"><span class="lineNum">    4971 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt; arr_exp_list = NodeQuery::querySubTree(astNode,V_SgPntrArrRefExp);</span></a>
<a name="4972"><span class="lineNum">    4972 </span><span class="lineNoCov">          0 :   for (Rose_STL_Container&lt;SgNode*&gt;::iterator iter_0 = arr_exp_list.begin(); iter_0 !=arr_exp_list.end(); iter_0 ++)</span></a>
<a name="4973"><span class="lineNum">    4973 </span>            :   {</a>
<a name="4974"><span class="lineNum">    4974 </span><span class="lineNoCov">          0 :     SgPntrArrRefExp * arr_exp = isSgPntrArrRefExp(*iter_0);</span></a>
<a name="4975"><span class="lineNum">    4975 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (arr_exp != NULL);</span></a>
<a name="4976"><span class="lineNum">    4976 </span>            :     //printf(&quot;Debug: Found SgPntrArrRefExp :%p\n&quot;, arr_exp);</a>
<a name="4977"><span class="lineNum">    4977 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt; refList = NodeQuery::querySubTree(arr_exp-&gt;get_lhs_operand(),V_SgVarRefExp);</span></a>
<a name="4978"><span class="lineNum">    4978 </span><span class="lineNoCov">          0 :     for (Rose_STL_Container&lt;SgNode*&gt;::iterator iter = refList.begin(); iter !=refList.end(); iter ++)</span></a>
<a name="4979"><span class="lineNum">    4979 </span>            :     {</a>
<a name="4980"><span class="lineNum">    4980 </span><span class="lineNoCov">          0 :       SgVarRefExp* cur_ref = isSgVarRefExp(*iter);</span></a>
<a name="4981"><span class="lineNum">    4981 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (cur_ref != NULL);</span></a>
<a name="4982"><span class="lineNum">    4982 </span><span class="lineNoCov">          0 :       SgVariableSymbol * sym = cur_ref-&gt;get_symbol();</span></a>
<a name="4983"><span class="lineNum">    4983 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (sym != NULL);</span></a>
<a name="4984"><span class="lineNum">    4984 </span><span class="lineNoCov">          0 :       SgInitializedName * i_name = sym-&gt;get_declaration();</span></a>
<a name="4985"><span class="lineNum">    4985 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (i_name != NULL);</span></a>
<a name="4986"><span class="lineNum">    4986 </span><span class="lineNoCov">          0 :       SgArrayType * a_type = isSgArrayType(i_name-&gt;get_typeptr());</span></a>
<a name="4987"><span class="lineNum">    4987 </span><span class="lineNoCov">          0 :       if (a_type &amp;&amp; a_type-&gt;get_dim_info())</span></a>
<a name="4988"><span class="lineNum">    4988 </span>            :       {</a>
<a name="4989"><span class="lineNum">    4989 </span><span class="lineNoCov">          0 :         Rose_STL_Container&lt;SgNode*&gt; dim_ref_list = NodeQuery::querySubTree(a_type-&gt;get_dim_info(),V_SgVarRefExp);</span></a>
<a name="4990"><span class="lineNum">    4990 </span><span class="lineNoCov">          0 :         for (Rose_STL_Container&lt;SgNode*&gt;::iterator iter2 = dim_ref_list.begin(); iter2 != dim_ref_list.end(); iter2++)</span></a>
<a name="4991"><span class="lineNum">    4991 </span>            :         {</a>
<a name="4992"><span class="lineNum">    4992 </span><span class="lineNoCov">          0 :           SgVarRefExp* dim_ref = isSgVarRefExp(*iter2);</span></a>
<a name="4993"><span class="lineNum">    4993 </span>            :           //printf(&quot;Debug: Found indirect SgVarRefExp as part of array dimension declaration:%s\n&quot;, dim_ref-&gt;get_symbol()-&gt;get_name().str());</a>
<a name="4994"><span class="lineNum">    4994 </span><span class="lineNoCov">          0 :           NodeList_t.push_back(dim_ref);</span></a>
<a name="4995"><span class="lineNum">    4995 </span>            :         }</a>
<a name="4996"><span class="lineNum">    4996 </span>            :       }</a>
<a name="4997"><span class="lineNum">    4997 </span>            :     }</a>
<a name="4998"><span class="lineNum">    4998 </span>            :   } // end for</a>
<a name="4999"><span class="lineNum">    4999 </span><span class="lineNoCov">          0 : }</span></a>
<a name="5000"><span class="lineNum">    5000 </span>            : </a>
<a name="5001"><span class="lineNum">    5001 </span>            : // DQ (11/25/2020): This disables these non-inlined functions in favor of</a>
<a name="5002"><span class="lineNum">    5002 </span>            : // inlined versions of the functions in the sageInterface.h (header file).</a>
<a name="5003"><span class="lineNum">    5003 </span>            : #if (INLINE_OPTIMIZED_IS_LANGUAGE_KIND_FUNCTIONS == 0)</a>
<a name="5004"><span class="lineNum">    5004 </span>            : bool</a>
<a name="5005"><span class="lineNum">    5005 </span>            : SageInterface::is_C_language()</a>
<a name="5006"><span class="lineNum">    5006 </span>            :    {</a>
<a name="5007"><span class="lineNum">    5007 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5008"><span class="lineNum">    5008 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5009"><span class="lineNum">    5009 </span>            :      return Rose::is_C_language;</a>
<a name="5010"><span class="lineNum">    5010 </span>            : #else</a>
<a name="5011"><span class="lineNum">    5011 </span>            :      bool returnValue = false;</a>
<a name="5012"><span class="lineNum">    5012 </span>            : </a>
<a name="5013"><span class="lineNum">    5013 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5014"><span class="lineNum">    5014 </span>            : </a>
<a name="5015"><span class="lineNum">    5015 </span>            :      int size = (int)fileList.size();</a>
<a name="5016"><span class="lineNum">    5016 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5017"><span class="lineNum">    5017 </span>            :         {</a>
<a name="5018"><span class="lineNum">    5018 </span>            :           if (fileList[i]-&gt;get_C_only() == true)</a>
<a name="5019"><span class="lineNum">    5019 </span>            :                returnValue = true;</a>
<a name="5020"><span class="lineNum">    5020 </span>            :         }</a>
<a name="5021"><span class="lineNum">    5021 </span>            : </a>
<a name="5022"><span class="lineNum">    5022 </span>            :      return returnValue;</a>
<a name="5023"><span class="lineNum">    5023 </span>            : #endif</a>
<a name="5024"><span class="lineNum">    5024 </span>            :    }</a>
<a name="5025"><span class="lineNum">    5025 </span>            : </a>
<a name="5026"><span class="lineNum">    5026 </span>            : bool</a>
<a name="5027"><span class="lineNum">    5027 </span>            : SageInterface::is_OpenMP_language()</a>
<a name="5028"><span class="lineNum">    5028 </span>            :    {</a>
<a name="5029"><span class="lineNum">    5029 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5030"><span class="lineNum">    5030 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5031"><span class="lineNum">    5031 </span>            :      return Rose::is_OpenMP_language;</a>
<a name="5032"><span class="lineNum">    5032 </span>            : #else</a>
<a name="5033"><span class="lineNum">    5033 </span>            :      bool returnValue = false;</a>
<a name="5034"><span class="lineNum">    5034 </span>            : </a>
<a name="5035"><span class="lineNum">    5035 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5036"><span class="lineNum">    5036 </span>            : </a>
<a name="5037"><span class="lineNum">    5037 </span>            :      int size = (int)fileList.size();</a>
<a name="5038"><span class="lineNum">    5038 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5039"><span class="lineNum">    5039 </span>            :         {</a>
<a name="5040"><span class="lineNum">    5040 </span>            :           if (fileList[i]-&gt;get_openmp() == true)</a>
<a name="5041"><span class="lineNum">    5041 </span>            :                returnValue = true;</a>
<a name="5042"><span class="lineNum">    5042 </span>            :         }</a>
<a name="5043"><span class="lineNum">    5043 </span>            : </a>
<a name="5044"><span class="lineNum">    5044 </span>            :      return returnValue;</a>
<a name="5045"><span class="lineNum">    5045 </span>            : #endif</a>
<a name="5046"><span class="lineNum">    5046 </span>            :    }</a>
<a name="5047"><span class="lineNum">    5047 </span>            : </a>
<a name="5048"><span class="lineNum">    5048 </span>            : bool</a>
<a name="5049"><span class="lineNum">    5049 </span>            : SageInterface::is_UPC_language()</a>
<a name="5050"><span class="lineNum">    5050 </span>            :    {</a>
<a name="5051"><span class="lineNum">    5051 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5052"><span class="lineNum">    5052 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5053"><span class="lineNum">    5053 </span>            :      return Rose::is_UPC_language;</a>
<a name="5054"><span class="lineNum">    5054 </span>            : #else</a>
<a name="5055"><span class="lineNum">    5055 </span>            :      bool returnValue = false;</a>
<a name="5056"><span class="lineNum">    5056 </span>            : </a>
<a name="5057"><span class="lineNum">    5057 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5058"><span class="lineNum">    5058 </span>            : </a>
<a name="5059"><span class="lineNum">    5059 </span>            :      int size = (int)fileList.size();</a>
<a name="5060"><span class="lineNum">    5060 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5061"><span class="lineNum">    5061 </span>            :         {</a>
<a name="5062"><span class="lineNum">    5062 </span>            :           if (fileList[i]-&gt;get_UPC_only() == true)</a>
<a name="5063"><span class="lineNum">    5063 </span>            :                returnValue = true;</a>
<a name="5064"><span class="lineNum">    5064 </span>            :         }</a>
<a name="5065"><span class="lineNum">    5065 </span>            : </a>
<a name="5066"><span class="lineNum">    5066 </span>            :      return returnValue;</a>
<a name="5067"><span class="lineNum">    5067 </span>            : #endif</a>
<a name="5068"><span class="lineNum">    5068 </span>            :    }</a>
<a name="5069"><span class="lineNum">    5069 </span>            : </a>
<a name="5070"><span class="lineNum">    5070 </span>            : //FMZ</a>
<a name="5071"><span class="lineNum">    5071 </span>            : bool</a>
<a name="5072"><span class="lineNum">    5072 </span>            : SageInterface::is_CAF_language()</a>
<a name="5073"><span class="lineNum">    5073 </span>            :    {</a>
<a name="5074"><span class="lineNum">    5074 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5075"><span class="lineNum">    5075 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5076"><span class="lineNum">    5076 </span>            :      return Rose::is_CAF_language;</a>
<a name="5077"><span class="lineNum">    5077 </span>            : #else</a>
<a name="5078"><span class="lineNum">    5078 </span>            :      bool returnValue = false;</a>
<a name="5079"><span class="lineNum">    5079 </span>            : </a>
<a name="5080"><span class="lineNum">    5080 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5081"><span class="lineNum">    5081 </span>            : </a>
<a name="5082"><span class="lineNum">    5082 </span>            :      int size = (int)fileList.size();</a>
<a name="5083"><span class="lineNum">    5083 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5084"><span class="lineNum">    5084 </span>            :         {</a>
<a name="5085"><span class="lineNum">    5085 </span>            :           if (fileList[i]-&gt;get_CoArrayFortran_only()==true)</a>
<a name="5086"><span class="lineNum">    5086 </span>            :                returnValue = true;</a>
<a name="5087"><span class="lineNum">    5087 </span>            :         }</a>
<a name="5088"><span class="lineNum">    5088 </span>            : </a>
<a name="5089"><span class="lineNum">    5089 </span>            :      return returnValue;</a>
<a name="5090"><span class="lineNum">    5090 </span>            : #endif</a>
<a name="5091"><span class="lineNum">    5091 </span>            :    }</a>
<a name="5092"><span class="lineNum">    5092 </span>            : </a>
<a name="5093"><span class="lineNum">    5093 </span>            : </a>
<a name="5094"><span class="lineNum">    5094 </span>            : // true if any of upc_threads is set to &gt;0 via command line: -rose:upc_threads n</a>
<a name="5095"><span class="lineNum">    5095 </span>            : bool</a>
<a name="5096"><span class="lineNum">    5096 </span>            : SageInterface::is_UPC_dynamic_threads()</a>
<a name="5097"><span class="lineNum">    5097 </span>            :    {</a>
<a name="5098"><span class="lineNum">    5098 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5099"><span class="lineNum">    5099 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5100"><span class="lineNum">    5100 </span>            :      return Rose::is_UPC_dynamic_threads;</a>
<a name="5101"><span class="lineNum">    5101 </span>            : #else</a>
<a name="5102"><span class="lineNum">    5102 </span>            :      bool returnValue = false;</a>
<a name="5103"><span class="lineNum">    5103 </span>            : </a>
<a name="5104"><span class="lineNum">    5104 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5105"><span class="lineNum">    5105 </span>            : </a>
<a name="5106"><span class="lineNum">    5106 </span>            :      int size = (int)fileList.size();</a>
<a name="5107"><span class="lineNum">    5107 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5108"><span class="lineNum">    5108 </span>            :         {</a>
<a name="5109"><span class="lineNum">    5109 </span>            :           if (fileList[i]-&gt;get_upc_threads() &gt; 0)</a>
<a name="5110"><span class="lineNum">    5110 </span>            :                returnValue = true;</a>
<a name="5111"><span class="lineNum">    5111 </span>            :         }</a>
<a name="5112"><span class="lineNum">    5112 </span>            : </a>
<a name="5113"><span class="lineNum">    5113 </span>            :      return returnValue;</a>
<a name="5114"><span class="lineNum">    5114 </span>            : #endif</a>
<a name="5115"><span class="lineNum">    5115 </span>            :    }</a>
<a name="5116"><span class="lineNum">    5116 </span>            : </a>
<a name="5117"><span class="lineNum">    5117 </span>            : </a>
<a name="5118"><span class="lineNum">    5118 </span>            : </a>
<a name="5119"><span class="lineNum">    5119 </span>            : bool</a>
<a name="5120"><span class="lineNum">    5120 </span>            : SageInterface::is_C99_language()</a>
<a name="5121"><span class="lineNum">    5121 </span>            :    {</a>
<a name="5122"><span class="lineNum">    5122 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5123"><span class="lineNum">    5123 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5124"><span class="lineNum">    5124 </span>            :      return Rose::is_C99_language;</a>
<a name="5125"><span class="lineNum">    5125 </span>            : #else</a>
<a name="5126"><span class="lineNum">    5126 </span>            :      bool returnValue = false;</a>
<a name="5127"><span class="lineNum">    5127 </span>            : </a>
<a name="5128"><span class="lineNum">    5128 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5129"><span class="lineNum">    5129 </span>            : </a>
<a name="5130"><span class="lineNum">    5130 </span>            :      int size = (int)fileList.size();</a>
<a name="5131"><span class="lineNum">    5131 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5132"><span class="lineNum">    5132 </span>            :         {</a>
<a name="5133"><span class="lineNum">    5133 </span>            :           if (fileList[i]-&gt;get_C99_only() == true)</a>
<a name="5134"><span class="lineNum">    5134 </span>            :                returnValue = true;</a>
<a name="5135"><span class="lineNum">    5135 </span>            :         }</a>
<a name="5136"><span class="lineNum">    5136 </span>            : </a>
<a name="5137"><span class="lineNum">    5137 </span>            :      return returnValue;</a>
<a name="5138"><span class="lineNum">    5138 </span>            : #endif</a>
<a name="5139"><span class="lineNum">    5139 </span>            :    }</a>
<a name="5140"><span class="lineNum">    5140 </span>            : </a>
<a name="5141"><span class="lineNum">    5141 </span>            : bool</a>
<a name="5142"><span class="lineNum">    5142 </span>            : SageInterface::is_Cxx_language()</a>
<a name="5143"><span class="lineNum">    5143 </span>            :    {</a>
<a name="5144"><span class="lineNum">    5144 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5145"><span class="lineNum">    5145 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5146"><span class="lineNum">    5146 </span>            :      return Rose::is_Cxx_language;</a>
<a name="5147"><span class="lineNum">    5147 </span>            : #else</a>
<a name="5148"><span class="lineNum">    5148 </span>            :      bool returnValue = false;</a>
<a name="5149"><span class="lineNum">    5149 </span>            : </a>
<a name="5150"><span class="lineNum">    5150 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5151"><span class="lineNum">    5151 </span>            : </a>
<a name="5152"><span class="lineNum">    5152 </span>            :      int size = (int)fileList.size();</a>
<a name="5153"><span class="lineNum">    5153 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5154"><span class="lineNum">    5154 </span>            :         {</a>
<a name="5155"><span class="lineNum">    5155 </span>            :        // DQ (8/19/2007): Make sure this is not a Fortran code!</a>
<a name="5156"><span class="lineNum">    5156 </span>            :        // if (fileList[i]-&gt;get_C99_only() == false &amp;&amp; fileList[i]-&gt;get_C_only() == false)</a>
<a name="5157"><span class="lineNum">    5157 </span>            :        // if (fileList[i]-&gt;get_Fortran_only() == false &amp;&amp; fileList[i]-&gt;get_C99_only() == false &amp;&amp; fileList[i]-&gt;get_C_only() == false &amp;&amp; fileList[i]-&gt;get_binary_only() == false)</a>
<a name="5158"><span class="lineNum">    5158 </span>            :           if (fileList[i]-&gt;get_Cxx_only() == true)</a>
<a name="5159"><span class="lineNum">    5159 </span>            :              {</a>
<a name="5160"><span class="lineNum">    5160 </span>            :             // ROSE_ASSERT(fileList[i]-&gt;get_Cxx_only() == true);</a>
<a name="5161"><span class="lineNum">    5161 </span>            :                ROSE_ASSERT(fileList[i]-&gt;get_Fortran_only() == false &amp;&amp; fileList[i]-&gt;get_C99_only() == false &amp;&amp; fileList[i]-&gt;get_C_only() == false);</a>
<a name="5162"><span class="lineNum">    5162 </span>            : </a>
<a name="5163"><span class="lineNum">    5163 </span>            :                returnValue = true;</a>
<a name="5164"><span class="lineNum">    5164 </span>            :              }</a>
<a name="5165"><span class="lineNum">    5165 </span>            :         }</a>
<a name="5166"><span class="lineNum">    5166 </span>            : </a>
<a name="5167"><span class="lineNum">    5167 </span>            :      return returnValue;</a>
<a name="5168"><span class="lineNum">    5168 </span>            : #endif</a>
<a name="5169"><span class="lineNum">    5169 </span>            :    }</a>
<a name="5170"><span class="lineNum">    5170 </span>            : </a>
<a name="5171"><span class="lineNum">    5171 </span>            : bool</a>
<a name="5172"><span class="lineNum">    5172 </span>            : SageInterface::is_Fortran_language()</a>
<a name="5173"><span class="lineNum">    5173 </span>            :    {</a>
<a name="5174"><span class="lineNum">    5174 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5175"><span class="lineNum">    5175 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5176"><span class="lineNum">    5176 </span>            :      return Rose::is_Fortran_language;</a>
<a name="5177"><span class="lineNum">    5177 </span>            : #else</a>
<a name="5178"><span class="lineNum">    5178 </span>            :      bool returnValue = false;</a>
<a name="5179"><span class="lineNum">    5179 </span>            : </a>
<a name="5180"><span class="lineNum">    5180 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5181"><span class="lineNum">    5181 </span>            : </a>
<a name="5182"><span class="lineNum">    5182 </span>            :      int size = (int)fileList.size();</a>
<a name="5183"><span class="lineNum">    5183 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5184"><span class="lineNum">    5184 </span>            :         {</a>
<a name="5185"><span class="lineNum">    5185 </span>            :           if (fileList[i]-&gt;get_Fortran_only() == true)</a>
<a name="5186"><span class="lineNum">    5186 </span>            :                returnValue = true;</a>
<a name="5187"><span class="lineNum">    5187 </span>            :         }</a>
<a name="5188"><span class="lineNum">    5188 </span>            : </a>
<a name="5189"><span class="lineNum">    5189 </span>            :      return returnValue;</a>
<a name="5190"><span class="lineNum">    5190 </span>            : #endif</a>
<a name="5191"><span class="lineNum">    5191 </span>            :    }</a>
<a name="5192"><span class="lineNum">    5192 </span>            : </a>
<a name="5193"><span class="lineNum">    5193 </span>            : bool</a>
<a name="5194"><span class="lineNum">    5194 </span>            : SageInterface::is_Cuda_language()</a>
<a name="5195"><span class="lineNum">    5195 </span>            :    {</a>
<a name="5196"><span class="lineNum">    5196 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5197"><span class="lineNum">    5197 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5198"><span class="lineNum">    5198 </span>            :      return Rose::is_Cuda_language;</a>
<a name="5199"><span class="lineNum">    5199 </span>            : #else</a>
<a name="5200"><span class="lineNum">    5200 </span>            :      bool returnValue = false;</a>
<a name="5201"><span class="lineNum">    5201 </span>            : </a>
<a name="5202"><span class="lineNum">    5202 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5203"><span class="lineNum">    5203 </span>            : </a>
<a name="5204"><span class="lineNum">    5204 </span>            :      int size = (int)fileList.size();</a>
<a name="5205"><span class="lineNum">    5205 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5206"><span class="lineNum">    5206 </span>            :         {</a>
<a name="5207"><span class="lineNum">    5207 </span>            :           if (fileList[i]-&gt;get_Cuda_only() == true)</a>
<a name="5208"><span class="lineNum">    5208 </span>            :                returnValue = true;</a>
<a name="5209"><span class="lineNum">    5209 </span>            :         }</a>
<a name="5210"><span class="lineNum">    5210 </span>            : </a>
<a name="5211"><span class="lineNum">    5211 </span>            :      return returnValue;</a>
<a name="5212"><span class="lineNum">    5212 </span>            : #endif</a>
<a name="5213"><span class="lineNum">    5213 </span>            :    }</a>
<a name="5214"><span class="lineNum">    5214 </span>            : </a>
<a name="5215"><span class="lineNum">    5215 </span>            : bool</a>
<a name="5216"><span class="lineNum">    5216 </span>            : SageInterface::is_OpenCL_language()</a>
<a name="5217"><span class="lineNum">    5217 </span>            :    {</a>
<a name="5218"><span class="lineNum">    5218 </span>            : #if OPTIMIZE_IS_LANGUAGE_KIND_FUNCTIONS</a>
<a name="5219"><span class="lineNum">    5219 </span>            :   // DQ (11/25/2020): Add support to set this as a specific language kind file (there is at least one language kind file processed by ROSE).</a>
<a name="5220"><span class="lineNum">    5220 </span>            :      return Rose::is_OpenCL_language;</a>
<a name="5221"><span class="lineNum">    5221 </span>            : #else</a>
<a name="5222"><span class="lineNum">    5222 </span>            :      bool returnValue = false;</a>
<a name="5223"><span class="lineNum">    5223 </span>            : </a>
<a name="5224"><span class="lineNum">    5224 </span>            :      vector&lt;SgFile*&gt; fileList = generateFileList();</a>
<a name="5225"><span class="lineNum">    5225 </span>            : </a>
<a name="5226"><span class="lineNum">    5226 </span>            :      int size = (int)fileList.size();</a>
<a name="5227"><span class="lineNum">    5227 </span>            :      for (int i = 0; i &lt; size; i++)</a>
<a name="5228"><span class="lineNum">    5228 </span>            :         {</a>
<a name="5229"><span class="lineNum">    5229 </span>            :           if (fileList[i]-&gt;get_OpenCL_only() == true)</a>
<a name="5230"><span class="lineNum">    5230 </span>            :                returnValue = true;</a>
<a name="5231"><span class="lineNum">    5231 </span>            :         }</a>
<a name="5232"><span class="lineNum">    5232 </span>            : </a>
<a name="5233"><span class="lineNum">    5233 </span>            :      return returnValue;</a>
<a name="5234"><span class="lineNum">    5234 </span>            : #endif</a>
<a name="5235"><span class="lineNum">    5235 </span>            :    }</a>
<a name="5236"><span class="lineNum">    5236 </span>            : </a>
<a name="5237"><span class="lineNum">    5237 </span>            : // for if (INLINE_OPTIMIZED_IS_LANGUAGE_KIND_FUNCTIONS == 0)</a>
<a name="5238"><span class="lineNum">    5238 </span>            : #endif</a>
<a name="5239"><span class="lineNum">    5239 </span>            : </a>
<a name="5240"><span class="lineNum">    5240 </span><span class="lineNoCov">          0 : bool SageInterface::is_mixed_C_and_Cxx_language()</span></a>
<a name="5241"><span class="lineNum">    5241 </span>            :    {</a>
<a name="5242"><span class="lineNum">    5242 </span><span class="lineNoCov">          0 :      return is_C_language() &amp;&amp; is_Cxx_language();</span></a>
<a name="5243"><span class="lineNum">    5243 </span>            :    }</a>
<a name="5244"><span class="lineNum">    5244 </span>            : </a>
<a name="5245"><span class="lineNum">    5245 </span><span class="lineCov">          1 : bool SageInterface::is_mixed_Fortran_and_C_language()</span></a>
<a name="5246"><span class="lineNum">    5246 </span>            :    {</a>
<a name="5247"><span class="lineNum">    5247 </span><span class="lineCov">          1 :      return is_Fortran_language() &amp;&amp; is_C_language();</span></a>
<a name="5248"><span class="lineNum">    5248 </span>            :    }</a>
<a name="5249"><span class="lineNum">    5249 </span>            : </a>
<a name="5250"><span class="lineNum">    5250 </span><span class="lineNoCov">          0 : bool SageInterface::is_mixed_Fortran_and_Cxx_language()</span></a>
<a name="5251"><span class="lineNum">    5251 </span>            :    {</a>
<a name="5252"><span class="lineNum">    5252 </span><span class="lineNoCov">          0 :      return is_Fortran_language() &amp;&amp; is_Cxx_language();</span></a>
<a name="5253"><span class="lineNum">    5253 </span>            :    }</a>
<a name="5254"><span class="lineNum">    5254 </span>            : </a>
<a name="5255"><span class="lineNum">    5255 </span><span class="lineNoCov">          0 : bool SageInterface::is_mixed_Fortran_and_C_and_Cxx_language()</span></a>
<a name="5256"><span class="lineNum">    5256 </span>            :    {</a>
<a name="5257"><span class="lineNum">    5257 </span><span class="lineNoCov">          0 :      return is_Fortran_language() &amp;&amp; is_C_language() &amp;&amp; is_Cxx_language();</span></a>
<a name="5258"><span class="lineNum">    5258 </span>            :    }</a>
<a name="5259"><span class="lineNum">    5259 </span>            : </a>
<a name="5260"><span class="lineNum">    5260 </span>            : // Rasmussen (3/22/2020): Added this function because ROSE supports multiple</a>
<a name="5261"><span class="lineNum">    5261 </span>            : // languages that are case insensitive. Warning, this doesn't work for mixed languages.</a>
<a name="5262"><span class="lineNum">    5262 </span><span class="lineCov">      53012 : bool SageInterface::is_language_case_insensitive()</span></a>
<a name="5263"><span class="lineNum">    5263 </span>            :    {</a>
<a name="5264"><span class="lineNum">    5264 </span>            :    // This won't work for mixed languages so try returning to original</a>
<a name="5265"><span class="lineNum">    5265 </span>            :    // return is_Fortran_language() || is_Jovial_language();</a>
<a name="5266"><span class="lineNum">    5266 </span><span class="lineCov">      53012 :       return symbol_table_case_insensitive_semantics == true;</span></a>
<a name="5267"><span class="lineNum">    5267 </span>            :    }</a>
<a name="5268"><span class="lineNum">    5268 </span>            : </a>
<a name="5269"><span class="lineNum">    5269 </span>            : // Rasmussen (3/28/2020): Collecting all languages that may have scopes that contain</a>
<a name="5270"><span class="lineNum">    5270 </span>            : // statements that are not only declarations here. For Fortran (at least), function</a>
<a name="5271"><span class="lineNum">    5271 </span>            : // definitions may be declared at the end of other procedures.</a>
<a name="5272"><span class="lineNum">    5272 </span><span class="lineCov">      19243 : bool SageInterface::language_may_contain_nondeclarations_in_scope()</span></a>
<a name="5273"><span class="lineNum">    5273 </span>            :    {</a>
<a name="5274"><span class="lineNum">    5274 </span><span class="lineCov">      19243 :       return is_Fortran_language();</span></a>
<a name="5275"><span class="lineNum">    5275 </span>            :    }</a>
<a name="5276"><span class="lineNum">    5276 </span>            : </a>
<a name="5277"><span class="lineNum">    5277 </span>            : // #endif</a>
<a name="5278"><span class="lineNum">    5278 </span>            : </a>
<a name="5279"><span class="lineNum">    5279 </span>            : // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="5280"><span class="lineNum">    5280 </span>            : // labels for scopes in a function (as required for name mangling).</a>
<a name="5281"><span class="lineNum">    5281 </span>            : void</a>
<a name="5282"><span class="lineNum">    5282 </span><span class="lineCov">       2271 : SageInterface::clearScopeNumbers( SgFunctionDefinition* functionDefinition )</span></a>
<a name="5283"><span class="lineNum">    5283 </span>            :    {</a>
<a name="5284"><span class="lineNum">    5284 </span><span class="lineCov">       2271 :      ROSE_ASSERT(functionDefinition != NULL);</span></a>
<a name="5285"><span class="lineNum">    5285 </span><span class="lineCov">       2271 :      std::map&lt;SgNode*,int&gt; &amp; scopeMap = functionDefinition-&gt;get_scope_number_list();</span></a>
<a name="5286"><span class="lineNum">    5286 </span>            : </a>
<a name="5287"><span class="lineNum">    5287 </span>            :   // Clear the cache of stored (scope,integer) pairs</a>
<a name="5288"><span class="lineNum">    5288 </span><span class="lineCov">       2271 :      scopeMap.erase(scopeMap.begin(),scopeMap.end());</span></a>
<a name="5289"><span class="lineNum">    5289 </span>            : </a>
<a name="5290"><span class="lineNum">    5290 </span><span class="lineCov">       2271 :      ROSE_ASSERT(scopeMap.empty() == true);</span></a>
<a name="5291"><span class="lineNum">    5291 </span><span class="lineCov">       2271 :      ROSE_ASSERT(functionDefinition-&gt;get_scope_number_list().empty() == true);</span></a>
<a name="5292"><span class="lineNum">    5292 </span><span class="lineCov">       2271 :    }</span></a>
<a name="5293"><span class="lineNum">    5293 </span>            : </a>
<a name="5294"><span class="lineNum">    5294 </span>            : #ifndef USE_ROSE</a>
<a name="5295"><span class="lineNum">    5295 </span>            : </a>
<a name="5296"><span class="lineNum">    5296 </span>            : // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="5297"><span class="lineNum">    5297 </span>            : // labels for scopes in a function (as required for name mangling).</a>
<a name="5298"><span class="lineNum">    5298 </span>            : void</a>
<a name="5299"><span class="lineNum">    5299 </span><span class="lineCov">       2783 : SageInterface::resetScopeNumbers( SgFunctionDefinition* functionDefinition )</span></a>
<a name="5300"><span class="lineNum">    5300 </span>            :    {</a>
<a name="5301"><span class="lineNum">    5301 </span><span class="lineCov">       2783 :      ROSE_ASSERT(functionDefinition != NULL);</span></a>
<a name="5302"><span class="lineNum">    5302 </span>            :   // std::map&lt;SgNode*,int&gt; &amp; scopeMap = functionDefinition-&gt;get_scope_number_list();</a>
<a name="5303"><span class="lineNum">    5303 </span>            :   // ROSE_ASSERT(scopeMap.empty() == true);</a>
<a name="5304"><span class="lineNum">    5304 </span><span class="lineCov">       2783 :      ROSE_ASSERT(functionDefinition-&gt;get_scope_number_list().empty() == true);</span></a>
<a name="5305"><span class="lineNum">    5305 </span>            : </a>
<a name="5306"><span class="lineNum">    5306 </span>            :   // Preorder traversal to uniquely label the scopes (SgScopeStatements)</a>
<a name="5307"><span class="lineNum">    5307 </span><span class="lineCov">       2783 :      class ScopeNumberingTraversal : public AstSimpleProcessing</span></a>
<a name="5308"><span class="lineNum">    5308 </span>            :         {</a>
<a name="5309"><span class="lineNum">    5309 </span>            :           public:</a>
<a name="5310"><span class="lineNum">    5310 </span><span class="lineCov">       5566 :                ScopeNumberingTraversal() : count (0), storedFunctionDefinition(NULL) {}</span></a>
<a name="5311"><span class="lineNum">    5311 </span><span class="lineCov">     133540 :                void visit (SgNode* node)</span></a>
<a name="5312"><span class="lineNum">    5312 </span>            :                   {</a>
<a name="5313"><span class="lineNum">    5313 </span><span class="lineCov">     133540 :                     SgScopeStatement* scope = isSgScopeStatement (node);</span></a>
<a name="5314"><span class="lineNum">    5314 </span><span class="lineCov">     133540 :                     if (scope != NULL)</span></a>
<a name="5315"><span class="lineNum">    5315 </span>            :                        {</a>
<a name="5316"><span class="lineNum">    5316 </span>            :                       // Set the function definition</a>
<a name="5317"><span class="lineNum">    5317 </span><span class="lineCov">      12435 :                          SgFunctionDefinition* testFunctionDefinition = isSgFunctionDefinition(scope);</span></a>
<a name="5318"><span class="lineNum">    5318 </span><span class="lineCov">      12435 :                          if (testFunctionDefinition != NULL &amp;&amp; storedFunctionDefinition == NULL)</span></a>
<a name="5319"><span class="lineNum">    5319 </span>            :                             {</a>
<a name="5320"><span class="lineNum">    5320 </span><span class="lineCov">       2783 :                               ROSE_ASSERT(storedFunctionDefinition == NULL);</span></a>
<a name="5321"><span class="lineNum">    5321 </span><span class="lineCov">       2783 :                               storedFunctionDefinition = testFunctionDefinition;</span></a>
<a name="5322"><span class="lineNum">    5322 </span>            :                             }</a>
<a name="5323"><span class="lineNum">    5323 </span>            : </a>
<a name="5324"><span class="lineNum">    5324 </span>            :                       // This should now be set (since the root of each traversal is a SgFunctionDefinition).</a>
<a name="5325"><span class="lineNum">    5325 </span><span class="lineCov">      12435 :                          ROSE_ASSERT(storedFunctionDefinition != NULL);</span></a>
<a name="5326"><span class="lineNum">    5326 </span>            : </a>
<a name="5327"><span class="lineNum">    5327 </span><span class="lineCov">      12435 :                          count++;</span></a>
<a name="5328"><span class="lineNum">    5328 </span>            : </a>
<a name="5329"><span class="lineNum">    5329 </span><span class="lineCov">      12435 :                          std::map&lt;SgNode*,int&gt; &amp; scopeMap = storedFunctionDefinition-&gt;get_scope_number_list();</span></a>
<a name="5330"><span class="lineNum">    5330 </span><span class="lineCov">      12435 :                          scopeMap.insert(pair&lt;SgNode*,int&gt;(scope,count));</span></a>
<a name="5331"><span class="lineNum">    5331 </span>            : #if 0</a>
<a name="5332"><span class="lineNum">    5332 </span>            :                          string functionName = storedFunctionDefinition-&gt;get_declaration()-&gt;get_name().str();</a>
<a name="5333"><span class="lineNum">    5333 </span>            :                          printf (&quot;In function = %s insert scope = %p = %s with count = %d into local map (size = %d) \n&quot;,</a>
<a name="5334"><span class="lineNum">    5334 </span>            :                               functionName.c_str(),scope,scope-&gt;class_name().c_str(),count,scopeMap.size());</a>
<a name="5335"><span class="lineNum">    5335 </span>            : #endif</a>
<a name="5336"><span class="lineNum">    5336 </span>            :                        }</a>
<a name="5337"><span class="lineNum">    5337 </span><span class="lineCov">     133540 :                   }</span></a>
<a name="5338"><span class="lineNum">    5338 </span>            : </a>
<a name="5339"><span class="lineNum">    5339 </span>            :           private:</a>
<a name="5340"><span class="lineNum">    5340 </span>            :                int count; // running total of scopes found in the input function</a>
<a name="5341"><span class="lineNum">    5341 </span>            :                SgFunctionDefinition* storedFunctionDefinition;</a>
<a name="5342"><span class="lineNum">    5342 </span>            :         };</a>
<a name="5343"><span class="lineNum">    5343 </span>            : </a>
<a name="5344"><span class="lineNum">    5344 </span>            :     // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="5345"><span class="lineNum">    5345 </span><span class="lineCov">       2783 :        ScopeNumberingTraversal traversal;</span></a>
<a name="5346"><span class="lineNum">    5346 </span><span class="lineCov">       2783 :        traversal.traverse(functionDefinition, preorder);</span></a>
<a name="5347"><span class="lineNum">    5347 </span><span class="lineCov">       2783 :    }</span></a>
<a name="5348"><span class="lineNum">    5348 </span>            : </a>
<a name="5349"><span class="lineNum">    5349 </span>            : #endif</a>
<a name="5350"><span class="lineNum">    5350 </span>            : </a>
<a name="5351"><span class="lineNum">    5351 </span>            : #ifndef USE_ROSE</a>
<a name="5352"><span class="lineNum">    5352 </span>            : </a>
<a name="5353"><span class="lineNum">    5353 </span>            : #if 0</a>
<a name="5354"><span class="lineNum">    5354 </span>            : // DQ (6/26/2007): These are removed and the support is added to SgNode to support a single mangled name cache.</a>
<a name="5355"><span class="lineNum">    5355 </span>            : // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="5356"><span class="lineNum">    5356 </span>            : // labels for scopes in a function (as required for name mangling).</a>
<a name="5357"><span class="lineNum">    5357 </span>            : void</a>
<a name="5358"><span class="lineNum">    5358 </span>            : SageInterface::clearMangledNameCache( SgGlobal* globalScope )</a>
<a name="5359"><span class="lineNum">    5359 </span>            :    {</a>
<a name="5360"><span class="lineNum">    5360 </span>            :      ROSE_ASSERT(globalScope != NULL);</a>
<a name="5361"><span class="lineNum">    5361 </span>            :      std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache = globalScope-&gt;get_mangledNameCache();</a>
<a name="5362"><span class="lineNum">    5362 </span>            : </a>
<a name="5363"><span class="lineNum">    5363 </span>            :   // Clear the cache of stored (scope,integer) pairs</a>
<a name="5364"><span class="lineNum">    5364 </span>            :      mangledNameCache.erase(mangledNameCache.begin(),mangledNameCache.end());</a>
<a name="5365"><span class="lineNum">    5365 </span>            : </a>
<a name="5366"><span class="lineNum">    5366 </span>            :      ROSE_ASSERT(mangledNameCache.empty() == true);</a>
<a name="5367"><span class="lineNum">    5367 </span>            :      ROSE_ASSERT(globalScope-&gt;get_mangledNameCache().empty() == true);</a>
<a name="5368"><span class="lineNum">    5368 </span>            :    }</a>
<a name="5369"><span class="lineNum">    5369 </span>            : </a>
<a name="5370"><span class="lineNum">    5370 </span>            : // DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</a>
<a name="5371"><span class="lineNum">    5371 </span>            : // labels for scopes in a function (as required for name mangling).</a>
<a name="5372"><span class="lineNum">    5372 </span>            : void</a>
<a name="5373"><span class="lineNum">    5373 </span>            : SageInterface::resetMangledNameCache( SgGlobal* globalScope )</a>
<a name="5374"><span class="lineNum">    5374 </span>            :    {</a>
<a name="5375"><span class="lineNum">    5375 </span>            :      ROSE_ASSERT(globalScope != NULL);</a>
<a name="5376"><span class="lineNum">    5376 </span>            :      ROSE_ASSERT(globalScope-&gt;get_mangledNameCache().empty() == true);</a>
<a name="5377"><span class="lineNum">    5377 </span>            : </a>
<a name="5378"><span class="lineNum">    5378 </span>            :   // Preorder traversal to uniquely label the scopes (SgScopeStatements)</a>
<a name="5379"><span class="lineNum">    5379 </span>            :      class MangledNameTraversal : public AstSimpleProcessing</a>
<a name="5380"><span class="lineNum">    5380 </span>            :         {</a>
<a name="5381"><span class="lineNum">    5381 </span>            :           public:</a>
<a name="5382"><span class="lineNum">    5382 </span>            :                MangledNameTraversal() : storedGlobalScope(NULL) {}</a>
<a name="5383"><span class="lineNum">    5383 </span>            :                void visit (SgNode* node)</a>
<a name="5384"><span class="lineNum">    5384 </span>            :                   {</a>
<a name="5385"><span class="lineNum">    5385 </span>            :                     SgFunctionDeclaration* mangleableNode = isSgFunctionDeclaration(node);</a>
<a name="5386"><span class="lineNum">    5386 </span>            :                     if ( (mangleableNode != NULL) || (isSgGlobal(node) != NULL) )</a>
<a name="5387"><span class="lineNum">    5387 </span>            :                        {</a>
<a name="5388"><span class="lineNum">    5388 </span>            :                       // Set the global scope</a>
<a name="5389"><span class="lineNum">    5389 </span>            :                          SgGlobal* testGlobalScope = isSgGlobal(mangleableNode);</a>
<a name="5390"><span class="lineNum">    5390 </span>            :                          if (testGlobalScope != NULL &amp;&amp; storedGlobalScope == NULL)</a>
<a name="5391"><span class="lineNum">    5391 </span>            :                             {</a>
<a name="5392"><span class="lineNum">    5392 </span>            :                               ROSE_ASSERT(storedGlobalScope == NULL);</a>
<a name="5393"><span class="lineNum">    5393 </span>            :                               storedGlobalScope = testGlobalScope;</a>
<a name="5394"><span class="lineNum">    5394 </span>            :                             }</a>
<a name="5395"><span class="lineNum">    5395 </span>            : </a>
<a name="5396"><span class="lineNum">    5396 </span>            :                       // This should now be set (since the root of each traversal is a SgFunctionDefinition).</a>
<a name="5397"><span class="lineNum">    5397 </span>            :                          ROSE_ASSERT(storedGlobalScope != NULL);</a>
<a name="5398"><span class="lineNum">    5398 </span>            : </a>
<a name="5399"><span class="lineNum">    5399 </span>            :                          string mangledName = mangleableNode-&gt;get_mangled_name();</a>
<a name="5400"><span class="lineNum">    5400 </span>            :                       // printf (&quot;mangledName = %s \n&quot;,mangledName.c_str());</a>
<a name="5401"><span class="lineNum">    5401 </span>            : </a>
<a name="5402"><span class="lineNum">    5402 </span>            :                          std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache = storedGlobalScope-&gt;get_mangledNameCache();</a>
<a name="5403"><span class="lineNum">    5403 </span>            :                          mangledNameCache.insert(pair&lt;SgNode*,std::string&gt;(mangleableNode,mangledName));</a>
<a name="5404"><span class="lineNum">    5404 </span>            : #if 0</a>
<a name="5405"><span class="lineNum">    5405 </span>            :                          string nodeName = get_name(mangleableNode);</a>
<a name="5406"><span class="lineNum">    5406 </span>            :                          printf (&quot;At node = %p = %s = %s in local map (size = %d) \n&quot;,</a>
<a name="5407"><span class="lineNum">    5407 </span>            :                               mangleableNode,mangleableNode-&gt;class_name().c_str(),nodeName.c_str(),mangledNameCache.size());</a>
<a name="5408"><span class="lineNum">    5408 </span>            : #endif</a>
<a name="5409"><span class="lineNum">    5409 </span>            :                        }</a>
<a name="5410"><span class="lineNum">    5410 </span>            :                   }</a>
<a name="5411"><span class="lineNum">    5411 </span>            : </a>
<a name="5412"><span class="lineNum">    5412 </span>            :           private:</a>
<a name="5413"><span class="lineNum">    5413 </span>            :                SgGlobal* storedGlobalScope;</a>
<a name="5414"><span class="lineNum">    5414 </span>            :         };</a>
<a name="5415"><span class="lineNum">    5415 </span>            : </a>
<a name="5416"><span class="lineNum">    5416 </span>            :     // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="5417"><span class="lineNum">    5417 </span>            :        MangledNameTraversal traversal;</a>
<a name="5418"><span class="lineNum">    5418 </span>            :        traversal.traverse(globalScope, preorder);</a>
<a name="5419"><span class="lineNum">    5419 </span>            :    }</a>
<a name="5420"><span class="lineNum">    5420 </span>            : #endif</a>
<a name="5421"><span class="lineNum">    5421 </span>            : </a>
<a name="5422"><span class="lineNum">    5422 </span>            : </a>
<a name="5423"><span class="lineNum">    5423 </span>            : string</a>
<a name="5424"><span class="lineNum">    5424 </span><span class="lineCov">   35719000 : SageInterface::getMangledNameFromCache( SgNode* astNode )</span></a>
<a name="5425"><span class="lineNum">    5425 </span>            :    {</a>
<a name="5426"><span class="lineNum">    5426 </span>            :   // The TransformationSupport is not defined yet (I forget the</a>
<a name="5427"><span class="lineNum">    5427 </span>            :   // details but I recall that there is a reason why this is this way).</a>
<a name="5428"><span class="lineNum">    5428 </span>            :   // SgGlobal* globalScope = TransformationSupport::getGlobalScope(astNode);</a>
<a name="5429"><span class="lineNum">    5429 </span>            : #if 0</a>
<a name="5430"><span class="lineNum">    5430 </span>            :      SgGlobal* globalScope = isSgGlobal(astNode);</a>
<a name="5431"><span class="lineNum">    5431 </span>            : </a>
<a name="5432"><span class="lineNum">    5432 </span>            :      if (globalScope == NULL &amp;&amp; isSgFile(astNode) != NULL)</a>
<a name="5433"><span class="lineNum">    5433 </span>            :         {</a>
<a name="5434"><span class="lineNum">    5434 </span>            :           globalScope = isSgFile(astNode)-&gt;get_globalScope();</a>
<a name="5435"><span class="lineNum">    5435 </span>            :           ROSE_ASSERT(globalScope != NULL);</a>
<a name="5436"><span class="lineNum">    5436 </span>            :         }</a>
<a name="5437"><span class="lineNum">    5437 </span>            : </a>
<a name="5438"><span class="lineNum">    5438 </span>            :      if (globalScope == NULL &amp;&amp; isSgProject(astNode) != NULL)</a>
<a name="5439"><span class="lineNum">    5439 </span>            :         {</a>
<a name="5440"><span class="lineNum">    5440 </span>            :        // Check to make sure that the SgFile can be uniquely determined</a>
<a name="5441"><span class="lineNum">    5441 </span>            :           ROSE_ASSERT( isSgProject(astNode)-&gt;get_fileList()-&gt;size() == 1 );</a>
<a name="5442"><span class="lineNum">    5442 </span>            :           globalScope = isSgProject(astNode)-&gt;get_fileList()-&gt;operator[](0)-&gt;get_globalScope();</a>
<a name="5443"><span class="lineNum">    5443 </span>            :           ROSE_ASSERT(globalScope != NULL);</a>
<a name="5444"><span class="lineNum">    5444 </span>            :         }</a>
<a name="5445"><span class="lineNum">    5445 </span>            : </a>
<a name="5446"><span class="lineNum">    5446 </span>            :      SgNode* temp = astNode;</a>
<a name="5447"><span class="lineNum">    5447 </span>            :      while (temp-&gt;get_parent() != NULL &amp;&amp; globalScope == NULL)</a>
<a name="5448"><span class="lineNum">    5448 </span>            :         {</a>
<a name="5449"><span class="lineNum">    5449 </span>            :           temp = temp-&gt;get_parent();</a>
<a name="5450"><span class="lineNum">    5450 </span>            :           globalScope = isSgGlobal(temp);</a>
<a name="5451"><span class="lineNum">    5451 </span>            :         }</a>
<a name="5452"><span class="lineNum">    5452 </span>            :      ROSE_ASSERT(globalScope != NULL);</a>
<a name="5453"><span class="lineNum">    5453 </span>            : #endif</a>
<a name="5454"><span class="lineNum">    5454 </span>            : </a>
<a name="5455"><span class="lineNum">    5455 </span>            :   // std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache = globalScope-&gt;get_mangledNameCache();</a>
<a name="5456"><span class="lineNum">    5456 </span><span class="lineCov">   35719000 :      std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache = SgNode::get_globalMangledNameMap();</span></a>
<a name="5457"><span class="lineNum">    5457 </span>            : </a>
<a name="5458"><span class="lineNum">    5458 </span>            :   // Build an iterator</a>
<a name="5459"><span class="lineNum">    5459 </span><span class="lineCov">   35719000 :      std::map&lt;SgNode*,std::string&gt;::iterator i = mangledNameCache.find(astNode);</span></a>
<a name="5460"><span class="lineNum">    5460 </span>            : </a>
<a name="5461"><span class="lineNum">    5461 </span><span class="lineCov">   35719000 :      string mangledName;</span></a>
<a name="5462"><span class="lineNum">    5462 </span><span class="lineCov">   35719000 :      if (i != mangledNameCache.end())</span></a>
<a name="5463"><span class="lineNum">    5463 </span>            :         {</a>
<a name="5464"><span class="lineNum">    5464 </span>            :        // get the precomputed mangled name!</a>
<a name="5465"><span class="lineNum">    5465 </span>            :        // printf (&quot;Mangled name IS found in cache (node = %p = %s) \n&quot;,astNode,astNode-&gt;class_name().c_str());</a>
<a name="5466"><span class="lineNum">    5466 </span><span class="lineCov">   32222800 :           mangledName = i-&gt;second;</span></a>
<a name="5467"><span class="lineNum">    5467 </span>            :         }</a>
<a name="5468"><span class="lineNum">    5468 </span>            :        else</a>
<a name="5469"><span class="lineNum">    5469 </span>            :         {</a>
<a name="5470"><span class="lineNum">    5470 </span>            :        // mangled name not found in cache!</a>
<a name="5471"><span class="lineNum">    5471 </span>            :        // printf (&quot;Mangled name NOT found in cache (node = %p = %s) \n&quot;,astNode,astNode-&gt;class_name().c_str());</a>
<a name="5472"><span class="lineNum">    5472 </span>            :         }</a>
<a name="5473"><span class="lineNum">    5473 </span>            : </a>
<a name="5474"><span class="lineNum">    5474 </span><span class="lineCov">   35719000 :      return mangledName;</span></a>
<a name="5475"><span class="lineNum">    5475 </span>            :    }</a>
<a name="5476"><span class="lineNum">    5476 </span>            : </a>
<a name="5477"><span class="lineNum">    5477 </span>            : #define DEBUG_SAGE_INTERFACE_ADD_MANGLED_TO_CACHE 0</a>
<a name="5478"><span class="lineNum">    5478 </span>            : </a>
<a name="5479"><span class="lineNum">    5479 </span>            : std::string</a>
<a name="5480"><span class="lineNum">    5480 </span><span class="lineCov">    3490120 : SageInterface::addMangledNameToCache( SgNode* astNode, const std::string &amp; oldMangledName)</span></a>
<a name="5481"><span class="lineNum">    5481 </span>            :    {</a>
<a name="5482"><span class="lineNum">    5482 </span>            : #if DEBUG_SAGE_INTERFACE_ADD_MANGLED_TO_CACHE</a>
<a name="5483"><span class="lineNum">    5483 </span>            :      printf (&quot;In SageInterface::addMangledNameToCache(): TOP: astNode = %p = %s oldMangledName = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),oldMangledName.c_str());</a>
<a name="5484"><span class="lineNum">    5484 </span>            : #endif</a>
<a name="5485"><span class="lineNum">    5485 </span>            : </a>
<a name="5486"><span class="lineNum">    5486 </span>            : #if 0</a>
<a name="5487"><span class="lineNum">    5487 </span>            :      SgGlobal* globalScope = isSgGlobal(astNode);</a>
<a name="5488"><span class="lineNum">    5488 </span>            : </a>
<a name="5489"><span class="lineNum">    5489 </span>            :      if (globalScope == NULL &amp;&amp; isSgFile(astNode) != NULL)</a>
<a name="5490"><span class="lineNum">    5490 </span>            :         {</a>
<a name="5491"><span class="lineNum">    5491 </span>            :           globalScope = isSgFile(astNode)-&gt;get_globalScope();</a>
<a name="5492"><span class="lineNum">    5492 </span>            :           ROSE_ASSERT(globalScope != NULL);</a>
<a name="5493"><span class="lineNum">    5493 </span>            :         }</a>
<a name="5494"><span class="lineNum">    5494 </span>            : </a>
<a name="5495"><span class="lineNum">    5495 </span>            :      if (globalScope == NULL &amp;&amp; isSgProject(astNode) != NULL)</a>
<a name="5496"><span class="lineNum">    5496 </span>            :         {</a>
<a name="5497"><span class="lineNum">    5497 </span>            :        // Check to make sure that the SgFile can be uniquely determined</a>
<a name="5498"><span class="lineNum">    5498 </span>            :           ROSE_ASSERT( isSgProject(astNode)-&gt;get_fileList()-&gt;size() == 1 );</a>
<a name="5499"><span class="lineNum">    5499 </span>            :           globalScope = isSgProject(astNode)-&gt;get_fileList()-&gt;operator[](0)-&gt;get_globalScope();</a>
<a name="5500"><span class="lineNum">    5500 </span>            :           ROSE_ASSERT(globalScope != NULL);</a>
<a name="5501"><span class="lineNum">    5501 </span>            :         }</a>
<a name="5502"><span class="lineNum">    5502 </span>            : </a>
<a name="5503"><span class="lineNum">    5503 </span>            :      SgNode* temp = astNode;</a>
<a name="5504"><span class="lineNum">    5504 </span>            :      while (temp-&gt;get_parent() != NULL &amp;&amp; globalScope == NULL)</a>
<a name="5505"><span class="lineNum">    5505 </span>            :         {</a>
<a name="5506"><span class="lineNum">    5506 </span>            :           temp = temp-&gt;get_parent();</a>
<a name="5507"><span class="lineNum">    5507 </span>            :           globalScope = isSgGlobal(temp);</a>
<a name="5508"><span class="lineNum">    5508 </span>            :         }</a>
<a name="5509"><span class="lineNum">    5509 </span>            :      ROSE_ASSERT(globalScope != NULL);</a>
<a name="5510"><span class="lineNum">    5510 </span>            : #endif</a>
<a name="5511"><span class="lineNum">    5511 </span>            : </a>
<a name="5512"><span class="lineNum">    5512 </span>            :   // std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache = globalScope-&gt;get_mangledNameCache();</a>
<a name="5513"><span class="lineNum">    5513 </span>            :   // std::map&lt;std::string, int&gt; &amp; shortMangledNameCache = globalScope-&gt;get_shortMangledNameCache();</a>
<a name="5514"><span class="lineNum">    5514 </span><span class="lineCov">    3490120 :      std::map&lt;SgNode*,std::string&gt; &amp; mangledNameCache   = SgNode::get_globalMangledNameMap();</span></a>
<a name="5515"><span class="lineNum">    5515 </span>            : </a>
<a name="5516"><span class="lineNum">    5516 </span><span class="lineCov">    3490120 :      std::string mangledName;</span></a>
<a name="5517"><span class="lineNum">    5517 </span>            : </a>
<a name="5518"><span class="lineNum">    5518 </span>            : #define USE_SHORT_MANGLED_NAMES 1</a>
<a name="5519"><span class="lineNum">    5519 </span>            : #if USE_SHORT_MANGLED_NAMES</a>
<a name="5520"><span class="lineNum">    5520 </span><span class="lineCov">    3490120 :      std::map&lt;std::string, int&gt; &amp; shortMangledNameCache = SgNode::get_shortMangledNameCache();</span></a>
<a name="5521"><span class="lineNum">    5521 </span>            : </a>
<a name="5522"><span class="lineNum">    5522 </span>            :   // This bound was 40 previously!</a>
<a name="5523"><span class="lineNum">    5523 </span><span class="lineCov">    3490120 :      if (oldMangledName.size() &gt; 40) {</span></a>
<a name="5524"><span class="lineNum">    5524 </span><span class="lineCov">    3303670 :        std::map&lt;std::string, int&gt;::const_iterator shortMNIter = shortMangledNameCache.find(oldMangledName);</span></a>
<a name="5525"><span class="lineNum">    5525 </span><span class="lineCov">    3303670 :        int idNumber = (int)shortMangledNameCache.size();</span></a>
<a name="5526"><span class="lineNum">    5526 </span><span class="lineCov">    3303670 :        if (shortMNIter != shortMangledNameCache.end())</span></a>
<a name="5527"><span class="lineNum">    5527 </span>            :           {</a>
<a name="5528"><span class="lineNum">    5528 </span><span class="lineCov">    1076240 :             idNumber = shortMNIter-&gt;second;</span></a>
<a name="5529"><span class="lineNum">    5529 </span>            :           }</a>
<a name="5530"><span class="lineNum">    5530 </span>            :          else</a>
<a name="5531"><span class="lineNum">    5531 </span>            :           {</a>
<a name="5532"><span class="lineNum">    5532 </span><span class="lineCov">    2227420 :             shortMangledNameCache.insert(std::pair&lt;std::string, int&gt;(oldMangledName, idNumber));</span></a>
<a name="5533"><span class="lineNum">    5533 </span>            :           }</a>
<a name="5534"><span class="lineNum">    5534 </span>            : </a>
<a name="5535"><span class="lineNum">    5535 </span><span class="lineCov">    3303670 :        std::ostringstream mn;</span></a>
<a name="5536"><span class="lineNum">    5536 </span><span class="lineCov">    3303670 :        mn &lt;&lt; 'L' &lt;&lt; idNumber &lt;&lt; 'R';</span></a>
<a name="5537"><span class="lineNum">    5537 </span><span class="lineCov">    3303670 :        mangledName = mn.str();</span></a>
<a name="5538"><span class="lineNum">    5538 </span>            :      } else {</a>
<a name="5539"><span class="lineNum">    5539 </span><span class="lineCov">     186455 :        mangledName = oldMangledName;</span></a>
<a name="5540"><span class="lineNum">    5540 </span>            :      }</a>
<a name="5541"><span class="lineNum">    5541 </span>            : #else</a>
<a name="5542"><span class="lineNum">    5542 </span>            :   // DQ (7/24/2012): Note that using this option can cause some test codes using operators that have</a>
<a name="5543"><span class="lineNum">    5543 </span>            :   // difficult names (conversion operators to user-defined types) to fail.  See test2004_141.C for example.</a>
<a name="5544"><span class="lineNum">    5544 </span>            :   // The conversion operator &quot;operator T&amp;() const;&quot; will fail because the character &quot;&amp;&quot; will remain in</a>
<a name="5545"><span class="lineNum">    5545 </span>            :   // mangled name.  The substring coding changes the strings for the mangled names and this effectively</a>
<a name="5546"><span class="lineNum">    5546 </span>            :   // removes the special characters, but there could be cases where they might remain.</a>
<a name="5547"><span class="lineNum">    5547 </span>            : </a>
<a name="5548"><span class="lineNum">    5548 </span>            :   // DQ (3/27/2012): Use this as a mechanism to limit the I/O but still output a warning infrequently.</a>
<a name="5549"><span class="lineNum">    5549 </span>            :      static unsigned long counter = 0;</a>
<a name="5550"><span class="lineNum">    5550 </span>            : </a>
<a name="5551"><span class="lineNum">    5551 </span>            :   // DQ (3/27/2012): Use this as a mechanism to limit the I/O but still output a warning infrequently.</a>
<a name="5552"><span class="lineNum">    5552 </span>            :   // This supports debugging the new EDG 4.x interface...</a>
<a name="5553"><span class="lineNum">    5553 </span>            :      if (counter++ % 500 == 0)</a>
<a name="5554"><span class="lineNum">    5554 </span>            :         {</a>
<a name="5555"><span class="lineNum">    5555 </span>            :           printf (&quot;WARNING: In SageInterface::addMangledNameToCache(): Using longer forms of mangled names (can cause some function names with embedded special characters to fail; test2004_141.C) \n&quot;);</a>
<a name="5556"><span class="lineNum">    5556 </span>            :         }</a>
<a name="5557"><span class="lineNum">    5557 </span>            :      mangledName = oldMangledName;</a>
<a name="5558"><span class="lineNum">    5558 </span>            : #endif</a>
<a name="5559"><span class="lineNum">    5559 </span>            : </a>
<a name="5560"><span class="lineNum">    5560 </span>            :   // DQ (6/26/2007): Output information useful for understanding Jeremiah's shortended name merge caching.</a>
<a name="5561"><span class="lineNum">    5561 </span>            :   // std::cerr &lt;&lt; &quot;Changed MN &quot; &lt;&lt; oldMangledName &lt;&lt; &quot; to &quot; &lt;&lt; mangledName &lt;&lt; std::endl;</a>
<a name="5562"><span class="lineNum">    5562 </span>            : </a>
<a name="5563"><span class="lineNum">    5563 </span>            : #if 0</a>
<a name="5564"><span class="lineNum">    5564 </span>            :      printf (&quot;Updating mangled name cache for node = %p = %s with mangledName = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),mangledName.c_str());</a>
<a name="5565"><span class="lineNum">    5565 </span>            : #endif</a>
<a name="5566"><span class="lineNum">    5566 </span>            : </a>
<a name="5567"><span class="lineNum">    5567 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="5568"><span class="lineNum">    5568 </span>            :      SgStatement* statement = isSgStatement(astNode);</a>
<a name="5569"><span class="lineNum">    5569 </span>            :      if (statement != NULL &amp;&amp; statement-&gt;hasExplicitScope() == true)</a>
<a name="5570"><span class="lineNum">    5570 </span>            :         {</a>
<a name="5571"><span class="lineNum">    5571 </span>            :           if (statement-&gt;get_scope() == NULL)</a>
<a name="5572"><span class="lineNum">    5572 </span>            :              {</a>
<a name="5573"><span class="lineNum">    5573 </span>            :                printf (&quot;Warning: SageInterface::addMangledNameToCache(): In it might be premature to add this IR node and name to the mangledNameCache: statement = %p = %s oldMangledName = %s \n&quot;,</a>
<a name="5574"><span class="lineNum">    5574 </span>            :                     statement,statement-&gt;class_name().c_str(),oldMangledName.c_str());</a>
<a name="5575"><span class="lineNum">    5575 </span>            :              }</a>
<a name="5576"><span class="lineNum">    5576 </span>            :         }</a>
<a name="5577"><span class="lineNum">    5577 </span>            : #endif</a>
<a name="5578"><span class="lineNum">    5578 </span>            : </a>
<a name="5579"><span class="lineNum">    5579 </span><span class="lineCov">    6980250 :      mangledNameCache.insert(pair&lt;SgNode*,string&gt;(astNode,mangledName));</span></a>
<a name="5580"><span class="lineNum">    5580 </span>            : </a>
<a name="5581"><span class="lineNum">    5581 </span>            : #if DEBUG_SAGE_INTERFACE_ADD_MANGLED_TO_CACHE</a>
<a name="5582"><span class="lineNum">    5582 </span>            :      printf (&quot;In SageInterface::addMangledNameToCache(): returning mangledName = %s \n&quot;,mangledName.c_str());</a>
<a name="5583"><span class="lineNum">    5583 </span>            : #endif</a>
<a name="5584"><span class="lineNum">    5584 </span>            : </a>
<a name="5585"><span class="lineNum">    5585 </span><span class="lineCov">    3490120 :      return mangledName;</span></a>
<a name="5586"><span class="lineNum">    5586 </span>            :    }</a>
<a name="5587"><span class="lineNum">    5587 </span>            : </a>
<a name="5588"><span class="lineNum">    5588 </span>            : </a>
<a name="5589"><span class="lineNum">    5589 </span>            : // #endif</a>
<a name="5590"><span class="lineNum">    5590 </span>            : </a>
<a name="5591"><span class="lineNum">    5591 </span>            : #ifndef USE_ROSE</a>
<a name="5592"><span class="lineNum">    5592 </span>            : </a>
<a name="5593"><span class="lineNum">    5593 </span>            : bool</a>
<a name="5594"><span class="lineNum">    5594 </span><span class="lineCov">       3462 : SageInterface::declarationPreceedsDefinition ( SgDeclarationStatement* nonDefiningDeclaration, SgDeclarationStatement* definingDeclaration )</span></a>
<a name="5595"><span class="lineNum">    5595 </span>            :    {</a>
<a name="5596"><span class="lineNum">    5596 </span>            :   // This function is used in the unparser, but might be more generally useful.  Since it is</a>
<a name="5597"><span class="lineNum">    5597 </span>            :   // related to general AST tests, I have put it here.  It might be alternatively put in the</a>
<a name="5598"><span class="lineNum">    5598 </span>            :   // src/backend/unparser or related utility directory.</a>
<a name="5599"><span class="lineNum">    5599 </span>            : </a>
<a name="5600"><span class="lineNum">    5600 </span>            :   // Preorder traversal to test the order of declaration of non-defining vs. defining class</a>
<a name="5601"><span class="lineNum">    5601 </span>            :   // declarations in the preorder traversal of the AST.</a>
<a name="5602"><span class="lineNum">    5602 </span><span class="lineNoCov">          0 :      class DeclarationOrderTraversal : public AstSimpleProcessing</span></a>
<a name="5603"><span class="lineNum">    5603 </span>            :         {</a>
<a name="5604"><span class="lineNum">    5604 </span>            :           public:</a>
<a name="5605"><span class="lineNum">    5605 </span><span class="lineCov">       3462 :                DeclarationOrderTraversal( SgDeclarationStatement* nonDefiningDeclaration, SgDeclarationStatement* definingDeclaration )</span></a>
<a name="5606"><span class="lineNum">    5606 </span><span class="lineCov">       3462 :                   : storedNondefiningDeclaration(nonDefiningDeclaration),</span></a>
<a name="5607"><span class="lineNum">    5607 </span><span class="lineCov">       6924 :                     storedDefiningDeclaration(definingDeclaration)</span></a>
<a name="5608"><span class="lineNum">    5608 </span>            :                   {</a>
<a name="5609"><span class="lineNum">    5609 </span><span class="lineCov">       3462 :                     storedDeclarationFound                            = false;</span></a>
<a name="5610"><span class="lineNum">    5610 </span><span class="lineCov">       3462 :                     nonDefiningDeclarationPreceedsDefiningDeclaration = false;</span></a>
<a name="5611"><span class="lineNum">    5611 </span>            :                   }</a>
<a name="5612"><span class="lineNum">    5612 </span>            : </a>
<a name="5613"><span class="lineNum">    5613 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="5614"><span class="lineNum">    5614 </span>            :                   {</a>
<a name="5615"><span class="lineNum">    5615 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedNondefiningDeclaration != NULL);</span></a>
<a name="5616"><span class="lineNum">    5616 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedDefiningDeclaration != NULL);</span></a>
<a name="5617"><span class="lineNum">    5617 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedNondefiningDeclaration != storedDefiningDeclaration);</span></a>
<a name="5618"><span class="lineNum">    5618 </span>            :                  // ROSE_ASSERT(storedNondefiningDeclaration-&gt;get_definingDeclaration() == storedDefiningDeclaration);</a>
<a name="5619"><span class="lineNum">    5619 </span>            : </a>
<a name="5620"><span class="lineNum">    5620 </span>            :                  // Even though we only care about the SgClassDeclaration IR nodes we have to traverse them</a>
<a name="5621"><span class="lineNum">    5621 </span>            :                  // in the AST in the order defined by the traversal (order of apprearance in the AST).  We</a>
<a name="5622"><span class="lineNum">    5622 </span>            :                  // also can't just search the declarations of a single scope (since the nondefining declaration</a>
<a name="5623"><span class="lineNum">    5623 </span>            :                  // can appear in a different scope than the defining declaration).</a>
<a name="5624"><span class="lineNum">    5624 </span><span class="lineNoCov">          0 :                     SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="5625"><span class="lineNum">    5625 </span><span class="lineNoCov">          0 :                     if ( declaration != NULL )</span></a>
<a name="5626"><span class="lineNum">    5626 </span>            :                        {</a>
<a name="5627"><span class="lineNum">    5627 </span>            :                       // if (classDeclaration == storedNondefiningDeclaration &amp;&amp; neitherStoredDeclarationFound == true)</a>
<a name="5628"><span class="lineNum">    5628 </span><span class="lineNoCov">          0 :                          if (storedDeclarationFound == false)</span></a>
<a name="5629"><span class="lineNum">    5629 </span>            :                             {</a>
<a name="5630"><span class="lineNum">    5630 </span><span class="lineNoCov">          0 :                               if (declaration == storedDefiningDeclaration)</span></a>
<a name="5631"><span class="lineNum">    5631 </span>            :                                  {</a>
<a name="5632"><span class="lineNum">    5632 </span><span class="lineNoCov">          0 :                                    storedDeclarationFound = true;</span></a>
<a name="5633"><span class="lineNum">    5633 </span><span class="lineNoCov">          0 :                                    nonDefiningDeclarationPreceedsDefiningDeclaration = false;</span></a>
<a name="5634"><span class="lineNum">    5634 </span>            :                                  }</a>
<a name="5635"><span class="lineNum">    5635 </span><span class="lineNoCov">          0 :                               if (declaration == storedNondefiningDeclaration)</span></a>
<a name="5636"><span class="lineNum">    5636 </span>            :                                  {</a>
<a name="5637"><span class="lineNum">    5637 </span><span class="lineNoCov">          0 :                                    storedDeclarationFound = true;</span></a>
<a name="5638"><span class="lineNum">    5638 </span><span class="lineNoCov">          0 :                                    nonDefiningDeclarationPreceedsDefiningDeclaration = true;</span></a>
<a name="5639"><span class="lineNum">    5639 </span>            :                                  }</a>
<a name="5640"><span class="lineNum">    5640 </span>            :                             }</a>
<a name="5641"><span class="lineNum">    5641 </span>            :                        }</a>
<a name="5642"><span class="lineNum">    5642 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="5643"><span class="lineNum">    5643 </span>            : </a>
<a name="5644"><span class="lineNum">    5644 </span>            :           public:</a>
<a name="5645"><span class="lineNum">    5645 </span>            :                bool storedDeclarationFound;</a>
<a name="5646"><span class="lineNum">    5646 </span>            :                bool nonDefiningDeclarationPreceedsDefiningDeclaration;</a>
<a name="5647"><span class="lineNum">    5647 </span>            : </a>
<a name="5648"><span class="lineNum">    5648 </span>            :           private:</a>
<a name="5649"><span class="lineNum">    5649 </span>            :                SgDeclarationStatement* storedNondefiningDeclaration;</a>
<a name="5650"><span class="lineNum">    5650 </span>            :                SgDeclarationStatement* storedDefiningDeclaration;</a>
<a name="5651"><span class="lineNum">    5651 </span>            :         };</a>
<a name="5652"><span class="lineNum">    5652 </span>            : </a>
<a name="5653"><span class="lineNum">    5653 </span><span class="lineCov">       3462 :      ROSE_ASSERT(nonDefiningDeclaration != NULL);</span></a>
<a name="5654"><span class="lineNum">    5654 </span>            : #if 0</a>
<a name="5655"><span class="lineNum">    5655 </span>            :      printf (&quot;In SageInterface::declarationPreceedsDefinition(): \n&quot;);</a>
<a name="5656"><span class="lineNum">    5656 </span>            :      printf (&quot;     nondefiningDeclaration                            = %p = %s \n&quot;,nonDefiningDeclaration,nonDefiningDeclaration-&gt;class_name().c_str());</a>
<a name="5657"><span class="lineNum">    5657 </span>            :      nonDefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;nonDefiningDeclaration&quot;);</a>
<a name="5658"><span class="lineNum">    5658 </span>            :      printf (&quot;     nondefiningDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,nonDefiningDeclaration-&gt;get_definingDeclaration());</a>
<a name="5659"><span class="lineNum">    5659 </span>            :      printf (&quot;     definingDeclaration                               = %p = %s \n&quot;,definingDeclaration,definingDeclaration-&gt;class_name().c_str());</a>
<a name="5660"><span class="lineNum">    5660 </span>            :      definingDeclaration-&gt;get_file_info()-&gt;display(&quot;definingDeclaration&quot;);</a>
<a name="5661"><span class="lineNum">    5661 </span>            :      printf (&quot;************************************************************* \n&quot;);</a>
<a name="5662"><span class="lineNum">    5662 </span>            : #endif</a>
<a name="5663"><span class="lineNum">    5663 </span>            : </a>
<a name="5664"><span class="lineNum">    5664 </span>            : #if 0</a>
<a name="5665"><span class="lineNum">    5665 </span>            :   // The nonDefiningDeclaration can be a different type of declaration than the definingDeclaration</a>
<a name="5666"><span class="lineNum">    5666 </span>            :      if (nonDefiningDeclaration-&gt;get_definingDeclaration() != definingDeclaration)</a>
<a name="5667"><span class="lineNum">    5667 </span>            :         {</a>
<a name="5668"><span class="lineNum">    5668 </span>            :           printf (&quot;In SageInterface::declarationPreceedsDefinition() (warning): \n&quot;);</a>
<a name="5669"><span class="lineNum">    5669 </span>            :           printf (&quot;     nondefiningDeclaration                            = %p \n&quot;,nonDefiningDeclaration);</a>
<a name="5670"><span class="lineNum">    5670 </span>            :           printf (&quot;     nondefiningDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,nonDefiningDeclaration-&gt;get_definingDeclaration());</a>
<a name="5671"><span class="lineNum">    5671 </span>            :           printf (&quot;     definingDeclaration                               = %p \n&quot;,definingDeclaration);</a>
<a name="5672"><span class="lineNum">    5672 </span>            :         }</a>
<a name="5673"><span class="lineNum">    5673 </span>            : #endif</a>
<a name="5674"><span class="lineNum">    5674 </span>            : </a>
<a name="5675"><span class="lineNum">    5675 </span>            :   // define trival case of classNonDefiningDeclaration == classDefiningDeclaration to be false.</a>
<a name="5676"><span class="lineNum">    5676 </span><span class="lineCov">       3462 :      bool returnResult = false;</span></a>
<a name="5677"><span class="lineNum">    5677 </span><span class="lineCov">       3462 :      if (nonDefiningDeclaration != definingDeclaration)</span></a>
<a name="5678"><span class="lineNum">    5678 </span>            :         {</a>
<a name="5679"><span class="lineNum">    5679 </span>            :        // Get the global scope from a traversal back (up) through the AST.</a>
<a name="5680"><span class="lineNum">    5680 </span><span class="lineCov">       3462 :           SgGlobal* globalScope = TransformationSupport::getGlobalScope(definingDeclaration);</span></a>
<a name="5681"><span class="lineNum">    5681 </span><span class="lineCov">       3462 :           ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="5682"><span class="lineNum">    5682 </span>            : </a>
<a name="5683"><span class="lineNum">    5683 </span>            :        // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="5684"><span class="lineNum">    5684 </span><span class="lineCov">       6924 :           DeclarationOrderTraversal traversal (nonDefiningDeclaration,definingDeclaration);</span></a>
<a name="5685"><span class="lineNum">    5685 </span>            : </a>
<a name="5686"><span class="lineNum">    5686 </span>            : #if 0</a>
<a name="5687"><span class="lineNum">    5687 </span>            :           traversal.traverse(globalScope, preorder);</a>
<a name="5688"><span class="lineNum">    5688 </span>            : #else</a>
<a name="5689"><span class="lineNum">    5689 </span>            :        // DQ (5/29/2007): To avoid order n^2 complexity in unparsing we turn off the name qualification for now.</a>
<a name="5690"><span class="lineNum">    5690 </span><span class="lineCov">       3462 :           printf (&quot;Skipping traversal within SageInterface::declarationPreceedsDefinition() \n&quot;);</span></a>
<a name="5691"><span class="lineNum">    5691 </span><span class="lineCov">       3462 :           traversal.storedDeclarationFound = true;</span></a>
<a name="5692"><span class="lineNum">    5692 </span><span class="lineCov">       3462 :           traversal.nonDefiningDeclarationPreceedsDefiningDeclaration = false;</span></a>
<a name="5693"><span class="lineNum">    5693 </span>            : #endif</a>
<a name="5694"><span class="lineNum">    5694 </span>            : </a>
<a name="5695"><span class="lineNum">    5695 </span>            :        // I hope that we have found the input nondefining or defining declaration, if not let it be an error</a>
<a name="5696"><span class="lineNum">    5696 </span>            :        // for now.  There may however be good reasons why we might miss them (hidden island problem, or</a>
<a name="5697"><span class="lineNum">    5697 </span>            :        // nondefining declarations that are not in the traversal).</a>
<a name="5698"><span class="lineNum">    5698 </span>            : </a>
<a name="5699"><span class="lineNum">    5699 </span><span class="lineCov">       3462 :           if (traversal.storedDeclarationFound == false)</span></a>
<a name="5700"><span class="lineNum">    5700 </span>            :              {</a>
<a name="5701"><span class="lineNum">    5701 </span>            : #if 0</a>
<a name="5702"><span class="lineNum">    5702 </span>            :                printf (&quot;In SageInterface::declarationPreceedsDefinition(): warning, nonDefiningDeclaration not found in the AST \n&quot;);</a>
<a name="5703"><span class="lineNum">    5703 </span>            :                nonDefiningDeclaration-&gt;get_file_info()-&gt;display(&quot;nonDefiningDeclaration&quot;);</a>
<a name="5704"><span class="lineNum">    5704 </span>            :                definingDeclaration-&gt;get_file_info()-&gt;display(&quot;definingDeclaration&quot;);</a>
<a name="5705"><span class="lineNum">    5705 </span>            :                printf (&quot;---------------------------------------------------- \n\n&quot;);</a>
<a name="5706"><span class="lineNum">    5706 </span>            : #endif</a>
<a name="5707"><span class="lineNum">    5707 </span>            :             // Set this error case to return true so that we will not assume incorrectly</a>
<a name="5708"><span class="lineNum">    5708 </span>            :             // that the classNonDefiningDeclaration apears after the classDefiningDeclaration.</a>
<a name="5709"><span class="lineNum">    5709 </span>            :                returnResult = true;</a>
<a name="5710"><span class="lineNum">    5710 </span>            :              }</a>
<a name="5711"><span class="lineNum">    5711 </span>            :             else</a>
<a name="5712"><span class="lineNum">    5712 </span>            :              {</a>
<a name="5713"><span class="lineNum">    5713 </span><span class="lineCov">       3462 :                returnResult = traversal.nonDefiningDeclarationPreceedsDefiningDeclaration;</span></a>
<a name="5714"><span class="lineNum">    5714 </span>            :              }</a>
<a name="5715"><span class="lineNum">    5715 </span>            : </a>
<a name="5716"><span class="lineNum">    5716 </span>            :        // ROSE_ASSERT(traversal.storedDeclarationFound == true);</a>
<a name="5717"><span class="lineNum">    5717 </span>            :         }</a>
<a name="5718"><span class="lineNum">    5718 </span>            : #if 0</a>
<a name="5719"><span class="lineNum">    5719 </span>            :      printf (&quot;returnResult = %s \n&quot;,returnResult ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5720"><span class="lineNum">    5720 </span>            :      printf (&quot;************************************************************* \n\n&quot;);</a>
<a name="5721"><span class="lineNum">    5721 </span>            : #endif</a>
<a name="5722"><span class="lineNum">    5722 </span><span class="lineCov">       3462 :      return returnResult;</span></a>
<a name="5723"><span class="lineNum">    5723 </span>            :    }</a>
<a name="5724"><span class="lineNum">    5724 </span>            : </a>
<a name="5725"><span class="lineNum">    5725 </span>            : </a>
<a name="5726"><span class="lineNum">    5726 </span>            : bool</a>
<a name="5727"><span class="lineNum">    5727 </span><span class="lineNoCov">          0 : SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope ( SgFunctionCallExp* functionCall )</span></a>
<a name="5728"><span class="lineNum">    5728 </span>            :    {</a>
<a name="5729"><span class="lineNum">    5729 </span>            :   // This function is used in the unparser, but might be more generally useful.  Since it is</a>
<a name="5730"><span class="lineNum">    5730 </span>            :   // related to general AST tests, I have put it here.  It might be alternatively put in the</a>
<a name="5731"><span class="lineNum">    5731 </span>            :   // src/backend/unparser or related utility directory.</a>
<a name="5732"><span class="lineNum">    5732 </span>            : </a>
<a name="5733"><span class="lineNum">    5733 </span>            :   // Preorder traversal to test the order of declaration of non-defining vs. defining class</a>
<a name="5734"><span class="lineNum">    5734 </span>            :   // declarations in the preorder traversal of the AST.</a>
<a name="5735"><span class="lineNum">    5735 </span><span class="lineNoCov">          0 :      class DeclarationOrderTraversal : public AstSimpleProcessing</span></a>
<a name="5736"><span class="lineNum">    5736 </span>            :         {</a>
<a name="5737"><span class="lineNum">    5737 </span>            :           public:</a>
<a name="5738"><span class="lineNum">    5738 </span><span class="lineNoCov">          0 :                DeclarationOrderTraversal( SgFunctionCallExp* functionCall )</span></a>
<a name="5739"><span class="lineNum">    5739 </span><span class="lineNoCov">          0 :                   : storedFunctionCall(functionCall)</span></a>
<a name="5740"><span class="lineNum">    5740 </span>            :                   {</a>
<a name="5741"><span class="lineNum">    5741 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionCall != NULL);</span></a>
<a name="5742"><span class="lineNum">    5742 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(functionCall-&gt;get_function() != NULL);</span></a>
<a name="5743"><span class="lineNum">    5743 </span><span class="lineNoCov">          0 :                     SgExpression* functionExpression = functionCall-&gt;get_function();</span></a>
<a name="5744"><span class="lineNum">    5744 </span>            : </a>
<a name="5745"><span class="lineNum">    5745 </span><span class="lineNoCov">          0 :                     switch (functionExpression-&gt;variantT())</span></a>
<a name="5746"><span class="lineNum">    5746 </span>            :                        {</a>
<a name="5747"><span class="lineNum">    5747 </span>            :                       // these are the acceptable cases</a>
<a name="5748"><span class="lineNum">    5748 </span><span class="lineNoCov">          0 :                          case V_SgDotExp:</span></a>
<a name="5749"><span class="lineNum">    5749 </span><span class="lineNoCov">          0 :                          case V_SgDotStarOp:</span></a>
<a name="5750"><span class="lineNum">    5750 </span><span class="lineNoCov">          0 :                          case V_SgArrowExp:</span></a>
<a name="5751"><span class="lineNum">    5751 </span><span class="lineNoCov">          0 :                          case V_SgArrowStarOp:</span></a>
<a name="5752"><span class="lineNum">    5752 </span><span class="lineNoCov">          0 :                          case V_SgPointerDerefExp:</span></a>
<a name="5753"><span class="lineNum">    5753 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="5754"><span class="lineNum">    5754 </span>            :                            // These are the acceptable cases, but not handled yet.</a>
<a name="5755"><span class="lineNum">    5755 </span><span class="lineNoCov">          0 :                               printf (&quot;These are the acceptable cases, but not handled yet... \n&quot;);</span></a>
<a name="5756"><span class="lineNum">    5756 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="5757"><span class="lineNum">    5757 </span>            :                             }</a>
<a name="5758"><span class="lineNum">    5758 </span>            : </a>
<a name="5759"><span class="lineNum">    5759 </span><span class="lineNoCov">          0 :                          case V_SgFunctionRefExp:</span></a>
<a name="5760"><span class="lineNum">    5760 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="5761"><span class="lineNum">    5761 </span><span class="lineNoCov">          0 :                               SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(functionExpression);</span></a>
<a name="5762"><span class="lineNum">    5762 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(functionRefExp != NULL);</span></a>
<a name="5763"><span class="lineNum">    5763 </span><span class="lineNoCov">          0 :                               SgFunctionSymbol* functionSymbol = functionRefExp-&gt;get_symbol();</span></a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="5765"><span class="lineNum">    5765 </span>            : </a>
<a name="5766"><span class="lineNum">    5766 </span>            :                            // Make sure that the function has a valid declaration</a>
<a name="5767"><span class="lineNum">    5767 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(functionSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="5768"><span class="lineNum">    5768 </span><span class="lineNoCov">          0 :                               storedFunctionDeclaration = functionSymbol-&gt;get_declaration();</span></a>
<a name="5769"><span class="lineNum">    5769 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="5770"><span class="lineNum">    5770 </span>            :                             }</a>
<a name="5771"><span class="lineNum">    5771 </span>            : </a>
<a name="5772"><span class="lineNum">    5772 </span><span class="lineNoCov">          0 :                          case V_SgMemberFunctionRefExp:</span></a>
<a name="5773"><span class="lineNum">    5773 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="5774"><span class="lineNum">    5774 </span><span class="lineNoCov">          0 :                               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(functionExpression);</span></a>
<a name="5775"><span class="lineNum">    5775 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(memberFunctionRefExp != NULL);</span></a>
<a name="5776"><span class="lineNum">    5776 </span><span class="lineNoCov">          0 :                               SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="5777"><span class="lineNum">    5777 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(memberFunctionSymbol != NULL);</span></a>
<a name="5778"><span class="lineNum">    5778 </span>            : </a>
<a name="5779"><span class="lineNum">    5779 </span><span class="lineNoCov">          0 :                               storedFunctionDeclaration = memberFunctionSymbol-&gt;get_declaration();</span></a>
<a name="5780"><span class="lineNum">    5780 </span>            : </a>
<a name="5781"><span class="lineNum">    5781 </span><span class="lineNoCov">          0 :                               printf (&quot;V_SgMemberFunctionRefExp case not handled yet... \n&quot;);</span></a>
<a name="5782"><span class="lineNum">    5782 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="5783"><span class="lineNum">    5783 </span>            :                             }</a>
<a name="5784"><span class="lineNum">    5784 </span>            : </a>
<a name="5785"><span class="lineNum">    5785 </span><span class="lineNoCov">          0 :                          default:</span></a>
<a name="5786"><span class="lineNum">    5786 </span><span class="lineNoCov">          0 :                             {</span></a>
<a name="5787"><span class="lineNum">    5787 </span><span class="lineNoCov">          0 :                               printf (&quot;default reached in SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() functionExpression = %s \n&quot;,</span></a>
<a name="5788"><span class="lineNum">    5788 </span><span class="lineNoCov">          0 :                                    functionExpression-&gt;class_name().c_str());</span></a>
<a name="5789"><span class="lineNum">    5789 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="5790"><span class="lineNum">    5790 </span>            :                             }</a>
<a name="5791"><span class="lineNum">    5791 </span>            :                        }</a>
<a name="5792"><span class="lineNum">    5792 </span>            :                  // ROSE_ASSERT(functionCall-&gt;get_declaration() != NULL);</a>
<a name="5793"><span class="lineNum">    5793 </span>            :                  // ROSE_ASSERT(functionCall-&gt;get_function()-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="5794"><span class="lineNum">    5794 </span>            :                  // storedFunctionDeclaration = functionCall-&gt;get_declaration()-&gt;get_firstNondefiningDeclaration();</a>
<a name="5795"><span class="lineNum">    5795 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedFunctionDeclaration != NULL);</span></a>
<a name="5796"><span class="lineNum">    5796 </span>            : </a>
<a name="5797"><span class="lineNum">    5797 </span><span class="lineNoCov">          0 :                     storedFunctionCallFound                                       = false;</span></a>
<a name="5798"><span class="lineNum">    5798 </span><span class="lineNoCov">          0 :                     functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;</span></a>
<a name="5799"><span class="lineNum">    5799 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="5800"><span class="lineNum">    5800 </span>            : </a>
<a name="5801"><span class="lineNum">    5801 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="5802"><span class="lineNum">    5802 </span>            :                   {</a>
<a name="5803"><span class="lineNum">    5803 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedFunctionCall != NULL);</span></a>
<a name="5804"><span class="lineNum">    5804 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(storedFunctionDeclaration != NULL);</span></a>
<a name="5805"><span class="lineNum">    5805 </span>            :                  // ROSE_ASSERT(storedFunctionCall != storedFunctionDeclaration);</a>
<a name="5806"><span class="lineNum">    5806 </span>            : </a>
<a name="5807"><span class="lineNum">    5807 </span><span class="lineNoCov">          0 :                     if (storedFunctionCallFound == false)</span></a>
<a name="5808"><span class="lineNum">    5808 </span>            :                        {</a>
<a name="5809"><span class="lineNum">    5809 </span><span class="lineNoCov">          0 :                          SgFunctionCallExp* functionCall = isSgFunctionCallExp(node);</span></a>
<a name="5810"><span class="lineNum">    5810 </span><span class="lineNoCov">          0 :                          if ( functionCall != NULL )</span></a>
<a name="5811"><span class="lineNum">    5811 </span>            :                             {</a>
<a name="5812"><span class="lineNum">    5812 </span><span class="lineNoCov">          0 :                               if (functionCall == storedFunctionCall)</span></a>
<a name="5813"><span class="lineNum">    5813 </span>            :                                  {</a>
<a name="5814"><span class="lineNum">    5814 </span><span class="lineNoCov">          0 :                                    storedFunctionCallFound = true;</span></a>
<a name="5815"><span class="lineNum">    5815 </span>            : </a>
<a name="5816"><span class="lineNum">    5816 </span>            :                                 // A declaration for the function in a scope where the function could be defined</a>
<a name="5817"><span class="lineNum">    5817 </span>            :                                 // (and a scope associated with it) has not been found so the function call</a>
<a name="5818"><span class="lineNum">    5818 </span>            :                                 // preceeds such a declaration (if it even exists).</a>
<a name="5819"><span class="lineNum">    5819 </span><span class="lineNoCov">          0 :                                    functionCallExpressionPreceedsDeclarationWhichAssociatesScope = true;</span></a>
<a name="5820"><span class="lineNum">    5820 </span>            :                                  }</a>
<a name="5821"><span class="lineNum">    5821 </span>            :                             }</a>
<a name="5822"><span class="lineNum">    5822 </span>            : </a>
<a name="5823"><span class="lineNum">    5823 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* declaration = isSgDeclarationStatement(node);</span></a>
<a name="5824"><span class="lineNum">    5824 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(storedFunctionDeclaration != NULL);</span></a>
<a name="5825"><span class="lineNum">    5825 </span>            : </a>
<a name="5826"><span class="lineNum">    5826 </span>            :                       // Note that all firstNondefiningDeclaration are set to the same declaration (for all associated declarations).</a>
<a name="5827"><span class="lineNum">    5827 </span>            :                       // Need to check the result of get_firstNondefiningDeclaration() since this will be the same for all declarations</a>
<a name="5828"><span class="lineNum">    5828 </span>            :                       // of the same function and thus can be used to match that we have an associated declaration for the same function.</a>
<a name="5829"><span class="lineNum">    5829 </span>            :                       // if ( declaration != NULL &amp;&amp; declaration-&gt;get_firstNondefiningDeclaration() == storedFunctionDeclaration)</a>
<a name="5830"><span class="lineNum">    5830 </span><span class="lineNoCov">          0 :                          if ( declaration != NULL &amp;&amp; declaration-&gt;get_firstNondefiningDeclaration() == storedFunctionDeclaration-&gt;get_firstNondefiningDeclaration())</span></a>
<a name="5831"><span class="lineNum">    5831 </span>            :                             {</a>
<a name="5832"><span class="lineNum">    5832 </span>            :                            // Test if this is a declaration is a scope where the existance of the forward</a>
<a name="5833"><span class="lineNum">    5833 </span>            :                            // declaration will define the scope fo the function declaration.</a>
<a name="5834"><span class="lineNum">    5834 </span>            :                            // if (declaration-&gt;get_scope()-&gt;supportsDefiningFunctionDeclaration() == true)</a>
<a name="5835"><span class="lineNum">    5835 </span><span class="lineNoCov">          0 :                               SgScopeStatement* parentScopeOfDeclaration = isSgScopeStatement(declaration-&gt;get_parent());</span></a>
<a name="5836"><span class="lineNum">    5836 </span><span class="lineNoCov">          0 :                               if (parentScopeOfDeclaration != NULL &amp;&amp; parentScopeOfDeclaration-&gt;supportsDefiningFunctionDeclaration() == true)</span></a>
<a name="5837"><span class="lineNum">    5837 </span>            :                                  {</a>
<a name="5838"><span class="lineNum">    5838 </span>            :                                 // We are done so we can skip further testing</a>
<a name="5839"><span class="lineNum">    5839 </span><span class="lineNoCov">          0 :                                    storedFunctionCallFound = true;</span></a>
<a name="5840"><span class="lineNum">    5840 </span>            : </a>
<a name="5841"><span class="lineNum">    5841 </span>            :                                 // We have found a declaration which will associated the scope of a function declaration</a>
<a name="5842"><span class="lineNum">    5842 </span>            :                                 // (so all function calls after this point can be qualified (and might have to be).</a>
<a name="5843"><span class="lineNum">    5843 </span><span class="lineNoCov">          0 :                                    functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;</span></a>
<a name="5844"><span class="lineNum">    5844 </span>            : #if 0</a>
<a name="5845"><span class="lineNum">    5845 </span>            :                                    printf (&quot;Found a declaration which preceeds the function \n&quot;);</a>
<a name="5846"><span class="lineNum">    5846 </span>            :                                    declaration-&gt;get_file_info()-&gt;display(&quot;Found a declaration which preceeds the function: declaration&quot;);</a>
<a name="5847"><span class="lineNum">    5847 </span>            :                                    storedFunctionCall-&gt;get_file_info()-&gt;display(&quot;Found a declaration which preceeds the function: storedFunctionCall&quot;);</a>
<a name="5848"><span class="lineNum">    5848 </span>            :                                    storedFunctionDeclaration-&gt;get_file_info()-&gt;display(&quot;Found a declaration which preceeds the function: storedFunctionDeclaration&quot;);</a>
<a name="5849"><span class="lineNum">    5849 </span>            : #endif</a>
<a name="5850"><span class="lineNum">    5850 </span>            :                                  }</a>
<a name="5851"><span class="lineNum">    5851 </span>            :                                 else</a>
<a name="5852"><span class="lineNum">    5852 </span>            :                                  {</a>
<a name="5853"><span class="lineNum">    5853 </span>            :                                 // Error checking!</a>
<a name="5854"><span class="lineNum">    5854 </span><span class="lineNoCov">          0 :                                    if (parentScopeOfDeclaration == NULL)</span></a>
<a name="5855"><span class="lineNum">    5855 </span>            :                                       {</a>
<a name="5856"><span class="lineNum">    5856 </span>            :                                      // This might be a function declaration (non-defining) used in a type or buried deeply in some sort of declaration!</a>
<a name="5857"><span class="lineNum">    5857 </span><span class="lineNoCov">          0 :                                         printf (&quot;Strange case of parentScopeOfDeclaration == NULL in SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() \n&quot;);</span></a>
<a name="5858"><span class="lineNum">    5858 </span><span class="lineNoCov">          0 :                                         SgNode* parent = declaration-&gt;get_parent();</span></a>
<a name="5859"><span class="lineNum">    5859 </span><span class="lineNoCov">          0 :                                         if (parent != NULL) {</span></a>
<a name="5860"><span class="lineNum">    5860 </span><span class="lineNoCov">          0 :                                            printf (&quot;declaration-&gt;get_parent() = %s \n&quot;,parent-&gt;class_name().c_str());</span></a>
<a name="5861"><span class="lineNum">    5861 </span>            :                                         }</a>
<a name="5862"><span class="lineNum">    5862 </span>            :                                         else {</a>
<a name="5863"><span class="lineNum">    5863 </span><span class="lineNoCov">          0 :                                            printf (&quot;declaration-&gt;get_parent() = NULL \n&quot;);</span></a>
<a name="5864"><span class="lineNum">    5864 </span>            :                                         }</a>
<a name="5865"><span class="lineNum">    5865 </span><span class="lineNoCov">          0 :                                         declaration-&gt;get_file_info()-&gt;display(&quot;case of parentScopeOfDeclaration == NULL&quot;);</span></a>
<a name="5866"><span class="lineNum">    5866 </span><span class="lineNoCov">          0 :                                         ROSE_ABORT();</span></a>
<a name="5867"><span class="lineNum">    5867 </span>            :                                       }</a>
<a name="5868"><span class="lineNum">    5868 </span>            :                                  }</a>
<a name="5869"><span class="lineNum">    5869 </span>            :                             }</a>
<a name="5870"><span class="lineNum">    5870 </span>            :                        }</a>
<a name="5871"><span class="lineNum">    5871 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="5872"><span class="lineNum">    5872 </span>            : </a>
<a name="5873"><span class="lineNum">    5873 </span>            :           public:</a>
<a name="5874"><span class="lineNum">    5874 </span>            :                bool storedFunctionCallFound;</a>
<a name="5875"><span class="lineNum">    5875 </span>            :                bool functionCallExpressionPreceedsDeclarationWhichAssociatesScope;</a>
<a name="5876"><span class="lineNum">    5876 </span>            : </a>
<a name="5877"><span class="lineNum">    5877 </span>            :           private:</a>
<a name="5878"><span class="lineNum">    5878 </span>            :                SgFunctionCallExp* storedFunctionCall;</a>
<a name="5879"><span class="lineNum">    5879 </span>            :                SgDeclarationStatement* storedFunctionDeclaration;</a>
<a name="5880"><span class="lineNum">    5880 </span>            :         };</a>
<a name="5881"><span class="lineNum">    5881 </span>            : </a>
<a name="5882"><span class="lineNum">    5882 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(functionCall != NULL);</span></a>
<a name="5883"><span class="lineNum">    5883 </span>            : #if 0</a>
<a name="5884"><span class="lineNum">    5884 </span>            :      printf (&quot;In SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope(): \n&quot;);</a>
<a name="5885"><span class="lineNum">    5885 </span>            :      printf (&quot;     storedFunctionCall                           = %p = %s \n&quot;,functionCall,functionCall-&gt;class_name().c_str());</a>
<a name="5886"><span class="lineNum">    5886 </span>            :      functionCall-&gt;get_file_info()-&gt;display(&quot;storedFunctionCall&quot;);</a>
<a name="5887"><span class="lineNum">    5887 </span>            :      printf (&quot;     storedFunctionCall-&gt;get_function() = %p = %s \n&quot;,functionCall-&gt;get_function(),functionCall-&gt;get_function()-&gt;class_name().c_str());</a>
<a name="5888"><span class="lineNum">    5888 </span>            :      printf (&quot;************************************************************* \n&quot;);</a>
<a name="5889"><span class="lineNum">    5889 </span>            : #endif</a>
<a name="5890"><span class="lineNum">    5890 </span>            : </a>
<a name="5891"><span class="lineNum">    5891 </span>            :   // define trival case of classNonDefiningDeclaration == classDefiningDeclaration to be false.</a>
<a name="5892"><span class="lineNum">    5892 </span><span class="lineNoCov">          0 :      bool returnResult = false;</span></a>
<a name="5893"><span class="lineNum">    5893 </span>            : </a>
<a name="5894"><span class="lineNum">    5894 </span>            :   // Get the global scope from a traversal back (up) through the AST.</a>
<a name="5895"><span class="lineNum">    5895 </span><span class="lineNoCov">          0 :      SgGlobal* globalScope = TransformationSupport::getGlobalScope(functionCall);</span></a>
<a name="5896"><span class="lineNum">    5896 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="5897"><span class="lineNum">    5897 </span>            : </a>
<a name="5898"><span class="lineNum">    5898 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="5899"><span class="lineNum">    5899 </span><span class="lineNoCov">          0 :      DeclarationOrderTraversal traversal (functionCall);</span></a>
<a name="5900"><span class="lineNum">    5900 </span>            : </a>
<a name="5901"><span class="lineNum">    5901 </span>            : #if 0</a>
<a name="5902"><span class="lineNum">    5902 </span>            :      traversal.traverse(globalScope, preorder);</a>
<a name="5903"><span class="lineNum">    5903 </span>            : #else</a>
<a name="5904"><span class="lineNum">    5904 </span>            :   // DQ (5/29/2007): To avoid order n^2 complexity in unparsing we turn off the name qualification for now.</a>
<a name="5905"><span class="lineNum">    5905 </span><span class="lineNoCov">          0 :      printf (&quot;Skipping traversal within SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() \n&quot;);</span></a>
<a name="5906"><span class="lineNum">    5906 </span><span class="lineNoCov">          0 :      traversal.storedFunctionCallFound = true;</span></a>
<a name="5907"><span class="lineNum">    5907 </span><span class="lineNoCov">          0 :      traversal.functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;</span></a>
<a name="5908"><span class="lineNum">    5908 </span>            : #endif</a>
<a name="5909"><span class="lineNum">    5909 </span>            : </a>
<a name="5910"><span class="lineNum">    5910 </span>            :   // I hope that we have found the input nondefining or defining declaration, if not let it be an error</a>
<a name="5911"><span class="lineNum">    5911 </span>            :   // for now.  There may however be good reasons why we might miss them (hidden island problem, or</a>
<a name="5912"><span class="lineNum">    5912 </span>            :   // nondefining declarations that are not in the traversal).</a>
<a name="5913"><span class="lineNum">    5913 </span>            : </a>
<a name="5914"><span class="lineNum">    5914 </span><span class="lineNoCov">          0 :      if (traversal.storedFunctionCallFound == false)</span></a>
<a name="5915"><span class="lineNum">    5915 </span>            :         {</a>
<a name="5916"><span class="lineNum">    5916 </span>            : #if 0</a>
<a name="5917"><span class="lineNum">    5917 </span>            :           printf (&quot;In SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope(): warning, storedFunctionCall not found in the AST \n&quot;);</a>
<a name="5918"><span class="lineNum">    5918 </span>            :           functionCall-&gt;get_file_info()-&gt;display(&quot;functionCall&quot;);</a>
<a name="5919"><span class="lineNum">    5919 </span>            :           printf (&quot;---------------------------------------------------- \n\n&quot;);</a>
<a name="5920"><span class="lineNum">    5920 </span>            : #endif</a>
<a name="5921"><span class="lineNum">    5921 </span>            :        // Set this error case to return true so that we will not assume incorrectly</a>
<a name="5922"><span class="lineNum">    5922 </span>            :        // that the function call is used after a declaration that associated the scope</a>
<a name="5923"><span class="lineNum">    5923 </span>            :        // with the function.  This still causes the global name qualifier to be omitted.</a>
<a name="5924"><span class="lineNum">    5924 </span>            :           returnResult = true;</a>
<a name="5925"><span class="lineNum">    5925 </span>            :         }</a>
<a name="5926"><span class="lineNum">    5926 </span>            :        else</a>
<a name="5927"><span class="lineNum">    5927 </span>            :         {</a>
<a name="5928"><span class="lineNum">    5928 </span><span class="lineNoCov">          0 :           returnResult = traversal.functionCallExpressionPreceedsDeclarationWhichAssociatesScope;</span></a>
<a name="5929"><span class="lineNum">    5929 </span>            :         }</a>
<a name="5930"><span class="lineNum">    5930 </span>            : </a>
<a name="5931"><span class="lineNum">    5931 </span>            :   // I hope that this is nearly always be true!</a>
<a name="5932"><span class="lineNum">    5932 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(traversal.storedFunctionCallFound == true);</span></a>
<a name="5933"><span class="lineNum">    5933 </span>            : #if 0</a>
<a name="5934"><span class="lineNum">    5934 </span>            :      printf (&quot;returnResult = %s \n&quot;,returnResult ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5935"><span class="lineNum">    5935 </span>            :      printf (&quot;************************************************************* \n\n&quot;);</a>
<a name="5936"><span class="lineNum">    5936 </span>            : #endif</a>
<a name="5937"><span class="lineNum">    5937 </span><span class="lineNoCov">          0 :      return returnResult;</span></a>
<a name="5938"><span class="lineNum">    5938 </span>            :    }</a>
<a name="5939"><span class="lineNum">    5939 </span>            : </a>
<a name="5940"><span class="lineNum">    5940 </span>            : #endif</a>
<a name="5941"><span class="lineNum">    5941 </span>            : </a>
<a name="5942"><span class="lineNum">    5942 </span>            : // #ifndef USE_ROSE</a>
<a name="5943"><span class="lineNum">    5943 </span>            : </a>
<a name="5944"><span class="lineNum">    5944 </span>            : string</a>
<a name="5945"><span class="lineNum">    5945 </span><span class="lineCov">        330 : SageInterface::generateProjectName( const SgProject* project, bool supressSuffix )</span></a>
<a name="5946"><span class="lineNum">    5946 </span>            :    {</a>
<a name="5947"><span class="lineNum">    5947 </span>            :   // This function generates a string to use as a unique project name for</a>
<a name="5948"><span class="lineNum">    5948 </span>            :   // a collection of files.  The last file will include it's suffix so that</a>
<a name="5949"><span class="lineNum">    5949 </span>            :   // we generate proper names that communicate the source language.</a>
<a name="5950"><span class="lineNum">    5950 </span>            :   // Also also allows the single file case to be consistant with the previous</a>
<a name="5951"><span class="lineNum">    5951 </span>            :   // version of names generated for &quot;DOT&quot; files in the tutorial.</a>
<a name="5952"><span class="lineNum">    5952 </span>            : </a>
<a name="5953"><span class="lineNum">    5953 </span>            :   // DQ (9/6/2008): Introduced optional parameter to supresse the suffix in the</a>
<a name="5954"><span class="lineNum">    5954 </span>            :   // generation of the project name so that we can support more complex name</a>
<a name="5955"><span class="lineNum">    5955 </span>            :   // construction as required for the generation of names for the whole AST</a>
<a name="5956"><span class="lineNum">    5956 </span>            :   // graphs which append an additional suffix to avoid filename collision.</a>
<a name="5957"><span class="lineNum">    5957 </span>            : </a>
<a name="5958"><span class="lineNum">    5958 </span><span class="lineCov">        330 :      ROSE_ASSERT(project != NULL);</span></a>
<a name="5959"><span class="lineNum">    5959 </span><span class="lineCov">        660 :      string projectName;</span></a>
<a name="5960"><span class="lineNum">    5960 </span>            : </a>
<a name="5961"><span class="lineNum">    5961 </span>            :   // DQ (9/2/2008): Removed the redundant function getFileNames().</a>
<a name="5962"><span class="lineNum">    5962 </span>            :   // Rose_STL_Container&lt;string&gt; fileList = project-&gt;get_sourceFileNameList();</a>
<a name="5963"><span class="lineNum">    5963 </span><span class="lineCov">        660 :      Rose_STL_Container&lt;string&gt; fileList = project-&gt;getAbsolutePathFileNames();</span></a>
<a name="5964"><span class="lineNum">    5964 </span>            : </a>
<a name="5965"><span class="lineNum">    5965 </span><span class="lineCov">        330 :      Rose_STL_Container&lt;string&gt;::iterator i = fileList.begin();</span></a>
<a name="5966"><span class="lineNum">    5966 </span>            : </a>
<a name="5967"><span class="lineNum">    5967 </span>            :   // Handle the case of an empty list (e.g. for link lines).</a>
<a name="5968"><span class="lineNum">    5968 </span><span class="lineCov">        330 :      if ( fileList.empty() == true )</span></a>
<a name="5969"><span class="lineNum">    5969 </span>            :         {</a>
<a name="5970"><span class="lineNum">    5970 </span><span class="lineNoCov">          0 :           return &quot;empty_file_list&quot;;</span></a>
<a name="5971"><span class="lineNum">    5971 </span>            :         }</a>
<a name="5972"><span class="lineNum">    5972 </span>            : </a>
<a name="5973"><span class="lineNum">    5973 </span><span class="lineCov">        333 :      do {</span></a>
<a name="5974"><span class="lineNum">    5974 </span><span class="lineCov">        333 :           string filename = *i;</span></a>
<a name="5975"><span class="lineNum">    5975 </span>            : </a>
<a name="5976"><span class="lineNum">    5976 </span>            :        // printf (&quot;In SageInterface::generateProjectName(): absolute filename = %s \n&quot;,filename.c_str());</a>
<a name="5977"><span class="lineNum">    5977 </span>            : </a>
<a name="5978"><span class="lineNum">    5978 </span>            :        // string filenameWithoutSuffix       = StringUtility::stripFileSuffixFromFileName(filename);</a>
<a name="5979"><span class="lineNum">    5979 </span>            : </a>
<a name="5980"><span class="lineNum">    5980 </span><span class="lineCov">        333 :           if (i != fileList.begin())</span></a>
<a name="5981"><span class="lineNum">    5981 </span><span class="lineCov">          3 :                projectName += &quot;--&quot;;</span></a>
<a name="5982"><span class="lineNum">    5982 </span>            : </a>
<a name="5983"><span class="lineNum">    5983 </span><span class="lineCov">        333 :           i++;</span></a>
<a name="5984"><span class="lineNum">    5984 </span>            : </a>
<a name="5985"><span class="lineNum">    5985 </span><span class="lineCov">        666 :           string filenameWithoutSuffix;</span></a>
<a name="5986"><span class="lineNum">    5986 </span><span class="lineCov">        333 :           if ( i != fileList.end() || supressSuffix == true )</span></a>
<a name="5987"><span class="lineNum">    5987 </span><span class="lineCov">          5 :                filenameWithoutSuffix = StringUtility::stripFileSuffixFromFileName(filename);</span></a>
<a name="5988"><span class="lineNum">    5988 </span>            :             else</a>
<a name="5989"><span class="lineNum">    5989 </span><span class="lineCov">        328 :                filenameWithoutSuffix = filename;</span></a>
<a name="5990"><span class="lineNum">    5990 </span>            : </a>
<a name="5991"><span class="lineNum">    5991 </span><span class="lineCov">        666 :           string filenameWithoutPathOrSuffix = StringUtility::stripPathFromFileName(filenameWithoutSuffix);</span></a>
<a name="5992"><span class="lineNum">    5992 </span>            : </a>
<a name="5993"><span class="lineNum">    5993 </span>            :        // printf (&quot;filenameWithoutSuffix       = %s \n&quot;,filenameWithoutSuffix.c_str());</a>
<a name="5994"><span class="lineNum">    5994 </span>            :        // printf (&quot;filenameWithoutPathOrSuffix = %s \n&quot;,filenameWithoutPathOrSuffix.c_str());</a>
<a name="5995"><span class="lineNum">    5995 </span>            : </a>
<a name="5996"><span class="lineNum">    5996 </span><span class="lineCov">        333 :           filename = filenameWithoutPathOrSuffix;</span></a>
<a name="5997"><span class="lineNum">    5997 </span>            : </a>
<a name="5998"><span class="lineNum">    5998 </span>            :           unsigned long int n = 0;</a>
<a name="5999"><span class="lineNum">    5999 </span><span class="lineCov">       5774 :           while (n &lt; filename.size())</span></a>
<a name="6000"><span class="lineNum">    6000 </span>            :              {</a>
<a name="6001"><span class="lineNum">    6001 </span><span class="lineCov">       5441 :                if (filename[n] == '/')</span></a>
<a name="6002"><span class="lineNum">    6002 </span><span class="lineNoCov">          0 :                     filename[n] = '_';</span></a>
<a name="6003"><span class="lineNum">    6003 </span><span class="lineCov">       5441 :                n++;</span></a>
<a name="6004"><span class="lineNum">    6004 </span>            :              }</a>
<a name="6005"><span class="lineNum">    6005 </span>            : </a>
<a name="6006"><span class="lineNum">    6006 </span>            :        // printf (&quot;In SageInterface:generateProjectName(): modified absolute filename = %s \n&quot;,filename.c_str());</a>
<a name="6007"><span class="lineNum">    6007 </span>            : </a>
<a name="6008"><span class="lineNum">    6008 </span><span class="lineCov">        333 :           projectName += filename;</span></a>
<a name="6009"><span class="lineNum">    6009 </span>            : </a>
<a name="6010"><span class="lineNum">    6010 </span>            :        // printf (&quot;In SageInterface:generateProjectName(): evolving projectName = %s \n&quot;,projectName.c_str());</a>
<a name="6011"><span class="lineNum">    6011 </span>            :         }</a>
<a name="6012"><span class="lineNum">    6012 </span><span class="lineCov">        333 :      while (i != fileList.end());</span></a>
<a name="6013"><span class="lineNum">    6013 </span>            : </a>
<a name="6014"><span class="lineNum">    6014 </span>            :   // printf (&quot;In SageInterface:generateProjectName(): projectName = %s \n&quot;,projectName.c_str());</a>
<a name="6015"><span class="lineNum">    6015 </span>            : </a>
<a name="6016"><span class="lineNum">    6016 </span><span class="lineCov">        660 :      return projectName;</span></a>
<a name="6017"><span class="lineNum">    6017 </span>            :    }</a>
<a name="6018"><span class="lineNum">    6018 </span>            : </a>
<a name="6019"><span class="lineNum">    6019 </span>            : // #endif</a>
<a name="6020"><span class="lineNum">    6020 </span>            : </a>
<a name="6021"><span class="lineNum">    6021 </span>            : // #ifndef USE_ROSE</a>
<a name="6022"><span class="lineNum">    6022 </span>            : </a>
<a name="6023"><span class="lineNum">    6023 </span>            : SgFunctionSymbol*</a>
<a name="6024"><span class="lineNum">    6024 </span><span class="lineCov">      11059 : SageInterface::lookupFunctionSymbolInParentScopes(const SgName &amp; functionName, SgScopeStatement* currentScope )</span></a>
<a name="6025"><span class="lineNum">    6025 </span>            :    {</a>
<a name="6026"><span class="lineNum">    6026 </span>            :   // DQ (11/24/2007): This function can return NULL.  It returns NULL when the function symbol is not found.</a>
<a name="6027"><span class="lineNum">    6027 </span>            :   // This can happen when a function is referenced before it it defined (no prototype mechanism in Fortran is required).</a>
<a name="6028"><span class="lineNum">    6028 </span>            : </a>
<a name="6029"><span class="lineNum">    6029 </span>            :   // enable default search from top of StackScope, Liao, 1/24/2008</a>
<a name="6030"><span class="lineNum">    6030 </span><span class="lineCov">      11059 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="6031"><span class="lineNum">    6031 </span><span class="lineCov">      11059 :      if (currentScope == NULL)</span></a>
<a name="6032"><span class="lineNum">    6032 </span><span class="lineNoCov">          0 :           currentScope = SageBuilder::topScopeStack();</span></a>
<a name="6033"><span class="lineNum">    6033 </span><span class="lineCov">      11059 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="6034"><span class="lineNum">    6034 </span>            : </a>
<a name="6035"><span class="lineNum">    6035 </span><span class="lineCov">      11059 :      SgScopeStatement* tempScope = currentScope;</span></a>
<a name="6036"><span class="lineNum">    6036 </span><span class="lineCov">      26551 :      while ((functionSymbol == NULL) &amp;&amp; (tempScope != NULL))</span></a>
<a name="6037"><span class="lineNum">    6037 </span>            :         {</a>
<a name="6038"><span class="lineNum">    6038 </span><span class="lineCov">      15492 :           functionSymbol = tempScope-&gt;lookup_function_symbol(functionName);</span></a>
<a name="6039"><span class="lineNum">    6039 </span>            : #if 0</a>
<a name="6040"><span class="lineNum">    6040 </span>            :           printf (&quot;In lookupFunctionSymbolInParentScopes(): Searching scope = %p = %s functionName = %s functionSymbol = %p \n&quot;,tempScope,tempScope-&gt;class_name().c_str(),functionName.str(),functionSymbol);</a>
<a name="6041"><span class="lineNum">    6041 </span>            : #endif</a>
<a name="6042"><span class="lineNum">    6042 </span><span class="lineCov">      15492 :           if (tempScope-&gt;get_parent()!=NULL) // avoid calling get_scope when parent is not set in middle of translation</span></a>
<a name="6043"><span class="lineNum">    6043 </span><span class="lineCov">      15429 :                tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="6044"><span class="lineNum">    6044 </span>            :             else</a>
<a name="6045"><span class="lineNum">    6045 </span>            :                tempScope = NULL;</a>
<a name="6046"><span class="lineNum">    6046 </span>            :         }</a>
<a name="6047"><span class="lineNum">    6047 </span><span class="lineCov">      11059 :      return functionSymbol;</span></a>
<a name="6048"><span class="lineNum">    6048 </span>            :    }</a>
<a name="6049"><span class="lineNum">    6049 </span>            : </a>
<a name="6050"><span class="lineNum">    6050 </span>            : SgFunctionSymbol*</a>
<a name="6051"><span class="lineNum">    6051 </span><span class="lineNoCov">          0 : SageInterface::lookupTemplateFunctionSymbolInParentScopes(const SgName &amp; functionName, SgFunctionType * ftype, SgTemplateParameterPtrList * tplparams, SgScopeStatement* currentScope )</span></a>
<a name="6052"><span class="lineNum">    6052 </span>            :    {</a>
<a name="6053"><span class="lineNum">    6053 </span>            :   // DQ (11/24/2007): This function can return NULL.  It returns NULL when the function symbol is not found.</a>
<a name="6054"><span class="lineNum">    6054 </span>            :   // This can happen when a function is referenced before it it defined (no prototype mechanism in Fortran is required).</a>
<a name="6055"><span class="lineNum">    6055 </span>            : </a>
<a name="6056"><span class="lineNum">    6056 </span>            :   // enable default search from top of StackScope, Liao, 1/24/2008</a>
<a name="6057"><span class="lineNum">    6057 </span><span class="lineNoCov">          0 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="6058"><span class="lineNum">    6058 </span><span class="lineNoCov">          0 :      if (currentScope == NULL)</span></a>
<a name="6059"><span class="lineNum">    6059 </span><span class="lineNoCov">          0 :           currentScope = SageBuilder::topScopeStack();</span></a>
<a name="6060"><span class="lineNum">    6060 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="6061"><span class="lineNum">    6061 </span>            : </a>
<a name="6062"><span class="lineNum">    6062 </span><span class="lineNoCov">          0 :      SgScopeStatement* tempScope = currentScope;</span></a>
<a name="6063"><span class="lineNum">    6063 </span><span class="lineNoCov">          0 :      while ((functionSymbol == NULL) &amp;&amp; (tempScope != NULL))</span></a>
<a name="6064"><span class="lineNum">    6064 </span>            :         {</a>
<a name="6065"><span class="lineNum">    6065 </span><span class="lineNoCov">          0 :           functionSymbol = tempScope-&gt;lookup_template_function_symbol(functionName, ftype, tplparams);</span></a>
<a name="6066"><span class="lineNum">    6066 </span>            : #if 0</a>
<a name="6067"><span class="lineNum">    6067 </span>            :           printf (&quot;In lookupTemplateFunctionSymbolInParentScopes(): Searching scope = %p = %s functionName = %s functionSymbol = %p \n&quot;,tempScope,tempScope-&gt;class_name().c_str(),functionName.str(),functionSymbol);</a>
<a name="6068"><span class="lineNum">    6068 </span>            : #endif</a>
<a name="6069"><span class="lineNum">    6069 </span><span class="lineNoCov">          0 :           if (tempScope-&gt;get_parent()!=NULL) // avoid calling get_scope when parent is not set in middle of translation</span></a>
<a name="6070"><span class="lineNum">    6070 </span><span class="lineNoCov">          0 :                tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="6071"><span class="lineNum">    6071 </span>            :             else</a>
<a name="6072"><span class="lineNum">    6072 </span>            :                tempScope = NULL;</a>
<a name="6073"><span class="lineNum">    6073 </span>            :         }</a>
<a name="6074"><span class="lineNum">    6074 </span><span class="lineNoCov">          0 :      return functionSymbol;</span></a>
<a name="6075"><span class="lineNum">    6075 </span>            :    }</a>
<a name="6076"><span class="lineNum">    6076 </span>            : </a>
<a name="6077"><span class="lineNum">    6077 </span>            : SgFunctionSymbol*</a>
<a name="6078"><span class="lineNum">    6078 </span><span class="lineNoCov">          0 : SageInterface::lookupTemplateMemberFunctionSymbolInParentScopes(const SgName &amp; functionName, SgFunctionType * ftype, SgTemplateParameterPtrList * tplparams, SgScopeStatement* currentScope )</span></a>
<a name="6079"><span class="lineNum">    6079 </span>            :    {</a>
<a name="6080"><span class="lineNum">    6080 </span>            :   // DQ (11/24/2007): This function can return NULL.  It returns NULL when the function symbol is not found.</a>
<a name="6081"><span class="lineNum">    6081 </span>            :   // This can happen when a function is referenced before it it defined (no prototype mechanism in Fortran is required).</a>
<a name="6082"><span class="lineNum">    6082 </span>            : </a>
<a name="6083"><span class="lineNum">    6083 </span>            :   // enable default search from top of StackScope, Liao, 1/24/2008</a>
<a name="6084"><span class="lineNum">    6084 </span><span class="lineNoCov">          0 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="6085"><span class="lineNum">    6085 </span><span class="lineNoCov">          0 :      if (currentScope == NULL)</span></a>
<a name="6086"><span class="lineNum">    6086 </span><span class="lineNoCov">          0 :           currentScope = SageBuilder::topScopeStack();</span></a>
<a name="6087"><span class="lineNum">    6087 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="6088"><span class="lineNum">    6088 </span>            : </a>
<a name="6089"><span class="lineNum">    6089 </span><span class="lineNoCov">          0 :      SgScopeStatement* tempScope = currentScope;</span></a>
<a name="6090"><span class="lineNum">    6090 </span><span class="lineNoCov">          0 :      while ((functionSymbol == NULL) &amp;&amp; (tempScope != NULL))</span></a>
<a name="6091"><span class="lineNum">    6091 </span>            :         {</a>
<a name="6092"><span class="lineNum">    6092 </span><span class="lineNoCov">          0 :           functionSymbol = tempScope-&gt;lookup_template_member_function_symbol(functionName, ftype, tplparams);</span></a>
<a name="6093"><span class="lineNum">    6093 </span>            : #if 0</a>
<a name="6094"><span class="lineNum">    6094 </span>            :           printf (&quot;In lookupTemplateMemberFunctionSymbolInParentScopes(): Searching scope = %p = %s functionName = %s functionSymbol = %p \n&quot;,tempScope,tempScope-&gt;class_name().c_str(),functionName.str(),functionSymbol);</a>
<a name="6095"><span class="lineNum">    6095 </span>            : #endif</a>
<a name="6096"><span class="lineNum">    6096 </span><span class="lineNoCov">          0 :           if (tempScope-&gt;get_parent()!=NULL) // avoid calling get_scope when parent is not set in middle of translation</span></a>
<a name="6097"><span class="lineNum">    6097 </span><span class="lineNoCov">          0 :                tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="6098"><span class="lineNum">    6098 </span>            :             else</a>
<a name="6099"><span class="lineNum">    6099 </span>            :                tempScope = NULL;</a>
<a name="6100"><span class="lineNum">    6100 </span>            :         }</a>
<a name="6101"><span class="lineNum">    6101 </span><span class="lineNoCov">          0 :      return functionSymbol;</span></a>
<a name="6102"><span class="lineNum">    6102 </span>            :    }</a>
<a name="6103"><span class="lineNum">    6103 </span>            : </a>
<a name="6104"><span class="lineNum">    6104 </span>            : void</a>
<a name="6105"><span class="lineNum">    6105 </span><span class="lineNoCov">          0 : SageInterface::addTextForUnparser ( SgNode* astNode, string s, AstUnparseAttribute::RelativePositionType inputlocation )</span></a>
<a name="6106"><span class="lineNum">    6106 </span>            :    {</a>
<a name="6107"><span class="lineNum">    6107 </span>            :   // printf (&quot;addText(): using new attribute interface (s = %s) \n&quot;,s.c_str());</a>
<a name="6108"><span class="lineNum">    6108 </span>            : </a>
<a name="6109"><span class="lineNum">    6109 </span><span class="lineNoCov">          0 :      if (isSgType(astNode) != NULL)</span></a>
<a name="6110"><span class="lineNum">    6110 </span>            :         {</a>
<a name="6111"><span class="lineNum">    6111 </span><span class="lineNoCov">          0 :           printf (&quot;Error: the mechanism to add text to be unparsed at IR nodes is not intended to operate on SgType IR nodes (since they are shared) \n&quot;);</span></a>
<a name="6112"><span class="lineNum">    6112 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="6113"><span class="lineNum">    6113 </span>            :         }</a>
<a name="6114"><span class="lineNum">    6114 </span>            : </a>
<a name="6115"><span class="lineNum">    6115 </span><span class="lineNoCov">          0 :      if (astNode-&gt;attributeExists(AstUnparseAttribute::markerName) == true)</span></a>
<a name="6116"><span class="lineNum">    6116 </span>            :         {</a>
<a name="6117"><span class="lineNum">    6117 </span><span class="lineNoCov">          0 :           AstUnparseAttribute* code = dynamic_cast&lt;AstUnparseAttribute*&gt;(astNode-&gt;getAttribute(AstUnparseAttribute::markerName));</span></a>
<a name="6118"><span class="lineNum">    6118 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(code != NULL);</span></a>
<a name="6119"><span class="lineNum">    6119 </span>            : </a>
<a name="6120"><span class="lineNum">    6120 </span>            :        // DQ (2/23/2009): commented added.</a>
<a name="6121"><span class="lineNum">    6121 </span>            :        // Since there is at least one other string (there is an existing attribute) the relative order of the strings is significant.</a>
<a name="6122"><span class="lineNum">    6122 </span><span class="lineNoCov">          0 :           code-&gt;addString(s,inputlocation);</span></a>
<a name="6123"><span class="lineNum">    6123 </span>            :         }</a>
<a name="6124"><span class="lineNum">    6124 </span>            :        else</a>
<a name="6125"><span class="lineNum">    6125 </span>            :         {</a>
<a name="6126"><span class="lineNum">    6126 </span>            :        // DQ (2/25/2016): I think it is significant, because inputlocation refers to the order relative to</a>
<a name="6127"><span class="lineNum">    6127 </span>            :        // the statement, not relative to other AstUnparseAttribute objects. Fixed to use the inputlocation.</a>
<a name="6128"><span class="lineNum">    6128 </span>            :        // DQ (2/23/2009): commented added.</a>
<a name="6129"><span class="lineNum">    6129 </span>            :        // Note that this will be the only string in the attribute, so inputlocation is not significant (and e_before is the default used).</a>
<a name="6130"><span class="lineNum">    6130 </span>            :        // AstUnparseAttribute* code = new AstUnparseAttribute(s,AstUnparseAttribute::e_before);</a>
<a name="6131"><span class="lineNum">    6131 </span><span class="lineNoCov">          0 :           AstUnparseAttribute* code = new AstUnparseAttribute(s,inputlocation);</span></a>
<a name="6132"><span class="lineNum">    6132 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(code != NULL);</span></a>
<a name="6133"><span class="lineNum">    6133 </span>            : </a>
<a name="6134"><span class="lineNum">    6134 </span><span class="lineNoCov">          0 :           astNode-&gt;addNewAttribute(AstUnparseAttribute::markerName,code);</span></a>
<a name="6135"><span class="lineNum">    6135 </span>            :         }</a>
<a name="6136"><span class="lineNum">    6136 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6137"><span class="lineNum">    6137 </span>            : </a>
<a name="6138"><span class="lineNum">    6138 </span>            : </a>
<a name="6139"><span class="lineNum">    6139 </span>            : #if 0</a>
<a name="6140"><span class="lineNum">    6140 </span>            : // DQ (7/20/2011): Resolving conflict, this was added in previous work in dq-cxx-rc branch.</a>
<a name="6141"><span class="lineNum">    6141 </span>            : // DQ (7/17/2011): Added function from cxx branch that I need here for the Java support.</a>
<a name="6142"><span class="lineNum">    6142 </span>            : SgClassSymbol *</a>
<a name="6143"><span class="lineNum">    6143 </span>            : SageInterface::lookupClassSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</a>
<a name="6144"><span class="lineNum">    6144 </span>            :    {</a>
<a name="6145"><span class="lineNum">    6145 </span>            :   // DQ (5/7/2011): I think this is the better implementation that lookupVariableSymbolInParentScopes() should have.</a>
<a name="6146"><span class="lineNum">    6146 </span>            :      SgClassSymbol* symbol = NULL;</a>
<a name="6147"><span class="lineNum">    6147 </span>            :      if (cscope == NULL)</a>
<a name="6148"><span class="lineNum">    6148 </span>            :           cscope = SageBuilder::topScopeStack();</a>
<a name="6149"><span class="lineNum">    6149 </span>            :      ROSE_ASSERT(cscope != NULL);</a>
<a name="6150"><span class="lineNum">    6150 </span>            : </a>
<a name="6151"><span class="lineNum">    6151 </span>            :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</a>
<a name="6152"><span class="lineNum">    6152 </span>            :         {</a>
<a name="6153"><span class="lineNum">    6153 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6154"><span class="lineNum">    6154 </span>            :           symbol = cscope-&gt;lookup_class_symbol(name,NULL);</a>
<a name="6155"><span class="lineNum">    6155 </span>            : </a>
<a name="6156"><span class="lineNum">    6156 </span>            :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</a>
<a name="6157"><span class="lineNum">    6157 </span>            :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</a>
<a name="6158"><span class="lineNum">    6158 </span>            :             else</a>
<a name="6159"><span class="lineNum">    6159 </span>            :                cscope = NULL;</a>
<a name="6160"><span class="lineNum">    6160 </span>            :         }</a>
<a name="6161"><span class="lineNum">    6161 </span>            : </a>
<a name="6162"><span class="lineNum">    6162 </span>            :      return symbol;</a>
<a name="6163"><span class="lineNum">    6163 </span>            :    }</a>
<a name="6164"><span class="lineNum">    6164 </span>            : #endif</a>
<a name="6165"><span class="lineNum">    6165 </span>            : </a>
<a name="6166"><span class="lineNum">    6166 </span>            : </a>
<a name="6167"><span class="lineNum">    6167 </span>            : </a>
<a name="6168"><span class="lineNum">    6168 </span><span class="lineCov">          1 : SgType* SageInterface::lookupNamedTypeInParentScopes(const std::string&amp; type_name, SgScopeStatement* scope/*=NULL*/)</span></a>
<a name="6169"><span class="lineNum">    6169 </span>            :    {</a>
<a name="6170"><span class="lineNum">    6170 </span><span class="lineCov">          1 :      if (scope == NULL)</span></a>
<a name="6171"><span class="lineNum">    6171 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="6172"><span class="lineNum">    6172 </span>            : </a>
<a name="6173"><span class="lineNum">    6173 </span>            :   // DQ (8/16/2013): Added NULL pointers to at least handle the API change.</a>
<a name="6174"><span class="lineNum">    6174 </span><span class="lineCov">          1 :      SgSymbol* symbol = lookupSymbolInParentScopes (type_name,scope,NULL,NULL);</span></a>
<a name="6175"><span class="lineNum">    6175 </span>            : </a>
<a name="6176"><span class="lineNum">    6176 </span><span class="lineCov">          1 :      if (symbol == NULL)</span></a>
<a name="6177"><span class="lineNum">    6177 </span>            :           return NULL;</a>
<a name="6178"><span class="lineNum">    6178 </span>            :        else</a>
<a name="6179"><span class="lineNum">    6179 </span><span class="lineCov">          1 :           return symbol-&gt;get_type();</span></a>
<a name="6180"><span class="lineNum">    6180 </span>            :    }</a>
<a name="6181"><span class="lineNum">    6181 </span>            : </a>
<a name="6182"><span class="lineNum">    6182 </span><span class="lineCov">      13235 : SgFunctionSymbol *SageInterface::lookupFunctionSymbolInParentScopes (const SgName &amp;functionName,</span></a>
<a name="6183"><span class="lineNum">    6183 </span>            :                                                         const SgType* t,</a>
<a name="6184"><span class="lineNum">    6184 </span>            :                                                         SgScopeStatement *currentScope)</a>
<a name="6185"><span class="lineNum">    6185 </span>            :                                                         //SgScopeStatement *currentScope=NULL)</a>
<a name="6186"><span class="lineNum">    6186 </span>            : {</a>
<a name="6187"><span class="lineNum">    6187 </span><span class="lineCov">      13235 :     SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="6188"><span class="lineNum">    6188 </span><span class="lineCov">      13235 :     if (currentScope == NULL)</span></a>
<a name="6189"><span class="lineNum">    6189 </span><span class="lineNoCov">          0 :         currentScope = SageBuilder::topScopeStack();</span></a>
<a name="6190"><span class="lineNum">    6190 </span><span class="lineCov">      13235 :     ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="6191"><span class="lineNum">    6191 </span><span class="lineCov">      13235 :     SgScopeStatement* tempScope = currentScope;</span></a>
<a name="6192"><span class="lineNum">    6192 </span><span class="lineCov">      40246 :     while (functionSymbol == NULL &amp;&amp; tempScope != NULL)</span></a>
<a name="6193"><span class="lineNum">    6193 </span>            :     {</a>
<a name="6194"><span class="lineNum">    6194 </span><span class="lineCov">      27011 :         functionSymbol = tempScope-&gt;lookup_function_symbol(functionName,t);</span></a>
<a name="6195"><span class="lineNum">    6195 </span><span class="lineCov">      27011 :         if (tempScope-&gt;get_parent()!=NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6196"><span class="lineNum">    6196 </span><span class="lineCov">      27011 :             tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="6197"><span class="lineNum">    6197 </span>            :         else tempScope = NULL;</a>
<a name="6198"><span class="lineNum">    6198 </span>            :     }</a>
<a name="6199"><span class="lineNum">    6199 </span><span class="lineCov">      13235 :     return functionSymbol;</span></a>
<a name="6200"><span class="lineNum">    6200 </span>            : }</a>
<a name="6201"><span class="lineNum">    6201 </span>            : </a>
<a name="6202"><span class="lineNum">    6202 </span>            : // Liao, 1/22/2008</a>
<a name="6203"><span class="lineNum">    6203 </span>            : // SgScopeStatement* SgStatement::get_scope</a>
<a name="6204"><span class="lineNum">    6204 </span>            : // SgScopeStatement* SgStatement::get_scope() assumes all parent pointers are set, which is</a>
<a name="6205"><span class="lineNum">    6205 </span>            : // not always true during translation.</a>
<a name="6206"><span class="lineNum">    6206 </span>            : // SgSymbol *SageInterface:: lookupSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</a>
<a name="6207"><span class="lineNum">    6207 </span>            : SgSymbol*</a>
<a name="6208"><span class="lineNum">    6208 </span><span class="lineCov">    1721100 : SageInterface::lookupSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)</span></a>
<a name="6209"><span class="lineNum">    6209 </span>            :    {</a>
<a name="6210"><span class="lineNum">    6210 </span><span class="lineCov">    1721100 :      SgSymbol* symbol = NULL;</span></a>
<a name="6211"><span class="lineNum">    6211 </span><span class="lineCov">    1721100 :      if (cscope == NULL)</span></a>
<a name="6212"><span class="lineNum">    6212 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6213"><span class="lineNum">    6213 </span>            : </a>
<a name="6214"><span class="lineNum">    6214 </span><span class="lineCov">    1721100 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6215"><span class="lineNum">    6215 </span>            : </a>
<a name="6216"><span class="lineNum">    6216 </span>            : #define DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES 0</a>
<a name="6217"><span class="lineNum">    6217 </span>            : </a>
<a name="6218"><span class="lineNum">    6218 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES</a>
<a name="6219"><span class="lineNum">    6219 </span>            :      printf (&quot;In SageInterface:: lookupSymbolInParentScopes(): cscope = %p = %s (templateParameterList = %p templateArgumentList = %p) \n&quot;,cscope,cscope-&gt;class_name().c_str(),templateParameterList,templateArgumentList);</a>
<a name="6220"><span class="lineNum">    6220 </span>            : #endif</a>
<a name="6221"><span class="lineNum">    6221 </span>            : </a>
<a name="6222"><span class="lineNum">    6222 </span><span class="lineCov">    3964960 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6223"><span class="lineNum">    6223 </span>            :         {</a>
<a name="6224"><span class="lineNum">    6224 </span>            : #if 0</a>
<a name="6225"><span class="lineNum">    6225 </span>            :        // DQ (5/21/2013): Restricting direct access to the symbol table to support namespace symbol table support.</a>
<a name="6226"><span class="lineNum">    6226 </span>            :           if (cscope-&gt;get_symbol_table() == NULL)</a>
<a name="6227"><span class="lineNum">    6227 </span>            :              {</a>
<a name="6228"><span class="lineNum">    6228 </span>            :                printf (&quot;Error: cscope-&gt;get_symbol_table() == NULL for cscope = %p = %s \n&quot;,cscope,cscope-&gt;class_name().c_str());</a>
<a name="6229"><span class="lineNum">    6229 </span>            :                cscope-&gt;get_startOfConstruct()-&gt;display(&quot;cscope-&gt;p_symbol_table == NULL: debug&quot;);</a>
<a name="6230"><span class="lineNum">    6230 </span>            : #if 0</a>
<a name="6231"><span class="lineNum">    6231 </span>            :                ROSE_ASSERT(cscope-&gt;get_parent() != NULL);</a>
<a name="6232"><span class="lineNum">    6232 </span>            :                SgNode* parent = cscope-&gt;get_parent();</a>
<a name="6233"><span class="lineNum">    6233 </span>            :                while (parent != NULL)</a>
<a name="6234"><span class="lineNum">    6234 </span>            :                   {</a>
<a name="6235"><span class="lineNum">    6235 </span>            :                     printf (&quot;Error: cscope-&gt;get_symbol_table() == NULL for parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="6236"><span class="lineNum">    6236 </span>            :                     parent-&gt;get_startOfConstruct()-&gt;display(&quot;parent == NULL: debug&quot;);</a>
<a name="6237"><span class="lineNum">    6237 </span>            :                     parent = parent-&gt;get_parent();</a>
<a name="6238"><span class="lineNum">    6238 </span>            :                   }</a>
<a name="6239"><span class="lineNum">    6239 </span>            : #endif</a>
<a name="6240"><span class="lineNum">    6240 </span>            :              }</a>
<a name="6241"><span class="lineNum">    6241 </span>            :           ROSE_ASSERT(cscope-&gt;get_symbol_table() != NULL);</a>
<a name="6242"><span class="lineNum">    6242 </span>            : #endif</a>
<a name="6243"><span class="lineNum">    6243 </span>            : </a>
<a name="6244"><span class="lineNum">    6244 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES</a>
<a name="6245"><span class="lineNum">    6245 </span>            :           printf(&quot;   --- In SageInterface:: lookupSymbolInParentScopes(): name = %s cscope = %p = %s \n&quot;,name.str(),cscope,cscope-&gt;class_name().c_str());</a>
<a name="6246"><span class="lineNum">    6246 </span>            : #endif</a>
<a name="6247"><span class="lineNum">    6247 </span>            : </a>
<a name="6248"><span class="lineNum">    6248 </span>            :        // DQ (8/16/2013): Changed API to support template parameters and template arguments.</a>
<a name="6249"><span class="lineNum">    6249 </span>            :        // symbol = cscope-&gt;lookup_symbol(name);</a>
<a name="6250"><span class="lineNum">    6250 </span><span class="lineCov">    2243860 :           symbol = cscope-&gt;lookup_symbol(name,templateParameterList,templateArgumentList);</span></a>
<a name="6251"><span class="lineNum">    6251 </span>            : </a>
<a name="6252"><span class="lineNum">    6252 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES &amp;&amp; 1</a>
<a name="6253"><span class="lineNum">    6253 </span>            :        // debug</a>
<a name="6254"><span class="lineNum">    6254 </span>            :           printf(&quot;   --- In SageInterface:: lookupSymbolInParentScopes(): symbol = %p \n&quot;,symbol);</a>
<a name="6255"><span class="lineNum">    6255 </span>            :           cscope-&gt;print_symboltable(&quot;In SageInterface:: lookupSymbolInParentScopes(): debug&quot;);</a>
<a name="6256"><span class="lineNum">    6256 </span>            : #endif</a>
<a name="6257"><span class="lineNum">    6257 </span><span class="lineCov">    2243860 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6258"><span class="lineNum">    6258 </span><span class="lineCov">    2243860 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6259"><span class="lineNum">    6259 </span>            :             else</a>
<a name="6260"><span class="lineNum">    6260 </span>            :                cscope = NULL;</a>
<a name="6261"><span class="lineNum">    6261 </span>            : </a>
<a name="6262"><span class="lineNum">    6262 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES</a>
<a name="6263"><span class="lineNum">    6263 </span>            :           printf (&quot;   --- In SageInterface:: (base of loop) lookupSymbolInParentScopes(): cscope = %p symbol = %p \n\n&quot;,cscope,symbol);</a>
<a name="6264"><span class="lineNum">    6264 </span>            : #endif</a>
<a name="6265"><span class="lineNum">    6265 </span>            :         }</a>
<a name="6266"><span class="lineNum">    6266 </span>            : </a>
<a name="6267"><span class="lineNum">    6267 </span><span class="lineCov">    1721100 :      if (symbol == NULL)</span></a>
<a name="6268"><span class="lineNum">    6268 </span>            :         {</a>
<a name="6269"><span class="lineNum">    6269 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES</a>
<a name="6270"><span class="lineNum">    6270 </span>            :           printf (&quot;Warning: In SageInterface:: lookupSymbolInParentScopes(): could not locate the specified name %s in any outer symbol table (templateParameterList = %p templateArgumentList = %p) \n&quot;,name.str(),templateParameterList,templateArgumentList);</a>
<a name="6271"><span class="lineNum">    6271 </span>            : #endif</a>
<a name="6272"><span class="lineNum">    6272 </span>            :        // ROSE_ASSERT(false);</a>
<a name="6273"><span class="lineNum">    6273 </span>            :         }</a>
<a name="6274"><span class="lineNum">    6274 </span>            : </a>
<a name="6275"><span class="lineNum">    6275 </span><span class="lineCov">    1721100 :      return symbol;</span></a>
<a name="6276"><span class="lineNum">    6276 </span>            :    }</a>
<a name="6277"><span class="lineNum">    6277 </span>            : </a>
<a name="6278"><span class="lineNum">    6278 </span>            : </a>
<a name="6279"><span class="lineNum">    6279 </span>            : </a>
<a name="6280"><span class="lineNum">    6280 </span>            : SgSymbol*</a>
<a name="6281"><span class="lineNum">    6281 </span><span class="lineCov">       9974 : SageInterface::lookupSymbolInParentScopesIgnoringAliasSymbols (const SgName &amp; name, SgScopeStatement *currentScope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)</span></a>
<a name="6282"><span class="lineNum">    6282 </span>            :    {</a>
<a name="6283"><span class="lineNum">    6283 </span>            : // DQ (8/5/2020): the &quot;using namespace&quot; directive will not hide existing visability of symbols in resolving visability.</a>
<a name="6284"><span class="lineNum">    6284 </span>            : // So we need to test if a symbol is visible exclusing matching alises due to using direectives before we can decide to</a>
<a name="6285"><span class="lineNum">    6285 </span>            : // persue name space qualification. This is best demonstrated by Cxx_tests/test2020_18.C, test2020_19.C, test2020_20.C,</a>
<a name="6286"><span class="lineNum">    6286 </span>            : // and test2020_21.C.</a>
<a name="6287"><span class="lineNum">    6287 </span>            : </a>
<a name="6288"><span class="lineNum">    6288 </span><span class="lineCov">       9974 :      SgSymbol* symbol = NULL;</span></a>
<a name="6289"><span class="lineNum">    6289 </span><span class="lineCov">       9974 :      if (currentScope == NULL)</span></a>
<a name="6290"><span class="lineNum">    6290 </span>            :         {</a>
<a name="6291"><span class="lineNum">    6291 </span><span class="lineNoCov">          0 :           currentScope = SageBuilder::topScopeStack();</span></a>
<a name="6292"><span class="lineNum">    6292 </span>            :         }</a>
<a name="6293"><span class="lineNum">    6293 </span>            : </a>
<a name="6294"><span class="lineNum">    6294 </span><span class="lineCov">       9974 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="6295"><span class="lineNum">    6295 </span>            : </a>
<a name="6296"><span class="lineNum">    6296 </span>            : #define DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS 0</a>
<a name="6297"><span class="lineNum">    6297 </span>            : </a>
<a name="6298"><span class="lineNum">    6298 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS</a>
<a name="6299"><span class="lineNum">    6299 </span>            :      printf (&quot;In SageInterface:: lookupSymbolInParentScopesIgnoringAliasSymbols(): currentScope = %p = %s (templateParameterList = %p templateArgumentList = %p) \n&quot;,</a>
<a name="6300"><span class="lineNum">    6300 </span>            :           currentScope,currentScope-&gt;class_name().c_str(),templateParameterList,templateArgumentList);</a>
<a name="6301"><span class="lineNum">    6301 </span>            : #endif</a>
<a name="6302"><span class="lineNum">    6302 </span>            : </a>
<a name="6303"><span class="lineNum">    6303 </span><span class="lineCov">      19948 :      while ((currentScope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6304"><span class="lineNum">    6304 </span>            :         {</a>
<a name="6305"><span class="lineNum">    6305 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS</a>
<a name="6306"><span class="lineNum">    6306 </span>            :           printf(&quot;   --- In SageInterface:: lookupSymbolInParentScopesIgnoringAliasSymbols(): name = %s currentScope = %p = %s \n&quot;,</a>
<a name="6307"><span class="lineNum">    6307 </span>            :                name.str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6308"><span class="lineNum">    6308 </span>            : #endif</a>
<a name="6309"><span class="lineNum">    6309 </span>            : </a>
<a name="6310"><span class="lineNum">    6310 </span>            :        // DQ (8/16/2013): Changed API to support template parameters and template arguments.</a>
<a name="6311"><span class="lineNum">    6311 </span>            :        // symbol = cscope-&gt;lookup_symbol(name);</a>
<a name="6312"><span class="lineNum">    6312 </span><span class="lineCov">       9974 :           symbol = currentScope-&gt;lookup_symbol(name,templateParameterList,templateArgumentList);</span></a>
<a name="6313"><span class="lineNum">    6313 </span>            : </a>
<a name="6314"><span class="lineNum">    6314 </span><span class="lineCov">       9974 :           if (isSgAliasSymbol(symbol) != NULL)</span></a>
<a name="6315"><span class="lineNum">    6315 </span>            :              {</a>
<a name="6316"><span class="lineNum">    6316 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS</a>
<a name="6317"><span class="lineNum">    6317 </span>            :                printf (&quot;Found a SgAliasSymbol: reset to NULL: symbol = %p = %s \n&quot;,symbol,symbol-&gt;class_name().c_str());</a>
<a name="6318"><span class="lineNum">    6318 </span>            : #endif</a>
<a name="6319"><span class="lineNum">    6319 </span><span class="lineNoCov">          0 :                symbol = NULL;</span></a>
<a name="6320"><span class="lineNum">    6320 </span>            :              }</a>
<a name="6321"><span class="lineNum">    6321 </span>            : </a>
<a name="6322"><span class="lineNum">    6322 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS &amp;&amp; 1</a>
<a name="6323"><span class="lineNum">    6323 </span>            :        // debug</a>
<a name="6324"><span class="lineNum">    6324 </span>            :           printf(&quot;   --- In SageInterface:: lookupSymbolInParentScopesIgnoringAliasSymbols(): symbol = %p \n&quot;,symbol);</a>
<a name="6325"><span class="lineNum">    6325 </span>            :           currentScope-&gt;print_symboltable(&quot;In SageInterface:: lookupSymbolInParentScopesIgnoringAliasSymbols(): debug&quot;);</a>
<a name="6326"><span class="lineNum">    6326 </span>            : #endif</a>
<a name="6327"><span class="lineNum">    6327 </span><span class="lineCov">       9974 :           if (currentScope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6328"><span class="lineNum">    6328 </span><span class="lineCov">       9974 :                currentScope = isSgGlobal(currentScope) ? NULL : currentScope-&gt;get_scope();</span></a>
<a name="6329"><span class="lineNum">    6329 </span>            :             else</a>
<a name="6330"><span class="lineNum">    6330 </span>            :                currentScope = NULL;</a>
<a name="6331"><span class="lineNum">    6331 </span>            : </a>
<a name="6332"><span class="lineNum">    6332 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS</a>
<a name="6333"><span class="lineNum">    6333 </span>            :           printf (&quot;   --- In SageInterface:: (base of loop) lookupSymbolInParentScopesIgnoringAliasSymbols(): cscope = %p symbol = %p \n\n&quot;,currentScope,symbol);</a>
<a name="6334"><span class="lineNum">    6334 </span>            : #endif</a>
<a name="6335"><span class="lineNum">    6335 </span>            :         }</a>
<a name="6336"><span class="lineNum">    6336 </span>            : </a>
<a name="6337"><span class="lineNum">    6337 </span><span class="lineCov">       9974 :      if (symbol == NULL)</span></a>
<a name="6338"><span class="lineNum">    6338 </span>            :         {</a>
<a name="6339"><span class="lineNum">    6339 </span>            : #if DEBUG_SYMBOL_LOOKUP_IN_PARENT_SCOPES_IGNORING_ALIAS_SYMBOLS</a>
<a name="6340"><span class="lineNum">    6340 </span>            :           printf (&quot;Warning: In SageInterface:: lookupSymbolInParentScopesIgnoringAliasSymbols(): could not locate the specified name %s in any outer symbol table (templateParameterList = %p templateArgumentList = %p) \n&quot;,</a>
<a name="6341"><span class="lineNum">    6341 </span>            :                name.str(),templateParameterList,templateArgumentList);</a>
<a name="6342"><span class="lineNum">    6342 </span>            : #endif</a>
<a name="6343"><span class="lineNum">    6343 </span>            :        // ROSE_ASSERT(false);</a>
<a name="6344"><span class="lineNum">    6344 </span>            :         }</a>
<a name="6345"><span class="lineNum">    6345 </span>            : </a>
<a name="6346"><span class="lineNum">    6346 </span>            : #if 0</a>
<a name="6347"><span class="lineNum">    6347 </span>            :      printf (&quot;Support for lookupSymbolInParentScopesIgnoringAliasSymbols() is not yet implemented \n&quot;);</a>
<a name="6348"><span class="lineNum">    6348 </span>            :      ROSE_ABORT();</a>
<a name="6349"><span class="lineNum">    6349 </span>            : #endif</a>
<a name="6350"><span class="lineNum">    6350 </span>            : </a>
<a name="6351"><span class="lineNum">    6351 </span><span class="lineCov">       9974 :      return symbol;</span></a>
<a name="6352"><span class="lineNum">    6352 </span>            :    }</a>
<a name="6353"><span class="lineNum">    6353 </span>            : </a>
<a name="6354"><span class="lineNum">    6354 </span>            : </a>
<a name="6355"><span class="lineNum">    6355 </span>            : </a>
<a name="6356"><span class="lineNum">    6356 </span>            : </a>
<a name="6357"><span class="lineNum">    6357 </span>            : </a>
<a name="6358"><span class="lineNum">    6358 </span>            : </a>
<a name="6359"><span class="lineNum">    6359 </span>            : </a>
<a name="6360"><span class="lineNum">    6360 </span>            : </a>
<a name="6361"><span class="lineNum">    6361 </span>            : #if 0</a>
<a name="6362"><span class="lineNum">    6362 </span>            : // DQ (7/13/2011): This was part of a merge conflict with the above modified function.</a>
<a name="6363"><span class="lineNum">    6363 </span>            : // It appeas they are the same so this one is commented out.</a>
<a name="6364"><span class="lineNum">    6364 </span>            : SgSymbol *SageInterface:: lookupSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</a>
<a name="6365"><span class="lineNum">    6365 </span>            : {</a>
<a name="6366"><span class="lineNum">    6366 </span>            :     SgSymbol* symbol = NULL;</a>
<a name="6367"><span class="lineNum">    6367 </span>            :     if (cscope == NULL)</a>
<a name="6368"><span class="lineNum">    6368 </span>            :         cscope = SageBuilder::topScopeStack();</a>
<a name="6369"><span class="lineNum">    6369 </span>            :     ROSE_ASSERT(cscope);</a>
<a name="6370"><span class="lineNum">    6370 </span>            : </a>
<a name="6371"><span class="lineNum">    6371 </span>            :     while ((cscope!=NULL)&amp;&amp;(symbol==NULL))</a>
<a name="6372"><span class="lineNum">    6372 </span>            :     {</a>
<a name="6373"><span class="lineNum">    6373 </span>            :         symbol = cscope-&gt;lookup_symbol(name);</a>
<a name="6374"><span class="lineNum">    6374 </span>            :         //debug</a>
<a name="6375"><span class="lineNum">    6375 </span>            :         // cscope-&gt;print_symboltable(&quot;debug sageInterface.C L3749...&quot;);</a>
<a name="6376"><span class="lineNum">    6376 </span>            :         if (cscope-&gt;get_parent()!=NULL) // avoid calling get_scope when parent is not set</a>
<a name="6377"><span class="lineNum">    6377 </span>            :             cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</a>
<a name="6378"><span class="lineNum">    6378 </span>            :         else</a>
<a name="6379"><span class="lineNum">    6379 </span>            :             cscope = NULL;</a>
<a name="6380"><span class="lineNum">    6380 </span>            :     }</a>
<a name="6381"><span class="lineNum">    6381 </span>            : </a>
<a name="6382"><span class="lineNum">    6382 </span>            :     if (symbol==NULL)</a>
<a name="6383"><span class="lineNum">    6383 </span>            :     {</a>
<a name="6384"><span class="lineNum">    6384 </span>            :         //    printf (&quot;Warning: could not locate the specified name %s in any outer symbol table \n&quot;e,</a>
<a name="6385"><span class="lineNum">    6385 </span>            :         //  name.str());</a>
<a name="6386"><span class="lineNum">    6386 </span>            :         //  ROSE_ASSERT(false);</a>
<a name="6387"><span class="lineNum">    6387 </span>            :     }</a>
<a name="6388"><span class="lineNum">    6388 </span>            :     return symbol;</a>
<a name="6389"><span class="lineNum">    6389 </span>            : }</a>
<a name="6390"><span class="lineNum">    6390 </span>            : #endif</a>
<a name="6391"><span class="lineNum">    6391 </span>            : </a>
<a name="6392"><span class="lineNum">    6392 </span>            : SgVariableSymbol *</a>
<a name="6393"><span class="lineNum">    6393 </span><span class="lineCov">       1197 : SageInterface::lookupVariableSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</span></a>
<a name="6394"><span class="lineNum">    6394 </span>            :    {</a>
<a name="6395"><span class="lineNum">    6395 </span>            :   // DQ (1/24/2011): This function is inconsistant with an implementation that would correctly handle SgAliasSymbols.</a>
<a name="6396"><span class="lineNum">    6396 </span>            :   // Also this function might get a SgClassSymbol instead of a SgVariableSymbol when both names are used.</a>
<a name="6397"><span class="lineNum">    6397 </span>            :   // This function needs to be fixed to handle the multi-map semantics of the symbol tables.</a>
<a name="6398"><span class="lineNum">    6398 </span>            : </a>
<a name="6399"><span class="lineNum">    6399 </span>            : #if 0</a>
<a name="6400"><span class="lineNum">    6400 </span>            :   // DQ (5/7/2011): I think this implementation is not correct (does not resolve past hidden types) and so should</a>
<a name="6401"><span class="lineNum">    6401 </span>            :   // be fixed to be consistant with the implementation of SageInterface::lookupClassSymbolInParentScopes().</a>
<a name="6402"><span class="lineNum">    6402 </span>            :   // Since I don't know where this function is used, I don't want to change it just yet.</a>
<a name="6403"><span class="lineNum">    6403 </span>            :      printf (&quot;WARNING: SageInterface::lookupVariableSymbolInParentScopes() should be implemented similar to SageInterface::lookupClassSymbolInParentScopes() \n&quot;);</a>
<a name="6404"><span class="lineNum">    6404 </span>            : </a>
<a name="6405"><span class="lineNum">    6405 </span>            :      SgVariableSymbol* result = NULL;</a>
<a name="6406"><span class="lineNum">    6406 </span>            :      SgSymbol* symbol=lookupSymbolInParentScopes(name,cscope);</a>
<a name="6407"><span class="lineNum">    6407 </span>            :      if (symbol != NULL)</a>
<a name="6408"><span class="lineNum">    6408 </span>            :         {</a>
<a name="6409"><span class="lineNum">    6409 </span>            :           if (isSgAliasSymbol(symbol) != NULL)</a>
<a name="6410"><span class="lineNum">    6410 </span>            :              {</a>
<a name="6411"><span class="lineNum">    6411 </span>            :                printf (&quot;Error: This SageInterface::lookupVariableSymbolInParentScopes() function does not handle SgAliasSymbols \n&quot;);</a>
<a name="6412"><span class="lineNum">    6412 </span>            :                ROSE_ABORT();</a>
<a name="6413"><span class="lineNum">    6413 </span>            :              }</a>
<a name="6414"><span class="lineNum">    6414 </span>            :           result = isSgVariableSymbol(symbol);</a>
<a name="6415"><span class="lineNum">    6415 </span>            :         }</a>
<a name="6416"><span class="lineNum">    6416 </span>            :      return result;</a>
<a name="6417"><span class="lineNum">    6417 </span>            : #else</a>
<a name="6418"><span class="lineNum">    6418 </span>            :   // I think this is the better implementation.</a>
<a name="6419"><span class="lineNum">    6419 </span><span class="lineCov">       1197 :      SgVariableSymbol* symbol = NULL;</span></a>
<a name="6420"><span class="lineNum">    6420 </span><span class="lineCov">       1197 :      if (cscope == NULL)</span></a>
<a name="6421"><span class="lineNum">    6421 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6422"><span class="lineNum">    6422 </span><span class="lineCov">       1197 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6423"><span class="lineNum">    6423 </span>            : </a>
<a name="6424"><span class="lineNum">    6424 </span><span class="lineCov">       4495 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6425"><span class="lineNum">    6425 </span>            :         {</a>
<a name="6426"><span class="lineNum">    6426 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6427"><span class="lineNum">    6427 </span><span class="lineCov">       3298 :           symbol = cscope-&gt;lookup_variable_symbol(name);</span></a>
<a name="6428"><span class="lineNum">    6428 </span>            : </a>
<a name="6429"><span class="lineNum">    6429 </span><span class="lineCov">       3298 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6430"><span class="lineNum">    6430 </span><span class="lineCov">       3295 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6431"><span class="lineNum">    6431 </span>            :             else</a>
<a name="6432"><span class="lineNum">    6432 </span>            :                cscope = NULL;</a>
<a name="6433"><span class="lineNum">    6433 </span>            :         }</a>
<a name="6434"><span class="lineNum">    6434 </span>            : </a>
<a name="6435"><span class="lineNum">    6435 </span><span class="lineCov">       1197 :      return symbol;</span></a>
<a name="6436"><span class="lineNum">    6436 </span>            : #endif</a>
<a name="6437"><span class="lineNum">    6437 </span>            :    }</a>
<a name="6438"><span class="lineNum">    6438 </span>            : </a>
<a name="6439"><span class="lineNum">    6439 </span>            : #define DEBUG_LOOKUP_TEMPLATE_VARIABLE 0</a>
<a name="6440"><span class="lineNum">    6440 </span>            : </a>
<a name="6441"><span class="lineNum">    6441 </span>            : SgTemplateVariableSymbol *</a>
<a name="6442"><span class="lineNum">    6442 </span><span class="lineNoCov">          0 : SageInterface::lookupTemplateVariableSymbolInParentScopes (const SgName &amp;  name, SgTemplateParameterPtrList * tplparams, SgTemplateArgumentPtrList* tplargs, SgScopeStatement *cscope)</span></a>
<a name="6443"><span class="lineNum">    6443 </span>            :    {</a>
<a name="6444"><span class="lineNum">    6444 </span>            : #if DEBUG_LOOKUP_TEMPLATE_VARIABLE</a>
<a name="6445"><span class="lineNum">    6445 </span>            :      printf (&quot;In SageInterface::lookupTemplateVariableSymbolInParentScopes():\n&quot;);</a>
<a name="6446"><span class="lineNum">    6446 </span>            :      printf (&quot;  -- name = %s\n&quot;, name.str());</a>
<a name="6447"><span class="lineNum">    6447 </span>            :      printf (&quot;  -- tplparams = %p [%zd]\n&quot;, tplparams, tplparams ? tplparams-&gt;size() : 0);</a>
<a name="6448"><span class="lineNum">    6448 </span>            :      printf (&quot;  -- tplargs   = %p [%zd]\n&quot;,   tplargs,   tplargs ?   tplargs-&gt;size() : 0);</a>
<a name="6449"><span class="lineNum">    6449 </span>            :      printf (&quot;  -- cscope    = %p (%s)\n&quot;,     cscope,    cscope ?    cscope-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="6450"><span class="lineNum">    6450 </span>            : #endif</a>
<a name="6451"><span class="lineNum">    6451 </span>            : </a>
<a name="6452"><span class="lineNum">    6452 </span><span class="lineNoCov">          0 :      SgTemplateVariableSymbol* symbol = NULL;</span></a>
<a name="6453"><span class="lineNum">    6453 </span><span class="lineNoCov">          0 :      if (cscope == NULL)</span></a>
<a name="6454"><span class="lineNum">    6454 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6455"><span class="lineNum">    6455 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6456"><span class="lineNum">    6456 </span>            : </a>
<a name="6457"><span class="lineNum">    6457 </span><span class="lineNoCov">          0 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6458"><span class="lineNum">    6458 </span>            :         {</a>
<a name="6459"><span class="lineNum">    6459 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6460"><span class="lineNum">    6460 </span><span class="lineNoCov">          0 :           symbol = cscope-&gt;lookup_template_variable_symbol(name, tplparams, tplargs);</span></a>
<a name="6461"><span class="lineNum">    6461 </span>            : </a>
<a name="6462"><span class="lineNum">    6462 </span><span class="lineNoCov">          0 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6463"><span class="lineNum">    6463 </span><span class="lineNoCov">          0 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6464"><span class="lineNum">    6464 </span>            :             else</a>
<a name="6465"><span class="lineNum">    6465 </span>            :                cscope = NULL;</a>
<a name="6466"><span class="lineNum">    6466 </span>            :         }</a>
<a name="6467"><span class="lineNum">    6467 </span>            : </a>
<a name="6468"><span class="lineNum">    6468 </span><span class="lineNoCov">          0 :      return symbol;</span></a>
<a name="6469"><span class="lineNum">    6469 </span>            :    }</a>
<a name="6470"><span class="lineNum">    6470 </span>            : </a>
<a name="6471"><span class="lineNum">    6471 </span>            : // SgClassSymbol* SageInterface::lookupClassSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</a>
<a name="6472"><span class="lineNum">    6472 </span>            : SgClassSymbol*</a>
<a name="6473"><span class="lineNum">    6473 </span><span class="lineCov">       7612 : SageInterface::lookupClassSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope, SgTemplateArgumentPtrList* templateArgumentList)</span></a>
<a name="6474"><span class="lineNum">    6474 </span>            :    {</a>
<a name="6475"><span class="lineNum">    6475 </span>            :   // DQ (5/7/2011): I think this is the better implementation that lookupVariableSymbolInParentScopes() should have.</a>
<a name="6476"><span class="lineNum">    6476 </span><span class="lineCov">       7612 :      SgClassSymbol* symbol = NULL;</span></a>
<a name="6477"><span class="lineNum">    6477 </span><span class="lineCov">       7612 :      if (cscope == NULL)</span></a>
<a name="6478"><span class="lineNum">    6478 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6479"><span class="lineNum">    6479 </span><span class="lineCov">       7612 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6480"><span class="lineNum">    6480 </span>            : </a>
<a name="6481"><span class="lineNum">    6481 </span><span class="lineCov">      25307 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6482"><span class="lineNum">    6482 </span>            :         {</a>
<a name="6483"><span class="lineNum">    6483 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6484"><span class="lineNum">    6484 </span>            :        // symbol = cscope-&gt;lookup_class_symbol(name,NULL);</a>
<a name="6485"><span class="lineNum">    6485 </span><span class="lineCov">      17695 :           symbol = cscope-&gt;lookup_class_symbol(name,templateArgumentList);</span></a>
<a name="6486"><span class="lineNum">    6486 </span>            : </a>
<a name="6487"><span class="lineNum">    6487 </span><span class="lineCov">      17695 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6488"><span class="lineNum">    6488 </span><span class="lineCov">      17695 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6489"><span class="lineNum">    6489 </span>            :             else</a>
<a name="6490"><span class="lineNum">    6490 </span>            :                cscope = NULL;</a>
<a name="6491"><span class="lineNum">    6491 </span>            :         }</a>
<a name="6492"><span class="lineNum">    6492 </span>            : </a>
<a name="6493"><span class="lineNum">    6493 </span><span class="lineCov">       7612 :      return symbol;</span></a>
<a name="6494"><span class="lineNum">    6494 </span>            :    }</a>
<a name="6495"><span class="lineNum">    6495 </span>            : </a>
<a name="6496"><span class="lineNum">    6496 </span>            : SgNonrealSymbol*</a>
<a name="6497"><span class="lineNum">    6497 </span><span class="lineCov">       3760 : SageInterface::lookupNonrealSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)</span></a>
<a name="6498"><span class="lineNum">    6498 </span>            :    {</a>
<a name="6499"><span class="lineNum">    6499 </span><span class="lineCov">       3760 :      SgNonrealSymbol* symbol = NULL;</span></a>
<a name="6500"><span class="lineNum">    6500 </span><span class="lineCov">       3760 :      if (cscope == NULL)</span></a>
<a name="6501"><span class="lineNum">    6501 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6502"><span class="lineNum">    6502 </span><span class="lineCov">       3760 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6503"><span class="lineNum">    6503 </span>            : </a>
<a name="6504"><span class="lineNum">    6504 </span><span class="lineCov">      23794 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6505"><span class="lineNum">    6505 </span>            :         {</a>
<a name="6506"><span class="lineNum">    6506 </span><span class="lineCov">      20034 :           symbol = cscope-&gt;lookup_nonreal_symbol(name,templateParameterList,templateArgumentList);</span></a>
<a name="6507"><span class="lineNum">    6507 </span>            : </a>
<a name="6508"><span class="lineNum">    6508 </span><span class="lineCov">      20034 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6509"><span class="lineNum">    6509 </span><span class="lineCov">      20034 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6510"><span class="lineNum">    6510 </span>            :             else</a>
<a name="6511"><span class="lineNum">    6511 </span>            :                cscope = NULL;</a>
<a name="6512"><span class="lineNum">    6512 </span>            :         }</a>
<a name="6513"><span class="lineNum">    6513 </span>            : </a>
<a name="6514"><span class="lineNum">    6514 </span><span class="lineCov">       3760 :      return symbol;</span></a>
<a name="6515"><span class="lineNum">    6515 </span>            :    }</a>
<a name="6516"><span class="lineNum">    6516 </span>            : </a>
<a name="6517"><span class="lineNum">    6517 </span>            : SgTypedefSymbol *</a>
<a name="6518"><span class="lineNum">    6518 </span><span class="lineCov">       6697 : SageInterface::lookupTypedefSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</span></a>
<a name="6519"><span class="lineNum">    6519 </span>            :    {</a>
<a name="6520"><span class="lineNum">    6520 </span>            :   // DQ (5/7/2011): This is similar to lookupClassSymbolInParentScopes().</a>
<a name="6521"><span class="lineNum">    6521 </span><span class="lineCov">       6697 :      SgTypedefSymbol* symbol = NULL;</span></a>
<a name="6522"><span class="lineNum">    6522 </span><span class="lineCov">       6697 :      if (cscope == NULL)</span></a>
<a name="6523"><span class="lineNum">    6523 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6524"><span class="lineNum">    6524 </span><span class="lineCov">       6697 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6525"><span class="lineNum">    6525 </span>            : </a>
<a name="6526"><span class="lineNum">    6526 </span>            : #if 0</a>
<a name="6527"><span class="lineNum">    6527 </span>            :      printf (&quot;In lookupTypedefSymbolInParentScopes(): name = %s starting with cscope = %p = %s \n&quot;,name.str(),cscope,cscope-&gt;class_name().c_str());</a>
<a name="6528"><span class="lineNum">    6528 </span>            :      printf (&quot;--- parent scope = %p = %s \n&quot;,cscope-&gt;get_scope(),(cscope-&gt;get_scope() != NULL) ? cscope-&gt;get_scope()-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="6529"><span class="lineNum">    6529 </span>            : #endif</a>
<a name="6530"><span class="lineNum">    6530 </span>            : </a>
<a name="6531"><span class="lineNum">    6531 </span><span class="lineCov">      26792 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6532"><span class="lineNum">    6532 </span>            :         {</a>
<a name="6533"><span class="lineNum">    6533 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6534"><span class="lineNum">    6534 </span><span class="lineCov">      20095 :           symbol = cscope-&gt;lookup_typedef_symbol(name);</span></a>
<a name="6535"><span class="lineNum">    6535 </span>            : </a>
<a name="6536"><span class="lineNum">    6536 </span><span class="lineCov">      20095 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6537"><span class="lineNum">    6537 </span><span class="lineCov">      20095 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6538"><span class="lineNum">    6538 </span>            :             else</a>
<a name="6539"><span class="lineNum">    6539 </span>            :                cscope = NULL;</a>
<a name="6540"><span class="lineNum">    6540 </span>            : </a>
<a name="6541"><span class="lineNum">    6541 </span>            : #if 0</a>
<a name="6542"><span class="lineNum">    6542 </span>            :           printf (&quot;In lookupTypedefSymbolInParentScopes(): symbol = %p next cscope = %p = %s \n&quot;,symbol,cscope,(cscope != NULL) ? cscope-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="6543"><span class="lineNum">    6543 </span>            : #endif</a>
<a name="6544"><span class="lineNum">    6544 </span>            :         }</a>
<a name="6545"><span class="lineNum">    6545 </span>            : </a>
<a name="6546"><span class="lineNum">    6546 </span>            : #if 0</a>
<a name="6547"><span class="lineNum">    6547 </span>            :      printf (&quot;Leaving lookupTypedefSymbolInParentScopes(): symbol = %p \n&quot;,symbol);</a>
<a name="6548"><span class="lineNum">    6548 </span>            : #endif</a>
<a name="6549"><span class="lineNum">    6549 </span>            : </a>
<a name="6550"><span class="lineNum">    6550 </span><span class="lineCov">       6697 :      return symbol;</span></a>
<a name="6551"><span class="lineNum">    6551 </span>            :    }</a>
<a name="6552"><span class="lineNum">    6552 </span>            : </a>
<a name="6553"><span class="lineNum">    6553 </span>            : #if 0</a>
<a name="6554"><span class="lineNum">    6554 </span>            : // DQ (8/13/2013): This function does not make since any more, now that we have make the symbol</a>
<a name="6555"><span class="lineNum">    6555 </span>            : // table handling more precise and we have to provide template parameters for any template lookup.</a>
<a name="6556"><span class="lineNum">    6556 </span>            : // We also have to know if we want to lookup template classes, template functions, or template</a>
<a name="6557"><span class="lineNum">    6557 </span>            : // member functions (since each have specific requirements).</a>
<a name="6558"><span class="lineNum">    6558 </span>            : SgTemplateSymbol*</a>
<a name="6559"><span class="lineNum">    6559 </span>            : SageInterface::lookupTemplateSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</a>
<a name="6560"><span class="lineNum">    6560 </span>            :    {</a>
<a name="6561"><span class="lineNum">    6561 </span>            :   // DQ (5/7/2011): This is similar to lookupClassSymbolInParentScopes().</a>
<a name="6562"><span class="lineNum">    6562 </span>            :      SgTemplateSymbol* symbol = NULL;</a>
<a name="6563"><span class="lineNum">    6563 </span>            :      if (cscope == NULL)</a>
<a name="6564"><span class="lineNum">    6564 </span>            :           cscope = SageBuilder::topScopeStack();</a>
<a name="6565"><span class="lineNum">    6565 </span>            :      ROSE_ASSERT(cscope != NULL);</a>
<a name="6566"><span class="lineNum">    6566 </span>            : </a>
<a name="6567"><span class="lineNum">    6567 </span>            :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</a>
<a name="6568"><span class="lineNum">    6568 </span>            :         {</a>
<a name="6569"><span class="lineNum">    6569 </span>            :        // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="6570"><span class="lineNum">    6570 </span>            :        // In this case these are unavailable from this point.</a>
<a name="6571"><span class="lineNum">    6571 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6572"><span class="lineNum">    6572 </span>            :        // symbol = cscope-&gt;lookup_template_symbol(name);</a>
<a name="6573"><span class="lineNum">    6573 </span>            :           symbol = cscope-&gt;lookup_template_symbol(name,NULL,NULL);</a>
<a name="6574"><span class="lineNum">    6574 </span>            : #if 0</a>
<a name="6575"><span class="lineNum">    6575 </span>            :           printf (&quot;In lookupTemplateSymbolInParentScopes(): Searching scope = %p = %s name = %s symbol = %p \n&quot;,cscope,cscope-&gt;class_name().c_str(),name.str(),symbol);</a>
<a name="6576"><span class="lineNum">    6576 </span>            : #endif</a>
<a name="6577"><span class="lineNum">    6577 </span>            :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</a>
<a name="6578"><span class="lineNum">    6578 </span>            :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</a>
<a name="6579"><span class="lineNum">    6579 </span>            :             else</a>
<a name="6580"><span class="lineNum">    6580 </span>            :                cscope = NULL;</a>
<a name="6581"><span class="lineNum">    6581 </span>            :         }</a>
<a name="6582"><span class="lineNum">    6582 </span>            : </a>
<a name="6583"><span class="lineNum">    6583 </span>            :      return symbol;</a>
<a name="6584"><span class="lineNum">    6584 </span>            :    }</a>
<a name="6585"><span class="lineNum">    6585 </span>            : #endif</a>
<a name="6586"><span class="lineNum">    6586 </span>            : </a>
<a name="6587"><span class="lineNum">    6587 </span>            : </a>
<a name="6588"><span class="lineNum">    6588 </span>            : SgTemplateClassSymbol*</a>
<a name="6589"><span class="lineNum">    6589 </span><span class="lineNoCov">          0 : SageInterface::lookupTemplateClassSymbolInParentScopes (const SgName &amp;  name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, SgScopeStatement *cscope)</span></a>
<a name="6590"><span class="lineNum">    6590 </span>            :    {</a>
<a name="6591"><span class="lineNum">    6591 </span>            :   // DQ (5/7/2011): This is similar to lookupClassSymbolInParentScopes().</a>
<a name="6592"><span class="lineNum">    6592 </span><span class="lineNoCov">          0 :      SgTemplateClassSymbol* symbol = NULL;</span></a>
<a name="6593"><span class="lineNum">    6593 </span><span class="lineNoCov">          0 :      if (cscope == NULL)</span></a>
<a name="6594"><span class="lineNum">    6594 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6595"><span class="lineNum">    6595 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6596"><span class="lineNum">    6596 </span>            : </a>
<a name="6597"><span class="lineNum">    6597 </span><span class="lineNoCov">          0 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6598"><span class="lineNum">    6598 </span>            :         {</a>
<a name="6599"><span class="lineNum">    6599 </span>            :        // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="6600"><span class="lineNum">    6600 </span>            :        // In this case these are unavailable from this point.</a>
<a name="6601"><span class="lineNum">    6601 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6602"><span class="lineNum">    6602 </span>            :        // symbol = cscope-&gt;lookup_template_symbol(name);</a>
<a name="6603"><span class="lineNum">    6603 </span><span class="lineNoCov">          0 :           symbol = cscope-&gt;lookup_template_class_symbol(name,templateParameterList,templateArgumentList);</span></a>
<a name="6604"><span class="lineNum">    6604 </span>            : #if 0</a>
<a name="6605"><span class="lineNum">    6605 </span>            :           printf (&quot;In lookupTemplateSymbolInParentScopes(): Searching scope = %p = %s name = %s symbol = %p \n&quot;,cscope,cscope-&gt;class_name().c_str(),name.str(),symbol);</a>
<a name="6606"><span class="lineNum">    6606 </span>            : #endif</a>
<a name="6607"><span class="lineNum">    6607 </span><span class="lineNoCov">          0 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6608"><span class="lineNum">    6608 </span><span class="lineNoCov">          0 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6609"><span class="lineNum">    6609 </span>            :             else</a>
<a name="6610"><span class="lineNum">    6610 </span>            :                cscope = NULL;</a>
<a name="6611"><span class="lineNum">    6611 </span>            :         }</a>
<a name="6612"><span class="lineNum">    6612 </span>            : </a>
<a name="6613"><span class="lineNum">    6613 </span><span class="lineNoCov">          0 :      return symbol;</span></a>
<a name="6614"><span class="lineNum">    6614 </span>            :    }</a>
<a name="6615"><span class="lineNum">    6615 </span>            : </a>
<a name="6616"><span class="lineNum">    6616 </span>            : </a>
<a name="6617"><span class="lineNum">    6617 </span>            : SgEnumSymbol *</a>
<a name="6618"><span class="lineNum">    6618 </span><span class="lineNoCov">          0 : SageInterface::lookupEnumSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</span></a>
<a name="6619"><span class="lineNum">    6619 </span>            :    {</a>
<a name="6620"><span class="lineNum">    6620 </span>            :   // DQ (5/7/2011): This is similar to lookupClassSymbolInParentScopes().</a>
<a name="6621"><span class="lineNum">    6621 </span>            :   // A templated solution might make for a better implementation.</a>
<a name="6622"><span class="lineNum">    6622 </span><span class="lineNoCov">          0 :      SgEnumSymbol* symbol = NULL;</span></a>
<a name="6623"><span class="lineNum">    6623 </span><span class="lineNoCov">          0 :      if (cscope == NULL)</span></a>
<a name="6624"><span class="lineNum">    6624 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6625"><span class="lineNum">    6625 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6626"><span class="lineNum">    6626 </span>            : </a>
<a name="6627"><span class="lineNum">    6627 </span><span class="lineNoCov">          0 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6628"><span class="lineNum">    6628 </span>            :         {</a>
<a name="6629"><span class="lineNum">    6629 </span>            :        // I think this will resolve SgAliasSymbols to be a SgClassSymbol where the alias is of a SgClassSymbol.</a>
<a name="6630"><span class="lineNum">    6630 </span><span class="lineNoCov">          0 :           symbol = cscope-&gt;lookup_enum_symbol(name);</span></a>
<a name="6631"><span class="lineNum">    6631 </span>            : </a>
<a name="6632"><span class="lineNum">    6632 </span><span class="lineNoCov">          0 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6633"><span class="lineNum">    6633 </span><span class="lineNoCov">          0 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6634"><span class="lineNum">    6634 </span>            :             else</a>
<a name="6635"><span class="lineNum">    6635 </span>            :                cscope = NULL;</a>
<a name="6636"><span class="lineNum">    6636 </span>            :         }</a>
<a name="6637"><span class="lineNum">    6637 </span>            : </a>
<a name="6638"><span class="lineNum">    6638 </span><span class="lineNoCov">          0 :      return symbol;</span></a>
<a name="6639"><span class="lineNum">    6639 </span>            :    }</a>
<a name="6640"><span class="lineNum">    6640 </span>            : </a>
<a name="6641"><span class="lineNum">    6641 </span>            : SgNamespaceSymbol *</a>
<a name="6642"><span class="lineNum">    6642 </span><span class="lineNoCov">          0 : SageInterface::lookupNamespaceSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope)</span></a>
<a name="6643"><span class="lineNum">    6643 </span>            :    {</a>
<a name="6644"><span class="lineNum">    6644 </span>            :   // DQ (5/7/2011): This is similar to lookupClassSymbolInParentScopes().</a>
<a name="6645"><span class="lineNum">    6645 </span><span class="lineNoCov">          0 :      SgNamespaceSymbol* symbol = NULL;</span></a>
<a name="6646"><span class="lineNum">    6646 </span><span class="lineNoCov">          0 :      if (cscope == NULL)</span></a>
<a name="6647"><span class="lineNum">    6647 </span><span class="lineNoCov">          0 :           cscope = SageBuilder::topScopeStack();</span></a>
<a name="6648"><span class="lineNum">    6648 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(cscope != NULL);</span></a>
<a name="6649"><span class="lineNum">    6649 </span>            : </a>
<a name="6650"><span class="lineNum">    6650 </span><span class="lineNoCov">          0 :      while ((cscope != NULL) &amp;&amp; (symbol == NULL))</span></a>
<a name="6651"><span class="lineNum">    6651 </span>            :         {</a>
<a name="6652"><span class="lineNum">    6652 </span>            :        // I think this will resolve SgAliasSymbols to be a SgNamespaceSymbol where the alias is of a SgNamespaceSymbol.</a>
<a name="6653"><span class="lineNum">    6653 </span><span class="lineNoCov">          0 :           symbol = cscope-&gt;lookup_namespace_symbol(name);</span></a>
<a name="6654"><span class="lineNum">    6654 </span>            : </a>
<a name="6655"><span class="lineNum">    6655 </span><span class="lineNoCov">          0 :           if (cscope-&gt;get_parent() != NULL) // avoid calling get_scope when parent is not set</span></a>
<a name="6656"><span class="lineNum">    6656 </span><span class="lineNoCov">          0 :                cscope = isSgGlobal(cscope) ? NULL : cscope-&gt;get_scope();</span></a>
<a name="6657"><span class="lineNum">    6657 </span>            :             else</a>
<a name="6658"><span class="lineNum">    6658 </span>            :                cscope = NULL;</a>
<a name="6659"><span class="lineNum">    6659 </span>            :         }</a>
<a name="6660"><span class="lineNum">    6660 </span>            : </a>
<a name="6661"><span class="lineNum">    6661 </span><span class="lineNoCov">          0 :      return symbol;</span></a>
<a name="6662"><span class="lineNum">    6662 </span>            :    }</a>
<a name="6663"><span class="lineNum">    6663 </span>            : </a>
<a name="6664"><span class="lineNum">    6664 </span>            : template&lt;class T&gt;</a>
<a name="6665"><span class="lineNum">    6665 </span>            : void</a>
<a name="6666"><span class="lineNum">    6666 </span><span class="lineCov">   16235228 : SageInterface::setSourcePositionToDefault( T* node )</span></a>
<a name="6667"><span class="lineNum">    6667 </span>            :    {</a>
<a name="6668"><span class="lineNum">    6668 </span>            :   // This is a templated function because SgPragma is not yet derived from SgLocatedNode.</a>
<a name="6669"><span class="lineNum">    6669 </span>            : </a>
<a name="6670"><span class="lineNum">    6670 </span>            :   // DQ (2/17/2013): This function is called a lot, so it might be a performance issue.</a>
<a name="6671"><span class="lineNum">    6671 </span>            :   // All IR nodes built by the Build Interface are assighed source position information</a>
<a name="6672"><span class="lineNum">    6672 </span>            :   // using this function and then reset afterward as we use information within EDG to</a>
<a name="6673"><span class="lineNum">    6673 </span>            :   // reset the source position information.  Ideally, the EDG/ROSE connection would</a>
<a name="6674"><span class="lineNum">    6674 </span>            :   // use NULL pointers as the behavior for the front-end mode.  We can move to that</a>
<a name="6675"><span class="lineNum">    6675 </span>            :   // later to maek the source position handling more efficient.</a>
<a name="6676"><span class="lineNum">    6676 </span>            : </a>
<a name="6677"><span class="lineNum">    6677 </span>            :   // DQ (1/24/2009): It might be that this function is only called from the Fortran support.</a>
<a name="6678"><span class="lineNum">    6678 </span>            : </a>
<a name="6679"><span class="lineNum">    6679 </span>            :   // This function sets the source position to be marked as not</a>
<a name="6680"><span class="lineNum">    6680 </span>            :   // available (since we often don't have token information)</a>
<a name="6681"><span class="lineNum">    6681 </span>            :   // These nodes WILL be unparsed in the conde generation phase.</a>
<a name="6682"><span class="lineNum">    6682 </span>            : </a>
<a name="6683"><span class="lineNum">    6683 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="6684"><span class="lineNum">    6684 </span><span class="lineCov">   16235228 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6685"><span class="lineNum">    6685 </span>            : </a>
<a name="6686"><span class="lineNum">    6686 </span>            :   // We have to support this being called where the Sg_File_Info have previously been set.</a>
<a name="6687"><span class="lineNum">    6687 </span><span class="lineCov">   16235228 :      if (node-&gt;get_endOfConstruct() == NULL &amp;&amp; node-&gt;get_startOfConstruct() == NULL)</span></a>
<a name="6688"><span class="lineNum">    6688 </span>            :         {</a>
<a name="6689"><span class="lineNum">    6689 </span>            : #if 0</a>
<a name="6690"><span class="lineNum">    6690 </span>            :           printf (&quot;Both startOfConstruct and endOfConstruct are NOT yet initialized with pointers to Sg_File_Info objects (node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6691"><span class="lineNum">    6691 </span>            : #endif</a>
<a name="6692"><span class="lineNum">    6692 </span>            :        // Check the endOfConstruct first since it is most likely NULL (helpful in debugging)</a>
<a name="6693"><span class="lineNum">    6693 </span><span class="lineCov">   10677528 :           ROSE_ASSERT(node-&gt;get_endOfConstruct()   == NULL);</span></a>
<a name="6694"><span class="lineNum">    6694 </span><span class="lineCov">   10677528 :           ROSE_ASSERT(node-&gt;get_startOfConstruct() == NULL);</span></a>
<a name="6695"><span class="lineNum">    6695 </span>            : </a>
<a name="6696"><span class="lineNum">    6696 </span><span class="lineCov">   10677528 :           Sg_File_Info* start_fileInfo = Sg_File_Info::generateDefaultFileInfo();</span></a>
<a name="6697"><span class="lineNum">    6697 </span><span class="lineCov">   10677528 :           Sg_File_Info* end_fileInfo   = Sg_File_Info::generateDefaultFileInfo();</span></a>
<a name="6698"><span class="lineNum">    6698 </span>            : </a>
<a name="6699"><span class="lineNum">    6699 </span>            :        // DQ (5/2/2012): I think we don't want to do this.</a>
<a name="6700"><span class="lineNum">    6700 </span>            : #if 0</a>
<a name="6701"><span class="lineNum">    6701 </span>            :           printf (&quot;In SageInterface::setSourcePositionToDefault(): Calling setSourcePositionUnavailableInFrontend() \n&quot;);</a>
<a name="6702"><span class="lineNum">    6702 </span>            : #endif</a>
<a name="6703"><span class="lineNum">    6703 </span><span class="lineCov">   10677528 :           start_fileInfo-&gt;setSourcePositionUnavailableInFrontend();</span></a>
<a name="6704"><span class="lineNum">    6704 </span><span class="lineCov">   10677528 :           end_fileInfo-&gt;setSourcePositionUnavailableInFrontend();</span></a>
<a name="6705"><span class="lineNum">    6705 </span>            : </a>
<a name="6706"><span class="lineNum">    6706 </span>            :        // DQ (5/2/2012): I think we don't want to do this.</a>
<a name="6707"><span class="lineNum">    6707 </span>            : #if 0</a>
<a name="6708"><span class="lineNum">    6708 </span>            :           printf (&quot;In SageInterface::setSourcePositionToDefault(): Calling setOutputInCodeGeneration() \n&quot;);</a>
<a name="6709"><span class="lineNum">    6709 </span>            : #endif</a>
<a name="6710"><span class="lineNum">    6710 </span>            :        // This is required for the unparser to output the code from the AST.</a>
<a name="6711"><span class="lineNum">    6711 </span><span class="lineCov">   10677528 :           start_fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="6712"><span class="lineNum">    6712 </span><span class="lineCov">   10677528 :           end_fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="6713"><span class="lineNum">    6713 </span>            : </a>
<a name="6714"><span class="lineNum">    6714 </span><span class="lineCov">   10677528 :           node-&gt;set_startOfConstruct(start_fileInfo);</span></a>
<a name="6715"><span class="lineNum">    6715 </span><span class="lineCov">   10677528 :           node-&gt;set_endOfConstruct  (end_fileInfo);</span></a>
<a name="6716"><span class="lineNum">    6716 </span>            : </a>
<a name="6717"><span class="lineNum">    6717 </span><span class="lineCov">   10677528 :           node-&gt;get_startOfConstruct()-&gt;set_parent(node);</span></a>
<a name="6718"><span class="lineNum">    6718 </span><span class="lineCov">   10677528 :           node-&gt;get_endOfConstruct  ()-&gt;set_parent(node);</span></a>
<a name="6719"><span class="lineNum">    6719 </span>            :         }</a>
<a name="6720"><span class="lineNum">    6720 </span>            :        else</a>
<a name="6721"><span class="lineNum">    6721 </span>            :         {</a>
<a name="6722"><span class="lineNum">    6722 </span>            :        // If both the starting  and ending Sg_File_Info pointers are not NULL then both must be valid.</a>
<a name="6723"><span class="lineNum">    6723 </span>            :        // We don't want to support partially completed source code position information.</a>
<a name="6724"><span class="lineNum">    6724 </span>            : #if 0</a>
<a name="6725"><span class="lineNum">    6725 </span>            :           printf (&quot;Both startOfConstruct and endOfConstruct are ALREADY initialized with pointers to Sg_File_Info objects (node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6726"><span class="lineNum">    6726 </span>            : #endif</a>
<a name="6727"><span class="lineNum">    6727 </span><span class="lineCov">    5557730 :           if (node-&gt;get_startOfConstruct() == NULL)</span></a>
<a name="6728"><span class="lineNum">    6728 </span>            :              {</a>
<a name="6729"><span class="lineNum">    6729 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: startOfConstruct not set for locatedNode = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="6730"><span class="lineNum">    6730 </span>            :              }</a>
<a name="6731"><span class="lineNum">    6731 </span><span class="lineCov">    5557730 :           if (node-&gt;get_endOfConstruct() == NULL)</span></a>
<a name="6732"><span class="lineNum">    6732 </span>            :              {</a>
<a name="6733"><span class="lineNum">    6733 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: endOfConstruct not set for locatedNode = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="6734"><span class="lineNum">    6734 </span>            :              }</a>
<a name="6735"><span class="lineNum">    6735 </span>            : </a>
<a name="6736"><span class="lineNum">    6736 </span><span class="lineCov">    5557730 :           ROSE_ASSERT(node-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="6737"><span class="lineNum">    6737 </span><span class="lineCov">    5557730 :           ROSE_ASSERT(node-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="6738"><span class="lineNum">    6738 </span><span class="lineCov">    5557730 :           ROSE_ASSERT(node-&gt;get_endOfConstruct() != NULL &amp;&amp; node-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="6739"><span class="lineNum">    6739 </span>            :         }</a>
<a name="6740"><span class="lineNum">    6740 </span>            : </a>
<a name="6741"><span class="lineNum">    6741 </span>            :   // DQ (11/2/2012): This is an important fix to support the new EDG 4.x branch.</a>
<a name="6742"><span class="lineNum">    6742 </span>            :   // Note that because the unparser will use the function isFromAnotherFile() in the unparsing</a>
<a name="6743"><span class="lineNum">    6743 </span>            :   // of expressions, specifically: SgAggregateInitializer, SgCompoundInitializer, and anything</a>
<a name="6744"><span class="lineNum">    6744 </span>            :   // in their expression lists (which could be any expression).   The isFromAnotherFile() will</a>
<a name="6745"><span class="lineNum">    6745 </span>            :   // use the get_file_info() function on the SgExpression IR nodes and the data from that</a>
<a name="6746"><span class="lineNum">    6746 </span>            :   // Sg_File_Info object to determine if that expression subtree should be unparsed.  This</a>
<a name="6747"><span class="lineNum">    6747 </span>            :   // expression level granularity of unparsing capability is extremely useful in handling</a>
<a name="6748"><span class="lineNum">    6748 </span>            :   // now #includes and other CPP directives are woven back into the AST.  But since the</a>
<a name="6749"><span class="lineNum">    6749 </span>            :   // get_file_info() function is used, and it returns the value of get_operatorPosition(),</a>
<a name="6750"><span class="lineNum">    6750 </span>            :   // it is critically important to have correct data in the SgExpression::p_operatorPosition</a>
<a name="6751"><span class="lineNum">    6751 </span>            :   // Sg_File_Info object (it counts more that the startOfConstruct and endOfConstruct</a>
<a name="6752"><span class="lineNum">    6752 </span>            :   // Sg_File_Info objects in controlling what expressions are unparsed.  So we have to set these</a>
<a name="6753"><span class="lineNum">    6753 </span>            :   // up for all expressions (since any SgExpression could appear in the list contained in</a>
<a name="6754"><span class="lineNum">    6754 </span>            :   // a SgAggregateInitializer or SgCompoundInitializer.</a>
<a name="6755"><span class="lineNum">    6755 </span>            : </a>
<a name="6756"><span class="lineNum">    6756 </span>            :   // DQ (11/2/2012): Set the operator source position information to default values.</a>
<a name="6757"><span class="lineNum">    6757 </span>            :   // This will trigger it to be reset to valid source position information in the front-end.</a>
<a name="6758"><span class="lineNum">    6758 </span><span class="lineCov">   16235228 :      SgExpression* expression = isSgExpression(node);</span></a>
<a name="6759"><span class="lineNum">    6759 </span><span class="lineCov">   16235228 :      if (expression != NULL)</span></a>
<a name="6760"><span class="lineNum">    6760 </span>            :         {</a>
<a name="6761"><span class="lineNum">    6761 </span>            : #if 0</a>
<a name="6762"><span class="lineNum">    6762 </span>            :           SgBinaryOp* binaryOp = isSgBinaryOp(expression);</a>
<a name="6763"><span class="lineNum">    6763 </span>            :           if (binaryOp != NULL)</a>
<a name="6764"><span class="lineNum">    6764 </span>            :              {</a>
<a name="6765"><span class="lineNum">    6765 </span>            :                if (binaryOp-&gt;get_operatorPosition() == NULL)</a>
<a name="6766"><span class="lineNum">    6766 </span>            :                   {</a>
<a name="6767"><span class="lineNum">    6767 </span>            :                     Sg_File_Info* operator_fileInfo = Sg_File_Info::generateDefaultFileInfo();</a>
<a name="6768"><span class="lineNum">    6768 </span>            :                     operator_fileInfo-&gt;setSourcePositionUnavailableInFrontend();</a>
<a name="6769"><span class="lineNum">    6769 </span>            :                     operator_fileInfo-&gt;setOutputInCodeGeneration();</a>
<a name="6770"><span class="lineNum">    6770 </span>            :                     binaryOp-&gt;set_operatorPosition(operator_fileInfo);</a>
<a name="6771"><span class="lineNum">    6771 </span>            : </a>
<a name="6772"><span class="lineNum">    6772 </span>            :                  // This is equivalent to: &quot;operator_fileInfo-&gt;set_parent(binaryOp);&quot;</a>
<a name="6773"><span class="lineNum">    6773 </span>            :                     binaryOp-&gt;get_operatorPosition()-&gt;set_parent(binaryOp);</a>
<a name="6774"><span class="lineNum">    6774 </span>            :                   }</a>
<a name="6775"><span class="lineNum">    6775 </span>            :              }</a>
<a name="6776"><span class="lineNum">    6776 </span>            : #else</a>
<a name="6777"><span class="lineNum">    6777 </span>            :        // Setup all of the SgExpression operatorPosition pointers to default objects.</a>
<a name="6778"><span class="lineNum">    6778 </span><span class="lineCov">     383983 :           if (expression-&gt;get_operatorPosition() == NULL)</span></a>
<a name="6779"><span class="lineNum">    6779 </span>            :              {</a>
<a name="6780"><span class="lineNum">    6780 </span><span class="lineCov">     365772 :                Sg_File_Info* operator_fileInfo = Sg_File_Info::generateDefaultFileInfo();</span></a>
<a name="6781"><span class="lineNum">    6781 </span><span class="lineCov">     365772 :                operator_fileInfo-&gt;setSourcePositionUnavailableInFrontend();</span></a>
<a name="6782"><span class="lineNum">    6782 </span><span class="lineCov">     365772 :                operator_fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="6783"><span class="lineNum">    6783 </span><span class="lineCov">     365772 :                expression-&gt;set_operatorPosition(operator_fileInfo);</span></a>
<a name="6784"><span class="lineNum">    6784 </span>            : </a>
<a name="6785"><span class="lineNum">    6785 </span>            :             // This is equivalent to: &quot;operator_fileInfo-&gt;set_parent(binaryOp);&quot;</a>
<a name="6786"><span class="lineNum">    6786 </span>            :             // expression-&gt;get_operatorPosition()-&gt;set_parent(expression);</a>
<a name="6787"><span class="lineNum">    6787 </span><span class="lineCov">     365772 :                operator_fileInfo-&gt;set_parent(expression);</span></a>
<a name="6788"><span class="lineNum">    6788 </span><span class="lineCov">     365772 :                ROSE_ASSERT(expression-&gt;get_operatorPosition()-&gt;get_parent() == expression);</span></a>
<a name="6789"><span class="lineNum">    6789 </span>            :              }</a>
<a name="6790"><span class="lineNum">    6790 </span>            : #endif</a>
<a name="6791"><span class="lineNum">    6791 </span>            :         }</a>
<a name="6792"><span class="lineNum">    6792 </span><span class="lineCov">   16235228 :    }</span></a>
<a name="6793"><span class="lineNum">    6793 </span>            : </a>
<a name="6794"><span class="lineNum">    6794 </span>            : </a>
<a name="6795"><span class="lineNum">    6795 </span>            : void</a>
<a name="6796"><span class="lineNum">    6796 </span><span class="lineCov">      73886 : SageInterface::setOneSourcePositionForTransformation(SgNode *node)</span></a>
<a name="6797"><span class="lineNum">    6797 </span>            :    {</a>
<a name="6798"><span class="lineNum">    6798 </span>            :   // DQ (5/1/2012): Older depricated function.</a>
<a name="6799"><span class="lineNum">    6799 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="6800"><span class="lineNum">    6800 </span>            :      printf (&quot;+++++ Depricated function (use setSourcePositionAsTransformation() instead) (no using internal source position mode) \n&quot;);</a>
<a name="6801"><span class="lineNum">    6801 </span>            : #endif</a>
<a name="6802"><span class="lineNum">    6802 </span>            : </a>
<a name="6803"><span class="lineNum">    6803 </span>            :   // setSourcePositionAsTransformation(node);</a>
<a name="6804"><span class="lineNum">    6804 </span><span class="lineCov">      73886 :      setSourcePosition(node);</span></a>
<a name="6805"><span class="lineNum">    6805 </span><span class="lineCov">      73886 :    }</span></a>
<a name="6806"><span class="lineNum">    6806 </span>            : </a>
<a name="6807"><span class="lineNum">    6807 </span>            : </a>
<a name="6808"><span class="lineNum">    6808 </span>            : void</a>
<a name="6809"><span class="lineNum">    6809 </span><span class="lineCov">      67985 : SageInterface::setSourcePositionAsTransformation(SgNode *node)</span></a>
<a name="6810"><span class="lineNum">    6810 </span>            :    {</a>
<a name="6811"><span class="lineNum">    6811 </span>            :   // DQ (5/1/2012): Newer function to support specification of IR nodes being a part of a transformation.</a>
<a name="6812"><span class="lineNum">    6812 </span>            : </a>
<a name="6813"><span class="lineNum">    6813 </span>            :   // DQ (1/24/2009): I think this should be renamed to be &quot;setSourcePositionAsTransformation(SgNode *node)&quot;</a>
<a name="6814"><span class="lineNum">    6814 </span>            :   // The logic should be make more independent of if (locatedNode-&gt;get_startOfConstruct() == NULL)</a>
<a name="6815"><span class="lineNum">    6815 </span>            :   // Since that make understanding where the function is applied too complex.</a>
<a name="6816"><span class="lineNum">    6816 </span>            :   // If (locatedNode-&gt;get_startOfConstruct() != NULL), then we should just make that Sg_File_Info as</a>
<a name="6817"><span class="lineNum">    6817 </span>            :   // a transforamtion directly, this function misses that step.</a>
<a name="6818"><span class="lineNum">    6818 </span>            : </a>
<a name="6819"><span class="lineNum">    6819 </span><span class="lineCov">      67985 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6820"><span class="lineNum">    6820 </span>            : </a>
<a name="6821"><span class="lineNum">    6821 </span>            :   // DQ (10/12/2012): Commented out since we are past AST regression tests passing and now trying to get this work checked in.</a>
<a name="6822"><span class="lineNum">    6822 </span>            : //     printf (&quot;In SageInterface::setSourcePositionAsTransformation() for node = %p = %s (make this an error while debugging AST construction) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="6823"><span class="lineNum">    6823 </span>            :   // ROSE_ASSERT(false);</a>
<a name="6824"><span class="lineNum">    6824 </span>            : </a>
<a name="6825"><span class="lineNum">    6825 </span><span class="lineCov">      67985 :      SgLocatedNode*     locatedNode = isSgLocatedNode(node);</span></a>
<a name="6826"><span class="lineNum">    6826 </span><span class="lineCov">      67985 :      SgExpression*      expression  = isSgExpression(node);</span></a>
<a name="6827"><span class="lineNum">    6827 </span>            :   // SgInitializedName* initName    = isSgInitializedName(node);</a>
<a name="6828"><span class="lineNum">    6828 </span><span class="lineCov">      67985 :      SgPragma*          pragma      = isSgPragma(node); // missed this one!! Liao, 1/30/2008</span></a>
<a name="6829"><span class="lineNum">    6829 </span><span class="lineCov">      67985 :      SgGlobal*          global      = isSgGlobal(node); // SgGlobal should have NULL endOfConstruct()</span></a>
<a name="6830"><span class="lineNum">    6830 </span>            : </a>
<a name="6831"><span class="lineNum">    6831 </span>            : #if 0</a>
<a name="6832"><span class="lineNum">    6832 </span>            :      SgVariableDefinition * v_d = isSgVariableDefinition(node);</a>
<a name="6833"><span class="lineNum">    6833 </span>            :      if (v_d )</a>
<a name="6834"><span class="lineNum">    6834 </span>            :        printf (&quot;Debug, Found a variable definition: %p\n&quot;, v_d);</a>
<a name="6835"><span class="lineNum">    6835 </span>            : #endif</a>
<a name="6836"><span class="lineNum">    6836 </span>            : </a>
<a name="6837"><span class="lineNum">    6837 </span>            :   // if ((locatedNode) &amp;&amp; (locatedNode-&gt;get_endOfConstruct() == NULL))</a>
<a name="6838"><span class="lineNum">    6838 </span>            :   // if ( (locatedNode != NULL) &amp;&amp; (locatedNode-&gt;get_startOfConstruct() == NULL) )</a>
<a name="6839"><span class="lineNum">    6839 </span><span class="lineCov">      67985 :      if (locatedNode != NULL)</span></a>
<a name="6840"><span class="lineNum">    6840 </span>            :         {</a>
<a name="6841"><span class="lineNum">    6841 </span><span class="lineCov">      27871 :           locatedNode-&gt;set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</span></a>
<a name="6842"><span class="lineNum">    6842 </span><span class="lineCov">      27871 :           locatedNode-&gt;get_startOfConstruct()-&gt;set_parent(locatedNode);</span></a>
<a name="6843"><span class="lineNum">    6843 </span>            : </a>
<a name="6844"><span class="lineNum">    6844 </span><span class="lineCov">      27871 :           if (global==NULL)</span></a>
<a name="6845"><span class="lineNum">    6845 </span>            :              {</a>
<a name="6846"><span class="lineNum">    6846 </span><span class="lineCov">      27871 :                locatedNode-&gt;set_endOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</span></a>
<a name="6847"><span class="lineNum">    6847 </span><span class="lineCov">      27871 :                locatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(locatedNode);</span></a>
<a name="6848"><span class="lineNum">    6848 </span>            :              }</a>
<a name="6849"><span class="lineNum">    6849 </span>            : </a>
<a name="6850"><span class="lineNum">    6850 </span>            :        // Only SgExpression IR nodes have a 3rd source position data structure.</a>
<a name="6851"><span class="lineNum">    6851 </span><span class="lineCov">      27871 :           if (expression!=NULL)</span></a>
<a name="6852"><span class="lineNum">    6852 </span>            :              {</a>
<a name="6853"><span class="lineNum">    6853 </span><span class="lineCov">      22116 :                expression-&gt;set_operatorPosition(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</span></a>
<a name="6854"><span class="lineNum">    6854 </span><span class="lineCov">      22116 :                expression-&gt;get_operatorPosition()-&gt;set_parent(expression);</span></a>
<a name="6855"><span class="lineNum">    6855 </span>            :              }</a>
<a name="6856"><span class="lineNum">    6856 </span>            :         }</a>
<a name="6857"><span class="lineNum">    6857 </span>            :        else // special non-located node with file info</a>
<a name="6858"><span class="lineNum">    6858 </span>            :         {</a>
<a name="6859"><span class="lineNum">    6859 </span>            : //        if ( (initName != NULL) &amp;&amp; (initName-&gt;get_startOfConstruct() == NULL) )</a>
<a name="6860"><span class="lineNum">    6860 </span>            : //         {</a>
<a name="6861"><span class="lineNum">    6861 </span>            : //           locatedNode-&gt;set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</a>
<a name="6862"><span class="lineNum">    6862 </span>            : //           locatedNode-&gt;get_startOfConstruct()-&gt;set_parent(locatedNode);</a>
<a name="6863"><span class="lineNum">    6863 </span>            : //</a>
<a name="6864"><span class="lineNum">    6864 </span>            : //           locatedNode-&gt;set_endOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</a>
<a name="6865"><span class="lineNum">    6865 </span>            : //           locatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(locatedNode);</a>
<a name="6866"><span class="lineNum">    6866 </span>            : //</a>
<a name="6867"><span class="lineNum">    6867 </span>            : //         }</a>
<a name="6868"><span class="lineNum">    6868 </span>            : //         else</a>
<a name="6869"><span class="lineNum">    6869 </span>            : </a>
<a name="6870"><span class="lineNum">    6870 </span><span class="lineCov">      40114 :           if ( (pragma != NULL) &amp;&amp; (pragma-&gt;get_startOfConstruct() == NULL) )</span></a>
<a name="6871"><span class="lineNum">    6871 </span>            :              {</a>
<a name="6872"><span class="lineNum">    6872 </span><span class="lineCov">          1 :                pragma-&gt;set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</span></a>
<a name="6873"><span class="lineNum">    6873 </span><span class="lineCov">          1 :                pragma-&gt;get_startOfConstruct()-&gt;set_parent(pragma);</span></a>
<a name="6874"><span class="lineNum">    6874 </span>            :              }</a>
<a name="6875"><span class="lineNum">    6875 </span>            :         }</a>
<a name="6876"><span class="lineNum">    6876 </span><span class="lineCov">      67985 :    }</span></a>
<a name="6877"><span class="lineNum">    6877 </span>            : </a>
<a name="6878"><span class="lineNum">    6878 </span>            : </a>
<a name="6879"><span class="lineNum">    6879 </span>            : void</a>
<a name="6880"><span class="lineNum">    6880 </span><span class="lineCov">    9120530 : SageInterface::setOneSourcePositionNull(SgNode *node)</span></a>
<a name="6881"><span class="lineNum">    6881 </span>            :    {</a>
<a name="6882"><span class="lineNum">    6882 </span>            :   // DQ (5/1/2012): Older depricated function (use setSourcePositionPointersToNull() instead).</a>
<a name="6883"><span class="lineNum">    6883 </span>            : #if 0</a>
<a name="6884"><span class="lineNum">    6884 </span>            :      printf (&quot;+++++ Depricated name setOneSourcePositionNull() (use setSourcePositionPointersToNull() instead) (no using internal source position mode) \n&quot;);</a>
<a name="6885"><span class="lineNum">    6885 </span>            : #endif</a>
<a name="6886"><span class="lineNum">    6886 </span>            : </a>
<a name="6887"><span class="lineNum">    6887 </span><span class="lineCov">    9120530 :      setSourcePosition(node);</span></a>
<a name="6888"><span class="lineNum">    6888 </span><span class="lineCov">    9120530 :    }</span></a>
<a name="6889"><span class="lineNum">    6889 </span>            : </a>
<a name="6890"><span class="lineNum">    6890 </span>            : // DQ (5/1/2012): Newly renamed function (previous name preserved for backward compatability).</a>
<a name="6891"><span class="lineNum">    6891 </span>            : void</a>
<a name="6892"><span class="lineNum">    6892 </span><span class="lineNoCov">          0 : SageInterface::setSourcePositionPointersToNull(SgNode *node)</span></a>
<a name="6893"><span class="lineNum">    6893 </span>            :    {</a>
<a name="6894"><span class="lineNum">    6894 </span>            :   // DQ (1/24/2009): I think this should be renamed to be &quot;setSourcePositionToNULL(SgNode *node)&quot;</a>
<a name="6895"><span class="lineNum">    6895 </span>            :   // However, if this is doen then the logic should be that it asserts that: (locatedNode-&gt;get_startOfConstruct() == NULL)</a>
<a name="6896"><span class="lineNum">    6896 </span>            :   // so that we know when we are leaking memory.  Similarly, we should assert that:</a>
<a name="6897"><span class="lineNum">    6897 </span>            :   // (locatedNode-&gt;get_endOfConstruct() == NULL).</a>
<a name="6898"><span class="lineNum">    6898 </span>            :   // But then this function just asserts that everything is already NULL and is less about setting them to NULL.</a>
<a name="6899"><span class="lineNum">    6899 </span>            :   // If (locatedNode-&gt;get_startOfConstruct() != NULL), should we delete the existing Sg_File_Info object?</a>
<a name="6900"><span class="lineNum">    6900 </span>            :   // This function misses that step.</a>
<a name="6901"><span class="lineNum">    6901 </span>            : </a>
<a name="6902"><span class="lineNum">    6902 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="6903"><span class="lineNum">    6903 </span>            : </a>
<a name="6904"><span class="lineNum">    6904 </span><span class="lineNoCov">          0 :      SgLocatedNode *    locatedNode = isSgLocatedNode(node);</span></a>
<a name="6905"><span class="lineNum">    6905 </span><span class="lineNoCov">          0 :      SgExpression*      expression  = isSgExpression(node);</span></a>
<a name="6906"><span class="lineNum">    6906 </span><span class="lineNoCov">          0 :      SgPragma*          pragma      = isSgPragma(node); // missed this one!! Liao, 1/30/2008</span></a>
<a name="6907"><span class="lineNum">    6907 </span><span class="lineNoCov">          0 :      SgGlobal*          global      = isSgGlobal(node); // SgGlobal should have NULL endOfConstruct()</span></a>
<a name="6908"><span class="lineNum">    6908 </span>            : </a>
<a name="6909"><span class="lineNum">    6909 </span>            :   // DQ (1/24/2009): If the point is to set the source position to NULL pointers,</a>
<a name="6910"><span class="lineNum">    6910 </span>            :   // why do we only handle the case when (get_startOfConstruct() == NULL)</a>
<a name="6911"><span class="lineNum">    6911 </span>            :   // (i.e. when the start source postion is already NULL).</a>
<a name="6912"><span class="lineNum">    6912 </span>            : </a>
<a name="6913"><span class="lineNum">    6913 </span>            :   // if ((locatedNode) &amp;&amp; (locatedNode-&gt;get_endOfConstruct() == NULL))</a>
<a name="6914"><span class="lineNum">    6914 </span>            :   // if ( (locatedNode != NULL) &amp;&amp; (locatedNode-&gt;get_startOfConstruct() == NULL) )</a>
<a name="6915"><span class="lineNum">    6915 </span><span class="lineNoCov">          0 :      if (locatedNode != NULL)</span></a>
<a name="6916"><span class="lineNum">    6916 </span>            :         {</a>
<a name="6917"><span class="lineNum">    6917 </span><span class="lineNoCov">          0 :           if (locatedNode-&gt;get_startOfConstruct() != NULL)</span></a>
<a name="6918"><span class="lineNum">    6918 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: In SageInterface::setSourcePositionPointersToNull(): Memory leak of startOfConstruct Sg_File_Info object (setting Sg_File_Info pointers to NULL) \n&quot;);</span></a>
<a name="6919"><span class="lineNum">    6919 </span>            : </a>
<a name="6920"><span class="lineNum">    6920 </span><span class="lineNoCov">          0 :           locatedNode-&gt;set_startOfConstruct(NULL);</span></a>
<a name="6921"><span class="lineNum">    6921 </span>            : </a>
<a name="6922"><span class="lineNum">    6922 </span>            :        // Note that SgGlobal should have NULL endOfConstruct()</a>
<a name="6923"><span class="lineNum">    6923 </span><span class="lineNoCov">          0 :           if (global == NULL)</span></a>
<a name="6924"><span class="lineNum">    6924 </span>            :              {</a>
<a name="6925"><span class="lineNum">    6925 </span><span class="lineNoCov">          0 :                if (locatedNode-&gt;get_endOfConstruct() != NULL)</span></a>
<a name="6926"><span class="lineNum">    6926 </span><span class="lineNoCov">          0 :                     printf (&quot;WARNING: In SageInterface::setSourcePositionPointersToNull(): Memory leak of endOfConstruct Sg_File_Info object (setting Sg_File_Info pointers to NULL) \n&quot;);</span></a>
<a name="6927"><span class="lineNum">    6927 </span>            : </a>
<a name="6928"><span class="lineNum">    6928 </span><span class="lineNoCov">          0 :                locatedNode-&gt;set_endOfConstruct(NULL);</span></a>
<a name="6929"><span class="lineNum">    6929 </span>            :              }</a>
<a name="6930"><span class="lineNum">    6930 </span>            : </a>
<a name="6931"><span class="lineNum">    6931 </span>            :        // Only SgExpression IR nodes have a 3rd source position data structure.</a>
<a name="6932"><span class="lineNum">    6932 </span><span class="lineNoCov">          0 :           if (expression != NULL)</span></a>
<a name="6933"><span class="lineNum">    6933 </span>            :              {</a>
<a name="6934"><span class="lineNum">    6934 </span><span class="lineNoCov">          0 :                if (expression-&gt;get_operatorPosition() != NULL)</span></a>
<a name="6935"><span class="lineNum">    6935 </span><span class="lineNoCov">          0 :                     printf (&quot;WARNING: In SageInterface::setSourcePositionPointersToNull(): Memory leak of operatorPosition Sg_File_Info object (setting Sg_File_Info pointers to NULL) \n&quot;);</span></a>
<a name="6936"><span class="lineNum">    6936 </span>            : </a>
<a name="6937"><span class="lineNum">    6937 </span><span class="lineNoCov">          0 :                expression-&gt;set_operatorPosition(NULL);</span></a>
<a name="6938"><span class="lineNum">    6938 </span>            :              }</a>
<a name="6939"><span class="lineNum">    6939 </span>            :         }</a>
<a name="6940"><span class="lineNum">    6940 </span>            :        else</a>
<a name="6941"><span class="lineNum">    6941 </span>            :         {</a>
<a name="6942"><span class="lineNum">    6942 </span>            :        // if ( (pragma != NULL) &amp;&amp; (pragma-&gt;get_startOfConstruct() == NULL) )</a>
<a name="6943"><span class="lineNum">    6943 </span><span class="lineNoCov">          0 :           if ( (pragma != NULL) &amp;&amp; (pragma-&gt;get_startOfConstruct() != NULL) )</span></a>
<a name="6944"><span class="lineNum">    6944 </span>            :              {</a>
<a name="6945"><span class="lineNum">    6945 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: In SageInterface::setSourcePositionPointersToNull(): Memory leak of Sg_File_Info object (setting Sg_File_Info pointers to NULL) \n&quot;);</span></a>
<a name="6946"><span class="lineNum">    6946 </span>            : </a>
<a name="6947"><span class="lineNum">    6947 </span><span class="lineNoCov">          0 :                pragma-&gt;set_startOfConstruct(NULL);</span></a>
<a name="6948"><span class="lineNum">    6948 </span>            :              }</a>
<a name="6949"><span class="lineNum">    6949 </span>            :         }</a>
<a name="6950"><span class="lineNum">    6950 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6951"><span class="lineNum">    6951 </span>            : </a>
<a name="6952"><span class="lineNum">    6952 </span>            : // DQ (1/24/2009): Could we change the name to be &quot;setSourcePositionAtRootAndAllChildrenAsTransformation(SgNode *root)&quot;</a>
<a name="6953"><span class="lineNum">    6953 </span>            : void</a>
<a name="6954"><span class="lineNum">    6954 </span><span class="lineCov">      35913 : SageInterface::setSourcePositionForTransformation(SgNode *root)</span></a>
<a name="6955"><span class="lineNum">    6955 </span>            :    {</a>
<a name="6956"><span class="lineNum">    6956 </span>            : #if 1</a>
<a name="6957"><span class="lineNum">    6957 </span>            : #if 0</a>
<a name="6958"><span class="lineNum">    6958 </span>            :      printf (&quot;+++++ Depricated name setSourcePositionForTransformation() (use setSourcePositionAtRootAndAllChildrenAsTransformation() instead) \n&quot;);</a>
<a name="6959"><span class="lineNum">    6959 </span>            : #endif</a>
<a name="6960"><span class="lineNum">    6960 </span>            : </a>
<a name="6961"><span class="lineNum">    6961 </span>            :   // This is the semantically correct function to call.</a>
<a name="6962"><span class="lineNum">    6962 </span>            :   // setSourcePositionAtRootAndAllChildrenAsTransformation(root);</a>
<a name="6963"><span class="lineNum">    6963 </span>            : </a>
<a name="6964"><span class="lineNum">    6964 </span>            :   // DQ (5/2/2012): This is a test to replace the support we have to mark every thing as a transformation with the new mechanism using source position modes.</a>
<a name="6965"><span class="lineNum">    6965 </span>            :   // setSourcePosition(root);</a>
<a name="6966"><span class="lineNum">    6966 </span>            :   // Liao 11/21/2012. This function should only be called when the mode is transformation</a>
<a name="6967"><span class="lineNum">    6967 </span>            :   // Liao 8/2/2013. It can actually be called inside frontend by OmpSupport::lower_omp().</a>
<a name="6968"><span class="lineNum">    6968 </span>            :      //ROSE_ASSERT(SageBuilder::SourcePositionClassificationMode == SageBuilder::e_sourcePositionTransformation);</a>
<a name="6969"><span class="lineNum">    6969 </span><span class="lineCov">      35913 :      setSourcePositionAtRootAndAllChildren(root);</span></a>
<a name="6970"><span class="lineNum">    6970 </span>            : #else</a>
<a name="6971"><span class="lineNum">    6971 </span>            :      Rose_STL_Container &lt;SgNode*&gt; nodeList = NodeQuery::querySubTree(root,V_SgNode);</a>
<a name="6972"><span class="lineNum">    6972 </span>            :      for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i!=nodeList.end(); i++ )</a>
<a name="6973"><span class="lineNum">    6973 </span>            :         {</a>
<a name="6974"><span class="lineNum">    6974 </span>            :           setOneSourcePositionForTransformation(*i);</a>
<a name="6975"><span class="lineNum">    6975 </span>            :         }</a>
<a name="6976"><span class="lineNum">    6976 </span>            : #endif</a>
<a name="6977"><span class="lineNum">    6977 </span><span class="lineCov">      35913 :    }</span></a>
<a name="6978"><span class="lineNum">    6978 </span>            : </a>
<a name="6979"><span class="lineNum">    6979 </span>            : </a>
<a name="6980"><span class="lineNum">    6980 </span>            : #if 0</a>
<a name="6981"><span class="lineNum">    6981 </span>            : // DQ (5/1/2012): New function with improved name (still preserving the previous interface).</a>
<a name="6982"><span class="lineNum">    6982 </span>            : void</a>
<a name="6983"><span class="lineNum">    6983 </span>            : SageInterface::setSourcePositionAtRootAndAllChildrenAsTransformation(SgNode *root)</a>
<a name="6984"><span class="lineNum">    6984 </span>            :    {</a>
<a name="6985"><span class="lineNum">    6985 </span>            :      Rose_STL_Container &lt;SgNode*&gt; nodeList= NodeQuery::querySubTree(root,V_SgNode);</a>
<a name="6986"><span class="lineNum">    6986 </span>            :      for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i!=nodeList.end(); i++ )</a>
<a name="6987"><span class="lineNum">    6987 </span>            :         {</a>
<a name="6988"><span class="lineNum">    6988 </span>            :           setOneSourcePositionForTransformation(*i);</a>
<a name="6989"><span class="lineNum">    6989 </span>            :         }</a>
<a name="6990"><span class="lineNum">    6990 </span>            :    }</a>
<a name="6991"><span class="lineNum">    6991 </span>            : #endif</a>
<a name="6992"><span class="lineNum">    6992 </span>            : </a>
<a name="6993"><span class="lineNum">    6993 </span>            : #if 0</a>
<a name="6994"><span class="lineNum">    6994 </span>            : void</a>
<a name="6995"><span class="lineNum">    6995 </span>            : SageInterface::setSourcePositionAtRootAndAllChildrenAsDefault(SgNode *root)</a>
<a name="6996"><span class="lineNum">    6996 </span>            :    {</a>
<a name="6997"><span class="lineNum">    6997 </span>            :      Rose_STL_Container &lt;SgNode*&gt; nodeList= NodeQuery::querySubTree(root,V_SgNode);</a>
<a name="6998"><span class="lineNum">    6998 </span>            :      for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i!=nodeList.end(); i++ )</a>
<a name="6999"><span class="lineNum">    6999 </span>            :         {</a>
<a name="7000"><span class="lineNum">    7000 </span>            :           setSourcePositionAsDefault(*i);</a>
<a name="7001"><span class="lineNum">    7001 </span>            :         }</a>
<a name="7002"><span class="lineNum">    7002 </span>            :    }</a>
<a name="7003"><span class="lineNum">    7003 </span>            : #endif</a>
<a name="7004"><span class="lineNum">    7004 </span>            : </a>
<a name="7005"><span class="lineNum">    7005 </span>            : void</a>
<a name="7006"><span class="lineNum">    7006 </span><span class="lineCov">    2380880 : SageInterface::setSourcePositionAtRootAndAllChildren(SgNode *root)</span></a>
<a name="7007"><span class="lineNum">    7007 </span>            :    {</a>
<a name="7008"><span class="lineNum">    7008 </span>            :   // DQ (2/17/2013): This is a relatively expensive operation so we might look into this.</a>
<a name="7009"><span class="lineNum">    7009 </span>            : </a>
<a name="7010"><span class="lineNum">    7010 </span><span class="lineCov">    2380880 :      Rose_STL_Container &lt;SgNode*&gt; nodeList = NodeQuery::querySubTree(root,V_SgNode);</span></a>
<a name="7011"><span class="lineNum">    7011 </span>            : </a>
<a name="7012"><span class="lineNum">    7012 </span>            : #if 0</a>
<a name="7013"><span class="lineNum">    7013 </span>            :      printf (&quot;In setSourcePositionAtRootAndAllChildren(): nodeList.size() = %&quot; PRIuPTR &quot; \n&quot;,nodeList.size());</a>
<a name="7014"><span class="lineNum">    7014 </span>            : #endif</a>
<a name="7015"><span class="lineNum">    7015 </span>            : </a>
<a name="7016"><span class="lineNum">    7016 </span><span class="lineCov">   29586300 :      for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i != nodeList.end(); i++)</span></a>
<a name="7017"><span class="lineNum">    7017 </span>            :         {</a>
<a name="7018"><span class="lineNum">    7018 </span>            : #if 0</a>
<a name="7019"><span class="lineNum">    7019 </span>            :           printf (&quot;In setSourcePositionAtRootAndAllChildren(): *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="7020"><span class="lineNum">    7020 </span>            : #endif</a>
<a name="7021"><span class="lineNum">    7021 </span><span class="lineCov">   27205400 :           setSourcePosition(*i);</span></a>
<a name="7022"><span class="lineNum">    7022 </span>            :         }</a>
<a name="7023"><span class="lineNum">    7023 </span><span class="lineCov">    2380880 :    }</span></a>
<a name="7024"><span class="lineNum">    7024 </span>            : </a>
<a name="7025"><span class="lineNum">    7025 </span>            : // DQ (5/1/2012): This function queries the SageBuilder::SourcePositionClassification mode (stored in the SageBuilder</a>
<a name="7026"><span class="lineNum">    7026 </span>            : // interface) and used the specified mode to initialize the source position data (Sg_File_Info objects).  This</a>
<a name="7027"><span class="lineNum">    7027 </span>            : // function is the only function that should be called directly (though in a namespace we can't define permissions).</a>
<a name="7028"><span class="lineNum">    7028 </span>            : void</a>
<a name="7029"><span class="lineNum">    7029 </span><span class="lineCov">   37801700 : SageInterface::setSourcePosition(SgNode* node)</span></a>
<a name="7030"><span class="lineNum">    7030 </span>            :    {</a>
<a name="7031"><span class="lineNum">    7031 </span>            :   // Check the mode and build the correct type of source code position.</a>
<a name="7032"><span class="lineNum">    7032 </span><span class="lineCov">   37801700 :      SourcePositionClassification scp = getSourcePositionClassificationMode();</span></a>
<a name="7033"><span class="lineNum">    7033 </span>            : </a>
<a name="7034"><span class="lineNum">    7034 </span>            :   // DQ (2/17/2013): Note that the SourcePositionClassification will be e_sourcePositionFrontendConstruction</a>
<a name="7035"><span class="lineNum">    7035 </span>            :   // during construction of the AST from the EDG frontend.</a>
<a name="7036"><span class="lineNum">    7036 </span>            : </a>
<a name="7037"><span class="lineNum">    7037 </span>            : #if 0</a>
<a name="7038"><span class="lineNum">    7038 </span>            :      printf (&quot;In SageInterface::setSourcePosition(): SourcePositionClassification scp = %s \n&quot;,display(scp).c_str());</a>
<a name="7039"><span class="lineNum">    7039 </span>            : #endif</a>
<a name="7040"><span class="lineNum">    7040 </span>            : </a>
<a name="7041"><span class="lineNum">    7041 </span><span class="lineCov">   37801700 :      switch(scp)</span></a>
<a name="7042"><span class="lineNum">    7042 </span>            :         {</a>
<a name="7043"><span class="lineNum">    7043 </span><span class="lineNoCov">          0 :           case e_sourcePositionError: // Error value for enum.</span></a>
<a name="7044"><span class="lineNum">    7044 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7045"><span class="lineNum">    7045 </span><span class="lineNoCov">          0 :                printf (&quot;Error: error value e_sourcePositionError in SageInterface::setSourcePosition() \n&quot;);</span></a>
<a name="7046"><span class="lineNum">    7046 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="7047"><span class="lineNum">    7047 </span>            :              }</a>
<a name="7048"><span class="lineNum">    7048 </span>            : </a>
<a name="7049"><span class="lineNum">    7049 </span><span class="lineNoCov">          0 :           case e_sourcePositionDefault: // Default source position.</span></a>
<a name="7050"><span class="lineNum">    7050 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7051"><span class="lineNum">    7051 </span>            : #if 0</a>
<a name="7052"><span class="lineNum">    7052 </span>            :                printf (&quot;e_sourcePositionDefault in SageInterface::setSourcePosition() \n&quot;);</a>
<a name="7053"><span class="lineNum">    7053 </span>            : #endif</a>
<a name="7054"><span class="lineNum">    7054 </span><span class="lineNoCov">          0 :                SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="7055"><span class="lineNum">    7055 </span><span class="lineNoCov">          0 :                if (locatedNode != NULL)</span></a>
<a name="7056"><span class="lineNum">    7056 </span>            :                   {</a>
<a name="7057"><span class="lineNum">    7057 </span><span class="lineNoCov">          0 :                     setSourcePositionToDefault(locatedNode);</span></a>
<a name="7058"><span class="lineNum">    7058 </span>            :                   }</a>
<a name="7059"><span class="lineNum">    7059 </span>            :                  else</a>
<a name="7060"><span class="lineNum">    7060 </span>            :                   {</a>
<a name="7061"><span class="lineNum">    7061 </span>            :                  // This is not supported (not clear if it need be).</a>
<a name="7062"><span class="lineNum">    7062 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: can't call setSourcePosition() in mode e_sourcePositionDefault with non SgLocatedNode (node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="7063"><span class="lineNum">    7063 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="7064"><span class="lineNum">    7064 </span>            :                   }</a>
<a name="7065"><span class="lineNum">    7065 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="7066"><span class="lineNum">    7066 </span>            :              }</a>
<a name="7067"><span class="lineNum">    7067 </span>            : </a>
<a name="7068"><span class="lineNum">    7068 </span><span class="lineCov">      67985 :           case e_sourcePositionTransformation:       // Classify as a transformation.</span></a>
<a name="7069"><span class="lineNum">    7069 </span><span class="lineCov">      67985 :              {</span></a>
<a name="7070"><span class="lineNum">    7070 </span>            : #if 0</a>
<a name="7071"><span class="lineNum">    7071 </span>            :                printf (&quot;e_sourcePositionTransformation in SageInterface::setSourcePosition() \n&quot;);</a>
<a name="7072"><span class="lineNum">    7072 </span>            : #endif</a>
<a name="7073"><span class="lineNum">    7073 </span>            :             // setSourcePositionAtRootAndAllChildrenAsTransformation(node);</a>
<a name="7074"><span class="lineNum">    7074 </span><span class="lineCov">      67985 :                setSourcePositionAsTransformation(node);</span></a>
<a name="7075"><span class="lineNum">    7075 </span><span class="lineCov">      67985 :                break;</span></a>
<a name="7076"><span class="lineNum">    7076 </span>            :              }</a>
<a name="7077"><span class="lineNum">    7077 </span>            : </a>
<a name="7078"><span class="lineNum">    7078 </span><span class="lineNoCov">          0 :           case e_sourcePositionCompilerGenerated:    // Classify as compiler generated code (e.g. template instantiation).</span></a>
<a name="7079"><span class="lineNum">    7079 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7080"><span class="lineNum">    7080 </span><span class="lineNoCov">          0 :                printf (&quot;e_sourcePositionCompilerGenerated in SageInterface::setSourcePosition() \n&quot;);</span></a>
<a name="7081"><span class="lineNum">    7081 </span>            : </a>
<a name="7082"><span class="lineNum">    7082 </span><span class="lineNoCov">          0 :                printf (&quot;Sorry, not implemented \n&quot;);</span></a>
<a name="7083"><span class="lineNum">    7083 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="7084"><span class="lineNum">    7084 </span>            :              }</a>
<a name="7085"><span class="lineNum">    7085 </span>            : </a>
<a name="7086"><span class="lineNum">    7086 </span><span class="lineNoCov">          0 :           case e_sourcePositionNullPointers:         // Set pointers to Sg_File_Info objects to NULL.</span></a>
<a name="7087"><span class="lineNum">    7087 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7088"><span class="lineNum">    7088 </span>            :             // DQ (2/17/2013): We want to move to this mode as the one used for EDG/ROSE connection so that we can</a>
<a name="7089"><span class="lineNum">    7089 </span>            :             // avoid building and rebuilding source position information.</a>
<a name="7090"><span class="lineNum">    7090 </span>            : #if 0</a>
<a name="7091"><span class="lineNum">    7091 </span>            :                printf (&quot;e_sourcePositionNullPointers in SageInterface::setSourcePosition() \n&quot;);</a>
<a name="7092"><span class="lineNum">    7092 </span>            : #endif</a>
<a name="7093"><span class="lineNum">    7093 </span><span class="lineNoCov">          0 :                setSourcePositionPointersToNull(node);</span></a>
<a name="7094"><span class="lineNum">    7094 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="7095"><span class="lineNum">    7095 </span>            :              }</a>
<a name="7096"><span class="lineNum">    7096 </span>            : </a>
<a name="7097"><span class="lineNum">    7097 </span><span class="lineCov">   37733700 :           case e_sourcePositionFrontendConstruction: // Specify as source position to be filled in as part of AST construction in the front-end.</span></a>
<a name="7098"><span class="lineNum">    7098 </span><span class="lineCov">   37733700 :              {</span></a>
<a name="7099"><span class="lineNum">    7099 </span>            :             // DQ (2/17/2013): The setSourcePositionToDefault() function is called a lot, so it might be a performance issue.</a>
<a name="7100"><span class="lineNum">    7100 </span>            :             // All IR nodes built by the Build Interface are assighed source position information</a>
<a name="7101"><span class="lineNum">    7101 </span>            :             // using this function and then reset afterward as we use information within EDG to</a>
<a name="7102"><span class="lineNum">    7102 </span>            :             // reset the source position information.  Ideally, the EDG/ROSE connection would</a>
<a name="7103"><span class="lineNum">    7103 </span>            :             // use NULL pointers as the behavior for the front-end mode.  We can move to that</a>
<a name="7104"><span class="lineNum">    7104 </span>            :             // later to make the source position handling more efficient.</a>
<a name="7105"><span class="lineNum">    7105 </span>            : </a>
<a name="7106"><span class="lineNum">    7106 </span>            :             // This function builds an empty Sg_File_Info entry (valid object but filled with default values; must be reset in front-end processing).</a>
<a name="7107"><span class="lineNum">    7107 </span>            : #if 0</a>
<a name="7108"><span class="lineNum">    7108 </span>            :                printf (&quot;e_sourcePositionFrontendConstruction in SageInterface::setSourcePosition() \n&quot;);</a>
<a name="7109"><span class="lineNum">    7109 </span>            : #endif</a>
<a name="7110"><span class="lineNum">    7110 </span><span class="lineCov">   37733700 :                SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="7111"><span class="lineNum">    7111 </span><span class="lineCov">   37733700 :                if (locatedNode != NULL)</span></a>
<a name="7112"><span class="lineNum">    7112 </span>            :                   {</a>
<a name="7113"><span class="lineNum">    7113 </span>            :                  // setSourcePositionAtRootAndAllChildrenAsDefault(locatedNode);</a>
<a name="7114"><span class="lineNum">    7114 </span><span class="lineCov">   16233400 :                     setSourcePositionToDefault(locatedNode);</span></a>
<a name="7115"><span class="lineNum">    7115 </span>            :                   }</a>
<a name="7116"><span class="lineNum">    7116 </span>            :                  else</a>
<a name="7117"><span class="lineNum">    7117 </span>            :                   {</a>
<a name="7118"><span class="lineNum">    7118 </span>            :                  // This is not supported (not clear if it need be).</a>
<a name="7119"><span class="lineNum">    7119 </span><span class="lineCov">   21500300 :                     SgPragma* pragma = isSgPragma(node);</span></a>
<a name="7120"><span class="lineNum">    7120 </span><span class="lineCov">   21500300 :                     if (pragma != NULL)</span></a>
<a name="7121"><span class="lineNum">    7121 </span>            :                        {</a>
<a name="7122"><span class="lineNum">    7122 </span><span class="lineCov">       1828 :                          setSourcePositionToDefault(pragma);</span></a>
<a name="7123"><span class="lineNum">    7123 </span>            :                        }</a>
<a name="7124"><span class="lineNum">    7124 </span>            :                       else</a>
<a name="7125"><span class="lineNum">    7125 </span>            :                        {</a>
<a name="7126"><span class="lineNum">    7126 </span>            :                       // printf (&quot;Error: can't call setSourcePosition() in mode e_sourcePositionFrontendConstruction with non SgLocatedNode (node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="7127"><span class="lineNum">    7127 </span>            :                       // ROSE_ASSERT(false);</a>
<a name="7128"><span class="lineNum">    7128 </span><span class="lineCov">   21498500 :                          SgType* type = isSgType(node);</span></a>
<a name="7129"><span class="lineNum">    7129 </span><span class="lineCov">   21498500 :                          if (type != NULL)</span></a>
<a name="7130"><span class="lineNum">    7130 </span>            :                             {</a>
<a name="7131"><span class="lineNum">    7131 </span>            :                            // Ignore this case, OK.</a>
<a name="7132"><span class="lineNum">    7132 </span>            :                             }</a>
<a name="7133"><span class="lineNum">    7133 </span>            :                            else</a>
<a name="7134"><span class="lineNum">    7134 </span>            :                             {</a>
<a name="7135"><span class="lineNum">    7135 </span><span class="lineCov">    1161180 :                               SgFunctionParameterTypeList* functionParameterTypeList = isSgFunctionParameterTypeList(node);</span></a>
<a name="7136"><span class="lineNum">    7136 </span><span class="lineCov">    1161180 :                               if (functionParameterTypeList != NULL)</span></a>
<a name="7137"><span class="lineNum">    7137 </span>            :                                  {</a>
<a name="7138"><span class="lineNum">    7138 </span>            :                                 // Ignore this case, OK.</a>
<a name="7139"><span class="lineNum">    7139 </span>            :                                  }</a>
<a name="7140"><span class="lineNum">    7140 </span>            :                                 else</a>
<a name="7141"><span class="lineNum">    7141 </span>            :                                  {</a>
<a name="7142"><span class="lineNum">    7142 </span><span class="lineNoCov">          0 :                                    printf (&quot;Error: can't call setSourcePosition() in mode e_sourcePositionFrontendConstruction with non SgLocatedNode (node = %p = %s) \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="7143"><span class="lineNum">    7143 </span><span class="lineNoCov">          0 :                                    ROSE_ABORT();</span></a>
<a name="7144"><span class="lineNum">    7144 </span>            :                                  }</a>
<a name="7145"><span class="lineNum">    7145 </span>            :                             }</a>
<a name="7146"><span class="lineNum">    7146 </span>            :                        }</a>
<a name="7147"><span class="lineNum">    7147 </span>            :                   }</a>
<a name="7148"><span class="lineNum">    7148 </span>            : </a>
<a name="7149"><span class="lineNum">    7149 </span>            :                break;</a>
<a name="7150"><span class="lineNum">    7150 </span>            :              }</a>
<a name="7151"><span class="lineNum">    7151 </span>            : </a>
<a name="7152"><span class="lineNum">    7152 </span>            : </a>
<a name="7153"><span class="lineNum">    7153 </span><span class="lineNoCov">          0 :           case e_sourcePosition_last:</span></a>
<a name="7154"><span class="lineNum">    7154 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7155"><span class="lineNum">    7155 </span><span class="lineNoCov">          0 :                printf (&quot;Error: error value e_sourcePositionError in SageInterface::setSourcePosition() \n&quot;);</span></a>
<a name="7156"><span class="lineNum">    7156 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="7157"><span class="lineNum">    7157 </span>            :              }</a>
<a name="7158"><span class="lineNum">    7158 </span>            : </a>
<a name="7159"><span class="lineNum">    7159 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="7160"><span class="lineNum">    7160 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7161"><span class="lineNum">    7161 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached in SageInterface::setSourcePosition() \n&quot;);</span></a>
<a name="7162"><span class="lineNum">    7162 </span>            :                break;</a>
<a name="7163"><span class="lineNum">    7163 </span>            :              }</a>
<a name="7164"><span class="lineNum">    7164 </span>            :         }</a>
<a name="7165"><span class="lineNum">    7165 </span>            : </a>
<a name="7166"><span class="lineNum">    7166 </span>            : #if 0</a>
<a name="7167"><span class="lineNum">    7167 </span>            :      if (node-&gt;get_file_info() != NULL)</a>
<a name="7168"><span class="lineNum">    7168 </span>            :         {</a>
<a name="7169"><span class="lineNum">    7169 </span>            :           node-&gt;get_file_info()-&gt;display(&quot;Leaving SageInterface::setSourcePosition()&quot;);</a>
<a name="7170"><span class="lineNum">    7170 </span>            :         }</a>
<a name="7171"><span class="lineNum">    7171 </span>            : #endif</a>
<a name="7172"><span class="lineNum">    7172 </span><span class="lineCov">   37801700 :    }</span></a>
<a name="7173"><span class="lineNum">    7173 </span>            : </a>
<a name="7174"><span class="lineNum">    7174 </span>            : #if 0</a>
<a name="7175"><span class="lineNum">    7175 </span>            : void</a>
<a name="7176"><span class="lineNum">    7176 </span>            : SageInterface::setSourcePositionForTransformation_memoryPool()</a>
<a name="7177"><span class="lineNum">    7177 </span>            :    {</a>
<a name="7178"><span class="lineNum">    7178 </span>            :   // DQ (1/24/2009): This seems like a very dangerous function to have, is it required!</a>
<a name="7179"><span class="lineNum">    7179 </span>            : </a>
<a name="7180"><span class="lineNum">    7180 </span>            :   // DQ (5/1/2012): Make it an error to call this function.</a>
<a name="7181"><span class="lineNum">    7181 </span>            :      printf (&quot;ERROR: In setSourcePositionForTransformation_memoryPool(): This seems like a very dangerous function to have, is it required? \n&quot;);</a>
<a name="7182"><span class="lineNum">    7182 </span>            :      ROSE_ABORT();</a>
<a name="7183"><span class="lineNum">    7183 </span>            : </a>
<a name="7184"><span class="lineNum">    7184 </span>            :      VariantVector vv(V_SgNode);</a>
<a name="7185"><span class="lineNum">    7185 </span>            :      Rose_STL_Container&lt;SgNode*&gt; nodeList = NodeQuery::queryMemoryPool(vv);</a>
<a name="7186"><span class="lineNum">    7186 </span>            :      for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i != nodeList.end(); i++ )</a>
<a name="7187"><span class="lineNum">    7187 </span>            :         {</a>
<a name="7188"><span class="lineNum">    7188 </span>            :           setOneSourcePositionForTransformation(*i);</a>
<a name="7189"><span class="lineNum">    7189 </span>            :         }</a>
<a name="7190"><span class="lineNum">    7190 </span>            :    }</a>
<a name="7191"><span class="lineNum">    7191 </span>            : #endif</a>
<a name="7192"><span class="lineNum">    7192 </span>            : </a>
<a name="7193"><span class="lineNum">    7193 </span><span class="lineCov">         23 : SgGlobal * SageInterface::getFirstGlobalScope(SgProject *project)</span></a>
<a name="7194"><span class="lineNum">    7194 </span>            :    {</a>
<a name="7195"><span class="lineNum">    7195 </span>            :   // Liao, 1/9/2008, get the first global scope from current project</a>
<a name="7196"><span class="lineNum">    7196 </span>            :   // mostly used to prepare for AST construction under the global scope</a>
<a name="7197"><span class="lineNum">    7197 </span><span class="lineCov">         23 :      ROSE_ASSERT(project != NULL);</span></a>
<a name="7198"><span class="lineNum">    7198 </span>            : </a>
<a name="7199"><span class="lineNum">    7199 </span>            :   // DQ (1/24/2009): Added a check to make sure STL list is non-empty.</a>
<a name="7200"><span class="lineNum">    7200 </span><span class="lineCov">         23 :      ROSE_ASSERT(project-&gt;get_fileList().empty() == false);</span></a>
<a name="7201"><span class="lineNum">    7201 </span>            : </a>
<a name="7202"><span class="lineNum">    7202 </span>            :   // SgGlobal* global = project-&gt;get_file(0).get_root();</a>
<a name="7203"><span class="lineNum">    7203 </span><span class="lineCov">         23 :      SgSourceFile* file = isSgSourceFile(project-&gt;get_fileList()[0]);</span></a>
<a name="7204"><span class="lineNum">    7204 </span><span class="lineCov">         23 :      SgGlobal* global = file-&gt;get_globalScope();</span></a>
<a name="7205"><span class="lineNum">    7205 </span>            : </a>
<a name="7206"><span class="lineNum">    7206 </span>            : #if 0</a>
<a name="7207"><span class="lineNum">    7207 </span>            :      SgFilePtrListPtr fileList = project-&gt;get_fileList();</a>
<a name="7208"><span class="lineNum">    7208 </span>            :      SgFilePtrList::const_iterator i= fileList-&gt;begin();</a>
<a name="7209"><span class="lineNum">    7209 </span>            : </a>
<a name="7210"><span class="lineNum">    7210 </span>            :      SgGlobal* global = (*i)-&gt;get_globalScope();</a>
<a name="7211"><span class="lineNum">    7211 </span>            : #endif</a>
<a name="7212"><span class="lineNum">    7212 </span><span class="lineCov">         23 :      ROSE_ASSERT(global != NULL);</span></a>
<a name="7213"><span class="lineNum">    7213 </span>            : </a>
<a name="7214"><span class="lineNum">    7214 </span><span class="lineCov">         23 :      return global;</span></a>
<a name="7215"><span class="lineNum">    7215 </span>            :    }</a>
<a name="7216"><span class="lineNum">    7216 </span>            : </a>
<a name="7217"><span class="lineNum">    7217 </span>            : // Liao, 1/10/2008, get the last stmt from the scope</a>
<a name="7218"><span class="lineNum">    7218 </span>            : // two cases</a>
<a name="7219"><span class="lineNum">    7219 </span>            : //      SgScopeStatement::getDeclarationList</a>
<a name="7220"><span class="lineNum">    7220 </span>            : //      SgScopeStatement::getStatementList()</a>
<a name="7221"><span class="lineNum">    7221 </span><span class="lineCov">         25 : SgStatement* SageInterface::getLastStatement(SgScopeStatement *scope)</span></a>
<a name="7222"><span class="lineNum">    7222 </span>            :    {</a>
<a name="7223"><span class="lineNum">    7223 </span><span class="lineCov">         25 :      ROSE_ASSERT(scope);</span></a>
<a name="7224"><span class="lineNum">    7224 </span><span class="lineCov">         25 :      SgStatement* stmt = NULL;</span></a>
<a name="7225"><span class="lineNum">    7225 </span>            : </a>
<a name="7226"><span class="lineNum">    7226 </span><span class="lineCov">         25 :      if (scope-&gt;containsOnlyDeclarations())</span></a>
<a name="7227"><span class="lineNum">    7227 </span>            :         {</a>
<a name="7228"><span class="lineNum">    7228 </span>            :        // DQ (2/17/2013): Fixed declList to be a reference instead of a copy.</a>
<a name="7229"><span class="lineNum">    7229 </span>            :        // SgDeclarationStatementPtrList declList = scope-&gt;getDeclarationList();</a>
<a name="7230"><span class="lineNum">    7230 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList &amp; declList = scope-&gt;getDeclarationList();</span></a>
<a name="7231"><span class="lineNum">    7231 </span>            : </a>
<a name="7232"><span class="lineNum">    7232 </span>            :        // DQ (2/17/2013): Fixed evaluation of empty list use SgDeclarationStatementPtrList::empty() member function for faster performance.</a>
<a name="7233"><span class="lineNum">    7233 </span>            :        // if (declList.size()&gt;0)</a>
<a name="7234"><span class="lineNum">    7234 </span><span class="lineNoCov">          0 :           if (declList.empty() == false)</span></a>
<a name="7235"><span class="lineNum">    7235 </span>            :              {</a>
<a name="7236"><span class="lineNum">    7236 </span><span class="lineNoCov">          0 :                stmt = isSgStatement(declList.back());</span></a>
<a name="7237"><span class="lineNum">    7237 </span>            :              }</a>
<a name="7238"><span class="lineNum">    7238 </span>            :         }</a>
<a name="7239"><span class="lineNum">    7239 </span>            :        else</a>
<a name="7240"><span class="lineNum">    7240 </span>            :         {</a>
<a name="7241"><span class="lineNum">    7241 </span>            :        // DQ (2/17/2013): Fixed stmtList to be a reference instead of a copy.</a>
<a name="7242"><span class="lineNum">    7242 </span><span class="lineCov">         25 :           SgStatementPtrList &amp; stmtList = scope-&gt;getStatementList();</span></a>
<a name="7243"><span class="lineNum">    7243 </span>            : </a>
<a name="7244"><span class="lineNum">    7244 </span>            :        // DQ (2/17/2013): Fixed evaluation of empty list use SgDeclarationStatementPtrList::empty() member function for faster performance.</a>
<a name="7245"><span class="lineNum">    7245 </span>            :        // if (stmtList.size()&gt;0)</a>
<a name="7246"><span class="lineNum">    7246 </span><span class="lineCov">         25 :           if (stmtList.empty() == false)</span></a>
<a name="7247"><span class="lineNum">    7247 </span>            :              {</a>
<a name="7248"><span class="lineNum">    7248 </span><span class="lineCov">         25 :                stmt = stmtList.back();</span></a>
<a name="7249"><span class="lineNum">    7249 </span>            :              }</a>
<a name="7250"><span class="lineNum">    7250 </span>            :         }</a>
<a name="7251"><span class="lineNum">    7251 </span>            : </a>
<a name="7252"><span class="lineNum">    7252 </span><span class="lineCov">         25 :      return stmt;</span></a>
<a name="7253"><span class="lineNum">    7253 </span>            :    }</a>
<a name="7254"><span class="lineNum">    7254 </span>            : </a>
<a name="7255"><span class="lineNum">    7255 </span>            : </a>
<a name="7256"><span class="lineNum">    7256 </span><span class="lineCov">          7 : SgStatement* SageInterface::getFirstStatement(SgScopeStatement *scope, bool includingCompilerGenerated/*=false*/)</span></a>
<a name="7257"><span class="lineNum">    7257 </span>            :    {</a>
<a name="7258"><span class="lineNum">    7258 </span>            :   // DQ (2/17/2013): This function appears to be a performance problem (so a pass was made to</a>
<a name="7259"><span class="lineNum">    7259 </span>            :   // use lower complexity operations that are equivalent in funcionality for this context).</a>
<a name="7260"><span class="lineNum">    7260 </span>            : </a>
<a name="7261"><span class="lineNum">    7261 </span><span class="lineCov">          7 :      ROSE_ASSERT(scope);</span></a>
<a name="7262"><span class="lineNum">    7262 </span><span class="lineCov">          7 :      SgStatement* stmt = NULL;</span></a>
<a name="7263"><span class="lineNum">    7263 </span>            : </a>
<a name="7264"><span class="lineNum">    7264 </span><span class="lineCov">          7 :      if (scope-&gt;containsOnlyDeclarations())</span></a>
<a name="7265"><span class="lineNum">    7265 </span>            :         {</a>
<a name="7266"><span class="lineNum">    7266 </span>            :        // DQ (2/17/2013): Fixed declList to be a reference instead of a copy.</a>
<a name="7267"><span class="lineNum">    7267 </span>            :        // DQ Note: Do we really need to make a copy of the list just to return a pointer to the first entry?</a>
<a name="7268"><span class="lineNum">    7268 </span>            :        // SgDeclarationStatementPtrList declList = scope-&gt;getDeclarationList();</a>
<a name="7269"><span class="lineNum">    7269 </span><span class="lineCov">          3 :           SgDeclarationStatementPtrList &amp; declList = scope-&gt;getDeclarationList();</span></a>
<a name="7270"><span class="lineNum">    7270 </span><span class="lineCov">          3 :           if (includingCompilerGenerated)</span></a>
<a name="7271"><span class="lineNum">    7271 </span>            :              {</a>
<a name="7272"><span class="lineNum">    7272 </span>            :             // DQ (2/17/2013): Fixed evaluation of empty list use SgDeclarationStatementPtrList::empty() member function for faster performance.</a>
<a name="7273"><span class="lineNum">    7273 </span>            :             // DQ Note: (declList.empty() == false) is a much faster test  O(1) than (declList.size() &gt; 0), which is O(n).</a>
<a name="7274"><span class="lineNum">    7274 </span>            :             // if (declList.size()&gt;0)</a>
<a name="7275"><span class="lineNum">    7275 </span><span class="lineNoCov">          0 :                if (declList.empty() == false)</span></a>
<a name="7276"><span class="lineNum">    7276 </span>            :                   {</a>
<a name="7277"><span class="lineNum">    7277 </span><span class="lineNoCov">          0 :                     stmt = isSgStatement(declList.front());</span></a>
<a name="7278"><span class="lineNum">    7278 </span>            :                   }</a>
<a name="7279"><span class="lineNum">    7279 </span>            :              }</a>
<a name="7280"><span class="lineNum">    7280 </span>            :             else</a>
<a name="7281"><span class="lineNum">    7281 </span>            :              {</a>
<a name="7282"><span class="lineNum">    7282 </span>            :             // skip compiler-generated declarations</a>
<a name="7283"><span class="lineNum">    7283 </span><span class="lineCov">          3 :                SgDeclarationStatementPtrList::iterator i=declList.begin();</span></a>
<a name="7284"><span class="lineNum">    7284 </span><span class="lineCov">       8824 :                while (i != declList.end())</span></a>
<a name="7285"><span class="lineNum">    7285 </span>            :                   {</a>
<a name="7286"><span class="lineNum">    7286 </span>            :                  // isCompilerGenerated(),isOutputInCodeGeneration(),etc. are not good enough,</a>
<a name="7287"><span class="lineNum">    7287 </span>            :                  // some content from headers included are not marked as compiler-generated</a>
<a name="7288"><span class="lineNum">    7288 </span>            :                  //</a>
<a name="7289"><span class="lineNum">    7289 </span>            :                  // cout&lt;&lt;(*i)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="7290"><span class="lineNum">    7290 </span>            :                  // ((*i)-&gt;get_file_info())-&gt;display(&quot;debug.......&quot;);</a>
<a name="7291"><span class="lineNum">    7291 </span><span class="lineCov">       8824 :                     Sg_File_Info * fileInfo = (*i)-&gt;get_file_info();</span></a>
<a name="7292"><span class="lineNum">    7292 </span>            :                  // include transformation-generated  statements, but not the hidden ones</a>
<a name="7293"><span class="lineNum">    7293 </span>            :                  // Note: isOutputInCodeGeneration is not default to true for original statements from user code</a>
<a name="7294"><span class="lineNum">    7294 </span><span class="lineCov">       8824 :                     if ((fileInfo-&gt;isSameFile(scope-&gt;get_file_info())) || (fileInfo-&gt;isTransformation() &amp;&amp; fileInfo-&gt;isOutputInCodeGeneration()))</span></a>
<a name="7295"><span class="lineNum">    7295 </span>            :                        {</a>
<a name="7296"><span class="lineNum">    7296 </span><span class="lineCov">          3 :                          stmt = *i;</span></a>
<a name="7297"><span class="lineNum">    7297 </span><span class="lineCov">          3 :                          break;</span></a>
<a name="7298"><span class="lineNum">    7298 </span>            :                        }</a>
<a name="7299"><span class="lineNum">    7299 </span>            :                       else</a>
<a name="7300"><span class="lineNum">    7300 </span>            :                        {</a>
<a name="7301"><span class="lineNum">    7301 </span><span class="lineCov">       8821 :                          i++;</span></a>
<a name="7302"><span class="lineNum">    7302 </span><span class="lineCov">       8821 :                          continue;</span></a>
<a name="7303"><span class="lineNum">    7303 </span>            :                        }</a>
<a name="7304"><span class="lineNum">    7304 </span>            :                   }</a>
<a name="7305"><span class="lineNum">    7305 </span>            :              }</a>
<a name="7306"><span class="lineNum">    7306 </span>            :         }</a>
<a name="7307"><span class="lineNum">    7307 </span>            :        else</a>
<a name="7308"><span class="lineNum">    7308 </span>            :         {</a>
<a name="7309"><span class="lineNum">    7309 </span>            :        // DQ Note: Do we really need to make a copy of the list just to return a pointer to the first entry?</a>
<a name="7310"><span class="lineNum">    7310 </span><span class="lineCov">          4 :           SgStatementPtrList &amp; stmtList = scope-&gt;getStatementList();</span></a>
<a name="7311"><span class="lineNum">    7311 </span><span class="lineCov">          4 :           if (includingCompilerGenerated)</span></a>
<a name="7312"><span class="lineNum">    7312 </span>            :              {</a>
<a name="7313"><span class="lineNum">    7313 </span>            :             // DQ (2/17/2013): Fixed evaluation of empty list use SgStatementPtrList::empty() member function for faster performance.</a>
<a name="7314"><span class="lineNum">    7314 </span>            :             // DQ Note: (stmtList.empty() == false) is a much faster test  O(1) than (stmtList.size() &gt; 0), which is O(n).</a>
<a name="7315"><span class="lineNum">    7315 </span>            :             // if (stmtList.size()&gt;0)</a>
<a name="7316"><span class="lineNum">    7316 </span><span class="lineNoCov">          0 :                if (stmtList.empty() == false)</span></a>
<a name="7317"><span class="lineNum">    7317 </span>            :                   {</a>
<a name="7318"><span class="lineNum">    7318 </span><span class="lineNoCov">          0 :                     stmt = stmtList.front();</span></a>
<a name="7319"><span class="lineNum">    7319 </span>            :                   }</a>
<a name="7320"><span class="lineNum">    7320 </span>            :              }</a>
<a name="7321"><span class="lineNum">    7321 </span>            :             else</a>
<a name="7322"><span class="lineNum">    7322 </span>            :              {</a>
<a name="7323"><span class="lineNum">    7323 </span>            :             // skip compiler-generated declarations</a>
<a name="7324"><span class="lineNum">    7324 </span><span class="lineCov">          4 :                SgStatementPtrList::iterator i = stmtList.begin();</span></a>
<a name="7325"><span class="lineNum">    7325 </span><span class="lineCov">          4 :                while (i!=stmtList.end())</span></a>
<a name="7326"><span class="lineNum">    7326 </span>            :                   {</a>
<a name="7327"><span class="lineNum">    7327 </span>            :                  // isCompilerGenerated(),isOutputInCodeGeneration(),etc. are not good enough,</a>
<a name="7328"><span class="lineNum">    7328 </span>            :                  // some content from headers included are not marked as compiler-generated</a>
<a name="7329"><span class="lineNum">    7329 </span>            :                  //</a>
<a name="7330"><span class="lineNum">    7330 </span>            :                  // cout&lt;&lt;(*i)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="7331"><span class="lineNum">    7331 </span>            :                  // ((*i)-&gt;get_file_info())-&gt;display(&quot;debug.......&quot;);</a>
<a name="7332"><span class="lineNum">    7332 </span><span class="lineCov">          4 :                     Sg_File_Info * fileInfo = (*i)-&gt;get_file_info();</span></a>
<a name="7333"><span class="lineNum">    7333 </span>            :                  // include transformation-generated  statements, but not the hidden ones</a>
<a name="7334"><span class="lineNum">    7334 </span>            :                  // Note: isOutputInCodeGeneration is not default to true for original statements from user code</a>
<a name="7335"><span class="lineNum">    7335 </span><span class="lineCov">          4 :                     if ( (fileInfo-&gt;isSameFile(scope-&gt;get_file_info())) || (fileInfo-&gt;isTransformation()&amp;&amp; fileInfo-&gt;isOutputInCodeGeneration()))</span></a>
<a name="7336"><span class="lineNum">    7336 </span>            :                        {</a>
<a name="7337"><span class="lineNum">    7337 </span><span class="lineCov">          4 :                          stmt=*i;</span></a>
<a name="7338"><span class="lineNum">    7338 </span><span class="lineCov">          4 :                          break;</span></a>
<a name="7339"><span class="lineNum">    7339 </span>            :                        }</a>
<a name="7340"><span class="lineNum">    7340 </span>            :                       else</a>
<a name="7341"><span class="lineNum">    7341 </span>            :                        {</a>
<a name="7342"><span class="lineNum">    7342 </span><span class="lineNoCov">          0 :                          i++;</span></a>
<a name="7343"><span class="lineNum">    7343 </span><span class="lineNoCov">          0 :                          continue;</span></a>
<a name="7344"><span class="lineNum">    7344 </span>            :                        }</a>
<a name="7345"><span class="lineNum">    7345 </span>            :                   }</a>
<a name="7346"><span class="lineNum">    7346 </span>            :              }</a>
<a name="7347"><span class="lineNum">    7347 </span>            :         }</a>
<a name="7348"><span class="lineNum">    7348 </span>            : </a>
<a name="7349"><span class="lineNum">    7349 </span><span class="lineCov">          7 :      return stmt;</span></a>
<a name="7350"><span class="lineNum">    7350 </span>            :    }</a>
<a name="7351"><span class="lineNum">    7351 </span>            : </a>
<a name="7352"><span class="lineNum">    7352 </span>            : </a>
<a name="7353"><span class="lineNum">    7353 </span><span class="lineNoCov">          0 :   SgFunctionDeclaration* SageInterface::findFirstDefiningFunctionDecl(SgScopeStatement* scope)</span></a>
<a name="7354"><span class="lineNum">    7354 </span>            :   {</a>
<a name="7355"><span class="lineNum">    7355 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(scope);</span></a>
<a name="7356"><span class="lineNum">    7356 </span><span class="lineNoCov">          0 :     SgFunctionDeclaration* result = NULL;</span></a>
<a name="7357"><span class="lineNum">    7357 </span><span class="lineNoCov">          0 :     if (scope-&gt;containsOnlyDeclarations())</span></a>
<a name="7358"><span class="lineNum">    7358 </span>            :     {</a>
<a name="7359"><span class="lineNum">    7359 </span><span class="lineNoCov">          0 :       SgDeclarationStatementPtrList declList = scope-&gt;getDeclarationList();</span></a>
<a name="7360"><span class="lineNum">    7360 </span><span class="lineNoCov">          0 :       SgDeclarationStatementPtrList::iterator i=declList.begin();</span></a>
<a name="7361"><span class="lineNum">    7361 </span><span class="lineNoCov">          0 :       while (i!=declList.end())</span></a>
<a name="7362"><span class="lineNum">    7362 </span>            :       {</a>
<a name="7363"><span class="lineNum">    7363 </span><span class="lineNoCov">          0 :         Sg_File_Info * fileInfo = (*i)-&gt;get_file_info();</span></a>
<a name="7364"><span class="lineNum">    7364 </span>            : </a>
<a name="7365"><span class="lineNum">    7365 </span><span class="lineNoCov">          0 :        if ((fileInfo-&gt;isSameFile(scope-&gt;get_file_info()))||</span></a>
<a name="7366"><span class="lineNum">    7366 </span><span class="lineNoCov">          0 :           (fileInfo-&gt;isTransformation()&amp;&amp; fileInfo-&gt;isOutputInCodeGeneration())</span></a>
<a name="7367"><span class="lineNum">    7367 </span>            :         )</a>
<a name="7368"><span class="lineNum">    7368 </span>            :         {</a>
<a name="7369"><span class="lineNum">    7369 </span><span class="lineNoCov">          0 :           SgFunctionDeclaration* func = isSgFunctionDeclaration(*i);</span></a>
<a name="7370"><span class="lineNum">    7370 </span><span class="lineNoCov">          0 :           if (func)</span></a>
<a name="7371"><span class="lineNum">    7371 </span>            :           {</a>
<a name="7372"><span class="lineNum">    7372 </span><span class="lineNoCov">          0 :             if (func-&gt;get_definingDeclaration ()==func)</span></a>
<a name="7373"><span class="lineNum">    7373 </span>            :             {</a>
<a name="7374"><span class="lineNum">    7374 </span>            :             //cout&lt;&lt;&quot;debug, first defining func decl is:&quot;&lt;&lt;(*i)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="7375"><span class="lineNum">    7375 </span>            :             result=func;</a>
<a name="7376"><span class="lineNum">    7376 </span>            :             break;</a>
<a name="7377"><span class="lineNum">    7377 </span>            :             }</a>
<a name="7378"><span class="lineNum">    7378 </span>            :           }</a>
<a name="7379"><span class="lineNum">    7379 </span>            :         }</a>
<a name="7380"><span class="lineNum">    7380 </span><span class="lineNoCov">          0 :         i++;</span></a>
<a name="7381"><span class="lineNum">    7381 </span>            :       }//end while</a>
<a name="7382"><span class="lineNum">    7382 </span>            :     } else</a>
<a name="7383"><span class="lineNum">    7383 </span>            :     {</a>
<a name="7384"><span class="lineNum">    7384 </span><span class="lineNoCov">          0 :       SgStatementPtrList stmtList = scope-&gt;getStatementList();</span></a>
<a name="7385"><span class="lineNum">    7385 </span><span class="lineNoCov">          0 :       SgStatementPtrList::iterator i=stmtList.begin();</span></a>
<a name="7386"><span class="lineNum">    7386 </span><span class="lineNoCov">          0 :       while (i!=stmtList.end())</span></a>
<a name="7387"><span class="lineNum">    7387 </span>            :       {</a>
<a name="7388"><span class="lineNum">    7388 </span><span class="lineNoCov">          0 :         Sg_File_Info * fileInfo = (*i)-&gt;get_file_info();</span></a>
<a name="7389"><span class="lineNum">    7389 </span><span class="lineNoCov">          0 :         if ( (fileInfo-&gt;isSameFile(scope-&gt;get_file_info()))||</span></a>
<a name="7390"><span class="lineNum">    7390 </span><span class="lineNoCov">          0 :              (fileInfo-&gt;isTransformation()&amp;&amp; fileInfo-&gt;isOutputInCodeGeneration())</span></a>
<a name="7391"><span class="lineNum">    7391 </span>            :             )</a>
<a name="7392"><span class="lineNum">    7392 </span>            :          {</a>
<a name="7393"><span class="lineNum">    7393 </span><span class="lineNoCov">          0 :           SgFunctionDeclaration* func = isSgFunctionDeclaration(*i);</span></a>
<a name="7394"><span class="lineNum">    7394 </span><span class="lineNoCov">          0 :           if (func)</span></a>
<a name="7395"><span class="lineNum">    7395 </span>            :           {</a>
<a name="7396"><span class="lineNum">    7396 </span><span class="lineNoCov">          0 :             if (func-&gt;get_definingDeclaration ()==func)</span></a>
<a name="7397"><span class="lineNum">    7397 </span>            :             {</a>
<a name="7398"><span class="lineNum">    7398 </span>            :             //cout&lt;&lt;&quot;debug, first defining func decl is:&quot;&lt;&lt;(*i)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="7399"><span class="lineNum">    7399 </span>            :             result=func;</a>
<a name="7400"><span class="lineNum">    7400 </span>            :             break;</a>
<a name="7401"><span class="lineNum">    7401 </span>            :             }// if defining</a>
<a name="7402"><span class="lineNum">    7402 </span>            :           } // if func</a>
<a name="7403"><span class="lineNum">    7403 </span>            :          }// if fileInof</a>
<a name="7404"><span class="lineNum">    7404 </span><span class="lineNoCov">          0 :         i++;</span></a>
<a name="7405"><span class="lineNum">    7405 </span>            :       }//while</a>
<a name="7406"><span class="lineNum">    7406 </span>            :     } // end if</a>
<a name="7407"><span class="lineNum">    7407 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="7408"><span class="lineNum">    7408 </span>            :   }</a>
<a name="7409"><span class="lineNum">    7409 </span>            : </a>
<a name="7410"><span class="lineNum">    7410 </span>            : </a>
<a name="7411"><span class="lineNum">    7411 </span><span class="lineCov">     409202 : bool SageInterface::isMain(const SgNode* n)</span></a>
<a name="7412"><span class="lineNum">    7412 </span>            : {</a>
<a name="7413"><span class="lineNum">    7413 </span><span class="lineCov">     409202 :    bool result = false;</span></a>
<a name="7414"><span class="lineNum">    7414 </span>            :    // Liao 1/5/2010, handle Fortran main entry: SgProgramHeaderStatement</a>
<a name="7415"><span class="lineNum">    7415 </span><span class="lineCov">     409202 :    if (SageInterface::is_Fortran_language()) {</span></a>
<a name="7416"><span class="lineNum">    7416 </span><span class="lineCov">         10 :       if (isSgProgramHeaderStatement(n)) {</span></a>
<a name="7417"><span class="lineNum">    7417 </span><span class="lineCov">          2 :          result = true;</span></a>
<a name="7418"><span class="lineNum">    7418 </span>            :       }</a>
<a name="7419"><span class="lineNum">    7419 </span>            :    }</a>
<a name="7420"><span class="lineNum">    7420 </span>            :    else {</a>
<a name="7421"><span class="lineNum">    7421 </span><span class="lineCov">     409192 :       if (isSgFunctionDeclaration(n) != nullptr) {</span></a>
<a name="7422"><span class="lineNum">    7422 </span><span class="lineCov">      66506 :          bool either = false;</span></a>
<a name="7423"><span class="lineNum">    7423 </span><span class="lineCov">      66506 :          const SgStatement* stmnt = isSgStatement(n);</span></a>
<a name="7424"><span class="lineNum">    7424 </span><span class="lineCov">      66506 :          ROSE_ASSERT(stmnt != nullptr);</span></a>
<a name="7425"><span class="lineNum">    7425 </span><span class="lineCov">      66506 :          if (isSgGlobal(stmnt-&gt;get_scope())) {</span></a>
<a name="7426"><span class="lineNum">    7426 </span><span class="lineCov">      57440 :             either = true;</span></a>
<a name="7427"><span class="lineNum">    7427 </span>            :          }</a>
<a name="7428"><span class="lineNum">    7428 </span><span class="lineCov">      57440 :          if (either) {</span></a>
<a name="7429"><span class="lineNum">    7429 </span><span class="lineCov">      57440 :             const SgFunctionDeclaration* funcDefn = isSgFunctionDeclaration(n);</span></a>
<a name="7430"><span class="lineNum">    7430 </span><span class="lineCov">      57440 :             ROSE_ASSERT(funcDefn != nullptr);</span></a>
<a name="7431"><span class="lineNum">    7431 </span><span class="lineCov">      57440 :             if (funcDefn-&gt;get_name() == &quot;main&quot;) {</span></a>
<a name="7432"><span class="lineNum">    7432 </span><span class="lineCov">         16 :                result = true;</span></a>
<a name="7433"><span class="lineNum">    7433 </span>            :             }</a>
<a name="7434"><span class="lineNum">    7434 </span>            :          }</a>
<a name="7435"><span class="lineNum">    7435 </span>            :       }</a>
<a name="7436"><span class="lineNum">    7436 </span>            :    }</a>
<a name="7437"><span class="lineNum">    7437 </span><span class="lineCov">     409202 :    return result;</span></a>
<a name="7438"><span class="lineNum">    7438 </span>            : }</a>
<a name="7439"><span class="lineNum">    7439 </span>            : </a>
<a name="7440"><span class="lineNum">    7440 </span>            : // Originally from ompTranslator.C</a>
<a name="7441"><span class="lineNum">    7441 </span>            : // DQ (1/6/2007): The correct qualified name for &quot;main&quot; is &quot;::main&quot;, at least in C++.</a>
<a name="7442"><span class="lineNum">    7442 </span>            : // however for C is should be &quot;main&quot;.  Our name qualification is not language specific,</a>
<a name="7443"><span class="lineNum">    7443 </span>            : // however, for C is makes no sense to as for the qualified name, so the name we</a>
<a name="7444"><span class="lineNum">    7444 </span>            : // want to search for could be language specific.  The test code test2007_07.C</a>
<a name="7445"><span class="lineNum">    7445 </span>            : // demonstrates that the function &quot;main&quot; can exist in both classes (as member functions)</a>
<a name="7446"><span class="lineNum">    7446 </span>            : // and in namespaces (as more meaningfully qualified names).  Because of this C++</a>
<a name="7447"><span class="lineNum">    7447 </span>            : // would have to qualify the global main function as &quot;::main&quot;, I think.</a>
<a name="7448"><span class="lineNum">    7448 </span>            : </a>
<a name="7449"><span class="lineNum">    7449 </span>            : // Revised by Jeremiah,</a>
<a name="7450"><span class="lineNum">    7450 </span>            : // Added check to see if the scope is global: Liao</a>
<a name="7451"><span class="lineNum">    7451 </span><span class="lineCov">     727384 : SgFunctionDeclaration* SageInterface::findMain(SgNode* n) {</span></a>
<a name="7452"><span class="lineNum">    7452 </span><span class="lineCov">     727384 :   if (!n) return 0;</span></a>
<a name="7453"><span class="lineNum">    7453 </span><span class="lineCov">     409202 :   if (isMain(n))</span></a>
<a name="7454"><span class="lineNum">    7454 </span>            :   {</a>
<a name="7455"><span class="lineNum">    7455 </span><span class="lineCov">         18 :     return isSgFunctionDeclaration(n);</span></a>
<a name="7456"><span class="lineNum">    7456 </span>            :   }</a>
<a name="7457"><span class="lineNum">    7457 </span><span class="lineCov">    1136570 :   vector&lt;SgNode*&gt; children = n-&gt;get_traversalSuccessorContainer();</span></a>
<a name="7458"><span class="lineNum">    7458 </span><span class="lineCov">    1136480 :   for (vector&lt;SgNode*&gt;::const_iterator i = children.begin();</span></a>
<a name="7459"><span class="lineNum">    7459 </span><span class="lineCov">    1136480 :   i != children.end(); ++i) {</span></a>
<a name="7460"><span class="lineNum">    7460 </span>            : </a>
<a name="7461"><span class="lineNum">    7461 </span><span class="lineCov">     727366 :     SgFunctionDeclaration* mainDecl = findMain(*i);</span></a>
<a name="7462"><span class="lineNum">    7462 </span><span class="lineCov">     727366 :     if (mainDecl)</span></a>
<a name="7463"><span class="lineNum">    7463 </span><span class="lineCov">         72 :       if (mainDecl-&gt;get_definingDeclaration() == mainDecl) // skip non-defining main() declaration, Liao 8/27/2010</span></a>
<a name="7464"><span class="lineNum">    7464 </span><span class="lineCov">         72 :       return mainDecl;</span></a>
<a name="7465"><span class="lineNum">    7465 </span>            :   }</a>
<a name="7466"><span class="lineNum">    7466 </span>            :   return 0;</a>
<a name="7467"><span class="lineNum">    7467 </span>            : }</a>
<a name="7468"><span class="lineNum">    7468 </span>            : </a>
<a name="7469"><span class="lineNum">    7469 </span>            : //! iterate through the statement within a scope, find the last declaration statement (if any) after which</a>
<a name="7470"><span class="lineNum">    7470 </span>            : //  another declaration statement can be inserted.</a>
<a name="7471"><span class="lineNum">    7471 </span>            : // This is useful to find a safe place to insert a declaration statement with special requirements about where it can be inserted.</a>
<a name="7472"><span class="lineNum">    7472 </span>            : // e.g. a variable declaration statement should not be inserted before IMPLICIT none in Fortran</a>
<a name="7473"><span class="lineNum">    7473 </span>            : // If it returns NULL, a declaration statement should be able to be prepended to the scope</a>
<a name="7474"><span class="lineNum">    7474 </span><span class="lineCov">          5 : SgStatement* SageInterface::findLastDeclarationStatement(SgScopeStatement * scope, bool includePragma/* = false */ )</span></a>
<a name="7475"><span class="lineNum">    7475 </span>            : {</a>
<a name="7476"><span class="lineNum">    7476 </span><span class="lineCov">          5 :   SgStatement* rt = NULL;</span></a>
<a name="7477"><span class="lineNum">    7477 </span><span class="lineCov">          5 :   ROSE_ASSERT (scope != NULL);</span></a>
<a name="7478"><span class="lineNum">    7478 </span>            : </a>
<a name="7479"><span class="lineNum">    7479 </span><span class="lineCov">          5 :   SgStatementPtrList stmt_list = scope-&gt;generateStatementList ();</span></a>
<a name="7480"><span class="lineNum">    7480 </span>            : </a>
<a name="7481"><span class="lineNum">    7481 </span><span class="lineCov">         30 :   for (size_t i = 0; i&lt;stmt_list.size(); i++)</span></a>
<a name="7482"><span class="lineNum">    7482 </span>            :   {</a>
<a name="7483"><span class="lineNum">    7483 </span><span class="lineCov">         25 :     SgStatement* cur_stmt = stmt_list[i];</span></a>
<a name="7484"><span class="lineNum">    7484 </span>            :     // We should exclude pragma decl. We don't want to insert things after pragmas.</a>
<a name="7485"><span class="lineNum">    7485 </span><span class="lineCov">         25 :     if (isSgDeclarationStatement(cur_stmt))</span></a>
<a name="7486"><span class="lineNum">    7486 </span>            :     {</a>
<a name="7487"><span class="lineNum">    7487 </span><span class="lineCov">         15 :       if (isSgPragmaDeclaration (cur_stmt))</span></a>
<a name="7488"><span class="lineNum">    7488 </span>            :       {</a>
<a name="7489"><span class="lineNum">    7489 </span><span class="lineNoCov">          0 :         if (includePragma)</span></a>
<a name="7490"><span class="lineNum">    7490 </span><span class="lineNoCov">          0 :           rt = cur_stmt;</span></a>
<a name="7491"><span class="lineNum">    7491 </span>            :       }</a>
<a name="7492"><span class="lineNum">    7492 </span>            :       else</a>
<a name="7493"><span class="lineNum">    7493 </span>            :         rt = cur_stmt;</a>
<a name="7494"><span class="lineNum">    7494 </span>            :     }</a>
<a name="7495"><span class="lineNum">    7495 </span>            :     //if (isSgImplicitStatement(cur_stmt)) || isSgFortranIncludeLine(cur_stmt) || isSgDeclarationStatement</a>
<a name="7496"><span class="lineNum">    7496 </span>            :   }</a>
<a name="7497"><span class="lineNum">    7497 </span>            : </a>
<a name="7498"><span class="lineNum">    7498 </span><span class="lineCov">         10 :   return rt;</span></a>
<a name="7499"><span class="lineNum">    7499 </span>            : }</a>
<a name="7500"><span class="lineNum">    7500 </span>            : </a>
<a name="7501"><span class="lineNum">    7501 </span><span class="lineCov">      35899 : SgNode * SageInterface::deepCopyNode (const SgNode* n)</span></a>
<a name="7502"><span class="lineNum">    7502 </span>            : {</a>
<a name="7503"><span class="lineNum">    7503 </span><span class="lineCov">      35899 :   SgNode* rt = NULL;</span></a>
<a name="7504"><span class="lineNum">    7504 </span><span class="lineCov">      35899 :   SgTreeCopy g_treeCopy; // should use a copy object each time of usage!</span></a>
<a name="7505"><span class="lineNum">    7505 </span><span class="lineCov">      35899 :   if (n!= NULL)</span></a>
<a name="7506"><span class="lineNum">    7506 </span>            :   {</a>
<a name="7507"><span class="lineNum">    7507 </span><span class="lineCov">      35899 :      rt = n-&gt;copy (g_treeCopy);</span></a>
<a name="7508"><span class="lineNum">    7508 </span><span class="lineCov">      35899 :      SageInterface::setSourcePositionForTransformation (rt);</span></a>
<a name="7509"><span class="lineNum">    7509 </span>            :   }</a>
<a name="7510"><span class="lineNum">    7510 </span>            :   //  return n ? n-&gt;copy (g_treeCopy) : 0;</a>
<a name="7511"><span class="lineNum">    7511 </span><span class="lineCov">      35899 :   return rt;</span></a>
<a name="7512"><span class="lineNum">    7512 </span>            : }</a>
<a name="7513"><span class="lineNum">    7513 </span>            : </a>
<a name="7514"><span class="lineNum">    7514 </span>            : // by Jeremiah</a>
<a name="7515"><span class="lineNum">    7515 </span>            : // Return bool for C++ code, and int for C code</a>
<a name="7516"><span class="lineNum">    7516 </span><span class="lineNoCov">          0 : SgType* SageInterface::getBoolType(SgNode* n) {</span></a>
<a name="7517"><span class="lineNum">    7517 </span><span class="lineNoCov">          0 :   bool isC = TransformationSupport::getSourceFile(n)-&gt;get_outputLanguage() == SgFile::e_C_language;</span></a>
<a name="7518"><span class="lineNum">    7518 </span><span class="lineNoCov">          0 :   if (isC) {</span></a>
<a name="7519"><span class="lineNum">    7519 </span><span class="lineNoCov">          0 :     return SgTypeInt::createType();</span></a>
<a name="7520"><span class="lineNum">    7520 </span>            :   } else {</a>
<a name="7521"><span class="lineNum">    7521 </span><span class="lineNoCov">          0 :     return SgTypeBool::createType();</span></a>
<a name="7522"><span class="lineNum">    7522 </span>            :   }</a>
<a name="7523"><span class="lineNum">    7523 </span>            : }</a>
<a name="7524"><span class="lineNum">    7524 </span>            : </a>
<a name="7525"><span class="lineNum">    7525 </span>            : #if 1</a>
<a name="7526"><span class="lineNum">    7526 </span>            : // Change continue statements in a given block of code to gotos to a label</a>
<a name="7527"><span class="lineNum">    7527 </span><span class="lineNoCov">          0 : void SageInterface::changeContinuesToGotos(SgStatement* stmt, SgLabelStatement* label)</span></a>
<a name="7528"><span class="lineNum">    7528 </span>            :    {</a>
<a name="7529"><span class="lineNum">    7529 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="7530"><span class="lineNum">    7530 </span><span class="lineNoCov">          0 :      std::vector&lt;SgContinueStmt*&gt; continues = SageInterface::findContinueStmts(stmt);</span></a>
<a name="7531"><span class="lineNum">    7531 </span><span class="lineNoCov">          0 :      for (std::vector&lt;SgContinueStmt*&gt;::iterator i = continues.begin(); i != continues.end(); ++i)</span></a>
<a name="7532"><span class="lineNum">    7532 </span>            :         {</a>
<a name="7533"><span class="lineNum">    7533 </span><span class="lineNoCov">          0 :           SgGotoStatement* gotoStatement = SageBuilder::buildGotoStatement(label);</span></a>
<a name="7534"><span class="lineNum">    7534 </span>            :        // printf (&quot;Building gotoStatement #1 = %p \n&quot;,gotoStatement);</a>
<a name="7535"><span class="lineNum">    7535 </span>            : #ifndef _MSC_VER</a>
<a name="7536"><span class="lineNum">    7536 </span><span class="lineNoCov">          0 :           LowLevelRewrite::replace(*i, make_unit_list( gotoStatement ) );</span></a>
<a name="7537"><span class="lineNum">    7537 </span>            : #else</a>
<a name="7538"><span class="lineNum">    7538 </span>            :           ROSE_ABORT();</a>
<a name="7539"><span class="lineNum">    7539 </span>            : #endif</a>
<a name="7540"><span class="lineNum">    7540 </span>            :         }</a>
<a name="7541"><span class="lineNum">    7541 </span>            : #else</a>
<a name="7542"><span class="lineNum">    7542 </span>            :           printf (&quot;Not supported in mode: ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT (LowLevelRewrite::replace() is unavailable)&quot;);</a>
<a name="7543"><span class="lineNum">    7543 </span>            :           ROSE_ABORT();</a>
<a name="7544"><span class="lineNum">    7544 </span>            : #endif</a>
<a name="7545"><span class="lineNum">    7545 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="7546"><span class="lineNum">    7546 </span>            : </a>
<a name="7547"><span class="lineNum">    7547 </span>            : #define DEBUG_TEMPLATE_ARG_EQUIVALENCE 0</a>
<a name="7548"><span class="lineNum">    7548 </span>            : </a>
<a name="7549"><span class="lineNum">    7549 </span><span class="lineNoCov">          0 : bool SageInterface::templateArgumentEquivalence(SgTemplateArgument * arg1, SgTemplateArgument * arg2)</span></a>
<a name="7550"><span class="lineNum">    7550 </span>            :    {</a>
<a name="7551"><span class="lineNum">    7551 </span><span class="lineNoCov">          0 :      if (arg1 == arg2)</span></a>
<a name="7552"><span class="lineNum">    7552 </span>            :         {</a>
<a name="7553"><span class="lineNum">    7553 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7554"><span class="lineNum">    7554 </span>            :           printf (&quot;In templateArgumentEquivalence(): same pointer to template argument: returning true \n&quot;);</a>
<a name="7555"><span class="lineNum">    7555 </span>            : #endif</a>
<a name="7556"><span class="lineNum">    7556 </span>            :           return true;</a>
<a name="7557"><span class="lineNum">    7557 </span>            :         }</a>
<a name="7558"><span class="lineNum">    7558 </span>            : </a>
<a name="7559"><span class="lineNum">    7559 </span><span class="lineNoCov">          0 :      if (arg1-&gt;get_argumentType() != arg2-&gt;get_argumentType())</span></a>
<a name="7560"><span class="lineNum">    7560 </span>            :         {</a>
<a name="7561"><span class="lineNum">    7561 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7562"><span class="lineNum">    7562 </span>            :           printf (&quot;In templateArgumentEquivalence(): different argumentType(): returning false \n&quot;);</a>
<a name="7563"><span class="lineNum">    7563 </span>            : #endif</a>
<a name="7564"><span class="lineNum">    7564 </span>            :           return false;</a>
<a name="7565"><span class="lineNum">    7565 </span>            :         }</a>
<a name="7566"><span class="lineNum">    7566 </span>            : </a>
<a name="7567"><span class="lineNum">    7567 </span><span class="lineNoCov">          0 :      switch (arg1-&gt;get_argumentType())</span></a>
<a name="7568"><span class="lineNum">    7568 </span>            :         {</a>
<a name="7569"><span class="lineNum">    7569 </span><span class="lineNoCov">          0 :           case SgTemplateArgument::type_argument:</span></a>
<a name="7570"><span class="lineNum">    7570 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7571"><span class="lineNum">    7571 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(arg1-&gt;get_type() != NULL);</span></a>
<a name="7572"><span class="lineNum">    7572 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(arg2-&gt;get_type() != NULL);</span></a>
<a name="7573"><span class="lineNum">    7573 </span>            : </a>
<a name="7574"><span class="lineNum">    7574 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7575"><span class="lineNum">    7575 </span>            :                printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::type_argument: checking for the same type: arg1-&gt;get_type() = %p = %s arg2-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="7576"><span class="lineNum">    7576 </span>            :                     arg1-&gt;get_type(),arg1-&gt;get_type()-&gt;class_name().c_str(),</a>
<a name="7577"><span class="lineNum">    7577 </span>            :                     arg2-&gt;get_type(),arg2-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="7578"><span class="lineNum">    7578 </span>            : #endif</a>
<a name="7579"><span class="lineNum">    7579 </span>            :             // DQ (5/19/2016): Rewrote to support debugging.</a>
<a name="7580"><span class="lineNum">    7580 </span>            :             // return arg1-&gt;get_type() == arg2-&gt;get_type();</a>
<a name="7581"><span class="lineNum">    7581 </span><span class="lineNoCov">          0 :                if (arg1-&gt;get_type() == arg2-&gt;get_type())</span></a>
<a name="7582"><span class="lineNum">    7582 </span>            :                   {</a>
<a name="7583"><span class="lineNum">    7583 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7584"><span class="lineNum">    7584 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::type_argument: checking for the same type: returning true \n&quot;);</a>
<a name="7585"><span class="lineNum">    7585 </span>            : #endif</a>
<a name="7586"><span class="lineNum">    7586 </span>            :                     return true;</a>
<a name="7587"><span class="lineNum">    7587 </span>            :                   }</a>
<a name="7588"><span class="lineNum">    7588 </span>            :                  else</a>
<a name="7589"><span class="lineNum">    7589 </span>            :                   {</a>
<a name="7590"><span class="lineNum">    7590 </span>            :                  // ROSE_ASSERT(!&quot;NIY: non-type template argument comparaison.&quot;); /// \todo</a>
<a name="7591"><span class="lineNum">    7591 </span>            : </a>
<a name="7592"><span class="lineNum">    7592 </span>            :                  // DQ (5/19/2016): Use type equivalence mechanism to handle the case where</a>
<a name="7593"><span class="lineNum">    7593 </span>            :                  // these are different pointers to what might still be the same type.</a>
<a name="7594"><span class="lineNum">    7594 </span>            :                  // return false;</a>
<a name="7595"><span class="lineNum">    7595 </span><span class="lineNoCov">          0 :                     bool typesAreEqual = isEquivalentType(arg1-&gt;get_type(),arg2-&gt;get_type());</span></a>
<a name="7596"><span class="lineNum">    7596 </span>            : </a>
<a name="7597"><span class="lineNum">    7597 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7598"><span class="lineNum">    7598 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::type_argument: checking for the same type: pointers are different: returning typesAreEqual = %s \n&quot;,typesAreEqual ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="7599"><span class="lineNum">    7599 </span>            : #endif</a>
<a name="7600"><span class="lineNum">    7600 </span><span class="lineNoCov">          0 :                     return typesAreEqual;</span></a>
<a name="7601"><span class="lineNum">    7601 </span>            :                   }</a>
<a name="7602"><span class="lineNum">    7602 </span>            :              }</a>
<a name="7603"><span class="lineNum">    7603 </span>            : </a>
<a name="7604"><span class="lineNum">    7604 </span><span class="lineNoCov">          0 :           case SgTemplateArgument::nontype_argument:</span></a>
<a name="7605"><span class="lineNum">    7605 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7606"><span class="lineNum">    7606 </span><span class="lineNoCov">          0 :                SgExpression * expr1 = arg1-&gt;get_expression();</span></a>
<a name="7607"><span class="lineNum">    7607 </span><span class="lineNoCov">          0 :                SgExpression * expr2 = arg2-&gt;get_expression();</span></a>
<a name="7608"><span class="lineNum">    7608 </span><span class="lineNoCov">          0 :                if (expr1 == expr2) {</span></a>
<a name="7609"><span class="lineNum">    7609 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7610"><span class="lineNum">    7610 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::nontype_argument: checking for the same expression: returning true \n&quot;);</a>
<a name="7611"><span class="lineNum">    7611 </span>            : #endif</a>
<a name="7612"><span class="lineNum">    7612 </span>            :                     return true;</a>
<a name="7613"><span class="lineNum">    7613 </span><span class="lineNoCov">          0 :                } else if (expr1-&gt;variantT() == expr2-&gt;variantT() ) {</span></a>
<a name="7614"><span class="lineNum">    7614 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7615"><span class="lineNum">    7615 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::nontype_argument: same variant of expression: %s\n&quot;, expr1-&gt;class_name().c_str());</a>
<a name="7616"><span class="lineNum">    7616 </span>            : #endif</a>
<a name="7617"><span class="lineNum">    7617 </span><span class="lineNoCov">          0 :                     switch (expr1-&gt;variantT()) {</span></a>
<a name="7618"><span class="lineNum">    7618 </span><span class="lineNoCov">          0 :                       case V_SgLongIntVal: {</span></a>
<a name="7619"><span class="lineNum">    7619 </span><span class="lineNoCov">          0 :                         return ((SgLongIntVal *)expr1)-&gt;get_value() == ((SgLongIntVal *)expr2)-&gt;get_value();</span></a>
<a name="7620"><span class="lineNum">    7620 </span>            :                       }</a>
<a name="7621"><span class="lineNum">    7621 </span><span class="lineNoCov">          0 :                       default: {</span></a>
<a name="7622"><span class="lineNum">    7622 </span><span class="lineNoCov">          0 :                         printf (&quot;FATAL: In templateArgumentEquivalence(): case SgTemplateArgument::nontype_argument: expression have the same variant %s but comparison is not NIY!\n&quot;, expr1-&gt;class_name().c_str());</span></a>
<a name="7623"><span class="lineNum">    7623 </span><span class="lineNoCov">          0 :                         ROSE_ABORT();</span></a>
<a name="7624"><span class="lineNum">    7624 </span>            :                       }</a>
<a name="7625"><span class="lineNum">    7625 </span>            :                     }</a>
<a name="7626"><span class="lineNum">    7626 </span>            :                } else {</a>
<a name="7627"><span class="lineNum">    7627 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7628"><span class="lineNum">    7628 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::nontype_argument: different variant of expression: returning false \n&quot;);</a>
<a name="7629"><span class="lineNum">    7629 </span>            : #endif</a>
<a name="7630"><span class="lineNum">    7630 </span>            :                     return false;</a>
<a name="7631"><span class="lineNum">    7631 </span>            :                }</a>
<a name="7632"><span class="lineNum">    7632 </span>            :              }</a>
<a name="7633"><span class="lineNum">    7633 </span>            : </a>
<a name="7634"><span class="lineNum">    7634 </span><span class="lineNoCov">          0 :           case SgTemplateArgument::template_template_argument:</span></a>
<a name="7635"><span class="lineNum">    7635 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7636"><span class="lineNum">    7636 </span><span class="lineNoCov">          0 :                if (arg1-&gt;get_templateDeclaration() == arg2-&gt;get_templateDeclaration())</span></a>
<a name="7637"><span class="lineNum">    7637 </span>            :                   {</a>
<a name="7638"><span class="lineNum">    7638 </span>            : #if DEBUG_TEMPLATE_ARG_EQUIVALENCE</a>
<a name="7639"><span class="lineNum">    7639 </span>            :                     printf (&quot;In templateArgumentEquivalence(): case SgTemplateArgument::template_template_argument: checking for the same templateDeclaration: returning true \n&quot;);</a>
<a name="7640"><span class="lineNum">    7640 </span>            : #endif</a>
<a name="7641"><span class="lineNum">    7641 </span>            :                     return true;</a>
<a name="7642"><span class="lineNum">    7642 </span>            :                   }</a>
<a name="7643"><span class="lineNum">    7643 </span>            :                  else</a>
<a name="7644"><span class="lineNum">    7644 </span>            :                   {</a>
<a name="7645"><span class="lineNum">    7645 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(!&quot;NIY: template template argument comparaison.&quot;); /// \todo</span></a>
<a name="7646"><span class="lineNum">    7646 </span>            :                   }</a>
<a name="7647"><span class="lineNum">    7647 </span>            :              }</a>
<a name="7648"><span class="lineNum">    7648 </span>            : </a>
<a name="7649"><span class="lineNum">    7649 </span><span class="lineNoCov">          0 :           case SgTemplateArgument::argument_undefined:</span></a>
<a name="7650"><span class="lineNum">    7650 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7651"><span class="lineNum">    7651 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(!&quot;Try to compare template arguments of unknown type...&quot;);</span></a>
<a name="7652"><span class="lineNum">    7652 </span>            :              }</a>
<a name="7653"><span class="lineNum">    7653 </span>            : </a>
<a name="7654"><span class="lineNum">    7654 </span>            :        // DQ (7/19/2015): Added missing case:</a>
<a name="7655"><span class="lineNum">    7655 </span><span class="lineNoCov">          0 :           case SgTemplateArgument::start_of_pack_expansion_argument:</span></a>
<a name="7656"><span class="lineNum">    7656 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7657"><span class="lineNum">    7657 </span>            :                // Liao 6/24/2016. Handle the simplest case: both arguments are parameter pack.</a>
<a name="7658"><span class="lineNum">    7658 </span><span class="lineNoCov">          0 :                if (arg2-&gt;get_argumentType() == SgTemplateArgument::start_of_pack_expansion_argument)</span></a>
<a name="7659"><span class="lineNum">    7659 </span>            :                  return true;</a>
<a name="7660"><span class="lineNum">    7660 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(!&quot;Try to compare template arguments of unknown type start_of_pack_expansion_argument&quot;);</span></a>
<a name="7661"><span class="lineNum">    7661 </span>            :              }</a>
<a name="7662"><span class="lineNum">    7662 </span>            : </a>
<a name="7663"><span class="lineNum">    7663 </span>            :        // DQ (7/19/2015): Added missing default case: we always want to ahve a default case to catch errors and missing cases.</a>
<a name="7664"><span class="lineNum">    7664 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="7665"><span class="lineNum">    7665 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="7666"><span class="lineNum">    7666 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default case not handled! \n&quot;);</span></a>
<a name="7667"><span class="lineNum">    7667 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="7668"><span class="lineNum">    7668 </span>            :              }</a>
<a name="7669"><span class="lineNum">    7669 </span>            :         }</a>
<a name="7670"><span class="lineNum">    7670 </span>            : </a>
<a name="7671"><span class="lineNum">    7671 </span>            :      ROSE_ABORT(); // unreachable code</a>
<a name="7672"><span class="lineNum">    7672 </span>            :    }</a>
<a name="7673"><span class="lineNum">    7673 </span>            : </a>
<a name="7674"><span class="lineNum">    7674 </span>            : #define DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE 0</a>
<a name="7675"><span class="lineNum">    7675 </span>            : </a>
<a name="7676"><span class="lineNum">    7676 </span><span class="lineCov">       7084 : bool SageInterface::templateArgumentListEquivalence(const SgTemplateArgumentPtrList &amp; list1, const SgTemplateArgumentPtrList &amp; list2)</span></a>
<a name="7677"><span class="lineNum">    7677 </span>            :    {</a>
<a name="7678"><span class="lineNum">    7678 </span><span class="lineCov">       7084 :      if (list1.size() != list2.size())</span></a>
<a name="7679"><span class="lineNum">    7679 </span>            :         {</a>
<a name="7680"><span class="lineNum">    7680 </span>            : #if DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE</a>
<a name="7681"><span class="lineNum">    7681 </span>            :           printf (&quot;In templateArgumentListEquivalence(): different list sizes: returning false \n&quot;);</a>
<a name="7682"><span class="lineNum">    7682 </span>            :           printf (&quot;   --- list1.size() = %zu \n&quot;,list1.size());</a>
<a name="7683"><span class="lineNum">    7683 </span>            :           printf (&quot;   --- list2.size() = %zu \n&quot;,list2.size());</a>
<a name="7684"><span class="lineNum">    7684 </span>            : #endif</a>
<a name="7685"><span class="lineNum">    7685 </span>            :           return false;</a>
<a name="7686"><span class="lineNum">    7686 </span>            :         }</a>
<a name="7687"><span class="lineNum">    7687 </span>            : </a>
<a name="7688"><span class="lineNum">    7688 </span><span class="lineCov">       7084 :      if (list1 == list2)</span></a>
<a name="7689"><span class="lineNum">    7689 </span>            :         {</a>
<a name="7690"><span class="lineNum">    7690 </span>            : #if DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE</a>
<a name="7691"><span class="lineNum">    7691 </span>            :           printf (&quot;In templateArgumentListEquivalence(): same list using STL equality operator: returning true \n&quot;);</a>
<a name="7692"><span class="lineNum">    7692 </span>            : #endif</a>
<a name="7693"><span class="lineNum">    7693 </span>            :           return true;</a>
<a name="7694"><span class="lineNum">    7694 </span>            :         }</a>
<a name="7695"><span class="lineNum">    7695 </span>            : </a>
<a name="7696"><span class="lineNum">    7696 </span>            :   // for (unsigned i = 0; i &lt; list1.size(); i++)</a>
<a name="7697"><span class="lineNum">    7697 </span><span class="lineNoCov">          0 :      for (size_t i = 0; i &lt; list1.size(); i++)</span></a>
<a name="7698"><span class="lineNum">    7698 </span>            :         {</a>
<a name="7699"><span class="lineNum">    7699 </span>            : #if DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE</a>
<a name="7700"><span class="lineNum">    7700 </span>            :           printf (&quot;In templateArgumentListEquivalence(): calling templateArgumentEquivalence() for i = %zu \n&quot;,i);</a>
<a name="7701"><span class="lineNum">    7701 </span>            : #endif</a>
<a name="7702"><span class="lineNum">    7702 </span>            :        // if (!templateArgumentEquivalence(list1[i], list2[i]))</a>
<a name="7703"><span class="lineNum">    7703 </span><span class="lineNoCov">          0 :           if (templateArgumentEquivalence(list1[i], list2[i]) == false)</span></a>
<a name="7704"><span class="lineNum">    7704 </span>            :              {</a>
<a name="7705"><span class="lineNum">    7705 </span>            : #if DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE</a>
<a name="7706"><span class="lineNum">    7706 </span>            :                printf (&quot;In templateArgumentListEquivalence(): calling templateArgumentEquivalence() for i = %zu --- returned false: returning false \n&quot;,i);</a>
<a name="7707"><span class="lineNum">    7707 </span>            : #endif</a>
<a name="7708"><span class="lineNum">    7708 </span>            :                return false;</a>
<a name="7709"><span class="lineNum">    7709 </span>            :              }</a>
<a name="7710"><span class="lineNum">    7710 </span>            :         }</a>
<a name="7711"><span class="lineNum">    7711 </span>            : </a>
<a name="7712"><span class="lineNum">    7712 </span>            : #if DEBUG_TEMPLATE_ARG_LIST_EQUIVALENCE</a>
<a name="7713"><span class="lineNum">    7713 </span>            :      printf (&quot;In templateArgumentListEquivalence(): reached base of function: returning true \n&quot;);</a>
<a name="7714"><span class="lineNum">    7714 </span>            : #endif</a>
<a name="7715"><span class="lineNum">    7715 </span>            : </a>
<a name="7716"><span class="lineNum">    7716 </span>            :      return true;</a>
<a name="7717"><span class="lineNum">    7717 </span>            :    }</a>
<a name="7718"><span class="lineNum">    7718 </span>            : </a>
<a name="7719"><span class="lineNum">    7719 </span>            : // Add a step statement to the end of a loop body</a>
<a name="7720"><span class="lineNum">    7720 </span>            : // Add a new label to the end of the loop, with the step statement after</a>
<a name="7721"><span class="lineNum">    7721 </span>            : // it; then change all continue statements in the old loop body into</a>
<a name="7722"><span class="lineNum">    7722 </span>            : // jumps to the label</a>
<a name="7723"><span class="lineNum">    7723 </span>            : //</a>
<a name="7724"><span class="lineNum">    7724 </span>            : // For example:</a>
<a name="7725"><span class="lineNum">    7725 </span>            : // while (a &lt; 5) {if (a &lt; -3) continue;} (adding &quot;a++&quot; to end) becomes</a>
<a name="7726"><span class="lineNum">    7726 </span>            : // while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;}</a>
<a name="7727"><span class="lineNum">    7727 </span><span class="lineNoCov">          0 : void SageInterface::addStepToLoopBody(SgScopeStatement* loopStmt, SgStatement* step) {</span></a>
<a name="7728"><span class="lineNum">    7728 </span><span class="lineNoCov">          0 :   using namespace SageBuilder;</span></a>
<a name="7729"><span class="lineNum">    7729 </span><span class="lineNoCov">          0 :   SgScopeStatement* proc = SageInterface::getEnclosingProcedure(loopStmt);</span></a>
<a name="7730"><span class="lineNum">    7730 </span><span class="lineNoCov">          0 :   SgStatement* old_body = SageInterface::getLoopBody(loopStmt);</span></a>
<a name="7731"><span class="lineNum">    7731 </span><span class="lineNoCov">          0 :   SgBasicBlock* new_body = buildBasicBlock();</span></a>
<a name="7732"><span class="lineNum">    7732 </span>            : // printf (&quot;Building IR node #13: new SgBasicBlock = %p \n&quot;,new_body);</a>
<a name="7733"><span class="lineNum">    7733 </span><span class="lineNoCov">          0 :   SgName labelname = &quot;rose_label__&quot;;</span></a>
<a name="7734"><span class="lineNum">    7734 </span><span class="lineNoCov">          0 :   labelname &lt;&lt; ++gensym_counter;</span></a>
<a name="7735"><span class="lineNum">    7735 </span><span class="lineNoCov">          0 :   SgLabelStatement* labelstmt = buildLabelStatement(labelname,</span></a>
<a name="7736"><span class="lineNum">    7736 </span><span class="lineNoCov">          0 : buildBasicBlock(), proc);</span></a>
<a name="7737"><span class="lineNum">    7737 </span><span class="lineNoCov">          0 :   changeContinuesToGotos(old_body, labelstmt);</span></a>
<a name="7738"><span class="lineNum">    7738 </span><span class="lineNoCov">          0 :   appendStatement(old_body, new_body);</span></a>
<a name="7739"><span class="lineNum">    7739 </span><span class="lineNoCov">          0 :   appendStatement(labelstmt, new_body);</span></a>
<a name="7740"><span class="lineNum">    7740 </span><span class="lineNoCov">          0 :   appendStatement(step, new_body);</span></a>
<a name="7741"><span class="lineNum">    7741 </span><span class="lineNoCov">          0 :   SageInterface::setLoopBody(loopStmt, new_body);</span></a>
<a name="7742"><span class="lineNum">    7742 </span><span class="lineNoCov">          0 : }</span></a>
<a name="7743"><span class="lineNum">    7743 </span>            : </a>
<a name="7744"><span class="lineNum">    7744 </span>            : </a>
<a name="7745"><span class="lineNum">    7745 </span><span class="lineNoCov">          0 : void SageInterface::moveForStatementIncrementIntoBody(SgForStatement* f) {</span></a>
<a name="7746"><span class="lineNum">    7746 </span><span class="lineNoCov">          0 :   if (isSgNullExpression(f-&gt;get_increment())) return;</span></a>
<a name="7747"><span class="lineNum">    7747 </span><span class="lineNoCov">          0 :   SgExprStatement* incrStmt = SageBuilder::buildExprStatement(f-&gt;get_increment());</span></a>
<a name="7748"><span class="lineNum">    7748 </span><span class="lineNoCov">          0 :   f-&gt;get_increment()-&gt;set_parent(incrStmt);</span></a>
<a name="7749"><span class="lineNum">    7749 </span><span class="lineNoCov">          0 :   SageInterface::addStepToLoopBody(f, incrStmt);</span></a>
<a name="7750"><span class="lineNum">    7750 </span><span class="lineNoCov">          0 :   SgNullExpression* ne = SageBuilder::buildNullExpression();</span></a>
<a name="7751"><span class="lineNum">    7751 </span><span class="lineNoCov">          0 :   f-&gt;set_increment(ne);</span></a>
<a name="7752"><span class="lineNum">    7752 </span><span class="lineNoCov">          0 :   ne-&gt;set_parent(f);</span></a>
<a name="7753"><span class="lineNum">    7753 </span>            : }</a>
<a name="7754"><span class="lineNum">    7754 </span>            : </a>
<a name="7755"><span class="lineNum">    7755 </span>            : static</a>
<a name="7756"><span class="lineNum">    7756 </span><span class="lineNoCov">          0 : bool hasEmptyCondition(SgForStatement* f)</span></a>
<a name="7757"><span class="lineNum">    7757 </span>            : {</a>
<a name="7758"><span class="lineNum">    7758 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(f);</span></a>
<a name="7759"><span class="lineNum">    7759 </span>            : </a>
<a name="7760"><span class="lineNum">    7760 </span><span class="lineNoCov">          0 :   SgStatement* condstmt = f-&gt;get_test();</span></a>
<a name="7761"><span class="lineNum">    7761 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(condstmt);</span></a>
<a name="7762"><span class="lineNum">    7762 </span>            : </a>
<a name="7763"><span class="lineNum">    7763 </span><span class="lineNoCov">          0 :   if (isSgNullStatement(condstmt)) return true;</span></a>
<a name="7764"><span class="lineNum">    7764 </span>            : </a>
<a name="7765"><span class="lineNum">    7765 </span><span class="lineNoCov">          0 :   SgExprStatement* exprStmt = isSgExprStatement(condstmt);</span></a>
<a name="7766"><span class="lineNum">    7766 </span>            : </a>
<a name="7767"><span class="lineNum">    7767 </span><span class="lineNoCov">          0 :   return isSgNullExpression(exprStmt-&gt;get_expression());</span></a>
<a name="7768"><span class="lineNum">    7768 </span>            : }</a>
<a name="7769"><span class="lineNum">    7769 </span>            : </a>
<a name="7770"><span class="lineNum">    7770 </span><span class="lineNoCov">          0 : void SageInterface::convertForToWhile(SgForStatement* f) {</span></a>
<a name="7771"><span class="lineNum">    7771 </span><span class="lineNoCov">          0 :   moveForStatementIncrementIntoBody(f);</span></a>
<a name="7772"><span class="lineNum">    7772 </span><span class="lineNoCov">          0 :   SgBasicBlock* bb = SageBuilder::buildBasicBlock();</span></a>
<a name="7773"><span class="lineNum">    7773 </span><span class="lineNoCov">          0 :   SgForInitStatement* inits = f-&gt;get_for_init_stmt();</span></a>
<a name="7774"><span class="lineNum">    7774 </span><span class="lineNoCov">          0 :   SgStatementPtrList&amp; bbStmts = bb-&gt;get_statements();</span></a>
<a name="7775"><span class="lineNum">    7775 </span><span class="lineNoCov">          0 :   SgStatementPtrList&amp; initStmts = inits-&gt;get_init_stmt();</span></a>
<a name="7776"><span class="lineNum">    7776 </span><span class="lineNoCov">          0 :   bbStmts = initStmts;</span></a>
<a name="7777"><span class="lineNum">    7777 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; bbStmts.size(); ++i) {</span></a>
<a name="7778"><span class="lineNum">    7778 </span><span class="lineNoCov">          0 :     bbStmts[i]-&gt;set_parent(bb);</span></a>
<a name="7779"><span class="lineNum">    7779 </span>            :   }</a>
<a name="7780"><span class="lineNum">    7780 </span>            : </a>
<a name="7781"><span class="lineNum">    7781 </span><span class="lineNoCov">          0 :   const bool testIsNull = hasEmptyCondition(f);</span></a>
<a name="7782"><span class="lineNum">    7782 </span><span class="lineNoCov">          0 :   SgStatement* test = testIsNull ? SageBuilder::buildExprStatement(SageBuilder::buildBoolValExp(true))</span></a>
<a name="7783"><span class="lineNum">    7783 </span><span class="lineNoCov">          0 :                                  : f-&gt;get_test();</span></a>
<a name="7784"><span class="lineNum">    7784 </span><span class="lineNoCov">          0 :   SgWhileStmt* ws = SageBuilder::buildWhileStmt(test, f-&gt;get_loop_body());</span></a>
<a name="7785"><span class="lineNum">    7785 </span>            : </a>
<a name="7786"><span class="lineNum">    7786 </span><span class="lineNoCov">          0 :   appendStatement(ws, bb);</span></a>
<a name="7787"><span class="lineNum">    7787 </span><span class="lineNoCov">          0 :   isSgStatement(f-&gt;get_parent())-&gt;replace_statement(f, bb);</span></a>
<a name="7788"><span class="lineNum">    7788 </span><span class="lineNoCov">          0 : }</span></a>
<a name="7789"><span class="lineNum">    7789 </span>            : </a>
<a name="7790"><span class="lineNum">    7790 </span><span class="lineNoCov">          0 : void SageInterface::convertAllForsToWhiles(SgNode* top) {</span></a>
<a name="7791"><span class="lineNum">    7791 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt; fors = NodeQuery::querySubTree(top,</span></a>
<a name="7792"><span class="lineNum">    7792 </span><span class="lineNoCov">          0 : V_SgForStatement);</span></a>
<a name="7793"><span class="lineNum">    7793 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; fors.size(); ++i) {</span></a>
<a name="7794"><span class="lineNum">    7794 </span><span class="lineNoCov">          0 :     convertForToWhile(isSgForStatement(fors[i]));</span></a>
<a name="7795"><span class="lineNum">    7795 </span>            :   }</a>
<a name="7796"><span class="lineNum">    7796 </span><span class="lineNoCov">          0 : }</span></a>
<a name="7797"><span class="lineNum">    7797 </span>            : </a>
<a name="7798"><span class="lineNum">    7798 </span><span class="lineNoCov">          0 :   vector&lt;SgGotoStatement*&gt; SageInterface::findGotoStmts(SgStatement* scope, SgLabelStatement* l) {</span></a>
<a name="7799"><span class="lineNum">    7799 </span>            :  // DQ (9/25/2007): Moved from std::list to std::vector uniformally in ROSE.</a>
<a name="7800"><span class="lineNum">    7800 </span>            :  // But we still need the copy since the return type is IR node specific.</a>
<a name="7801"><span class="lineNum">    7801 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt; allGotos = NodeQuery::querySubTree(scope, V_SgGotoStatement);</span></a>
<a name="7802"><span class="lineNum">    7802 </span>            : </a>
<a name="7803"><span class="lineNum">    7803 </span><span class="lineNoCov">          0 :     vector&lt;SgGotoStatement*&gt; result;</span></a>
<a name="7804"><span class="lineNum">    7804 </span><span class="lineNoCov">          0 :     for (Rose_STL_Container&lt;SgNode*&gt;::const_iterator i = allGotos.begin(); i != allGotos.end(); ++i) {</span></a>
<a name="7805"><span class="lineNum">    7805 </span><span class="lineNoCov">          0 :       if (isSgGotoStatement(*i)-&gt;get_label() == l) {</span></a>
<a name="7806"><span class="lineNum">    7806 </span><span class="lineNoCov">          0 :         result.push_back(isSgGotoStatement(*i));</span></a>
<a name="7807"><span class="lineNum">    7807 </span>            :       }</a>
<a name="7808"><span class="lineNum">    7808 </span>            :     }</a>
<a name="7809"><span class="lineNum">    7809 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="7810"><span class="lineNum">    7810 </span>            :   }</a>
<a name="7811"><span class="lineNum">    7811 </span>            : </a>
<a name="7812"><span class="lineNum">    7812 </span>            : #if 0 // Liao 5/21/2010. This is a bad function in terms of performance</a>
<a name="7813"><span class="lineNum">    7813 </span>            :       // vectors are created/destroyed multiple times</a>
<a name="7814"><span class="lineNum">    7814 </span>            :   vector&lt;SgReturnStmt*&gt; SageInterface::findReturnStmts(SgStatement* scope) {</a>
<a name="7815"><span class="lineNum">    7815 </span>            :  // DQ (9/25/2007): Moved from std::list to std::vector uniformally in ROSE.</a>
<a name="7816"><span class="lineNum">    7816 </span>            :  // But we still need the copy since the return type is IR node specific.</a>
<a name="7817"><span class="lineNum">    7817 </span>            :     Rose_STL_Container&lt;SgNode*&gt; returns = NodeQuery::querySubTree(scope, V_SgReturnStmt);</a>
<a name="7818"><span class="lineNum">    7818 </span>            : </a>
<a name="7819"><span class="lineNum">    7819 </span>            :     vector&lt;SgReturnStmt*&gt; result;</a>
<a name="7820"><span class="lineNum">    7820 </span>            :     for (Rose_STL_Container&lt;SgNode*&gt;::const_iterator i = returns.begin(); i != returns.end(); ++i) {</a>
<a name="7821"><span class="lineNum">    7821 </span>            :       result.push_back(isSgReturnStmt(*i));</a>
<a name="7822"><span class="lineNum">    7822 </span>            :     }</a>
<a name="7823"><span class="lineNum">    7823 </span>            :     return result;</a>
<a name="7824"><span class="lineNum">    7824 </span>            :   }</a>
<a name="7825"><span class="lineNum">    7825 </span>            : </a>
<a name="7826"><span class="lineNum">    7826 </span>            : #endif</a>
<a name="7827"><span class="lineNum">    7827 </span><span class="lineNoCov">          0 : static  void getSwitchCasesHelper(SgStatement* top, vector&lt;SgStatement*&gt;&amp; result) {</span></a>
<a name="7828"><span class="lineNum">    7828 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (top);</span></a>
<a name="7829"><span class="lineNum">    7829 </span><span class="lineNoCov">          0 :     if (isSgSwitchStatement(top)) return; // Don't descend into nested switches</span></a>
<a name="7830"><span class="lineNum">    7830 </span><span class="lineNoCov">          0 :     if (isSgCaseOptionStmt(top) || isSgDefaultOptionStmt(top)) {</span></a>
<a name="7831"><span class="lineNum">    7831 </span><span class="lineNoCov">          0 :       result.push_back(top);</span></a>
<a name="7832"><span class="lineNum">    7832 </span>            :     }</a>
<a name="7833"><span class="lineNum">    7833 </span><span class="lineNoCov">          0 :     vector&lt;SgNode*&gt; children = top-&gt;get_traversalSuccessorContainer();</span></a>
<a name="7834"><span class="lineNum">    7834 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; children.size(); ++i) {</span></a>
<a name="7835"><span class="lineNum">    7835 </span><span class="lineNoCov">          0 :       if (isSgStatement(children[i])) {</span></a>
<a name="7836"><span class="lineNum">    7836 </span><span class="lineNoCov">          0 :         getSwitchCasesHelper(isSgStatement(children[i]), result);</span></a>
<a name="7837"><span class="lineNum">    7837 </span>            :       }</a>
<a name="7838"><span class="lineNum">    7838 </span>            :     }</a>
<a name="7839"><span class="lineNum">    7839 </span>            :   }</a>
<a name="7840"><span class="lineNum">    7840 </span>            : </a>
<a name="7841"><span class="lineNum">    7841 </span><span class="lineNoCov">          0 :   vector&lt;SgStatement*&gt; SageInterface::getSwitchCases(SgSwitchStatement* sw) {</span></a>
<a name="7842"><span class="lineNum">    7842 </span><span class="lineNoCov">          0 :     vector&lt;SgStatement*&gt; result;</span></a>
<a name="7843"><span class="lineNum">    7843 </span><span class="lineNoCov">          0 :     getSwitchCasesHelper(sw-&gt;get_body(), result);</span></a>
<a name="7844"><span class="lineNum">    7844 </span><span class="lineNoCov">          0 :     return result;</span></a>
<a name="7845"><span class="lineNum">    7845 </span>            :   }</a>
<a name="7846"><span class="lineNum">    7846 </span>            : </a>
<a name="7847"><span class="lineNum">    7847 </span>            : </a>
<a name="7848"><span class="lineNum">    7848 </span>            : #endif</a>
<a name="7849"><span class="lineNum">    7849 </span>            : </a>
<a name="7850"><span class="lineNum">    7850 </span><span class="lineCov">       3120 : AbstractHandle::abstract_handle* SageInterface::buildAbstractHandle(SgNode* n)</span></a>
<a name="7851"><span class="lineNum">    7851 </span>            : {</a>
<a name="7852"><span class="lineNum">    7852 </span><span class="lineCov">       3120 :   return AbstractHandle::buildAbstractHandle(n);</span></a>
<a name="7853"><span class="lineNum">    7853 </span>            : </a>
<a name="7854"><span class="lineNum">    7854 </span>            : }</a>
<a name="7855"><span class="lineNum">    7855 </span>            : //! Get the enclosing scope from a node n</a>
<a name="7856"><span class="lineNum">    7856 </span><span class="lineCov">       8090 : SgScopeStatement* SageInterface::getEnclosingScope(SgNode* n, const bool includingSelf/* =false*/)</span></a>
<a name="7857"><span class="lineNum">    7857 </span>            : {</a>
<a name="7858"><span class="lineNum">    7858 </span><span class="lineCov">       8090 :   SgScopeStatement* result = getScope (n);</span></a>
<a name="7859"><span class="lineNum">    7859 </span><span class="lineCov">       8090 :   if (result == n)</span></a>
<a name="7860"><span class="lineNum">    7860 </span>            :   {</a>
<a name="7861"><span class="lineNum">    7861 </span><span class="lineCov">       5136 :     if (!includingSelf)</span></a>
<a name="7862"><span class="lineNum">    7862 </span><span class="lineCov">       5136 :       result = getScope(n-&gt;get_parent());</span></a>
<a name="7863"><span class="lineNum">    7863 </span>            :   }</a>
<a name="7864"><span class="lineNum">    7864 </span><span class="lineCov">       8090 :   return result;</span></a>
<a name="7865"><span class="lineNum">    7865 </span>            : }</a>
<a name="7866"><span class="lineNum">    7866 </span>            : </a>
<a name="7867"><span class="lineNum">    7867 </span>            : // from transformationSupport.C</a>
<a name="7868"><span class="lineNum">    7868 </span>            : SgScopeStatement*</a>
<a name="7869"><span class="lineNum">    7869 </span><span class="lineCov">      28778 : SageInterface::getScope( const SgNode* astNode )</span></a>
<a name="7870"><span class="lineNum">    7870 </span>            :    {</a>
<a name="7871"><span class="lineNum">    7871 </span>            : </a>
<a name="7872"><span class="lineNum">    7872 </span>            :    // Case 1: directly call get_scope() for some types of nodes</a>
<a name="7873"><span class="lineNum">    7873 </span><span class="lineCov">      28778 :     if (const SgSymbol* symbol = isSgSymbol(astNode))</span></a>
<a name="7874"><span class="lineNum">    7874 </span><span class="lineNoCov">          0 :         return symbol-&gt;get_scope();</span></a>
<a name="7875"><span class="lineNum">    7875 </span><span class="lineCov">      28778 :     else if (const SgInitializedName* initName = isSgInitializedName(astNode))</span></a>
<a name="7876"><span class="lineNum">    7876 </span><span class="lineCov">        289 :         return initName-&gt;get_scope();</span></a>
<a name="7877"><span class="lineNum">    7877 </span><span class="lineCov">      28489 :     else if (const SgTemplateArgument* tempArg = isSgTemplateArgument(astNode))</span></a>
<a name="7878"><span class="lineNum">    7878 </span><span class="lineNoCov">          0 :         return tempArg-&gt;get_scope();</span></a>
<a name="7879"><span class="lineNum">    7879 </span><span class="lineCov">      28489 :     else if (const SgQualifiedName* qualifiedName = isSgQualifiedName(astNode))</span></a>
<a name="7880"><span class="lineNum">    7880 </span><span class="lineNoCov">          0 :         return qualifiedName-&gt;get_scope();</span></a>
<a name="7881"><span class="lineNum">    7881 </span>            : </a>
<a name="7882"><span class="lineNum">    7882 </span>            :     // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)</a>
<a name="7883"><span class="lineNum">    7883 </span>            :     const SgNode* parentNode = astNode;</a>
<a name="7884"><span class="lineNum">    7884 </span><span class="lineCov">      52285 :     while (!isSgScopeStatement(parentNode))</span></a>
<a name="7885"><span class="lineNum">    7885 </span>            :     {</a>
<a name="7886"><span class="lineNum">    7886 </span>            :         //George Vulov (11/29/2010)</a>
<a name="7887"><span class="lineNum">    7887 </span>            :         //Function parameter lists are siblings of SgFunctionDefinition, so just going up to parents</a>
<a name="7888"><span class="lineNum">    7888 </span>            :         //produces SgGlobal.</a>
<a name="7889"><span class="lineNum">    7889 </span><span class="lineCov">      23932 :         if (isSgFunctionParameterList(parentNode) || isSgCtorInitializerList(parentNode))</span></a>
<a name="7890"><span class="lineNum">    7890 </span>            :         {</a>
<a name="7891"><span class="lineNum">    7891 </span><span class="lineCov">        410 :             const SgFunctionDeclaration* funcDeclaration = isSgFunctionDeclaration(parentNode-&gt;get_parent());</span></a>
<a name="7892"><span class="lineNum">    7892 </span><span class="lineCov">        410 :             ROSE_ASSERT(funcDeclaration != NULL);</span></a>
<a name="7893"><span class="lineNum">    7893 </span><span class="lineCov">        410 :             funcDeclaration = isSgFunctionDeclaration(funcDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="7894"><span class="lineNum">    7894 </span><span class="lineCov">        410 :             if (funcDeclaration != NULL)</span></a>
<a name="7895"><span class="lineNum">    7895 </span>            :             {</a>
<a name="7896"><span class="lineNum">    7896 </span><span class="lineCov">        136 :                 return funcDeclaration-&gt;get_definition();</span></a>
<a name="7897"><span class="lineNum">    7897 </span>            :             }</a>
<a name="7898"><span class="lineNum">    7898 </span>            :         }</a>
<a name="7899"><span class="lineNum">    7899 </span>            : </a>
<a name="7900"><span class="lineNum">    7900 </span><span class="lineCov">      23796 :         parentNode = parentNode-&gt;get_parent();</span></a>
<a name="7901"><span class="lineNum">    7901 </span><span class="lineCov">      23796 :         if (parentNode == NULL)</span></a>
<a name="7902"><span class="lineNum">    7902 </span>            :         {</a>
<a name="7903"><span class="lineNum">    7903 </span>            :             break;</a>
<a name="7904"><span class="lineNum">    7904 </span>            :         }</a>
<a name="7905"><span class="lineNum">    7905 </span>            :     }</a>
<a name="7906"><span class="lineNum">    7906 </span>            : </a>
<a name="7907"><span class="lineNum">    7907 </span>            :   // Check to see if we made it back to the root (current root is SgProject).</a>
<a name="7908"><span class="lineNum">    7908 </span>            :   // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).</a>
<a name="7909"><span class="lineNum">    7909 </span><span class="lineCov">      28353 :      if ( isSgScopeStatement(parentNode) == NULL &amp;&amp;</span></a>
<a name="7910"><span class="lineNum">    7910 </span><span class="lineCov">      28353 :           dynamic_cast&lt;const SgType*&gt;(parentNode) == NULL &amp;&amp;</span></a>
<a name="7911"><span class="lineNum">    7911 </span><span class="lineNoCov">          0 :           dynamic_cast&lt;const SgSymbol*&gt;(parentNode) == NULL )</span></a>
<a name="7912"><span class="lineNum">    7912 </span>            :         {</a>
<a name="7913"><span class="lineNum">    7913 </span><span class="lineNoCov">          0 :           printf (&quot;Error: In SageInterface::getScope(): could not trace back to SgScopeStatement node \n&quot;);</span></a>
<a name="7914"><span class="lineNum">    7914 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="7915"><span class="lineNum">    7915 </span>            :         }</a>
<a name="7916"><span class="lineNum">    7916 </span>            :        else</a>
<a name="7917"><span class="lineNum">    7917 </span>            :         {</a>
<a name="7918"><span class="lineNum">    7918 </span><span class="lineCov">      28353 :           if ( dynamic_cast&lt;const SgType*&gt;(parentNode) != NULL || dynamic_cast&lt;const SgSymbol*&gt;(parentNode) != NULL )</span></a>
<a name="7919"><span class="lineNum">    7919 </span>            :              {</a>
<a name="7920"><span class="lineNum">    7920 </span><span class="lineNoCov">          0 :                printf (&quot;Error: can't locate an associated SgStatement from astNode = %p = %s parentNode = %p = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),parentNode,parentNode-&gt;class_name().c_str());</span></a>
<a name="7921"><span class="lineNum">    7921 </span><span class="lineNoCov">          0 :                return NULL;</span></a>
<a name="7922"><span class="lineNum">    7922 </span>            :              }</a>
<a name="7923"><span class="lineNum">    7923 </span>            :         }</a>
<a name="7924"><span class="lineNum">    7924 </span>            : </a>
<a name="7925"><span class="lineNum">    7925 </span>            :   // Make sure we have a SgStatement node</a>
<a name="7926"><span class="lineNum">    7926 </span><span class="lineCov">      28353 :      const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);</span></a>
<a name="7927"><span class="lineNum">    7927 </span>            :      //SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);</a>
<a name="7928"><span class="lineNum">    7928 </span><span class="lineCov">      28353 :      ROSE_ASSERT (scopeStatement != NULL);</span></a>
<a name="7929"><span class="lineNum">    7929 </span>            : </a>
<a name="7930"><span class="lineNum">    7930 </span>            :      // ensure the search is inclusive</a>
<a name="7931"><span class="lineNum">    7931 </span><span class="lineCov">      28353 :      if (isSgScopeStatement(astNode))</span></a>
<a name="7932"><span class="lineNum">    7932 </span><span class="lineCov">       7379 :        if (isSgScopeStatement(parentNode))</span></a>
<a name="7933"><span class="lineNum">    7933 </span>            :        {</a>
<a name="7934"><span class="lineNum">    7934 </span><span class="lineCov">       7379 :           ROSE_ASSERT (astNode == parentNode);</span></a>
<a name="7935"><span class="lineNum">    7935 </span>            :        }</a>
<a name="7936"><span class="lineNum">    7936 </span>            : </a>
<a name="7937"><span class="lineNum">    7937 </span>            :    // return scopeStatement;</a>
<a name="7938"><span class="lineNum">    7938 </span>            :      return const_cast&lt;SgScopeStatement*&gt;(scopeStatement);</a>
<a name="7939"><span class="lineNum">    7939 </span>            :    }</a>
<a name="7940"><span class="lineNum">    7940 </span>            : </a>
<a name="7941"><span class="lineNum">    7941 </span>            : </a>
<a name="7942"><span class="lineNum">    7942 </span>            : // from outliner, ASTtools</a>
<a name="7943"><span class="lineNum">    7943 </span>            : // ------------------------------------------------</a>
<a name="7944"><span class="lineNum">    7944 </span>            : </a>
<a name="7945"><span class="lineNum">    7945 </span>            : /*!</a>
<a name="7946"><span class="lineNum">    7946 </span>            :  *  \brief Return an existing variable symbol for the given</a>
<a name="7947"><span class="lineNum">    7947 </span>            :  *  initialized name.</a>
<a name="7948"><span class="lineNum">    7948 </span>            :  *</a>
<a name="7949"><span class="lineNum">    7949 </span>            :  *  This routine checks various scopes in trying to find a suitable</a>
<a name="7950"><span class="lineNum">    7950 </span>            :  *  variable symbol for the given initialized name.</a>
<a name="7951"><span class="lineNum">    7951 </span>            :  */</a>
<a name="7952"><span class="lineNum">    7952 </span>            : static</a>
<a name="7953"><span class="lineNum">    7953 </span>            : const SgVariableSymbol *</a>
<a name="7954"><span class="lineNum">    7954 </span><span class="lineCov">      42475 : getVarSymFromName_const (const SgInitializedName* name)</span></a>
<a name="7955"><span class="lineNum">    7955 </span>            :    {</a>
<a name="7956"><span class="lineNum">    7956 </span><span class="lineCov">      42475 :      SgVariableSymbol* v_sym = NULL;</span></a>
<a name="7957"><span class="lineNum">    7957 </span>            : </a>
<a name="7958"><span class="lineNum">    7958 </span><span class="lineCov">      42475 :      if (name != NULL)</span></a>
<a name="7959"><span class="lineNum">    7959 </span>            :         {</a>
<a name="7960"><span class="lineNum">    7960 </span>            : #if 0</a>
<a name="7961"><span class="lineNum">    7961 </span>            :           printf (&quot;In getVarSymFromName(): name-&gt;get_name() = %s \n&quot;,name-&gt;get_name().str());</a>
<a name="7962"><span class="lineNum">    7962 </span>            : #endif</a>
<a name="7963"><span class="lineNum">    7963 </span><span class="lineCov">      42475 :           SgScopeStatement* scope = name-&gt;get_scope();</span></a>
<a name="7964"><span class="lineNum">    7964 </span><span class="lineCov">      42475 :           ROSE_ASSERT (scope != NULL);</span></a>
<a name="7965"><span class="lineNum">    7965 </span>            : #if 0</a>
<a name="7966"><span class="lineNum">    7966 </span>            :           printf (&quot;In getVarSymFromName(): name-&gt;get_name() = %s scope = %p = %s \n&quot;,name-&gt;get_name().str(),scope,scope-&gt;class_name().c_str());</a>
<a name="7967"><span class="lineNum">    7967 </span>            : #endif</a>
<a name="7968"><span class="lineNum">    7968 </span><span class="lineCov">      42475 :           v_sym = scope-&gt;lookup_var_symbol (name-&gt;get_name());</span></a>
<a name="7969"><span class="lineNum">    7969 </span>            : </a>
<a name="7970"><span class="lineNum">    7970 </span><span class="lineCov">      42475 :           if (!v_sym) // E.g., might be part of an 'extern' declaration.</span></a>
<a name="7971"><span class="lineNum">    7971 </span>            :             {</a>
<a name="7972"><span class="lineNum">    7972 </span>            :            // Try the declaration's scope.</a>
<a name="7973"><span class="lineNum">    7973 </span><span class="lineNoCov">          0 :               SgDeclarationStatement* decl = name-&gt;get_declaration ();</span></a>
<a name="7974"><span class="lineNum">    7974 </span><span class="lineNoCov">          0 :               ROSE_ASSERT (decl);</span></a>
<a name="7975"><span class="lineNum">    7975 </span>            : </a>
<a name="7976"><span class="lineNum">    7976 </span><span class="lineNoCov">          0 :               SgScopeStatement* decl_scope = decl-&gt;get_scope ();</span></a>
<a name="7977"><span class="lineNum">    7977 </span><span class="lineNoCov">          0 :               if (decl_scope != NULL)</span></a>
<a name="7978"><span class="lineNum">    7978 </span><span class="lineNoCov">          0 :                    v_sym = decl_scope-&gt;lookup_var_symbol (name-&gt;get_name());</span></a>
<a name="7979"><span class="lineNum">    7979 </span>            : </a>
<a name="7980"><span class="lineNum">    7980 </span><span class="lineNoCov">          0 :               if (!v_sym)</span></a>
<a name="7981"><span class="lineNum">    7981 </span><span class="lineNoCov">          0 :                    cerr &lt;&lt; &quot;\t\t*** WARNING: Can't seem to find a symbol for '&quot;</span></a>
<a name="7982"><span class="lineNum">    7982 </span><span class="lineNoCov">          0 :                         &lt;&lt; name-&gt;get_name ().str ()</span></a>
<a name="7983"><span class="lineNum">    7983 </span><span class="lineNoCov">          0 :                         &lt;&lt; &quot;' ***&quot; &lt;&lt; endl;</span></a>
<a name="7984"><span class="lineNum">    7984 </span>            :              }</a>
<a name="7985"><span class="lineNum">    7985 </span>            :         }</a>
<a name="7986"><span class="lineNum">    7986 </span>            : </a>
<a name="7987"><span class="lineNum">    7987 </span><span class="lineCov">      42475 :      return v_sym;</span></a>
<a name="7988"><span class="lineNum">    7988 </span>            :    }</a>
<a name="7989"><span class="lineNum">    7989 </span>            : </a>
<a name="7990"><span class="lineNum">    7990 </span>            : #if 0</a>
<a name="7991"><span class="lineNum">    7991 </span>            : /*!</a>
<a name="7992"><span class="lineNum">    7992 </span>            :  *  \brief Return an existing variable symbol for the given</a>
<a name="7993"><span class="lineNum">    7993 </span>            :  *  initialized name.</a>
<a name="7994"><span class="lineNum">    7994 </span>            :  *</a>
<a name="7995"><span class="lineNum">    7995 </span>            :  *  This routine checks various scopes in trying to find a suitable</a>
<a name="7996"><span class="lineNum">    7996 </span>            :  *  variable symbol for the given initialized name.</a>
<a name="7997"><span class="lineNum">    7997 </span>            :  */</a>
<a name="7998"><span class="lineNum">    7998 </span>            : static</a>
<a name="7999"><span class="lineNum">    7999 </span>            : SgVariableSymbol *</a>
<a name="8000"><span class="lineNum">    8000 </span>            : getVarSymFromName (SgInitializedName* name)</a>
<a name="8001"><span class="lineNum">    8001 </span>            : {</a>
<a name="8002"><span class="lineNum">    8002 </span>            :   const SgVariableSymbol* v_sym = getVarSymFromName_const (name);</a>
<a name="8003"><span class="lineNum">    8003 </span>            :   return const_cast&lt;SgVariableSymbol *&gt; (v_sym);</a>
<a name="8004"><span class="lineNum">    8004 </span>            : }</a>
<a name="8005"><span class="lineNum">    8005 </span>            : #endif</a>
<a name="8006"><span class="lineNum">    8006 </span>            : /*!</a>
<a name="8007"><span class="lineNum">    8007 </span>            :  *  \brief Returns the SgVariableSymbol associated with an SgVarRefExp</a>
<a name="8008"><span class="lineNum">    8008 </span>            :  *  or SgInitializedName, or 0 if none.</a>
<a name="8009"><span class="lineNum">    8009 </span>            :  */</a>
<a name="8010"><span class="lineNum">    8010 </span>            : static</a>
<a name="8011"><span class="lineNum">    8011 </span>            : const SgVariableSymbol *</a>
<a name="8012"><span class="lineNum">    8012 </span><span class="lineCov">      42475 : getVarSym_const (const SgNode* n)</span></a>
<a name="8013"><span class="lineNum">    8013 </span>            : {</a>
<a name="8014"><span class="lineNum">    8014 </span><span class="lineCov">      42475 :   const SgVariableSymbol* v_sym = 0;</span></a>
<a name="8015"><span class="lineNum">    8015 </span><span class="lineCov">      42475 :   switch (n-&gt;variantT ())</span></a>
<a name="8016"><span class="lineNum">    8016 </span>            :     {</a>
<a name="8017"><span class="lineNum">    8017 </span><span class="lineNoCov">          0 :     case V_SgVarRefExp:</span></a>
<a name="8018"><span class="lineNum">    8018 </span><span class="lineNoCov">          0 :       v_sym = isSgVarRefExp (n)-&gt;get_symbol ();</span></a>
<a name="8019"><span class="lineNum">    8019 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="8020"><span class="lineNum">    8020 </span><span class="lineCov">      42475 :     case V_SgInitializedName:</span></a>
<a name="8021"><span class="lineNum">    8021 </span><span class="lineCov">      42475 :       v_sym = getVarSymFromName_const (isSgInitializedName (n));</span></a>
<a name="8022"><span class="lineNum">    8022 </span><span class="lineCov">      42475 :       break;</span></a>
<a name="8023"><span class="lineNum">    8023 </span>            :     default:</a>
<a name="8024"><span class="lineNum">    8024 </span>            :       break;</a>
<a name="8025"><span class="lineNum">    8025 </span>            :     }</a>
<a name="8026"><span class="lineNum">    8026 </span><span class="lineCov">      42475 :   return v_sym;</span></a>
<a name="8027"><span class="lineNum">    8027 </span>            : }</a>
<a name="8028"><span class="lineNum">    8028 </span>            : </a>
<a name="8029"><span class="lineNum">    8029 </span>            : #if 0</a>
<a name="8030"><span class="lineNum">    8030 </span>            : /*!</a>
<a name="8031"><span class="lineNum">    8031 </span>            :  *  \brief Returns the SgVariableSymbol associated with an SgVarRefExp</a>
<a name="8032"><span class="lineNum">    8032 </span>            :  *  or SgInitializedName, or 0 if none.</a>
<a name="8033"><span class="lineNum">    8033 </span>            :  */</a>
<a name="8034"><span class="lineNum">    8034 </span>            : static</a>
<a name="8035"><span class="lineNum">    8035 </span>            : SgVariableSymbol *</a>
<a name="8036"><span class="lineNum">    8036 </span>            : getVarSym (SgNode* n)</a>
<a name="8037"><span class="lineNum">    8037 </span>            : {</a>
<a name="8038"><span class="lineNum">    8038 </span>            :   const SgVariableSymbol* v_sym = getVarSym_const (n);</a>
<a name="8039"><span class="lineNum">    8039 </span>            :   return const_cast&lt;SgVariableSymbol *&gt; (v_sym);</a>
<a name="8040"><span class="lineNum">    8040 </span>            : }</a>
<a name="8041"><span class="lineNum">    8041 </span>            : #endif</a>
<a name="8042"><span class="lineNum">    8042 </span>            : </a>
<a name="8043"><span class="lineNum">    8043 </span>            : static</a>
<a name="8044"><span class="lineNum">    8044 </span>            : const SgVariableSymbol *</a>
<a name="8045"><span class="lineNum">    8045 </span><span class="lineCov">      42475 : getFirstVarSym_const (const SgVariableDeclaration* decl)</span></a>
<a name="8046"><span class="lineNum">    8046 </span>            : {</a>
<a name="8047"><span class="lineNum">    8047 </span><span class="lineCov">      42475 :   if (!decl) return 0;</span></a>
<a name="8048"><span class="lineNum">    8048 </span><span class="lineCov">      42475 :   const SgInitializedNamePtrList&amp; names = decl-&gt;get_variables ();</span></a>
<a name="8049"><span class="lineNum">    8049 </span><span class="lineCov">      42475 :   if (names.begin () != names.end ())</span></a>
<a name="8050"><span class="lineNum">    8050 </span>            :     {</a>
<a name="8051"><span class="lineNum">    8051 </span><span class="lineCov">      42475 :       const SgInitializedName* name = *(names.begin ());</span></a>
<a name="8052"><span class="lineNum">    8052 </span><span class="lineCov">      42475 :       return getVarSym_const (name);</span></a>
<a name="8053"><span class="lineNum">    8053 </span>            :     }</a>
<a name="8054"><span class="lineNum">    8054 </span>            :   else</a>
<a name="8055"><span class="lineNum">    8055 </span>            :     return 0;</a>
<a name="8056"><span class="lineNum">    8056 </span>            : }</a>
<a name="8057"><span class="lineNum">    8057 </span>            : </a>
<a name="8058"><span class="lineNum">    8058 </span>            : SgVariableSymbol *</a>
<a name="8059"><span class="lineNum">    8059 </span><span class="lineCov">      42475 : SageInterface::getFirstVarSym (SgVariableDeclaration* decl)</span></a>
<a name="8060"><span class="lineNum">    8060 </span>            : {</a>
<a name="8061"><span class="lineNum">    8061 </span><span class="lineCov">      42475 :   const SgVariableSymbol* sym = getFirstVarSym_const (decl);</span></a>
<a name="8062"><span class="lineNum">    8062 </span><span class="lineCov">      42475 :   return const_cast&lt;SgVariableSymbol *&gt; (sym);</span></a>
<a name="8063"><span class="lineNum">    8063 </span>            : }</a>
<a name="8064"><span class="lineNum">    8064 </span>            : </a>
<a name="8065"><span class="lineNum">    8065 </span>            : </a>
<a name="8066"><span class="lineNum">    8066 </span>            : SgInitializedName*</a>
<a name="8067"><span class="lineNum">    8067 </span><span class="lineCov">     171635 : SageInterface::getFirstInitializedName (SgVariableDeclaration* decl)</span></a>
<a name="8068"><span class="lineNum">    8068 </span>            : {</a>
<a name="8069"><span class="lineNum">    8069 </span><span class="lineCov">     171635 :   ROSE_ASSERT(decl);</span></a>
<a name="8070"><span class="lineNum">    8070 </span><span class="lineCov">     171635 :   SgInitializedNamePtrList&amp; names = decl-&gt;get_variables ();</span></a>
<a name="8071"><span class="lineNum">    8071 </span><span class="lineCov">     171635 :   if (names.begin () != names.end ())</span></a>
<a name="8072"><span class="lineNum">    8072 </span><span class="lineCov">     171635 :     return *(names.begin ());</span></a>
<a name="8073"><span class="lineNum">    8073 </span>            :   else</a>
<a name="8074"><span class="lineNum">    8074 </span>            :     return NULL;</a>
<a name="8075"><span class="lineNum">    8075 </span>            : }</a>
<a name="8076"><span class="lineNum">    8076 </span>            : </a>
<a name="8077"><span class="lineNum">    8077 </span>            : </a>
<a name="8078"><span class="lineNum">    8078 </span><span class="lineCov">         60 : static void findBreakStmtsHelper(SgStatement* code, const std::string&amp; fortranLabel, bool inOutermostBody, vector&lt;SgBreakStmt*&gt;&amp; breakStmts) {</span></a>
<a name="8079"><span class="lineNum">    8079 </span><span class="lineCov">         60 :   if (isSgWhileStmt(code) || isSgDoWhileStmt(code) || isSgForStatement(code) || isSgSwitchStatement(code)) {</span></a>
<a name="8080"><span class="lineNum">    8080 </span><span class="lineNoCov">          0 :     if (fortranLabel == &quot;&quot;) {</span></a>
<a name="8081"><span class="lineNum">    8081 </span>            :       // Outermost loop only</a>
<a name="8082"><span class="lineNum">    8082 </span><span class="lineNoCov">          0 :       return;</span></a>
<a name="8083"><span class="lineNum">    8083 </span>            :     } else {</a>
<a name="8084"><span class="lineNum">    8084 </span>            :       // Set this for query on children</a>
<a name="8085"><span class="lineNum">    8085 </span>            :       inOutermostBody = false;</a>
<a name="8086"><span class="lineNum">    8086 </span>            :     }</a>
<a name="8087"><span class="lineNum">    8087 </span>            :   }</a>
<a name="8088"><span class="lineNum">    8088 </span><span class="lineCov">         60 :   if (isSgBreakStmt(code)) {</span></a>
<a name="8089"><span class="lineNum">    8089 </span><span class="lineNoCov">          0 :     SgBreakStmt* bs = isSgBreakStmt(code);</span></a>
<a name="8090"><span class="lineNum">    8090 </span><span class="lineNoCov">          0 :     bool breakMatchesThisConstruct = false;</span></a>
<a name="8091"><span class="lineNum">    8091 </span><span class="lineNoCov">          0 :     if (bs-&gt;get_do_string_label() == &quot;&quot;) {</span></a>
<a name="8092"><span class="lineNum">    8092 </span>            :       // Break matches closest construct</a>
<a name="8093"><span class="lineNum">    8093 </span>            :       breakMatchesThisConstruct = inOutermostBody;</a>
<a name="8094"><span class="lineNum">    8094 </span>            :     } else {</a>
<a name="8095"><span class="lineNum">    8095 </span><span class="lineNoCov">          0 :       breakMatchesThisConstruct = (fortranLabel == bs-&gt;get_do_string_label());</span></a>
<a name="8096"><span class="lineNum">    8096 </span>            :     }</a>
<a name="8097"><span class="lineNum">    8097 </span><span class="lineNoCov">          0 :     if (breakMatchesThisConstruct) {</span></a>
<a name="8098"><span class="lineNum">    8098 </span><span class="lineNoCov">          0 :       breakStmts.push_back(bs);</span></a>
<a name="8099"><span class="lineNum">    8099 </span>            :     }</a>
<a name="8100"><span class="lineNum">    8100 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="8101"><span class="lineNum">    8101 </span>            :   }</a>
<a name="8102"><span class="lineNum">    8102 </span><span class="lineCov">        120 :   vector&lt;SgNode*&gt; children = code-&gt;get_traversalSuccessorContainer();</span></a>
<a name="8103"><span class="lineNum">    8103 </span><span class="lineCov">        132 :   for (unsigned int i = 0; i &lt; children.size(); ++i) {</span></a>
<a name="8104"><span class="lineNum">    8104 </span><span class="lineCov">         72 :     if (isSgStatement(children[i])) {</span></a>
<a name="8105"><span class="lineNum">    8105 </span><span class="lineCov">         36 :       findBreakStmtsHelper(isSgStatement(children[i]), fortranLabel, inOutermostBody, breakStmts);</span></a>
<a name="8106"><span class="lineNum">    8106 </span>            :     }</a>
<a name="8107"><span class="lineNum">    8107 </span>            :   }</a>
<a name="8108"><span class="lineNum">    8108 </span>            : }</a>
<a name="8109"><span class="lineNum">    8109 </span>            : </a>
<a name="8110"><span class="lineNum">    8110 </span><span class="lineCov">         24 : vector&lt;SgBreakStmt*&gt; SageInterface::findBreakStmts(SgStatement* code, const std::string&amp; fortranLabel) {</span></a>
<a name="8111"><span class="lineNum">    8111 </span>            :   // Run this on the body of a loop or switch, because it stops at any</a>
<a name="8112"><span class="lineNum">    8112 </span>            :   // construct which defines a new scope for break statements</a>
<a name="8113"><span class="lineNum">    8113 </span><span class="lineCov">         24 :   vector&lt;SgBreakStmt*&gt; result;</span></a>
<a name="8114"><span class="lineNum">    8114 </span><span class="lineCov">         24 :   findBreakStmtsHelper(code, fortranLabel, true, result);</span></a>
<a name="8115"><span class="lineNum">    8115 </span><span class="lineCov">         24 :   return result;</span></a>
<a name="8116"><span class="lineNum">    8116 </span>            : }</a>
<a name="8117"><span class="lineNum">    8117 </span>            : </a>
<a name="8118"><span class="lineNum">    8118 </span>            : </a>
<a name="8119"><span class="lineNum">    8119 </span><span class="lineCov">         68 : static void findContinueStmtsHelper(SgStatement* code, const std::string&amp; fortranLabel, bool inOutermostBody, vector&lt;SgContinueStmt*&gt;&amp; continueStmts) {</span></a>
<a name="8120"><span class="lineNum">    8120 </span><span class="lineCov">         68 :   if (isSgWhileStmt(code) || isSgDoWhileStmt(code) || isSgForStatement(code)) {</span></a>
<a name="8121"><span class="lineNum">    8121 </span><span class="lineNoCov">          0 :     if (fortranLabel == &quot;&quot;) {</span></a>
<a name="8122"><span class="lineNum">    8122 </span>            :       // Outermost loop only</a>
<a name="8123"><span class="lineNum">    8123 </span><span class="lineNoCov">          0 :       return;</span></a>
<a name="8124"><span class="lineNum">    8124 </span>            :     } else {</a>
<a name="8125"><span class="lineNum">    8125 </span>            :       // Set this for query on children</a>
<a name="8126"><span class="lineNum">    8126 </span>            :       inOutermostBody = false;</a>
<a name="8127"><span class="lineNum">    8127 </span>            :     }</a>
<a name="8128"><span class="lineNum">    8128 </span>            :   }</a>
<a name="8129"><span class="lineNum">    8129 </span><span class="lineCov">         68 :   if (isSgContinueStmt(code)) {</span></a>
<a name="8130"><span class="lineNum">    8130 </span><span class="lineNoCov">          0 :     SgContinueStmt* cs = isSgContinueStmt(code);</span></a>
<a name="8131"><span class="lineNum">    8131 </span><span class="lineNoCov">          0 :     bool continueMatchesThisConstruct = false;</span></a>
<a name="8132"><span class="lineNum">    8132 </span><span class="lineNoCov">          0 :     if (cs-&gt;get_do_string_label() == &quot;&quot;) {</span></a>
<a name="8133"><span class="lineNum">    8133 </span>            :       // Continue matches closest construct</a>
<a name="8134"><span class="lineNum">    8134 </span>            :       continueMatchesThisConstruct = inOutermostBody;</a>
<a name="8135"><span class="lineNum">    8135 </span>            :     } else {</a>
<a name="8136"><span class="lineNum">    8136 </span><span class="lineNoCov">          0 :       continueMatchesThisConstruct = (fortranLabel == cs-&gt;get_do_string_label());</span></a>
<a name="8137"><span class="lineNum">    8137 </span>            :     }</a>
<a name="8138"><span class="lineNum">    8138 </span><span class="lineNoCov">          0 :     if (continueMatchesThisConstruct) {</span></a>
<a name="8139"><span class="lineNum">    8139 </span><span class="lineNoCov">          0 :       continueStmts.push_back(cs);</span></a>
<a name="8140"><span class="lineNum">    8140 </span>            :     }</a>
<a name="8141"><span class="lineNum">    8141 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="8142"><span class="lineNum">    8142 </span>            :   }</a>
<a name="8143"><span class="lineNum">    8143 </span><span class="lineCov">        136 :   vector&lt;SgNode*&gt; children = code-&gt;get_traversalSuccessorContainer();</span></a>
<a name="8144"><span class="lineNum">    8144 </span><span class="lineCov">        148 :   for (unsigned int i = 0; i &lt; children.size(); ++i) {</span></a>
<a name="8145"><span class="lineNum">    8145 </span><span class="lineCov">         80 :     SgStatement* stmnt = isSgStatement(children[i]);</span></a>
<a name="8146"><span class="lineNum">    8146 </span><span class="lineCov">         80 :     if (stmnt != NULL) {</span></a>
<a name="8147"><span class="lineNum">    8147 </span><span class="lineCov">         40 :       findContinueStmtsHelper(stmnt, fortranLabel, inOutermostBody, continueStmts);</span></a>
<a name="8148"><span class="lineNum">    8148 </span>            :     }</a>
<a name="8149"><span class="lineNum">    8149 </span>            :   }</a>
<a name="8150"><span class="lineNum">    8150 </span>            : }</a>
<a name="8151"><span class="lineNum">    8151 </span>            : </a>
<a name="8152"><span class="lineNum">    8152 </span><span class="lineCov">         28 : vector&lt;SgContinueStmt*&gt; SageInterface::findContinueStmts(SgStatement* code, const std::string&amp; fortranLabel) {</span></a>
<a name="8153"><span class="lineNum">    8153 </span>            :   // Run this on the body of a loop, because it stops at any construct which</a>
<a name="8154"><span class="lineNum">    8154 </span>            :   // defines a new scope for continue statements</a>
<a name="8155"><span class="lineNum">    8155 </span><span class="lineCov">         28 :   vector&lt;SgContinueStmt*&gt; result;</span></a>
<a name="8156"><span class="lineNum">    8156 </span><span class="lineCov">         28 :   findContinueStmtsHelper(code, fortranLabel, true, result);</span></a>
<a name="8157"><span class="lineNum">    8157 </span><span class="lineCov">         28 :   return result;</span></a>
<a name="8158"><span class="lineNum">    8158 </span>            : }</a>
<a name="8159"><span class="lineNum">    8159 </span>            : </a>
<a name="8160"><span class="lineNum">    8160 </span>            : </a>
<a name="8161"><span class="lineNum">    8161 </span>            : // Get the initializer containing an expression if it is within an</a>
<a name="8162"><span class="lineNum">    8162 </span>            : // initializer.</a>
<a name="8163"><span class="lineNum">    8163 </span>            : //  from replaceExpressionWithStatement.C</a>
<a name="8164"><span class="lineNum">    8164 </span><span class="lineNoCov">          0 : SgInitializer* SageInterface::getInitializerOfExpression(SgExpression* n) {</span></a>
<a name="8165"><span class="lineNum">    8165 </span><span class="lineNoCov">          0 :   assert(n);</span></a>
<a name="8166"><span class="lineNum">    8166 </span>            : #if 0</a>
<a name="8167"><span class="lineNum">    8167 </span>            :   std::cout &lt;&lt; &quot;Starting getInitializerOfExpression on 0x&quot; &lt;&lt; std::hex &lt;&lt; (int)n &lt;&lt; &quot;, which has type &quot; &lt;&lt; n-&gt;sage_class_name() &lt;&lt; std::endl;</a>
<a name="8168"><span class="lineNum">    8168 </span>            : #endif</a>
<a name="8169"><span class="lineNum">    8169 </span><span class="lineNoCov">          0 :   while (!isSgInitializer(n)) {</span></a>
<a name="8170"><span class="lineNum">    8170 </span><span class="lineNoCov">          0 :     n = isSgExpression(n-&gt;get_parent());</span></a>
<a name="8171"><span class="lineNum">    8171 </span>            : #if 0</a>
<a name="8172"><span class="lineNum">    8172 </span>            :     std::cout &lt;&lt; &quot;Continuing getInitializerOfExpression on 0x&quot; &lt;&lt; std::hex &lt;&lt; (int)n;</a>
<a name="8173"><span class="lineNum">    8173 </span>            :     if (n) std::cout &lt;&lt; &quot;, which has type &quot; &lt;&lt; n-&gt;sage_class_name();</a>
<a name="8174"><span class="lineNum">    8174 </span>            :     std::cout &lt;&lt; std::endl;</a>
<a name="8175"><span class="lineNum">    8175 </span>            : #endif</a>
<a name="8176"><span class="lineNum">    8176 </span><span class="lineNoCov">          0 :     assert(n);</span></a>
<a name="8177"><span class="lineNum">    8177 </span>            :   }</a>
<a name="8178"><span class="lineNum">    8178 </span><span class="lineNoCov">          0 :   return isSgInitializer(n);</span></a>
<a name="8179"><span class="lineNum">    8179 </span>            : }</a>
<a name="8180"><span class="lineNum">    8180 </span>            : </a>
<a name="8181"><span class="lineNum">    8181 </span>            : #ifndef USE_ROSE</a>
<a name="8182"><span class="lineNum">    8182 </span>            : // Get all symbols used in a given expression</a>
<a name="8183"><span class="lineNum">    8183 </span><span class="lineNoCov">          0 : vector&lt;SgVariableSymbol*&gt; SageInterface::getSymbolsUsedInExpression(SgExpression* expr) {</span></a>
<a name="8184"><span class="lineNum">    8184 </span><span class="lineNoCov">          0 :  class GetSymbolsUsedInExpressionVisitor: public AstSimpleProcessing {</span></a>
<a name="8185"><span class="lineNum">    8185 </span>            :   public:</a>
<a name="8186"><span class="lineNum">    8186 </span>            :   std::vector&lt;SgVariableSymbol*&gt; symbols;</a>
<a name="8187"><span class="lineNum">    8187 </span>            : </a>
<a name="8188"><span class="lineNum">    8188 </span><span class="lineNoCov">          0 :   virtual void visit(SgNode* n) {</span></a>
<a name="8189"><span class="lineNum">    8189 </span><span class="lineNoCov">          0 :     if (isSgVarRefExp(n))</span></a>
<a name="8190"><span class="lineNum">    8190 </span><span class="lineNoCov">          0 :       symbols.push_back(isSgVarRefExp(n)-&gt;get_symbol());</span></a>
<a name="8191"><span class="lineNum">    8191 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="8192"><span class="lineNum">    8192 </span>            :  };</a>
<a name="8193"><span class="lineNum">    8193 </span>            : </a>
<a name="8194"><span class="lineNum">    8194 </span><span class="lineNoCov">          0 :   GetSymbolsUsedInExpressionVisitor vis;</span></a>
<a name="8195"><span class="lineNum">    8195 </span><span class="lineNoCov">          0 :   vis.traverse(expr, preorder);</span></a>
<a name="8196"><span class="lineNum">    8196 </span><span class="lineNoCov">          0 :   return vis.symbols;</span></a>
<a name="8197"><span class="lineNum">    8197 </span>            : }</a>
<a name="8198"><span class="lineNum">    8198 </span>            : #endif</a>
<a name="8199"><span class="lineNum">    8199 </span>            : </a>
<a name="8200"><span class="lineNum">    8200 </span>            : SgSourceFile*</a>
<a name="8201"><span class="lineNum">    8201 </span><span class="lineCov">       2041 : SageInterface::getEnclosingSourceFile(SgNode* n,bool includingSelf) {</span></a>
<a name="8202"><span class="lineNum">    8202 </span><span class="lineCov">       2041 :     return getEnclosingNode&lt;SgSourceFile&gt;(n, includingSelf);</span></a>
<a name="8203"><span class="lineNum">    8203 </span>            : }</a>
<a name="8204"><span class="lineNum">    8204 </span>            : </a>
<a name="8205"><span class="lineNum">    8205 </span>            : </a>
<a name="8206"><span class="lineNum">    8206 </span><span class="lineCov">          4 : SgFunctionDeclaration* SageInterface::findFunctionDeclaration(SgNode* root, std::string name, SgScopeStatement* scope, bool isDefining)</span></a>
<a name="8207"><span class="lineNum">    8207 </span>            : {</a>
<a name="8208"><span class="lineNum">    8208 </span><span class="lineCov">          6 :   return findDeclarationStatement&lt;SgFunctionDeclaration&gt; (root, name, scope, isDefining);</span></a>
<a name="8209"><span class="lineNum">    8209 </span>            : }</a>
<a name="8210"><span class="lineNum">    8210 </span>            : </a>
<a name="8211"><span class="lineNum">    8211 </span>            : </a>
<a name="8212"><span class="lineNum">    8212 </span><span class="lineCov">         37 : SgFunctionDefinition* SageInterface::getEnclosingProcedure(SgNode* n, bool includingSelf)</span></a>
<a name="8213"><span class="lineNum">    8213 </span>            : {</a>
<a name="8214"><span class="lineNum">    8214 </span><span class="lineCov">         37 :   return getEnclosingFunctionDefinition(n,includingSelf);</span></a>
<a name="8215"><span class="lineNum">    8215 </span>            : }</a>
<a name="8216"><span class="lineNum">    8216 </span>            : </a>
<a name="8217"><span class="lineNum">    8217 </span>            : SgFunctionDefinition*</a>
<a name="8218"><span class="lineNum">    8218 </span><span class="lineCov">         70 : SageInterface::getEnclosingFunctionDefinition(SgNode* n,bool includingSelf) {</span></a>
<a name="8219"><span class="lineNum">    8219 </span><span class="lineCov">         70 :     return getEnclosingNode&lt;SgFunctionDefinition&gt;(n, includingSelf);</span></a>
<a name="8220"><span class="lineNum">    8220 </span>            : }</a>
<a name="8221"><span class="lineNum">    8221 </span>            : </a>
<a name="8222"><span class="lineNum">    8222 </span>            : </a>
<a name="8223"><span class="lineNum">    8223 </span>            : SgFunctionDeclaration*</a>
<a name="8224"><span class="lineNum">    8224 </span><span class="lineCov">       2255 : SageInterface::getEnclosingFunctionDeclaration (SgNode * astNode,bool includingSelf) {</span></a>
<a name="8225"><span class="lineNum">    8225 </span><span class="lineCov">       2255 :     return getEnclosingNode&lt;SgFunctionDeclaration&gt;(astNode, includingSelf);</span></a>
<a name="8226"><span class="lineNum">    8226 </span>            : }</a>
<a name="8227"><span class="lineNum">    8227 </span>            : </a>
<a name="8228"><span class="lineNum">    8228 </span>            : // #endif</a>
<a name="8229"><span class="lineNum">    8229 </span>            : </a>
<a name="8230"><span class="lineNum">    8230 </span>            : // #ifndef USE_ROSE</a>
<a name="8231"><span class="lineNum">    8231 </span>            : </a>
<a name="8232"><span class="lineNum">    8232 </span>            : SgGlobal*</a>
<a name="8233"><span class="lineNum">    8233 </span><span class="lineCov">      41453 : SageInterface::getGlobalScope(const SgNode* astNode) {</span></a>
<a name="8234"><span class="lineNum">    8234 </span>            :     // should including itself in this case</a>
<a name="8235"><span class="lineNum">    8235 </span><span class="lineCov">      41453 :     return getEnclosingNode&lt;SgGlobal&gt;(astNode, true /*includingSelf*/);</span></a>
<a name="8236"><span class="lineNum">    8236 </span>            : }</a>
<a name="8237"><span class="lineNum">    8237 </span>            : </a>
<a name="8238"><span class="lineNum">    8238 </span>            : SgClassDefinition*</a>
<a name="8239"><span class="lineNum">    8239 </span><span class="lineCov">       2255 : SageInterface::getEnclosingClassDefinition(SgNode* astNode, const bool includingSelf/* =false*/) {</span></a>
<a name="8240"><span class="lineNum">    8240 </span><span class="lineCov">       2255 :     return getEnclosingNode&lt;SgClassDefinition&gt;(astNode, includingSelf);</span></a>
<a name="8241"><span class="lineNum">    8241 </span>            : }</a>
<a name="8242"><span class="lineNum">    8242 </span>            : </a>
<a name="8243"><span class="lineNum">    8243 </span>            : </a>
<a name="8244"><span class="lineNum">    8244 </span>            : SgClassDeclaration*</a>
<a name="8245"><span class="lineNum">    8245 </span><span class="lineNoCov">          0 : SageInterface::getEnclosingClassDeclaration(SgNode* astNode) {</span></a>
<a name="8246"><span class="lineNum">    8246 </span>            :     // DQ (1/24/2019): This might have to get the SgClassDefinition and then the SgClassDeclaration from that.</a>
<a name="8247"><span class="lineNum">    8247 </span>            :     // I'm having trouble making this work for a member function declared outside of the class definition.</a>
<a name="8248"><span class="lineNum">    8248 </span><span class="lineNoCov">          0 :     return getEnclosingNode&lt;SgClassDeclaration&gt;(astNode, true);</span></a>
<a name="8249"><span class="lineNum">    8249 </span>            : }</a>
<a name="8250"><span class="lineNum">    8250 </span>            : </a>
<a name="8251"><span class="lineNum">    8251 </span>            : SgExprListExp*</a>
<a name="8252"><span class="lineNum">    8252 </span><span class="lineNoCov">          0 : SageInterface::getEnclosingExprListExp(SgNode* astNode, const bool includingSelf/* =false*/) {</span></a>
<a name="8253"><span class="lineNum">    8253 </span><span class="lineNoCov">          0 :     return getEnclosingNode&lt;SgExprListExp&gt;(astNode, includingSelf);</span></a>
<a name="8254"><span class="lineNum">    8254 </span>            : }</a>
<a name="8255"><span class="lineNum">    8255 </span>            : </a>
<a name="8256"><span class="lineNum">    8256 </span>            : bool</a>
<a name="8257"><span class="lineNum">    8257 </span><span class="lineNoCov">          0 : SageInterface::isInSubTree(SgExpression* subtree, SgExpression* exp)</span></a>
<a name="8258"><span class="lineNum">    8258 </span>            :    {</a>
<a name="8259"><span class="lineNum">    8259 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="8260"><span class="lineNum">    8260 </span>            : </a>
<a name="8261"><span class="lineNum">    8261 </span><span class="lineNoCov">          0 :      struct Visitor: public AstSimpleProcessing</span></a>
<a name="8262"><span class="lineNum">    8262 </span>            :         {</a>
<a name="8263"><span class="lineNum">    8263 </span>            :           SgExpression* expression_target;</a>
<a name="8264"><span class="lineNum">    8264 </span>            :           bool in_subtree;</a>
<a name="8265"><span class="lineNum">    8265 </span><span class="lineNoCov">          0 :           virtual void visit(SgNode* n)</span></a>
<a name="8266"><span class="lineNum">    8266 </span>            :              {</a>
<a name="8267"><span class="lineNum">    8267 </span><span class="lineNoCov">          0 :                if (n == expression_target)</span></a>
<a name="8268"><span class="lineNum">    8268 </span>            :                   {</a>
<a name="8269"><span class="lineNum">    8269 </span><span class="lineNoCov">          0 :                     in_subtree = true;</span></a>
<a name="8270"><span class="lineNum">    8270 </span>            :                   }</a>
<a name="8271"><span class="lineNum">    8271 </span><span class="lineNoCov">          0 :              }</span></a>
<a name="8272"><span class="lineNum">    8272 </span>            : </a>
<a name="8273"><span class="lineNum">    8273 </span><span class="lineNoCov">          0 :           Visitor(SgExpression* expr) : expression_target(expr), in_subtree(false) {}</span></a>
<a name="8274"><span class="lineNum">    8274 </span>            :         };</a>
<a name="8275"><span class="lineNum">    8275 </span>            : </a>
<a name="8276"><span class="lineNum">    8276 </span><span class="lineNoCov">          0 :      Visitor traversal(exp);</span></a>
<a name="8277"><span class="lineNum">    8277 </span>            : </a>
<a name="8278"><span class="lineNum">    8278 </span><span class="lineNoCov">          0 :      traversal.traverse(subtree, preorder);</span></a>
<a name="8279"><span class="lineNum">    8279 </span>            : </a>
<a name="8280"><span class="lineNum">    8280 </span><span class="lineNoCov">          0 :      returnValue = traversal.in_subtree;</span></a>
<a name="8281"><span class="lineNum">    8281 </span>            : </a>
<a name="8282"><span class="lineNum">    8282 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="8283"><span class="lineNum">    8283 </span>            :    }</a>
<a name="8284"><span class="lineNum">    8284 </span>            : </a>
<a name="8285"><span class="lineNum">    8285 </span>            : </a>
<a name="8286"><span class="lineNum">    8286 </span>            : SgFunctionDeclaration*</a>
<a name="8287"><span class="lineNum">    8287 </span><span class="lineNoCov">          0 : SageInterface::getFunctionDeclaration ( SgFunctionCallExp* functionCallExp )</span></a>
<a name="8288"><span class="lineNum">    8288 </span>            :    {</a>
<a name="8289"><span class="lineNum">    8289 </span>            :   // DQ (2/7/2019): Added more general function to support extraction of the associated function declaration.</a>
<a name="8290"><span class="lineNum">    8290 </span>            :   // The lower level functions are more robust on the SgFunctionRefExp and SgMemberFunctionRefExp than</a>
<a name="8291"><span class="lineNum">    8291 </span>            :   // when called on the SgFunctionCallExp for example.</a>
<a name="8292"><span class="lineNum">    8292 </span>            : </a>
<a name="8293"><span class="lineNum">    8293 </span>            :   // SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(astNode);</a>
<a name="8294"><span class="lineNum">    8294 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (functionCallExp != NULL);</span></a>
<a name="8295"><span class="lineNum">    8295 </span>            : </a>
<a name="8296"><span class="lineNum">    8296 </span><span class="lineNoCov">          0 :      SgExpression* expression = functionCallExp-&gt;get_function();</span></a>
<a name="8297"><span class="lineNum">    8297 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (expression != NULL);</span></a>
<a name="8298"><span class="lineNum">    8298 </span>            : </a>
<a name="8299"><span class="lineNum">    8299 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* returnDeclaration = NULL;</span></a>
<a name="8300"><span class="lineNum">    8300 </span>            : </a>
<a name="8301"><span class="lineNum">    8301 </span><span class="lineNoCov">          0 :      SgDotExp* dotExp = isSgDotExp(expression);</span></a>
<a name="8302"><span class="lineNum">    8302 </span><span class="lineNoCov">          0 :      if (dotExp != NULL)</span></a>
<a name="8303"><span class="lineNum">    8303 </span>            :         {</a>
<a name="8304"><span class="lineNum">    8304 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (dotExp != NULL);</span></a>
<a name="8305"><span class="lineNum">    8305 </span>            : </a>
<a name="8306"><span class="lineNum">    8306 </span><span class="lineNoCov">          0 :           SgExpression* rhsOperand = dotExp-&gt;get_rhs_operand();</span></a>
<a name="8307"><span class="lineNum">    8307 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (rhsOperand != NULL);</span></a>
<a name="8308"><span class="lineNum">    8308 </span>            : </a>
<a name="8309"><span class="lineNum">    8309 </span><span class="lineNoCov">          0 :           SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(rhsOperand);</span></a>
<a name="8310"><span class="lineNum">    8310 </span>            : </a>
<a name="8311"><span class="lineNum">    8311 </span>            :        // ROSE_ASSERT (memberFunctionRefExp != NULL);</a>
<a name="8312"><span class="lineNum">    8312 </span><span class="lineNoCov">          0 :           if (memberFunctionRefExp != NULL)</span></a>
<a name="8313"><span class="lineNum">    8313 </span>            :              {</a>
<a name="8314"><span class="lineNum">    8314 </span><span class="lineNoCov">          0 :                returnDeclaration = memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration();</span></a>
<a name="8315"><span class="lineNum">    8315 </span>            :              }</a>
<a name="8316"><span class="lineNum">    8316 </span>            :         }</a>
<a name="8317"><span class="lineNum">    8317 </span>            : </a>
<a name="8318"><span class="lineNum">    8318 </span><span class="lineNoCov">          0 :      SgFunctionRefExp* functionReferenceExp = isSgFunctionRefExp(expression);</span></a>
<a name="8319"><span class="lineNum">    8319 </span><span class="lineNoCov">          0 :      if (functionReferenceExp != NULL)</span></a>
<a name="8320"><span class="lineNum">    8320 </span>            :         {</a>
<a name="8321"><span class="lineNum">    8321 </span><span class="lineNoCov">          0 :           returnDeclaration = functionReferenceExp-&gt;getAssociatedFunctionDeclaration();</span></a>
<a name="8322"><span class="lineNum">    8322 </span>            :         }</a>
<a name="8323"><span class="lineNum">    8323 </span>            : </a>
<a name="8324"><span class="lineNum">    8324 </span><span class="lineNoCov">          0 :      SgArrowExp* arrowExp = isSgArrowExp(expression);</span></a>
<a name="8325"><span class="lineNum">    8325 </span><span class="lineNoCov">          0 :      if ( arrowExp != NULL)</span></a>
<a name="8326"><span class="lineNum">    8326 </span>            :         {</a>
<a name="8327"><span class="lineNum">    8327 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (arrowExp != NULL);</span></a>
<a name="8328"><span class="lineNum">    8328 </span>            : </a>
<a name="8329"><span class="lineNum">    8329 </span><span class="lineNoCov">          0 :           SgExpression* rhsOperand = arrowExp-&gt;get_rhs_operand();</span></a>
<a name="8330"><span class="lineNum">    8330 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (rhsOperand != NULL);</span></a>
<a name="8331"><span class="lineNum">    8331 </span>            : </a>
<a name="8332"><span class="lineNum">    8332 </span><span class="lineNoCov">          0 :           SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(rhsOperand);</span></a>
<a name="8333"><span class="lineNum">    8333 </span>            : </a>
<a name="8334"><span class="lineNum">    8334 </span>            :        // ROSE_ASSERT (memberFunctionRefExp != NULL);</a>
<a name="8335"><span class="lineNum">    8335 </span><span class="lineNoCov">          0 :           if (memberFunctionRefExp != NULL)</span></a>
<a name="8336"><span class="lineNum">    8336 </span>            :              {</a>
<a name="8337"><span class="lineNum">    8337 </span><span class="lineNoCov">          0 :                returnDeclaration = memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration();</span></a>
<a name="8338"><span class="lineNum">    8338 </span>            :              }</a>
<a name="8339"><span class="lineNum">    8339 </span>            :         }</a>
<a name="8340"><span class="lineNum">    8340 </span>            : </a>
<a name="8341"><span class="lineNum">    8341 </span><span class="lineNoCov">          0 :      return returnDeclaration;</span></a>
<a name="8342"><span class="lineNum">    8342 </span>            :    }</a>
<a name="8343"><span class="lineNum">    8343 </span>            : </a>
<a name="8344"><span class="lineNum">    8344 </span>            : </a>
<a name="8345"><span class="lineNum">    8345 </span>            : </a>
<a name="8346"><span class="lineNum">    8346 </span>            : std::list&lt;SgClassType*&gt;</a>
<a name="8347"><span class="lineNum">    8347 </span><span class="lineCov">       9285 : SageInterface::getClassTypeChainForMemberReference(SgExpression* refExp)</span></a>
<a name="8348"><span class="lineNum">    8348 </span>            :    {</a>
<a name="8349"><span class="lineNum">    8349 </span>            :   // DQ (2/16/2019): This version support for data member name qualification return type chains.</a>
<a name="8350"><span class="lineNum">    8350 </span>            : </a>
<a name="8351"><span class="lineNum">    8351 </span>            : #define DEBUG_DATA_MEMBER_TYPE_CHAIN 0</a>
<a name="8352"><span class="lineNum">    8352 </span>            : </a>
<a name="8353"><span class="lineNum">    8353 </span>            :   // The input must be one of these two, then this function is suficiently general to support name qualification requirements for both.</a>
<a name="8354"><span class="lineNum">    8354 </span><span class="lineCov">       9285 :      SgVarRefExp*            varRefExp            = isSgVarRefExp(refExp);</span></a>
<a name="8355"><span class="lineNum">    8355 </span><span class="lineCov">       9285 :      SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(refExp);</span></a>
<a name="8356"><span class="lineNum">    8356 </span>            : </a>
<a name="8357"><span class="lineNum">    8357 </span><span class="lineCov">       9285 :      ROSE_ASSERT(varRefExp != NULL || memberFunctionRefExp != NULL);</span></a>
<a name="8358"><span class="lineNum">    8358 </span>            : </a>
<a name="8359"><span class="lineNum">    8359 </span><span class="lineCov">       9285 :      std::list&lt;SgClassType*&gt; returnTypeChain;</span></a>
<a name="8360"><span class="lineNum">    8360 </span>            : </a>
<a name="8361"><span class="lineNum">    8361 </span>            :   // Internal list used to filter the class chain generated from chained SgCastExp objects to identify the subset containing an ambiguity.</a>
<a name="8362"><span class="lineNum">    8362 </span><span class="lineNoCov">          0 :      std::list&lt;SgClassType*&gt; classChain;</span></a>
<a name="8363"><span class="lineNum">    8363 </span>            : </a>
<a name="8364"><span class="lineNum">    8364 </span>            :   // Make sure this is at least a reference to a data or member function member.</a>
<a name="8365"><span class="lineNum">    8365 </span>            :   // The requirements for these functions are different, however, if they were</a>
<a name="8366"><span class="lineNum">    8366 </span>            :   // virtual functions it might be a more attractive design.</a>
<a name="8367"><span class="lineNum">    8367 </span><span class="lineCov">       9285 :      if (varRefExp != NULL)</span></a>
<a name="8368"><span class="lineNum">    8368 </span>            :         {</a>
<a name="8369"><span class="lineNum">    8369 </span><span class="lineCov">       5166 :           ROSE_ASSERT(isDataMemberReference(varRefExp) == true);</span></a>
<a name="8370"><span class="lineNum">    8370 </span>            :         }</a>
<a name="8371"><span class="lineNum">    8371 </span>            :        else</a>
<a name="8372"><span class="lineNum">    8372 </span>            :         {</a>
<a name="8373"><span class="lineNum">    8373 </span><span class="lineCov">       4119 :           ROSE_ASSERT(memberFunctionRefExp != NULL);</span></a>
<a name="8374"><span class="lineNum">    8374 </span><span class="lineCov">       4119 :           ROSE_ASSERT(isMemberFunctionMemberReference(memberFunctionRefExp) == true);</span></a>
<a name="8375"><span class="lineNum">    8375 </span>            :         }</a>
<a name="8376"><span class="lineNum">    8376 </span>            : </a>
<a name="8377"><span class="lineNum">    8377 </span><span class="lineCov">       9285 :      SgNode* parent = refExp-&gt;get_parent();</span></a>
<a name="8378"><span class="lineNum">    8378 </span><span class="lineCov">       9285 :      ROSE_ASSERT(parent != NULL);</span></a>
<a name="8379"><span class="lineNum">    8379 </span>            : </a>
<a name="8380"><span class="lineNum">    8380 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8381"><span class="lineNum">    8381 </span>            :      printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="8382"><span class="lineNum">    8382 </span>            : #endif</a>
<a name="8383"><span class="lineNum">    8383 </span>            : </a>
<a name="8384"><span class="lineNum">    8384 </span><span class="lineCov">       9285 :      SgArrowExp* arrowExp = isSgArrowExp(parent);</span></a>
<a name="8385"><span class="lineNum">    8385 </span><span class="lineCov">       9285 :      SgDotExp*   dotExp   = isSgDotExp(parent);</span></a>
<a name="8386"><span class="lineNum">    8386 </span>            : </a>
<a name="8387"><span class="lineNum">    8387 </span><span class="lineCov">       9285 :      SgBinaryOp* binaryOperator = NULL;</span></a>
<a name="8388"><span class="lineNum">    8388 </span>            : </a>
<a name="8389"><span class="lineNum">    8389 </span><span class="lineCov">       9285 :      if (arrowExp != NULL)</span></a>
<a name="8390"><span class="lineNum">    8390 </span>            :         {</a>
<a name="8391"><span class="lineNum">    8391 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8392"><span class="lineNum">    8392 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): Found an arrow expression \n&quot;);</a>
<a name="8393"><span class="lineNum">    8393 </span>            : #endif</a>
<a name="8394"><span class="lineNum">    8394 </span><span class="lineCov">       6079 :           binaryOperator = arrowExp;</span></a>
<a name="8395"><span class="lineNum">    8395 </span>            :         }</a>
<a name="8396"><span class="lineNum">    8396 </span>            : </a>
<a name="8397"><span class="lineNum">    8397 </span><span class="lineCov">       9285 :      if (dotExp != NULL)</span></a>
<a name="8398"><span class="lineNum">    8398 </span>            :         {</a>
<a name="8399"><span class="lineNum">    8399 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8400"><span class="lineNum">    8400 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): Found an dot expression \n&quot;);</a>
<a name="8401"><span class="lineNum">    8401 </span>            : #endif</a>
<a name="8402"><span class="lineNum">    8402 </span><span class="lineCov">       3206 :           binaryOperator = dotExp;</span></a>
<a name="8403"><span class="lineNum">    8403 </span>            :         }</a>
<a name="8404"><span class="lineNum">    8404 </span>            : </a>
<a name="8405"><span class="lineNum">    8405 </span>            :   // ROSE_ASSERT(binaryOperator != NULL);</a>
<a name="8406"><span class="lineNum">    8406 </span><span class="lineCov">       9285 :      if (binaryOperator != NULL)</span></a>
<a name="8407"><span class="lineNum">    8407 </span>            :         {</a>
<a name="8408"><span class="lineNum">    8408 </span><span class="lineCov">       9285 :      SgExpression* lhs = binaryOperator-&gt;get_lhs_operand();</span></a>
<a name="8409"><span class="lineNum">    8409 </span><span class="lineCov">       9285 :      ROSE_ASSERT(lhs != NULL);</span></a>
<a name="8410"><span class="lineNum">    8410 </span>            : </a>
<a name="8411"><span class="lineNum">    8411 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8412"><span class="lineNum">    8412 </span>            :      printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs = %p = %s \n&quot;,lhs,lhs-&gt;class_name().c_str());</a>
<a name="8413"><span class="lineNum">    8413 </span>            : #endif</a>
<a name="8414"><span class="lineNum">    8414 </span>            : </a>
<a name="8415"><span class="lineNum">    8415 </span>            :   // Looking for a chain of SgCastExp expressions.</a>
<a name="8416"><span class="lineNum">    8416 </span><span class="lineCov">       9285 :      SgExpression* temp_lhs = lhs;</span></a>
<a name="8417"><span class="lineNum">    8417 </span><span class="lineCov">       9285 :      SgCastExp* cast = NULL;</span></a>
<a name="8418"><span class="lineNum">    8418 </span><span class="lineCov">       9998 :      while (isSgCastExp(temp_lhs) != NULL)</span></a>
<a name="8419"><span class="lineNum">    8419 </span>            :         {</a>
<a name="8420"><span class="lineNum">    8420 </span><span class="lineCov">        713 :           cast = isSgCastExp(temp_lhs);</span></a>
<a name="8421"><span class="lineNum">    8421 </span><span class="lineCov">        713 :           ROSE_ASSERT(cast != NULL);</span></a>
<a name="8422"><span class="lineNum">    8422 </span><span class="lineCov">        713 :           temp_lhs = cast-&gt;get_operand();</span></a>
<a name="8423"><span class="lineNum">    8423 </span>            : </a>
<a name="8424"><span class="lineNum">    8424 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8425"><span class="lineNum">    8425 </span>            :           printf (&quot;Top of loop: processing cast = %p temp_lhs = %p = %s \n&quot;,cast,temp_lhs,temp_lhs-&gt;class_name().c_str());</a>
<a name="8426"><span class="lineNum">    8426 </span>            : #endif</a>
<a name="8427"><span class="lineNum">    8427 </span><span class="lineCov">        713 :           ROSE_ASSERT(cast-&gt;get_type() != NULL);</span></a>
<a name="8428"><span class="lineNum">    8428 </span><span class="lineCov">        713 :           SgClassType* classType = isSgClassType(cast-&gt;get_type());</span></a>
<a name="8429"><span class="lineNum">    8429 </span><span class="lineCov">        713 :           if (classType == NULL)</span></a>
<a name="8430"><span class="lineNum">    8430 </span>            :              {</a>
<a name="8431"><span class="lineNum">    8431 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8432"><span class="lineNum">    8432 </span>            :                printf (&quot; --- looking for base type: In SageInterface::getClassTypeChainForDataMemberReference(): classType == NULL: cast-&gt;get_type() = %p = %s \n&quot;,</a>
<a name="8433"><span class="lineNum">    8433 </span>            :                     cast-&gt;get_type(),cast-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="8434"><span class="lineNum">    8434 </span>            : #endif</a>
<a name="8435"><span class="lineNum">    8435 </span><span class="lineCov">        574 :                SgType* baseType = cast-&gt;get_type()-&gt;stripType(SgType::STRIP_POINTER_TYPE | SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</span></a>
<a name="8436"><span class="lineNum">    8436 </span><span class="lineCov">        574 :                ROSE_ASSERT(baseType != NULL);</span></a>
<a name="8437"><span class="lineNum">    8437 </span>            : </a>
<a name="8438"><span class="lineNum">    8438 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8439"><span class="lineNum">    8439 </span>            :                printf (&quot; --- baseType = %p = %s name = %s \n&quot;,baseType,baseType-&gt;class_name().c_str(),get_name(baseType).c_str());</a>
<a name="8440"><span class="lineNum">    8440 </span>            : #endif</a>
<a name="8441"><span class="lineNum">    8441 </span><span class="lineCov">        574 :                classType = isSgClassType(baseType);</span></a>
<a name="8442"><span class="lineNum">    8442 </span>            :              }</a>
<a name="8443"><span class="lineNum">    8443 </span>            :        // ROSE_ASSERT(classType != NULL);</a>
<a name="8444"><span class="lineNum">    8444 </span>            : </a>
<a name="8445"><span class="lineNum">    8445 </span><span class="lineCov">        713 :           ROSE_ASSERT(temp_lhs != NULL);</span></a>
<a name="8446"><span class="lineNum">    8446 </span>            : </a>
<a name="8447"><span class="lineNum">    8447 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8448"><span class="lineNum">    8448 </span>            :           printf (&quot; --- temp_lhs = %p = %s name = %s \n&quot;,temp_lhs,temp_lhs-&gt;class_name().c_str(),get_name(temp_lhs).c_str());</a>
<a name="8449"><span class="lineNum">    8449 </span>            : #endif</a>
<a name="8450"><span class="lineNum">    8450 </span>            : </a>
<a name="8451"><span class="lineNum">    8451 </span>            : #if 1</a>
<a name="8452"><span class="lineNum">    8452 </span>            :        // DQ (1/20/2020): This (original) code works fine.</a>
<a name="8453"><span class="lineNum">    8453 </span>            :        // returnTypeChain.push_front(classType);</a>
<a name="8454"><span class="lineNum">    8454 </span><span class="lineCov">        713 :           if (classType != NULL)</span></a>
<a name="8455"><span class="lineNum">    8455 </span>            :              {</a>
<a name="8456"><span class="lineNum">    8456 </span><span class="lineCov">        713 :                classChain.push_front(classType);</span></a>
<a name="8457"><span class="lineNum">    8457 </span>            :              }</a>
<a name="8458"><span class="lineNum">    8458 </span>            : #else</a>
<a name="8459"><span class="lineNum">    8459 </span>            :        // DQ (1/20/2020): This (new) code works for Cxx11_tests/test2020_61.C.</a>
<a name="8460"><span class="lineNum">    8460 </span>            :           if (classType != NULL)</a>
<a name="8461"><span class="lineNum">    8461 </span>            :              {</a>
<a name="8462"><span class="lineNum">    8462 </span>            :             // DQ (1/20/2020): We might want to fully resolve the class types associated with this cast here directly</a>
<a name="8463"><span class="lineNum">    8463 </span>            :             // (see Cxx11_tests/test2020_61.C). The point is that we need a qualified name that will reflect all of</a>
<a name="8464"><span class="lineNum">    8464 </span>            :             // the class declarations from the temp_lhs to the declarations associated with the classType.</a>
<a name="8465"><span class="lineNum">    8465 </span>            :             // The steps are:</a>
<a name="8466"><span class="lineNum">    8466 </span>            :             //    1) Get the target class definition for the type represented by the temp_lhs.</a>
<a name="8467"><span class="lineNum">    8467 </span>            :             //    2) Get the source class definition for the classType.</a>
<a name="8468"><span class="lineNum">    8468 </span>            :             //    3) Iterate from the source class definition to the target class definition, and save the associated</a>
<a name="8469"><span class="lineNum">    8469 </span>            :             //       types associated with the class declarations associated with the scopes visited.</a>
<a name="8470"><span class="lineNum">    8470 </span>            :                SgType* target_type = temp_lhs-&gt;get_type();</a>
<a name="8471"><span class="lineNum">    8471 </span>            :                ROSE_ASSERT(target_type != NULL);</a>
<a name="8472"><span class="lineNum">    8472 </span>            :                SgClassType* target_classType = isSgClassType(target_type);</a>
<a name="8473"><span class="lineNum">    8473 </span>            :             // ROSE_ASSERT(target_classType != NULL);</a>
<a name="8474"><span class="lineNum">    8474 </span>            :                if (target_classType != NULL)</a>
<a name="8475"><span class="lineNum">    8475 </span>            :                   {</a>
<a name="8476"><span class="lineNum">    8476 </span>            :                     SgDeclarationStatement* target_declaration = target_classType-&gt;get_declaration();</a>
<a name="8477"><span class="lineNum">    8477 </span>            :                     ROSE_ASSERT(target_declaration != NULL);</a>
<a name="8478"><span class="lineNum">    8478 </span>            :                     SgClassDeclaration* target_classDeclaration = isSgClassDeclaration(target_declaration);</a>
<a name="8479"><span class="lineNum">    8479 </span>            :                     ROSE_ASSERT(target_classDeclaration != NULL);</a>
<a name="8480"><span class="lineNum">    8480 </span>            :                     SgClassDeclaration* target_definingClassDeclaration = isSgClassDeclaration(target_classDeclaration-&gt;get_definingDeclaration());</a>
<a name="8481"><span class="lineNum">    8481 </span>            :                     ROSE_ASSERT(target_definingClassDeclaration != NULL);</a>
<a name="8482"><span class="lineNum">    8482 </span>            :                     SgScopeStatement* target_scope = target_definingClassDeclaration-&gt;get_definition();</a>
<a name="8483"><span class="lineNum">    8483 </span>            :                     ROSE_ASSERT(target_scope != NULL);</a>
<a name="8484"><span class="lineNum">    8484 </span>            : </a>
<a name="8485"><span class="lineNum">    8485 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8486"><span class="lineNum">    8486 </span>            :                     printf (&quot;target_classDeclaration = %p = %s name = %s target_scope = %p = %s \n&quot;,</a>
<a name="8487"><span class="lineNum">    8487 </span>            :                             target_classDeclaration,target_classDeclaration-&gt;class_name().c_str(),target_classDeclaration-&gt;get_name().str(),target_scope,target_scope-&gt;class_name().c_str());</a>
<a name="8488"><span class="lineNum">    8488 </span>            : #endif</a>
<a name="8489"><span class="lineNum">    8489 </span>            :                     SgClassType* source_classType = classType;</a>
<a name="8490"><span class="lineNum">    8490 </span>            :                     ROSE_ASSERT(source_classType != NULL);</a>
<a name="8491"><span class="lineNum">    8491 </span>            :                     SgDeclarationStatement* source_declaration = source_classType-&gt;get_declaration();</a>
<a name="8492"><span class="lineNum">    8492 </span>            :                     ROSE_ASSERT(source_declaration != NULL);</a>
<a name="8493"><span class="lineNum">    8493 </span>            :                     SgClassDeclaration* source_classDeclaration = isSgClassDeclaration(source_declaration);</a>
<a name="8494"><span class="lineNum">    8494 </span>            :                     ROSE_ASSERT(source_classDeclaration != NULL);</a>
<a name="8495"><span class="lineNum">    8495 </span>            :                     SgClassDeclaration* source_definingClassDeclaration = isSgClassDeclaration(source_classDeclaration-&gt;get_definingDeclaration());</a>
<a name="8496"><span class="lineNum">    8496 </span>            :                     ROSE_ASSERT(source_definingClassDeclaration != NULL);</a>
<a name="8497"><span class="lineNum">    8497 </span>            :                     SgScopeStatement* source_scope = source_definingClassDeclaration-&gt;get_definition();</a>
<a name="8498"><span class="lineNum">    8498 </span>            :                     ROSE_ASSERT(source_scope != NULL);</a>
<a name="8499"><span class="lineNum">    8499 </span>            : </a>
<a name="8500"><span class="lineNum">    8500 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8501"><span class="lineNum">    8501 </span>            :                     printf (&quot;source_classDeclaration = %p = %s name = %s source_scope = %p = %s \n&quot;,</a>
<a name="8502"><span class="lineNum">    8502 </span>            :                             source_classDeclaration,source_classDeclaration-&gt;class_name().c_str(),source_classDeclaration-&gt;get_name().str(),source_scope,source_scope-&gt;class_name().c_str());</a>
<a name="8503"><span class="lineNum">    8503 </span>            : #endif</a>
<a name="8504"><span class="lineNum">    8504 </span>            :                     SgScopeStatement* tmp_scope = source_scope;</a>
<a name="8505"><span class="lineNum">    8505 </span>            :                     while (tmp_scope != NULL &amp;&amp; tmp_scope != target_scope)</a>
<a name="8506"><span class="lineNum">    8506 </span>            :                        {</a>
<a name="8507"><span class="lineNum">    8507 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8508"><span class="lineNum">    8508 </span>            :                          printf (&quot;tmp_scope = %p = %s \n&quot;,tmp_scope,tmp_scope-&gt;class_name().c_str());</a>
<a name="8509"><span class="lineNum">    8509 </span>            : #endif</a>
<a name="8510"><span class="lineNum">    8510 </span>            :                          SgClassDefinition* tmp_classDefinition = isSgClassDefinition(tmp_scope);</a>
<a name="8511"><span class="lineNum">    8511 </span>            :                          ROSE_ASSERT(tmp_classDefinition != NULL);</a>
<a name="8512"><span class="lineNum">    8512 </span>            :                          SgClassDeclaration* tmp_classDeclaration = tmp_classDefinition-&gt;get_declaration();</a>
<a name="8513"><span class="lineNum">    8513 </span>            :                          ROSE_ASSERT(tmp_classDeclaration != NULL);</a>
<a name="8514"><span class="lineNum">    8514 </span>            : </a>
<a name="8515"><span class="lineNum">    8515 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8516"><span class="lineNum">    8516 </span>            :                          SgName scope_name = tmp_classDeclaration-&gt;get_name();</a>
<a name="8517"><span class="lineNum">    8517 </span>            :                          printf (&quot;scope_name = %s \n&quot;,scope_name.str());</a>
<a name="8518"><span class="lineNum">    8518 </span>            : #endif</a>
<a name="8519"><span class="lineNum">    8519 </span>            :                          SgClassType* tmp_classType = tmp_classDeclaration-&gt;get_type();</a>
<a name="8520"><span class="lineNum">    8520 </span>            :                          ROSE_ASSERT(tmp_classType != NULL);</a>
<a name="8521"><span class="lineNum">    8521 </span>            : </a>
<a name="8522"><span class="lineNum">    8522 </span>            :                       // classChain.push_front(tmp_classDefinition);</a>
<a name="8523"><span class="lineNum">    8523 </span>            :                          classChain.push_front(tmp_classType);</a>
<a name="8524"><span class="lineNum">    8524 </span>            : </a>
<a name="8525"><span class="lineNum">    8525 </span>            :                          tmp_scope = tmp_scope-&gt;get_scope();</a>
<a name="8526"><span class="lineNum">    8526 </span>            : </a>
<a name="8527"><span class="lineNum">    8527 </span>            :                          if (isSgGlobal(tmp_scope) != NULL)</a>
<a name="8528"><span class="lineNum">    8528 </span>            :                             {</a>
<a name="8529"><span class="lineNum">    8529 </span>            :                               tmp_scope = NULL;</a>
<a name="8530"><span class="lineNum">    8530 </span>            :                             }</a>
<a name="8531"><span class="lineNum">    8531 </span>            :                        }</a>
<a name="8532"><span class="lineNum">    8532 </span>            :                   }</a>
<a name="8533"><span class="lineNum">    8533 </span>            :                  else</a>
<a name="8534"><span class="lineNum">    8534 </span>            :                   {</a>
<a name="8535"><span class="lineNum">    8535 </span>            : #if 1</a>
<a name="8536"><span class="lineNum">    8536 </span>            :                     printf (&quot;In loop processing cast: target_type = %p = %s \n&quot;,target_type,target_type-&gt;class_name().c_str());</a>
<a name="8537"><span class="lineNum">    8537 </span>            : #endif</a>
<a name="8538"><span class="lineNum">    8538 </span>            :                   }</a>
<a name="8539"><span class="lineNum">    8539 </span>            :              }</a>
<a name="8540"><span class="lineNum">    8540 </span>            : #endif</a>
<a name="8541"><span class="lineNum">    8541 </span>            : </a>
<a name="8542"><span class="lineNum">    8542 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8543"><span class="lineNum">    8543 </span>            :           printf (&quot;Bottom of loop: processing cast = %p temp_lhs = %p = %s \n&quot;,cast,temp_lhs,temp_lhs-&gt;class_name().c_str());</a>
<a name="8544"><span class="lineNum">    8544 </span>            : #endif</a>
<a name="8545"><span class="lineNum">    8545 </span>            :         }</a>
<a name="8546"><span class="lineNum">    8546 </span>            : </a>
<a name="8547"><span class="lineNum">    8547 </span>            :   // We also need to include the first class where we are referencing the variable or function because that is where the first ambiguity may happen.</a>
<a name="8548"><span class="lineNum">    8548 </span>            : </a>
<a name="8549"><span class="lineNum">    8549 </span><span class="lineCov">       9285 :      ROSE_ASSERT(temp_lhs != NULL);</span></a>
<a name="8550"><span class="lineNum">    8550 </span>            : </a>
<a name="8551"><span class="lineNum">    8551 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8552"><span class="lineNum">    8552 </span>            :      printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): temp_lhs = %p = %s \n&quot;,temp_lhs,temp_lhs-&gt;class_name().c_str());</a>
<a name="8553"><span class="lineNum">    8553 </span>            : #endif</a>
<a name="8554"><span class="lineNum">    8554 </span>            : </a>
<a name="8555"><span class="lineNum">    8555 </span><span class="lineCov">       9285 :      SgVarRefExp* derivedClassVarRefExp = isSgVarRefExp(temp_lhs);</span></a>
<a name="8556"><span class="lineNum">    8556 </span><span class="lineCov">       9285 :      if (derivedClassVarRefExp != NULL)</span></a>
<a name="8557"><span class="lineNum">    8557 </span>            :         {</a>
<a name="8558"><span class="lineNum">    8558 </span><span class="lineCov">       2825 :           SgVariableSymbol* derivedClassVariableSymbol =  derivedClassVarRefExp-&gt;get_symbol();</span></a>
<a name="8559"><span class="lineNum">    8559 </span><span class="lineCov">       2825 :           ROSE_ASSERT(derivedClassVariableSymbol != NULL);</span></a>
<a name="8560"><span class="lineNum">    8560 </span>            : </a>
<a name="8561"><span class="lineNum">    8561 </span><span class="lineCov">       2825 :           SgName derivedClassVariableName = derivedClassVariableSymbol-&gt;get_name();</span></a>
<a name="8562"><span class="lineNum">    8562 </span>            : </a>
<a name="8563"><span class="lineNum">    8563 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8564"><span class="lineNum">    8564 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): derivedClassVariableName = %s \n&quot;,derivedClassVariableName.str());</a>
<a name="8565"><span class="lineNum">    8565 </span>            : #endif</a>
<a name="8566"><span class="lineNum">    8566 </span>            :        // SgType* type = cast-&gt;get_type();</a>
<a name="8567"><span class="lineNum">    8567 </span><span class="lineCov">       2825 :           SgType* type = temp_lhs-&gt;get_type();</span></a>
<a name="8568"><span class="lineNum">    8568 </span><span class="lineCov">       2825 :           ROSE_ASSERT(type != NULL);</span></a>
<a name="8569"><span class="lineNum">    8569 </span>            : </a>
<a name="8570"><span class="lineNum">    8570 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8571"><span class="lineNum">    8571 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs type = %p = %s \n&quot;,type,type-&gt;class_name().c_str());</a>
<a name="8572"><span class="lineNum">    8572 </span>            : #endif</a>
<a name="8573"><span class="lineNum">    8573 </span>            : </a>
<a name="8574"><span class="lineNum">    8574 </span>            :        // SgType* stripped_type = type-&gt;stripType(SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_MODIFIER_TYPE);</a>
<a name="8575"><span class="lineNum">    8575 </span><span class="lineCov">       2825 :           SgType* stripped_type = type-&gt;stripType(SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_MODIFIER_TYPE);</span></a>
<a name="8576"><span class="lineNum">    8576 </span>            : </a>
<a name="8577"><span class="lineNum">    8577 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8578"><span class="lineNum">    8578 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs stripped_type = %p = %s \n&quot;,stripped_type,stripped_type-&gt;class_name().c_str());</a>
<a name="8579"><span class="lineNum">    8579 </span>            : #endif</a>
<a name="8580"><span class="lineNum">    8580 </span>            : </a>
<a name="8581"><span class="lineNum">    8581 </span>            :        // SgClassType* classType = isSgClassType(type);</a>
<a name="8582"><span class="lineNum">    8582 </span><span class="lineCov">       2825 :           SgClassType* classType = isSgClassType(stripped_type);</span></a>
<a name="8583"><span class="lineNum">    8583 </span>            : </a>
<a name="8584"><span class="lineNum">    8584 </span>            :        // ROSE_ASSERT(classType != NULL);</a>
<a name="8585"><span class="lineNum">    8585 </span><span class="lineCov">       2825 :           if (classType != NULL)</span></a>
<a name="8586"><span class="lineNum">    8586 </span>            :              {</a>
<a name="8587"><span class="lineNum">    8587 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8588"><span class="lineNum">    8588 </span>            :                printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs classType = %p = %s \n&quot;,classType,classType-&gt;class_name().c_str());</a>
<a name="8589"><span class="lineNum">    8589 </span>            :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</a>
<a name="8590"><span class="lineNum">    8590 </span>            :                ROSE_ASSERT(classDeclaration != NULL);</a>
<a name="8591"><span class="lineNum">    8591 </span>            :                printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs classDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="8592"><span class="lineNum">    8592 </span>            :                     classDeclaration,classDeclaration-&gt;class_name().c_str(),classDeclaration-&gt;get_name().str());</a>
<a name="8593"><span class="lineNum">    8593 </span>            : #endif</a>
<a name="8594"><span class="lineNum">    8594 </span>            :             // This is where we want the SgVarRefExp data member qualification to start.</a>
<a name="8595"><span class="lineNum">    8595 </span>            :             // returnType = classType;</a>
<a name="8596"><span class="lineNum">    8596 </span>            :             // returnTypeChain.push_front(classType);</a>
<a name="8597"><span class="lineNum">    8597 </span><span class="lineCov">       2825 :                classChain.push_front(classType);</span></a>
<a name="8598"><span class="lineNum">    8598 </span>            :              }</a>
<a name="8599"><span class="lineNum">    8599 </span>            :             else</a>
<a name="8600"><span class="lineNum">    8600 </span>            :              {</a>
<a name="8601"><span class="lineNum">    8601 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8602"><span class="lineNum">    8602 </span>            :                printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs stripped_type is not a SgClassType \n&quot;);</a>
<a name="8603"><span class="lineNum">    8603 </span>            : #endif</a>
<a name="8604"><span class="lineNum">    8604 </span>            :              }</a>
<a name="8605"><span class="lineNum">    8605 </span>            :         }</a>
<a name="8606"><span class="lineNum">    8606 </span>            :        else</a>
<a name="8607"><span class="lineNum">    8607 </span>            :         {</a>
<a name="8608"><span class="lineNum">    8608 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8609"><span class="lineNum">    8609 </span>            :           printf (&quot;Need to support alternative to SgVarRefExp: temp_lhs = %p = %s \n&quot;,temp_lhs,temp_lhs-&gt;class_name().c_str());</a>
<a name="8610"><span class="lineNum">    8610 </span>            : #endif</a>
<a name="8611"><span class="lineNum">    8611 </span><span class="lineCov">       6460 :           SgType* type = temp_lhs-&gt;get_type();</span></a>
<a name="8612"><span class="lineNum">    8612 </span><span class="lineCov">       6460 :           ROSE_ASSERT(type != NULL);</span></a>
<a name="8613"><span class="lineNum">    8613 </span>            : </a>
<a name="8614"><span class="lineNum">    8614 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8615"><span class="lineNum">    8615 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): lhs type = %p = %s name = %s \n&quot;,type,type-&gt;class_name().c_str(),get_name(type).c_str());</a>
<a name="8616"><span class="lineNum">    8616 </span>            : #endif</a>
<a name="8617"><span class="lineNum">    8617 </span>            : </a>
<a name="8618"><span class="lineNum">    8618 </span>            :        // DQ (1/3/2019): Need to strip the type to get to a possible SgClassType.</a>
<a name="8619"><span class="lineNum">    8619 </span><span class="lineCov">       6460 :           SgType* stripped_type = type-&gt;stripType(SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_MODIFIER_TYPE);</span></a>
<a name="8620"><span class="lineNum">    8620 </span>            : </a>
<a name="8621"><span class="lineNum">    8621 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8622"><span class="lineNum">    8622 </span>            :           printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): stripped_type = %p = %s name = %s \n&quot;,stripped_type,stripped_type-&gt;class_name().c_str(),get_name(stripped_type).c_str());</a>
<a name="8623"><span class="lineNum">    8623 </span>            : #endif</a>
<a name="8624"><span class="lineNum">    8624 </span>            :        // SgClassType* classType = isSgClassType(type);</a>
<a name="8625"><span class="lineNum">    8625 </span><span class="lineCov">       6460 :           SgClassType* classType = isSgClassType(stripped_type);</span></a>
<a name="8626"><span class="lineNum">    8626 </span>            :        // returnTypeChain.push_front(classType);</a>
<a name="8627"><span class="lineNum">    8627 </span><span class="lineCov">       6460 :           if (classType != NULL)</span></a>
<a name="8628"><span class="lineNum">    8628 </span>            :              {</a>
<a name="8629"><span class="lineNum">    8629 </span><span class="lineCov">       6460 :                classChain.push_front(classType);</span></a>
<a name="8630"><span class="lineNum">    8630 </span>            :              }</a>
<a name="8631"><span class="lineNum">    8631 </span>            :         }</a>
<a name="8632"><span class="lineNum">    8632 </span>            : </a>
<a name="8633"><span class="lineNum">    8633 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8634"><span class="lineNum">    8634 </span>            :      printf (&quot;classChain.size() = %zu \n&quot;,classChain.size());</a>
<a name="8635"><span class="lineNum">    8635 </span>            :      std::list&lt;SgClassType*&gt;::iterator iter = classChain.begin();</a>
<a name="8636"><span class="lineNum">    8636 </span>            :      while(iter != classChain.end())</a>
<a name="8637"><span class="lineNum">    8637 </span>            :         {</a>
<a name="8638"><span class="lineNum">    8638 </span>            :           printf (&quot; --- *iter = %p = %s name = %s \n&quot;,*iter,(*iter)-&gt;class_name().c_str(),(*iter)-&gt;get_name().str());</a>
<a name="8639"><span class="lineNum">    8639 </span>            : </a>
<a name="8640"><span class="lineNum">    8640 </span>            :           iter++;</a>
<a name="8641"><span class="lineNum">    8641 </span>            :         }</a>
<a name="8642"><span class="lineNum">    8642 </span>            : #endif</a>
<a name="8643"><span class="lineNum">    8643 </span>            : </a>
<a name="8644"><span class="lineNum">    8644 </span>            :   // Test the first element in the list to see if there is an ambiguity in the associated classDefinition</a>
<a name="8645"><span class="lineNum">    8645 </span>            :   // for the input variable referenced SgVarRefExp).</a>
<a name="8646"><span class="lineNum">    8646 </span>            : </a>
<a name="8647"><span class="lineNum">    8647 </span>            :   // SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</a>
<a name="8648"><span class="lineNum">    8648 </span>            :   // ROSE_ASSERT(variableSymbol != NULL);</a>
<a name="8649"><span class="lineNum">    8649 </span>            :   // SgName variableName = variableSymbol-&gt;get_name();</a>
<a name="8650"><span class="lineNum">    8650 </span><span class="lineCov">       9285 :      SgSymbol* referenceSymbol = NULL;</span></a>
<a name="8651"><span class="lineNum">    8651 </span><span class="lineCov">       9285 :      if (varRefExp != NULL)</span></a>
<a name="8652"><span class="lineNum">    8652 </span>            :         {</a>
<a name="8653"><span class="lineNum">    8653 </span><span class="lineCov">       5166 :           ROSE_ASSERT(varRefExp != NULL);</span></a>
<a name="8654"><span class="lineNum">    8654 </span><span class="lineCov">       5166 :           ROSE_ASSERT(memberFunctionRefExp == NULL);</span></a>
<a name="8655"><span class="lineNum">    8655 </span>            : </a>
<a name="8656"><span class="lineNum">    8656 </span><span class="lineCov">       5166 :           referenceSymbol = varRefExp-&gt;get_symbol();</span></a>
<a name="8657"><span class="lineNum">    8657 </span>            :         }</a>
<a name="8658"><span class="lineNum">    8658 </span>            :        else</a>
<a name="8659"><span class="lineNum">    8659 </span>            :         {</a>
<a name="8660"><span class="lineNum">    8660 </span><span class="lineCov">       4119 :           ROSE_ASSERT(varRefExp == NULL);</span></a>
<a name="8661"><span class="lineNum">    8661 </span><span class="lineCov">       4119 :           ROSE_ASSERT(memberFunctionRefExp != NULL);</span></a>
<a name="8662"><span class="lineNum">    8662 </span>            : </a>
<a name="8663"><span class="lineNum">    8663 </span><span class="lineCov">       4119 :           referenceSymbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="8664"><span class="lineNum">    8664 </span>            :         }</a>
<a name="8665"><span class="lineNum">    8665 </span><span class="lineCov">       9285 :      ROSE_ASSERT(referenceSymbol != NULL);</span></a>
<a name="8666"><span class="lineNum">    8666 </span><span class="lineCov">       9285 :      SgName symbolName = referenceSymbol-&gt;get_name();</span></a>
<a name="8667"><span class="lineNum">    8667 </span>            : </a>
<a name="8668"><span class="lineNum">    8668 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8669"><span class="lineNum">    8669 </span>            :      printf (&quot;referenceSymbol = %p = %s \n&quot;,referenceSymbol,referenceSymbol-&gt;class_name().c_str());</a>
<a name="8670"><span class="lineNum">    8670 </span>            :      printf (&quot;symbolName = %s \n&quot;,symbolName.str());</a>
<a name="8671"><span class="lineNum">    8671 </span>            : #endif</a>
<a name="8672"><span class="lineNum">    8672 </span>            : </a>
<a name="8673"><span class="lineNum">    8673 </span>            :   // Generate the name without the template arguments.</a>
<a name="8674"><span class="lineNum">    8674 </span><span class="lineCov">       9285 :      SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(referenceSymbol);</span></a>
<a name="8675"><span class="lineNum">    8675 </span><span class="lineCov">       9285 :      if (functionSymbol != NULL)</span></a>
<a name="8676"><span class="lineNum">    8676 </span>            :         {</a>
<a name="8677"><span class="lineNum">    8677 </span>            :        // DQ (2/24/2019): NOTE: the SgSymbol get_declaration() function is not a virtual function (and maybe it should be). So we need to case it explicitly.</a>
<a name="8678"><span class="lineNum">    8678 </span>            :        // SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(referenceSymbol-&gt;get_declaration());</a>
<a name="8679"><span class="lineNum">    8679 </span><span class="lineCov">       4119 :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(functionSymbol-&gt;get_declaration());</span></a>
<a name="8680"><span class="lineNum">    8680 </span><span class="lineCov">       4119 :           if (templateInstantiationMemberFunctionDeclaration != NULL)</span></a>
<a name="8681"><span class="lineNum">    8681 </span>            :              {</a>
<a name="8682"><span class="lineNum">    8682 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8683"><span class="lineNum">    8683 </span>            :                printf (&quot;This is a template name, we want the name without template arguments \n&quot;);</a>
<a name="8684"><span class="lineNum">    8684 </span>            :                printf (&quot;templateInstantiationMemberFunctionDeclaration             = %p \n&quot;,templateInstantiationMemberFunctionDeclaration);</a>
<a name="8685"><span class="lineNum">    8685 </span>            :                printf (&quot;templateInstantiationMemberFunctionDeclaration-&gt;get_name() = %s \n&quot;,templateInstantiationMemberFunctionDeclaration-&gt;get_name().str());</a>
<a name="8686"><span class="lineNum">    8686 </span>            : #endif</a>
<a name="8687"><span class="lineNum">    8687 </span>            : </a>
<a name="8688"><span class="lineNum">    8688 </span>            :             // DQ (2/24/2019): This is an error (calls base class function).</a>
<a name="8689"><span class="lineNum">    8689 </span>            :             // printf (&quot;templateInstantiationMemberFunctionDeclaration-&gt;get_template_name() = %s \n&quot;,templateInstantiationMemberFunctionDeclaration-&gt;get_template_name().str());</a>
<a name="8690"><span class="lineNum">    8690 </span>            : </a>
<a name="8691"><span class="lineNum">    8691 </span><span class="lineCov">       2483 :                SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration =</span></a>
<a name="8692"><span class="lineNum">    8692 </span><span class="lineCov">       2483 :                     isSgTemplateMemberFunctionDeclaration(templateInstantiationMemberFunctionDeclaration-&gt;get_templateDeclaration());</span></a>
<a name="8693"><span class="lineNum">    8693 </span><span class="lineCov">       2483 :                if (templateMemberFunctionDeclaration != NULL)</span></a>
<a name="8694"><span class="lineNum">    8694 </span>            :                   {</a>
<a name="8695"><span class="lineNum">    8695 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8696"><span class="lineNum">    8696 </span>            :                     printf (&quot;templateMemberFunctionDeclaration = %p \n&quot;,templateMemberFunctionDeclaration);</a>
<a name="8697"><span class="lineNum">    8697 </span>            :                     printf (&quot;templateMemberFunctionDeclaration-&gt;get_name() = %s \n&quot;,templateMemberFunctionDeclaration-&gt;get_name().str());</a>
<a name="8698"><span class="lineNum">    8698 </span>            : #endif</a>
<a name="8699"><span class="lineNum">    8699 </span>            :                  // We need the template name without template arguments.</a>
<a name="8700"><span class="lineNum">    8700 </span><span class="lineCov">       2483 :                     symbolName = templateMemberFunctionDeclaration-&gt;get_name();</span></a>
<a name="8701"><span class="lineNum">    8701 </span>            :                   }</a>
<a name="8702"><span class="lineNum">    8702 </span>            :                  else</a>
<a name="8703"><span class="lineNum">    8703 </span>            :                   {</a>
<a name="8704"><span class="lineNum">    8704 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8705"><span class="lineNum">    8705 </span>            :                     printf (&quot;templateMemberFunctionDeclaration == NULL: template declaration not available from template instantiation (rare, I think) \n&quot;);</a>
<a name="8706"><span class="lineNum">    8706 </span>            : #endif</a>
<a name="8707"><span class="lineNum">    8707 </span>            :                   }</a>
<a name="8708"><span class="lineNum">    8708 </span>            : #if 0</a>
<a name="8709"><span class="lineNum">    8709 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="8710"><span class="lineNum">    8710 </span>            :                ROSE_ABORT();</a>
<a name="8711"><span class="lineNum">    8711 </span>            : #endif</a>
<a name="8712"><span class="lineNum">    8712 </span>            :              }</a>
<a name="8713"><span class="lineNum">    8713 </span>            :             else</a>
<a name="8714"><span class="lineNum">    8714 </span>            :              {</a>
<a name="8715"><span class="lineNum">    8715 </span>            :             // DQ (2/24/2019): This might indicate another case to handle: finding SgMemberFunctionDeclaration (but this is not a template).</a>
<a name="8716"><span class="lineNum">    8716 </span><span class="lineCov">       1636 :                SgDeclarationStatement* declarationStatement = functionSymbol-&gt;get_declaration();</span></a>
<a name="8717"><span class="lineNum">    8717 </span><span class="lineCov">       1636 :                ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="8718"><span class="lineNum">    8718 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8719"><span class="lineNum">    8719 </span>            :                printf (&quot;functionSymbol != NULL: but declaration is not a member function: declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="8720"><span class="lineNum">    8720 </span>            : #endif</a>
<a name="8721"><span class="lineNum">    8721 </span>            :              }</a>
<a name="8722"><span class="lineNum">    8722 </span>            :         }</a>
<a name="8723"><span class="lineNum">    8723 </span>            :        else</a>
<a name="8724"><span class="lineNum">    8724 </span>            :         {</a>
<a name="8725"><span class="lineNum">    8725 </span><span class="lineCov">       5166 :           SgVariableSymbol* variableSymbol = isSgVariableSymbol(referenceSymbol);</span></a>
<a name="8726"><span class="lineNum">    8726 </span><span class="lineCov">       5166 :           if (variableSymbol != NULL)</span></a>
<a name="8727"><span class="lineNum">    8727 </span>            :              {</a>
<a name="8728"><span class="lineNum">    8728 </span>            :              // Nothing to do in this case of a SgVariableSymbol.</a>
<a name="8729"><span class="lineNum">    8729 </span>            :              }</a>
<a name="8730"><span class="lineNum">    8730 </span>            :             else</a>
<a name="8731"><span class="lineNum">    8731 </span>            :              {</a>
<a name="8732"><span class="lineNum">    8732 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8733"><span class="lineNum">    8733 </span>            :                printf (&quot;In SageInterface::getClassTypeChainForDataMemberReference(): NOTE: referenceSymbol is not a SgFunctionSymbol or SgVariableSymbol \n&quot;);</a>
<a name="8734"><span class="lineNum">    8734 </span>            : #endif</a>
<a name="8735"><span class="lineNum">    8735 </span>            : #if 1</a>
<a name="8736"><span class="lineNum">    8736 </span><span class="lineNoCov">          0 :                printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="8737"><span class="lineNum">    8737 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="8738"><span class="lineNum">    8738 </span>            : #endif</a>
<a name="8739"><span class="lineNum">    8739 </span>            :              }</a>
<a name="8740"><span class="lineNum">    8740 </span>            : </a>
<a name="8741"><span class="lineNum">    8741 </span>            :         }</a>
<a name="8742"><span class="lineNum">    8742 </span>            : </a>
<a name="8743"><span class="lineNum">    8743 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8744"><span class="lineNum">    8744 </span>            :      printf (&quot;symbolName = %s \n&quot;,symbolName.str());</a>
<a name="8745"><span class="lineNum">    8745 </span>            : #endif</a>
<a name="8746"><span class="lineNum">    8746 </span>            : </a>
<a name="8747"><span class="lineNum">    8747 </span>            :   // SgClassType* firstDetectedAmbiguity = NULL;</a>
<a name="8748"><span class="lineNum">    8748 </span>            :   // SgClassType* lastDetectedAmbiguity  = NULL;</a>
<a name="8749"><span class="lineNum">    8749 </span>            : </a>
<a name="8750"><span class="lineNum">    8750 </span>            :   // bool nameQualificationRequired = false;</a>
<a name="8751"><span class="lineNum">    8751 </span>            : </a>
<a name="8752"><span class="lineNum">    8752 </span>            :   // std::list&lt;SgClassType*&gt; deleteList;</a>
<a name="8753"><span class="lineNum">    8753 </span><span class="lineCov">      18570 :      std::list&lt;SgClassType*&gt; saveList;</span></a>
<a name="8754"><span class="lineNum">    8754 </span>            : </a>
<a name="8755"><span class="lineNum">    8755 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8756"><span class="lineNum">    8756 </span>            :      printf (&quot;classChain.size() = %zu \n&quot;,classChain.size());</a>
<a name="8757"><span class="lineNum">    8757 </span>            : #endif</a>
<a name="8758"><span class="lineNum">    8758 </span>            : </a>
<a name="8759"><span class="lineNum">    8759 </span><span class="lineCov">       9285 :      std::list&lt;SgClassType*&gt;::iterator i = classChain.begin();</span></a>
<a name="8760"><span class="lineNum">    8760 </span><span class="lineCov">       9285 :      std::list&lt;SgClassType*&gt;::iterator save_iter = i;</span></a>
<a name="8761"><span class="lineNum">    8761 </span>            : </a>
<a name="8762"><span class="lineNum">    8762 </span>            :   // If we have an abiguity at i then we want to save i++, so define save_iter to be the next in the class type list.</a>
<a name="8763"><span class="lineNum">    8763 </span><span class="lineCov">       9285 :      save_iter++;</span></a>
<a name="8764"><span class="lineNum">    8764 </span>            : </a>
<a name="8765"><span class="lineNum">    8765 </span>            :   // DQ (1/19/2020): Add support for more complex nested base classes, see Cxx11_tests/test2020_61.C.</a>
<a name="8766"><span class="lineNum">    8766 </span><span class="lineCov">       9285 :      bool ambiguityDetectedSoSaveWholeChain = false;</span></a>
<a name="8767"><span class="lineNum">    8767 </span>            : </a>
<a name="8768"><span class="lineNum">    8768 </span><span class="lineCov">      18437 :      while(i != classChain.end())</span></a>
<a name="8769"><span class="lineNum">    8769 </span>            :         {</a>
<a name="8770"><span class="lineNum">    8770 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8771"><span class="lineNum">    8771 </span>            :           printf (&quot;******** TOP OF WHILE LOOP ******** \n&quot;);</a>
<a name="8772"><span class="lineNum">    8772 </span>            :           printf (&quot; --- *i = %p = %s name = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),(*i)-&gt;get_name().str());</a>
<a name="8773"><span class="lineNum">    8773 </span>            :           printf (&quot; --- --- referenceSymbol = %p = %s \n&quot;,referenceSymbol,referenceSymbol-&gt;class_name().c_str());</a>
<a name="8774"><span class="lineNum">    8774 </span>            : #endif</a>
<a name="8775"><span class="lineNum">    8775 </span><span class="lineCov">       9152 :           bool ambiguityDetected = false;</span></a>
<a name="8776"><span class="lineNum">    8776 </span>            : </a>
<a name="8777"><span class="lineNum">    8777 </span><span class="lineCov">       9152 :           SgDeclarationStatement* declarationStatement = (*i)-&gt;get_declaration();</span></a>
<a name="8778"><span class="lineNum">    8778 </span><span class="lineCov">       9152 :           ROSE_ASSERT(declarationStatement != NULL);</span></a>
<a name="8779"><span class="lineNum">    8779 </span><span class="lineCov">       9152 :           SgDeclarationStatement* definingDeclarationStatement = declarationStatement-&gt;get_definingDeclaration();</span></a>
<a name="8780"><span class="lineNum">    8780 </span><span class="lineCov">       9152 :           if (definingDeclarationStatement != NULL)</span></a>
<a name="8781"><span class="lineNum">    8781 </span>            :              {</a>
<a name="8782"><span class="lineNum">    8782 </span><span class="lineCov">       9152 :                SgClassDeclaration* classDeclaration = isSgClassDeclaration(definingDeclarationStatement);</span></a>
<a name="8783"><span class="lineNum">    8783 </span><span class="lineCov">       9152 :                ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="8784"><span class="lineNum">    8784 </span><span class="lineCov">       9152 :                SgClassDefinition* classDefinition =  classDeclaration-&gt;get_definition();</span></a>
<a name="8785"><span class="lineNum">    8785 </span>            : </a>
<a name="8786"><span class="lineNum">    8786 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8787"><span class="lineNum">    8787 </span>            :                printf (&quot; --- classDeclaration = %p = %s name = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str(),classDeclaration-&gt;get_name().str());</a>
<a name="8788"><span class="lineNum">    8788 </span>            :                printf (&quot; --- classDefinition = %p = %s \n&quot;,classDefinition,classDefinition-&gt;class_name().c_str());</a>
<a name="8789"><span class="lineNum">    8789 </span>            : #endif</a>
<a name="8790"><span class="lineNum">    8790 </span>            :             // This works for any SgName and SgSymbol, so it need not be specific to variables.</a>
<a name="8791"><span class="lineNum">    8791 </span><span class="lineCov">       9152 :                ambiguityDetected = classDefinition-&gt;hasAmbiguity(symbolName,referenceSymbol);</span></a>
<a name="8792"><span class="lineNum">    8792 </span>            : </a>
<a name="8793"><span class="lineNum">    8793 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8794"><span class="lineNum">    8794 </span>            :                printf (&quot; --- ambiguityDetected = %s \n&quot;,ambiguityDetected ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8795"><span class="lineNum">    8795 </span>            : #endif</a>
<a name="8796"><span class="lineNum">    8796 </span>            :              }</a>
<a name="8797"><span class="lineNum">    8797 </span>            : </a>
<a name="8798"><span class="lineNum">    8798 </span>            :        // DQ (1/19/2020): Add support for more complex nested base classes, see Cxx11_tests/test2020_61.C.</a>
<a name="8799"><span class="lineNum">    8799 </span>            :        // if (ambiguityDetected == true)</a>
<a name="8800"><span class="lineNum">    8800 </span>            :        // if (ambiguityDetected == true || ambiguityDetectedSoSaveWholeChain == true)</a>
<a name="8801"><span class="lineNum">    8801 </span>            :        // if (ambiguityDetected == true)</a>
<a name="8802"><span class="lineNum">    8802 </span><span class="lineCov">       9152 :           if (ambiguityDetected == true || ambiguityDetectedSoSaveWholeChain == true)</span></a>
<a name="8803"><span class="lineNum">    8803 </span>            :              {</a>
<a name="8804"><span class="lineNum">    8804 </span><span class="lineCov">       1553 :                ambiguityDetectedSoSaveWholeChain = true;</span></a>
<a name="8805"><span class="lineNum">    8805 </span>            : </a>
<a name="8806"><span class="lineNum">    8806 </span><span class="lineCov">       1553 :                if (save_iter != classChain.end())</span></a>
<a name="8807"><span class="lineNum">    8807 </span>            :                   {</a>
<a name="8808"><span class="lineNum">    8808 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8809"><span class="lineNum">    8809 </span>            :                     printf (&quot; --- add to saveList: *save_iter = %p \n&quot;,*save_iter);</a>
<a name="8810"><span class="lineNum">    8810 </span>            : #endif</a>
<a name="8811"><span class="lineNum">    8811 </span><span class="lineCov">        136 :                     saveList.push_back(*save_iter);</span></a>
<a name="8812"><span class="lineNum">    8812 </span>            :                   }</a>
<a name="8813"><span class="lineNum">    8813 </span>            :                  else</a>
<a name="8814"><span class="lineNum">    8814 </span>            :                   {</a>
<a name="8815"><span class="lineNum">    8815 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8816"><span class="lineNum">    8816 </span>            :                     printf (&quot; --- save_iter == classChain.end() \n&quot;);</a>
<a name="8817"><span class="lineNum">    8817 </span>            : #endif</a>
<a name="8818"><span class="lineNum">    8818 </span>            :                   }</a>
<a name="8819"><span class="lineNum">    8819 </span>            :              }</a>
<a name="8820"><span class="lineNum">    8820 </span>            : </a>
<a name="8821"><span class="lineNum">    8821 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN || 0</a>
<a name="8822"><span class="lineNum">    8822 </span>            :           printf (&quot;******** BOTTOM OF WHILE LOOP ******** \n&quot;);</a>
<a name="8823"><span class="lineNum">    8823 </span>            : #endif</a>
<a name="8824"><span class="lineNum">    8824 </span><span class="lineCov">       9152 :           i++;</span></a>
<a name="8825"><span class="lineNum">    8825 </span>            : </a>
<a name="8826"><span class="lineNum">    8826 </span>            :        // Also increment the save_iter.</a>
<a name="8827"><span class="lineNum">    8827 </span><span class="lineCov">      18437 :           save_iter++;</span></a>
<a name="8828"><span class="lineNum">    8828 </span>            :         }</a>
<a name="8829"><span class="lineNum">    8829 </span>            : </a>
<a name="8830"><span class="lineNum">    8830 </span>            :   // Now build a list of class types to use in the name qualification from firstDetectedAmbiguity to lastDetectedAmbiguity (inclusive).</a>
<a name="8831"><span class="lineNum">    8831 </span>            : </a>
<a name="8832"><span class="lineNum">    8832 </span>            : #if DEBUG_DATA_MEMBER_TYPE_CHAIN</a>
<a name="8833"><span class="lineNum">    8833 </span>            :      printf (&quot;saveList.size() = %zu \n&quot;,saveList.size());</a>
<a name="8834"><span class="lineNum">    8834 </span>            :      std::list&lt;SgClassType*&gt;::iterator saveList_iterator = saveList.begin();</a>
<a name="8835"><span class="lineNum">    8835 </span>            :      while (saveList_iterator != saveList.end())</a>
<a name="8836"><span class="lineNum">    8836 </span>            :         {</a>
<a name="8837"><span class="lineNum">    8837 </span>            :           printf (&quot; --- *saveList_iterator = %p = %s name = %s \n&quot;,*saveList_iterator,(*saveList_iterator)-&gt;class_name().c_str(),(*saveList_iterator)-&gt;get_name().str());</a>
<a name="8838"><span class="lineNum">    8838 </span>            : </a>
<a name="8839"><span class="lineNum">    8839 </span>            :           saveList_iterator++;</a>
<a name="8840"><span class="lineNum">    8840 </span>            :         }</a>
<a name="8841"><span class="lineNum">    8841 </span>            : #endif</a>
<a name="8842"><span class="lineNum">    8842 </span>            : </a>
<a name="8843"><span class="lineNum">    8843 </span><span class="lineCov">       9285 :      returnTypeChain = saveList;</span></a>
<a name="8844"><span class="lineNum">    8844 </span>            : </a>
<a name="8845"><span class="lineNum">    8845 </span>            :        // End of branch for binaryOperator != NULL.</a>
<a name="8846"><span class="lineNum">    8846 </span>            :         }</a>
<a name="8847"><span class="lineNum">    8847 </span>            : </a>
<a name="8848"><span class="lineNum">    8848 </span><span class="lineCov">      18570 :      return returnTypeChain;</span></a>
<a name="8849"><span class="lineNum">    8849 </span>            :    }</a>
<a name="8850"><span class="lineNum">    8850 </span>            : </a>
<a name="8851"><span class="lineNum">    8851 </span>            : </a>
<a name="8852"><span class="lineNum">    8852 </span>            : </a>
<a name="8853"><span class="lineNum">    8853 </span>            : bool</a>
<a name="8854"><span class="lineNum">    8854 </span><span class="lineCov">       9280 : SageInterface::isMemberFunctionMemberReference(SgMemberFunctionRefExp* memberFunctionRefExp)</span></a>
<a name="8855"><span class="lineNum">    8855 </span>            :    {</a>
<a name="8856"><span class="lineNum">    8856 </span>            :   // DQ (2/17/2019): This may share a design in common with isDataMemberReference() below.</a>
<a name="8857"><span class="lineNum">    8857 </span>            : </a>
<a name="8858"><span class="lineNum">    8858 </span>            : #define DEBUG_IS_MEMBER_FUNCTION_MEMBER_REFERENCE 0</a>
<a name="8859"><span class="lineNum">    8859 </span>            : </a>
<a name="8860"><span class="lineNum">    8860 </span><span class="lineCov">       9280 :      ROSE_ASSERT(memberFunctionRefExp != NULL);</span></a>
<a name="8861"><span class="lineNum">    8861 </span>            : </a>
<a name="8862"><span class="lineNum">    8862 </span><span class="lineCov">       9280 :      bool returnValue = false;</span></a>
<a name="8863"><span class="lineNum">    8863 </span>            : </a>
<a name="8864"><span class="lineNum">    8864 </span>            :   // Check that this is a data member access (e.g. &quot;X x; x.member;&quot;) and not just a reference to a data member (e.g. &quot;X::member;&quot;)</a>
<a name="8865"><span class="lineNum">    8865 </span><span class="lineCov">       9280 :      SgNode* parent = memberFunctionRefExp-&gt;get_parent();</span></a>
<a name="8866"><span class="lineNum">    8866 </span>            : </a>
<a name="8867"><span class="lineNum">    8867 </span><span class="lineCov">       9280 :      SgArrowExp* arrowExp = isSgArrowExp(parent);</span></a>
<a name="8868"><span class="lineNum">    8868 </span><span class="lineCov">       9280 :      SgDotExp*   dotExp   = isSgDotExp(parent);</span></a>
<a name="8869"><span class="lineNum">    8869 </span>            : </a>
<a name="8870"><span class="lineNum">    8870 </span>            :   // I don't know that the SgAddressOfOp is as relevant for the case of SgMemberFunctionRefExp, but I think</a>
<a name="8871"><span class="lineNum">    8871 </span>            :   // it is because we would have to support membr pointeds to functions the same a member pointers to data.</a>
<a name="8872"><span class="lineNum">    8872 </span>            :   // I need some examples test codes to verify that name qualification is important in this case.</a>
<a name="8873"><span class="lineNum">    8873 </span><span class="lineCov">       9280 :      SgAddressOfOp* addressOfOp = isSgAddressOfOp(parent);</span></a>
<a name="8874"><span class="lineNum">    8874 </span>            : </a>
<a name="8875"><span class="lineNum">    8875 </span>            :   // if (arrowExp != NULL || dotExp != NULL)</a>
<a name="8876"><span class="lineNum">    8876 </span><span class="lineCov">       9280 :      if (arrowExp != NULL || dotExp != NULL || addressOfOp != NULL)</span></a>
<a name="8877"><span class="lineNum">    8877 </span>            :         {</a>
<a name="8878"><span class="lineNum">    8878 </span>            :        // Use a SgFunctionSymbol instead of a SgMemberFunctionSymbol for generality (I hope this works).</a>
<a name="8879"><span class="lineNum">    8879 </span><span class="lineCov">       8292 :           SgFunctionSymbol* symbol = memberFunctionRefExp-&gt;get_symbol();</span></a>
<a name="8880"><span class="lineNum">    8880 </span><span class="lineCov">       8292 :           ROSE_ASSERT(symbol != NULL);</span></a>
<a name="8881"><span class="lineNum">    8881 </span>            : </a>
<a name="8882"><span class="lineNum">    8882 </span><span class="lineCov">       8292 :           SgFunctionDeclaration* functionDeclaration = symbol-&gt;get_declaration();</span></a>
<a name="8883"><span class="lineNum">    8883 </span><span class="lineCov">       8292 :           ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="8884"><span class="lineNum">    8884 </span>            : </a>
<a name="8885"><span class="lineNum">    8885 </span>            :        // Check if this is a statically declared variable.</a>
<a name="8886"><span class="lineNum">    8886 </span><span class="lineCov">       8292 :           if (functionDeclaration != NULL)</span></a>
<a name="8887"><span class="lineNum">    8887 </span>            :              {</a>
<a name="8888"><span class="lineNum">    8888 </span><span class="lineCov">       8292 :                bool isStatic = functionDeclaration-&gt;get_declarationModifier().get_storageModifier().isStatic();</span></a>
<a name="8889"><span class="lineNum">    8889 </span>            : #if DEBUG_IS_MEMBER_FUNCTION_MEMBER_REFERENCE</a>
<a name="8890"><span class="lineNum">    8890 </span>            :                printf (&quot;isStatic = %s \n&quot;,isStatic ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8891"><span class="lineNum">    8891 </span>            : #endif</a>
<a name="8892"><span class="lineNum">    8892 </span><span class="lineCov">       8292 :                if (isStatic == false)</span></a>
<a name="8893"><span class="lineNum">    8893 </span>            :                   {</a>
<a name="8894"><span class="lineNum">    8894 </span><span class="lineCov">       8238 :                     SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</span></a>
<a name="8895"><span class="lineNum">    8895 </span><span class="lineCov">       8238 :                     ROSE_ASSERT(scope != NULL);</span></a>
<a name="8896"><span class="lineNum">    8896 </span>            : </a>
<a name="8897"><span class="lineNum">    8897 </span><span class="lineCov">       8238 :                     SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="8898"><span class="lineNum">    8898 </span><span class="lineCov">       8238 :                     if (classDefinition != NULL)</span></a>
<a name="8899"><span class="lineNum">    8899 </span>            :                        {</a>
<a name="8900"><span class="lineNum">    8900 </span><span class="lineCov">       8238 :                          returnValue = true;</span></a>
<a name="8901"><span class="lineNum">    8901 </span>            :                        }</a>
<a name="8902"><span class="lineNum">    8902 </span>            :                   }</a>
<a name="8903"><span class="lineNum">    8903 </span>            :              }</a>
<a name="8904"><span class="lineNum">    8904 </span>            :             else</a>
<a name="8905"><span class="lineNum">    8905 </span>            :              {</a>
<a name="8906"><span class="lineNum">    8906 </span>            : #if DEBUG_IS_MEMBER_FUNCTION_MEMBER_REFERENCE</a>
<a name="8907"><span class="lineNum">    8907 </span>            :                printf (&quot;In SageInterface::isMemberFunctionMemberReference(): memberFunctionRefExp is not associated with variableDeclaration (could not compute if it is static data member) \n&quot;);</a>
<a name="8908"><span class="lineNum">    8908 </span>            : #endif</a>
<a name="8909"><span class="lineNum">    8909 </span>            :              }</a>
<a name="8910"><span class="lineNum">    8910 </span>            :         }</a>
<a name="8911"><span class="lineNum">    8911 </span>            :        else</a>
<a name="8912"><span class="lineNum">    8912 </span>            :         {</a>
<a name="8913"><span class="lineNum">    8913 </span>            : #if DEBUG_IS_MEMBER_FUNCTION_MEMBER_REFERENCE</a>
<a name="8914"><span class="lineNum">    8914 </span>            :           printf (&quot;In SageInterface::isMemberFunctionMemberReference(): memberFunctionRefExp parent is not a is not SgArrowExp or SgDotExp expression \n&quot;);</a>
<a name="8915"><span class="lineNum">    8915 </span>            : #endif</a>
<a name="8916"><span class="lineNum">    8916 </span>            :         }</a>
<a name="8917"><span class="lineNum">    8917 </span>            : </a>
<a name="8918"><span class="lineNum">    8918 </span>            : #if DEBUG_IS_MEMBER_FUNCTION_MEMBER_REFERENCE</a>
<a name="8919"><span class="lineNum">    8919 </span>            :      printf (&quot;Leaving SageInterface::isMemberFunctionMemberReference(): returnValue = %s \n&quot;,returnValue ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="8920"><span class="lineNum">    8920 </span>            : #endif</a>
<a name="8921"><span class="lineNum">    8921 </span>            : </a>
<a name="8922"><span class="lineNum">    8922 </span><span class="lineCov">       9280 :      return returnValue;</span></a>
<a name="8923"><span class="lineNum">    8923 </span>            :    }</a>
<a name="8924"><span class="lineNum">    8924 </span>            : </a>
<a name="8925"><span class="lineNum">    8925 </span>            : </a>
<a name="8926"><span class="lineNum">    8926 </span>            : </a>
<a name="8927"><span class="lineNum">    8927 </span>            : bool</a>
<a name="8928"><span class="lineNum">    8928 </span><span class="lineCov">      71441 : SageInterface::isDataMemberReference(SgVarRefExp* varRefExp)</span></a>
<a name="8929"><span class="lineNum">    8929 </span>            :    {</a>
<a name="8930"><span class="lineNum">    8930 </span>            :   // This function is used to support the name qualification of data member references seperate from name qualification</a>
<a name="8931"><span class="lineNum">    8931 </span>            :   // of variables that might be members (e.g. &quot;X x; x.A::y;&quot; instead of &quot;A::y&quot; (which is just simple name qualification)).</a>
<a name="8932"><span class="lineNum">    8932 </span>            : </a>
<a name="8933"><span class="lineNum">    8933 </span>            :   // DQ (2/8/2019): Adding support for detecting when to use added name qualification for pointer-to-member expressions.</a>
<a name="8934"><span class="lineNum">    8934 </span>            : </a>
<a name="8935"><span class="lineNum">    8935 </span>            :   // DQ (2/17/2019): I think we need to make sure this is not a static data member reference (since those are qualified</a>
<a name="8936"><span class="lineNum">    8936 </span>            :   // differently (not member data name qualification).  Consider changing the name of this function to indicate non-static.</a>
<a name="8937"><span class="lineNum">    8937 </span>            : </a>
<a name="8938"><span class="lineNum">    8938 </span>            : #define DEBUG_IS_DATA_MEMBER_REFERENCE 0</a>
<a name="8939"><span class="lineNum">    8939 </span>            : </a>
<a name="8940"><span class="lineNum">    8940 </span><span class="lineCov">      71441 :      ROSE_ASSERT(varRefExp != NULL);</span></a>
<a name="8941"><span class="lineNum">    8941 </span>            : </a>
<a name="8942"><span class="lineNum">    8942 </span><span class="lineCov">      71441 :      bool returnValue = false;</span></a>
<a name="8943"><span class="lineNum">    8943 </span>            : </a>
<a name="8944"><span class="lineNum">    8944 </span>            :   // Check that this is a data member access (e.g. &quot;X x; x.member;&quot;) and not just a reference to a data member (e.g. &quot;X::member;&quot;)</a>
<a name="8945"><span class="lineNum">    8945 </span><span class="lineCov">      71441 :      SgNode* parent = varRefExp-&gt;get_parent();</span></a>
<a name="8946"><span class="lineNum">    8946 </span>            : </a>
<a name="8947"><span class="lineNum">    8947 </span><span class="lineCov">      71441 :      SgArrowExp* arrowExp = isSgArrowExp(parent);</span></a>
<a name="8948"><span class="lineNum">    8948 </span><span class="lineCov">      71441 :      SgDotExp*   dotExp   = isSgDotExp(parent);</span></a>
<a name="8949"><span class="lineNum">    8949 </span>            : </a>
<a name="8950"><span class="lineNum">    8950 </span><span class="lineCov">      71441 :      SgAddressOfOp* addressOfOp = isSgAddressOfOp(parent);</span></a>
<a name="8951"><span class="lineNum">    8951 </span>            : </a>
<a name="8952"><span class="lineNum">    8952 </span>            :   // if (arrowExp != NULL || dotExp != NULL)</a>
<a name="8953"><span class="lineNum">    8953 </span><span class="lineCov">      71441 :      if (arrowExp != NULL || dotExp != NULL || addressOfOp != NULL)</span></a>
<a name="8954"><span class="lineNum">    8954 </span>            :         {</a>
<a name="8955"><span class="lineNum">    8955 </span><span class="lineCov">      18947 :           if (arrowExp != NULL)</span></a>
<a name="8956"><span class="lineNum">    8956 </span>            :              {</a>
<a name="8957"><span class="lineNum">    8957 </span>            :             // DQ (2/17/2019): Check if this is part of a sizeof operand for which is is_objectless_nonstatic_data_member_reference == true.</a>
<a name="8958"><span class="lineNum">    8958 </span><span class="lineCov">       9654 :                SgNode* parentOfArrowExp = arrowExp-&gt;get_parent();</span></a>
<a name="8959"><span class="lineNum">    8959 </span><span class="lineCov">       9654 :                ROSE_ASSERT(parentOfArrowExp != NULL);</span></a>
<a name="8960"><span class="lineNum">    8960 </span><span class="lineCov">       9654 :                SgSizeOfOp* sizeOfOp = isSgSizeOfOp(parentOfArrowExp);</span></a>
<a name="8961"><span class="lineNum">    8961 </span><span class="lineCov">       9654 :                if (sizeOfOp != NULL &amp;&amp; sizeOfOp-&gt;get_is_objectless_nonstatic_data_member_reference() == true)</span></a>
<a name="8962"><span class="lineNum">    8962 </span>            :                   {</a>
<a name="8963"><span class="lineNum">    8963 </span>            :                  // This is not to be qualified using data member name qualification (it should use standard name qualification).</a>
<a name="8964"><span class="lineNum">    8964 </span>            : #if DEBUG_IS_DATA_MEMBER_REFERENCE</a>
<a name="8965"><span class="lineNum">    8965 </span>            :                     printf (&quot;In SageInterface::isDataMemberReference(): Found case of expression used in sizeof with objectless_nonstatic_data_member_reference \n&quot;);</a>
<a name="8966"><span class="lineNum">    8966 </span>            : #endif</a>
<a name="8967"><span class="lineNum">    8967 </span>            :                     return false;</a>
<a name="8968"><span class="lineNum">    8968 </span>            :                   }</a>
<a name="8969"><span class="lineNum">    8969 </span>            :              }</a>
<a name="8970"><span class="lineNum">    8970 </span>            : </a>
<a name="8971"><span class="lineNum">    8971 </span><span class="lineCov">      18947 :           SgVariableSymbol* symbol = varRefExp-&gt;get_symbol();</span></a>
<a name="8972"><span class="lineNum">    8972 </span><span class="lineCov">      18947 :           ROSE_ASSERT(symbol != NULL);</span></a>
<a name="8973"><span class="lineNum">    8973 </span>            : </a>
<a name="8974"><span class="lineNum">    8974 </span><span class="lineCov">      18947 :           SgInitializedName* initializedName = symbol-&gt;get_declaration();</span></a>
<a name="8975"><span class="lineNum">    8975 </span><span class="lineCov">      18947 :           ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="8976"><span class="lineNum">    8976 </span>            : </a>
<a name="8977"><span class="lineNum">    8977 </span>            :        // Check if this is a statically declared variable.</a>
<a name="8978"><span class="lineNum">    8978 </span><span class="lineCov">      18947 :           SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</span></a>
<a name="8979"><span class="lineNum">    8979 </span><span class="lineCov">      18947 :           if (variableDeclaration != NULL)</span></a>
<a name="8980"><span class="lineNum">    8980 </span>            :              {</a>
<a name="8981"><span class="lineNum">    8981 </span><span class="lineCov">      12175 :                bool isStatic = variableDeclaration-&gt;get_declarationModifier().get_storageModifier().isStatic();</span></a>
<a name="8982"><span class="lineNum">    8982 </span><span class="lineCov">      12175 :                if (isStatic == false)</span></a>
<a name="8983"><span class="lineNum">    8983 </span>            :                   {</a>
<a name="8984"><span class="lineNum">    8984 </span><span class="lineCov">      12175 :                     SgScopeStatement* scope = initializedName-&gt;get_scope();</span></a>
<a name="8985"><span class="lineNum">    8985 </span><span class="lineCov">      12175 :                     ROSE_ASSERT(scope != NULL);</span></a>
<a name="8986"><span class="lineNum">    8986 </span>            : </a>
<a name="8987"><span class="lineNum">    8987 </span><span class="lineCov">      12175 :                     SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="8988"><span class="lineNum">    8988 </span><span class="lineCov">      12175 :                     if (classDefinition != NULL)</span></a>
<a name="8989"><span class="lineNum">    8989 </span>            :                        {</a>
<a name="8990"><span class="lineNum">    8990 </span><span class="lineCov">      10332 :                          returnValue = true;</span></a>
<a name="8991"><span class="lineNum">    8991 </span>            :                        }</a>
<a name="8992"><span class="lineNum">    8992 </span>            :                   }</a>
<a name="8993"><span class="lineNum">    8993 </span>            :              }</a>
<a name="8994"><span class="lineNum">    8994 </span>            :             else</a>
<a name="8995"><span class="lineNum">    8995 </span>            :              {</a>
<a name="8996"><span class="lineNum">    8996 </span>            : #if DEBUG_IS_DATA_MEMBER_REFERENCE</a>
<a name="8997"><span class="lineNum">    8997 </span>            :                printf (&quot;In SageInterface::isDataMemberReference(): varRefExp is not associated with variableDeclaration (could not compute if it is static data member) \n&quot;);</a>
<a name="8998"><span class="lineNum">    8998 </span>            : #endif</a>
<a name="8999"><span class="lineNum">    8999 </span>            :              }</a>
<a name="9000"><span class="lineNum">    9000 </span>            :         }</a>
<a name="9001"><span class="lineNum">    9001 </span>            :        else</a>
<a name="9002"><span class="lineNum">    9002 </span>            :         {</a>
<a name="9003"><span class="lineNum">    9003 </span>            : #if DEBUG_IS_DATA_MEMBER_REFERENCE</a>
<a name="9004"><span class="lineNum">    9004 </span>            :           printf (&quot;In SageInterface::isDataMemberReference(): varRefExp parent is not a is not SgArrowExp or SgDotExp expression \n&quot;);</a>
<a name="9005"><span class="lineNum">    9005 </span>            : #endif</a>
<a name="9006"><span class="lineNum">    9006 </span>            :         }</a>
<a name="9007"><span class="lineNum">    9007 </span>            : </a>
<a name="9008"><span class="lineNum">    9008 </span>            : #if DEBUG_IS_DATA_MEMBER_REFERENCE</a>
<a name="9009"><span class="lineNum">    9009 </span>            :      printf (&quot;Leaving SageInterface::isDataMemberReference(): returnValue = %s \n&quot;,returnValue ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9010"><span class="lineNum">    9010 </span>            : #endif</a>
<a name="9011"><span class="lineNum">    9011 </span>            : </a>
<a name="9012"><span class="lineNum">    9012 </span>            :      return returnValue;</a>
<a name="9013"><span class="lineNum">    9013 </span>            :    }</a>
<a name="9014"><span class="lineNum">    9014 </span>            : </a>
<a name="9015"><span class="lineNum">    9015 </span>            : </a>
<a name="9016"><span class="lineNum">    9016 </span>            : #if 0</a>
<a name="9017"><span class="lineNum">    9017 </span>            : bool</a>
<a name="9018"><span class="lineNum">    9018 </span>            : SageInterface::isAddressTaken(SgVarRefExp* varRefExp)</a>
<a name="9019"><span class="lineNum">    9019 </span>            :    {</a>
<a name="9020"><span class="lineNum">    9020 </span>            :   // DQ (2/8/2019): Adding support for detecting when to use added name qualification for pointer-to-member expressions.</a>
<a name="9021"><span class="lineNum">    9021 </span>            :      ROSE_ASSERT(varRefExp != NULL);</a>
<a name="9022"><span class="lineNum">    9022 </span>            : </a>
<a name="9023"><span class="lineNum">    9023 </span>            :      bool returnValue = false;</a>
<a name="9024"><span class="lineNum">    9024 </span>            : </a>
<a name="9025"><span class="lineNum">    9025 </span>            :      SgAddressOfOp* addressOfOp = isSgAddressOfOp(varRefExp-&gt;get_parent());</a>
<a name="9026"><span class="lineNum">    9026 </span>            : </a>
<a name="9027"><span class="lineNum">    9027 </span>            :      if (addressOfOp != NULL)</a>
<a name="9028"><span class="lineNum">    9028 </span>            :         {</a>
<a name="9029"><span class="lineNum">    9029 </span>            :           returnValue = true;</a>
<a name="9030"><span class="lineNum">    9030 </span>            :         }</a>
<a name="9031"><span class="lineNum">    9031 </span>            : </a>
<a name="9032"><span class="lineNum">    9032 </span>            :      return returnValue;</a>
<a name="9033"><span class="lineNum">    9033 </span>            :    }</a>
<a name="9034"><span class="lineNum">    9034 </span>            : #endif</a>
<a name="9035"><span class="lineNum">    9035 </span>            : </a>
<a name="9036"><span class="lineNum">    9036 </span>            : bool</a>
<a name="9037"><span class="lineNum">    9037 </span><span class="lineCov">      71436 : SageInterface::isAddressTaken(SgExpression* refExp)</span></a>
<a name="9038"><span class="lineNum">    9038 </span>            :    {</a>
<a name="9039"><span class="lineNum">    9039 </span>            :   // DQ (2/17/2019): Need to generalize this function to apply to member functions references as well.</a>
<a name="9040"><span class="lineNum">    9040 </span>            : </a>
<a name="9041"><span class="lineNum">    9041 </span>            :   // The input must be one of these two, then this function is suficiently general to support name qualification requirements for both.</a>
<a name="9042"><span class="lineNum">    9042 </span><span class="lineCov">      71436 :      SgVarRefExp*            varRefExp            = isSgVarRefExp(refExp);</span></a>
<a name="9043"><span class="lineNum">    9043 </span><span class="lineCov">      71436 :      SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(refExp);</span></a>
<a name="9044"><span class="lineNum">    9044 </span>            : </a>
<a name="9045"><span class="lineNum">    9045 </span><span class="lineCov">      71436 :      ROSE_ASSERT(varRefExp != NULL || memberFunctionRefExp != NULL);</span></a>
<a name="9046"><span class="lineNum">    9046 </span>            : </a>
<a name="9047"><span class="lineNum">    9047 </span>            :   // DQ (2/8/2019): Adding support for detecting when to use added name qualification for pointer-to-member expressions.</a>
<a name="9048"><span class="lineNum">    9048 </span>            :   // ROSE_ASSERT(varRefExp != NULL);</a>
<a name="9049"><span class="lineNum">    9049 </span><span class="lineCov">      71436 :      ROSE_ASSERT(refExp != NULL);</span></a>
<a name="9050"><span class="lineNum">    9050 </span>            : </a>
<a name="9051"><span class="lineNum">    9051 </span><span class="lineCov">      71436 :      bool returnValue = false;</span></a>
<a name="9052"><span class="lineNum">    9052 </span>            : </a>
<a name="9053"><span class="lineNum">    9053 </span>            :   // SgAddressOfOp* addressOfOp = isSgAddressOfOp(varRefExp-&gt;get_parent());</a>
<a name="9054"><span class="lineNum">    9054 </span><span class="lineCov">      71436 :      SgAddressOfOp* addressOfOp = isSgAddressOfOp(refExp-&gt;get_parent());</span></a>
<a name="9055"><span class="lineNum">    9055 </span>            : </a>
<a name="9056"><span class="lineNum">    9056 </span><span class="lineCov">      71436 :      if (addressOfOp != NULL)</span></a>
<a name="9057"><span class="lineNum">    9057 </span>            :         {</a>
<a name="9058"><span class="lineNum">    9058 </span><span class="lineCov">        361 :           returnValue = true;</span></a>
<a name="9059"><span class="lineNum">    9059 </span>            :         }</a>
<a name="9060"><span class="lineNum">    9060 </span>            : </a>
<a name="9061"><span class="lineNum">    9061 </span><span class="lineCov">      71436 :      return returnValue;</span></a>
<a name="9062"><span class="lineNum">    9062 </span>            :    }</a>
<a name="9063"><span class="lineNum">    9063 </span>            : </a>
<a name="9064"><span class="lineNum">    9064 </span><span class="lineCov">        229 : SgFile * SageInterface::getEnclosingFileNode(SgNode* astNode)</span></a>
<a name="9065"><span class="lineNum">    9065 </span>            :    {</a>
<a name="9066"><span class="lineNum">    9066 </span>            :   // DQ (3/4/2014): This new version of this function supports both C/C++ and also Java.</a>
<a name="9067"><span class="lineNum">    9067 </span>            :   // If the SgJavaPackageDeclaration is noticed then the previous parent is a</a>
<a name="9068"><span class="lineNum">    9068 </span>            :   // SgClassDefinition and the previous previous parent is a SgClassDeclaration whose</a>
<a name="9069"><span class="lineNum">    9069 </span>            :   // name can be used to match the filename in the SgProject's list of files.</a>
<a name="9070"><span class="lineNum">    9070 </span>            :   // A better implementation usign an attribute (not in place until tomorrow) and</a>
<a name="9071"><span class="lineNum">    9071 </span>            :   // from the attribute the pointer to the associated file is directly available.</a>
<a name="9072"><span class="lineNum">    9072 </span>            :   // The later implementation is as fast as possible.</a>
<a name="9073"><span class="lineNum">    9073 </span>            : </a>
<a name="9074"><span class="lineNum">    9074 </span><span class="lineCov">        229 :      ROSE_ASSERT (astNode != NULL);</span></a>
<a name="9075"><span class="lineNum">    9075 </span>            : </a>
<a name="9076"><span class="lineNum">    9076 </span>            :   // Make sure this is not a project node (since the SgFile exists below</a>
<a name="9077"><span class="lineNum">    9077 </span>            :   // the project and could not be found by a traversal of the parent list)</a>
<a name="9078"><span class="lineNum">    9078 </span><span class="lineCov">        229 :      ROSE_ASSERT (isSgProject(astNode) == NULL);</span></a>
<a name="9079"><span class="lineNum">    9079 </span>            : </a>
<a name="9080"><span class="lineNum">    9080 </span><span class="lineCov">        229 :      SgNode* previous_parent = NULL;</span></a>
<a name="9081"><span class="lineNum">    9081 </span><span class="lineCov">        229 :      SgNode* previous_previous_parent = NULL;</span></a>
<a name="9082"><span class="lineNum">    9082 </span>            : </a>
<a name="9083"><span class="lineNum">    9083 </span><span class="lineCov">        229 :      SgNode* parent = astNode;</span></a>
<a name="9084"><span class="lineNum">    9084 </span>            :   // while ( (parent != NULL) &amp;&amp; (isSgFile(parent) == NULL) )</a>
<a name="9085"><span class="lineNum">    9085 </span><span class="lineCov">       1192 :      while ( (parent != NULL) &amp;&amp; (isSgFile(parent) == NULL) )</span></a>
<a name="9086"><span class="lineNum">    9086 </span>            :         {</a>
<a name="9087"><span class="lineNum">    9087 </span>            : #if 0</a>
<a name="9088"><span class="lineNum">    9088 </span>            :           printf (&quot;In getEnclosingFileNode(): parent = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="9089"><span class="lineNum">    9089 </span>            : #endif</a>
<a name="9090"><span class="lineNum">    9090 </span><span class="lineCov">        963 :           previous_previous_parent = previous_parent;</span></a>
<a name="9091"><span class="lineNum">    9091 </span><span class="lineCov">        963 :           previous_parent = parent;</span></a>
<a name="9092"><span class="lineNum">    9092 </span>            : </a>
<a name="9093"><span class="lineNum">    9093 </span><span class="lineCov">        963 :           parent = parent-&gt;get_parent();</span></a>
<a name="9094"><span class="lineNum">    9094 </span>            :         }</a>
<a name="9095"><span class="lineNum">    9095 </span>            : </a>
<a name="9096"><span class="lineNum">    9096 </span><span class="lineCov">        229 :      if (previous_previous_parent != NULL &amp;&amp; previous_parent != NULL )</span></a>
<a name="9097"><span class="lineNum">    9097 </span>            :         {</a>
<a name="9098"><span class="lineNum">    9098 </span>            :        // This is for a Java program and is contained within a SgJavaPackageDeclaration</a>
<a name="9099"><span class="lineNum">    9099 </span>            : #if 0</a>
<a name="9100"><span class="lineNum">    9100 </span>            :           printf (&quot;parent                   = %p = %s \n&quot;,parent,parent-&gt;class_name().c_str());</a>
<a name="9101"><span class="lineNum">    9101 </span>            :           printf (&quot;previous_parent          = %p = %s \n&quot;,previous_parent,previous_parent-&gt;class_name().c_str());</a>
<a name="9102"><span class="lineNum">    9102 </span>            :           printf (&quot;previous_previous_parent = %p = %s \n&quot;,previous_previous_parent,previous_previous_parent-&gt;class_name().c_str());</a>
<a name="9103"><span class="lineNum">    9103 </span>            : #endif</a>
<a name="9104"><span class="lineNum">    9104 </span><span class="lineCov">        222 :           SgClassDeclaration* classDeclaration = isSgClassDeclaration(previous_previous_parent);</span></a>
<a name="9105"><span class="lineNum">    9105 </span><span class="lineCov">        222 :           if (classDeclaration != NULL)</span></a>
<a name="9106"><span class="lineNum">    9106 </span>            :              {</a>
<a name="9107"><span class="lineNum">    9107 </span>            : #if 0</a>
<a name="9108"><span class="lineNum">    9108 </span>            :                printf (&quot;Class name = %p = %s = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str(),classDeclaration-&gt;get_name().str());</a>
<a name="9109"><span class="lineNum">    9109 </span>            : #endif</a>
<a name="9110"><span class="lineNum">    9110 </span>            :             // Find the associated Java class file.</a>
<a name="9111"><span class="lineNum">    9111 </span>            : #if 0</a>
<a name="9112"><span class="lineNum">    9112 </span>            :             // DQ (3/4/2014): This is the code we want to use until we get Philippe's branch in place with the attribute.</a>
<a name="9113"><span class="lineNum">    9113 </span>            :                SgProject* project = TransformationSupport::getProject(parent);</a>
<a name="9114"><span class="lineNum">    9114 </span>            :                ROSE_ASSERT(project != NULL);</a>
<a name="9115"><span class="lineNum">    9115 </span>            :                SgFileList* fileList = project-&gt;get_fileList_ptr();</a>
<a name="9116"><span class="lineNum">    9116 </span>            :                ROSE_ASSERT(fileList != NULL);</a>
<a name="9117"><span class="lineNum">    9117 </span>            :                SgFilePtrList &amp; vectorFile = fileList-&gt;get_listOfFiles();</a>
<a name="9118"><span class="lineNum">    9118 </span>            : #if 0</a>
<a name="9119"><span class="lineNum">    9119 </span>            :                printf (&quot;Output list of files: \n&quot;);</a>
<a name="9120"><span class="lineNum">    9120 </span>            : #endif</a>
<a name="9121"><span class="lineNum">    9121 </span>            :                SgFilePtrList::iterator i = vectorFile.begin();</a>
<a name="9122"><span class="lineNum">    9122 </span>            :                while (i != vectorFile.end())</a>
<a name="9123"><span class="lineNum">    9123 </span>            :                   {</a>
<a name="9124"><span class="lineNum">    9124 </span>            :                     SgFile* file = *i;</a>
<a name="9125"><span class="lineNum">    9125 </span>            :                     ROSE_ASSERT(file != NULL);</a>
<a name="9126"><span class="lineNum">    9126 </span>            : #if 0</a>
<a name="9127"><span class="lineNum">    9127 </span>            :                     printf (&quot;   --- filename = %s \n&quot;,file-&gt;getFileName().c_str());</a>
<a name="9128"><span class="lineNum">    9128 </span>            : #endif</a>
<a name="9129"><span class="lineNum">    9129 </span>            :                     string filename            = file-&gt;getFileName();</a>
<a name="9130"><span class="lineNum">    9130 </span>            :                     string filenameWithoutPath = file-&gt;get_sourceFileNameWithoutPath();</a>
<a name="9131"><span class="lineNum">    9131 </span>            :                     string classname           = classDeclaration-&gt;get_name();</a>
<a name="9132"><span class="lineNum">    9132 </span>            :                     string matchingfilename    = classname + &quot;.java&quot;;</a>
<a name="9133"><span class="lineNum">    9133 </span>            : #if 0</a>
<a name="9134"><span class="lineNum">    9134 </span>            :                     printf (&quot;   ---   --- filename            = %s \n&quot;,filename.c_str());</a>
<a name="9135"><span class="lineNum">    9135 </span>            :                     printf (&quot;   ---   --- filenameWithoutPath = %s \n&quot;,filenameWithoutPath.c_str());</a>
<a name="9136"><span class="lineNum">    9136 </span>            :                     printf (&quot;   ---   --- classname           = %s \n&quot;,classname.c_str());</a>
<a name="9137"><span class="lineNum">    9137 </span>            :                     printf (&quot;   ---   --- matchingfilename    = %s \n&quot;,matchingfilename.c_str());</a>
<a name="9138"><span class="lineNum">    9138 </span>            : #endif</a>
<a name="9139"><span class="lineNum">    9139 </span>            :                     if (filenameWithoutPath == matchingfilename)</a>
<a name="9140"><span class="lineNum">    9140 </span>            :                        {</a>
<a name="9141"><span class="lineNum">    9141 </span>            : #if 0</a>
<a name="9142"><span class="lineNum">    9142 </span>            :                          printf (&quot;   return file = %p \n&quot;,file);</a>
<a name="9143"><span class="lineNum">    9143 </span>            : #endif</a>
<a name="9144"><span class="lineNum">    9144 </span>            :                          return file;</a>
<a name="9145"><span class="lineNum">    9145 </span>            :                        }</a>
<a name="9146"><span class="lineNum">    9146 </span>            : </a>
<a name="9147"><span class="lineNum">    9147 </span>            :                     i++;</a>
<a name="9148"><span class="lineNum">    9148 </span>            :                   }</a>
<a name="9149"><span class="lineNum">    9149 </span>            : #else</a>
<a name="9150"><span class="lineNum">    9150 </span>            :             // DQ (3/4/2014): This is the code we want to use when the attribute is in place (philippe's branch).</a>
<a name="9151"><span class="lineNum">    9151 </span><span class="lineNoCov">          0 :                AstSgNodeAttribute *attribute = (AstSgNodeAttribute *) classDeclaration-&gt;getAttribute(&quot;sourcefile&quot;);</span></a>
<a name="9152"><span class="lineNum">    9152 </span>            : </a>
<a name="9153"><span class="lineNum">    9153 </span>            :                // &quot;This simpler and more efficent code requires the latest work in Java support (3/6/2014)&quot;</a>
<a name="9154"><span class="lineNum">    9154 </span>            : </a>
<a name="9155"><span class="lineNum">    9155 </span><span class="lineNoCov">          0 :                if (attribute)</span></a>
<a name="9156"><span class="lineNum">    9156 </span>            :                   {</a>
<a name="9157"><span class="lineNum">    9157 </span>            :                  // true for all user-specified classes and false for all classes fom libraries</a>
<a name="9158"><span class="lineNum">    9158 </span><span class="lineNoCov">          0 :                     SgSourceFile *sourcefile = isSgSourceFile(attribute-&gt;getNode());</span></a>
<a name="9159"><span class="lineNum">    9159 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(sourcefile != NULL);</span></a>
<a name="9160"><span class="lineNum">    9160 </span><span class="lineNoCov">          0 :                     return sourcefile;</span></a>
<a name="9161"><span class="lineNum">    9161 </span>            :                   }</a>
<a name="9162"><span class="lineNum">    9162 </span>            : #endif</a>
<a name="9163"><span class="lineNum">    9163 </span>            :              }</a>
<a name="9164"><span class="lineNum">    9164 </span>            :         }</a>
<a name="9165"><span class="lineNum">    9165 </span>            :        else</a>
<a name="9166"><span class="lineNum">    9166 </span>            :         {</a>
<a name="9167"><span class="lineNum">    9167 </span>            :         }</a>
<a name="9168"><span class="lineNum">    9168 </span>            : </a>
<a name="9169"><span class="lineNum">    9169 </span>            :   // This is where we handle the C/C++ files.</a>
<a name="9170"><span class="lineNum">    9170 </span>            :   // if (!parent)</a>
<a name="9171"><span class="lineNum">    9171 </span><span class="lineCov">        229 :      if (parent == NULL)</span></a>
<a name="9172"><span class="lineNum">    9172 </span>            :         {</a>
<a name="9173"><span class="lineNum">    9173 </span>            :           return NULL;</a>
<a name="9174"><span class="lineNum">    9174 </span>            :         }</a>
<a name="9175"><span class="lineNum">    9175 </span>            :        else</a>
<a name="9176"><span class="lineNum">    9176 </span>            :         {</a>
<a name="9177"><span class="lineNum">    9177 </span><span class="lineCov">        229 :           return isSgFile(parent);</span></a>
<a name="9178"><span class="lineNum">    9178 </span>            :         }</a>
<a name="9179"><span class="lineNum">    9179 </span>            :    }</a>
<a name="9180"><span class="lineNum">    9180 </span>            : </a>
<a name="9181"><span class="lineNum">    9181 </span><span class="lineCov">          2 : std::set&lt;SgNode*&gt; SageInterface::getFrontendSpecificNodes() {</span></a>
<a name="9182"><span class="lineNum">    9182 </span><span class="lineCov">          2 :   struct FrontendSpecificTraversal : public ROSE_VisitTraversal {</span></a>
<a name="9183"><span class="lineNum">    9183 </span>            :     std::set&lt;SgNode*&gt; specific;</a>
<a name="9184"><span class="lineNum">    9184 </span>            :     std::set&lt;SgNode*&gt; non_specific;</a>
<a name="9185"><span class="lineNum">    9185 </span>            : </a>
<a name="9186"><span class="lineNum">    9186 </span><span class="lineCov">         53 :     static void recursive_collect( SgNode* node , std::set&lt;SgNode *&gt; &amp; collection ) {</span></a>
<a name="9187"><span class="lineNum">    9187 </span>            :       // Stop on sinks and loops</a>
<a name="9188"><span class="lineNum">    9188 </span><span class="lineCov">        106 :       if (node == NULL || !collection.insert(node).second) return;</span></a>
<a name="9189"><span class="lineNum">    9189 </span>            : </a>
<a name="9190"><span class="lineNum">    9190 </span><span class="lineNoCov">          0 :       std::vector&lt;std::pair&lt;SgNode*, std::string&gt; &gt; data_members = node-&gt;returnDataMemberPointers();</span></a>
<a name="9191"><span class="lineNum">    9191 </span><span class="lineNoCov">          0 :       for (std::vector&lt;std::pair&lt;SgNode*, std::string&gt; &gt;::iterator i = data_members.begin(); i != data_members.end(); ++i) {</span></a>
<a name="9192"><span class="lineNum">    9192 </span><span class="lineNoCov">          0 :         recursive_collect(i-&gt;first, collection);</span></a>
<a name="9193"><span class="lineNum">    9193 </span>            :       }</a>
<a name="9194"><span class="lineNum">    9194 </span>            :     }</a>
<a name="9195"><span class="lineNum">    9195 </span>            : </a>
<a name="9196"><span class="lineNum">    9196 </span><span class="lineCov">        307 :     void visit (SgNode* n) {</span></a>
<a name="9197"><span class="lineNum">    9197 </span><span class="lineCov">        307 :       Sg_File_Info * fileInfo = n-&gt;get_file_info();</span></a>
<a name="9198"><span class="lineNum">    9198 </span>            : </a>
<a name="9199"><span class="lineNum">    9199 </span><span class="lineCov">        307 :       if (fileInfo != NULL) {</span></a>
<a name="9200"><span class="lineNum">    9200 </span><span class="lineCov">         53 :         if (fileInfo-&gt;isFrontendSpecific()) {</span></a>
<a name="9201"><span class="lineNum">    9201 </span><span class="lineNoCov">          0 :           specific.insert(n);</span></a>
<a name="9202"><span class="lineNum">    9202 </span><span class="lineNoCov">          0 :           recursive_collect(n, specific);</span></a>
<a name="9203"><span class="lineNum">    9203 </span>            :         } else {</a>
<a name="9204"><span class="lineNum">    9204 </span><span class="lineCov">         53 :           non_specific.insert(n);</span></a>
<a name="9205"><span class="lineNum">    9205 </span><span class="lineCov">         53 :           recursive_collect(n, non_specific);</span></a>
<a name="9206"><span class="lineNum">    9206 </span>            :         }</a>
<a name="9207"><span class="lineNum">    9207 </span>            :       } else {</a>
<a name="9208"><span class="lineNum">    9208 </span><span class="lineCov">        254 :         fileInfo = isSg_File_Info(n);</span></a>
<a name="9209"><span class="lineNum">    9209 </span><span class="lineCov">        254 :         if (fileInfo != NULL) {</span></a>
<a name="9210"><span class="lineNum">    9210 </span><span class="lineCov">        165 :           if (fileInfo-&gt;isFrontendSpecific()) {</span></a>
<a name="9211"><span class="lineNum">    9211 </span><span class="lineNoCov">          0 :             specific.insert(n);</span></a>
<a name="9212"><span class="lineNum">    9212 </span>            :           } else {</a>
<a name="9213"><span class="lineNum">    9213 </span><span class="lineCov">        165 :             non_specific.insert(n);</span></a>
<a name="9214"><span class="lineNum">    9214 </span>            :           }</a>
<a name="9215"><span class="lineNum">    9215 </span>            :         }</a>
<a name="9216"><span class="lineNum">    9216 </span>            :       }</a>
<a name="9217"><span class="lineNum">    9217 </span><span class="lineCov">        307 :     }</span></a>
<a name="9218"><span class="lineNum">    9218 </span>            : </a>
<a name="9219"><span class="lineNum">    9219 </span><span class="lineCov">          2 :     std::set&lt;SgNode*&gt; apply() {</span></a>
<a name="9220"><span class="lineNum">    9220 </span><span class="lineCov">          2 :       traverseMemoryPool();</span></a>
<a name="9221"><span class="lineNum">    9221 </span>            : </a>
<a name="9222"><span class="lineNum">    9222 </span><span class="lineCov">          2 :       std::set&lt;SgNode*&gt; result;</span></a>
<a name="9223"><span class="lineNum">    9223 </span>            : </a>
<a name="9224"><span class="lineNum">    9224 </span><span class="lineCov">          2 :       std::set_difference(</span></a>
<a name="9225"><span class="lineNum">    9225 </span>            :         specific.begin(), specific.end(),</a>
<a name="9226"><span class="lineNum">    9226 </span>            :         non_specific.begin(), non_specific.end(),</a>
<a name="9227"><span class="lineNum">    9227 </span>            :         std::insert_iterator&lt;set&lt;SgNode*&gt; &gt;(result, result.begin())</a>
<a name="9228"><span class="lineNum">    9228 </span><span class="lineCov">          2 :       );</span></a>
<a name="9229"><span class="lineNum">    9229 </span>            : </a>
<a name="9230"><span class="lineNum">    9230 </span><span class="lineCov">          2 :       return result;</span></a>
<a name="9231"><span class="lineNum">    9231 </span>            :     }</a>
<a name="9232"><span class="lineNum">    9232 </span>            :   };</a>
<a name="9233"><span class="lineNum">    9233 </span>            : </a>
<a name="9234"><span class="lineNum">    9234 </span><span class="lineCov">          2 :   FrontendSpecificTraversal fst;</span></a>
<a name="9235"><span class="lineNum">    9235 </span><span class="lineCov">          4 :   return fst.apply();</span></a>
<a name="9236"><span class="lineNum">    9236 </span>            : }</a>
<a name="9237"><span class="lineNum">    9237 </span>            : </a>
<a name="9238"><span class="lineNum">    9238 </span>            : void</a>
<a name="9239"><span class="lineNum">    9239 </span><span class="lineNoCov">          0 : SageInterface::outputSharedNodes( SgNode* node )</span></a>
<a name="9240"><span class="lineNum">    9240 </span>            :    {</a>
<a name="9241"><span class="lineNum">    9241 </span>            :   // DQ (2/17/2019): Display the shared nodes in the AST for debugging.</a>
<a name="9242"><span class="lineNum">    9242 </span>            : </a>
<a name="9243"><span class="lineNum">    9243 </span><span class="lineNoCov">          0 :      class OutputSharedNodesTraversal : public SgSimpleProcessing</span></a>
<a name="9244"><span class="lineNum">    9244 </span>            :         {</a>
<a name="9245"><span class="lineNum">    9245 </span>            :        // This traversal collects the includes at the top of a file.</a>
<a name="9246"><span class="lineNum">    9246 </span>            :           public:</a>
<a name="9247"><span class="lineNum">    9247 </span><span class="lineNoCov">          0 :                void visit(SgNode *astNode)</span></a>
<a name="9248"><span class="lineNum">    9248 </span>            :                   {</a>
<a name="9249"><span class="lineNum">    9249 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(astNode != NULL);</span></a>
<a name="9250"><span class="lineNum">    9250 </span><span class="lineNoCov">          0 :                     Sg_File_Info* file_info = astNode-&gt;get_file_info();</span></a>
<a name="9251"><span class="lineNum">    9251 </span><span class="lineNoCov">          0 :                     if (file_info != NULL)</span></a>
<a name="9252"><span class="lineNum">    9252 </span>            :                        {</a>
<a name="9253"><span class="lineNum">    9253 </span><span class="lineNoCov">          0 :                          if (file_info-&gt;isShared() == true)</span></a>
<a name="9254"><span class="lineNum">    9254 </span>            :                             {</a>
<a name="9255"><span class="lineNum">    9255 </span><span class="lineNoCov">          0 :                               printf (&quot;Found shared node: astNode = %p = %s \n&quot;,astNode,astNode-&gt;class_name().c_str());</span></a>
<a name="9256"><span class="lineNum">    9256 </span>            :                             }</a>
<a name="9257"><span class="lineNum">    9257 </span>            :                        }</a>
<a name="9258"><span class="lineNum">    9258 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="9259"><span class="lineNum">    9259 </span>            :         };</a>
<a name="9260"><span class="lineNum">    9260 </span>            : </a>
<a name="9261"><span class="lineNum">    9261 </span><span class="lineNoCov">          0 :      OutputSharedNodesTraversal tt;</span></a>
<a name="9262"><span class="lineNum">    9262 </span><span class="lineNoCov">          0 :      tt.traverse(node,preorder);</span></a>
<a name="9263"><span class="lineNum">    9263 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9264"><span class="lineNum">    9264 </span>            : </a>
<a name="9265"><span class="lineNum">    9265 </span>            : </a>
<a name="9266"><span class="lineNum">    9266 </span>            : </a>
<a name="9267"><span class="lineNum">    9267 </span>            : </a>
<a name="9268"><span class="lineNum">    9268 </span>            : </a>
<a name="9269"><span class="lineNum">    9269 </span><span class="lineCov">          9 : SgStatement* SageInterface::getEnclosingStatement(SgNode* n) {</span></a>
<a name="9270"><span class="lineNum">    9270 </span><span class="lineCov">         14 :   while (n &amp;&amp; !isSgStatement(n)) n = n-&gt;get_parent();</span></a>
<a name="9271"><span class="lineNum">    9271 </span><span class="lineCov">          9 :   return isSgStatement(n);</span></a>
<a name="9272"><span class="lineNum">    9272 </span>            : }</a>
<a name="9273"><span class="lineNum">    9273 </span>            : </a>
<a name="9274"><span class="lineNum">    9274 </span>            : </a>
<a name="9275"><span class="lineNum">    9275 </span>            : </a>
<a name="9276"><span class="lineNum">    9276 </span>            : #if 1</a>
<a name="9277"><span class="lineNum">    9277 </span>            : // DQ (11/19/2020): We need to expand the use of this to cover deffered transformations of common SageInterface transformations (e.g. replaceStatement).</a>
<a name="9278"><span class="lineNum">    9278 </span>            : // So I need to move this out of being specific to the outliner and make it more generally data structure in the SageInterface.</a>
<a name="9279"><span class="lineNum">    9279 </span>            : </a>
<a name="9280"><span class="lineNum">    9280 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::DeferredTransformation()</span></a>
<a name="9281"><span class="lineNum">    9281 </span>            :    : deferredTransformationKind(e_default),</a>
<a name="9282"><span class="lineNum">    9282 </span>            :      statementToRemove(NULL),</a>
<a name="9283"><span class="lineNum">    9283 </span>            :      statementToAdd(NULL),</a>
<a name="9284"><span class="lineNum">    9284 </span>            :      class_definition(NULL),</a>
<a name="9285"><span class="lineNum">    9285 </span>            :      target_class_member(NULL),</a>
<a name="9286"><span class="lineNum">    9286 </span>            :      new_function_prototype(NULL),</a>
<a name="9287"><span class="lineNum">    9287 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9288"><span class="lineNum">    9288 </span>            :      locationToOverwriteWithTransformation(NULL),</a>
<a name="9289"><span class="lineNum">    9289 </span>            :      transformationToOverwriteFirstStatementInInterval(NULL),</a>
<a name="9290"><span class="lineNum">    9290 </span><span class="lineNoCov">          0 :      blockOfStatementsToOutline(NULL)</span></a>
<a name="9291"><span class="lineNum">    9291 </span>            :    {</a>
<a name="9292"><span class="lineNum">    9292 </span>            :   // Default constructor (not particularly useful).</a>
<a name="9293"><span class="lineNum">    9293 </span>            : #if 0</a>
<a name="9294"><span class="lineNum">    9294 </span>            :      printf (&quot;In SageInterface::DeferredTransformation default constructor called \n&quot;);</a>
<a name="9295"><span class="lineNum">    9295 </span>            : #endif</a>
<a name="9296"><span class="lineNum">    9296 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9297"><span class="lineNum">    9297 </span>            : </a>
<a name="9298"><span class="lineNum">    9298 </span>            : // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9299"><span class="lineNum">    9299 </span>            : // IntervalType statementInterval;</a>
<a name="9300"><span class="lineNum">    9300 </span>            : // SgStatement* locationToOverwriteWithTransformation;</a>
<a name="9301"><span class="lineNum">    9301 </span>            : </a>
<a name="9302"><span class="lineNum">    9302 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::DeferredTransformation(</span></a>
<a name="9303"><span class="lineNum">    9303 </span>            :    SgClassDefinition* input_class_definition,</a>
<a name="9304"><span class="lineNum">    9304 </span>            :    SgDeclarationStatement* input_target_class_member,</a>
<a name="9305"><span class="lineNum">    9305 </span><span class="lineNoCov">          0 :    SgDeclarationStatement* input_new_function_prototype)</span></a>
<a name="9306"><span class="lineNum">    9306 </span>            :    : deferredTransformationKind(e_outliner),</a>
<a name="9307"><span class="lineNum">    9307 </span>            :      statementToRemove(NULL),</a>
<a name="9308"><span class="lineNum">    9308 </span>            :      statementToAdd(NULL),</a>
<a name="9309"><span class="lineNum">    9309 </span>            :      class_definition(input_class_definition),</a>
<a name="9310"><span class="lineNum">    9310 </span>            :      target_class_member(input_target_class_member),</a>
<a name="9311"><span class="lineNum">    9311 </span>            :      new_function_prototype(input_new_function_prototype),</a>
<a name="9312"><span class="lineNum">    9312 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9313"><span class="lineNum">    9313 </span>            :      locationToOverwriteWithTransformation(NULL),</a>
<a name="9314"><span class="lineNum">    9314 </span>            :      transformationToOverwriteFirstStatementInInterval(NULL),</a>
<a name="9315"><span class="lineNum">    9315 </span><span class="lineNoCov">          0 :      blockOfStatementsToOutline(NULL)</span></a>
<a name="9316"><span class="lineNum">    9316 </span>            :    {</a>
<a name="9317"><span class="lineNum">    9317 </span>            :   // This constructor is used by the outliner.</a>
<a name="9318"><span class="lineNum">    9318 </span>            : #if 0</a>
<a name="9319"><span class="lineNum">    9319 </span>            :      printf (&quot;In SageInterface::DeferredTransformation constructor for outliner called \n&quot;);</a>
<a name="9320"><span class="lineNum">    9320 </span>            : #endif</a>
<a name="9321"><span class="lineNum">    9321 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9322"><span class="lineNum">    9322 </span>            : </a>
<a name="9323"><span class="lineNum">    9323 </span>            : SageInterface::DeferredTransformation</a>
<a name="9324"><span class="lineNum">    9324 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::replaceDefiningFunctionDeclarationWithFunctionPrototype( SgFunctionDeclaration* functionDeclaration )</span></a>
<a name="9325"><span class="lineNum">    9325 </span>            :    {</a>
<a name="9326"><span class="lineNum">    9326 </span>            : #if 0</a>
<a name="9327"><span class="lineNum">    9327 </span>            :      printf (&quot;In SageInterface::DeferredTransformation constructor for replaceDefiningFunctionDeclarationWithFunctionPrototype called \n&quot;);</a>
<a name="9328"><span class="lineNum">    9328 </span>            : #endif</a>
<a name="9329"><span class="lineNum">    9329 </span>            :   // DQ (11/20/20): Added new static function to support genertation of deferred transformation.</a>
<a name="9330"><span class="lineNum">    9330 </span>            :   // This constructor is used by tool_G and supports the use of the transformation represented</a>
<a name="9331"><span class="lineNum">    9331 </span>            :   // by SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype().</a>
<a name="9332"><span class="lineNum">    9332 </span><span class="lineNoCov">          0 :      DeferredTransformation X;</span></a>
<a name="9333"><span class="lineNum">    9333 </span><span class="lineNoCov">          0 :      X.deferredTransformationKind = e_replaceDefiningFunctionDeclarationWithFunctionPrototype;</span></a>
<a name="9334"><span class="lineNum">    9334 </span><span class="lineNoCov">          0 :      X.statementToRemove          = functionDeclaration;</span></a>
<a name="9335"><span class="lineNum">    9335 </span><span class="lineNoCov">          0 :      X.statementToAdd             = NULL;</span></a>
<a name="9336"><span class="lineNum">    9336 </span><span class="lineNoCov">          0 :      X.class_definition           = NULL;</span></a>
<a name="9337"><span class="lineNum">    9337 </span><span class="lineNoCov">          0 :      X.target_class_member        = NULL;</span></a>
<a name="9338"><span class="lineNum">    9338 </span><span class="lineNoCov">          0 :      X.new_function_prototype     = NULL;</span></a>
<a name="9339"><span class="lineNum">    9339 </span>            : </a>
<a name="9340"><span class="lineNum">    9340 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9341"><span class="lineNum">    9341 </span>            :   // X.statementInterval;</a>
<a name="9342"><span class="lineNum">    9342 </span><span class="lineNoCov">          0 :      X.locationToOverwriteWithTransformation             = NULL;</span></a>
<a name="9343"><span class="lineNum">    9343 </span><span class="lineNoCov">          0 :      X.transformationToOverwriteFirstStatementInInterval = NULL;</span></a>
<a name="9344"><span class="lineNum">    9344 </span><span class="lineNoCov">          0 :      X.blockOfStatementsToOutline                        = NULL;</span></a>
<a name="9345"><span class="lineNum">    9345 </span>            : </a>
<a name="9346"><span class="lineNum">    9346 </span><span class="lineNoCov">          0 :      return X;</span></a>
<a name="9347"><span class="lineNum">    9347 </span>            :    }</a>
<a name="9348"><span class="lineNum">    9348 </span>            : </a>
<a name="9349"><span class="lineNum">    9349 </span>            : SageInterface::DeferredTransformation</a>
<a name="9350"><span class="lineNum">    9350 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::replaceStatement(SgStatement* oldStmt, SgStatement* newStmt, bool movePreprocessingInfo/* = false*/)</span></a>
<a name="9351"><span class="lineNum">    9351 </span>            :    {</a>
<a name="9352"><span class="lineNum">    9352 </span>            : #if 0</a>
<a name="9353"><span class="lineNum">    9353 </span>            :      printf (&quot;In SageInterface::DeferredTransformation constructor for replaceStatement called \n&quot;);</a>
<a name="9354"><span class="lineNum">    9354 </span>            : #endif</a>
<a name="9355"><span class="lineNum">    9355 </span>            :   // DQ (11/20/20): Added new static function to support genertation of deferred transformation.</a>
<a name="9356"><span class="lineNum">    9356 </span>            :   // This constructor is used by tool_G and supports the use of the transformation represented</a>
<a name="9357"><span class="lineNum">    9357 </span>            :   // by SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype().</a>
<a name="9358"><span class="lineNum">    9358 </span><span class="lineNoCov">          0 :      DeferredTransformation X;</span></a>
<a name="9359"><span class="lineNum">    9359 </span><span class="lineNoCov">          0 :      X.deferredTransformationKind = e_replaceStatement;</span></a>
<a name="9360"><span class="lineNum">    9360 </span><span class="lineNoCov">          0 :      X.statementToRemove          = oldStmt;</span></a>
<a name="9361"><span class="lineNum">    9361 </span><span class="lineNoCov">          0 :      X.statementToAdd             = newStmt;</span></a>
<a name="9362"><span class="lineNum">    9362 </span><span class="lineNoCov">          0 :      X.class_definition           = NULL;</span></a>
<a name="9363"><span class="lineNum">    9363 </span><span class="lineNoCov">          0 :      X.target_class_member        = NULL;</span></a>
<a name="9364"><span class="lineNum">    9364 </span><span class="lineNoCov">          0 :      X.new_function_prototype     = NULL;</span></a>
<a name="9365"><span class="lineNum">    9365 </span>            : </a>
<a name="9366"><span class="lineNum">    9366 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9367"><span class="lineNum">    9367 </span>            :   // X.statementInterval;</a>
<a name="9368"><span class="lineNum">    9368 </span><span class="lineNoCov">          0 :      X.locationToOverwriteWithTransformation = NULL;</span></a>
<a name="9369"><span class="lineNum">    9369 </span><span class="lineNoCov">          0 :      X.transformationToOverwriteFirstStatementInInterval = NULL;</span></a>
<a name="9370"><span class="lineNum">    9370 </span><span class="lineNoCov">          0 :      X.blockOfStatementsToOutline = NULL;</span></a>
<a name="9371"><span class="lineNum">    9371 </span>            : </a>
<a name="9372"><span class="lineNum">    9372 </span><span class="lineNoCov">          0 :      return X;</span></a>
<a name="9373"><span class="lineNum">    9373 </span>            :    }</a>
<a name="9374"><span class="lineNum">    9374 </span>            : </a>
<a name="9375"><span class="lineNum">    9375 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::DeferredTransformation (const DeferredTransformation&amp; X)</span></a>
<a name="9376"><span class="lineNum">    9376 </span>            : #if 0</a>
<a name="9377"><span class="lineNum">    9377 </span>            :    : deferredTransformationKind(X.deferredTransformationKind),</a>
<a name="9378"><span class="lineNum">    9378 </span>            :      statementToRemove(X.statementToRemove),</a>
<a name="9379"><span class="lineNum">    9379 </span>            :      statementToAdd(X.StatementToAdd),</a>
<a name="9380"><span class="lineNum">    9380 </span>            :      class_definition(X.class_definition),</a>
<a name="9381"><span class="lineNum">    9381 </span>            :      target_class_member(X.target_class_member),</a>
<a name="9382"><span class="lineNum">    9382 </span>            :      new_function_prototype(X.new_function_prototype),</a>
<a name="9383"><span class="lineNum">    9383 </span>            :      targetClasses(X.targetClasses),</a>
<a name="9384"><span class="lineNum">    9384 </span>            :      targetFriends(X.targetFriends)</a>
<a name="9385"><span class="lineNum">    9385 </span>            :    {</a>
<a name="9386"><span class="lineNum">    9386 </span>            :    }</a>
<a name="9387"><span class="lineNum">    9387 </span>            : #else</a>
<a name="9388"><span class="lineNum">    9388 </span>            :    {</a>
<a name="9389"><span class="lineNum">    9389 </span>            : #if 0</a>
<a name="9390"><span class="lineNum">    9390 </span>            :      printf (&quot;In SageInterface::DeferredTransformation copy constructor called \n&quot;);</a>
<a name="9391"><span class="lineNum">    9391 </span>            : #endif</a>
<a name="9392"><span class="lineNum">    9392 </span>            :   // DQ (11/19/2020): Leverage the operator=() implementation to reduce complexity (one place to update).</a>
<a name="9393"><span class="lineNum">    9393 </span><span class="lineNoCov">          0 :      *this = X;</span></a>
<a name="9394"><span class="lineNum">    9394 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9395"><span class="lineNum">    9395 </span>            : #endif</a>
<a name="9396"><span class="lineNum">    9396 </span>            : </a>
<a name="9397"><span class="lineNum">    9397 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation &amp; SageInterface::DeferredTransformation::operator= (const DeferredTransformation&amp; X)</span></a>
<a name="9398"><span class="lineNum">    9398 </span>            :    {</a>
<a name="9399"><span class="lineNum">    9399 </span>            : #if 0</a>
<a name="9400"><span class="lineNum">    9400 </span>            :      printf (&quot;Inside of SageInterface::DeferredTransformation::operator= (const DeferredTransformation&amp; X) \n&quot;);</a>
<a name="9401"><span class="lineNum">    9401 </span>            : #endif</a>
<a name="9402"><span class="lineNum">    9402 </span>            : </a>
<a name="9403"><span class="lineNum">    9403 </span>            : #if 0</a>
<a name="9404"><span class="lineNum">    9404 </span>            :   // Original code.</a>
<a name="9405"><span class="lineNum">    9405 </span>            :      targetFriends = X.targetFriends;</a>
<a name="9406"><span class="lineNum">    9406 </span>            :      targetClasses = X.targetClasses;</a>
<a name="9407"><span class="lineNum">    9407 </span>            : #else</a>
<a name="9408"><span class="lineNum">    9408 </span>            : </a>
<a name="9409"><span class="lineNum">    9409 </span>            :   // DQ (12/12/2020): Adding a string label so that we can name the different kinds of transformations.</a>
<a name="9410"><span class="lineNum">    9410 </span>            :   // E.g. moving pattern matched function from header file to dynamic library, vs. replacing function</a>
<a name="9411"><span class="lineNum">    9411 </span>            :   // definitions in the dynamic library file with function prototypes.</a>
<a name="9412"><span class="lineNum">    9412 </span><span class="lineNoCov">          0 :      transformationLabel = X.transformationLabel;</span></a>
<a name="9413"><span class="lineNum">    9413 </span>            : </a>
<a name="9414"><span class="lineNum">    9414 </span>            :   // New code added to support more general usage.</a>
<a name="9415"><span class="lineNum">    9415 </span><span class="lineNoCov">          0 :      deferredTransformationKind = X.deferredTransformationKind;</span></a>
<a name="9416"><span class="lineNum">    9416 </span><span class="lineNoCov">          0 :      statementToRemove          = X.statementToRemove;</span></a>
<a name="9417"><span class="lineNum">    9417 </span><span class="lineNoCov">          0 :      statementToAdd             = X.statementToAdd;</span></a>
<a name="9418"><span class="lineNum">    9418 </span>            : </a>
<a name="9419"><span class="lineNum">    9419 </span><span class="lineNoCov">          0 :      class_definition           = X.class_definition;</span></a>
<a name="9420"><span class="lineNum">    9420 </span><span class="lineNoCov">          0 :      target_class_member        = X.target_class_member;</span></a>
<a name="9421"><span class="lineNum">    9421 </span><span class="lineNoCov">          0 :      new_function_prototype     = X.new_function_prototype;</span></a>
<a name="9422"><span class="lineNum">    9422 </span><span class="lineNoCov">          0 :      targetClasses              = X.targetClasses;</span></a>
<a name="9423"><span class="lineNum">    9423 </span><span class="lineNoCov">          0 :      targetFriends              = X.targetFriends;</span></a>
<a name="9424"><span class="lineNum">    9424 </span>            : </a>
<a name="9425"><span class="lineNum">    9425 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9426"><span class="lineNum">    9426 </span><span class="lineNoCov">          0 :      statementInterval                                 = X.statementInterval;</span></a>
<a name="9427"><span class="lineNum">    9427 </span><span class="lineNoCov">          0 :      locationToOverwriteWithTransformation             = X.locationToOverwriteWithTransformation;</span></a>
<a name="9428"><span class="lineNum">    9428 </span><span class="lineNoCov">          0 :      transformationToOverwriteFirstStatementInInterval = X.transformationToOverwriteFirstStatementInInterval;</span></a>
<a name="9429"><span class="lineNum">    9429 </span>            : </a>
<a name="9430"><span class="lineNum">    9430 </span>            :   // DQ (3/1/2021): Added new data member to support deferred transformations.</a>
<a name="9431"><span class="lineNum">    9431 </span><span class="lineNoCov">          0 :      blockOfStatementsToOutline                        = X.blockOfStatementsToOutline;</span></a>
<a name="9432"><span class="lineNum">    9432 </span>            : #endif</a>
<a name="9433"><span class="lineNum">    9433 </span>            : </a>
<a name="9434"><span class="lineNum">    9434 </span><span class="lineNoCov">          0 :      return *this;</span></a>
<a name="9435"><span class="lineNum">    9435 </span>            :    }</a>
<a name="9436"><span class="lineNum">    9436 </span>            : </a>
<a name="9437"><span class="lineNum">    9437 </span><span class="lineNoCov">          0 : SageInterface::DeferredTransformation::~DeferredTransformation (void)</span></a>
<a name="9438"><span class="lineNum">    9438 </span>            :    {</a>
<a name="9439"><span class="lineNum">    9439 </span>            :    //! Shallow; does not delete fields.</a>
<a name="9440"><span class="lineNum">    9440 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9441"><span class="lineNum">    9441 </span>            : </a>
<a name="9442"><span class="lineNum">    9442 </span><span class="lineNoCov">          0 : std::string SageInterface::DeferredTransformation::outputDeferredTransformationKind(const TransformationKind &amp; kind)</span></a>
<a name="9443"><span class="lineNum">    9443 </span>            :    {</a>
<a name="9444"><span class="lineNum">    9444 </span><span class="lineNoCov">          0 :      string returnValue = &quot;uninitialized&quot;;</span></a>
<a name="9445"><span class="lineNum">    9445 </span><span class="lineNoCov">          0 :      switch (kind)</span></a>
<a name="9446"><span class="lineNum">    9446 </span>            :        {</a>
<a name="9447"><span class="lineNum">    9447 </span><span class="lineNoCov">          0 :          case e_error:                                                   returnValue = &quot;e_error&quot;;            break;</span></a>
<a name="9448"><span class="lineNum">    9448 </span><span class="lineNoCov">          0 :          case e_default:                                                 returnValue = &quot;e_default&quot;;          break;</span></a>
<a name="9449"><span class="lineNum">    9449 </span><span class="lineNoCov">          0 :          case e_outliner:                                                returnValue = &quot;e_outliner&quot;;         break;</span></a>
<a name="9450"><span class="lineNum">    9450 </span><span class="lineNoCov">          0 :          case e_replaceStatement:                                        returnValue = &quot;e_replaceStatement&quot;; break;</span></a>
<a name="9451"><span class="lineNum">    9451 </span><span class="lineNoCov">          0 :          case e_removeStatement:                                         returnValue = &quot;e_removeStatement&quot;;  break;</span></a>
<a name="9452"><span class="lineNum">    9452 </span><span class="lineNoCov">          0 :          case e_replaceDefiningFunctionDeclarationWithFunctionPrototype: returnValue = &quot;e_replaceDefiningFunctionDeclarationWithFunctionPrototype&quot;; break;</span></a>
<a name="9453"><span class="lineNum">    9453 </span><span class="lineNoCov">          0 :          case e_last:                                                    returnValue = &quot;e_last&quot;;             break;</span></a>
<a name="9454"><span class="lineNum">    9454 </span><span class="lineNoCov">          0 :          default:</span></a>
<a name="9455"><span class="lineNum">    9455 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="9456"><span class="lineNum">    9456 </span><span class="lineNoCov">          0 :               printf (&quot;Error: SageInterface::DeferredTransformation::get_deferredTransformationKind_string(): default reached \n&quot;);</span></a>
<a name="9457"><span class="lineNum">    9457 </span><span class="lineNoCov">          0 :               ROSE_ABORT();</span></a>
<a name="9458"><span class="lineNum">    9458 </span>            :             }</a>
<a name="9459"><span class="lineNum">    9459 </span>            :        }</a>
<a name="9460"><span class="lineNum">    9460 </span>            : </a>
<a name="9461"><span class="lineNum">    9461 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="9462"><span class="lineNum">    9462 </span>            :    }</a>
<a name="9463"><span class="lineNum">    9463 </span>            : </a>
<a name="9464"><span class="lineNum">    9464 </span><span class="lineNoCov">          0 : void SageInterface::DeferredTransformation::display ( std::string label ) const</span></a>
<a name="9465"><span class="lineNum">    9465 </span>            :    {</a>
<a name="9466"><span class="lineNum">    9466 </span><span class="lineNoCov">          0 :      printf (&quot;SageInterface::DeferredTransformation::display(): label = %s \n&quot;,label.c_str());</span></a>
<a name="9467"><span class="lineNum">    9467 </span>            : </a>
<a name="9468"><span class="lineNum">    9468 </span>            :   // DQ (12/12/2020): Adding a string label so that we can name the different kinds of transformations.</a>
<a name="9469"><span class="lineNum">    9469 </span>            :   // E.g. moving pattern matched function from header file to dynamic library, vs. replacing function</a>
<a name="9470"><span class="lineNum">    9470 </span>            :   // definitions in the dynamic library file with function prototypes.</a>
<a name="9471"><span class="lineNum">    9471 </span><span class="lineNoCov">          0 :      printf (&quot; --- transformationLabel = %s \n&quot;,transformationLabel.c_str());</span></a>
<a name="9472"><span class="lineNum">    9472 </span>            : </a>
<a name="9473"><span class="lineNum">    9473 </span><span class="lineNoCov">          0 :      printf (&quot; --- deferredTransformationKind = %s \n&quot;,outputDeferredTransformationKind(deferredTransformationKind).c_str());</span></a>
<a name="9474"><span class="lineNum">    9474 </span><span class="lineNoCov">          0 :      if (statementToRemove != NULL)</span></a>
<a name="9475"><span class="lineNum">    9475 </span>            :         {</a>
<a name="9476"><span class="lineNum">    9476 </span><span class="lineNoCov">          0 :           printf (&quot; --- statementToRemove = %p = %s name = %s \n&quot;,statementToRemove,statementToRemove-&gt;class_name().c_str(),get_name(statementToRemove).c_str());</span></a>
<a name="9477"><span class="lineNum">    9477 </span>            :         }</a>
<a name="9478"><span class="lineNum">    9478 </span>            :        else</a>
<a name="9479"><span class="lineNum">    9479 </span>            :         {</a>
<a name="9480"><span class="lineNum">    9480 </span><span class="lineNoCov">          0 :           printf (&quot; --- statementToRemove == NULL \n&quot;);</span></a>
<a name="9481"><span class="lineNum">    9481 </span>            :         }</a>
<a name="9482"><span class="lineNum">    9482 </span>            : </a>
<a name="9483"><span class="lineNum">    9483 </span><span class="lineNoCov">          0 :      if (statementToAdd != NULL)</span></a>
<a name="9484"><span class="lineNum">    9484 </span>            :         {</a>
<a name="9485"><span class="lineNum">    9485 </span><span class="lineNoCov">          0 :           printf (&quot; --- statementToAdd = %p = %s name = %s \n&quot;,statementToAdd,statementToAdd-&gt;class_name().c_str(),get_name(statementToAdd).c_str());</span></a>
<a name="9486"><span class="lineNum">    9486 </span>            :         }</a>
<a name="9487"><span class="lineNum">    9487 </span>            :        else</a>
<a name="9488"><span class="lineNum">    9488 </span>            :         {</a>
<a name="9489"><span class="lineNum">    9489 </span><span class="lineNoCov">          0 :           printf (&quot; --- statementToAdd == NULL \n&quot;);</span></a>
<a name="9490"><span class="lineNum">    9490 </span>            :         }</a>
<a name="9491"><span class="lineNum">    9491 </span>            : </a>
<a name="9492"><span class="lineNum">    9492 </span><span class="lineNoCov">          0 :      if (class_definition != NULL)</span></a>
<a name="9493"><span class="lineNum">    9493 </span>            :         {</a>
<a name="9494"><span class="lineNum">    9494 </span>            :        // printf (&quot; --- class_definition = %p = %s name = %s \n&quot;,class_definition,class_definition-&gt;class_name().c_str(),get_name(class_definition).c_str());</a>
<a name="9495"><span class="lineNum">    9495 </span><span class="lineNoCov">          0 :           printf (&quot; --- class_definition = %p \n&quot;,class_definition);</span></a>
<a name="9496"><span class="lineNum">    9496 </span>            :         }</a>
<a name="9497"><span class="lineNum">    9497 </span>            : </a>
<a name="9498"><span class="lineNum">    9498 </span><span class="lineNoCov">          0 :      if (target_class_member != NULL)</span></a>
<a name="9499"><span class="lineNum">    9499 </span>            :         {</a>
<a name="9500"><span class="lineNum">    9500 </span><span class="lineNoCov">          0 :           printf (&quot; --- target_class_member = %p = %s name = %s \n&quot;,target_class_member,target_class_member-&gt;class_name().c_str(),get_name(target_class_member).c_str());</span></a>
<a name="9501"><span class="lineNum">    9501 </span>            :         }</a>
<a name="9502"><span class="lineNum">    9502 </span>            : </a>
<a name="9503"><span class="lineNum">    9503 </span><span class="lineNoCov">          0 :      if (new_function_prototype != NULL)</span></a>
<a name="9504"><span class="lineNum">    9504 </span>            :         {</a>
<a name="9505"><span class="lineNum">    9505 </span><span class="lineNoCov">          0 :           printf (&quot; --- new_function_prototype = %p = %s name = %s \n&quot;,new_function_prototype,new_function_prototype-&gt;class_name().c_str(),get_name(new_function_prototype).c_str());</span></a>
<a name="9506"><span class="lineNum">    9506 </span>            :         }</a>
<a name="9507"><span class="lineNum">    9507 </span>            : </a>
<a name="9508"><span class="lineNum">    9508 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9509"><span class="lineNum">    9509 </span><span class="lineNoCov">          0 :      if (locationToOverwriteWithTransformation != NULL)</span></a>
<a name="9510"><span class="lineNum">    9510 </span>            :         {</a>
<a name="9511"><span class="lineNum">    9511 </span>            :        // printf (&quot; --- locationToOverwriteWithTransformation = %p = %s name = %s \n&quot;,locationToOverwriteWithTransformation,</a>
<a name="9512"><span class="lineNum">    9512 </span>            :        //      locationToOverwriteWithTransformation-&gt;class_name().c_str(),get_name(locationToOverwriteWithTransformation).c_str());</a>
<a name="9513"><span class="lineNum">    9513 </span><span class="lineNoCov">          0 :           printf (&quot; --- locationToOverwriteWithTransformation = %p \n&quot;,locationToOverwriteWithTransformation);</span></a>
<a name="9514"><span class="lineNum">    9514 </span>            :         }</a>
<a name="9515"><span class="lineNum">    9515 </span>            : </a>
<a name="9516"><span class="lineNum">    9516 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9517"><span class="lineNum">    9517 </span><span class="lineNoCov">          0 :      if (transformationToOverwriteFirstStatementInInterval != NULL)</span></a>
<a name="9518"><span class="lineNum">    9518 </span>            :         {</a>
<a name="9519"><span class="lineNum">    9519 </span>            :        // printf (&quot; --- transformationToOverwriteFirstStatementInInterval = %p = %s name = %s \n&quot;,transformationToOverwriteFirstStatementInInterval,</a>
<a name="9520"><span class="lineNum">    9520 </span>            :        //      transformationToOverwriteFirstStatementInInterval-&gt;class_name().c_str(),get_name(transformationToOverwriteFirstStatementInInterval).c_str());</a>
<a name="9521"><span class="lineNum">    9521 </span><span class="lineNoCov">          0 :           printf (&quot; --- transformationToOverwriteFirstStatementInInterval = %p \n&quot;,transformationToOverwriteFirstStatementInInterval);</span></a>
<a name="9522"><span class="lineNum">    9522 </span>            :         }</a>
<a name="9523"><span class="lineNum">    9523 </span>            : </a>
<a name="9524"><span class="lineNum">    9524 </span>            :   // DQ (3/1/2021): Added new data member to support deferred transformations.</a>
<a name="9525"><span class="lineNum">    9525 </span><span class="lineNoCov">          0 :      if (blockOfStatementsToOutline != NULL)</span></a>
<a name="9526"><span class="lineNum">    9526 </span>            :         {</a>
<a name="9527"><span class="lineNum">    9527 </span><span class="lineNoCov">          0 :           printf (&quot; --- blockOfStatementsToOutline = %p \n&quot;,blockOfStatementsToOutline);</span></a>
<a name="9528"><span class="lineNum">    9528 </span>            :         }</a>
<a name="9529"><span class="lineNum">    9529 </span>            : </a>
<a name="9530"><span class="lineNum">    9530 </span><span class="lineNoCov">          0 :      printf (&quot;targetClasses.size() = %zu \n&quot;,targetClasses.size());</span></a>
<a name="9531"><span class="lineNum">    9531 </span><span class="lineNoCov">          0 :      printf (&quot;targetFriends.size() = %zu \n&quot;,targetFriends.size());</span></a>
<a name="9532"><span class="lineNum">    9532 </span>            : </a>
<a name="9533"><span class="lineNum">    9533 </span>            :   // DQ (2/28/2021): Added new data member to support deferred transformations.</a>
<a name="9534"><span class="lineNum">    9534 </span><span class="lineNoCov">          0 :      printf (&quot;statementInterval.size() = %zu \n&quot;,statementInterval.size());</span></a>
<a name="9535"><span class="lineNum">    9535 </span>            : </a>
<a name="9536"><span class="lineNum">    9536 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="9537"><span class="lineNum">    9537 </span>            : #endif</a>
<a name="9538"><span class="lineNum">    9538 </span>            : </a>
<a name="9539"><span class="lineNum">    9539 </span>            : </a>
<a name="9540"><span class="lineNum">    9540 </span>            : </a>
<a name="9541"><span class="lineNum">    9541 </span>            : </a>
<a name="9542"><span class="lineNum">    9542 </span>            : </a>
<a name="9543"><span class="lineNum">    9543 </span>            : // DQ (/20/2010): Control debugging output for SageInterface::removeStatement() function.</a>
<a name="9544"><span class="lineNum">    9544 </span>            : #define REMOVE_STATEMENT_DEBUG 0</a>
<a name="9545"><span class="lineNum">    9545 </span>            : </a>
<a name="9546"><span class="lineNum">    9546 </span>            : //! Remove a statement: TODO consider side effects for symbol tables</a>
<a name="9547"><span class="lineNum">    9547 </span><span class="lineCov">        947 : void SageInterface::removeStatement(SgStatement* targetStmt, bool autoRelocatePreprocessingInfo /*= true*/)</span></a>
<a name="9548"><span class="lineNum">    9548 </span>            :    {</a>
<a name="9549"><span class="lineNum">    9549 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="9550"><span class="lineNum">    9550 </span>            :   // This function removes the input statement.</a>
<a name="9551"><span class="lineNum">    9551 </span>            :   // If there are comments and/or CPP directives then those comments and/or CPP directives will</a>
<a name="9552"><span class="lineNum">    9552 </span>            :   // be moved to a new SgStatement.  The new SgStatement is selected using the findSurroundingStatementFromSameFile()</a>
<a name="9553"><span class="lineNum">    9553 </span>            :   // function and if there is not statement found then the SgGlobal IR node will be selected.</a>
<a name="9554"><span class="lineNum">    9554 </span>            :   // this work is tested by the tests/nonsmoke/functional/roseTests/astInterfaceTests/removeStatementCommentRelocation.C</a>
<a name="9555"><span class="lineNum">    9555 </span>            :   // translator and a number of input codes that represent a range of contexts which exercise different</a>
<a name="9556"><span class="lineNum">    9556 </span>            :   // cases in the code below.</a>
<a name="9557"><span class="lineNum">    9557 </span>            : </a>
<a name="9558"><span class="lineNum">    9558 </span>            : #ifndef _MSC_VER</a>
<a name="9559"><span class="lineNum">    9559 </span>            :   // This function only supports the removal of a whole statement (not an expression within a statement)</a>
<a name="9560"><span class="lineNum">    9560 </span><span class="lineCov">        947 :      ROSE_ASSERT (targetStmt != NULL);</span></a>
<a name="9561"><span class="lineNum">    9561 </span>            : </a>
<a name="9562"><span class="lineNum">    9562 </span><span class="lineCov">        947 :      SgStatement * parentStatement = isSgStatement(targetStmt-&gt;get_parent());</span></a>
<a name="9563"><span class="lineNum">    9563 </span>            : </a>
<a name="9564"><span class="lineNum">    9564 </span>            :   // Can't assert this since SgFile is the parent of SgGlobal, and SgFile is not a statement.</a>
<a name="9565"><span class="lineNum">    9565 </span>            :   // Even so SgGlobal can't be removed from SgFile, but isRemovableStatement() takes a SgStatement.</a>
<a name="9566"><span class="lineNum">    9566 </span>            :   // ROSE_ASSERT (parentStatement != NULL);</a>
<a name="9567"><span class="lineNum">    9567 </span>            : </a>
<a name="9568"><span class="lineNum">    9568 </span><span class="lineCov">        947 :      bool isRemovable = (parentStatement != NULL) ? LowLevelRewrite::isRemovableStatement(targetStmt) : false;</span></a>
<a name="9569"><span class="lineNum">    9569 </span>            : </a>
<a name="9570"><span class="lineNum">    9570 </span>            : #if REMOVE_STATEMENT_DEBUG || 0</a>
<a name="9571"><span class="lineNum">    9571 </span>            :      printf (&quot;In SageInterface::removeStatement(): parentStatement = %p = %s remove targetStatement = %p = %s (isRemovable = %s) \n&quot;,</a>
<a name="9572"><span class="lineNum">    9572 </span>            :           parentStatement,parentStatement-&gt;class_name().c_str(),targetStmt,targetStmt-&gt;class_name().c_str(),isRemovable ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9573"><span class="lineNum">    9573 </span>            : #endif</a>
<a name="9574"><span class="lineNum">    9574 </span>            : </a>
<a name="9575"><span class="lineNum">    9575 </span><span class="lineCov">        945 :      if (isRemovable == true)</span></a>
<a name="9576"><span class="lineNum">    9576 </span>            :         {</a>
<a name="9577"><span class="lineNum">    9577 </span>            :        // DQ (9/19/2010): Disable this new (not completely working feature) so that I can checkin the latest UPC/UPC++ work.</a>
<a name="9578"><span class="lineNum">    9578 </span>            : #if 1</a>
<a name="9579"><span class="lineNum">    9579 </span>            :        // DQ (9/16/2010): Added support to move comments and CPP directives marked to</a>
<a name="9580"><span class="lineNum">    9580 </span>            :        // appear before the statment to be attached to the inserted statement (and marked</a>
<a name="9581"><span class="lineNum">    9581 </span>            :        // to appear before that statement).</a>
<a name="9582"><span class="lineNum">    9582 </span><span class="lineCov">        945 :           AttachedPreprocessingInfoType* comments = targetStmt-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="9583"><span class="lineNum">    9583 </span>            : </a>
<a name="9584"><span class="lineNum">    9584 </span>            :        // DQ (9/17/2010): Trying to eliminate failing case in OpenMP projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu.c</a>
<a name="9585"><span class="lineNum">    9585 </span>            :        // I think that special rules apply to inserting a SgBasicBlock so disable comment reloation when inserting a SgBasicBlock.</a>
<a name="9586"><span class="lineNum">    9586 </span>            :        // if (comments != NULL &amp;&amp; isRemovable == true &amp;&amp; isSgBasicBlock(targetStmt) == NULL )</a>
<a name="9587"><span class="lineNum">    9587 </span>            :        // Liao 10/28/2010. Sometimes we want remove the statement with all its preprocessing information</a>
<a name="9588"><span class="lineNum">    9588 </span><span class="lineCov">        945 :           if (autoRelocatePreprocessingInfo == true)</span></a>
<a name="9589"><span class="lineNum">    9589 </span>            :              {</a>
<a name="9590"><span class="lineNum">    9590 </span><span class="lineCov">        122 :                if (comments != NULL &amp;&amp; isSgBasicBlock(targetStmt) == NULL )</span></a>
<a name="9591"><span class="lineNum">    9591 </span>            :                   {</a>
<a name="9592"><span class="lineNum">    9592 </span><span class="lineCov">         64 :                     vector&lt;int&gt; captureList;</span></a>
<a name="9593"><span class="lineNum">    9593 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9594"><span class="lineNum">    9594 </span>            :                     printf (&quot;Found attached comments (removing %p = %s): comments-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str(),comments-&gt;size());</a>
<a name="9595"><span class="lineNum">    9595 </span>            : #endif</a>
<a name="9596"><span class="lineNum">    9596 </span>            : </a>
<a name="9597"><span class="lineNum">    9597 </span>            :                  // Liao 10/28/2010. relinking AST statements may be achieved by remove it and attach it to somewhere else.</a>
<a name="9598"><span class="lineNum">    9598 </span>            :                  // In this case, preprocessing information sometimes should go with the statements and not be relocated to the original places.</a>
<a name="9599"><span class="lineNum">    9599 </span>            :                  // Dan: Since this statement will be removed we have to relocate all the associated comments and CPP directives.</a>
<a name="9600"><span class="lineNum">    9600 </span><span class="lineCov">         32 :                     int commentIndex = 0;</span></a>
<a name="9601"><span class="lineNum">    9601 </span><span class="lineCov">         32 :                     AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="9602"><span class="lineNum">    9602 </span><span class="lineCov">         59 :                     for (i = comments-&gt;begin(); i != comments-&gt;end(); i++)</span></a>
<a name="9603"><span class="lineNum">    9603 </span>            :                        {</a>
<a name="9604"><span class="lineNum">    9604 </span><span class="lineCov">         27 :                          ROSE_ASSERT ( (*i) != NULL );</span></a>
<a name="9605"><span class="lineNum">    9605 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9606"><span class="lineNum">    9606 </span>            :                          printf (&quot;          Attached Comment (relativePosition=%s): %s\n&quot;,</a>
<a name="9607"><span class="lineNum">    9607 </span>            :                               ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="9608"><span class="lineNum">    9608 </span>            :                               (*i)-&gt;getString().c_str());</a>
<a name="9609"><span class="lineNum">    9609 </span>            :                          printf (&quot;Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*i)-&gt;getNumberOfLines(),(*i)-&gt;getColumnNumberOfEndOfString());</a>
<a name="9610"><span class="lineNum">    9610 </span>            :                          (*i)-&gt;get_file_info()-&gt;display(&quot;comment/directive location debug&quot;);</a>
<a name="9611"><span class="lineNum">    9611 </span>            : #endif</a>
<a name="9612"><span class="lineNum">    9612 </span><span class="lineCov">         27 :                          captureList.push_back(commentIndex);</span></a>
<a name="9613"><span class="lineNum">    9613 </span><span class="lineCov">         27 :                          commentIndex++;</span></a>
<a name="9614"><span class="lineNum">    9614 </span>            :                        }</a>
<a name="9615"><span class="lineNum">    9615 </span>            : </a>
<a name="9616"><span class="lineNum">    9616 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9617"><span class="lineNum">    9617 </span>            :                     printf (&quot;captureList.size() = %&quot; PRIuPTR &quot; \n&quot;,captureList.size());</a>
<a name="9618"><span class="lineNum">    9618 </span>            : #endif</a>
<a name="9619"><span class="lineNum">    9619 </span>            : </a>
<a name="9620"><span class="lineNum">    9620 </span><span class="lineCov">         32 :                     if (captureList.empty() == false)</span></a>
<a name="9621"><span class="lineNum">    9621 </span>            :                        {</a>
<a name="9622"><span class="lineNum">    9622 </span>            :                       // Remove these comments and/or CPP directives and put them into the previous statement (marked to be output after the statement).</a>
<a name="9623"><span class="lineNum">    9623 </span>            :                       // Find the surrounding statement by first looking up in the sequence of statements in this block, then down, we need another</a>
<a name="9624"><span class="lineNum">    9624 </span>            :                       // statement from the same file.</a>
<a name="9625"><span class="lineNum">    9625 </span><span class="lineCov">          5 :                          bool surroundingStatementPreceedsTargetStatement = false;</span></a>
<a name="9626"><span class="lineNum">    9626 </span><span class="lineCov">          5 :                          SgStatement* surroundingStatement = findSurroundingStatementFromSameFile(targetStmt,surroundingStatementPreceedsTargetStatement);</span></a>
<a name="9627"><span class="lineNum">    9627 </span>            : </a>
<a name="9628"><span class="lineNum">    9628 </span>            :                       // ROSE_ASSERT(surroundingStatement != NULL);</a>
<a name="9629"><span class="lineNum">    9629 </span><span class="lineCov">          5 :                          if (surroundingStatement != NULL)</span></a>
<a name="9630"><span class="lineNum">    9630 </span>            :                             {</a>
<a name="9631"><span class="lineNum">    9631 </span>            :                            // If we have identified a valid surrounding statemen, then move the comments and CPP directives to that statement.</a>
<a name="9632"><span class="lineNum">    9632 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9633"><span class="lineNum">    9633 </span>            :                               printf (&quot;In removeStatement(): surroundingStatementPreceedsTargetStatement = %s \n&quot;,surroundingStatementPreceedsTargetStatement ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9634"><span class="lineNum">    9634 </span>            :                               printf (&quot; --- moving comments from targetStmt         = %p = %s name = %s \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str(),get_name(targetStmt).c_str());</a>
<a name="9635"><span class="lineNum">    9635 </span>            :                               printf (&quot; --- moving comments to surroundingStatement = %p = %s name = %s \n&quot;,surroundingStatement,surroundingStatement-&gt;class_name().c_str(),get_name(surroundingStatement).c_str());</a>
<a name="9636"><span class="lineNum">    9636 </span>            : #endif</a>
<a name="9637"><span class="lineNum">    9637 </span><span class="lineCov">          4 :                               moveCommentsToNewStatement(targetStmt,captureList,surroundingStatement,surroundingStatementPreceedsTargetStatement);</span></a>
<a name="9638"><span class="lineNum">    9638 </span>            :                             }</a>
<a name="9639"><span class="lineNum">    9639 </span>            :                        }</a>
<a name="9640"><span class="lineNum">    9640 </span>            :                   } // end if (comments)</a>
<a name="9641"><span class="lineNum">    9641 </span>            :              }// end if (autoRelocatePreprocessingInfo)</a>
<a name="9642"><span class="lineNum">    9642 </span>            : #endif  // end #if 1</a>
<a name="9643"><span class="lineNum">    9643 </span>            : </a>
<a name="9644"><span class="lineNum">    9644 </span>            :        // DQ (12/1/2015): Adding support for fixup internal data struuctures that have references to statements (e.g. macro expansions).</a>
<a name="9645"><span class="lineNum">    9645 </span><span class="lineCov">        945 :           resetInternalMapsForTargetStatement(targetStmt);</span></a>
<a name="9646"><span class="lineNum">    9646 </span>            : </a>
<a name="9647"><span class="lineNum">    9647 </span><span class="lineCov">        945 :           parentStatement-&gt;remove_statement(targetStmt);</span></a>
<a name="9648"><span class="lineNum">    9648 </span>            :         }</a>
<a name="9649"><span class="lineNum">    9649 </span>            : #else</a>
<a name="9650"><span class="lineNum">    9650 </span>            :      printf (&quot;Error: This is not supported within Microsoft Windows (I forget why). \n&quot;);</a>
<a name="9651"><span class="lineNum">    9651 </span>            :      ROSE_ABORT();</a>
<a name="9652"><span class="lineNum">    9652 </span>            : #endif</a>
<a name="9653"><span class="lineNum">    9653 </span>            : </a>
<a name="9654"><span class="lineNum">    9654 </span>            : #endif</a>
<a name="9655"><span class="lineNum">    9655 </span><span class="lineCov">        947 :    }</span></a>
<a name="9656"><span class="lineNum">    9656 </span>            : </a>
<a name="9657"><span class="lineNum">    9657 </span>            : </a>
<a name="9658"><span class="lineNum">    9658 </span>            : </a>
<a name="9659"><span class="lineNum">    9659 </span>            : //! Reset internal data structures used for token-based unparsing and macro summaries based on modifications to this statement.</a>
<a name="9660"><span class="lineNum">    9660 </span>            : void</a>
<a name="9661"><span class="lineNum">    9661 </span><span class="lineCov">       1133 : SageInterface::resetInternalMapsForTargetStatement(SgStatement* sourceStatement)</span></a>
<a name="9662"><span class="lineNum">    9662 </span>            :    {</a>
<a name="9663"><span class="lineNum">    9663 </span>            :   // This function allows the modification of the input statement to trigger operations on internal</a>
<a name="9664"><span class="lineNum">    9664 </span>            :   // data structures that hold references to such statements.  An example is the macroExpansion</a>
<a name="9665"><span class="lineNum">    9665 </span>            :   // data structures that have a reference to the statements that are associated with and macro expansion.</a>
<a name="9666"><span class="lineNum">    9666 </span>            :   // if a statement assocated with a macro expansion is removed, then the macroExpansion needs to be</a>
<a name="9667"><span class="lineNum">    9667 </span>            :   // updated to force all of the statements to be marked as transformed (so that the AST will be unparsed</a>
<a name="9668"><span class="lineNum">    9668 </span>            :   // instead of the tokens representing the macro or some partial representation of the transformed</a>
<a name="9669"><span class="lineNum">    9669 </span>            :   // statements and the macro call (worse).</a>
<a name="9670"><span class="lineNum">    9670 </span>            : </a>
<a name="9671"><span class="lineNum">    9671 </span>            : #if 0</a>
<a name="9672"><span class="lineNum">    9672 </span>            :      printf (&quot;In SageInterface::resetInternalMapsForTargetStatement(SgStatement*): sourceStatement = %p = %s \n&quot;,sourceStatement,sourceStatement-&gt;class_name().c_str());</a>
<a name="9673"><span class="lineNum">    9673 </span>            : #endif</a>
<a name="9674"><span class="lineNum">    9674 </span>            : </a>
<a name="9675"><span class="lineNum">    9675 </span><span class="lineCov">       1133 :      SgSourceFile* sourceFile = getEnclosingSourceFile(sourceStatement);</span></a>
<a name="9676"><span class="lineNum">    9676 </span>            : </a>
<a name="9677"><span class="lineNum">    9677 </span>            :   // NOTE: if the statment has not yet been added to the AST then it will not return a valid pointer.</a>
<a name="9678"><span class="lineNum">    9678 </span>            :   // ROSE_ASSERT(sourceFile != NULL);</a>
<a name="9679"><span class="lineNum">    9679 </span>            : </a>
<a name="9680"><span class="lineNum">    9680 </span>            : #if 0</a>
<a name="9681"><span class="lineNum">    9681 </span>            :      printf (&quot;In SageInterface::resetInternalMapsForTargetStatement(SgStatement*): sourceFile = %p \n&quot;,sourceFile);</a>
<a name="9682"><span class="lineNum">    9682 </span>            : #endif</a>
<a name="9683"><span class="lineNum">    9683 </span>            : </a>
<a name="9684"><span class="lineNum">    9684 </span><span class="lineCov">       1133 :      if (sourceFile != NULL)</span></a>
<a name="9685"><span class="lineNum">    9685 </span>            :         {</a>
<a name="9686"><span class="lineNum">    9686 </span><span class="lineCov">       1066 :           std::map&lt;SgStatement*,MacroExpansion*&gt; &amp; macroExpansionMap = sourceFile-&gt;get_macroExpansionMap();</span></a>
<a name="9687"><span class="lineNum">    9687 </span>            : </a>
<a name="9688"><span class="lineNum">    9688 </span><span class="lineCov">       2132 :           if (macroExpansionMap.find(sourceStatement) != macroExpansionMap.end())</span></a>
<a name="9689"><span class="lineNum">    9689 </span>            :              {</a>
<a name="9690"><span class="lineNum">    9690 </span><span class="lineNoCov">          0 :                MacroExpansion* macroExpansion = macroExpansionMap[sourceStatement];</span></a>
<a name="9691"><span class="lineNum">    9691 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(macroExpansion != NULL);</span></a>
<a name="9692"><span class="lineNum">    9692 </span>            : #if 0</a>
<a name="9693"><span class="lineNum">    9693 </span>            :                printf (&quot;In resetInternalMapsForTargetStatement(): macroExpansion = %p = %s \n&quot;,macroExpansion,macroExpansion-&gt;macro_name.c_str());</a>
<a name="9694"><span class="lineNum">    9694 </span>            : #endif</a>
<a name="9695"><span class="lineNum">    9695 </span><span class="lineNoCov">          0 :                if (macroExpansion-&gt;isTransformed == false)</span></a>
<a name="9696"><span class="lineNum">    9696 </span>            :                   {</a>
<a name="9697"><span class="lineNum">    9697 </span>            :                  // Mark all of the statements in the macro expansion to be transformed.</a>
<a name="9698"><span class="lineNum">    9698 </span><span class="lineNoCov">          0 :                     std::vector&lt;SgStatement*&gt; &amp; associatedStatementVector = macroExpansion-&gt;associatedStatementVector;</span></a>
<a name="9699"><span class="lineNum">    9699 </span>            : </a>
<a name="9700"><span class="lineNum">    9700 </span><span class="lineNoCov">          0 :                     for (size_t i = 0; i &lt; associatedStatementVector.size(); i++)</span></a>
<a name="9701"><span class="lineNum">    9701 </span>            :                        {</a>
<a name="9702"><span class="lineNum">    9702 </span>            :                       // I am concerned that some of these statements might have been deleted.</a>
<a name="9703"><span class="lineNum">    9703 </span><span class="lineNoCov">          0 :                          SgStatement* statement = associatedStatementVector[i];</span></a>
<a name="9704"><span class="lineNum">    9704 </span>            : #if 0</a>
<a name="9705"><span class="lineNum">    9705 </span>            :                          printf (&quot;Mark as transformation to be output: statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</a>
<a name="9706"><span class="lineNum">    9706 </span>            : #endif</a>
<a name="9707"><span class="lineNum">    9707 </span>            :                       // Note that any new statement might not yet have valid Sg_File_Info objects setup at this point.</a>
<a name="9708"><span class="lineNum">    9708 </span>            :                       // Then again, now did it make it into the associatedStatementVector unless it was via memory</a>
<a name="9709"><span class="lineNum">    9709 </span>            :                       // recycling through the mmory pool.</a>
<a name="9710"><span class="lineNum">    9710 </span><span class="lineNoCov">          0 :                          if (statement-&gt;get_file_info() != NULL)</span></a>
<a name="9711"><span class="lineNum">    9711 </span>            :                             {</a>
<a name="9712"><span class="lineNum">    9712 </span>            :                            // Mark each of the statements as a transformation.</a>
<a name="9713"><span class="lineNum">    9713 </span><span class="lineNoCov">          0 :                               statement-&gt;setTransformation();</span></a>
<a name="9714"><span class="lineNum">    9714 </span>            : </a>
<a name="9715"><span class="lineNum">    9715 </span>            :                            // This is required, else the statement will not be output in the generated code.</a>
<a name="9716"><span class="lineNum">    9716 </span>            :                            // To understand this, consider that statements in header files could be transformed,</a>
<a name="9717"><span class="lineNum">    9717 </span>            :                            // but we would not want that to cause them to be unparse in the source file.</a>
<a name="9718"><span class="lineNum">    9718 </span><span class="lineNoCov">          0 :                               statement-&gt;setOutputInCodeGeneration();</span></a>
<a name="9719"><span class="lineNum">    9719 </span>            : </a>
<a name="9720"><span class="lineNum">    9720 </span>            :                            // Not clear if we should also remove the statement from the associatedStatementVector.</a>
<a name="9721"><span class="lineNum">    9721 </span>            :                            // This would be important to do to avoid having the same location in the memory pool</a>
<a name="9722"><span class="lineNum">    9722 </span>            :                            // be reused for another statement. Since we makr the macro expansion as transformed</a>
<a name="9723"><span class="lineNum">    9723 </span>            :                            // we likely don't have to worry about this.</a>
<a name="9724"><span class="lineNum">    9724 </span>            :                             }</a>
<a name="9725"><span class="lineNum">    9725 </span>            :                            else</a>
<a name="9726"><span class="lineNum">    9726 </span>            :                             {</a>
<a name="9727"><span class="lineNum">    9727 </span>            : #if 0</a>
<a name="9728"><span class="lineNum">    9728 </span>            :                               printf (&quot;WARNING: could this be an example of an IR node recycled through the memory pools: statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</a>
<a name="9729"><span class="lineNum">    9729 </span>            : #endif</a>
<a name="9730"><span class="lineNum">    9730 </span>            :                             }</a>
<a name="9731"><span class="lineNum">    9731 </span>            :                        }</a>
<a name="9732"><span class="lineNum">    9732 </span>            :                  }</a>
<a name="9733"><span class="lineNum">    9733 </span>            : </a>
<a name="9734"><span class="lineNum">    9734 </span>            :             // Mark this macro expansion as having been processed.</a>
<a name="9735"><span class="lineNum">    9735 </span><span class="lineNoCov">          0 :                macroExpansion-&gt;isTransformed = true;</span></a>
<a name="9736"><span class="lineNum">    9736 </span>            : </a>
<a name="9737"><span class="lineNum">    9737 </span>            : #if 0</a>
<a name="9738"><span class="lineNum">    9738 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="9739"><span class="lineNum">    9739 </span>            :                ROSE_ABORT();</a>
<a name="9740"><span class="lineNum">    9740 </span>            : #endif</a>
<a name="9741"><span class="lineNum">    9741 </span>            :              }</a>
<a name="9742"><span class="lineNum">    9742 </span>            : </a>
<a name="9743"><span class="lineNum">    9743 </span>            :        // Other data strucutes that may have to be updated include:</a>
<a name="9744"><span class="lineNum">    9744 </span>            :        // representativeWhitespaceStatementMap (should be required, but only effects whitespace details)</a>
<a name="9745"><span class="lineNum">    9745 </span>            :        // redundantlyMappedTokensToStatementMultimap (might not be required)</a>
<a name="9746"><span class="lineNum">    9746 </span>            : </a>
<a name="9747"><span class="lineNum">    9747 </span>            :         }</a>
<a name="9748"><span class="lineNum">    9748 </span>            : </a>
<a name="9749"><span class="lineNum">    9749 </span>            : #if 0</a>
<a name="9750"><span class="lineNum">    9750 </span>            :      printf (&quot;Leaving SageInterface::resetInternalMapsForTargetStatement(SgStatement*): sourceStatement = %p = %s \n&quot;,sourceStatement,sourceStatement-&gt;class_name().c_str());</a>
<a name="9751"><span class="lineNum">    9751 </span>            : #endif</a>
<a name="9752"><span class="lineNum">    9752 </span><span class="lineCov">       1133 :    }</span></a>
<a name="9753"><span class="lineNum">    9753 </span>            : </a>
<a name="9754"><span class="lineNum">    9754 </span>            : </a>
<a name="9755"><span class="lineNum">    9755 </span>            : //! Relocate comments and CPP directives from one statement to another.</a>
<a name="9756"><span class="lineNum">    9756 </span>            : void</a>
<a name="9757"><span class="lineNum">    9757 </span><span class="lineCov">          4 : SageInterface::moveCommentsToNewStatement(SgStatement* sourceStatement, const vector&lt;int&gt; &amp; indexList, SgStatement* targetStatement , bool surroundingStatementPreceedsTargetStatement)</span></a>
<a name="9758"><span class="lineNum">    9758 </span>            :    {</a>
<a name="9759"><span class="lineNum">    9759 </span><span class="lineCov">          4 :      AttachedPreprocessingInfoType* comments = sourceStatement-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="9760"><span class="lineNum">    9760 </span>            : </a>
<a name="9761"><span class="lineNum">    9761 </span>            : #if REMOVE_STATEMENT_DEBUG || 0</a>
<a name="9762"><span class="lineNum">    9762 </span>            :      printf (&quot;In moveCommentsToNewStatement(): surroundingStatementPreceedsTargetStatement = %s \n&quot;,surroundingStatementPreceedsTargetStatement ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9763"><span class="lineNum">    9763 </span>            :      printf (&quot; --- sourceStatement = %p = %s name = %s \n&quot;,sourceStatement,sourceStatement-&gt;class_name().c_str(),get_name(sourceStatement).c_str());</a>
<a name="9764"><span class="lineNum">    9764 </span>            :      printf (&quot; --- targetStatement = %p = %s name = %s \n&quot;,targetStatement,targetStatement-&gt;class_name().c_str(),get_name(targetStatement).c_str());</a>
<a name="9765"><span class="lineNum">    9765 </span>            : #endif</a>
<a name="9766"><span class="lineNum">    9766 </span>            : </a>
<a name="9767"><span class="lineNum">    9767 </span>            :   // Now add the entries from the captureList to the surroundingStatement and remove them from the targetStmt.</a>
<a name="9768"><span class="lineNum">    9768 </span>            :   // printf (&quot;This is a valid surrounding statement = %s for insertBefore = %s \n&quot;,surroundingStatement-&gt;class_name().c_str(),insertBefore ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9769"><span class="lineNum">    9769 </span><span class="lineCov">          4 :      vector&lt;int&gt;::const_iterator j = indexList.begin();</span></a>
<a name="9770"><span class="lineNum">    9770 </span><span class="lineCov">         29 :      while (j != indexList.end())</span></a>
<a name="9771"><span class="lineNum">    9771 </span>            :         {</a>
<a name="9772"><span class="lineNum">    9772 </span>            :        // Add the captured comments to the new statement. Likely we need to make sure that the order is preserved.</a>
<a name="9773"><span class="lineNum">    9773 </span><span class="lineCov">         25 :           ROSE_ASSERT(targetStatement-&gt;get_file_info() != NULL);</span></a>
<a name="9774"><span class="lineNum">    9774 </span>            : #if REMOVE_STATEMENT_DEBUG || 0</a>
<a name="9775"><span class="lineNum">    9775 </span>            :           printf (&quot;Attaching comments to targetStatement = %p = %s on file = %s line %d \n&quot;,</a>
<a name="9776"><span class="lineNum">    9776 </span>            :                targetStatement,targetStatement-&gt;class_name().c_str(),</a>
<a name="9777"><span class="lineNum">    9777 </span>            :                targetStatement-&gt;get_file_info()-&gt;get_filenameString().c_str(),</a>
<a name="9778"><span class="lineNum">    9778 </span>            :                targetStatement-&gt;get_file_info()-&gt;get_line());</a>
<a name="9779"><span class="lineNum">    9779 </span>            : </a>
<a name="9780"><span class="lineNum">    9780 </span>            :           printf (&quot;(*comments)[*j]-&gt;getRelativePosition() = %s \n&quot;,PreprocessingInfo::relativePositionName((*comments)[*j]-&gt;getRelativePosition()).c_str());</a>
<a name="9781"><span class="lineNum">    9781 </span>            : #endif</a>
<a name="9782"><span class="lineNum">    9782 </span>            : </a>
<a name="9783"><span class="lineNum">    9783 </span><span class="lineCov">         25 :           if (surroundingStatementPreceedsTargetStatement == true)</span></a>
<a name="9784"><span class="lineNum">    9784 </span>            :              {</a>
<a name="9785"><span class="lineNum">    9785 </span><span class="lineCov">          4 :                if ((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::before)</span></a>
<a name="9786"><span class="lineNum">    9786 </span>            :                   {</a>
<a name="9787"><span class="lineNum">    9787 </span>            : #if 0</a>
<a name="9788"><span class="lineNum">    9788 </span>            :                     printf (&quot;Mark comments that were before the preceeding statement to be after the preceeding statement \n&quot;);</a>
<a name="9789"><span class="lineNum">    9789 </span>            : #endif</a>
<a name="9790"><span class="lineNum">    9790 </span><span class="lineCov">          2 :                     (*comments)[*j]-&gt;setRelativePosition(PreprocessingInfo::after);</span></a>
<a name="9791"><span class="lineNum">    9791 </span><span class="lineCov">          2 :                     ROSE_ASSERT((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::after);</span></a>
<a name="9792"><span class="lineNum">    9792 </span>            :                   }</a>
<a name="9793"><span class="lineNum">    9793 </span>            :                  else</a>
<a name="9794"><span class="lineNum">    9794 </span>            :                   {</a>
<a name="9795"><span class="lineNum">    9795 </span>            : #if 0</a>
<a name="9796"><span class="lineNum">    9796 </span>            :                     printf (&quot;Leave the comments marked as being after the removed statement as after the preceeding \n&quot;);</a>
<a name="9797"><span class="lineNum">    9797 </span>            : #endif</a>
<a name="9798"><span class="lineNum">    9798 </span>            :                  // If is is not before, I hope it can only be after.</a>
<a name="9799"><span class="lineNum">    9799 </span><span class="lineCov">          2 :                     ROSE_ASSERT((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::after);</span></a>
<a name="9800"><span class="lineNum">    9800 </span>            :                   }</a>
<a name="9801"><span class="lineNum">    9801 </span>            :              }</a>
<a name="9802"><span class="lineNum">    9802 </span>            :             else</a>
<a name="9803"><span class="lineNum">    9803 </span>            :              {</a>
<a name="9804"><span class="lineNum">    9804 </span><span class="lineCov">         21 :                if ((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::before)</span></a>
<a name="9805"><span class="lineNum">    9805 </span>            :                   {</a>
<a name="9806"><span class="lineNum">    9806 </span>            :                  // Leave the comments marked as being before the associated statement.</a>
<a name="9807"><span class="lineNum">    9807 </span>            : #if 0</a>
<a name="9808"><span class="lineNum">    9808 </span>            :                     printf (&quot;Leave the comments marked as being before the removed statement as before the following statement \n&quot;);</a>
<a name="9809"><span class="lineNum">    9809 </span>            : #endif</a>
<a name="9810"><span class="lineNum">    9810 </span>            :                   }</a>
<a name="9811"><span class="lineNum">    9811 </span>            :                  else</a>
<a name="9812"><span class="lineNum">    9812 </span>            :                   {</a>
<a name="9813"><span class="lineNum">    9813 </span>            : #if 0</a>
<a name="9814"><span class="lineNum">    9814 </span>            :                     printf (&quot;Mark comments that were after the removed statement to be before the following statement \n&quot;);</a>
<a name="9815"><span class="lineNum">    9815 </span>            : #endif</a>
<a name="9816"><span class="lineNum">    9816 </span>            :                  // If is is not before, I hope it can only be after.</a>
<a name="9817"><span class="lineNum">    9817 </span><span class="lineCov">         12 :                     ROSE_ASSERT((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::after);</span></a>
<a name="9818"><span class="lineNum">    9818 </span><span class="lineCov">         12 :                     (*comments)[*j]-&gt;setRelativePosition(PreprocessingInfo::before);</span></a>
<a name="9819"><span class="lineNum">    9819 </span><span class="lineCov">         12 :                     ROSE_ASSERT((*comments)[*j]-&gt;getRelativePosition() == PreprocessingInfo::before);</span></a>
<a name="9820"><span class="lineNum">    9820 </span>            :                   }</a>
<a name="9821"><span class="lineNum">    9821 </span>            : </a>
<a name="9822"><span class="lineNum">    9822 </span>            :             // printf (&quot; This case (surroundingStatementPreceedsTargetStatement == false) is not handled yet. \n&quot;);</a>
<a name="9823"><span class="lineNum">    9823 </span>            :             // ROSE_ASSERT(false);</a>
<a name="9824"><span class="lineNum">    9824 </span>            :              }</a>
<a name="9825"><span class="lineNum">    9825 </span>            : </a>
<a name="9826"><span class="lineNum">    9826 </span><span class="lineCov">         25 :           targetStatement-&gt;addToAttachedPreprocessingInfo((*comments)[*j]);</span></a>
<a name="9827"><span class="lineNum">    9827 </span>            : </a>
<a name="9828"><span class="lineNum">    9828 </span>            :        // Remove them from the targetStmt. (set them to NULL and then remove them in a separate step).</a>
<a name="9829"><span class="lineNum">    9829 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9830"><span class="lineNum">    9830 </span>            :           printf (&quot;Marking entry from comments list as NULL on sourceStatement = %p = %s \n&quot;,sourceStatement,sourceStatement-&gt;class_name().c_str());</a>
<a name="9831"><span class="lineNum">    9831 </span>            : #endif</a>
<a name="9832"><span class="lineNum">    9832 </span><span class="lineCov">         25 :           (*comments)[*j] = NULL;</span></a>
<a name="9833"><span class="lineNum">    9833 </span>            : </a>
<a name="9834"><span class="lineNum">    9834 </span><span class="lineCov">         25 :           j++;</span></a>
<a name="9835"><span class="lineNum">    9835 </span>            :         }</a>
<a name="9836"><span class="lineNum">    9836 </span>            : </a>
<a name="9837"><span class="lineNum">    9837 </span>            :   // Now remove each NULL entries in the comments vector.</a>
<a name="9838"><span class="lineNum">    9838 </span>            :   // Because of iterator invalidation we must reset the iterators after each call to erase (I think).</a>
<a name="9839"><span class="lineNum">    9839 </span><span class="lineCov">         29 :      for (size_t n = 0; n &lt; indexList.size(); n++)</span></a>
<a name="9840"><span class="lineNum">    9840 </span>            :         {</a>
<a name="9841"><span class="lineNum">    9841 </span>            : #if REMOVE_STATEMENT_DEBUG || 0</a>
<a name="9842"><span class="lineNum">    9842 </span>            :           printf (&quot;Erase entry from comments list on comments-&gt;size() %&quot; PRIuPTR &quot; \n&quot;,comments-&gt;size());</a>
<a name="9843"><span class="lineNum">    9843 </span>            : #endif</a>
<a name="9844"><span class="lineNum">    9844 </span><span class="lineCov">         25 :           bool modifiedList = false;</span></a>
<a name="9845"><span class="lineNum">    9845 </span><span class="lineCov">         25 :           AttachedPreprocessingInfoType::iterator k = comments-&gt;begin();</span></a>
<a name="9846"><span class="lineNum">    9846 </span><span class="lineCov">         50 :           while (k != comments-&gt;end() &amp;&amp; modifiedList == false)</span></a>
<a name="9847"><span class="lineNum">    9847 </span>            :              {</a>
<a name="9848"><span class="lineNum">    9848 </span>            :             // Only modify the list once per iteration over the captureList</a>
<a name="9849"><span class="lineNum">    9849 </span>            :             // if ((*comments)[*k] == NULL)</a>
<a name="9850"><span class="lineNum">    9850 </span><span class="lineCov">         25 :                 if (*k == NULL)</span></a>
<a name="9851"><span class="lineNum">    9851 </span>            :                 {</a>
<a name="9852"><span class="lineNum">    9852 </span><span class="lineCov">         25 :                     k = comments-&gt;erase(k);</span></a>
<a name="9853"><span class="lineNum">    9853 </span><span class="lineCov">         25 :                     modifiedList = true;</span></a>
<a name="9854"><span class="lineNum">    9854 </span><span class="lineCov">         25 :                     continue;</span></a>
<a name="9855"><span class="lineNum">    9855 </span>            :                 }</a>
<a name="9856"><span class="lineNum">    9856 </span>            :                 else</a>
<a name="9857"><span class="lineNum">    9857 </span>            :                 {</a>
<a name="9858"><span class="lineNum">    9858 </span><span class="lineNoCov">          0 :                     k++;</span></a>
<a name="9859"><span class="lineNum">    9859 </span>            :                 }</a>
<a name="9860"><span class="lineNum">    9860 </span>            :              }</a>
<a name="9861"><span class="lineNum">    9861 </span>            :         }</a>
<a name="9862"><span class="lineNum">    9862 </span><span class="lineCov">          4 :    }</span></a>
<a name="9863"><span class="lineNum">    9863 </span>            : </a>
<a name="9864"><span class="lineNum">    9864 </span>            : </a>
<a name="9865"><span class="lineNum">    9865 </span>            : //! Remove a statement: TODO consider side effects for symbol tables</a>
<a name="9866"><span class="lineNum">    9866 </span>            : SgStatement*</a>
<a name="9867"><span class="lineNum">    9867 </span><span class="lineCov">          5 : SageInterface::findSurroundingStatementFromSameFile(SgStatement* targetStmt, bool &amp; surroundingStatementPreceedsTargetStatement)</span></a>
<a name="9868"><span class="lineNum">    9868 </span>            :    {</a>
<a name="9869"><span class="lineNum">    9869 </span>            :   // Note that if the return value is SgGlobal (global scope), then surroundingStatementPreceedsTargetStatement is false, but meaningless.</a>
<a name="9870"><span class="lineNum">    9870 </span>            :   // This function can not return a NULL pointer.</a>
<a name="9871"><span class="lineNum">    9871 </span>            : </a>
<a name="9872"><span class="lineNum">    9872 </span><span class="lineCov">          5 :      ROSE_ASSERT(targetStmt != NULL);</span></a>
<a name="9873"><span class="lineNum">    9873 </span>            : </a>
<a name="9874"><span class="lineNum">    9874 </span><span class="lineCov">          5 :      SgStatement* surroundingStatement = targetStmt;</span></a>
<a name="9875"><span class="lineNum">    9875 </span><span class="lineCov">          5 :      int surroundingStatement_fileId   = Sg_File_Info::BAD_FILE_ID; // No file id can have this value.</span></a>
<a name="9876"><span class="lineNum">    9876 </span>            : </a>
<a name="9877"><span class="lineNum">    9877 </span>            : #if REMOVE_STATEMENT_DEBUG || 0</a>
<a name="9878"><span class="lineNum">    9878 </span>            :      printf (&quot;TOP of findSurroundingStatementFromSameFile(): surroundingStatementPreceedsTargetStatement = %s \n&quot;,surroundingStatementPreceedsTargetStatement ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="9879"><span class="lineNum">    9879 </span>            : #endif</a>
<a name="9880"><span class="lineNum">    9880 </span>            : </a>
<a name="9881"><span class="lineNum">    9881 </span><span class="lineCov">          5 :      std::set&lt;SgStatement*&gt; previousVisitedStatementSet;</span></a>
<a name="9882"><span class="lineNum">    9882 </span>            : </a>
<a name="9883"><span class="lineNum">    9883 </span>            :   // Only handle relocation for statements that exist in the file (at least for now while debugging).</a>
<a name="9884"><span class="lineNum">    9884 </span><span class="lineCov">          5 :      if (targetStmt-&gt;get_file_info()-&gt;get_file_id() &gt;= 0)</span></a>
<a name="9885"><span class="lineNum">    9885 </span>            :         {</a>
<a name="9886"><span class="lineNum">    9886 </span><span class="lineCov">          4 :           surroundingStatementPreceedsTargetStatement = true;</span></a>
<a name="9887"><span class="lineNum">    9887 </span>            : </a>
<a name="9888"><span class="lineNum">    9888 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9889"><span class="lineNum">    9889 </span>            :           printf (&quot;   targetStmt-&gt;get_file_info()-&gt;get_file_id()           = %d \n&quot;,targetStmt-&gt;get_file_info()-&gt;get_file_id());</a>
<a name="9890"><span class="lineNum">    9890 </span>            : #endif</a>
<a name="9891"><span class="lineNum">    9891 </span><span class="lineCov">          4 :           bool returningNullSurroundingStatement = false;</span></a>
<a name="9892"><span class="lineNum">    9892 </span>            :        // while (surroundingStatement-&gt;get_file_info()-&gt;get_file_id() != targetStmt-&gt;get_file_info()-&gt;get_file_id())</a>
<a name="9893"><span class="lineNum">    9893 </span><span class="lineCov">       3572 :           while ((returningNullSurroundingStatement == false) &amp;&amp; (surroundingStatement != NULL) &amp;&amp; surroundingStatement_fileId != targetStmt-&gt;get_file_info()-&gt;get_file_id())</span></a>
<a name="9894"><span class="lineNum">    9894 </span>            :              {</a>
<a name="9895"><span class="lineNum">    9895 </span>            :             // Start by going up in the source sequence.</a>
<a name="9896"><span class="lineNum">    9896 </span>            :             // This is a declaration from the wrong file so go to the next statement.</a>
<a name="9897"><span class="lineNum">    9897 </span>            :             // surroundingStatement = (insertBefore == true) ? getNextStatement(surroundingStatement) : getPreviousStatement(surroundingStatement);</a>
<a name="9898"><span class="lineNum">    9898 </span>            :             // surroundingStatement = (insertBefore == true) ? getPreviousStatement(surroundingStatement) : getNextStatement(surroundingStatement);</a>
<a name="9899"><span class="lineNum">    9899 </span><span class="lineCov">       3568 :                surroundingStatement = getPreviousStatement(surroundingStatement);</span></a>
<a name="9900"><span class="lineNum">    9900 </span><span class="lineCov">       3568 :                if (surroundingStatement == NULL)</span></a>
<a name="9901"><span class="lineNum">    9901 </span>            :                   {</a>
<a name="9902"><span class="lineNum">    9902 </span>            :                     surroundingStatement_fileId = Sg_File_Info::BAD_FILE_ID;</a>
<a name="9903"><span class="lineNum">    9903 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9904"><span class="lineNum">    9904 </span>            :                     printf (&quot;   surroundingStatement_fileId set to Sg_File_Info::BAD_FILE_ID \n&quot;);</a>
<a name="9905"><span class="lineNum">    9905 </span>            : #endif</a>
<a name="9906"><span class="lineNum">    9906 </span>            :                   }</a>
<a name="9907"><span class="lineNum">    9907 </span>            :                  else</a>
<a name="9908"><span class="lineNum">    9908 </span>            :                   {</a>
<a name="9909"><span class="lineNum">    9909 </span><span class="lineCov">       3568 :                     surroundingStatement_fileId = surroundingStatement-&gt;get_file_info()-&gt;get_file_id();</span></a>
<a name="9910"><span class="lineNum">    9910 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9911"><span class="lineNum">    9911 </span>            :                     printf (&quot;   surroundingStatement = %p = %s surroundingStatement-&gt;get_file_info()-&gt;get_file_id() = %d \n&quot;,</a>
<a name="9912"><span class="lineNum">    9912 </span>            :                          surroundingStatement,surroundingStatement-&gt;class_name().c_str(),surroundingStatement-&gt;get_file_info()-&gt;get_file_id());</a>
<a name="9913"><span class="lineNum">    9913 </span>            : #endif</a>
<a name="9914"><span class="lineNum">    9914 </span>            :                   }</a>
<a name="9915"><span class="lineNum">    9915 </span>            : </a>
<a name="9916"><span class="lineNum">    9916 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9917"><span class="lineNum">    9917 </span>            :                if (surroundingStatement != NULL)</a>
<a name="9918"><span class="lineNum">    9918 </span>            :                   {</a>
<a name="9919"><span class="lineNum">    9919 </span>            :                     printf (&quot;Looping toward the top of the file for a statement to attach comments and CPP directives to: surroundingStatement = %p = %s file = %s file id = %d line = %d \n&quot;,</a>
<a name="9920"><span class="lineNum">    9920 </span>            :                          surroundingStatement,surroundingStatement-&gt;class_name().c_str(),</a>
<a name="9921"><span class="lineNum">    9921 </span>            :                          surroundingStatement-&gt;get_file_info()-&gt;get_filenameString().c_str(),</a>
<a name="9922"><span class="lineNum">    9922 </span>            :                          surroundingStatement-&gt;get_file_info()-&gt;get_file_id(),</a>
<a name="9923"><span class="lineNum">    9923 </span>            :                          surroundingStatement-&gt;get_file_info()-&gt;get_line());</a>
<a name="9924"><span class="lineNum">    9924 </span>            :                   }</a>
<a name="9925"><span class="lineNum">    9925 </span>            :                  else</a>
<a name="9926"><span class="lineNum">    9926 </span>            :                   {</a>
<a name="9927"><span class="lineNum">    9927 </span>            :                     printf (&quot;surroundingStatement == NULL \n&quot;);</a>
<a name="9928"><span class="lineNum">    9928 </span>            :                   }</a>
<a name="9929"><span class="lineNum">    9929 </span>            : #endif</a>
<a name="9930"><span class="lineNum">    9930 </span>            : </a>
<a name="9931"><span class="lineNum">    9931 </span>            :             // DQ (11/15/2020): Eliminate the infinite loop that is possible when we iterate over a loop of statements.</a>
<a name="9932"><span class="lineNum">    9932 </span><span class="lineCov">       7136 :                if (previousVisitedStatementSet.find(surroundingStatement) != previousVisitedStatementSet.end())</span></a>
<a name="9933"><span class="lineNum">    9933 </span>            :                  {</a>
<a name="9934"><span class="lineNum">    9934 </span><span class="lineNoCov">          0 :                    printf (&quot;This statement has been previously visited: surroundingStatement = %p = %s \n&quot;,surroundingStatement,surroundingStatement-&gt;class_name().c_str());</span></a>
<a name="9935"><span class="lineNum">    9935 </span>            : </a>
<a name="9936"><span class="lineNum">    9936 </span><span class="lineNoCov">          0 :                    printf (&quot;ERROR: SageInterface::findSurroundingStatementFromSameFile(): cannot located surrounding statement from same file (return NULL) \n&quot;);</span></a>
<a name="9937"><span class="lineNum">    9937 </span>            : </a>
<a name="9938"><span class="lineNum">    9938 </span><span class="lineNoCov">          0 :                    surroundingStatement = NULL;</span></a>
<a name="9939"><span class="lineNum">    9939 </span>            :                 // break;</a>
<a name="9940"><span class="lineNum">    9940 </span>            :                 // return NULL;</a>
<a name="9941"><span class="lineNum">    9941 </span>            :                  }</a>
<a name="9942"><span class="lineNum">    9942 </span>            :                else</a>
<a name="9943"><span class="lineNum">    9943 </span>            :                  {</a>
<a name="9944"><span class="lineNum">    9944 </span><span class="lineCov">       3568 :                    previousVisitedStatementSet.insert(surroundingStatement);</span></a>
<a name="9945"><span class="lineNum">    9945 </span>            :                  }</a>
<a name="9946"><span class="lineNum">    9946 </span>            : </a>
<a name="9947"><span class="lineNum">    9947 </span>            :             // As a last resort restart and go down in the statement sequence.</a>
<a name="9948"><span class="lineNum">    9948 </span>            :             // if (surroundingStatement == NULL)</a>
<a name="9949"><span class="lineNum">    9949 </span><span class="lineCov">       3568 :                if (surroundingStatement == NULL || isSgGlobal(surroundingStatement) != NULL)</span></a>
<a name="9950"><span class="lineNum">    9950 </span>            :                   {</a>
<a name="9951"><span class="lineNum">    9951 </span>            :                  // This is triggered by rose_inputloopUnrolling.C</a>
<a name="9952"><span class="lineNum">    9952 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9953"><span class="lineNum">    9953 </span>            :                     printf (&quot;We just ran off the start (top) of the file... targetStmt = %p = %s \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str());</a>
<a name="9954"><span class="lineNum">    9954 </span>            : #endif</a>
<a name="9955"><span class="lineNum">    9955 </span>            : #if 0</a>
<a name="9956"><span class="lineNum">    9956 </span>            :                     ROSE_ABORT();</a>
<a name="9957"><span class="lineNum">    9957 </span>            : #endif</a>
<a name="9958"><span class="lineNum">    9958 </span>            :                  // A statement in the same file could not be identified, so this is false.</a>
<a name="9959"><span class="lineNum">    9959 </span><span class="lineCov">          1 :                     surroundingStatementPreceedsTargetStatement = false;</span></a>
<a name="9960"><span class="lineNum">    9960 </span>            : </a>
<a name="9961"><span class="lineNum">    9961 </span>            :                  // Restart by going the other direction (down in the source sequence)</a>
<a name="9962"><span class="lineNum">    9962 </span><span class="lineCov">          1 :                     surroundingStatement = targetStmt;</span></a>
<a name="9963"><span class="lineNum">    9963 </span><span class="lineCov">          1 :                     SgStatement* previousStatement = surroundingStatement;</span></a>
<a name="9964"><span class="lineNum">    9964 </span>            :                  // surroundingStatement = getNextStatement(surroundingStatement);</a>
<a name="9965"><span class="lineNum">    9965 </span><span class="lineCov">          1 :                     surroundingStatement_fileId = Sg_File_Info::BAD_FILE_ID;</span></a>
<a name="9966"><span class="lineNum">    9966 </span>            : </a>
<a name="9967"><span class="lineNum">    9967 </span><span class="lineCov">          2 :                     std::set&lt;SgStatement*&gt; forwardVisitedStatementSet;</span></a>
<a name="9968"><span class="lineNum">    9968 </span>            : </a>
<a name="9969"><span class="lineNum">    9969 </span>            :                  // while ( (surroundingStatement != NULL) &amp;&amp; (surroundingStatement-&gt;get_file_info()-&gt;get_file_id() != targetStmt-&gt;get_file_info()-&gt;get_file_id()) )</a>
<a name="9970"><span class="lineNum">    9970 </span><span class="lineCov">          2 :                     while ( (surroundingStatement != NULL) &amp;&amp; (surroundingStatement_fileId != targetStmt-&gt;get_file_info()-&gt;get_file_id()) )</span></a>
<a name="9971"><span class="lineNum">    9971 </span>            :                        {</a>
<a name="9972"><span class="lineNum">    9972 </span>            :                       // DQ (11/15/2020): Eliminate the infinite loop that is possible when we iterate over a loop of statements.</a>
<a name="9973"><span class="lineNum">    9973 </span><span class="lineCov">          2 :                          if (forwardVisitedStatementSet.find(surroundingStatement) != forwardVisitedStatementSet.end())</span></a>
<a name="9974"><span class="lineNum">    9974 </span>            :                             {</a>
<a name="9975"><span class="lineNum">    9975 </span><span class="lineNoCov">          0 :                               printf (&quot;This statement has been previously visited: surroundingStatement = %p = %s \n&quot;,surroundingStatement,surroundingStatement-&gt;class_name().c_str());</span></a>
<a name="9976"><span class="lineNum">    9976 </span>            : </a>
<a name="9977"><span class="lineNum">    9977 </span><span class="lineNoCov">          0 :                               printf (&quot;ERROR: SageInterface::findSurroundingStatementFromSameFile(): cannot located surrounding statement from same file (return NULL) \n&quot;);</span></a>
<a name="9978"><span class="lineNum">    9978 </span>            : </a>
<a name="9979"><span class="lineNum">    9979 </span><span class="lineNoCov">          0 :                               surroundingStatement = NULL;</span></a>
<a name="9980"><span class="lineNum">    9980 </span><span class="lineNoCov">          0 :                               break;</span></a>
<a name="9981"><span class="lineNum">    9981 </span>            :                            // return NULL;</a>
<a name="9982"><span class="lineNum">    9982 </span>            :                             }</a>
<a name="9983"><span class="lineNum">    9983 </span>            :                            else</a>
<a name="9984"><span class="lineNum">    9984 </span>            :                             {</a>
<a name="9985"><span class="lineNum">    9985 </span><span class="lineCov">          1 :                               forwardVisitedStatementSet.insert(surroundingStatement);</span></a>
<a name="9986"><span class="lineNum">    9986 </span>            :                             }</a>
<a name="9987"><span class="lineNum">    9987 </span>            : </a>
<a name="9988"><span class="lineNum">    9988 </span><span class="lineCov">          1 :                          previousStatement = surroundingStatement;</span></a>
<a name="9989"><span class="lineNum">    9989 </span><span class="lineCov">          1 :                          surroundingStatement = getNextStatement(surroundingStatement);</span></a>
<a name="9990"><span class="lineNum">    9990 </span>            : </a>
<a name="9991"><span class="lineNum">    9991 </span><span class="lineCov">          1 :                          if (surroundingStatement == NULL)</span></a>
<a name="9992"><span class="lineNum">    9992 </span>            :                             {</a>
<a name="9993"><span class="lineNum">    9993 </span>            :                               surroundingStatement_fileId = Sg_File_Info::BAD_FILE_ID;</a>
<a name="9994"><span class="lineNum">    9994 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="9995"><span class="lineNum">    9995 </span>            :                               printf (&quot;We just ran off the end (bottom) of the file... \n&quot;);</a>
<a name="9996"><span class="lineNum">    9996 </span>            : #endif</a>
<a name="9997"><span class="lineNum">    9997 </span>            : #if 0</a>
<a name="9998"><span class="lineNum">    9998 </span>            :                               ROSE_ABORT();</a>
<a name="9999"><span class="lineNum">    9999 </span>            : #endif</a>
<a name="10000"><span class="lineNum">   10000 </span>            :                               returningNullSurroundingStatement = true;</a>
<a name="10001"><span class="lineNum">   10001 </span>            :                             }</a>
<a name="10002"><span class="lineNum">   10002 </span>            :                            else</a>
<a name="10003"><span class="lineNum">   10003 </span>            :                             {</a>
<a name="10004"><span class="lineNum">   10004 </span><span class="lineNoCov">          0 :                               surroundingStatement_fileId = surroundingStatement-&gt;get_file_info()-&gt;get_file_id();</span></a>
<a name="10005"><span class="lineNum">   10005 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="10006"><span class="lineNum">   10006 </span>            :                               printf (&quot;Looping toward the bottom of the file for a statement to attach comments and CPP directives to: surroundingStatement = %p = %s file = %s file id = %d line = %d \n&quot;,</a>
<a name="10007"><span class="lineNum">   10007 </span>            :                                    surroundingStatement,surroundingStatement-&gt;class_name().c_str(),</a>
<a name="10008"><span class="lineNum">   10008 </span>            :                                    surroundingStatement-&gt;get_file_info()-&gt;get_filenameString().c_str(),</a>
<a name="10009"><span class="lineNum">   10009 </span>            :                                    surroundingStatement-&gt;get_file_info()-&gt;get_file_id(),</a>
<a name="10010"><span class="lineNum">   10010 </span>            :                                    surroundingStatement-&gt;get_file_info()-&gt;get_line());</a>
<a name="10011"><span class="lineNum">   10011 </span>            : #endif</a>
<a name="10012"><span class="lineNum">   10012 </span>            :                             }</a>
<a name="10013"><span class="lineNum">   10013 </span>            :                        }</a>
<a name="10014"><span class="lineNum">   10014 </span>            : </a>
<a name="10015"><span class="lineNum">   10015 </span><span class="lineCov">          1 :                     if (surroundingStatement == NULL)</span></a>
<a name="10016"><span class="lineNum">   10016 </span>            :                        {</a>
<a name="10017"><span class="lineNum">   10017 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="10018"><span class="lineNum">   10018 </span>            :                          printf (&quot;Resetting the surroundingStatement to the previousStatement = %p = %s \n&quot;,previousStatement,previousStatement-&gt;class_name().c_str());</a>
<a name="10019"><span class="lineNum">   10019 </span>            : #endif</a>
<a name="10020"><span class="lineNum">   10020 </span><span class="lineCov">          1 :                          surroundingStatement = previousStatement;</span></a>
<a name="10021"><span class="lineNum">   10021 </span>            : </a>
<a name="10022"><span class="lineNum">   10022 </span>            :                       // Check if this is the input statement we are removing (since the we have to attach comments to the global scope IR node.</a>
<a name="10023"><span class="lineNum">   10023 </span><span class="lineCov">          1 :                          if (surroundingStatement == targetStmt)</span></a>
<a name="10024"><span class="lineNum">   10024 </span>            :                             {</a>
<a name="10025"><span class="lineNum">   10025 </span>            :                            // This can happen if there was only a single statement in a file and it was removed.</a>
<a name="10026"><span class="lineNum">   10026 </span>            :                            // All associated comments would have to be relocated to the SgGlobal IR node.</a>
<a name="10027"><span class="lineNum">   10027 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="10028"><span class="lineNum">   10028 </span>            :                               printf (&quot;Setting the surroundingStatement to be global scope \n&quot;);</a>
<a name="10029"><span class="lineNum">   10029 </span>            : #endif</a>
<a name="10030"><span class="lineNum">   10030 </span><span class="lineCov">          1 :                               surroundingStatement = TransformationSupport::getGlobalScope(targetStmt);</span></a>
<a name="10031"><span class="lineNum">   10031 </span>            :                             }</a>
<a name="10032"><span class="lineNum">   10032 </span>            :                        }</a>
<a name="10033"><span class="lineNum">   10033 </span>            :                   }</a>
<a name="10034"><span class="lineNum">   10034 </span>            :              }</a>
<a name="10035"><span class="lineNum">   10035 </span>            : </a>
<a name="10036"><span class="lineNum">   10036 </span><span class="lineCov">          4 :           ROSE_ASSERT(surroundingStatement != NULL);</span></a>
<a name="10037"><span class="lineNum">   10037 </span>            :         }</a>
<a name="10038"><span class="lineNum">   10038 </span>            :        else</a>
<a name="10039"><span class="lineNum">   10039 </span>            :         {</a>
<a name="10040"><span class="lineNum">   10040 </span><span class="lineCov">          1 :           printf (&quot;This is a special statement (not associated with the original source code, comment relocation is not supported for these statements) targetStmt file id = %d \n&quot;,targetStmt-&gt;get_file_info()-&gt;get_file_id());</span></a>
<a name="10041"><span class="lineNum">   10041 </span><span class="lineCov">          1 :           surroundingStatement = NULL;</span></a>
<a name="10042"><span class="lineNum">   10042 </span>            :         }</a>
<a name="10043"><span class="lineNum">   10043 </span>            : </a>
<a name="10044"><span class="lineNum">   10044 </span>            : #if REMOVE_STATEMENT_DEBUG</a>
<a name="10045"><span class="lineNum">   10045 </span>            :      printf (&quot;BOTTOM of findSurroundingStatementFromSameFile(): surroundingStatementPreceedsTargetStatement = %s surroundingStatement = %p \n&quot;,surroundingStatementPreceedsTargetStatement ? &quot;true&quot; : &quot;false&quot;,surroundingStatement);</a>
<a name="10046"><span class="lineNum">   10046 </span>            :      if (surroundingStatement != NULL)</a>
<a name="10047"><span class="lineNum">   10047 </span>            :         {</a>
<a name="10048"><span class="lineNum">   10048 </span>            :           printf (&quot;surroundingStatement = %p = %s \n&quot;,surroundingStatement,surroundingStatement-&gt;class_name().c_str());</a>
<a name="10049"><span class="lineNum">   10049 </span>            :         }</a>
<a name="10050"><span class="lineNum">   10050 </span>            : #endif</a>
<a name="10051"><span class="lineNum">   10051 </span>            : </a>
<a name="10052"><span class="lineNum">   10052 </span>            :   // ROSE_ASSERT(surroundingStatement != NULL);</a>
<a name="10053"><span class="lineNum">   10053 </span>            : </a>
<a name="10054"><span class="lineNum">   10054 </span><span class="lineCov">          5 :      return surroundingStatement;</span></a>
<a name="10055"><span class="lineNum">   10055 </span>            :    }</a>
<a name="10056"><span class="lineNum">   10056 </span>            : </a>
<a name="10057"><span class="lineNum">   10057 </span>            : </a>
<a name="10058"><span class="lineNum">   10058 </span>            : #ifndef USE_ROSE</a>
<a name="10059"><span class="lineNum">   10059 </span>            : //! Deep delete a sub AST tree. It uses postorder traversal to delete each child node.</a>
<a name="10060"><span class="lineNum">   10060 </span><span class="lineCov">         43 : void SageInterface::deepDelete(SgNode* root)</span></a>
<a name="10061"><span class="lineNum">   10061 </span>            : {</a>
<a name="10062"><span class="lineNum">   10062 </span>            : #if 0</a>
<a name="10063"><span class="lineNum">   10063 </span>            :    struct Visitor: public AstSimpleProcessing {</a>
<a name="10064"><span class="lineNum">   10064 </span>            :     virtual void visit(SgNode* n) {</a>
<a name="10065"><span class="lineNum">   10065 </span>            :         delete (n);</a>
<a name="10066"><span class="lineNum">   10066 </span>            :      }</a>
<a name="10067"><span class="lineNum">   10067 </span>            :     };</a>
<a name="10068"><span class="lineNum">   10068 </span>            :   Visitor().traverse(root, postorder);</a>
<a name="10069"><span class="lineNum">   10069 </span>            : #else</a>
<a name="10070"><span class="lineNum">   10070 </span><span class="lineCov">         43 :   deleteAST(root);</span></a>
<a name="10071"><span class="lineNum">   10071 </span>            : #endif</a>
<a name="10072"><span class="lineNum">   10072 </span><span class="lineCov">         43 : }</span></a>
<a name="10073"><span class="lineNum">   10073 </span>            : #endif</a>
<a name="10074"><span class="lineNum">   10074 </span>            : </a>
<a name="10075"><span class="lineNum">   10075 </span>            : //! Replace a statement with another</a>
<a name="10076"><span class="lineNum">   10076 </span><span class="lineCov">       1597 : void SageInterface::replaceStatement(SgStatement* oldStmt, SgStatement* newStmt, bool movePreprocessingInfoValue/* = false*/)</span></a>
<a name="10077"><span class="lineNum">   10077 </span>            : {</a>
<a name="10078"><span class="lineNum">   10078 </span><span class="lineCov">       1597 :   ROSE_ASSERT(oldStmt);</span></a>
<a name="10079"><span class="lineNum">   10079 </span><span class="lineCov">       1597 :   ROSE_ASSERT(newStmt);</span></a>
<a name="10080"><span class="lineNum">   10080 </span><span class="lineCov">       1597 :   if (oldStmt == newStmt) return;</span></a>
<a name="10081"><span class="lineNum">   10081 </span><span class="lineCov">       1597 :   SgStatement * p = isSgStatement(oldStmt-&gt;get_parent());</span></a>
<a name="10082"><span class="lineNum">   10082 </span><span class="lineCov">       1597 :   ROSE_ASSERT(p);</span></a>
<a name="10083"><span class="lineNum">   10083 </span>            : #if 0</a>
<a name="10084"><span class="lineNum">   10084 </span>            :   // TODO  handle replace the body of a C/Fortran function definition with a single statement?</a>
<a name="10085"><span class="lineNum">   10085 </span>            :   // Liao 2/1/2010, in some case, we want to replace the entire body (SgBasicBlock) for some parent nodes.</a>
<a name="10086"><span class="lineNum">   10086 </span>            :   // the built-in replace_statement() (insert_child() underneath) may not defined for them.</a>
<a name="10087"><span class="lineNum">   10087 </span>            :   if (SgFortranDo * f_do = isSgFortranDo (p))</a>
<a name="10088"><span class="lineNum">   10088 </span>            :   {</a>
<a name="10089"><span class="lineNum">   10089 </span>            :     ROSE_ASSERT (f_do-&gt;get_body() == oldStmt);</a>
<a name="10090"><span class="lineNum">   10090 </span>            :     if (!isSgBasicBlock(newStmt))</a>
<a name="10091"><span class="lineNum">   10091 </span>            :      newStmt = buildBasicBlock (newStmt);</a>
<a name="10092"><span class="lineNum">   10092 </span>            :     f_do-&gt;set_body(isSgBasicBlock(newStmt));</a>
<a name="10093"><span class="lineNum">   10093 </span>            :     newStmt-&gt;set_parent(f_do);</a>
<a name="10094"><span class="lineNum">   10094 </span>            :   }</a>
<a name="10095"><span class="lineNum">   10095 </span>            :   else</a>
<a name="10096"><span class="lineNum">   10096 </span>            : #endif</a>
<a name="10097"><span class="lineNum">   10097 </span><span class="lineCov">       1597 :     p-&gt;replace_statement(oldStmt,newStmt);</span></a>
<a name="10098"><span class="lineNum">   10098 </span>            : </a>
<a name="10099"><span class="lineNum">   10099 </span>            : // Some translators have their own handling for this (e.g. the outliner)</a>
<a name="10100"><span class="lineNum">   10100 </span><span class="lineCov">       1597 :   if (movePreprocessingInfoValue)</span></a>
<a name="10101"><span class="lineNum">   10101 </span>            :      {</a>
<a name="10102"><span class="lineNum">   10102 </span>            : #if 0</a>
<a name="10103"><span class="lineNum">   10103 </span>            :        printf (&quot;In SageInterface::replaceStatement(): calling moveUpPreprocessingInfo() changed to movePreprocessingInfo() \n&quot;);</a>
<a name="10104"><span class="lineNum">   10104 </span>            : #endif</a>
<a name="10105"><span class="lineNum">   10105 </span>            : </a>
<a name="10106"><span class="lineNum">   10106 </span>            :     // DQ (12/28/2020): I think this should be movePreprocessingInfo instead of moveUpPreprocessingInfo</a>
<a name="10107"><span class="lineNum">   10107 </span>            :     // (which has a collection of defaults that are not appropriate).</a>
<a name="10108"><span class="lineNum">   10108 </span>            :     // moveUpPreprocessingInfo(newStmt, oldStmt);</a>
<a name="10109"><span class="lineNum">   10109 </span>            : #if 1</a>
<a name="10110"><span class="lineNum">   10110 </span>            :     // DQ (12/28/2020): Since this works we will leave it in place (it appears to not be required to call this with: usePrepend == true).</a>
<a name="10111"><span class="lineNum">   10111 </span><span class="lineNoCov">          0 :        moveUpPreprocessingInfo(newStmt, oldStmt);</span></a>
<a name="10112"><span class="lineNum">   10112 </span>            : #else</a>
<a name="10113"><span class="lineNum">   10113 </span>            :     // void SageInterface::movePreprocessingInfo (SgStatement* stmt_src,  SgStatement* stmt_dst, PreprocessingInfo::RelativePositionType src_position/* =PreprocessingInfo::undef */,</a>
<a name="10114"><span class="lineNum">   10114 </span>            :     //                                            PreprocessingInfo::RelativePositionType dst_position/* =PreprocessingInfo::undef */, bool usePrepend /*= false */)</a>
<a name="10115"><span class="lineNum">   10115 </span>            :        bool usePrepend = true;</a>
<a name="10116"><span class="lineNum">   10116 </span>            :     // movePreprocessingInfo ( newStmt, oldStmt, PreprocessingInfo::undef, PreprocessingInfo::undef, usePrepend );</a>
<a name="10117"><span class="lineNum">   10117 </span>            :        movePreprocessingInfo ( oldStmt, newStmt, PreprocessingInfo::undef, PreprocessingInfo::undef, usePrepend );</a>
<a name="10118"><span class="lineNum">   10118 </span>            : #endif</a>
<a name="10119"><span class="lineNum">   10119 </span>            :      }</a>
<a name="10120"><span class="lineNum">   10120 </span>            : }</a>
<a name="10121"><span class="lineNum">   10121 </span>            : </a>
<a name="10122"><span class="lineNum">   10122 </span>            : void</a>
<a name="10123"><span class="lineNum">   10123 </span><span class="lineNoCov">          0 : SageInterface::moveDeclarationToAssociatedNamespace ( SgDeclarationStatement* declarationStatement )</span></a>
<a name="10124"><span class="lineNum">   10124 </span>            :    {</a>
<a name="10125"><span class="lineNum">   10125 </span>            :   // Relocate the declaration to be explicitly represented in its associated namespace (required for some backend compilers to process template instantiations).</a>
<a name="10126"><span class="lineNum">   10126 </span>            : </a>
<a name="10127"><span class="lineNum">   10127 </span>            :   // DQ (7/19/2015): This is required to support general unparsing of template instantations for the GNU g++</a>
<a name="10128"><span class="lineNum">   10128 </span>            :   // compiler which does not permit name qualification to be used to support the expression of the namespace</a>
<a name="10129"><span class="lineNum">   10129 </span>            :   // where a template instantiatoon would be places.  Such name qualification would also sometimes require</a>
<a name="10130"><span class="lineNum">   10130 </span>            :   // global qualification which is also not allowed by the GNU g++ compiler.  These issues appear to be</a>
<a name="10131"><span class="lineNum">   10131 </span>            :   // specific to the GNU compiler versions, at least versions 4.4 through 4.8.</a>
<a name="10132"><span class="lineNum">   10132 </span>            : </a>
<a name="10133"><span class="lineNum">   10133 </span>            :   // Find the previous statement in this scope so that we can close off the namepsace and start a new one.</a>
<a name="10134"><span class="lineNum">   10134 </span><span class="lineNoCov">          0 :      SgStatement* previousDeclarationStatement = getPreviousStatement(declarationStatement);</span></a>
<a name="10135"><span class="lineNum">   10135 </span><span class="lineNoCov">          0 :      SgStatement* nextDeclarationStatement     = getNextStatement(declarationStatement);</span></a>
<a name="10136"><span class="lineNum">   10136 </span>            : </a>
<a name="10137"><span class="lineNum">   10137 </span>            : #if 0</a>
<a name="10138"><span class="lineNum">   10138 </span>            :      printf (&quot;In SageInterface::moveDeclarationToAssociatedNamespace(): declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="10139"><span class="lineNum">   10139 </span>            :      printf (&quot;   --- previousDeclarationStatement = %p = %s \n&quot;,previousDeclarationStatement,previousDeclarationStatement != NULL ? previousDeclarationStatement-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="10140"><span class="lineNum">   10140 </span>            :      printf (&quot;   --- nextDeclarationStatement     = %p      \n&quot;,nextDeclarationStatement);</a>
<a name="10141"><span class="lineNum">   10141 </span>            :      printf (&quot;   --- nextDeclarationStatement     = %p = %s \n&quot;,nextDeclarationStatement,    nextDeclarationStatement != NULL     ? nextDeclarationStatement-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="10142"><span class="lineNum">   10142 </span>            : #endif</a>
<a name="10143"><span class="lineNum">   10143 </span>            : </a>
<a name="10144"><span class="lineNum">   10144 </span>            :   // DQ (7/19/2015): Initial error handling to allow us to focuse on the most common case.</a>
<a name="10145"><span class="lineNum">   10145 </span><span class="lineNoCov">          0 :      if (previousDeclarationStatement != NULL)</span></a>
<a name="10146"><span class="lineNum">   10146 </span>            :         {</a>
<a name="10147"><span class="lineNum">   10147 </span>            :        // printf (&quot;previousDeclarationStatement = %p = %s \n&quot;,previousDeclarationStatement,previousDeclarationStatement-&gt;class_name().c_str());</a>
<a name="10148"><span class="lineNum">   10148 </span>            :         }</a>
<a name="10149"><span class="lineNum">   10149 </span>            :        else</a>
<a name="10150"><span class="lineNum">   10150 </span>            :         {</a>
<a name="10151"><span class="lineNum">   10151 </span><span class="lineNoCov">          0 :           printf (&quot;There is no previous statement so there is no namespace to close off! \n&quot;);</span></a>
<a name="10152"><span class="lineNum">   10152 </span>            : </a>
<a name="10153"><span class="lineNum">   10153 </span>            :        // Handle this corner case after we have the most general case working!</a>
<a name="10154"><span class="lineNum">   10154 </span><span class="lineNoCov">          0 :           printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="10155"><span class="lineNum">   10155 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="10156"><span class="lineNum">   10156 </span>            :         }</a>
<a name="10157"><span class="lineNum">   10157 </span>            : </a>
<a name="10158"><span class="lineNum">   10158 </span>            :   // DQ (7/19/2015): Initial error handling to allow us to focuse on the most common case.</a>
<a name="10159"><span class="lineNum">   10159 </span><span class="lineNoCov">          0 :      if (nextDeclarationStatement != NULL)</span></a>
<a name="10160"><span class="lineNum">   10160 </span>            :         {</a>
<a name="10161"><span class="lineNum">   10161 </span>            :        // printf (&quot;nextDeclarationStatement = %p = %s \n&quot;,nextDeclarationStatement,nextDeclarationStatement-&gt;class_name().c_str());</a>
<a name="10162"><span class="lineNum">   10162 </span>            :         }</a>
<a name="10163"><span class="lineNum">   10163 </span>            :        else</a>
<a name="10164"><span class="lineNum">   10164 </span>            :         {</a>
<a name="10165"><span class="lineNum">   10165 </span>            : #if 0</a>
<a name="10166"><span class="lineNum">   10166 </span>            :           printf (&quot;There is no next statement so there is no namespace to reopen! \n&quot;);</a>
<a name="10167"><span class="lineNum">   10167 </span>            : #endif</a>
<a name="10168"><span class="lineNum">   10168 </span>            : #if 0</a>
<a name="10169"><span class="lineNum">   10169 </span>            :        // Handle this corner case after we have the most general case working!</a>
<a name="10170"><span class="lineNum">   10170 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10171"><span class="lineNum">   10171 </span>            :           ROSE_ABORT();</a>
<a name="10172"><span class="lineNum">   10172 </span>            : #endif</a>
<a name="10173"><span class="lineNum">   10173 </span>            :         }</a>
<a name="10174"><span class="lineNum">   10174 </span>            : </a>
<a name="10175"><span class="lineNum">   10175 </span><span class="lineNoCov">          0 :      if (previousDeclarationStatement != NULL &amp;&amp; nextDeclarationStatement != NULL)</span></a>
<a name="10176"><span class="lineNum">   10176 </span>            :         {</a>
<a name="10177"><span class="lineNum">   10177 </span>            :        // DQ (7/19/2015): This is the most common case!</a>
<a name="10178"><span class="lineNum">   10178 </span>            : #if 0</a>
<a name="10179"><span class="lineNum">   10179 </span>            :           printf (&quot;Identified the most common case... \n&quot;);</a>
<a name="10180"><span class="lineNum">   10180 </span>            : #endif</a>
<a name="10181"><span class="lineNum">   10181 </span>            :        // Identify the associated namespace</a>
<a name="10182"><span class="lineNum">   10182 </span>            :           //SgScopeStatement* declarationScope = declarationStatement-&gt;get_scope();</a>
<a name="10183"><span class="lineNum">   10183 </span>            : #if 0</a>
<a name="10184"><span class="lineNum">   10184 </span>            :           printf (&quot;declarationScope = %p = %s \n&quot;,declarationScope,declarationScope-&gt;class_name().c_str());</a>
<a name="10185"><span class="lineNum">   10185 </span>            : #endif</a>
<a name="10186"><span class="lineNum">   10186 </span>            : #if 0</a>
<a name="10187"><span class="lineNum">   10187 </span>            :        // Handle this corner case after we have the most general case working!</a>
<a name="10188"><span class="lineNum">   10188 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10189"><span class="lineNum">   10189 </span>            :           ROSE_ABORT();</a>
<a name="10190"><span class="lineNum">   10190 </span>            : #endif</a>
<a name="10191"><span class="lineNum">   10191 </span>            :         }</a>
<a name="10192"><span class="lineNum">   10192 </span>            :        else</a>
<a name="10193"><span class="lineNum">   10193 </span>            :         {</a>
<a name="10194"><span class="lineNum">   10194 </span><span class="lineNoCov">          0 :           if (previousDeclarationStatement != NULL &amp;&amp; nextDeclarationStatement == NULL)</span></a>
<a name="10195"><span class="lineNum">   10195 </span>            :              {</a>
<a name="10196"><span class="lineNum">   10196 </span>            :             // This is the case for the last template instantiaton in global scope (so it too is a common case)!</a>
<a name="10197"><span class="lineNum">   10197 </span>            : #if 0</a>
<a name="10198"><span class="lineNum">   10198 </span>            :                printf (&quot;Found 2nd most common case: previousDeclarationStatement != NULL &amp;&amp; nextDeclarationStatement == NULL \n&quot;);</a>
<a name="10199"><span class="lineNum">   10199 </span>            : #endif</a>
<a name="10200"><span class="lineNum">   10200 </span>            : #if 0</a>
<a name="10201"><span class="lineNum">   10201 </span>            :             // Handle this corner case after we have the most general case working!</a>
<a name="10202"><span class="lineNum">   10202 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10203"><span class="lineNum">   10203 </span>            :                ROSE_ABORT();</a>
<a name="10204"><span class="lineNum">   10204 </span>            : #endif</a>
<a name="10205"><span class="lineNum">   10205 </span>            :              }</a>
<a name="10206"><span class="lineNum">   10206 </span>            :             else</a>
<a name="10207"><span class="lineNum">   10207 </span>            :              {</a>
<a name="10208"><span class="lineNum">   10208 </span><span class="lineNoCov">          0 :                if (previousDeclarationStatement == NULL &amp;&amp; nextDeclarationStatement == NULL)</span></a>
<a name="10209"><span class="lineNum">   10209 </span>            :                   {</a>
<a name="10210"><span class="lineNum">   10210 </span>            :                     printf (&quot;This case should require no special handling, unless we are still in the wrong namespace \n&quot;);</a>
<a name="10211"><span class="lineNum">   10211 </span>            : </a>
<a name="10212"><span class="lineNum">   10212 </span>            :                  // Handle this corner case after we have the most general case working!</a>
<a name="10213"><span class="lineNum">   10213 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10214"><span class="lineNum">   10214 </span>            :                     ROSE_ABORT();</a>
<a name="10215"><span class="lineNum">   10215 </span>            :                   }</a>
<a name="10216"><span class="lineNum">   10216 </span>            :                  else</a>
<a name="10217"><span class="lineNum">   10217 </span>            :                   {</a>
<a name="10218"><span class="lineNum">   10218 </span><span class="lineNoCov">          0 :                     printf (&quot;This case should have been caught above! \n&quot;);</span></a>
<a name="10219"><span class="lineNum">   10219 </span>            : </a>
<a name="10220"><span class="lineNum">   10220 </span>            :                  // Handle this corner case after we have the most general case working!</a>
<a name="10221"><span class="lineNum">   10221 </span><span class="lineNoCov">          0 :                     printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="10222"><span class="lineNum">   10222 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="10223"><span class="lineNum">   10223 </span>            :                   }</a>
<a name="10224"><span class="lineNum">   10224 </span>            :              }</a>
<a name="10225"><span class="lineNum">   10225 </span>            :         }</a>
<a name="10226"><span class="lineNum">   10226 </span>            : </a>
<a name="10227"><span class="lineNum">   10227 </span><span class="lineNoCov">          0 :      SgScopeStatement* declarationParent = isSgScopeStatement(declarationStatement-&gt;get_parent());</span></a>
<a name="10228"><span class="lineNum">   10228 </span><span class="lineNoCov">          0 :      if (declarationParent == NULL)</span></a>
<a name="10229"><span class="lineNum">   10229 </span>            :         {</a>
<a name="10230"><span class="lineNum">   10230 </span>            : #if 0</a>
<a name="10231"><span class="lineNum">   10231 </span>            :           printf (&quot;declarationStatement-&gt;get_parent() = %p = %s \n&quot;,declarationStatement-&gt;get_parent(), (declarationStatement-&gt;get_parent() != NULL) ? declarationStatement-&gt;get_parent()-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="10232"><span class="lineNum">   10232 </span>            : #endif</a>
<a name="10233"><span class="lineNum">   10233 </span>            :         }</a>
<a name="10234"><span class="lineNum">   10234 </span>            :   // This can be a SgTemplateInstantiationDirectiveStatement (bug we want to skip over this case for now).</a>
<a name="10235"><span class="lineNum">   10235 </span>            :   // ROSE_ASSERT(declarationParent != NULL);</a>
<a name="10236"><span class="lineNum">   10236 </span>            : </a>
<a name="10237"><span class="lineNum">   10237 </span><span class="lineNoCov">          0 :      if (declarationParent != NULL)</span></a>
<a name="10238"><span class="lineNum">   10238 </span>            :         {</a>
<a name="10239"><span class="lineNum">   10239 </span><span class="lineNoCov">          0 :           SgScopeStatement* declarationScope = declarationStatement-&gt;get_scope();</span></a>
<a name="10240"><span class="lineNum">   10240 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(declarationScope != NULL);</span></a>
<a name="10241"><span class="lineNum">   10241 </span>            : </a>
<a name="10242"><span class="lineNum">   10242 </span><span class="lineNoCov">          0 :           SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(declarationScope);</span></a>
<a name="10243"><span class="lineNum">   10243 </span><span class="lineNoCov">          0 :           if (namespaceDefinition != NULL)</span></a>
<a name="10244"><span class="lineNum">   10244 </span>            :              {</a>
<a name="10245"><span class="lineNum">   10245 </span><span class="lineNoCov">          0 :                SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="10246"><span class="lineNum">   10246 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(namespaceDeclaration != NULL);</span></a>
<a name="10247"><span class="lineNum">   10247 </span>            : #if 0</a>
<a name="10248"><span class="lineNum">   10248 </span>            :                printf (&quot;The declaration has been identified to be associuated with a valid namespace = %p = %s \n&quot;,namespaceDeclaration,namespaceDeclaration-&gt;get_name().str());</a>
<a name="10249"><span class="lineNum">   10249 </span>            :                printf (&quot;   --- declarationParent = %p = %s \n&quot;,declarationParent,declarationParent-&gt;class_name().c_str());</a>
<a name="10250"><span class="lineNum">   10250 </span>            :                printf (&quot;   --- Move declaration from scope = %p = %s to namespace = %p = %s \n&quot;,declarationParent,declarationParent-&gt;class_name().c_str(),namespaceDeclaration,namespaceDeclaration-&gt;get_name().str());</a>
<a name="10251"><span class="lineNum">   10251 </span>            : #endif</a>
<a name="10252"><span class="lineNum">   10252 </span>            : #if 0</a>
<a name="10253"><span class="lineNum">   10253 </span>            :                printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="10254"><span class="lineNum">   10254 </span>            :                ROSE_ABORT();</a>
<a name="10255"><span class="lineNum">   10255 </span>            : #endif</a>
<a name="10256"><span class="lineNum">   10256 </span>            :              }</a>
<a name="10257"><span class="lineNum">   10257 </span>            :             else</a>
<a name="10258"><span class="lineNum">   10258 </span>            :              {</a>
<a name="10259"><span class="lineNum">   10259 </span>            : #if 0</a>
<a name="10260"><span class="lineNum">   10260 </span>            :                printf (&quot;declaration is not associated with a namespace, so we don't have to wrap it: declarationScope = %p = %s \n&quot;,declarationScope,declarationScope-&gt;class_name().c_str());</a>
<a name="10261"><span class="lineNum">   10261 </span>            : #endif</a>
<a name="10262"><span class="lineNum">   10262 </span>            :              }</a>
<a name="10263"><span class="lineNum">   10263 </span>            :         }</a>
<a name="10264"><span class="lineNum">   10264 </span>            :        else</a>
<a name="10265"><span class="lineNum">   10265 </span>            :         {</a>
<a name="10266"><span class="lineNum">   10266 </span>            : #if 0</a>
<a name="10267"><span class="lineNum">   10267 </span>            :           printf (&quot;Warning: declarationParent == NULL: declarationStatement-&gt;get_parent() = %p = %s \n&quot;,declarationStatement-&gt;get_parent(), (declarationStatement-&gt;get_parent() != NULL) ? declarationStatement-&gt;get_parent()-&gt;class_name().c_str() : &quot;null&quot;);</a>
<a name="10268"><span class="lineNum">   10268 </span>            : #endif</a>
<a name="10269"><span class="lineNum">   10269 </span>            :        // ROSE_ASSERT(declarationParent != NULL);</a>
<a name="10270"><span class="lineNum">   10270 </span>            :         }</a>
<a name="10271"><span class="lineNum">   10271 </span>            : </a>
<a name="10272"><span class="lineNum">   10272 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="10273"><span class="lineNum">   10273 </span>            : </a>
<a name="10274"><span class="lineNum">   10274 </span>            : </a>
<a name="10275"><span class="lineNum">   10275 </span>            : bool</a>
<a name="10276"><span class="lineNum">   10276 </span><span class="lineNoCov">          0 : SageInterface::isTemplateInstantiationNode(SgNode* node)</span></a>
<a name="10277"><span class="lineNum">   10277 </span>            :    {</a>
<a name="10278"><span class="lineNum">   10278 </span>            :   // DQ (7/19/2015): I think we want to focus exclusively on declarations.</a>
<a name="10279"><span class="lineNum">   10279 </span><span class="lineNoCov">          0 :      if (isSgTemplateInstantiationDefn(node) != NULL)</span></a>
<a name="10280"><span class="lineNum">   10280 </span>            :         {</a>
<a name="10281"><span class="lineNum">   10281 </span>            : #if 0</a>
<a name="10282"><span class="lineNum">   10282 </span>            :           printf (&quot;Note: In SageInterface::isTemplateInstantiationNode(): skipping SgTemplateInstantiationDefn \n&quot;);</a>
<a name="10283"><span class="lineNum">   10283 </span>            : #endif</a>
<a name="10284"><span class="lineNum">   10284 </span>            :         }</a>
<a name="10285"><span class="lineNum">   10285 </span>            : </a>
<a name="10286"><span class="lineNum">   10286 </span><span class="lineNoCov">          0 :      return isSgTemplateInstantiationDecl(node)</span></a>
<a name="10287"><span class="lineNum">   10287 </span>            :       // DQ (1/3/2016): Allow SgTemplateInstantiationDefn IR nodes.</a>
<a name="10288"><span class="lineNum">   10288 </span>            : //       || isSgTemplateInstantiationDefn(node)</a>
<a name="10289"><span class="lineNum">   10289 </span><span class="lineNoCov">          0 :          || isSgTemplateInstantiationDefn(node)</span></a>
<a name="10290"><span class="lineNum">   10290 </span><span class="lineNoCov">          0 :          || isSgTemplateInstantiationFunctionDecl(node)</span></a>
<a name="10291"><span class="lineNum">   10291 </span><span class="lineNoCov">          0 :          || isSgTemplateInstantiationMemberFunctionDecl(node)</span></a>
<a name="10292"><span class="lineNum">   10292 </span><span class="lineNoCov">          0 :          || isSgTemplateInstantiationTypedefDeclaration(node)</span></a>
<a name="10293"><span class="lineNum">   10293 </span><span class="lineNoCov">          0 :          || isSgTemplateInstantiationDirectiveStatement(node)</span></a>
<a name="10294"><span class="lineNum">   10294 </span>            :          ;</a>
<a name="10295"><span class="lineNum">   10295 </span>            :    }</a>
<a name="10296"><span class="lineNum">   10296 </span>            : </a>
<a name="10297"><span class="lineNum">   10297 </span>            : #if 0</a>
<a name="10298"><span class="lineNum">   10298 </span>            : // DQ (6/27/2018): This will be the template declaration test version of the template instantiation test function above.</a>
<a name="10299"><span class="lineNum">   10299 </span>            : bool</a>
<a name="10300"><span class="lineNum">   10300 </span>            : SageInterface::isTemplateDeclarationNode(SgNode* node)</a>
<a name="10301"><span class="lineNum">   10301 </span>            :    {</a>
<a name="10302"><span class="lineNum">   10302 </span>            :   // DQ (7/19/2015): I think we want to focus exclusively on declarations.</a>
<a name="10303"><span class="lineNum">   10303 </span>            :      if (isSgTemplateDefinition(node) != NULL)</a>
<a name="10304"><span class="lineNum">   10304 </span>            :         {</a>
<a name="10305"><span class="lineNum">   10305 </span>            : #if 0</a>
<a name="10306"><span class="lineNum">   10306 </span>            :           printf (&quot;Note: In SageInterface::isTemplateDeclarationNode(): skipping SgTemplateDefinition \n&quot;);</a>
<a name="10307"><span class="lineNum">   10307 </span>            : #endif</a>
<a name="10308"><span class="lineNum">   10308 </span>            :         }</a>
<a name="10309"><span class="lineNum">   10309 </span>            : </a>
<a name="10310"><span class="lineNum">   10310 </span>            :      return isSgTemplateInstantiationDecl(node)</a>
<a name="10311"><span class="lineNum">   10311 </span>            :       // DQ (1/3/2016): Allow SgTemplateInstantiationDefn IR nodes.</a>
<a name="10312"><span class="lineNum">   10312 </span>            : //       || isSgTemplateInstantiationDefn(node)</a>
<a name="10313"><span class="lineNum">   10313 </span>            :          || isSgTemplateInstantiationDefn(node)</a>
<a name="10314"><span class="lineNum">   10314 </span>            :          || isSgTemplateInstantiationFunctionDecl(node)</a>
<a name="10315"><span class="lineNum">   10315 </span>            :          || isSgTemplateInstantiationMemberFunctionDecl(node)</a>
<a name="10316"><span class="lineNum">   10316 </span>            :          || isSgTemplateInstantiationTypedefDeclaration(node)</a>
<a name="10317"><span class="lineNum">   10317 </span>            :          || isSgTemplateInstantiationDirectiveStatement(node)</a>
<a name="10318"><span class="lineNum">   10318 </span>            :          ;</a>
<a name="10319"><span class="lineNum">   10319 </span>            :    }</a>
<a name="10320"><span class="lineNum">   10320 </span>            : #endif</a>
<a name="10321"><span class="lineNum">   10321 </span>            : </a>
<a name="10322"><span class="lineNum">   10322 </span>            : void</a>
<a name="10323"><span class="lineNum">   10323 </span><span class="lineNoCov">          0 : SageInterface::wrapAllTemplateInstantiationsInAssociatedNamespaces(SgProject* root)</span></a>
<a name="10324"><span class="lineNum">   10324 </span>            :    {</a>
<a name="10325"><span class="lineNum">   10325 </span>            :   // DQ (8/18/2015): This function is called from the tests/nonsmoke/functional/testTemplates translator.</a>
<a name="10326"><span class="lineNum">   10326 </span>            : </a>
<a name="10327"><span class="lineNum">   10327 </span>            :   // DQ (7/19/2015): This function can't use an iterator since it will be</a>
<a name="10328"><span class="lineNum">   10328 </span>            :   // doing transformations on the AST and will cause iterator invalidation errors.</a>
<a name="10329"><span class="lineNum">   10329 </span>            : </a>
<a name="10330"><span class="lineNum">   10330 </span>            : #if 0</a>
<a name="10331"><span class="lineNum">   10331 </span>            :      printf (&quot;In SageInterface::wrapAllTemplateInstantiationsInAssociatedNamespaces(): TOP \n&quot;);</a>
<a name="10332"><span class="lineNum">   10332 </span>            : #endif</a>
<a name="10333"><span class="lineNum">   10333 </span>            : </a>
<a name="10334"><span class="lineNum">   10334 </span><span class="lineNoCov">          0 :      std::vector&lt;SgDeclarationStatement*&gt; templateInstantiationVector;</span></a>
<a name="10335"><span class="lineNum">   10335 </span>            : </a>
<a name="10336"><span class="lineNum">   10336 </span>            :   // DQ (9/24/2015): This feature is not available yet in CMake (Markus is adding the library support for this feature).</a>
<a name="10337"><span class="lineNum">   10337 </span>            : #ifndef USE_CMAKEx</a>
<a name="10338"><span class="lineNum">   10338 </span><span class="lineNoCov">          0 :      RoseAst ast(root);</span></a>
<a name="10339"><span class="lineNum">   10339 </span>            : </a>
<a name="10340"><span class="lineNum">   10340 </span><span class="lineNoCov">          0 :      int n = 0;</span></a>
<a name="10341"><span class="lineNum">   10341 </span><span class="lineNoCov">          0 :      for (RoseAst::iterator i= ast.begin(); i!= ast.end(); ++i)</span></a>
<a name="10342"><span class="lineNum">   10342 </span>            :         {</a>
<a name="10343"><span class="lineNum">   10343 </span><span class="lineNoCov">          0 :           if (isTemplateInstantiationNode(*i))</span></a>
<a name="10344"><span class="lineNum">   10344 </span>            :              {</a>
<a name="10345"><span class="lineNum">   10345 </span>            :             // markNodeToBeUnparsed(*i);</a>
<a name="10346"><span class="lineNum">   10346 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* declaration = isSgDeclarationStatement(*i);</span></a>
<a name="10347"><span class="lineNum">   10347 </span>            : #if 0</a>
<a name="10348"><span class="lineNum">   10348 </span>            :                if (declaration == NULL)</a>
<a name="10349"><span class="lineNum">   10349 </span>            :                   {</a>
<a name="10350"><span class="lineNum">   10350 </span>            :                     printf (&quot;Error: found non-declaration statement: *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="10351"><span class="lineNum">   10351 </span>            :                   }</a>
<a name="10352"><span class="lineNum">   10352 </span>            : #endif</a>
<a name="10353"><span class="lineNum">   10353 </span>            : #if 1</a>
<a name="10354"><span class="lineNum">   10354 </span>            :             // DQ (1/3/2015): Newer version of code.</a>
<a name="10355"><span class="lineNum">   10355 </span><span class="lineNoCov">          0 :                if (declaration != NULL)</span></a>
<a name="10356"><span class="lineNum">   10356 </span>            :                   {</a>
<a name="10357"><span class="lineNum">   10357 </span><span class="lineNoCov">          0 :                     templateInstantiationVector.push_back(declaration);</span></a>
<a name="10358"><span class="lineNum">   10358 </span>            :                   }</a>
<a name="10359"><span class="lineNum">   10359 </span>            :                  else</a>
<a name="10360"><span class="lineNum">   10360 </span>            :                   {</a>
<a name="10361"><span class="lineNum">   10361 </span>            :                  // I think it is OK that not all are a SgDeclarationStatement.</a>
<a name="10362"><span class="lineNum">   10362 </span>            :                   }</a>
<a name="10363"><span class="lineNum">   10363 </span>            : #else</a>
<a name="10364"><span class="lineNum">   10364 </span>            :             // DQ (1/3/2015): Older version of code.</a>
<a name="10365"><span class="lineNum">   10365 </span>            :                ROSE_ASSERT(declaration != NULL);</a>
<a name="10366"><span class="lineNum">   10366 </span>            : </a>
<a name="10367"><span class="lineNum">   10367 </span>            :                templateInstantiationVector.push_back(declaration);</a>
<a name="10368"><span class="lineNum">   10368 </span>            : #endif</a>
<a name="10369"><span class="lineNum">   10369 </span><span class="lineNoCov">          0 :                n++;</span></a>
<a name="10370"><span class="lineNum">   10370 </span>            :              }</a>
<a name="10371"><span class="lineNum">   10371 </span>            :        }</a>
<a name="10372"><span class="lineNum">   10372 </span>            : #else</a>
<a name="10373"><span class="lineNum">   10373 </span>            :      std::cerr &lt;&lt; &quot;This feature for now is available with autotools only!&quot; &lt;&lt; std::endl;</a>
<a name="10374"><span class="lineNum">   10374 </span>            :      ROSE_ABORT();</a>
<a name="10375"><span class="lineNum">   10375 </span>            : #endif</a>
<a name="10376"><span class="lineNum">   10376 </span>            : </a>
<a name="10377"><span class="lineNum">   10377 </span>            : #if 0</a>
<a name="10378"><span class="lineNum">   10378 </span>            :      printf (&quot;Identified n = %d template instantiations \n&quot;,n);</a>
<a name="10379"><span class="lineNum">   10379 </span>            : #endif</a>
<a name="10380"><span class="lineNum">   10380 </span>            : </a>
<a name="10381"><span class="lineNum">   10381 </span><span class="lineNoCov">          0 :      std::vector&lt;SgDeclarationStatement*&gt;::iterator j = templateInstantiationVector.begin();</span></a>
<a name="10382"><span class="lineNum">   10382 </span><span class="lineNoCov">          0 :      while (j != templateInstantiationVector.end())</span></a>
<a name="10383"><span class="lineNum">   10383 </span>            :         {</a>
<a name="10384"><span class="lineNum">   10384 </span><span class="lineNoCov">          0 :           moveDeclarationToAssociatedNamespace(*j);</span></a>
<a name="10385"><span class="lineNum">   10385 </span>            : </a>
<a name="10386"><span class="lineNum">   10386 </span>            : #if 0</a>
<a name="10387"><span class="lineNum">   10387 </span>            :           printf (&quot;After processing first intatiation: Exiting as a test! \n&quot;);</a>
<a name="10388"><span class="lineNum">   10388 </span>            :           ROSE_ABORT();</a>
<a name="10389"><span class="lineNum">   10389 </span>            : #endif</a>
<a name="10390"><span class="lineNum">   10390 </span>            : </a>
<a name="10391"><span class="lineNum">   10391 </span><span class="lineNoCov">          0 :           j++;</span></a>
<a name="10392"><span class="lineNum">   10392 </span>            :         }</a>
<a name="10393"><span class="lineNum">   10393 </span>            : </a>
<a name="10394"><span class="lineNum">   10394 </span>            : #if 0</a>
<a name="10395"><span class="lineNum">   10395 </span>            :      printf (&quot;Leaving SageInterface::wrapAllTemplateInstantiationsInAssociatedNamespaces(): Exiting as a test! \n&quot;);</a>
<a name="10396"><span class="lineNum">   10396 </span>            :   // ROSE_ASSERT(false);</a>
<a name="10397"><span class="lineNum">   10397 </span>            : #endif</a>
<a name="10398"><span class="lineNum">   10398 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="10399"><span class="lineNum">   10399 </span>            : </a>
<a name="10400"><span class="lineNum">   10400 </span>            : </a>
<a name="10401"><span class="lineNum">   10401 </span>            : </a>
<a name="10402"><span class="lineNum">   10402 </span>            : //! Replace an anchor node with a specified pattern subtree with optional SgVariantExpression.</a>
<a name="10403"><span class="lineNum">   10403 </span>            : // All SgVariantExpression in the pattern will be replaced with copies of the anchor node.</a>
<a name="10404"><span class="lineNum">   10404 </span><span class="lineCov">          1 : SgNode* SageInterface::replaceWithPattern (SgNode * anchor, SgNode* new_pattern)</span></a>
<a name="10405"><span class="lineNum">   10405 </span>            : {</a>
<a name="10406"><span class="lineNum">   10406 </span><span class="lineCov">          1 :   SgExpression * anchor_exp = isSgExpression(anchor);</span></a>
<a name="10407"><span class="lineNum">   10407 </span><span class="lineCov">          1 :   SgExpression * pattern_exp = isSgExpression(new_pattern);</span></a>
<a name="10408"><span class="lineNum">   10408 </span><span class="lineCov">          1 :   ROSE_ASSERT (anchor_exp != NULL);</span></a>
<a name="10409"><span class="lineNum">   10409 </span><span class="lineCov">          1 :   ROSE_ASSERT (pattern_exp != NULL);</span></a>
<a name="10410"><span class="lineNum">   10410 </span>            : </a>
<a name="10411"><span class="lineNum">   10411 </span>            :    // we replace all SgExpression within the pattern with copies of anchor</a>
<a name="10412"><span class="lineNum">   10412 </span><span class="lineCov">          1 :    Rose_STL_Container&lt;SgNode*&gt; opaque_exp_list = NodeQuery::querySubTree(pattern_exp,V_SgExpression);</span></a>
<a name="10413"><span class="lineNum">   10413 </span><span class="lineCov">          5 :    for (size_t i = 0; i&lt;opaque_exp_list.size(); i++)</span></a>
<a name="10414"><span class="lineNum">   10414 </span>            :    {</a>
<a name="10415"><span class="lineNum">   10415 </span><span class="lineCov">          4 :      SgExpression* opaque_exp = isSgExpression(opaque_exp_list[i]);</span></a>
<a name="10416"><span class="lineNum">   10416 </span><span class="lineCov">          4 :      ROSE_ASSERT (opaque_exp != NULL);</span></a>
<a name="10417"><span class="lineNum">   10417 </span><span class="lineCov">          4 :      if (opaque_exp-&gt;variantT() == V_SgVariantExpression)</span></a>
<a name="10418"><span class="lineNum">   10418 </span>            :      {</a>
<a name="10419"><span class="lineNum">   10419 </span><span class="lineCov">          1 :        SgExpression * anchor_exp_copy = deepCopy(anchor_exp);</span></a>
<a name="10420"><span class="lineNum">   10420 </span><span class="lineCov">          1 :        replaceExpression(opaque_exp, anchor_exp_copy);</span></a>
<a name="10421"><span class="lineNum">   10421 </span>            :      }</a>
<a name="10422"><span class="lineNum">   10422 </span>            :    }</a>
<a name="10423"><span class="lineNum">   10423 </span>            : </a>
<a name="10424"><span class="lineNum">   10424 </span>            :    // finally we replace anchor_exp with the pattern_exp</a>
<a name="10425"><span class="lineNum">   10425 </span><span class="lineCov">          1 :    replaceExpression(anchor_exp, pattern_exp, false);</span></a>
<a name="10426"><span class="lineNum">   10426 </span><span class="lineCov">          2 :   return new_pattern;</span></a>
<a name="10427"><span class="lineNum">   10427 </span>            : }</a>
<a name="10428"><span class="lineNum">   10428 </span>            : /** Generate a name that is unique in the current scope and any parent and children scopes.</a>
<a name="10429"><span class="lineNum">   10429 </span>            :  * @param baseName the word to be included in the variable names. */</a>
<a name="10430"><span class="lineNum">   10430 </span><span class="lineCov">        729 : string SageInterface::generateUniqueVariableName(SgScopeStatement* scope, std::string baseName)</span></a>
<a name="10431"><span class="lineNum">   10431 </span>            : {</a>
<a name="10432"><span class="lineNum">   10432 </span>            :     //This implementation tends to generate numbers that are unnecessarily high.</a>
<a name="10433"><span class="lineNum">   10433 </span><span class="lineCov">        729 :     static int counter = 0;</span></a>
<a name="10434"><span class="lineNum">   10434 </span>            : </a>
<a name="10435"><span class="lineNum">   10435 </span><span class="lineCov">        729 :     string name;</span></a>
<a name="10436"><span class="lineNum">   10436 </span><span class="lineCov">        729 :     bool collision = false;</span></a>
<a name="10437"><span class="lineNum">   10437 </span><span class="lineCov">       1458 :     do</span></a>
<a name="10438"><span class="lineNum">   10438 </span>            :     {</a>
<a name="10439"><span class="lineNum">   10439 </span><span class="lineCov">        729 :         name = &quot;__&quot; + baseName + boost::lexical_cast&lt;string &gt; (counter++) + &quot;__&quot;;</span></a>
<a name="10440"><span class="lineNum">   10440 </span>            : </a>
<a name="10441"><span class="lineNum">   10441 </span>            :      // DQ (8/16/2013): Modified to reflect new API.</a>
<a name="10442"><span class="lineNum">   10442 </span>            :      // Look up the name in the parent scopes</a>
<a name="10443"><span class="lineNum">   10443 </span>            :      // SgSymbol* nameSymbol = SageInterface::lookupSymbolInParentScopes(SgName(name), scope);</a>
<a name="10444"><span class="lineNum">   10444 </span><span class="lineCov">        729 :         SgSymbol* nameSymbol = SageInterface::lookupSymbolInParentScopes(SgName(name), scope,NULL,NULL);</span></a>
<a name="10445"><span class="lineNum">   10445 </span><span class="lineCov">        729 :         collision = (nameSymbol != NULL);</span></a>
<a name="10446"><span class="lineNum">   10446 </span>            : </a>
<a name="10447"><span class="lineNum">   10447 </span>            :         //Look up the name in the children scopes</a>
<a name="10448"><span class="lineNum">   10448 </span><span class="lineCov">       1458 :         Rose_STL_Container&lt;SgNode*&gt; childScopes = NodeQuery::querySubTree(scope, V_SgScopeStatement);</span></a>
<a name="10449"><span class="lineNum">   10449 </span>            : </a>
<a name="10450"><span class="lineNum">   10450 </span><span class="lineCov">       2965 :         BOOST_FOREACH(SgNode* childScope, childScopes)</span></a>
<a name="10451"><span class="lineNum">   10451 </span>            :         {</a>
<a name="10452"><span class="lineNum">   10452 </span><span class="lineCov">       2236 :             SgScopeStatement* childScopeStatement = isSgScopeStatement(childScope);</span></a>
<a name="10453"><span class="lineNum">   10453 </span>            : </a>
<a name="10454"><span class="lineNum">   10454 </span>            :          // DQ (8/16/2013): Modified to reflect new API.</a>
<a name="10455"><span class="lineNum">   10455 </span>            :          // nameSymbol = childScopeStatement-&gt;lookup_symbol(SgName(name));</a>
<a name="10456"><span class="lineNum">   10456 </span><span class="lineCov">       2236 :             nameSymbol = childScopeStatement-&gt;lookup_symbol(SgName(name),NULL,NULL);</span></a>
<a name="10457"><span class="lineNum">   10457 </span>            : </a>
<a name="10458"><span class="lineNum">   10458 </span><span class="lineCov">       2236 :             collision = collision || (nameSymbol != NULL);</span></a>
<a name="10459"><span class="lineNum">   10459 </span>            :         }</a>
<a name="10460"><span class="lineNum">   10460 </span>            :     } while (collision);</a>
<a name="10461"><span class="lineNum">   10461 </span>            : </a>
<a name="10462"><span class="lineNum">   10462 </span><span class="lineCov">        729 :     return name;</span></a>
<a name="10463"><span class="lineNum">   10463 </span>            : }</a>
<a name="10464"><span class="lineNum">   10464 </span>            : </a>
<a name="10465"><span class="lineNum">   10465 </span>            : </a>
<a name="10466"><span class="lineNum">   10466 </span><span class="lineCov">        687 : std::pair&lt;SgVariableDeclaration*, SgExpression*&gt; SageInterface::createTempVariableForExpression</span></a>
<a name="10467"><span class="lineNum">   10467 </span>            : (SgExpression* expression, SgScopeStatement* scope, bool initializeInDeclaration, SgAssignOp** reEvaluate)</a>
<a name="10468"><span class="lineNum">   10468 </span>            : {</a>
<a name="10469"><span class="lineNum">   10469 </span><span class="lineCov">        687 :     SgType* expressionType = expression-&gt;get_type();</span></a>
<a name="10470"><span class="lineNum">   10470 </span><span class="lineCov">        687 :     SgType* variableType = expressionType;</span></a>
<a name="10471"><span class="lineNum">   10471 </span>            : </a>
<a name="10472"><span class="lineNum">   10472 </span>            :     //If the expression has a reference type, we need to use a pointer type for the temporary variable.</a>
<a name="10473"><span class="lineNum">   10473 </span>            :     //Else, re-assigning the variable is not possible</a>
<a name="10474"><span class="lineNum">   10474 </span><span class="lineCov">        687 :     bool isReferenceType = SageInterface::isReferenceType(expressionType);</span></a>
<a name="10475"><span class="lineNum">   10475 </span><span class="lineCov">        687 :     if (isReferenceType)</span></a>
<a name="10476"><span class="lineNum">   10476 </span>            :     {</a>
<a name="10477"><span class="lineNum">   10477 </span><span class="lineNoCov">          0 :         SgType* expressionBaseType = expressionType-&gt;stripType(SgType::STRIP_TYPEDEF_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE);</span></a>
<a name="10478"><span class="lineNum">   10478 </span><span class="lineNoCov">          0 :         variableType = SageBuilder::buildPointerType(expressionBaseType);</span></a>
<a name="10479"><span class="lineNum">   10479 </span>            :     }</a>
<a name="10480"><span class="lineNum">   10480 </span>            : </a>
<a name="10481"><span class="lineNum">   10481 </span>            :     //MS 10/24/2018: If the expression has array type, we need to use a pointer type referring to the base type for the temporary variable.</a>
<a name="10482"><span class="lineNum">   10482 </span><span class="lineCov">        687 :     if (SgArrayType* arrayType=isSgArrayType(expressionType)) {</span></a>
<a name="10483"><span class="lineNum">   10483 </span><span class="lineNoCov">          0 :       if(SgArrayType* strippedArrayType = isSgArrayType(arrayType-&gt;stripType(SgType::STRIP_TYPEDEF_TYPE))) {</span></a>
<a name="10484"><span class="lineNum">   10484 </span><span class="lineNoCov">          0 :         SgType* strippedArrayBaseType = strippedArrayType-&gt;get_base_type();</span></a>
<a name="10485"><span class="lineNum">   10485 </span><span class="lineNoCov">          0 :         variableType = SageBuilder::buildPointerType(strippedArrayBaseType);</span></a>
<a name="10486"><span class="lineNum">   10486 </span>            :       }</a>
<a name="10487"><span class="lineNum">   10487 </span>            :     }</a>
<a name="10488"><span class="lineNum">   10488 </span>            : </a>
<a name="10489"><span class="lineNum">   10489 </span>            :     // If the expression is a dereferenced pointer, use a reference to hold it.</a>
<a name="10490"><span class="lineNum">   10490 </span><span class="lineCov">        687 :     if (isSgPointerDerefExp(expression))</span></a>
<a name="10491"><span class="lineNum">   10491 </span><span class="lineNoCov">          0 :         variableType = SageBuilder::buildReferenceType(variableType);</span></a>
<a name="10492"><span class="lineNum">   10492 </span>            : </a>
<a name="10493"><span class="lineNum">   10493 </span>            :     //Generate a unique variable name</a>
<a name="10494"><span class="lineNum">   10494 </span><span class="lineCov">        687 :     string name = generateUniqueVariableName(scope);</span></a>
<a name="10495"><span class="lineNum">   10495 </span>            : </a>
<a name="10496"><span class="lineNum">   10496 </span>            :     //Initialize the temporary variable to an evaluation of the expression</a>
<a name="10497"><span class="lineNum">   10497 </span><span class="lineCov">        687 :     SgExpression* tempVarInitExpression = SageInterface::copyExpression(expression);</span></a>
<a name="10498"><span class="lineNum">   10498 </span><span class="lineCov">        687 :     ROSE_ASSERT(tempVarInitExpression != NULL);</span></a>
<a name="10499"><span class="lineNum">   10499 </span><span class="lineCov">        687 :     if (isReferenceType)</span></a>
<a name="10500"><span class="lineNum">   10500 </span>            :     {</a>
<a name="10501"><span class="lineNum">   10501 </span>            :         //FIXME: the next line is hiding a bug in ROSE. Remove this line and talk to Dan about the resulting assert</a>
<a name="10502"><span class="lineNum">   10502 </span><span class="lineNoCov">          0 :         tempVarInitExpression-&gt;set_lvalue(false);</span></a>
<a name="10503"><span class="lineNum">   10503 </span>            : </a>
<a name="10504"><span class="lineNum">   10504 </span><span class="lineNoCov">          0 :         tempVarInitExpression = SageBuilder::buildAddressOfOp(tempVarInitExpression);</span></a>
<a name="10505"><span class="lineNum">   10505 </span>            :     }</a>
<a name="10506"><span class="lineNum">   10506 </span>            : </a>
<a name="10507"><span class="lineNum">   10507 </span>            :     //Optionally initialize the variable in its declaration</a>
<a name="10508"><span class="lineNum">   10508 </span><span class="lineCov">        687 :     SgAssignInitializer* initializer = NULL;</span></a>
<a name="10509"><span class="lineNum">   10509 </span><span class="lineCov">        687 :     if (initializeInDeclaration)</span></a>
<a name="10510"><span class="lineNum">   10510 </span>            :     {</a>
<a name="10511"><span class="lineNum">   10511 </span><span class="lineCov">        687 :         SgExpression* initExpressionCopy = SageInterface::copyExpression(tempVarInitExpression);</span></a>
<a name="10512"><span class="lineNum">   10512 </span><span class="lineCov">        687 :         initializer = SageBuilder::buildAssignInitializer(initExpressionCopy);</span></a>
<a name="10513"><span class="lineNum">   10513 </span>            :     }</a>
<a name="10514"><span class="lineNum">   10514 </span>            : </a>
<a name="10515"><span class="lineNum">   10515 </span><span class="lineCov">        687 :     SgVariableDeclaration* tempVarDeclaration = SageBuilder::buildVariableDeclaration(name, variableType, initializer, scope);</span></a>
<a name="10516"><span class="lineNum">   10516 </span><span class="lineCov">        687 :     ROSE_ASSERT(tempVarDeclaration != NULL);</span></a>
<a name="10517"><span class="lineNum">   10517 </span>            : </a>
<a name="10518"><span class="lineNum">   10518 </span>            :     //Now create the assignment op for reevaluating the expression</a>
<a name="10519"><span class="lineNum">   10519 </span><span class="lineCov">        687 :     if (reEvaluate != NULL)</span></a>
<a name="10520"><span class="lineNum">   10520 </span>            :     {</a>
<a name="10521"><span class="lineNum">   10521 </span><span class="lineNoCov">          0 :         SgVarRefExp* tempVarReference = SageBuilder::buildVarRefExp(tempVarDeclaration);</span></a>
<a name="10522"><span class="lineNum">   10522 </span><span class="lineNoCov">          0 :         *reEvaluate = SageBuilder::buildAssignOp(tempVarReference, tempVarInitExpression);</span></a>
<a name="10523"><span class="lineNum">   10523 </span>            :     }</a>
<a name="10524"><span class="lineNum">   10524 </span>            : </a>
<a name="10525"><span class="lineNum">   10525 </span>            :     //Build the variable reference expression that can be used in place of the original expression</a>
<a name="10526"><span class="lineNum">   10526 </span><span class="lineCov">        687 :     SgExpression* varRefExpression = SageBuilder::buildVarRefExp(tempVarDeclaration);</span></a>
<a name="10527"><span class="lineNum">   10527 </span><span class="lineCov">        687 :     if (isReferenceType)</span></a>
<a name="10528"><span class="lineNum">   10528 </span>            :     {</a>
<a name="10529"><span class="lineNum">   10529 </span>            :         //The temp variable is a pointer type, so dereference it before using it</a>
<a name="10530"><span class="lineNum">   10530 </span><span class="lineNoCov">          0 :         varRefExpression = SageBuilder::buildPointerDerefExp(varRefExpression);</span></a>
<a name="10531"><span class="lineNum">   10531 </span>            :     }</a>
<a name="10532"><span class="lineNum">   10532 </span>            : </a>
<a name="10533"><span class="lineNum">   10533 </span><span class="lineCov">        687 :     return std::make_pair(tempVarDeclaration, varRefExpression);</span></a>
<a name="10534"><span class="lineNum">   10534 </span>            : }</a>
<a name="10535"><span class="lineNum">   10535 </span>            : </a>
<a name="10536"><span class="lineNum">   10536 </span>            : // This function creates a temporary variable for a given expression in the given scope</a>
<a name="10537"><span class="lineNum">   10537 </span>            : // This is different from SageInterface::createTempVariableForExpression in that it does not</a>
<a name="10538"><span class="lineNum">   10538 </span>            : // try to be smart to create pointers to reference types and so on. The tempt is initialized to expression.</a>
<a name="10539"><span class="lineNum">   10539 </span>            : // The caller is responsible for setting the parent of SgVariableDeclaration since buildVariableDeclaration</a>
<a name="10540"><span class="lineNum">   10540 </span>            : // may not set_parent() when the scope stack is empty. See programTransformation/extractFunctionArgumentsNormalization/ExtractFunctionArguments.C for sample usage.</a>
<a name="10541"><span class="lineNum">   10541 </span>            : </a>
<a name="10542"><span class="lineNum">   10542 </span><span class="lineNoCov">          0 : std::pair&lt;SgVariableDeclaration*, SgExpression*&gt; SageInterface::createTempVariableAndReferenceForExpression</span></a>
<a name="10543"><span class="lineNum">   10543 </span>            : (SgExpression* expression, SgScopeStatement* scope)</a>
<a name="10544"><span class="lineNum">   10544 </span>            : {</a>
<a name="10545"><span class="lineNum">   10545 </span><span class="lineNoCov">          0 :     SgType* expressionType = expression-&gt;get_type();</span></a>
<a name="10546"><span class="lineNum">   10546 </span><span class="lineNoCov">          0 :     SgType* variableType = expressionType;</span></a>
<a name="10547"><span class="lineNum">   10547 </span>            : </a>
<a name="10548"><span class="lineNum">   10548 </span>            :     //MS 10/24/2018: If the expression has array type, we need to use a pointer type for the temporary variable.</a>
<a name="10549"><span class="lineNum">   10549 </span><span class="lineNoCov">          0 :     if (SgArrayType* arrayType=isSgArrayType(expressionType))</span></a>
<a name="10550"><span class="lineNum">   10550 </span>            :     {</a>
<a name="10551"><span class="lineNum">   10551 </span><span class="lineNoCov">          0 :       if(SgArrayType* strippedArrayType = isSgArrayType(arrayType-&gt;stripType(SgType::STRIP_TYPEDEF_TYPE))) {</span></a>
<a name="10552"><span class="lineNum">   10552 </span><span class="lineNoCov">          0 :         SgType* strippedArrayBaseType = strippedArrayType-&gt;get_base_type();</span></a>
<a name="10553"><span class="lineNum">   10553 </span><span class="lineNoCov">          0 :         variableType = SageBuilder::buildPointerType(strippedArrayBaseType);</span></a>
<a name="10554"><span class="lineNum">   10554 </span>            :       }</a>
<a name="10555"><span class="lineNum">   10555 </span>            :     }</a>
<a name="10556"><span class="lineNum">   10556 </span>            : </a>
<a name="10557"><span class="lineNum">   10557 </span>            :     //Generate a unique variable name</a>
<a name="10558"><span class="lineNum">   10558 </span><span class="lineNoCov">          0 :     string name = generateUniqueVariableName(scope);</span></a>
<a name="10559"><span class="lineNum">   10559 </span>            : </a>
<a name="10560"><span class="lineNum">   10560 </span>            :     //initialize the variable in its declaration</a>
<a name="10561"><span class="lineNum">   10561 </span><span class="lineNoCov">          0 :     SgAssignInitializer* initializer = NULL;</span></a>
<a name="10562"><span class="lineNum">   10562 </span><span class="lineNoCov">          0 :     SgExpression* initExpressionCopy = SageInterface::copyExpression(expression);</span></a>
<a name="10563"><span class="lineNum">   10563 </span><span class="lineNoCov">          0 :     initializer = SageBuilder::buildAssignInitializer(initExpressionCopy);</span></a>
<a name="10564"><span class="lineNum">   10564 </span>            : </a>
<a name="10565"><span class="lineNum">   10565 </span><span class="lineNoCov">          0 :     SgVariableDeclaration* tempVarDeclaration = SageBuilder::buildVariableDeclaration(name, variableType, initializer, scope);</span></a>
<a name="10566"><span class="lineNum">   10566 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(tempVarDeclaration != NULL);</span></a>
<a name="10567"><span class="lineNum">   10567 </span>            : </a>
<a name="10568"><span class="lineNum">   10568 </span>            :     //Build the variable reference expression that can be used in place of the original expression</a>
<a name="10569"><span class="lineNum">   10569 </span><span class="lineNoCov">          0 :     SgExpression* varRefExpression = SageBuilder::buildVarRefExp(tempVarDeclaration);</span></a>
<a name="10570"><span class="lineNum">   10570 </span><span class="lineNoCov">          0 :     return std::make_pair(tempVarDeclaration, varRefExpression);</span></a>
<a name="10571"><span class="lineNum">   10571 </span>            : }</a>
<a name="10572"><span class="lineNum">   10572 </span>            : </a>
<a name="10573"><span class="lineNum">   10573 </span>            : </a>
<a name="10574"><span class="lineNum">   10574 </span>            : namespace</a>
<a name="10575"><span class="lineNum">   10575 </span>            : {</a>
<a name="10576"><span class="lineNum">   10576 </span>            :   void</a>
<a name="10577"><span class="lineNum">   10577 </span>            :   replaceExpressionInSgExpressionPtrList(SgExpression* oldExp, SgExpression* newExp, SgExpressionPtrList&amp; lst, bool replAll = false)</a>
<a name="10578"><span class="lineNum">   10578 </span>            :   {</a>
<a name="10579"><span class="lineNum">   10579 </span>            :     SgExpressionPtrList::iterator lim = lst.end();</a>
<a name="10580"><span class="lineNum">   10580 </span>            :     SgExpressionPtrList::iterator pos = lst.begin();</a>
<a name="10581"><span class="lineNum">   10581 </span>            :     bool                          chg = false;</a>
<a name="10582"><span class="lineNum">   10582 </span>            : </a>
<a name="10583"><span class="lineNum">   10583 </span>            :     do</a>
<a name="10584"><span class="lineNum">   10584 </span>            :     {</a>
<a name="10585"><span class="lineNum">   10585 </span>            :       pos = std::find(pos, lim, oldExp);</a>
<a name="10586"><span class="lineNum">   10586 </span>            : </a>
<a name="10587"><span class="lineNum">   10587 </span>            :       if (pos != lim) { *pos = newExp; ++pos; chg = true; }</a>
<a name="10588"><span class="lineNum">   10588 </span>            :     } while (replAll &amp;&amp; (pos != lim));</a>
<a name="10589"><span class="lineNum">   10589 </span>            : </a>
<a name="10590"><span class="lineNum">   10590 </span>            :     ROSE_ASSERT(chg);</a>
<a name="10591"><span class="lineNum">   10591 </span>            :   }</a>
<a name="10592"><span class="lineNum">   10592 </span>            : }</a>
<a name="10593"><span class="lineNum">   10593 </span>            : </a>
<a name="10594"><span class="lineNum">   10594 </span>            : // This code is based on OpenMP translator's ASTtools::replaceVarRefExp() and astInling's replaceExpressionWithExpression()</a>
<a name="10595"><span class="lineNum">   10595 </span>            : // Motivation: It involves the parent node to replace a VarRefExp with a new node</a>
<a name="10596"><span class="lineNum">   10596 </span>            : // Used to replace shared variables with the dereference expression of their addresses</a>
<a name="10597"><span class="lineNum">   10597 </span>            : // e.g. to replace shared1 with (*__pp_shared1)</a>
<a name="10598"><span class="lineNum">   10598 </span>            : </a>
<a name="10599"><span class="lineNum">   10599 </span><span class="lineCov">         43 : void SageInterface::replaceExpression(SgExpression* oldExp, SgExpression* newExp, bool keepOldExp/*=false*/) {</span></a>
<a name="10600"><span class="lineNum">   10600 </span><span class="lineCov">         43 :   SgExpression* parentExp;</span></a>
<a name="10601"><span class="lineNum">   10601 </span>            : </a>
<a name="10602"><span class="lineNum">   10602 </span><span class="lineCov">         43 :   ROSE_ASSERT(oldExp);</span></a>
<a name="10603"><span class="lineNum">   10603 </span><span class="lineCov">         43 :   ROSE_ASSERT(newExp);</span></a>
<a name="10604"><span class="lineNum">   10604 </span><span class="lineCov">         43 :   if (oldExp==newExp) return;</span></a>
<a name="10605"><span class="lineNum">   10605 </span>            : </a>
<a name="10606"><span class="lineNum">   10606 </span><span class="lineCov">         43 :   if (isSgVarRefExp(newExp))</span></a>
<a name="10607"><span class="lineNum">   10607 </span><span class="lineNoCov">          0 :     newExp-&gt;set_need_paren(true); // enclosing new expression with () to be safe</span></a>
<a name="10608"><span class="lineNum">   10608 </span>            : </a>
<a name="10609"><span class="lineNum">   10609 </span><span class="lineCov">         43 :   SgNode* parent = oldExp-&gt;get_parent();</span></a>
<a name="10610"><span class="lineNum">   10610 </span><span class="lineCov">         43 :   ROSE_ASSERT(parent!=NULL);</span></a>
<a name="10611"><span class="lineNum">   10611 </span><span class="lineCov">         43 :   newExp-&gt;set_parent(parent);</span></a>
<a name="10612"><span class="lineNum">   10612 </span>            : </a>
<a name="10613"><span class="lineNum">   10613 </span>            :   // set lvalue when necessary</a>
<a name="10614"><span class="lineNum">   10614 </span><span class="lineCov">         43 :   if (oldExp-&gt;get_lvalue() == true) newExp-&gt;set_lvalue(true);</span></a>
<a name="10615"><span class="lineNum">   10615 </span>            : </a>
<a name="10616"><span class="lineNum">   10616 </span><span class="lineCov">         43 :   if (isSgExprStatement(parent)) {</span></a>
<a name="10617"><span class="lineNum">   10617 </span><span class="lineCov">         21 :     isSgExprStatement(parent)-&gt;set_expression(newExp);</span></a>
<a name="10618"><span class="lineNum">   10618 </span><span class="lineCov">         22 :   } else if (isSgForStatement(parent)) {</span></a>
<a name="10619"><span class="lineNum">   10619 </span><span class="lineCov">          6 :     ROSE_ASSERT (isSgForStatement(parent)-&gt;get_increment() == oldExp);</span></a>
<a name="10620"><span class="lineNum">   10620 </span><span class="lineCov">          6 :     isSgForStatement(parent)-&gt;set_increment(newExp);</span></a>
<a name="10621"><span class="lineNum">   10621 </span>            :     // TODO: any other cases here??</a>
<a name="10622"><span class="lineNum">   10622 </span>            :   }</a>
<a name="10623"><span class="lineNum">   10623 </span><span class="lineCov">         16 :   else if (SgRangeExp* rngexp = isSgRangeExp(parent)) {</span></a>
<a name="10624"><span class="lineNum">   10624 </span><span class="lineNoCov">          0 :     if (rngexp-&gt;get_start() == oldExp)</span></a>
<a name="10625"><span class="lineNum">   10625 </span><span class="lineNoCov">          0 :       rngexp-&gt;set_start(newExp);</span></a>
<a name="10626"><span class="lineNum">   10626 </span><span class="lineNoCov">          0 :     else if (rngexp-&gt;get_end() == oldExp)</span></a>
<a name="10627"><span class="lineNum">   10627 </span><span class="lineNoCov">          0 :       rngexp-&gt;set_end(newExp);</span></a>
<a name="10628"><span class="lineNum">   10628 </span><span class="lineNoCov">          0 :     else if (rngexp-&gt;get_stride() == oldExp)</span></a>
<a name="10629"><span class="lineNum">   10629 </span><span class="lineNoCov">          0 :       rngexp-&gt;set_stride(newExp);</span></a>
<a name="10630"><span class="lineNum">   10630 </span>            :     else</a>
<a name="10631"><span class="lineNum">   10631 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(!&quot;sub-expression not found&quot;);</span></a>
<a name="10632"><span class="lineNum">   10632 </span><span class="lineCov">         16 :   } else if (isSgReturnStmt(parent)) {</span></a>
<a name="10633"><span class="lineNum">   10633 </span><span class="lineNoCov">          0 :     isSgReturnStmt(parent)-&gt;set_expression(newExp);</span></a>
<a name="10634"><span class="lineNum">   10634 </span><span class="lineCov">         16 :   } else  if (isSgBinaryOp(parent)!=NULL) {</span></a>
<a name="10635"><span class="lineNum">   10635 </span><span class="lineCov">         14 :     if (oldExp==isSgBinaryOp(parent)-&gt;get_lhs_operand()) {</span></a>
<a name="10636"><span class="lineNum">   10636 </span><span class="lineCov">          1 :       isSgBinaryOp(parent)-&gt;set_lhs_operand(newExp);</span></a>
<a name="10637"><span class="lineNum">   10637 </span><span class="lineCov">         13 :     } else if (oldExp==isSgBinaryOp(parent)-&gt;get_rhs_operand()) {</span></a>
<a name="10638"><span class="lineNum">   10638 </span><span class="lineCov">         13 :       isSgBinaryOp(parent)-&gt;set_rhs_operand(newExp);</span></a>
<a name="10639"><span class="lineNum">   10639 </span>            :     } else {</a>
<a name="10640"><span class="lineNum">   10640 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="10641"><span class="lineNum">   10641 </span>            :     }</a>
<a name="10642"><span class="lineNum">   10642 </span><span class="lineCov">          2 :   } else if (isSgUnaryOp(parent)!=NULL){</span></a>
<a name="10643"><span class="lineNum">   10643 </span><span class="lineNoCov">          0 :       if (oldExp==isSgUnaryOp(parent)-&gt;get_operand_i())</span></a>
<a name="10644"><span class="lineNum">   10644 </span><span class="lineNoCov">          0 :            isSgUnaryOp(parent)-&gt;set_operand_i(newExp);</span></a>
<a name="10645"><span class="lineNum">   10645 </span>            :       else</a>
<a name="10646"><span class="lineNum">   10646 </span><span class="lineNoCov">          0 :         ROSE_ABORT();</span></a>
<a name="10647"><span class="lineNum">   10647 </span><span class="lineCov">          2 :   } else if (isSgConditionalExp(parent) != NULL) {</span></a>
<a name="10648"><span class="lineNum">   10648 </span><span class="lineNoCov">          0 :      SgConditionalExp* expparent = isSgConditionalExp(parent); //get explicity type parent</span></a>
<a name="10649"><span class="lineNum">   10649 </span><span class="lineNoCov">          0 :      if (oldExp==expparent-&gt;get_conditional_exp())</span></a>
<a name="10650"><span class="lineNum">   10650 </span><span class="lineNoCov">          0 :         expparent-&gt;set_conditional_exp(newExp);</span></a>
<a name="10651"><span class="lineNum">   10651 </span><span class="lineNoCov">          0 :      else if (oldExp==expparent-&gt;get_true_exp())</span></a>
<a name="10652"><span class="lineNum">   10652 </span><span class="lineNoCov">          0 :         expparent-&gt;set_true_exp(newExp);</span></a>
<a name="10653"><span class="lineNum">   10653 </span><span class="lineNoCov">          0 :      else if (oldExp==expparent-&gt;get_false_exp())</span></a>
<a name="10654"><span class="lineNum">   10654 </span><span class="lineNoCov">          0 :         expparent-&gt;set_false_exp(newExp);</span></a>
<a name="10655"><span class="lineNum">   10655 </span>            :      else</a>
<a name="10656"><span class="lineNum">   10656 </span><span class="lineNoCov">          0 :         ROSE_ABORT();</span></a>
<a name="10657"><span class="lineNum">   10657 </span><span class="lineCov">          2 :   } else if (isSgExprListExp(parent) != NULL) {</span></a>
<a name="10658"><span class="lineNum">   10658 </span><span class="lineCov">          2 :     SgExpressionPtrList&amp; explist = isSgExprListExp(parent)-&gt;get_expressions();</span></a>
<a name="10659"><span class="lineNum">   10659 </span><span class="lineCov">          5 :     for (Rose_STL_Container&lt;SgExpression*&gt;::iterator i=explist.begin();i!=explist.end();i++) {</span></a>
<a name="10660"><span class="lineNum">   10660 </span><span class="lineCov">          3 :       if (isSgExpression(*i)==oldExp) {</span></a>
<a name="10661"><span class="lineNum">   10661 </span><span class="lineCov">          2 :         SgExprListExp* parentExpListExp = isSgExprListExp(parent);</span></a>
<a name="10662"><span class="lineNum">   10662 </span><span class="lineCov">          2 :         parentExpListExp-&gt;replace_expression(oldExp,newExp);</span></a>
<a name="10663"><span class="lineNum">   10663 </span>            :        // break; //replace the first occurrence only??</a>
<a name="10664"><span class="lineNum">   10664 </span>            :       }</a>
<a name="10665"><span class="lineNum">   10665 </span>            :     }</a>
<a name="10666"><span class="lineNum">   10666 </span>            :   }</a>
<a name="10667"><span class="lineNum">   10667 </span><span class="lineNoCov">          0 :   else if (isSgValueExp(parent)) {</span></a>
<a name="10668"><span class="lineNum">   10668 </span>            :       // For compiler generated code, this could happen.</a>
<a name="10669"><span class="lineNum">   10669 </span>            :       // We can just ignore this function call since it will not appear in the final AST.</a>
<a name="10670"><span class="lineNum">   10670 </span>            :       return;</a>
<a name="10671"><span class="lineNum">   10671 </span>            :   }</a>
<a name="10672"><span class="lineNum">   10672 </span><span class="lineNoCov">          0 :   else if (SgActualArgumentExpression* actexp = isSgActualArgumentExpression(parent)) {</span></a>
<a name="10673"><span class="lineNum">   10673 </span>            :     // PP (4/25/22) since SgExpression::replace_expression is deprecated, I added the</a>
<a name="10674"><span class="lineNum">   10674 </span>            :     //              functionality for replacing SgActualArgumentExpression::expression</a>
<a name="10675"><span class="lineNum">   10675 </span>            :     //              here.</a>
<a name="10676"><span class="lineNum">   10676 </span>            :     //              Note, this case needs to be ordered before isSgExpression!</a>
<a name="10677"><span class="lineNum">   10677 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(oldExp == actexp-&gt;get_expression());</span></a>
<a name="10678"><span class="lineNum">   10678 </span><span class="lineNoCov">          0 :     actexp-&gt;set_expression(newExp);</span></a>
<a name="10679"><span class="lineNum">   10679 </span><span class="lineNoCov">          0 :   } else if ((parentExp=isSgExpression(parent)) != NULL) {</span></a>
<a name="10680"><span class="lineNum">   10680 </span><span class="lineNoCov">          0 :     int worked = parentExp-&gt;replace_expression(oldExp, newExp);</span></a>
<a name="10681"><span class="lineNum">   10681 </span>            :     // ROSE_DEPRECATED_FUNCTION</a>
<a name="10682"><span class="lineNum">   10682 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (worked);</span></a>
<a name="10683"><span class="lineNum">   10683 </span><span class="lineNoCov">          0 :   } else if (isSgInitializedName(parent)) {</span></a>
<a name="10684"><span class="lineNum">   10684 </span><span class="lineNoCov">          0 :     SgInitializedName* initializedNameParent = isSgInitializedName(parent);</span></a>
<a name="10685"><span class="lineNum">   10685 </span><span class="lineNoCov">          0 :     if (oldExp == initializedNameParent-&gt;get_initializer()) {</span></a>
<a name="10686"><span class="lineNum">   10686 </span>            :       //We can only replace an initializer expression with another initializer expression</a>
<a name="10687"><span class="lineNum">   10687 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(isSgInitializer(newExp));</span></a>
<a name="10688"><span class="lineNum">   10688 </span><span class="lineNoCov">          0 :       initializedNameParent-&gt;set_initializer(isSgInitializer(newExp));</span></a>
<a name="10689"><span class="lineNum">   10689 </span>            :     } else {</a>
<a name="10690"><span class="lineNum">   10690 </span>            :       //What other expressions can be children of an SgInitializedname?</a>
<a name="10691"><span class="lineNum">   10691 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="10692"><span class="lineNum">   10692 </span>            :     }</a>
<a name="10693"><span class="lineNum">   10693 </span><span class="lineNoCov">          0 :   } else if (isSgCaseOptionStmt(parent)) {</span></a>
<a name="10694"><span class="lineNum">   10694 </span><span class="lineNoCov">          0 :     SgCaseOptionStmt * case_stmt = isSgCaseOptionStmt(parent);</span></a>
<a name="10695"><span class="lineNum">   10695 </span><span class="lineNoCov">          0 :     if (oldExp == case_stmt-&gt;get_key()) {</span></a>
<a name="10696"><span class="lineNum">   10696 </span><span class="lineNoCov">          0 :       case_stmt-&gt;set_key(newExp);</span></a>
<a name="10697"><span class="lineNum">   10697 </span><span class="lineNoCov">          0 :     } else if(oldExp == case_stmt-&gt;get_key_range_end()) {</span></a>
<a name="10698"><span class="lineNum">   10698 </span><span class="lineNoCov">          0 :       case_stmt-&gt;set_key_range_end(newExp);</span></a>
<a name="10699"><span class="lineNum">   10699 </span>            :     } else {</a>
<a name="10700"><span class="lineNum">   10700 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="10701"><span class="lineNum">   10701 </span>            :     }</a>
<a name="10702"><span class="lineNum">   10702 </span><span class="lineNoCov">          0 :   } else if (isSgProcessControlStatement(parent)) {</span></a>
<a name="10703"><span class="lineNum">   10703 </span><span class="lineNoCov">          0 :     SgProcessControlStatement * ctrl_stmt = (SgProcessControlStatement*)parent;</span></a>
<a name="10704"><span class="lineNum">   10704 </span><span class="lineNoCov">          0 :     if (oldExp == ctrl_stmt-&gt;get_quiet()) {</span></a>
<a name="10705"><span class="lineNum">   10705 </span><span class="lineNoCov">          0 :       ctrl_stmt-&gt;set_quiet(newExp);</span></a>
<a name="10706"><span class="lineNum">   10706 </span><span class="lineNoCov">          0 :     } else if (oldExp == ctrl_stmt-&gt;get_code()) {</span></a>
<a name="10707"><span class="lineNum">   10707 </span><span class="lineNoCov">          0 :       ctrl_stmt-&gt;set_code(newExp);</span></a>
<a name="10708"><span class="lineNum">   10708 </span>            :     } else {</a>
<a name="10709"><span class="lineNum">   10709 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="10710"><span class="lineNum">   10710 </span>            :     }</a>
<a name="10711"><span class="lineNum">   10711 </span><span class="lineNoCov">          0 :   } else if (isSgFortranDo(parent)) {</span></a>
<a name="10712"><span class="lineNum">   10712 </span><span class="lineNoCov">          0 :     SgFortranDo* fortranDo = isSgFortranDo(parent);</span></a>
<a name="10713"><span class="lineNum">   10713 </span><span class="lineNoCov">          0 :     if (oldExp == fortranDo-&gt;get_initialization()) {</span></a>
<a name="10714"><span class="lineNum">   10714 </span><span class="lineNoCov">          0 :       fortranDo-&gt;set_initialization(newExp);</span></a>
<a name="10715"><span class="lineNum">   10715 </span><span class="lineNoCov">          0 :     } else if(oldExp == fortranDo-&gt;get_bound()) {</span></a>
<a name="10716"><span class="lineNum">   10716 </span><span class="lineNoCov">          0 :       fortranDo-&gt;set_bound(newExp);</span></a>
<a name="10717"><span class="lineNum">   10717 </span><span class="lineNoCov">          0 :     } else if (oldExp == fortranDo-&gt;get_increment()) {</span></a>
<a name="10718"><span class="lineNum">   10718 </span><span class="lineNoCov">          0 :       fortranDo-&gt;set_increment(newExp);</span></a>
<a name="10719"><span class="lineNum">   10719 </span>            :     } else {</a>
<a name="10720"><span class="lineNum">   10720 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="10721"><span class="lineNum">   10721 </span>            :     }</a>
<a name="10722"><span class="lineNum">   10722 </span>            :   } else {</a>
<a name="10723"><span class="lineNum">   10723 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;SageInterface::replaceExpression(). Unhandled parent expression type of SageIII enum value: &quot; &lt;&lt;parent-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="10724"><span class="lineNum">   10724 </span><span class="lineNoCov">          0 :     ROSE_ABORT();</span></a>
<a name="10725"><span class="lineNum">   10725 </span>            :   }</a>
<a name="10726"><span class="lineNum">   10726 </span>            : </a>
<a name="10727"><span class="lineNum">   10727 </span><span class="lineCov">         43 :   if (!keepOldExp) {</span></a>
<a name="10728"><span class="lineNum">   10728 </span><span class="lineCov">         42 :     deepDelete(oldExp); // avoid dangling node in memory pool</span></a>
<a name="10729"><span class="lineNum">   10729 </span>            :   } else {</a>
<a name="10730"><span class="lineNum">   10730 </span><span class="lineCov">          1 :     oldExp-&gt;set_parent(NULL);</span></a>
<a name="10731"><span class="lineNum">   10731 </span>            :   }</a>
<a name="10732"><span class="lineNum">   10732 </span>            : </a>
<a name="10733"><span class="lineNum">   10733 </span>            : } //replaceExpression()</a>
<a name="10734"><span class="lineNum">   10734 </span>            : </a>
<a name="10735"><span class="lineNum">   10735 </span><span class="lineCov">       2742 : SgStatement* SageInterface::getNextStatement(SgStatement * currentStmt)</span></a>
<a name="10736"><span class="lineNum">   10736 </span>            :    {</a>
<a name="10737"><span class="lineNum">   10737 </span>            :   // reuse the implementation in ROSE namespace from src/roseSupport/utility_functions.C</a>
<a name="10738"><span class="lineNum">   10738 </span><span class="lineCov">       2742 :      return Rose::getNextStatement(currentStmt);</span></a>
<a name="10739"><span class="lineNum">   10739 </span>            :    }</a>
<a name="10740"><span class="lineNum">   10740 </span>            : </a>
<a name="10741"><span class="lineNum">   10741 </span><span class="lineCov">       3568 : SgStatement* SageInterface::getPreviousStatement(SgStatement * currentStmt, bool climbOutScope /*= true*/)</span></a>
<a name="10742"><span class="lineNum">   10742 </span>            :    {</a>
<a name="10743"><span class="lineNum">   10743 </span><span class="lineCov">       3568 :      return Rose::getPreviousStatement(currentStmt, climbOutScope);</span></a>
<a name="10744"><span class="lineNum">   10744 </span>            :    }</a>
<a name="10745"><span class="lineNum">   10745 </span>            : </a>
<a name="10746"><span class="lineNum">   10746 </span><span class="lineCov">       2141 : bool SageInterface::isEqualToIntConst(SgExpression* e, int value) {</span></a>
<a name="10747"><span class="lineNum">   10747 </span><span class="lineCov">       2141 :      return isSgIntVal(e) &amp;&amp; isSgIntVal(e)-&gt;get_value() == value;</span></a>
<a name="10748"><span class="lineNum">   10748 </span>            :   }</a>
<a name="10749"><span class="lineNum">   10749 </span>            : </a>
<a name="10750"><span class="lineNum">   10750 </span><span class="lineCov">      48752 :  bool SageInterface::isSameFunction(SgFunctionDeclaration* func1, SgFunctionDeclaration* func2)</span></a>
<a name="10751"><span class="lineNum">   10751 </span>            :  {</a>
<a name="10752"><span class="lineNum">   10752 </span><span class="lineCov">      48752 :    ROSE_ASSERT(func1&amp;&amp; func2);</span></a>
<a name="10753"><span class="lineNum">   10753 </span><span class="lineCov">      48752 :    bool result = false;</span></a>
<a name="10754"><span class="lineNum">   10754 </span><span class="lineCov">      48752 :    if (func1 == func2)</span></a>
<a name="10755"><span class="lineNum">   10755 </span>            :      result = true;</a>
<a name="10756"><span class="lineNum">   10756 </span>            :    else</a>
<a name="10757"><span class="lineNum">   10757 </span>            :     {</a>
<a name="10758"><span class="lineNum">   10758 </span><span class="lineCov">      48732 :       if (is_C_language()||is_C99_language()||is_Cuda_language()||is_OpenCL_language())</span></a>
<a name="10759"><span class="lineNum">   10759 </span>            :       {</a>
<a name="10760"><span class="lineNum">   10760 </span><span class="lineNoCov">          0 :         if (func1-&gt;get_name() == func2-&gt;get_name())</span></a>
<a name="10761"><span class="lineNum">   10761 </span><span class="lineNoCov">          0 :           result = true;</span></a>
<a name="10762"><span class="lineNum">   10762 </span>            :       }</a>
<a name="10763"><span class="lineNum">   10763 </span><span class="lineCov">      48732 :       else if (is_Cxx_language())</span></a>
<a name="10764"><span class="lineNum">   10764 </span>            :       {</a>
<a name="10765"><span class="lineNum">   10765 </span><span class="lineCov">      97460 :          if (func1-&gt;get_qualified_name().getString() +</span></a>
<a name="10766"><span class="lineNum">   10766 </span><span class="lineCov">     146190 :             func1-&gt;get_mangled_name().getString() ==</span></a>
<a name="10767"><span class="lineNum">   10767 </span><span class="lineCov">      97460 :             func2-&gt;get_qualified_name().getString() +</span></a>
<a name="10768"><span class="lineNum">   10768 </span><span class="lineCov">      97460 :             func2-&gt;get_mangled_name().getString()</span></a>
<a name="10769"><span class="lineNum">   10769 </span>            :             )</a>
<a name="10770"><span class="lineNum">   10770 </span><span class="lineCov">         10 :          result = true;</span></a>
<a name="10771"><span class="lineNum">   10771 </span>            :       }</a>
<a name="10772"><span class="lineNum">   10772 </span><span class="lineCov">          2 :       else if (is_Fortran_language())</span></a>
<a name="10773"><span class="lineNum">   10773 </span>            :       {</a>
<a name="10774"><span class="lineNum">   10774 </span><span class="lineCov">          2 :         if (func1-&gt;get_name() == func2-&gt;get_name())</span></a>
<a name="10775"><span class="lineNum">   10775 </span><span class="lineNoCov">          0 :           result = true;</span></a>
<a name="10776"><span class="lineNum">   10776 </span>            :       }</a>
<a name="10777"><span class="lineNum">   10777 </span>            :       else</a>
<a name="10778"><span class="lineNum">   10778 </span>            :       {</a>
<a name="10779"><span class="lineNum">   10779 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Error: SageInterface::isSameFunction(): unhandled language&quot;&lt;&lt;endl;</span></a>
<a name="10780"><span class="lineNum">   10780 </span><span class="lineNoCov">          0 :         ROSE_ABORT();</span></a>
<a name="10781"><span class="lineNum">   10781 </span>            :       }</a>
<a name="10782"><span class="lineNum">   10782 </span>            : </a>
<a name="10783"><span class="lineNum">   10783 </span>            :     } // not identical</a>
<a name="10784"><span class="lineNum">   10784 </span><span class="lineCov">      48752 :   return result;</span></a>
<a name="10785"><span class="lineNum">   10785 </span>            :  } // isSameFunction()</a>
<a name="10786"><span class="lineNum">   10786 </span>            : </a>
<a name="10787"><span class="lineNum">   10787 </span>            : //! Check if a statement is the last statement within its closed scope</a>
<a name="10788"><span class="lineNum">   10788 </span><span class="lineNoCov">          0 :  bool SageInterface::isLastStatement(SgStatement* stmt)</span></a>
<a name="10789"><span class="lineNum">   10789 </span>            : {</a>
<a name="10790"><span class="lineNum">   10790 </span><span class="lineNoCov">          0 :   bool result =false;</span></a>
<a name="10791"><span class="lineNum">   10791 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(stmt != NULL);</span></a>
<a name="10792"><span class="lineNum">   10792 </span><span class="lineNoCov">          0 :   SgScopeStatement* p_scope = stmt-&gt;get_scope();</span></a>
<a name="10793"><span class="lineNum">   10793 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(p_scope != NULL);</span></a>
<a name="10794"><span class="lineNum">   10794 </span>            : #if 0</a>
<a name="10795"><span class="lineNum">   10795 </span>            :   if (p_scope-&gt;containsOnlyDeclarations())</a>
<a name="10796"><span class="lineNum">   10796 </span>            :   {</a>
<a name="10797"><span class="lineNum">   10797 </span>            :     SgDeclarationStatementPtrList stmtlist= p_scope-&gt;getDeclarationList ()</a>
<a name="10798"><span class="lineNum">   10798 </span>            :       if (stmtlist[stmtlist.size()-1] == stmt)</a>
<a name="10799"><span class="lineNum">   10799 </span>            :         result = true;</a>
<a name="10800"><span class="lineNum">   10800 </span>            :   }</a>
<a name="10801"><span class="lineNum">   10801 </span>            :   else</a>
<a name="10802"><span class="lineNum">   10802 </span>            :   {</a>
<a name="10803"><span class="lineNum">   10803 </span>            :     SgStatementPtrList  stmtlist= p_scope-&gt;getStatementList ();</a>
<a name="10804"><span class="lineNum">   10804 </span>            :     if (stmtlist[stmtlist.size()-1] == stmt)</a>
<a name="10805"><span class="lineNum">   10805 </span>            :       result = true;</a>
<a name="10806"><span class="lineNum">   10806 </span>            :   }</a>
<a name="10807"><span class="lineNum">   10807 </span>            : #endif</a>
<a name="10808"><span class="lineNum">   10808 </span><span class="lineNoCov">          0 :   SgStatementPtrList  stmtlist= p_scope-&gt;generateStatementList ();</span></a>
<a name="10809"><span class="lineNum">   10809 </span><span class="lineNoCov">          0 :   if (stmtlist[stmtlist.size()-1] == stmt)</span></a>
<a name="10810"><span class="lineNum">   10810 </span><span class="lineNoCov">          0 :     result = true;</span></a>
<a name="10811"><span class="lineNum">   10811 </span>            : </a>
<a name="10812"><span class="lineNum">   10812 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="10813"><span class="lineNum">   10813 </span>            : }</a>
<a name="10814"><span class="lineNum">   10814 </span>            : </a>
<a name="10815"><span class="lineNum">   10815 </span>            : #ifndef USE_ROSE</a>
<a name="10816"><span class="lineNum">   10816 </span>            : //-----------------------------------------------</a>
<a name="10817"><span class="lineNum">   10817 </span>            : // Remove original expression trees from expressions, so you can change</a>
<a name="10818"><span class="lineNum">   10818 </span>            : // the value and have it unparsed correctly.</a>
<a name="10819"><span class="lineNum">   10819 </span><span class="lineCov">          1 : void SageInterface::removeAllOriginalExpressionTrees(SgNode* top) {</span></a>
<a name="10820"><span class="lineNum">   10820 </span><span class="lineCov">          1 :   struct Visitor: public AstSimpleProcessing {</span></a>
<a name="10821"><span class="lineNum">   10821 </span><span class="lineCov">          9 :     virtual void visit(SgNode* n) {</span></a>
<a name="10822"><span class="lineNum">   10822 </span><span class="lineCov">          9 :       SgValueExp* valueExp = isSgValueExp(n);</span></a>
<a name="10823"><span class="lineNum">   10823 </span><span class="lineCov">          9 :       if (valueExp != NULL) {</span></a>
<a name="10824"><span class="lineNum">   10824 </span><span class="lineCov">          1 :         valueExp-&gt;set_originalExpressionTree(NULL);</span></a>
<a name="10825"><span class="lineNum">   10825 </span>            :       }</a>
<a name="10826"><span class="lineNum">   10826 </span>            :       else {</a>
<a name="10827"><span class="lineNum">   10827 </span><span class="lineCov">          8 :         SgCastExp* cast_exp = isSgCastExp(n);</span></a>
<a name="10828"><span class="lineNum">   10828 </span><span class="lineCov">          8 :         if (cast_exp != NULL) {</span></a>
<a name="10829"><span class="lineNum">   10829 </span><span class="lineNoCov">          0 :           cast_exp-&gt;set_originalExpressionTree(NULL);</span></a>
<a name="10830"><span class="lineNum">   10830 </span>            :         }</a>
<a name="10831"><span class="lineNum">   10831 </span>            :       }</a>
<a name="10832"><span class="lineNum">   10832 </span><span class="lineCov">          9 :     }</span></a>
<a name="10833"><span class="lineNum">   10833 </span>            :   };</a>
<a name="10834"><span class="lineNum">   10834 </span><span class="lineCov">          1 :   Visitor().traverse(top, preorder);</span></a>
<a name="10835"><span class="lineNum">   10835 </span><span class="lineCov">          1 : }</span></a>
<a name="10836"><span class="lineNum">   10836 </span>            : #endif</a>
<a name="10837"><span class="lineNum">   10837 </span>            : </a>
<a name="10838"><span class="lineNum">   10838 </span><span class="lineNoCov">          0 : SgSwitchStatement* SageInterface::findEnclosingSwitch(SgStatement* s) {</span></a>
<a name="10839"><span class="lineNum">   10839 </span><span class="lineNoCov">          0 :   while (s &amp;&amp; !isSgSwitchStatement(s)) {</span></a>
<a name="10840"><span class="lineNum">   10840 </span><span class="lineNoCov">          0 :     s = isSgStatement(s-&gt;get_parent());</span></a>
<a name="10841"><span class="lineNum">   10841 </span>            :   }</a>
<a name="10842"><span class="lineNum">   10842 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (s);</span></a>
<a name="10843"><span class="lineNum">   10843 </span><span class="lineNoCov">          0 :   return isSgSwitchStatement(s);</span></a>
<a name="10844"><span class="lineNum">   10844 </span>            : }</a>
<a name="10845"><span class="lineNum">   10845 </span>            : </a>
<a name="10846"><span class="lineNum">   10846 </span>            : //! Find enclosing OpenMP clause body statement from s. If s is already one, return it directly.</a>
<a name="10847"><span class="lineNum">   10847 </span><span class="lineNoCov">          0 : SgUpirFieldBodyStatement* SageInterface::findEnclosingUpirFieldBodyStatement(SgStatement* s) {</span></a>
<a name="10848"><span class="lineNum">   10848 </span><span class="lineNoCov">          0 :   while (s &amp;&amp; !isSgUpirFieldBodyStatement(s)) {</span></a>
<a name="10849"><span class="lineNum">   10849 </span><span class="lineNoCov">          0 :     s = isSgStatement(s-&gt;get_parent());</span></a>
<a name="10850"><span class="lineNum">   10850 </span>            :   }</a>
<a name="10851"><span class="lineNum">   10851 </span>            :   // ROSE_ASSERT (s); // s is allowed to be NULL.</a>
<a name="10852"><span class="lineNum">   10852 </span><span class="lineNoCov">          0 :   if (s==NULL)</span></a>
<a name="10853"><span class="lineNum">   10853 </span>            :     return NULL;</a>
<a name="10854"><span class="lineNum">   10854 </span><span class="lineNoCov">          0 :   return isSgUpirFieldBodyStatement(s);</span></a>
<a name="10855"><span class="lineNum">   10855 </span>            : }</a>
<a name="10856"><span class="lineNum">   10856 </span>            : </a>
<a name="10857"><span class="lineNum">   10857 </span>            : </a>
<a name="10858"><span class="lineNum">   10858 </span><span class="lineNoCov">          0 : SgScopeStatement* SageInterface::findEnclosingLoop(SgStatement* s, const std::string&amp; label, bool stopOnSwitches) {</span></a>
<a name="10859"><span class="lineNum">   10859 </span>            :   /* label can represent a fortran label or a java label provided as a label in a continue/break statement */</a>
<a name="10860"><span class="lineNum">   10860 </span><span class="lineNoCov">          0 :   for (; s; s = isSgStatement(s-&gt;get_parent())) {</span></a>
<a name="10861"><span class="lineNum">   10861 </span><span class="lineNoCov">          0 :     SgScopeStatement* sc = isSgScopeStatement(s);</span></a>
<a name="10862"><span class="lineNum">   10862 </span>            :     // Need to check for empty label as for java we must detect the</a>
<a name="10863"><span class="lineNum">   10863 </span>            :         // innermost labeled statement and skip everything in between</a>
<a name="10864"><span class="lineNum">   10864 </span><span class="lineNoCov">          0 :     switch (s-&gt;variantT()) {</span></a>
<a name="10865"><span class="lineNum">   10865 </span><span class="lineNoCov">          0 :       case V_SgDoWhileStmt: {</span></a>
<a name="10866"><span class="lineNum">   10866 </span><span class="lineNoCov">          0 :           if (label.empty()) {</span></a>
<a name="10867"><span class="lineNum">   10867 </span><span class="lineNoCov">          0 :                   return sc;</span></a>
<a name="10868"><span class="lineNum">   10868 </span>            :           }</a>
<a name="10869"><span class="lineNum">   10869 </span>            :           break;</a>
<a name="10870"><span class="lineNum">   10870 </span>            :       }</a>
<a name="10871"><span class="lineNum">   10871 </span><span class="lineNoCov">          0 :       case V_SgForStatement: {</span></a>
<a name="10872"><span class="lineNum">   10872 </span><span class="lineNoCov">          0 :           if (label.empty()) {</span></a>
<a name="10873"><span class="lineNum">   10873 </span><span class="lineNoCov">          0 :                   return sc;</span></a>
<a name="10874"><span class="lineNum">   10874 </span>            :           }</a>
<a name="10875"><span class="lineNum">   10875 </span>            :           break;</a>
<a name="10876"><span class="lineNum">   10876 </span>            :       }</a>
<a name="10877"><span class="lineNum">   10877 </span><span class="lineNoCov">          0 :       case V_SgFortranDo:</span></a>
<a name="10878"><span class="lineNum">   10878 </span><span class="lineNoCov">          0 :       case V_SgFortranNonblockedDo: {</span></a>
<a name="10879"><span class="lineNum">   10879 </span><span class="lineNoCov">          0 :         if (label.empty() ||</span></a>
<a name="10880"><span class="lineNum">   10880 </span><span class="lineNoCov">          0 :                         label == isSgFortranDo(sc)-&gt;get_string_label()) {</span></a>
<a name="10881"><span class="lineNum">   10881 </span><span class="lineNoCov">          0 :           return sc;</span></a>
<a name="10882"><span class="lineNum">   10882 </span>            :         }</a>
<a name="10883"><span class="lineNum">   10883 </span>            :         break;</a>
<a name="10884"><span class="lineNum">   10884 </span>            :       }</a>
<a name="10885"><span class="lineNum">   10885 </span><span class="lineNoCov">          0 :       case V_SgWhileStmt: {</span></a>
<a name="10886"><span class="lineNum">   10886 </span><span class="lineNoCov">          0 :         if (label.empty() ||</span></a>
<a name="10887"><span class="lineNum">   10887 </span><span class="lineNoCov">          0 :                         label == isSgWhileStmt(sc)-&gt;get_string_label()) {</span></a>
<a name="10888"><span class="lineNum">   10888 </span><span class="lineNoCov">          0 :           return sc;</span></a>
<a name="10889"><span class="lineNum">   10889 </span>            :         }</a>
<a name="10890"><span class="lineNum">   10890 </span>            :         break;</a>
<a name="10891"><span class="lineNum">   10891 </span>            :       }</a>
<a name="10892"><span class="lineNum">   10892 </span><span class="lineNoCov">          0 :       case V_SgSwitchStatement: {</span></a>
<a name="10893"><span class="lineNum">   10893 </span><span class="lineNoCov">          0 :         if (stopOnSwitches) return sc;</span></a>
<a name="10894"><span class="lineNum">   10894 </span>            :         break;</a>
<a name="10895"><span class="lineNum">   10895 </span>            :       }</a>
<a name="10896"><span class="lineNum">   10896 </span><span class="lineNoCov">          0 :       default: continue;</span></a>
<a name="10897"><span class="lineNum">   10897 </span>            :     }</a>
<a name="10898"><span class="lineNum">   10898 </span>            :   }</a>
<a name="10899"><span class="lineNum">   10899 </span>            :   return NULL;</a>
<a name="10900"><span class="lineNum">   10900 </span>            : }</a>
<a name="10901"><span class="lineNum">   10901 </span>            : </a>
<a name="10902"><span class="lineNum">   10902 </span>            : #ifndef USE_ROSE</a>
<a name="10903"><span class="lineNum">   10903 </span><span class="lineNoCov">          0 : void SageInterface::removeJumpsToNextStatement(SgNode* top)</span></a>
<a name="10904"><span class="lineNum">   10904 </span>            : {</a>
<a name="10905"><span class="lineNum">   10905 </span><span class="lineNoCov">          0 :  class RemoveJumpsToNextStatementVisitor: public AstSimpleProcessing {</span></a>
<a name="10906"><span class="lineNum">   10906 </span>            :     public:</a>
<a name="10907"><span class="lineNum">   10907 </span><span class="lineNoCov">          0 :     virtual void visit(SgNode* n) {</span></a>
<a name="10908"><span class="lineNum">   10908 </span><span class="lineNoCov">          0 :       if (isSgBasicBlock(n)) {</span></a>
<a name="10909"><span class="lineNum">   10909 </span><span class="lineNoCov">          0 :         SgBasicBlock* bb = isSgBasicBlock(n);</span></a>
<a name="10910"><span class="lineNum">   10910 </span><span class="lineNoCov">          0 :         bool changes = true;</span></a>
<a name="10911"><span class="lineNum">   10911 </span><span class="lineNoCov">          0 :         while (changes) {</span></a>
<a name="10912"><span class="lineNum">   10912 </span><span class="lineNoCov">          0 :           changes = false;</span></a>
<a name="10913"><span class="lineNum">   10913 </span><span class="lineNoCov">          0 :           for (SgStatementPtrList::iterator i = bb-&gt;get_statements().begin();</span></a>
<a name="10914"><span class="lineNum">   10914 </span><span class="lineNoCov">          0 :                i != bb-&gt;get_statements().end(); ++i) {</span></a>
<a name="10915"><span class="lineNum">   10915 </span><span class="lineNoCov">          0 :             if (isSgGotoStatement(*i)) {</span></a>
<a name="10916"><span class="lineNum">   10916 </span><span class="lineNoCov">          0 :               SgGotoStatement* gs = isSgGotoStatement(*i);</span></a>
<a name="10917"><span class="lineNum">   10917 </span><span class="lineNoCov">          0 :               SgStatementPtrList::iterator inext = i;</span></a>
<a name="10918"><span class="lineNum">   10918 </span><span class="lineNoCov">          0 :               ++inext;</span></a>
<a name="10919"><span class="lineNum">   10919 </span><span class="lineNoCov">          0 :              if (inext == bb-&gt;get_statements().end())</span></a>
<a name="10920"><span class="lineNum">   10920 </span><span class="lineNoCov">          0 :                 continue;</span></a>
<a name="10921"><span class="lineNum">   10921 </span><span class="lineNoCov">          0 :              if (!isSgLabelStatement(*inext))</span></a>
<a name="10922"><span class="lineNum">   10922 </span><span class="lineNoCov">          0 :                 continue;</span></a>
<a name="10923"><span class="lineNum">   10923 </span><span class="lineNoCov">          0 :               SgLabelStatement* ls = isSgLabelStatement(*inext);</span></a>
<a name="10924"><span class="lineNum">   10924 </span><span class="lineNoCov">          0 :               if (gs-&gt;get_label() == ls) {</span></a>
<a name="10925"><span class="lineNum">   10925 </span><span class="lineNoCov">          0 :                 changes = true;</span></a>
<a name="10926"><span class="lineNum">   10926 </span><span class="lineNoCov">          0 :                 bb-&gt;get_statements().erase(i);</span></a>
<a name="10927"><span class="lineNum">   10927 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="10928"><span class="lineNum">   10928 </span>            :               }</a>
<a name="10929"><span class="lineNum">   10929 </span>            :             }</a>
<a name="10930"><span class="lineNum">   10930 </span>            :           }</a>
<a name="10931"><span class="lineNum">   10931 </span>            :         }</a>
<a name="10932"><span class="lineNum">   10932 </span>            :       }</a>
<a name="10933"><span class="lineNum">   10933 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="10934"><span class="lineNum">   10934 </span>            :   };</a>
<a name="10935"><span class="lineNum">   10935 </span>            : </a>
<a name="10936"><span class="lineNum">   10936 </span><span class="lineNoCov">          0 :   RemoveJumpsToNextStatementVisitor().traverse(top, postorder);</span></a>
<a name="10937"><span class="lineNum">   10937 </span>            : </a>
<a name="10938"><span class="lineNum">   10938 </span><span class="lineNoCov">          0 : }</span></a>
<a name="10939"><span class="lineNum">   10939 </span>            : #endif</a>
<a name="10940"><span class="lineNum">   10940 </span>            : </a>
<a name="10941"><span class="lineNum">   10941 </span>            : // special purpose remove for AST transformation/optimization from astInliner, don't use it otherwise.</a>
<a name="10942"><span class="lineNum">   10942 </span><span class="lineNoCov">          0 : void SageInterface::myRemoveStatement(SgStatement* stmt) {</span></a>
<a name="10943"><span class="lineNum">   10943 </span>            :   // assert (LowLevelRewrite::isRemovableStatement(*i));</a>
<a name="10944"><span class="lineNum">   10944 </span><span class="lineNoCov">          0 :   SgStatement* parent = isSgStatement(stmt-&gt;get_parent());</span></a>
<a name="10945"><span class="lineNum">   10945 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (parent);</span></a>
<a name="10946"><span class="lineNum">   10946 </span><span class="lineNoCov">          0 :   SgBasicBlock* bb = isSgBasicBlock(parent);</span></a>
<a name="10947"><span class="lineNum">   10947 </span><span class="lineNoCov">          0 :   SgForInitStatement* fis = isSgForInitStatement(parent);</span></a>
<a name="10948"><span class="lineNum">   10948 </span><span class="lineNoCov">          0 :   if (bb || fis) {</span></a>
<a name="10949"><span class="lineNum">   10949 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (bb || fis);</span></a>
<a name="10950"><span class="lineNum">   10950 </span><span class="lineNoCov">          0 :     SgStatementPtrList&amp; siblings =</span></a>
<a name="10951"><span class="lineNum">   10951 </span><span class="lineNoCov">          0 :       (bb ? bb-&gt;get_statements() : fis-&gt;get_init_stmt());</span></a>
<a name="10952"><span class="lineNum">   10952 </span><span class="lineNoCov">          0 :     SgStatementPtrList::iterator j =</span></a>
<a name="10953"><span class="lineNum">   10953 </span><span class="lineNoCov">          0 :       std::find(siblings.begin(), siblings.end(), stmt);</span></a>
<a name="10954"><span class="lineNum">   10954 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (j != siblings.end());</span></a>
<a name="10955"><span class="lineNum">   10955 </span><span class="lineNoCov">          0 :     siblings.erase(j);</span></a>
<a name="10956"><span class="lineNum">   10956 </span>            :     // LowLevelRewrite::remove(*i);</a>
<a name="10957"><span class="lineNum">   10957 </span>            :   } else {</a>
<a name="10958"><span class="lineNum">   10958 </span><span class="lineNoCov">          0 :     parent-&gt;replace_statement(stmt, new SgNullStatement(TRANS_FILE));</span></a>
<a name="10959"><span class="lineNum">   10959 </span>            :   }</a>
<a name="10960"><span class="lineNum">   10960 </span><span class="lineNoCov">          0 : }</span></a>
<a name="10961"><span class="lineNum">   10961 </span>            : </a>
<a name="10962"><span class="lineNum">   10962 </span>            : </a>
<a name="10963"><span class="lineNum">   10963 </span>            : #ifndef USE_ROSE</a>
<a name="10964"><span class="lineNum">   10964 </span><span class="lineNoCov">          0 : std::set&lt;SgLabelStatement*&gt; SageInterface::findUnusedLabels (SgNode* top)</span></a>
<a name="10965"><span class="lineNum">   10965 </span>            : {</a>
<a name="10966"><span class="lineNum">   10966 </span><span class="lineNoCov">          0 :   class FindUsedAndAllLabelsVisitor: public AstSimpleProcessing {</span></a>
<a name="10967"><span class="lineNum">   10967 </span>            :     SgLabelStatementPtrSet&amp; used;</a>
<a name="10968"><span class="lineNum">   10968 </span>            :     SgLabelStatementPtrSet&amp; all;</a>
<a name="10969"><span class="lineNum">   10969 </span>            : </a>
<a name="10970"><span class="lineNum">   10970 </span>            :     public:</a>
<a name="10971"><span class="lineNum">   10971 </span><span class="lineNoCov">          0 :     FindUsedAndAllLabelsVisitor(SgLabelStatementPtrSet&amp; used,</span></a>
<a name="10972"><span class="lineNum">   10972 </span><span class="lineNoCov">          0 :         SgLabelStatementPtrSet&amp; all):</span></a>
<a name="10973"><span class="lineNum">   10973 </span><span class="lineNoCov">          0 :       used(used), all(all) {}</span></a>
<a name="10974"><span class="lineNum">   10974 </span>            : </a>
<a name="10975"><span class="lineNum">   10975 </span><span class="lineNoCov">          0 :     virtual void visit(SgNode* n) {</span></a>
<a name="10976"><span class="lineNum">   10976 </span><span class="lineNoCov">          0 :       if (isSgGotoStatement(n)) {</span></a>
<a name="10977"><span class="lineNum">   10977 </span><span class="lineNoCov">          0 :         used.insert(isSgGotoStatement(n)-&gt;get_label());</span></a>
<a name="10978"><span class="lineNum">   10978 </span>            :       }</a>
<a name="10979"><span class="lineNum">   10979 </span><span class="lineNoCov">          0 :       if (isSgLabelStatement(n)) {</span></a>
<a name="10980"><span class="lineNum">   10980 </span><span class="lineNoCov">          0 :         all.insert(isSgLabelStatement(n));</span></a>
<a name="10981"><span class="lineNum">   10981 </span>            :       }</a>
<a name="10982"><span class="lineNum">   10982 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="10983"><span class="lineNum">   10983 </span>            :   };</a>
<a name="10984"><span class="lineNum">   10984 </span>            : </a>
<a name="10985"><span class="lineNum">   10985 </span><span class="lineNoCov">          0 :   SgLabelStatementPtrSet used;</span></a>
<a name="10986"><span class="lineNum">   10986 </span><span class="lineNoCov">          0 :   SgLabelStatementPtrSet unused;</span></a>
<a name="10987"><span class="lineNum">   10987 </span><span class="lineNoCov">          0 :   FindUsedAndAllLabelsVisitor(used, unused).traverse(top, preorder);</span></a>
<a name="10988"><span class="lineNum">   10988 </span>            : </a>
<a name="10989"><span class="lineNum">   10989 </span><span class="lineNoCov">          0 :   for (SgLabelStatementPtrSet::iterator i = used.begin();</span></a>
<a name="10990"><span class="lineNum">   10990 </span><span class="lineNoCov">          0 :       i != used.end(); ++i) {</span></a>
<a name="10991"><span class="lineNum">   10991 </span><span class="lineNoCov">          0 :     assert (unused.find(*i) != unused.end());</span></a>
<a name="10992"><span class="lineNum">   10992 </span>            :     // std::cout &lt;&lt; &quot;Keeping used label &quot; &lt;&lt; (*i)-&gt;get_label().str() &lt;&lt; std::endl;</a>
<a name="10993"><span class="lineNum">   10993 </span><span class="lineNoCov">          0 :     unused.erase(*i);</span></a>
<a name="10994"><span class="lineNum">   10994 </span>            :   }</a>
<a name="10995"><span class="lineNum">   10995 </span>            : </a>
<a name="10996"><span class="lineNum">   10996 </span><span class="lineNoCov">          0 :   return unused;</span></a>
<a name="10997"><span class="lineNum">   10997 </span>            : }</a>
<a name="10998"><span class="lineNum">   10998 </span>            : </a>
<a name="10999"><span class="lineNum">   10999 </span>            : // Remove all unused labels in a section of code.</a>
<a name="11000"><span class="lineNum">   11000 </span><span class="lineNoCov">          0 : void SageInterface::removeUnusedLabels(SgNode* top, bool keepChild/* =false */) {</span></a>
<a name="11001"><span class="lineNum">   11001 </span>            : </a>
<a name="11002"><span class="lineNum">   11002 </span><span class="lineNoCov">          0 :   SgLabelStatementPtrSet unused = findUnusedLabels(top);</span></a>
<a name="11003"><span class="lineNum">   11003 </span>            : </a>
<a name="11004"><span class="lineNum">   11004 </span><span class="lineNoCov">          0 :   for (SgLabelStatementPtrSet::iterator i = unused.begin();</span></a>
<a name="11005"><span class="lineNum">   11005 </span><span class="lineNoCov">          0 :       i != unused.end(); ++i) {</span></a>
<a name="11006"><span class="lineNum">   11006 </span>            : </a>
<a name="11007"><span class="lineNum">   11007 </span><span class="lineNoCov">          0 :     SgLabelStatement* l_stmt = *i;</span></a>
<a name="11008"><span class="lineNum">   11008 </span>            :     // std::cout &lt;&lt; &quot;Removing unused label &quot; &lt;&lt; (*i)-&gt;get_label().str() &lt;&lt; std::endl;</a>
<a name="11009"><span class="lineNum">   11009 </span><span class="lineNoCov">          0 :     if (keepChild)</span></a>
<a name="11010"><span class="lineNum">   11010 </span>            :     {</a>
<a name="11011"><span class="lineNum">   11011 </span><span class="lineNoCov">          0 :         SgStatement* child= l_stmt-&gt;get_statement();</span></a>
<a name="11012"><span class="lineNum">   11012 </span>            : //        l_stmt-&gt;set_parent(NULL);</a>
<a name="11013"><span class="lineNum">   11013 </span><span class="lineNoCov">          0 :         l_stmt-&gt;set_statement(NULL);</span></a>
<a name="11014"><span class="lineNum">   11014 </span><span class="lineNoCov">          0 :         replaceStatement (l_stmt, child);</span></a>
<a name="11015"><span class="lineNum">   11015 </span>            :     }</a>
<a name="11016"><span class="lineNum">   11016 </span>            :     else</a>
<a name="11017"><span class="lineNum">   11017 </span><span class="lineNoCov">          0 :       myRemoveStatement(*i);</span></a>
<a name="11018"><span class="lineNum">   11018 </span>            :   }</a>
<a name="11019"><span class="lineNum">   11019 </span><span class="lineNoCov">          0 : }</span></a>
<a name="11020"><span class="lineNum">   11020 </span>            : #endif</a>
<a name="11021"><span class="lineNum">   11021 </span>            : </a>
<a name="11022"><span class="lineNum">   11022 </span><span class="lineNoCov">          0 :   SgStatement* SageInterface::getLoopBody(SgScopeStatement* loopStmt) {</span></a>
<a name="11023"><span class="lineNum">   11023 </span><span class="lineNoCov">          0 :     if (isSgWhileStmt(loopStmt)) return isSgWhileStmt(loopStmt)-&gt;get_body();</span></a>
<a name="11024"><span class="lineNum">   11024 </span><span class="lineNoCov">          0 :     if (isSgForStatement(loopStmt)) return isSgForStatement(loopStmt)-&gt;get_loop_body();</span></a>
<a name="11025"><span class="lineNum">   11025 </span><span class="lineNoCov">          0 :     if (isSgDoWhileStmt(loopStmt)) return isSgDoWhileStmt(loopStmt)-&gt;get_body();</span></a>
<a name="11026"><span class="lineNum">   11026 </span>            : </a>
<a name="11027"><span class="lineNum">   11027 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (!&quot;Bad loop kind&quot;);</span></a>
<a name="11028"><span class="lineNum">   11028 </span>            :     return NULL;</a>
<a name="11029"><span class="lineNum">   11029 </span>            :   }</a>
<a name="11030"><span class="lineNum">   11030 </span>            : </a>
<a name="11031"><span class="lineNum">   11031 </span><span class="lineNoCov">          0 :   void SageInterface::setLoopBody(SgScopeStatement* loopStmt, SgStatement* body) {</span></a>
<a name="11032"><span class="lineNum">   11032 </span><span class="lineNoCov">          0 :     if (isSgWhileStmt(loopStmt)) {</span></a>
<a name="11033"><span class="lineNum">   11033 </span><span class="lineNoCov">          0 :       isSgWhileStmt(loopStmt)-&gt;set_body(body);</span></a>
<a name="11034"><span class="lineNum">   11034 </span><span class="lineNoCov">          0 :     } else if (isSgForStatement(loopStmt)) {</span></a>
<a name="11035"><span class="lineNum">   11035 </span><span class="lineNoCov">          0 :       isSgForStatement(loopStmt)-&gt;set_loop_body(body);</span></a>
<a name="11036"><span class="lineNum">   11036 </span><span class="lineNoCov">          0 :     } else if (isSgDoWhileStmt(loopStmt)) {</span></a>
<a name="11037"><span class="lineNum">   11037 </span><span class="lineNoCov">          0 :       isSgDoWhileStmt(loopStmt)-&gt;set_body(body);</span></a>
<a name="11038"><span class="lineNum">   11038 </span>            :     } else {</a>
<a name="11039"><span class="lineNum">   11039 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (!&quot;Bad loop kind&quot;);</span></a>
<a name="11040"><span class="lineNum">   11040 </span>            :     }</a>
<a name="11041"><span class="lineNum">   11041 </span><span class="lineNoCov">          0 :     body-&gt;set_parent(loopStmt);</span></a>
<a name="11042"><span class="lineNum">   11042 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="11043"><span class="lineNum">   11043 </span>            : </a>
<a name="11044"><span class="lineNum">   11044 </span><span class="lineNoCov">          0 :   SgStatement* SageInterface::getLoopCondition(SgScopeStatement* loopStmt) {</span></a>
<a name="11045"><span class="lineNum">   11045 </span><span class="lineNoCov">          0 :     if (isSgWhileStmt(loopStmt)) return isSgWhileStmt(loopStmt)-&gt;get_condition();</span></a>
<a name="11046"><span class="lineNum">   11046 </span><span class="lineNoCov">          0 :     if (isSgForStatement(loopStmt)) return isSgForStatement(loopStmt)-&gt;get_test();</span></a>
<a name="11047"><span class="lineNum">   11047 </span><span class="lineNoCov">          0 :     if (isSgDoWhileStmt(loopStmt)) return isSgDoWhileStmt(loopStmt)-&gt;get_condition();</span></a>
<a name="11048"><span class="lineNum">   11048 </span>            : </a>
<a name="11049"><span class="lineNum">   11049 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (!&quot;Bad loop kind&quot;);</span></a>
<a name="11050"><span class="lineNum">   11050 </span>            :     return NULL;</a>
<a name="11051"><span class="lineNum">   11051 </span>            :   }</a>
<a name="11052"><span class="lineNum">   11052 </span>            : </a>
<a name="11053"><span class="lineNum">   11053 </span><span class="lineNoCov">          0 :   void SageInterface::setLoopCondition(SgScopeStatement* loopStmt, SgStatement* cond) {</span></a>
<a name="11054"><span class="lineNum">   11054 </span><span class="lineNoCov">          0 :     if (isSgWhileStmt(loopStmt)) {</span></a>
<a name="11055"><span class="lineNum">   11055 </span><span class="lineNoCov">          0 :       isSgWhileStmt(loopStmt)-&gt;set_condition(cond);</span></a>
<a name="11056"><span class="lineNum">   11056 </span><span class="lineNoCov">          0 :     } else if (isSgForStatement(loopStmt)) {</span></a>
<a name="11057"><span class="lineNum">   11057 </span><span class="lineNoCov">          0 :       isSgForStatement(loopStmt)-&gt;set_test(cond);</span></a>
<a name="11058"><span class="lineNum">   11058 </span><span class="lineNoCov">          0 :     } else if (isSgDoWhileStmt(loopStmt)) {</span></a>
<a name="11059"><span class="lineNum">   11059 </span><span class="lineNoCov">          0 :       isSgDoWhileStmt(loopStmt)-&gt;set_condition(cond);</span></a>
<a name="11060"><span class="lineNum">   11060 </span>            :     } else {</a>
<a name="11061"><span class="lineNum">   11061 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (!&quot;Bad loop kind&quot;);</span></a>
<a name="11062"><span class="lineNum">   11062 </span>            :     }</a>
<a name="11063"><span class="lineNum">   11063 </span><span class="lineNoCov">          0 :     cond-&gt;set_parent(loopStmt);</span></a>
<a name="11064"><span class="lineNum">   11064 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="11065"><span class="lineNum">   11065 </span>            : </a>
<a name="11066"><span class="lineNum">   11066 </span>            : //! A helper function to strip off possible type casting operations for an expression</a>
<a name="11067"><span class="lineNum">   11067 </span>            : // usually useful when compare two expressions to see if they actually refer to the same variable</a>
<a name="11068"><span class="lineNum">   11068 </span><span class="lineCov">        112 : static SgExpression* SkipCasting (SgExpression* exp)</span></a>
<a name="11069"><span class="lineNum">   11069 </span>            : {</a>
<a name="11070"><span class="lineNum">   11070 </span><span class="lineCov">        112 :   SgCastExp* cast_exp = isSgCastExp(exp);</span></a>
<a name="11071"><span class="lineNum">   11071 </span><span class="lineCov">        112 :    if (cast_exp != NULL)</span></a>
<a name="11072"><span class="lineNum">   11072 </span>            :    {</a>
<a name="11073"><span class="lineNum">   11073 </span><span class="lineNoCov">          0 :       SgExpression* operand = cast_exp-&gt;get_operand();</span></a>
<a name="11074"><span class="lineNum">   11074 </span><span class="lineNoCov">          0 :       assert(operand != 0);</span></a>
<a name="11075"><span class="lineNum">   11075 </span>            :       return SkipCasting(operand);</a>
<a name="11076"><span class="lineNum">   11076 </span>            :    }</a>
<a name="11077"><span class="lineNum">   11077 </span>            :   else</a>
<a name="11078"><span class="lineNum">   11078 </span><span class="lineCov">        112 :     return exp;</span></a>
<a name="11079"><span class="lineNum">   11079 </span>            : }</a>
<a name="11080"><span class="lineNum">   11080 </span>            : </a>
<a name="11081"><span class="lineNum">   11081 </span>            : //! Promote the single variable declaration statement outside of the for loop header's init statement, e.g. for (int i=0;) becomes int i_x; for (i_x=0;..) and rewrite the loop with the new index variable</a>
<a name="11082"><span class="lineNum">   11082 </span><span class="lineCov">         22 : bool SageInterface::normalizeForLoopInitDeclaration(SgForStatement* loop)</span></a>
<a name="11083"><span class="lineNum">   11083 </span>            : {</a>
<a name="11084"><span class="lineNum">   11084 </span><span class="lineCov">         22 :   ROSE_ASSERT(loop!=NULL);</span></a>
<a name="11085"><span class="lineNum">   11085 </span>            : </a>
<a name="11086"><span class="lineNum">   11086 </span><span class="lineCov">         22 :   SgStatementPtrList &amp;init = loop -&gt;get_init_stmt();</span></a>
<a name="11087"><span class="lineNum">   11087 </span><span class="lineCov">         22 :   if (init.size() !=1) // We only handle one statement case</span></a>
<a name="11088"><span class="lineNum">   11088 </span>            :     return false;</a>
<a name="11089"><span class="lineNum">   11089 </span>            : </a>
<a name="11090"><span class="lineNum">   11090 </span><span class="lineCov">         22 :   SgStatement* init1 = init.front();</span></a>
<a name="11091"><span class="lineNum">   11091 </span><span class="lineCov">         22 :   SgVariableDeclaration* decl = isSgVariableDeclaration(init1);</span></a>
<a name="11092"><span class="lineNum">   11092 </span><span class="lineCov">         22 :   if (decl == NULL) // we only handle for (int i=0; ...)</span></a>
<a name="11093"><span class="lineNum">   11093 </span>            :     return true;    // the return value is ambiguous: if not int i=0; it is already normalized</a>
<a name="11094"><span class="lineNum">   11094 </span>            : </a>
<a name="11095"><span class="lineNum">   11095 </span><span class="lineCov">         17 :   SgVariableSymbol* osymbol = getFirstVarSym(decl);</span></a>
<a name="11096"><span class="lineNum">   11096 </span><span class="lineCov">         17 :   SgInitializedName* ivarname = decl-&gt;get_variables().front();</span></a>
<a name="11097"><span class="lineNum">   11097 </span><span class="lineCov">         17 :   SgExpression* lbast = NULL; // the lower bound, initial state</span></a>
<a name="11098"><span class="lineNum">   11098 </span><span class="lineCov">         17 :   ROSE_ASSERT(ivarname != NULL);</span></a>
<a name="11099"><span class="lineNum">   11099 </span><span class="lineCov">         17 :   SgInitializer * initor = ivarname-&gt;get_initializer();</span></a>
<a name="11100"><span class="lineNum">   11100 </span><span class="lineCov">         17 :   if (isSgAssignInitializer(initor))</span></a>
<a name="11101"><span class="lineNum">   11101 </span>            :   {</a>
<a name="11102"><span class="lineNum">   11102 </span><span class="lineCov">         17 :     lbast = isSgAssignInitializer(initor)-&gt;get_operand();</span></a>
<a name="11103"><span class="lineNum">   11103 </span>            :   }</a>
<a name="11104"><span class="lineNum">   11104 </span>            :   else</a>
<a name="11105"><span class="lineNum">   11105 </span>            :   { //SgConstructorInitializer etc.</a>
<a name="11106"><span class="lineNum">   11106 </span>            :     // other complex declaration statements, such as Decomposition::Iterator ditr(&amp;decomp) should be skipped</a>
<a name="11107"><span class="lineNum">   11107 </span>            :     // they cause a loop to be non-canonical.</a>
<a name="11108"><span class="lineNum">   11108 </span>            :     return false;</a>
<a name="11109"><span class="lineNum">   11109 </span>            :   }</a>
<a name="11110"><span class="lineNum">   11110 </span>            : </a>
<a name="11111"><span class="lineNum">   11111 </span>            :   // add a new statement like int i; and insert it to the enclosing function</a>
<a name="11112"><span class="lineNum">   11112 </span>            :   // There are multiple choices about where to insert this statement:</a>
<a name="11113"><span class="lineNum">   11113 </span>            :   //  global scope: max name pollution,</a>
<a name="11114"><span class="lineNum">   11114 </span>            :   //  right before the loop: mess up perfectly nested loops</a>
<a name="11115"><span class="lineNum">   11115 </span>            :   //  So we prepend the statement to the enclosing function's body</a>
<a name="11116"><span class="lineNum">   11116 </span><span class="lineCov">         17 :   SgFunctionDefinition* funcDef =  getEnclosingFunctionDefinition(loop);</span></a>
<a name="11117"><span class="lineNum">   11117 </span><span class="lineCov">         17 :   ROSE_ASSERT(funcDef!=NULL);</span></a>
<a name="11118"><span class="lineNum">   11118 </span><span class="lineCov">         17 :   SgBasicBlock* funcBody = funcDef-&gt;get_body();</span></a>
<a name="11119"><span class="lineNum">   11119 </span><span class="lineCov">         17 :   ROSE_ASSERT(funcBody!=NULL);</span></a>
<a name="11120"><span class="lineNum">   11120 </span>            :   //TODO a better name</a>
<a name="11121"><span class="lineNum">   11121 </span><span class="lineCov">         17 :   std::ostringstream os;</span></a>
<a name="11122"><span class="lineNum">   11122 </span><span class="lineCov">         17 :   os&lt;&lt;ivarname-&gt;get_name().getString();</span></a>
<a name="11123"><span class="lineNum">   11123 </span>            : </a>
<a name="11124"><span class="lineNum">   11124 </span>            :   // keep the original variable name if possible</a>
<a name="11125"><span class="lineNum">   11125 </span><span class="lineCov">         17 :   SgSymbol * visibleSym = NULL;</span></a>
<a name="11126"><span class="lineNum">   11126 </span><span class="lineCov">         17 :   visibleSym = lookupVariableSymbolInParentScopes(ivarname-&gt;get_name(), funcBody);</span></a>
<a name="11127"><span class="lineNum">   11127 </span><span class="lineCov">         17 :   if (visibleSym != NULL) // if there is a name collision, add suffix to the variable name</span></a>
<a name="11128"><span class="lineNum">   11128 </span>            :   {</a>
<a name="11129"><span class="lineNum">   11129 </span><span class="lineCov">          1 :     os&lt;&lt;&quot;_nom_&quot;;</span></a>
<a name="11130"><span class="lineNum">   11130 </span><span class="lineCov">          1 :     os&lt;&lt;++gensym_counter;</span></a>
<a name="11131"><span class="lineNum">   11131 </span>            :   }</a>
<a name="11132"><span class="lineNum">   11132 </span>            : </a>
<a name="11133"><span class="lineNum">   11133 </span><span class="lineCov">         17 :   SgVariableDeclaration* ndecl = buildVariableDeclaration(os.str(),ivarname-&gt;get_type(), NULL, funcBody);</span></a>
<a name="11134"><span class="lineNum">   11134 </span><span class="lineCov">         17 :   prependStatement(ndecl, funcBody);</span></a>
<a name="11135"><span class="lineNum">   11135 </span><span class="lineCov">         17 :   SgVariableSymbol* nsymbol = getFirstVarSym(ndecl);</span></a>
<a name="11136"><span class="lineNum">   11136 </span>            : </a>
<a name="11137"><span class="lineNum">   11137 </span>            :   // replace variable ref to the new symbol</a>
<a name="11138"><span class="lineNum">   11138 </span><span class="lineCov">         34 :   Rose_STL_Container&lt;SgNode*&gt; varRefs = NodeQuery::querySubTree(loop,V_SgVarRefExp);</span></a>
<a name="11139"><span class="lineNum">   11139 </span><span class="lineCov">        350 :   for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = varRefs.begin(); i != varRefs.end(); i++)</span></a>
<a name="11140"><span class="lineNum">   11140 </span>            :   {</a>
<a name="11141"><span class="lineNum">   11141 </span><span class="lineCov">        333 :     SgVarRefExp *vRef = isSgVarRefExp((*i));</span></a>
<a name="11142"><span class="lineNum">   11142 </span><span class="lineCov">        333 :     if (vRef-&gt;get_symbol()==osymbol)</span></a>
<a name="11143"><span class="lineNum">   11143 </span><span class="lineCov">         68 :       vRef-&gt;set_symbol(nsymbol);</span></a>
<a name="11144"><span class="lineNum">   11144 </span>            :   }</a>
<a name="11145"><span class="lineNum">   11145 </span>            :   // replace for (int i=0;) with for (i=0;)</a>
<a name="11146"><span class="lineNum">   11146 </span><span class="lineCov">         17 :   SgExprStatement* ninit = buildAssignStatement(buildVarRefExp(nsymbol),deepCopy(lbast));</span></a>
<a name="11147"><span class="lineNum">   11147 </span><span class="lineCov">         17 :   removeStatement(decl); //any side effect to the symbol? put after symbol replacement anyway</span></a>
<a name="11148"><span class="lineNum">   11148 </span><span class="lineCov">         17 :   init.push_back(ninit);</span></a>
<a name="11149"><span class="lineNum">   11149 </span><span class="lineCov">         17 :   ROSE_ASSERT (loop-&gt;get_for_init_stmt () != NULL);</span></a>
<a name="11150"><span class="lineNum">   11150 </span>            :   // ninit-&gt;set_parent(loop);</a>
<a name="11151"><span class="lineNum">   11151 </span><span class="lineCov">         17 :   ninit-&gt;set_parent(loop-&gt;get_for_init_stmt ());</span></a>
<a name="11152"><span class="lineNum">   11152 </span>            : </a>
<a name="11153"><span class="lineNum">   11153 </span>            :   // keep record of this normalization</a>
<a name="11154"><span class="lineNum">   11154 </span>            :   // We may undo it later on.</a>
<a name="11155"><span class="lineNum">   11155 </span><span class="lineCov">         17 :   trans_records.forLoopInitNormalizationTable[loop] = true;</span></a>
<a name="11156"><span class="lineNum">   11156 </span><span class="lineCov">         17 :   trans_records.forLoopInitNormalizationRecord[loop] = make_pair (decl, ndecl) ;</span></a>
<a name="11157"><span class="lineNum">   11157 </span>            : </a>
<a name="11158"><span class="lineNum">   11158 </span><span class="lineCov">         17 :   return true;</span></a>
<a name="11159"><span class="lineNum">   11159 </span>            : }</a>
<a name="11160"><span class="lineNum">   11160 </span>            : </a>
<a name="11161"><span class="lineNum">   11161 </span>            : /*</a>
<a name="11162"><span class="lineNum">   11162 </span>            :   int i_norm_1;</a>
<a name="11163"><span class="lineNum">   11163 </span>            :   for (i_norm_1=0; i_norm_1&lt;upper; i_norm_1 ++ );</a>
<a name="11164"><span class="lineNum">   11164 </span>            : Becomes:</a>
<a name="11165"><span class="lineNum">   11165 </span>            :   for (int i=0; i&lt; upper; i++) ;</a>
<a name="11166"><span class="lineNum">   11166 </span>            :  * */</a>
<a name="11167"><span class="lineNum">   11167 </span><span class="lineNoCov">          0 : bool SageInterface::unnormalizeForLoopInitDeclaration(SgForStatement* loop)</span></a>
<a name="11168"><span class="lineNum">   11168 </span>            : {</a>
<a name="11169"><span class="lineNum">   11169 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (loop != NULL);</span></a>
<a name="11170"><span class="lineNum">   11170 </span>            :   //If not previously normalized, nothing to do and return false.</a>
<a name="11171"><span class="lineNum">   11171 </span><span class="lineNoCov">          0 :   if (!trans_records.forLoopInitNormalizationTable[loop])</span></a>
<a name="11172"><span class="lineNum">   11172 </span>            :     return false;</a>
<a name="11173"><span class="lineNum">   11173 </span>            :   // retrieve original and new declaration of the previous normalization</a>
<a name="11174"><span class="lineNum">   11174 </span><span class="lineNoCov">          0 :   SgVariableDeclaration* decl = trans_records.forLoopInitNormalizationRecord[loop].first;</span></a>
<a name="11175"><span class="lineNum">   11175 </span><span class="lineNoCov">          0 :   SgVariableDeclaration* ndecl = trans_records.forLoopInitNormalizationRecord[loop].second;</span></a>
<a name="11176"><span class="lineNum">   11176 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (decl!= NULL);</span></a>
<a name="11177"><span class="lineNum">   11177 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ndecl!= NULL);</span></a>
<a name="11178"><span class="lineNum">   11178 </span>            : </a>
<a name="11179"><span class="lineNum">   11179 </span>            : </a>
<a name="11180"><span class="lineNum">   11180 </span>            :   // Sanity check</a>
<a name="11181"><span class="lineNum">   11181 </span><span class="lineNoCov">          0 :   SgStatementPtrList &amp;init = loop -&gt;get_init_stmt();</span></a>
<a name="11182"><span class="lineNum">   11182 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(init.size() ==1); // We only handle one statement case</span></a>
<a name="11183"><span class="lineNum">   11183 </span>            : </a>
<a name="11184"><span class="lineNum">   11184 </span>            :   // remove the current init_stmt</a>
<a name="11185"><span class="lineNum">   11185 </span><span class="lineNoCov">          0 :   SgStatement* init1 = init.front();</span></a>
<a name="11186"><span class="lineNum">   11186 </span><span class="lineNoCov">          0 :   SgExprStatement* exp_stmt = isSgExprStatement(init1);</span></a>
<a name="11187"><span class="lineNum">   11187 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (exp_stmt != NULL);</span></a>
<a name="11188"><span class="lineNum">   11188 </span><span class="lineNoCov">          0 :   SgAssignOp* assign_op = isSgAssignOp(exp_stmt-&gt;get_expression());</span></a>
<a name="11189"><span class="lineNum">   11189 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (assign_op != NULL);</span></a>
<a name="11190"><span class="lineNum">   11190 </span>            : </a>
<a name="11191"><span class="lineNum">   11191 </span>            :   // remove the new declaration and the current i_norm=1;</a>
<a name="11192"><span class="lineNum">   11192 </span><span class="lineNoCov">          0 :   removeStatement(ndecl);</span></a>
<a name="11193"><span class="lineNum">   11193 </span><span class="lineNoCov">          0 :   removeStatement (exp_stmt);</span></a>
<a name="11194"><span class="lineNum">   11194 </span>            : </a>
<a name="11195"><span class="lineNum">   11195 </span>            :   // restore the original declaration</a>
<a name="11196"><span class="lineNum">   11196 </span><span class="lineNoCov">          0 :   init.push_back(decl);</span></a>
<a name="11197"><span class="lineNum">   11197 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (loop-&gt;get_for_init_stmt () != NULL);</span></a>
<a name="11198"><span class="lineNum">   11198 </span>            :   // ninit-&gt;set_parent(loop);</a>
<a name="11199"><span class="lineNum">   11199 </span><span class="lineNoCov">          0 :   decl-&gt;set_parent(loop-&gt;get_for_init_stmt ());</span></a>
<a name="11200"><span class="lineNum">   11200 </span>            : </a>
<a name="11201"><span class="lineNum">   11201 </span>            :   // replace variable references</a>
<a name="11202"><span class="lineNum">   11202 </span>            :   // current symbol in the AST</a>
<a name="11203"><span class="lineNum">   11203 </span><span class="lineNoCov">          0 :   SgVariableSymbol* osymbol = getFirstVarSym(ndecl);</span></a>
<a name="11204"><span class="lineNum">   11204 </span>            :   // new symbol  we want to have: the original decl</a>
<a name="11205"><span class="lineNum">   11205 </span><span class="lineNoCov">          0 :   SgVariableSymbol* nsymbol = getFirstVarSym(decl);</span></a>
<a name="11206"><span class="lineNum">   11206 </span>            :   // replace variable ref to the new symbol</a>
<a name="11207"><span class="lineNum">   11207 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt; varRefs = NodeQuery::querySubTree(loop,V_SgVarRefExp);</span></a>
<a name="11208"><span class="lineNum">   11208 </span><span class="lineNoCov">          0 :   for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = varRefs.begin(); i != varRefs.end(); i++)</span></a>
<a name="11209"><span class="lineNum">   11209 </span>            :   {</a>
<a name="11210"><span class="lineNum">   11210 </span><span class="lineNoCov">          0 :     SgVarRefExp *vRef = isSgVarRefExp((*i));</span></a>
<a name="11211"><span class="lineNum">   11211 </span><span class="lineNoCov">          0 :     if (vRef-&gt;get_symbol()==osymbol)</span></a>
<a name="11212"><span class="lineNum">   11212 </span><span class="lineNoCov">          0 :       vRef-&gt;set_symbol(nsymbol);</span></a>
<a name="11213"><span class="lineNum">   11213 </span>            :   }</a>
<a name="11214"><span class="lineNum">   11214 </span>            : </a>
<a name="11215"><span class="lineNum">   11215 </span>            :   // clear record: now the loop is not normalized any more</a>
<a name="11216"><span class="lineNum">   11216 </span><span class="lineNoCov">          0 :   trans_records.forLoopInitNormalizationTable[loop] = false;</span></a>
<a name="11217"><span class="lineNum">   11217 </span><span class="lineNoCov">          0 :   return true;</span></a>
<a name="11218"><span class="lineNum">   11218 </span>            : }</a>
<a name="11219"><span class="lineNum">   11219 </span>            : </a>
<a name="11220"><span class="lineNum">   11220 </span><span class="lineCov">         22 : bool SageInterface::normalizeForLoopTest(SgForStatement* loop)</span></a>
<a name="11221"><span class="lineNum">   11221 </span>            : {</a>
<a name="11222"><span class="lineNum">   11222 </span><span class="lineCov">         22 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="11223"><span class="lineNum">   11223 </span>            : </a>
<a name="11224"><span class="lineNum">   11224 </span>            :   // Normalized the test expressions</a>
<a name="11225"><span class="lineNum">   11225 </span>            :   // -------------------------------------</a>
<a name="11226"><span class="lineNum">   11226 </span>            : #if 0  // this is undecided</a>
<a name="11227"><span class="lineNum">   11227 </span>            :   // skip for (;;) case</a>
<a name="11228"><span class="lineNum">   11228 </span>            :   SgStatement* test_stmt = loop-&gt;get_test();</a>
<a name="11229"><span class="lineNum">   11229 </span>            :   if (test_stmt!=NULL)</a>
<a name="11230"><span class="lineNum">   11230 </span>            :   {</a>
<a name="11231"><span class="lineNum">   11231 </span>            :     if (isSgNullStatement(test_stmt))</a>
<a name="11232"><span class="lineNum">   11232 </span>            :       return false;</a>
<a name="11233"><span class="lineNum">   11233 </span>            :   }</a>
<a name="11234"><span class="lineNum">   11234 </span>            : #endif</a>
<a name="11235"><span class="lineNum">   11235 </span><span class="lineCov">         22 :   SgExpression* test = loop-&gt;get_test_expr();</span></a>
<a name="11236"><span class="lineNum">   11236 </span><span class="lineCov">         22 :   SgExpression* testlhs=NULL, * testrhs=NULL;</span></a>
<a name="11237"><span class="lineNum">   11237 </span><span class="lineCov">         22 :   if (isSgBinaryOp(test))</span></a>
<a name="11238"><span class="lineNum">   11238 </span>            :   {</a>
<a name="11239"><span class="lineNum">   11239 </span><span class="lineCov">         22 :     testlhs = isSgBinaryOp(test)-&gt;get_lhs_operand();</span></a>
<a name="11240"><span class="lineNum">   11240 </span><span class="lineCov">         22 :     testrhs = isSgBinaryOp(test)-&gt;get_rhs_operand();</span></a>
<a name="11241"><span class="lineNum">   11241 </span><span class="lineCov">         22 :     ROSE_ASSERT(testlhs &amp;&amp; testrhs);</span></a>
<a name="11242"><span class="lineNum">   11242 </span>            :   }</a>
<a name="11243"><span class="lineNum">   11243 </span>            :   else</a>
<a name="11244"><span class="lineNum">   11244 </span>            :     return false;</a>
<a name="11245"><span class="lineNum">   11245 </span>            :   // keep the variable since test will be removed later on</a>
<a name="11246"><span class="lineNum">   11246 </span><span class="lineCov">         22 :   SgVarRefExp* testlhs_var = isSgVarRefExp(SkipCasting(testlhs));</span></a>
<a name="11247"><span class="lineNum">   11247 </span><span class="lineCov">         22 :   if (testlhs_var == NULL )</span></a>
<a name="11248"><span class="lineNum">   11248 </span>            :     return false;</a>
<a name="11249"><span class="lineNum">   11249 </span><span class="lineCov">         22 :   SgVariableSymbol * var_symbol = testlhs_var-&gt;get_symbol();</span></a>
<a name="11250"><span class="lineNum">   11250 </span><span class="lineCov">         22 :   if (var_symbol==NULL)</span></a>
<a name="11251"><span class="lineNum">   11251 </span>            :     return false;</a>
<a name="11252"><span class="lineNum">   11252 </span>            : </a>
<a name="11253"><span class="lineNum">   11253 </span><span class="lineCov">         22 :   switch (test-&gt;variantT()) {</span></a>
<a name="11254"><span class="lineNum">   11254 </span><span class="lineCov">         17 :     case V_SgLessThanOp:  // i&lt;x is normalized to i&lt;= (x-1)</span></a>
<a name="11255"><span class="lineNum">   11255 </span><span class="lineCov">         17 :       replaceExpression(test, buildLessOrEqualOp(deepCopy(testlhs),</span></a>
<a name="11256"><span class="lineNum">   11256 </span><span class="lineCov">         17 :             buildSubtractOp(deepCopy(testrhs), buildIntVal(1))));</span></a>
<a name="11257"><span class="lineNum">   11257 </span>            :       // deepDelete(test);// replaceExpression() does this already by default.</a>
<a name="11258"><span class="lineNum">   11258 </span><span class="lineCov">         17 :       break;</span></a>
<a name="11259"><span class="lineNum">   11259 </span><span class="lineCov">          4 :     case V_SgGreaterThanOp: // i&gt;x is normalized to i&gt;= (x+1)</span></a>
<a name="11260"><span class="lineNum">   11260 </span><span class="lineCov">          4 :       replaceExpression( test, buildGreaterOrEqualOp(deepCopy(testlhs),</span></a>
<a name="11261"><span class="lineNum">   11261 </span><span class="lineCov">          4 :             buildAddOp(deepCopy(testrhs), buildIntVal(1))));</span></a>
<a name="11262"><span class="lineNum">   11262 </span><span class="lineCov">          4 :       break;</span></a>
<a name="11263"><span class="lineNum">   11263 </span>            :     case V_SgLessOrEqualOp:</a>
<a name="11264"><span class="lineNum">   11264 </span>            :     case V_SgGreaterOrEqualOp:</a>
<a name="11265"><span class="lineNum">   11265 </span>            :     case V_SgNotEqualOp: //TODO Do we want to allow this?</a>
<a name="11266"><span class="lineNum">   11266 </span>            :       break;</a>
<a name="11267"><span class="lineNum">   11267 </span>            :     default:</a>
<a name="11268"><span class="lineNum">   11268 </span>            :       return false;</a>
<a name="11269"><span class="lineNum">   11269 </span>            :   }</a>
<a name="11270"><span class="lineNum">   11270 </span>            :   return true;</a>
<a name="11271"><span class="lineNum">   11271 </span>            : }</a>
<a name="11272"><span class="lineNum">   11272 </span><span class="lineCov">         22 : bool  SageInterface::normalizeForLoopIncrement(SgForStatement* loop)</span></a>
<a name="11273"><span class="lineNum">   11273 </span>            : {</a>
<a name="11274"><span class="lineNum">   11274 </span><span class="lineCov">         22 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="11275"><span class="lineNum">   11275 </span>            : </a>
<a name="11276"><span class="lineNum">   11276 </span><span class="lineCov">         22 :   SgExpression* test = loop-&gt;get_test_expr();</span></a>
<a name="11277"><span class="lineNum">   11277 </span><span class="lineCov">         22 :   SgExpression* testlhs=NULL, * testrhs=NULL;</span></a>
<a name="11278"><span class="lineNum">   11278 </span><span class="lineCov">         22 :   if (isSgBinaryOp(test))</span></a>
<a name="11279"><span class="lineNum">   11279 </span>            :   {</a>
<a name="11280"><span class="lineNum">   11280 </span><span class="lineCov">         22 :     testlhs = isSgBinaryOp(test)-&gt;get_lhs_operand();</span></a>
<a name="11281"><span class="lineNum">   11281 </span><span class="lineCov">         22 :     testrhs = isSgBinaryOp(test)-&gt;get_rhs_operand();</span></a>
<a name="11282"><span class="lineNum">   11282 </span><span class="lineCov">         22 :     ROSE_ASSERT(testlhs &amp;&amp; testrhs);</span></a>
<a name="11283"><span class="lineNum">   11283 </span>            :   }</a>
<a name="11284"><span class="lineNum">   11284 </span>            :   else</a>
<a name="11285"><span class="lineNum">   11285 </span>            :     return false;</a>
<a name="11286"><span class="lineNum">   11286 </span>            :   // keep the variable since test will be removed later on</a>
<a name="11287"><span class="lineNum">   11287 </span><span class="lineCov">         22 :   SgVarRefExp* testlhs_var = isSgVarRefExp(SkipCasting(testlhs));</span></a>
<a name="11288"><span class="lineNum">   11288 </span><span class="lineCov">         22 :   if (testlhs_var == NULL )</span></a>
<a name="11289"><span class="lineNum">   11289 </span>            :     return false;</a>
<a name="11290"><span class="lineNum">   11290 </span><span class="lineCov">         22 :   SgVariableSymbol * var_symbol = testlhs_var-&gt;get_symbol();</span></a>
<a name="11291"><span class="lineNum">   11291 </span><span class="lineCov">         22 :   if (var_symbol==NULL)</span></a>
<a name="11292"><span class="lineNum">   11292 </span>            :     return false;</a>
<a name="11293"><span class="lineNum">   11293 </span>            : </a>
<a name="11294"><span class="lineNum">   11294 </span>            : </a>
<a name="11295"><span class="lineNum">   11295 </span>            :   // -------------------------------------</a>
<a name="11296"><span class="lineNum">   11296 </span><span class="lineCov">         22 :   SgExpression* incr = loop-&gt;get_increment();</span></a>
<a name="11297"><span class="lineNum">   11297 </span><span class="lineCov">         22 :   ROSE_ASSERT(incr != NULL);</span></a>
<a name="11298"><span class="lineNum">   11298 </span><span class="lineCov">         22 :   switch (incr-&gt;variantT()) {</span></a>
<a name="11299"><span class="lineNum">   11299 </span><span class="lineCov">          4 :     case V_SgPlusPlusOp: //i++ is normalized to i+=1</span></a>
<a name="11300"><span class="lineNum">   11300 </span><span class="lineCov">          4 :       {</span></a>
<a name="11301"><span class="lineNum">   11301 </span>            :         // check if the variables match</a>
<a name="11302"><span class="lineNum">   11302 </span><span class="lineCov">          4 :         SgVarRefExp* incr_var = isSgVarRefExp(SkipCasting(isSgPlusPlusOp(incr)-&gt;get_operand()));</span></a>
<a name="11303"><span class="lineNum">   11303 </span><span class="lineCov">          4 :         if (incr_var == NULL) return false;</span></a>
<a name="11304"><span class="lineNum">   11304 </span><span class="lineCov">          4 :         if ( incr_var-&gt;get_symbol() != var_symbol)</span></a>
<a name="11305"><span class="lineNum">   11305 </span>            :           return false;</a>
<a name="11306"><span class="lineNum">   11306 </span><span class="lineCov">          8 :         replaceExpression(incr,</span></a>
<a name="11307"><span class="lineNum">   11307 </span><span class="lineCov">          4 :             buildPlusAssignOp(isSgExpression(deepCopy(incr_var)),buildIntVal(1)));</span></a>
<a name="11308"><span class="lineNum">   11308 </span><span class="lineCov">          4 :         break;</span></a>
<a name="11309"><span class="lineNum">   11309 </span>            :       }</a>
<a name="11310"><span class="lineNum">   11310 </span><span class="lineCov">          1 :     case V_SgMinusMinusOp: //i-- is normalized to i+=-1</span></a>
<a name="11311"><span class="lineNum">   11311 </span><span class="lineCov">          1 :       {</span></a>
<a name="11312"><span class="lineNum">   11312 </span>            :         // check if the variables match</a>
<a name="11313"><span class="lineNum">   11313 </span><span class="lineCov">          1 :         SgVarRefExp* incr_var = isSgVarRefExp(SkipCasting(isSgMinusMinusOp(incr)-&gt;get_operand()));</span></a>
<a name="11314"><span class="lineNum">   11314 </span><span class="lineCov">          1 :         if (incr_var == NULL) return false;</span></a>
<a name="11315"><span class="lineNum">   11315 </span><span class="lineCov">          1 :         if ( incr_var-&gt;get_symbol() != var_symbol)</span></a>
<a name="11316"><span class="lineNum">   11316 </span>            :           return false;</a>
<a name="11317"><span class="lineNum">   11317 </span><span class="lineCov">          2 :         replaceExpression(incr,</span></a>
<a name="11318"><span class="lineNum">   11318 </span><span class="lineCov">          1 :             buildPlusAssignOp(isSgExpression(deepCopy(incr_var)), buildIntVal(-1)));</span></a>
<a name="11319"><span class="lineNum">   11319 </span><span class="lineCov">          1 :         break;</span></a>
<a name="11320"><span class="lineNum">   11320 </span>            :       }</a>
<a name="11321"><span class="lineNum">   11321 </span><span class="lineCov">          1 :     case V_SgMinusAssignOp: // i-= s is normalized to i+= -s</span></a>
<a name="11322"><span class="lineNum">   11322 </span><span class="lineCov">          1 :       {</span></a>
<a name="11323"><span class="lineNum">   11323 </span><span class="lineCov">          1 :         SgVarRefExp* incr_var = isSgVarRefExp(SkipCasting(isSgMinusAssignOp(incr)-&gt;get_lhs_operand()));</span></a>
<a name="11324"><span class="lineNum">   11324 </span><span class="lineCov">          1 :         SgExpression* rhs = isSgMinusAssignOp(incr)-&gt;get_rhs_operand();</span></a>
<a name="11325"><span class="lineNum">   11325 </span><span class="lineCov">          1 :         ROSE_ASSERT (rhs != NULL);</span></a>
<a name="11326"><span class="lineNum">   11326 </span><span class="lineCov">          1 :         if (incr_var == NULL) return false;</span></a>
<a name="11327"><span class="lineNum">   11327 </span><span class="lineCov">          1 :         if ( incr_var-&gt;get_symbol() != var_symbol)</span></a>
<a name="11328"><span class="lineNum">   11328 </span>            :           return false;</a>
<a name="11329"><span class="lineNum">   11329 </span><span class="lineCov">          2 :         replaceExpression(incr,</span></a>
<a name="11330"><span class="lineNum">   11330 </span><span class="lineCov">          1 :             buildPlusAssignOp(isSgExpression(deepCopy(incr_var)), buildMultiplyOp(buildIntVal(-1), copyExpression(rhs))));</span></a>
<a name="11331"><span class="lineNum">   11331 </span><span class="lineCov">          1 :         break;</span></a>
<a name="11332"><span class="lineNum">   11332 </span>            :       }</a>
<a name="11333"><span class="lineNum">   11333 </span>            :     case V_SgAssignOp:</a>
<a name="11334"><span class="lineNum">   11334 </span>            :     case V_SgPlusAssignOp:</a>
<a name="11335"><span class="lineNum">   11335 </span>            :       break;</a>
<a name="11336"><span class="lineNum">   11336 </span>            :     default:</a>
<a name="11337"><span class="lineNum">   11337 </span>            :       return false;</a>
<a name="11338"><span class="lineNum">   11338 </span>            :   }</a>
<a name="11339"><span class="lineNum">   11339 </span>            : </a>
<a name="11340"><span class="lineNum">   11340 </span>            :   return true;</a>
<a name="11341"><span class="lineNum">   11341 </span>            : }</a>
<a name="11342"><span class="lineNum">   11342 </span>            : //! Normalize a for loop, part of migrating Qing's loop handling into SageInterface</a>
<a name="11343"><span class="lineNum">   11343 </span>            : // Her loop translation does not pass AST consistency tests so we rewrite some of them here</a>
<a name="11344"><span class="lineNum">   11344 </span>            : // NormalizeCPP.C  NormalizeLoopTraverse::ProcessLoop()</a>
<a name="11345"><span class="lineNum">   11345 </span><span class="lineCov">         22 : bool SageInterface::forLoopNormalization(SgForStatement* loop, bool foldConstant /*= true*/)</span></a>
<a name="11346"><span class="lineNum">   11346 </span>            : {</a>
<a name="11347"><span class="lineNum">   11347 </span><span class="lineCov">         22 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="11348"><span class="lineNum">   11348 </span>            :   // Normalize initialization statement of the for loop</a>
<a name="11349"><span class="lineNum">   11349 </span>            :   // -------------------------------------</a>
<a name="11350"><span class="lineNum">   11350 </span>            :   // for (int i=0;... ) becomes int i; for (i=0;..)</a>
<a name="11351"><span class="lineNum">   11351 </span>            :   // Only roughly check here, isCanonicalForLoop() should be called to have a stricter check</a>
<a name="11352"><span class="lineNum">   11352 </span><span class="lineCov">         22 :   if (!normalizeForLoopInitDeclaration(loop))</span></a>
<a name="11353"><span class="lineNum">   11353 </span>            :     return false;</a>
<a name="11354"><span class="lineNum">   11354 </span>            : </a>
<a name="11355"><span class="lineNum">   11355 </span>            :   // Normalized the test expressions</a>
<a name="11356"><span class="lineNum">   11356 </span><span class="lineCov">         22 :   if (!normalizeForLoopTest(loop))</span></a>
<a name="11357"><span class="lineNum">   11357 </span>            :     return false;</a>
<a name="11358"><span class="lineNum">   11358 </span>            : </a>
<a name="11359"><span class="lineNum">   11359 </span>            :  // Normalize the increment expression</a>
<a name="11360"><span class="lineNum">   11360 </span><span class="lineCov">         22 :   if (!normalizeForLoopIncrement(loop))</span></a>
<a name="11361"><span class="lineNum">   11361 </span>            :     return false;</a>
<a name="11362"><span class="lineNum">   11362 </span>            : </a>
<a name="11363"><span class="lineNum">   11363 </span>            :   // Normalize the loop body: ensure there is a basic block</a>
<a name="11364"><span class="lineNum">   11364 </span><span class="lineCov">         22 :   SgBasicBlock* body = ensureBasicBlockAsBodyOfFor(loop);</span></a>
<a name="11365"><span class="lineNum">   11365 </span><span class="lineCov">         22 :   ROSE_ASSERT(body!=NULL);</span></a>
<a name="11366"><span class="lineNum">   11366 </span>            :    // Liao, 9/22/2009</a>
<a name="11367"><span class="lineNum">   11367 </span>            :    // folding entire loop may cause decreased accuracy for floating point operations</a>
<a name="11368"><span class="lineNum">   11368 </span>            :    // we only want to fold the loop controlling expressions</a>
<a name="11369"><span class="lineNum">   11369 </span><span class="lineCov">         22 :   if (foldConstant)</span></a>
<a name="11370"><span class="lineNum">   11370 </span>            :   {</a>
<a name="11371"><span class="lineNum">   11371 </span>            :     //constantFolding(loop-&gt;get_parent());</a>
<a name="11372"><span class="lineNum">   11372 </span><span class="lineCov">         19 :     constantFolding(loop-&gt;get_test());</span></a>
<a name="11373"><span class="lineNum">   11373 </span><span class="lineCov">         19 :     constantFolding(loop-&gt;get_increment());</span></a>
<a name="11374"><span class="lineNum">   11374 </span>            :   }</a>
<a name="11375"><span class="lineNum">   11375 </span>            : </a>
<a name="11376"><span class="lineNum">   11376 </span>            :   return true;</a>
<a name="11377"><span class="lineNum">   11377 </span>            : }</a>
<a name="11378"><span class="lineNum">   11378 </span>            : </a>
<a name="11379"><span class="lineNum">   11379 </span>            : //!Normalize a Fortran Do loop. Make the default increment expression (1) explicit</a>
<a name="11380"><span class="lineNum">   11380 </span><span class="lineCov">          3 : bool SageInterface::doLoopNormalization(SgFortranDo* loop)</span></a>
<a name="11381"><span class="lineNum">   11381 </span>            : {</a>
<a name="11382"><span class="lineNum">   11382 </span>            :   // TODO, normalize continue to enddo ?</a>
<a name="11383"><span class="lineNum">   11383 </span><span class="lineCov">          3 :   ROSE_ASSERT (loop != NULL);</span></a>
<a name="11384"><span class="lineNum">   11384 </span><span class="lineCov">          3 :   SgExpression* e_3 = loop-&gt;get_increment();</span></a>
<a name="11385"><span class="lineNum">   11385 </span><span class="lineCov">          3 :   if (isSgNullExpression(e_3))</span></a>
<a name="11386"><span class="lineNum">   11386 </span>            :   {</a>
<a name="11387"><span class="lineNum">   11387 </span><span class="lineCov">          2 :     SgIntVal* iv = buildIntVal(1);</span></a>
<a name="11388"><span class="lineNum">   11388 </span><span class="lineCov">          2 :     loop-&gt;set_increment(iv);</span></a>
<a name="11389"><span class="lineNum">   11389 </span><span class="lineCov">          2 :     iv-&gt;set_parent(loop);</span></a>
<a name="11390"><span class="lineNum">   11390 </span><span class="lineCov">          2 :     delete (e_3);</span></a>
<a name="11391"><span class="lineNum">   11391 </span>            :   }</a>
<a name="11392"><span class="lineNum">   11392 </span><span class="lineCov">          3 :   return true;</span></a>
<a name="11393"><span class="lineNum">   11393 </span>            : }</a>
<a name="11394"><span class="lineNum">   11394 </span>            : </a>
<a name="11395"><span class="lineNum">   11395 </span>            : #if 0</a>
<a name="11396"><span class="lineNum">   11396 </span>            : bool SageInterface::loopUnrolling(SgForStatement* loop, size_t unrolling_factor)</a>
<a name="11397"><span class="lineNum">   11397 </span>            : {</a>
<a name="11398"><span class="lineNum">   11398 </span>            :   // normalize the loop first</a>
<a name="11399"><span class="lineNum">   11399 </span>            :   if (!forLoopNormalization(loop))</a>
<a name="11400"><span class="lineNum">   11400 </span>            :     return false; // input loop cannot be normalized to a canonical form</a>
<a name="11401"><span class="lineNum">   11401 </span>            :   // prepare Loop transformation environment</a>
<a name="11402"><span class="lineNum">   11402 </span>            :   SgFunctionDeclaration* func = getEnclosingFunctionDeclaration(loop);</a>
<a name="11403"><span class="lineNum">   11403 </span>            :   ROSE_ASSERT(func!=NULL);</a>
<a name="11404"><span class="lineNum">   11404 </span>            :   AstInterfaceImpl faImpl(func-&gt;get_definition()-&gt;get_body());</a>
<a name="11405"><span class="lineNum">   11405 </span>            :   AstInterface fa(&amp;faImpl);</a>
<a name="11406"><span class="lineNum">   11406 </span>            :   ArrayAnnotation* annot = ArrayAnnotation::get_inst();</a>
<a name="11407"><span class="lineNum">   11407 </span>            :   ArrayInterface array_interface (*annot);</a>
<a name="11408"><span class="lineNum">   11408 </span>            :   array_interface.initialize(fa, AstNodePtrImpl(func-&gt;get_definition()));</a>
<a name="11409"><span class="lineNum">   11409 </span>            :   array_interface.observe(fa);</a>
<a name="11410"><span class="lineNum">   11410 </span>            :   LoopTransformInterface :: set_astInterface(fa);</a>
<a name="11411"><span class="lineNum">   11411 </span>            :   LoopTransformInterface :: set_arrayInterface(&amp;array_interface);</a>
<a name="11412"><span class="lineNum">   11412 </span>            : </a>
<a name="11413"><span class="lineNum">   11413 </span>            :   // invoke the unrolling defined in Qing's code</a>
<a name="11414"><span class="lineNum">   11414 </span>            :   // the traversal will skip the input node ptr, so we pass loop's parent ptr instead</a>
<a name="11415"><span class="lineNum">   11415 </span>            :   AstNodePtr result = AstNodePtrImpl(loop-&gt;get_parent()) ;</a>
<a name="11416"><span class="lineNum">   11416 </span>            : </a>
<a name="11417"><span class="lineNum">   11417 </span>            :   LoopUnrolling lu(unrolling_factor);</a>
<a name="11418"><span class="lineNum">   11418 </span>            :   //LoopUnrolling lu(unrolling_factor,LoopUnrolling::COND_LEFTOVER);//works but not a good choice</a>
<a name="11419"><span class="lineNum">   11419 </span>            :   //if (lu.cmdline_configure()) // this will cause unrolling to be skipped if no -unroll is used in command line</a>
<a name="11420"><span class="lineNum">   11420 </span>            :   result = lu(lpTrans, result);</a>
<a name="11421"><span class="lineNum">   11421 </span>            :   return true;</a>
<a name="11422"><span class="lineNum">   11422 </span>            : }</a>
<a name="11423"><span class="lineNum">   11423 </span>            : #else</a>
<a name="11424"><span class="lineNum">   11424 </span>            : </a>
<a name="11425"><span class="lineNum">   11425 </span>            : // a brand new serious implementation for loop unrolling, Liao, 6/25/2009</a>
<a name="11426"><span class="lineNum">   11426 </span>            : /* Handle left-over iterations if iteration_count%unrolling_factor != 0</a>
<a name="11427"><span class="lineNum">   11427 </span>            :  * Handle stride (step) &gt;1</a>
<a name="11428"><span class="lineNum">   11428 </span>            :  * Assuming loop is normalized to [lb,ub,step], ub is inclusive (&lt;=, &gt;=)</a>
<a name="11429"><span class="lineNum">   11429 </span>            :  *</a>
<a name="11430"><span class="lineNum">   11430 </span>            :  *  iteration_count = (ub-lb+1)%step ==0?(ub-lb+1)/step: (ub-lb+1)/step+1</a>
<a name="11431"><span class="lineNum">   11431 </span>            :  *  fringe = iteration_count%unroll_factor==0 ? 0:unroll_factor*step;</a>
<a name="11432"><span class="lineNum">   11432 </span>            :  *    fringe ==0 if no leftover iterations</a>
<a name="11433"><span class="lineNum">   11433 </span>            :  *    otherwise adjust ub so the leftover iterations will put into the last fringe loop</a>
<a name="11434"><span class="lineNum">   11434 </span>            :  *  unrolled loop's header: for (i=lb;i&lt;=ub - fringe; i+= step*unroll_factor)</a>
<a name="11435"><span class="lineNum">   11435 </span>            :  *  loop body: copy body n times from 0 to factor -1</a>
<a name="11436"><span class="lineNum">   11436 </span>            :  *     stmt(i+ 0*step); ...; stmt (i+ (factor-1)*step);</a>
<a name="11437"><span class="lineNum">   11437 </span>            :  *  fringe loop: the same as the original loop, except for no init statement</a>
<a name="11438"><span class="lineNum">   11438 </span>            :  *</a>
<a name="11439"><span class="lineNum">   11439 </span>            :  * e.g:</a>
<a name="11440"><span class="lineNum">   11440 </span>            :  * // unrolling 3 times for the following loop with stride !=1</a>
<a name="11441"><span class="lineNum">   11441 </span>            :  *       for (i=0; i&lt;=9; i+=3)</a>
<a name="11442"><span class="lineNum">   11442 </span>            :  *       {</a>
<a name="11443"><span class="lineNum">   11443 </span>            :  *         a[i]=i;</a>
<a name="11444"><span class="lineNum">   11444 </span>            :  *       }</a>
<a name="11445"><span class="lineNum">   11445 </span>            :  * // it becomes</a>
<a name="11446"><span class="lineNum">   11446 </span>            :  *     // iteration count = 10%3=1 -&gt; 10/3+1 = 4</a>
<a name="11447"><span class="lineNum">   11447 </span>            :  *     // fringe = 4%3 =1 --&gt; 3*3</a>
<a name="11448"><span class="lineNum">   11448 </span>            :  *     // ub-fringe = 9-3*3</a>
<a name="11449"><span class="lineNum">   11449 </span>            :  *        for (i=0; i&lt;=9-3*3; i+=3*3)</a>
<a name="11450"><span class="lineNum">   11450 </span>            :  *     {</a>
<a name="11451"><span class="lineNum">   11451 </span>            :  *       a[i+3*0]=i;</a>
<a name="11452"><span class="lineNum">   11452 </span>            :  *       a[i+3*1]=i;</a>
<a name="11453"><span class="lineNum">   11453 </span>            :  *       a[i+3*2]=i;</a>
<a name="11454"><span class="lineNum">   11454 </span>            :  *     }</a>
<a name="11455"><span class="lineNum">   11455 </span>            :  *     // i=9 is the leftover iteration</a>
<a name="11456"><span class="lineNum">   11456 </span>            :  *     for (; i&lt;=9; i+=3)</a>
<a name="11457"><span class="lineNum">   11457 </span>            :  *     {</a>
<a name="11458"><span class="lineNum">   11458 </span>            :  *       a[i]=i;</a>
<a name="11459"><span class="lineNum">   11459 </span>            :  *     }</a>
<a name="11460"><span class="lineNum">   11460 </span>            :  *</a>
<a name="11461"><span class="lineNum">   11461 </span>            :  */</a>
<a name="11462"><span class="lineNum">   11462 </span><span class="lineCov">          2 : bool SageInterface::loopUnrolling(SgForStatement* target_loop, size_t unrolling_factor)</span></a>
<a name="11463"><span class="lineNum">   11463 </span>            : {</a>
<a name="11464"><span class="lineNum">   11464 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="11465"><span class="lineNum">   11465 </span>            :   //Handle 0 and 1, which means no unrolling at all</a>
<a name="11466"><span class="lineNum">   11466 </span><span class="lineCov">          2 :   if (unrolling_factor &lt;= 1)</span></a>
<a name="11467"><span class="lineNum">   11467 </span>            :     return true;</a>
<a name="11468"><span class="lineNum">   11468 </span>            : </a>
<a name="11469"><span class="lineNum">   11469 </span>            :   // normalize the target loop first</a>
<a name="11470"><span class="lineNum">   11470 </span>            : </a>
<a name="11471"><span class="lineNum">   11471 </span>            :   // DQ (3/25/2017): Fixed Clang warning: warning: if statement has empty body [-Wempty-body]</a>
<a name="11472"><span class="lineNum">   11472 </span>            :   // if (!forLoopNormalization(target_loop));</a>
<a name="11473"><span class="lineNum">   11473 </span><span class="lineCov">          2 :   if (!forLoopNormalization(target_loop))</span></a>
<a name="11474"><span class="lineNum">   11474 </span>            :   {</a>
<a name="11475"><span class="lineNum">   11475 </span>            :     // the return value is not reliable</a>
<a name="11476"><span class="lineNum">   11476 </span>            :     //    cerr&lt;&lt;&quot;Error in SageInterface::loopUnrolling(): target loop cannot be normalized.&quot;&lt;&lt;endl;</a>
<a name="11477"><span class="lineNum">   11477 </span>            :     //    dumpInfo(target_loop);</a>
<a name="11478"><span class="lineNum">   11478 </span>            :     //    return false;</a>
<a name="11479"><span class="lineNum">   11479 </span>            :   }</a>
<a name="11480"><span class="lineNum">   11480 </span>            :   // grab the target loop's essential header information</a>
<a name="11481"><span class="lineNum">   11481 </span><span class="lineCov">          2 :   SgInitializedName* ivar = NULL;</span></a>
<a name="11482"><span class="lineNum">   11482 </span><span class="lineCov">          2 :   SgExpression* lb = NULL;</span></a>
<a name="11483"><span class="lineNum">   11483 </span><span class="lineCov">          2 :   SgExpression* ub = NULL;</span></a>
<a name="11484"><span class="lineNum">   11484 </span><span class="lineCov">          2 :   SgExpression* step = NULL;</span></a>
<a name="11485"><span class="lineNum">   11485 </span><span class="lineCov">          2 :   SgStatement* orig_body = NULL;</span></a>
<a name="11486"><span class="lineNum">   11486 </span><span class="lineCov">          2 :   if (!isCanonicalForLoop(target_loop, &amp;ivar, &amp;lb, &amp;ub, &amp;step, &amp;orig_body))</span></a>
<a name="11487"><span class="lineNum">   11487 </span>            :   {</a>
<a name="11488"><span class="lineNum">   11488 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error in SageInterface::loopUnrolling(): target loop is not canonical.&quot;&lt;&lt;endl;</span></a>
<a name="11489"><span class="lineNum">   11489 </span><span class="lineNoCov">          0 :     dumpInfo(target_loop);</span></a>
<a name="11490"><span class="lineNum">   11490 </span><span class="lineNoCov">          0 :     return false;</span></a>
<a name="11491"><span class="lineNum">   11491 </span>            :   }</a>
<a name="11492"><span class="lineNum">   11492 </span><span class="lineCov">          2 :   ROSE_ASSERT(ivar&amp;&amp; lb &amp;&amp; ub &amp;&amp; step);</span></a>
<a name="11493"><span class="lineNum">   11493 </span><span class="lineCov">          2 :   ROSE_ASSERT(isSgBasicBlock(orig_body));</span></a>
<a name="11494"><span class="lineNum">   11494 </span>            : </a>
<a name="11495"><span class="lineNum">   11495 </span>            :    // generate the fringe loop</a>
<a name="11496"><span class="lineNum">   11496 </span><span class="lineCov">          2 :    bool needFringe = true;</span></a>
<a name="11497"><span class="lineNum">   11497 </span><span class="lineCov">          2 :    SgForStatement* fringe_loop = deepCopy&lt;SgForStatement&gt;(target_loop);</span></a>
<a name="11498"><span class="lineNum">   11498 </span><span class="lineCov">          2 :    if (target_loop-&gt;get_parent()-&gt;variantT() == V_SgUpirLoopParallelStatement) {</span></a>
<a name="11499"><span class="lineNum">   11499 </span><span class="lineNoCov">          0 :        insertStatementAfter(static_cast&lt;SgStatement *&gt;(target_loop-&gt;get_parent()),fringe_loop);</span></a>
<a name="11500"><span class="lineNum">   11500 </span>            :    } else {</a>
<a name="11501"><span class="lineNum">   11501 </span><span class="lineCov">          2 :        insertStatementAfter(target_loop,fringe_loop);</span></a>
<a name="11502"><span class="lineNum">   11502 </span>            :    }</a>
<a name="11503"><span class="lineNum">   11503 </span><span class="lineCov">          2 :    removeStatement(fringe_loop-&gt;get_for_init_stmt());</span></a>
<a name="11504"><span class="lineNum">   11504 </span><span class="lineCov">          2 :    fringe_loop-&gt;set_for_init_stmt(NULL);</span></a>
<a name="11505"><span class="lineNum">   11505 </span>            : </a>
<a name="11506"><span class="lineNum">   11506 </span>            :   // _lu_iter_count = (ub-lb+1)%step ==0?(ub-lb+1)/step: (ub-lb+1)/step+1;</a>
<a name="11507"><span class="lineNum">   11507 </span><span class="lineCov">          2 :   SgExpression* raw_range_exp =buildSubtractOp(buildAddOp(copyExpression(ub),buildIntVal(1)),</span></a>
<a name="11508"><span class="lineNum">   11508 </span>            :             copyExpression(lb));</a>
<a name="11509"><span class="lineNum">   11509 </span><span class="lineCov">          2 :   raw_range_exp-&gt;set_need_paren(true);</span></a>
<a name="11510"><span class="lineNum">   11510 </span><span class="lineCov">          2 :   SgExpression* range_d_step_exp = buildDivideOp(raw_range_exp,copyExpression(step));//(ub-lb+1)/step</span></a>
<a name="11511"><span class="lineNum">   11511 </span><span class="lineCov">          2 :   SgExpression* condition_1 = buildEqualityOp(buildModOp(copyExpression(raw_range_exp),copyExpression(step)),buildIntVal(0)); //(ub-lb+1)%step ==0</span></a>
<a name="11512"><span class="lineNum">   11512 </span>            : </a>
<a name="11513"><span class="lineNum">   11513 </span><span class="lineCov">          2 :   SgExpression* iter_count_exp = buildConditionalExp(condition_1,range_d_step_exp, buildAddOp(copyExpression(range_d_step_exp),buildIntVal(1)));</span></a>
<a name="11514"><span class="lineNum">   11514 </span>            :   // fringe = iteration_count%unroll_factor==0 ? 0:unroll_factor*step</a>
<a name="11515"><span class="lineNum">   11515 </span><span class="lineCov">          2 :   SgExpression* condition_2 = buildEqualityOp(buildModOp(iter_count_exp, buildIntVal(unrolling_factor)), buildIntVal(0));</span></a>
<a name="11516"><span class="lineNum">   11516 </span><span class="lineCov">          2 :   SgExpression* initor = buildConditionalExp(condition_2, buildIntVal(0), buildMultiplyOp(buildIntVal(unrolling_factor),copyExpression(step)));</span></a>
<a name="11517"><span class="lineNum">   11517 </span>            : </a>
<a name="11518"><span class="lineNum">   11518 </span><span class="lineCov">          2 :    SgScopeStatement* scope = target_loop-&gt;get_scope();</span></a>
<a name="11519"><span class="lineNum">   11519 </span><span class="lineCov">          2 :    ROSE_ASSERT(scope != NULL);</span></a>
<a name="11520"><span class="lineNum">   11520 </span><span class="lineCov">          4 :    string fringe_name = &quot;_lu_fringe_&quot;+ StringUtility::numberToString(++gensym_counter);</span></a>
<a name="11521"><span class="lineNum">   11521 </span><span class="lineCov">          2 :    SgVariableDeclaration* fringe_decl = buildVariableDeclaration(fringe_name, buildIntType(),buildAssignInitializer(initor), scope);</span></a>
<a name="11522"><span class="lineNum">   11522 </span><span class="lineCov">          2 :    if (target_loop-&gt;get_parent()-&gt;variantT() == V_SgUpirLoopParallelStatement) {</span></a>
<a name="11523"><span class="lineNum">   11523 </span><span class="lineNoCov">          0 :        insertStatementBefore(static_cast&lt;SgStatement *&gt;(target_loop-&gt;get_parent()),fringe_decl);</span></a>
<a name="11524"><span class="lineNum">   11524 </span>            :    } else {</a>
<a name="11525"><span class="lineNum">   11525 </span><span class="lineCov">          2 :        insertStatementAfter(target_loop,fringe_decl);</span></a>
<a name="11526"><span class="lineNum">   11526 </span>            :    }</a>
<a name="11527"><span class="lineNum">   11527 </span><span class="lineCov">          2 :    attachComment(fringe_decl, &quot;iter_count = (ub-lb+1)%step ==0?(ub-lb+1)/step: (ub-lb+1)/step+1;&quot;);</span></a>
<a name="11528"><span class="lineNum">   11528 </span><span class="lineCov">          2 :    attachComment(fringe_decl, &quot;fringe = iter_count%unroll_factor==0 ? 0:unroll_factor*step&quot;);</span></a>
<a name="11529"><span class="lineNum">   11529 </span>            : </a>
<a name="11530"><span class="lineNum">   11530 </span>            :   // compile-time evaluate to see if index is a constant of value 0</a>
<a name="11531"><span class="lineNum">   11531 </span>            :   // if so, the iteration count can be divided even by the unrolling factor</a>
<a name="11532"><span class="lineNum">   11532 </span>            :   // and no fringe loop is needed</a>
<a name="11533"><span class="lineNum">   11533 </span>            :   // WE have to fold on its parent node to get a possible constant since</a>
<a name="11534"><span class="lineNum">   11534 </span>            :   // constant folding only folds children nodes, not the current node to a constant</a>
<a name="11535"><span class="lineNum">   11535 </span><span class="lineCov">          2 :    ConstantFolding::constantFoldingOptimization(fringe_decl,false);</span></a>
<a name="11536"><span class="lineNum">   11536 </span><span class="lineCov">          2 :    SgInitializedName * ivarname = fringe_decl-&gt;get_variables().front();</span></a>
<a name="11537"><span class="lineNum">   11537 </span><span class="lineCov">          2 :    ROSE_ASSERT(ivarname != NULL);</span></a>
<a name="11538"><span class="lineNum">   11538 </span>            :    // points to a new address if constant folding happens</a>
<a name="11539"><span class="lineNum">   11539 </span><span class="lineCov">          2 :    SgAssignInitializer * init1 = isSgAssignInitializer(ivarname-&gt;get_initializer());</span></a>
<a name="11540"><span class="lineNum">   11540 </span><span class="lineCov">          2 :    if (init1)</span></a>
<a name="11541"><span class="lineNum">   11541 </span><span class="lineCov">          2 :     if (isSgIntVal(init1-&gt;get_operand_i()))</span></a>
<a name="11542"><span class="lineNum">   11542 </span><span class="lineCov">          2 :      if (isSgIntVal(init1-&gt;get_operand_i())-&gt;get_value() == 0)</span></a>
<a name="11543"><span class="lineNum">   11543 </span><span class="lineCov">          1 :        needFringe = false;</span></a>
<a name="11544"><span class="lineNum">   11544 </span>            : </a>
<a name="11545"><span class="lineNum">   11545 </span>            :   // rewrite loop header ub --&gt; ub -fringe; step --&gt; step *unrolling_factor</a>
<a name="11546"><span class="lineNum">   11546 </span><span class="lineCov">          2 :    SgBinaryOp* ub_bin_op = isSgBinaryOp(ub-&gt;get_parent());</span></a>
<a name="11547"><span class="lineNum">   11547 </span><span class="lineCov">          2 :    ROSE_ASSERT(ub_bin_op);</span></a>
<a name="11548"><span class="lineNum">   11548 </span><span class="lineCov">          2 :    if (needFringe) {</span></a>
<a name="11549"><span class="lineNum">   11549 </span>            :      //ub_bin_op-&gt;set_rhs_operand(buildSubtractOp(copyExpression(ub),buildVarRefExp(fringe_name,scope)));</a>
<a name="11550"><span class="lineNum">   11550 </span>            :    } else</a>
<a name="11551"><span class="lineNum">   11551 </span>            :    {</a>
<a name="11552"><span class="lineNum">   11552 </span><span class="lineCov">          1 :      ub_bin_op-&gt;set_rhs_operand(copyExpression(ub));</span></a>
<a name="11553"><span class="lineNum">   11553 </span><span class="lineCov">          1 :      removeStatement(fringe_decl);</span></a>
<a name="11554"><span class="lineNum">   11554 </span>            :    }</a>
<a name="11555"><span class="lineNum">   11555 </span>            : </a>
<a name="11556"><span class="lineNum">   11556 </span><span class="lineCov">          2 :    SgBinaryOp* step_bin_op = isSgBinaryOp(step-&gt;get_parent());</span></a>
<a name="11557"><span class="lineNum">   11557 </span><span class="lineCov">          2 :    ROSE_ASSERT(step_bin_op != NULL);</span></a>
<a name="11558"><span class="lineNum">   11558 </span><span class="lineCov">          2 :    step_bin_op-&gt;set_rhs_operand(buildMultiplyOp(copyExpression(step),buildIntVal(unrolling_factor)));</span></a>
<a name="11559"><span class="lineNum">   11559 </span>            : </a>
<a name="11560"><span class="lineNum">   11560 </span><span class="lineCov">          2 :    bool isPlus = false;</span></a>
<a name="11561"><span class="lineNum">   11561 </span><span class="lineCov">          2 :    if (isSgPlusAssignOp(step_bin_op))</span></a>
<a name="11562"><span class="lineNum">   11562 </span>            :      isPlus = true;</a>
<a name="11563"><span class="lineNum">   11563 </span><span class="lineNoCov">          0 :     else if (isSgMinusAssignOp(step_bin_op))</span></a>
<a name="11564"><span class="lineNum">   11564 </span>            :       isPlus = false;</a>
<a name="11565"><span class="lineNum">   11565 </span>            :     else</a>
<a name="11566"><span class="lineNum">   11566 </span>            :     {</a>
<a name="11567"><span class="lineNum">   11567 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;&quot;Error in SageInterface::loopUnrolling(): illegal incremental exp of a canonical loop&quot;&lt;&lt;endl;</span></a>
<a name="11568"><span class="lineNum">   11568 </span><span class="lineNoCov">          0 :       dumpInfo(step_bin_op);</span></a>
<a name="11569"><span class="lineNum">   11569 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="11570"><span class="lineNum">   11570 </span>            :     }</a>
<a name="11571"><span class="lineNum">   11571 </span>            : </a>
<a name="11572"><span class="lineNum">   11572 </span>            :    // copy loop body factor -1 times, and replace reference to ivar  with ivar +/- step*[1 to factor-1]</a>
<a name="11573"><span class="lineNum">   11573 </span><span class="lineCov">          8 :    for (size_t i =1; i&lt;unrolling_factor; i++)</span></a>
<a name="11574"><span class="lineNum">   11574 </span>            :    {</a>
<a name="11575"><span class="lineNum">   11575 </span><span class="lineCov">          6 :      SgBasicBlock* body = isSgBasicBlock(deepCopy(fringe_loop-&gt;get_loop_body())); // normalized loop has a BB body</span></a>
<a name="11576"><span class="lineNum">   11576 </span><span class="lineCov">          6 :      ROSE_ASSERT(body);</span></a>
<a name="11577"><span class="lineNum">   11577 </span><span class="lineCov">         12 :      std::vector&lt;SgVarRefExp*&gt; refs = querySubTree&lt;SgVarRefExp&gt; (body, V_SgVarRefExp);</span></a>
<a name="11578"><span class="lineNum">   11578 </span><span class="lineCov">         42 :      for (std::vector&lt;SgVarRefExp*&gt;::iterator iter = refs.begin(); iter !=refs.end(); iter++)</span></a>
<a name="11579"><span class="lineNum">   11579 </span>            :      {</a>
<a name="11580"><span class="lineNum">   11580 </span><span class="lineCov">         36 :        SgVarRefExp* refexp = *iter;</span></a>
<a name="11581"><span class="lineNum">   11581 </span><span class="lineCov">         36 :        if (refexp-&gt;get_symbol()==ivar-&gt;get_symbol_from_symbol_table())</span></a>
<a name="11582"><span class="lineNum">   11582 </span>            :        {</a>
<a name="11583"><span class="lineNum">   11583 </span>            :          // replace reference to ivar with ivar +/- step*i</a>
<a name="11584"><span class="lineNum">   11584 </span><span class="lineCov">         12 :          SgExpression* new_exp = NULL;</span></a>
<a name="11585"><span class="lineNum">   11585 </span>            :          //build replacement  expression for every appearance</a>
<a name="11586"><span class="lineNum">   11586 </span><span class="lineCov">         12 :          if (isPlus) //ivar +/- step * i</span></a>
<a name="11587"><span class="lineNum">   11587 </span><span class="lineCov">         12 :          new_exp = buildAddOp(buildVarRefExp(ivar,scope),buildMultiplyOp(copyExpression(step),buildIntVal(i)));</span></a>
<a name="11588"><span class="lineNum">   11588 </span>            :          else</a>
<a name="11589"><span class="lineNum">   11589 </span><span class="lineNoCov">          0 :          new_exp = buildSubtractOp(buildVarRefExp(ivar,scope),buildMultiplyOp(copyExpression(step),buildIntVal(i)));</span></a>
<a name="11590"><span class="lineNum">   11590 </span>            : </a>
<a name="11591"><span class="lineNum">   11591 </span>            :          // replace it with the right one</a>
<a name="11592"><span class="lineNum">   11592 </span><span class="lineCov">         12 :          replaceExpression(refexp, new_exp);</span></a>
<a name="11593"><span class="lineNum">   11593 </span>            :        }</a>
<a name="11594"><span class="lineNum">   11594 </span>            :      }</a>
<a name="11595"><span class="lineNum">   11595 </span>            :      // copy body to loop body, this should be a better choice</a>
<a name="11596"><span class="lineNum">   11596 </span>            :      // to avoid redefinition of variables after unrolling (new scope is introduced to avoid this)</a>
<a name="11597"><span class="lineNum">   11597 </span><span class="lineCov">          6 :      appendStatement(body,isSgBasicBlock(orig_body));</span></a>
<a name="11598"><span class="lineNum">   11598 </span>            :     // moveStatementsBetweenBlocks(body,isSgBasicBlock(orig_body));</a>
<a name="11599"><span class="lineNum">   11599 </span>            :    }</a>
<a name="11600"><span class="lineNum">   11600 </span>            : </a>
<a name="11601"><span class="lineNum">   11601 </span>            :    // remove the fringe loop if not needed finally</a>
<a name="11602"><span class="lineNum">   11602 </span>            :    // it is used to buffering the original loop body before in either cases</a>
<a name="11603"><span class="lineNum">   11603 </span><span class="lineCov">          2 :    if (!needFringe)</span></a>
<a name="11604"><span class="lineNum">   11604 </span><span class="lineCov">          1 :      removeStatement(fringe_loop);</span></a>
<a name="11605"><span class="lineNum">   11605 </span>            : </a>
<a name="11606"><span class="lineNum">   11606 </span>            :    // constant folding for the transformed AST</a>
<a name="11607"><span class="lineNum">   11607 </span><span class="lineCov">          2 :    ConstantFolding::constantFoldingOptimization(scope,false);</span></a>
<a name="11608"><span class="lineNum">   11608 </span>            :    //ConstantFolding::constantFoldingOptimization(getProject(),false);</a>
<a name="11609"><span class="lineNum">   11609 </span>            : </a>
<a name="11610"><span class="lineNum">   11610 </span>            : #endif</a>
<a name="11611"><span class="lineNum">   11611 </span>            : </a>
<a name="11612"><span class="lineNum">   11612 </span><span class="lineCov">          2 :   return true;</span></a>
<a name="11613"><span class="lineNum">   11613 </span>            : }</a>
<a name="11614"><span class="lineNum">   11614 </span>            : #endif</a>
<a name="11615"><span class="lineNum">   11615 </span>            : </a>
<a name="11616"><span class="lineNum">   11616 </span>            : // Liao, 6/15/2009</a>
<a name="11617"><span class="lineNum">   11617 </span>            : //! A helper function to calculate n!</a>
<a name="11618"><span class="lineNum">   11618 </span>            : //! See also, Combinatorics::factorial(), which also checks for overflow.</a>
<a name="11619"><span class="lineNum">   11619 </span><span class="lineCov">          2 : static size_t myfactorial (size_t n)</span></a>
<a name="11620"><span class="lineNum">   11620 </span>            : {</a>
<a name="11621"><span class="lineNum">   11621 </span><span class="lineCov">          2 :   size_t result=1;</span></a>
<a name="11622"><span class="lineNum">   11622 </span><span class="lineCov">          7 :   for (size_t i=2; i&lt;=n; i++)</span></a>
<a name="11623"><span class="lineNum">   11623 </span><span class="lineCov">          5 :     result*=i;</span></a>
<a name="11624"><span class="lineNum">   11624 </span><span class="lineCov">          2 :   return result;</span></a>
<a name="11625"><span class="lineNum">   11625 </span>            : }</a>
<a name="11626"><span class="lineNum">   11626 </span>            : </a>
<a name="11627"><span class="lineNum">   11627 </span>            : #endif</a>
<a name="11628"><span class="lineNum">   11628 </span>            : </a>
<a name="11629"><span class="lineNum">   11629 </span>            : #ifndef USE_ROSE</a>
<a name="11630"><span class="lineNum">   11630 </span>            : </a>
<a name="11631"><span class="lineNum">   11631 </span>            : //! A helper function to return a permutation order for n elements based on a lexicographical order number.</a>
<a name="11632"><span class="lineNum">   11632 </span>            : //! See also, Combinatorics::permute(), which is faster but does not use strict lexicographic ordering.</a>
<a name="11633"><span class="lineNum">   11633 </span><span class="lineCov">          1 : std::vector&lt;size_t&gt; getPermutationOrder( size_t n, size_t lexicoOrder)</span></a>
<a name="11634"><span class="lineNum">   11634 </span>            : {</a>
<a name="11635"><span class="lineNum">   11635 </span><span class="lineCov">          1 :   size_t k = lexicoOrder;</span></a>
<a name="11636"><span class="lineNum">   11636 </span><span class="lineCov">          1 :   std::vector&lt;size_t&gt; s(n);</span></a>
<a name="11637"><span class="lineNum">   11637 </span>            :   // initialize the permutation vector</a>
<a name="11638"><span class="lineNum">   11638 </span><span class="lineCov">          5 :   for (size_t i=0; i&lt;n; i++)</span></a>
<a name="11639"><span class="lineNum">   11639 </span><span class="lineCov">          4 :     s[i]=i;</span></a>
<a name="11640"><span class="lineNum">   11640 </span>            : </a>
<a name="11641"><span class="lineNum">   11641 </span>            :   //compute (n- 1)!</a>
<a name="11642"><span class="lineNum">   11642 </span><span class="lineCov">          1 :   size_t factorial = myfactorial(n-1);</span></a>
<a name="11643"><span class="lineNum">   11643 </span>            :   //check if the number is not in the range of [0, n! - 1]</a>
<a name="11644"><span class="lineNum">   11644 </span><span class="lineCov">          1 :   if (k/n&gt;=factorial)</span></a>
<a name="11645"><span class="lineNum">   11645 </span>            :   {</a>
<a name="11646"><span class="lineNum">   11646 </span><span class="lineNoCov">          0 :     printf(&quot;Error: in getPermutationOrder(), lexicoOrder is larger than n!-1\n&quot;);</span></a>
<a name="11647"><span class="lineNum">   11647 </span><span class="lineNoCov">          0 :     ROSE_ABORT();</span></a>
<a name="11648"><span class="lineNum">   11648 </span>            :   }</a>
<a name="11649"><span class="lineNum">   11649 </span>            :   // Algorithm:</a>
<a name="11650"><span class="lineNum">   11650 </span>            :   //check each element of the array, excluding the right most one.</a>
<a name="11651"><span class="lineNum">   11651 </span>            :   //the goal is to find the right element for each s[j] from 0 to n-2</a>
<a name="11652"><span class="lineNum">   11652 </span>            :   // method: each position is associated a factorial number</a>
<a name="11653"><span class="lineNum">   11653 </span>            :   //    s[0] -&gt; (n-1)!</a>
<a name="11654"><span class="lineNum">   11654 </span>            :   //    s[1] -&gt; (n-2)! ...</a>
<a name="11655"><span class="lineNum">   11655 </span>            :   // the input number k is divided by the factorial at each position (6, 3, 2, 1 for size =4)</a>
<a name="11656"><span class="lineNum">   11656 </span>            :   //   so only big enough k can have non-zero value after division</a>
<a name="11657"><span class="lineNum">   11657 </span>            :   //   0 value means no change to the position for the current iteration</a>
<a name="11658"><span class="lineNum">   11658 </span>            :   // The non-zero value is further modular by the number of the right hand elements of the current element.</a>
<a name="11659"><span class="lineNum">   11659 </span>            :   //     (mode on 4, 3, 2 to get offset 1-2-3, 1-2, 1 from the current position 0, 1, 2)</a>
<a name="11660"><span class="lineNum">   11660 </span>            :   //  choose one of them to be moved to the current position,</a>
<a name="11661"><span class="lineNum">   11661 </span>            :   //  shift elements between the current and the moved element to the right direction for one position</a>
<a name="11662"><span class="lineNum">   11662 </span><span class="lineCov">          4 :   for (size_t j=0; j&lt;n-1; j++)</span></a>
<a name="11663"><span class="lineNum">   11663 </span>            :   {</a>
<a name="11664"><span class="lineNum">   11664 </span>            :     //calculates the next cell from the cells left</a>
<a name="11665"><span class="lineNum">   11665 </span>            :     //(the cells in the range [j, s.length - 1])</a>
<a name="11666"><span class="lineNum">   11666 </span><span class="lineCov">          3 :     int tempj = (k/factorial) % (n - j);</span></a>
<a name="11667"><span class="lineNum">   11667 </span>            :     //Temporarily saves the value of the cell needed</a>
<a name="11668"><span class="lineNum">   11668 </span>            :     // to add to the permutation this time</a>
<a name="11669"><span class="lineNum">   11669 </span><span class="lineCov">          3 :     int temps = s[j+tempj];</span></a>
<a name="11670"><span class="lineNum">   11670 </span>            :     //shift all elements to &quot;cover&quot; the &quot;missing&quot; cell</a>
<a name="11671"><span class="lineNum">   11671 </span>            :     //shift them to the right</a>
<a name="11672"><span class="lineNum">   11672 </span><span class="lineCov">          4 :     for (size_t i=j+tempj; i&gt;j; i--)</span></a>
<a name="11673"><span class="lineNum">   11673 </span>            :     {</a>
<a name="11674"><span class="lineNum">   11674 </span><span class="lineCov">          1 :       s[i] = s[i-1]; //shift the chain right</span></a>
<a name="11675"><span class="lineNum">   11675 </span>            :     }</a>
<a name="11676"><span class="lineNum">   11676 </span>            :     // put the chosen cell in the correct spot</a>
<a name="11677"><span class="lineNum">   11677 </span><span class="lineCov">          3 :     s[j]= temps;</span></a>
<a name="11678"><span class="lineNum">   11678 </span>            :     // updates the factorial</a>
<a name="11679"><span class="lineNum">   11679 </span><span class="lineCov">          3 :     factorial = factorial /(n-(j+1));</span></a>
<a name="11680"><span class="lineNum">   11680 </span>            :   }</a>
<a name="11681"><span class="lineNum">   11681 </span>            : #if 0</a>
<a name="11682"><span class="lineNum">   11682 </span>            :   for (size_t i = 0; i&lt;n; i++)</a>
<a name="11683"><span class="lineNum">   11683 </span>            :     cout&lt;&lt;&quot; &quot;&lt;&lt;s[i];</a>
<a name="11684"><span class="lineNum">   11684 </span>            :   cout&lt;&lt;endl;</a>
<a name="11685"><span class="lineNum">   11685 </span>            : #endif</a>
<a name="11686"><span class="lineNum">   11686 </span><span class="lineCov">          1 :   return s;</span></a>
<a name="11687"><span class="lineNum">   11687 </span>            : }</a>
<a name="11688"><span class="lineNum">   11688 </span>            : </a>
<a name="11689"><span class="lineNum">   11689 </span>            : //! Tile the n-level (starting from 1) of a perfectly nested loop nest using tiling size s</a>
<a name="11690"><span class="lineNum">   11690 </span>            : /* Translation</a>
<a name="11691"><span class="lineNum">   11691 </span>            :  Before:</a>
<a name="11692"><span class="lineNum">   11692 </span>            :   for (i = 0; i &lt; 100; i++)</a>
<a name="11693"><span class="lineNum">   11693 </span>            :     for (j = 0; j &lt; 100; j++)</a>
<a name="11694"><span class="lineNum">   11694 </span>            :       for (k = 0; k &lt; 100; k++)</a>
<a name="11695"><span class="lineNum">   11695 </span>            :         c[i][j]= c[i][j]+a[i][k]*b[k][j];</a>
<a name="11696"><span class="lineNum">   11696 </span>            : </a>
<a name="11697"><span class="lineNum">   11697 </span>            :   After tiling i loop nest's level 3 (k-loop) with size 5, it becomes</a>
<a name="11698"><span class="lineNum">   11698 </span>            : </a>
<a name="11699"><span class="lineNum">   11699 </span>            : // added a new controlling loop at the outer most level</a>
<a name="11700"><span class="lineNum">   11700 </span>            :   int _lt_var_k;</a>
<a name="11701"><span class="lineNum">   11701 </span>            :   for (_lt_var_k = 0; _lt_var_k &lt;= 99; _lt_var_k += 1 * 5) {</a>
<a name="11702"><span class="lineNum">   11702 </span>            :     for (i = 0; i &lt; 100; i++)</a>
<a name="11703"><span class="lineNum">   11703 </span>            :       for (j = 0; j &lt; 100; j++)</a>
<a name="11704"><span class="lineNum">   11704 </span>            :         // rewritten loop header , normalized also</a>
<a name="11705"><span class="lineNum">   11705 </span>            :         for (k = _lt_var_k; k &lt;= (99 &lt; (_lt_var_k + 5 - 1))?99 : (_lt_var_k + 5 - 1); k += 1) {</a>
<a name="11706"><span class="lineNum">   11706 </span>            :           c[i][j] = c[i][j] + a[i][k] * b[k][j];</a>
<a name="11707"><span class="lineNum">   11707 </span>            :         }</a>
<a name="11708"><span class="lineNum">   11708 </span>            :   }</a>
<a name="11709"><span class="lineNum">   11709 </span>            : // finally run constant folding</a>
<a name="11710"><span class="lineNum">   11710 </span>            : </a>
<a name="11711"><span class="lineNum">   11711 </span>            :  */</a>
<a name="11712"><span class="lineNum">   11712 </span><span class="lineCov">          1 : bool SageInterface::loopTiling(SgForStatement* loopNest, size_t targetLevel, size_t tileSize)</span></a>
<a name="11713"><span class="lineNum">   11713 </span>            : {</a>
<a name="11714"><span class="lineNum">   11714 </span><span class="lineCov">          1 :   ROSE_ASSERT(loopNest != NULL);</span></a>
<a name="11715"><span class="lineNum">   11715 </span><span class="lineCov">          1 :   ROSE_ASSERT(targetLevel &gt;0);</span></a>
<a name="11716"><span class="lineNum">   11716 </span>            :  // ROSE_ASSERT(tileSize&gt;0);// 1 is allowed</a>
<a name="11717"><span class="lineNum">   11717 </span>            :  // skip tiling if tiling size is 0 (no tiling), we allow 0 to get a reference value for the original code being tuned</a>
<a name="11718"><span class="lineNum">   11718 </span>            :  // 1 (no need to tile)</a>
<a name="11719"><span class="lineNum">   11719 </span><span class="lineCov">          1 :   if (tileSize&lt;=1)</span></a>
<a name="11720"><span class="lineNum">   11720 </span>            :     return true;</a>
<a name="11721"><span class="lineNum">   11721 </span>            :   // Locate the target loop at level n</a>
<a name="11722"><span class="lineNum">   11722 </span><span class="lineCov">          2 :   std::vector&lt;SgForStatement* &gt; loops= SageInterface::querySubTree&lt;SgForStatement&gt;(loopNest,V_SgForStatement);</span></a>
<a name="11723"><span class="lineNum">   11723 </span><span class="lineCov">          1 :   ROSE_ASSERT(loops.size()&gt;=targetLevel);</span></a>
<a name="11724"><span class="lineNum">   11724 </span><span class="lineCov">          1 :   SgForStatement* target_loop = loops[targetLevel -1]; // adjust to numbering starting from 0</span></a>
<a name="11725"><span class="lineNum">   11725 </span>            : </a>
<a name="11726"><span class="lineNum">   11726 </span>            :   // DQ (3/25/2017): Fixed Clang warning: warning: if statement has empty body [-Wempty-body]</a>
<a name="11727"><span class="lineNum">   11727 </span>            :   // normalize the target loop first</a>
<a name="11728"><span class="lineNum">   11728 </span>            :   // if (!forLoopNormalization(target_loop));</a>
<a name="11729"><span class="lineNum">   11729 </span><span class="lineCov">          1 :   if (!forLoopNormalization(target_loop))</span></a>
<a name="11730"><span class="lineNum">   11730 </span>            :   {// the return value is not reliable</a>
<a name="11731"><span class="lineNum">   11731 </span>            : //    cerr&lt;&lt;&quot;Error in SageInterface::loopTiling(): target loop cannot be normalized.&quot;&lt;&lt;endl;</a>
<a name="11732"><span class="lineNum">   11732 </span>            : //    dumpInfo(target_loop);</a>
<a name="11733"><span class="lineNum">   11733 </span>            : //    return false;</a>
<a name="11734"><span class="lineNum">   11734 </span>            :   }</a>
<a name="11735"><span class="lineNum">   11735 </span>            :    // grab the target loop's essential header information</a>
<a name="11736"><span class="lineNum">   11736 </span><span class="lineCov">          1 :    SgInitializedName* ivar = NULL;</span></a>
<a name="11737"><span class="lineNum">   11737 </span><span class="lineCov">          1 :    SgExpression* lb = NULL;</span></a>
<a name="11738"><span class="lineNum">   11738 </span><span class="lineCov">          1 :    SgExpression* ub = NULL;</span></a>
<a name="11739"><span class="lineNum">   11739 </span><span class="lineCov">          1 :    SgExpression* step = NULL;</span></a>
<a name="11740"><span class="lineNum">   11740 </span><span class="lineCov">          1 :    if (!isCanonicalForLoop(target_loop, &amp;ivar, &amp;lb, &amp;ub, &amp;step, NULL))</span></a>
<a name="11741"><span class="lineNum">   11741 </span>            :    {</a>
<a name="11742"><span class="lineNum">   11742 </span><span class="lineNoCov">          0 :      cerr&lt;&lt;&quot;Error in SageInterface::loopTiling(): target loop is not canonical.&quot;&lt;&lt;endl;</span></a>
<a name="11743"><span class="lineNum">   11743 </span><span class="lineNoCov">          0 :      dumpInfo(target_loop);</span></a>
<a name="11744"><span class="lineNum">   11744 </span><span class="lineNoCov">          0 :      return false;</span></a>
<a name="11745"><span class="lineNum">   11745 </span>            :    }</a>
<a name="11746"><span class="lineNum">   11746 </span><span class="lineCov">          1 :    ROSE_ASSERT(ivar&amp;&amp; lb &amp;&amp; ub &amp;&amp; step);</span></a>
<a name="11747"><span class="lineNum">   11747 </span>            : </a>
<a name="11748"><span class="lineNum">   11748 </span>            :   // Add a controlling loop around the top loop nest</a>
<a name="11749"><span class="lineNum">   11749 </span>            :   // Ensure the parent can hold more than one children</a>
<a name="11750"><span class="lineNum">   11750 </span><span class="lineCov">          1 :   SgLocatedNode* parent = NULL; //SageInterface::ensureBasicBlockAsParent(loopNest)</span></a>
<a name="11751"><span class="lineNum">   11751 </span><span class="lineCov">          1 :   if (isBodyStatement(loopNest)) // if it is a single body statement (Already a for statement, not a basic block)</span></a>
<a name="11752"><span class="lineNum">   11752 </span><span class="lineNoCov">          0 :    parent = makeSingleStatementBodyToBlock (loopNest);</span></a>
<a name="11753"><span class="lineNum">   11753 </span>            :   else</a>
<a name="11754"><span class="lineNum">   11754 </span><span class="lineCov">          1 :     parent = isSgLocatedNode(loopNest -&gt;get_parent());</span></a>
<a name="11755"><span class="lineNum">   11755 </span>            : </a>
<a name="11756"><span class="lineNum">   11756 </span><span class="lineCov">          1 :   ROSE_ASSERT(parent!= NULL);</span></a>
<a name="11757"><span class="lineNum">   11757 </span>            :      // Now we can prepend a controlling loop index variable: __lt_var_originalIndex</a>
<a name="11758"><span class="lineNum">   11758 </span><span class="lineCov">          2 :   string ivar2_name = &quot;_lt_var_&quot;+ivar-&gt;get_name().getString();</span></a>
<a name="11759"><span class="lineNum">   11759 </span><span class="lineCov">          1 :   SgScopeStatement* scope = loopNest-&gt;get_scope();</span></a>
<a name="11760"><span class="lineNum">   11760 </span><span class="lineCov">          1 :   SgVariableDeclaration* loop_index_decl = buildVariableDeclaration(ivar2_name, buildIntType(),NULL, scope);</span></a>
<a name="11761"><span class="lineNum">   11761 </span>            :   //insertStatementBefore(loopNest, loop_index_decl);</a>
<a name="11762"><span class="lineNum">   11762 </span><span class="lineCov">          1 :   SgNode *loopNestParent = loopNest-&gt;get_parent();</span></a>
<a name="11763"><span class="lineNum">   11763 </span><span class="lineCov">          1 :   if (loopNestParent-&gt;get_parent()) loopNestParent = loopNestParent-&gt;get_parent();</span></a>
<a name="11764"><span class="lineNum">   11764 </span><span class="lineCov">          1 :   bool is_simd = false;</span></a>
<a name="11765"><span class="lineNum">   11765 </span><span class="lineCov">          2 :   std::string inc_name = &quot;_lt_var_inc&quot;;</span></a>
<a name="11766"><span class="lineNum">   11766 </span><span class="lineCov">          1 :   SgVarRefExp *inc_var_ref = NULL;</span></a>
<a name="11767"><span class="lineNum">   11767 </span>            :   </a>
<a name="11768"><span class="lineNum">   11768 </span>            :   // Check if the parent is a SIMD statement</a>
<a name="11769"><span class="lineNum">   11769 </span><span class="lineCov">          1 :   if (loopNest-&gt;get_parent()-&gt;variantT() == V_SgUpirLoopParallelStatement) {</span></a>
<a name="11770"><span class="lineNum">   11770 </span><span class="lineNoCov">          0 :     if (loopNestParent-&gt;variantT() == V_SgOmpTileStatement || loopNestParent-&gt;variantT() == V_SgOmpUnrollStatement) {</span></a>
<a name="11771"><span class="lineNum">   11771 </span>            :         // If we also have an unroll or tile statement, we should create a variable to hold the loop index</a>
<a name="11772"><span class="lineNum">   11772 </span><span class="lineNoCov">          0 :         is_simd = true;</span></a>
<a name="11773"><span class="lineNum">   11773 </span><span class="lineNoCov">          0 :         SgAssignInitializer *init = buildAssignInitializer(buildIntVal(1));</span></a>
<a name="11774"><span class="lineNum">   11774 </span><span class="lineNoCov">          0 :         SgVariableDeclaration *var_inc_decl = buildVariableDeclaration(inc_name, buildIntType(), init, scope);</span></a>
<a name="11775"><span class="lineNum">   11775 </span><span class="lineNoCov">          0 :         inc_var_ref = buildVarRefExp(inc_name, scope);</span></a>
<a name="11776"><span class="lineNum">   11776 </span>            :         </a>
<a name="11777"><span class="lineNum">   11777 </span><span class="lineNoCov">          0 :         insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNestParent), var_inc_decl);</span></a>
<a name="11778"><span class="lineNum">   11778 </span><span class="lineNoCov">          0 :         insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNestParent),loop_index_decl);</span></a>
<a name="11779"><span class="lineNum">   11779 </span>            :     } else {</a>
<a name="11780"><span class="lineNum">   11780 </span><span class="lineNoCov">          0 :         insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNest-&gt;get_parent()),loop_index_decl);</span></a>
<a name="11781"><span class="lineNum">   11781 </span>            :     }</a>
<a name="11782"><span class="lineNum">   11782 </span>            :     </a>
<a name="11783"><span class="lineNum">   11783 </span>            :   // Otherwise, setup normally</a>
<a name="11784"><span class="lineNum">   11784 </span><span class="lineCov">          1 :   } else if (loopNestParent-&gt;variantT() == V_SgOmpTileStatement || loopNestParent-&gt;variantT() == V_SgOmpUnrollStatement) {</span></a>
<a name="11785"><span class="lineNum">   11785 </span><span class="lineNoCov">          0 :     insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNestParent),loop_index_decl);</span></a>
<a name="11786"><span class="lineNum">   11786 </span>            :   } else {</a>
<a name="11787"><span class="lineNum">   11787 </span><span class="lineCov">          1 :     insertStatementBefore(loopNest, loop_index_decl);</span></a>
<a name="11788"><span class="lineNum">   11788 </span>            :   }</a>
<a name="11789"><span class="lineNum">   11789 </span>            :    // init statement of the loop header, copy the lower bound</a>
<a name="11790"><span class="lineNum">   11790 </span><span class="lineCov">          1 :    SgStatement* init_stmt = buildAssignStatement(buildVarRefExp(ivar2_name,scope), copyExpression(lb));</span></a>
<a name="11791"><span class="lineNum">   11791 </span>            :    //two cases &lt;= or &gt;= for a normalized loop</a>
<a name="11792"><span class="lineNum">   11792 </span><span class="lineCov">          1 :    SgExprStatement* cond_stmt = NULL;</span></a>
<a name="11793"><span class="lineNum">   11793 </span><span class="lineCov">          1 :    SgExpression* orig_test = target_loop-&gt;get_test_expr();</span></a>
<a name="11794"><span class="lineNum">   11794 </span><span class="lineCov">          1 :    if (isSgBinaryOp(orig_test))</span></a>
<a name="11795"><span class="lineNum">   11795 </span>            :    {</a>
<a name="11796"><span class="lineNum">   11796 </span><span class="lineCov">          1 :      if (isSgLessOrEqualOp(orig_test))</span></a>
<a name="11797"><span class="lineNum">   11797 </span><span class="lineCov">          1 :        cond_stmt = buildExprStatement(buildLessOrEqualOp(buildVarRefExp(ivar2_name,scope),copyExpression(ub)));</span></a>
<a name="11798"><span class="lineNum">   11798 </span><span class="lineNoCov">          0 :      else if (isSgGreaterOrEqualOp(orig_test))</span></a>
<a name="11799"><span class="lineNum">   11799 </span>            :      {</a>
<a name="11800"><span class="lineNum">   11800 </span><span class="lineNoCov">          0 :        cond_stmt = buildExprStatement(buildGreaterOrEqualOp(buildVarRefExp(ivar2_name,scope),copyExpression(ub)));</span></a>
<a name="11801"><span class="lineNum">   11801 </span>            :        }</a>
<a name="11802"><span class="lineNum">   11802 </span>            :      else</a>
<a name="11803"><span class="lineNum">   11803 </span>            :      {</a>
<a name="11804"><span class="lineNum">   11804 </span><span class="lineNoCov">          0 :        cerr&lt;&lt;&quot;Error: illegal condition operator for a canonical loop&quot;&lt;&lt;endl;</span></a>
<a name="11805"><span class="lineNum">   11805 </span><span class="lineNoCov">          0 :        dumpInfo(orig_test);</span></a>
<a name="11806"><span class="lineNum">   11806 </span><span class="lineNoCov">          0 :        ROSE_ABORT();</span></a>
<a name="11807"><span class="lineNum">   11807 </span>            :      }</a>
<a name="11808"><span class="lineNum">   11808 </span>            :    }</a>
<a name="11809"><span class="lineNum">   11809 </span>            :    else</a>
<a name="11810"><span class="lineNum">   11810 </span>            :    {</a>
<a name="11811"><span class="lineNum">   11811 </span><span class="lineNoCov">          0 :      cerr&lt;&lt;&quot;Error: illegal condition expression for a canonical loop&quot;&lt;&lt;endl;</span></a>
<a name="11812"><span class="lineNum">   11812 </span><span class="lineNoCov">          0 :      dumpInfo(orig_test);</span></a>
<a name="11813"><span class="lineNum">   11813 </span><span class="lineNoCov">          0 :      ROSE_ABORT();</span></a>
<a name="11814"><span class="lineNum">   11814 </span>            :    }</a>
<a name="11815"><span class="lineNum">   11815 </span><span class="lineCov">          1 :    ROSE_ASSERT(cond_stmt != NULL);</span></a>
<a name="11816"><span class="lineNum">   11816 </span>            : </a>
<a name="11817"><span class="lineNum">   11817 </span>            :    // build loop incremental  I</a>
<a name="11818"><span class="lineNum">   11818 </span>            :    // expression var+=up*tilesize or var-=upper * tilesize</a>
<a name="11819"><span class="lineNum">   11819 </span><span class="lineCov">          1 :    SgExpression* incr_exp = NULL;</span></a>
<a name="11820"><span class="lineNum">   11820 </span><span class="lineCov">          1 :    SgExpression* orig_incr_exp = target_loop-&gt;get_increment();</span></a>
<a name="11821"><span class="lineNum">   11821 </span>            :    </a>
<a name="11822"><span class="lineNum">   11822 </span><span class="lineCov">          1 :    if( isSgPlusAssignOp(orig_incr_exp))</span></a>
<a name="11823"><span class="lineNum">   11823 </span>            :    {</a>
<a name="11824"><span class="lineNum">   11824 </span><span class="lineCov">          1 :      if (is_simd) {</span></a>
<a name="11825"><span class="lineNum">   11825 </span><span class="lineNoCov">          0 :         incr_exp = buildPlusAssignOp(buildVarRefExp(ivar2_name,scope), buildMultiplyOp(inc_var_ref, buildIntVal(tileSize)));</span></a>
<a name="11826"><span class="lineNum">   11826 </span>            :      } else {</a>
<a name="11827"><span class="lineNum">   11827 </span><span class="lineCov">          1 :         incr_exp = buildPlusAssignOp(buildVarRefExp(ivar2_name,scope), buildMultiplyOp(copyExpression(step), buildIntVal(tileSize)));</span></a>
<a name="11828"><span class="lineNum">   11828 </span>            :      }</a>
<a name="11829"><span class="lineNum">   11829 </span>            :    }</a>
<a name="11830"><span class="lineNum">   11830 </span><span class="lineNoCov">          0 :     else if (isSgMinusAssignOp(orig_incr_exp))</span></a>
<a name="11831"><span class="lineNum">   11831 </span>            :     {</a>
<a name="11832"><span class="lineNum">   11832 </span><span class="lineNoCov">          0 :       incr_exp = buildMinusAssignOp(buildVarRefExp(ivar2_name,scope), buildMultiplyOp(copyExpression(step), buildIntVal(tileSize)));</span></a>
<a name="11833"><span class="lineNum">   11833 </span>            :     }</a>
<a name="11834"><span class="lineNum">   11834 </span>            :     else</a>
<a name="11835"><span class="lineNum">   11835 </span>            :     {</a>
<a name="11836"><span class="lineNum">   11836 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;&quot;Error: illegal increment expression for a canonical loop&quot;&lt;&lt;endl;</span></a>
<a name="11837"><span class="lineNum">   11837 </span><span class="lineNoCov">          0 :       dumpInfo(orig_incr_exp);</span></a>
<a name="11838"><span class="lineNum">   11838 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="11839"><span class="lineNum">   11839 </span>            :     }</a>
<a name="11840"><span class="lineNum">   11840 </span><span class="lineCov">          1 :     SgForStatement* control_loop = buildForStatement(init_stmt, cond_stmt,incr_exp, buildBasicBlock());</span></a>
<a name="11841"><span class="lineNum">   11841 </span>            :   //insertStatementBefore(loopNest, control_loop);</a>
<a name="11842"><span class="lineNum">   11842 </span>            :   /*if (loopNest-&gt;get_parent()-&gt;variantT() == V_SgUpirLoopParallelStatement) {</a>
<a name="11843"><span class="lineNum">   11843 </span>            :       insertStatementAfter(static_cast&lt;SgStatement *&gt;(loopNest-&gt;get_parent()),control_loop);</a>
<a name="11844"><span class="lineNum">   11844 </span>            :   } else {</a>
<a name="11845"><span class="lineNum">   11845 </span>            :       insertStatementAfter(loopNest,control_loop);</a>
<a name="11846"><span class="lineNum">   11846 </span>            :   }*/</a>
<a name="11847"><span class="lineNum">   11847 </span><span class="lineCov">          1 :   if (loopNest-&gt;get_parent()-&gt;variantT() == V_SgUpirLoopParallelStatement) {</span></a>
<a name="11848"><span class="lineNum">   11848 </span><span class="lineNoCov">          0 :     if (loopNestParent-&gt;variantT() == V_SgOmpTileStatement || loopNestParent-&gt;variantT() == V_SgOmpUnrollStatement) {</span></a>
<a name="11849"><span class="lineNum">   11849 </span><span class="lineNoCov">          0 :         insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNestParent),control_loop);</span></a>
<a name="11850"><span class="lineNum">   11850 </span>            :     } else {</a>
<a name="11851"><span class="lineNum">   11851 </span><span class="lineNoCov">          0 :         insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNest-&gt;get_parent()),control_loop);</span></a>
<a name="11852"><span class="lineNum">   11852 </span>            :     }</a>
<a name="11853"><span class="lineNum">   11853 </span><span class="lineCov">          1 :   } else if (loopNestParent-&gt;variantT() == V_SgOmpTileStatement || loopNestParent-&gt;variantT() == V_SgOmpUnrollStatement) {</span></a>
<a name="11854"><span class="lineNum">   11854 </span><span class="lineNoCov">          0 :     insertStatementBefore(static_cast&lt;SgStatement *&gt;(loopNestParent),control_loop);</span></a>
<a name="11855"><span class="lineNum">   11855 </span>            :   } else {</a>
<a name="11856"><span class="lineNum">   11856 </span><span class="lineCov">          1 :     insertStatementBefore(loopNest, control_loop);</span></a>
<a name="11857"><span class="lineNum">   11857 </span>            :   }</a>
<a name="11858"><span class="lineNum">   11858 </span>            :   </a>
<a name="11859"><span class="lineNum">   11859 </span>            :   // move loopNest into the control loop</a>
<a name="11860"><span class="lineNum">   11860 </span><span class="lineCov">          1 :   if (loopNest-&gt;get_parent()-&gt;variantT() != V_SgUpirLoopParallelStatement)</span></a>
<a name="11861"><span class="lineNum">   11861 </span><span class="lineCov">          1 :     removeStatement(loopNest);</span></a>
<a name="11862"><span class="lineNum">   11862 </span><span class="lineCov">          1 :   appendStatement(loopNest,isSgBasicBlock(control_loop-&gt;get_loop_body()));</span></a>
<a name="11863"><span class="lineNum">   11863 </span>            : </a>
<a name="11864"><span class="lineNum">   11864 </span>            :   // rewrite the lower (i=lb), upper bounds (i&lt;=/&gt;= ub) of the target loop</a>
<a name="11865"><span class="lineNum">   11865 </span><span class="lineCov">          1 :   SgAssignOp* assign_op  = isSgAssignOp(lb-&gt;get_parent());</span></a>
<a name="11866"><span class="lineNum">   11866 </span><span class="lineCov">          1 :   ROSE_ASSERT(assign_op);</span></a>
<a name="11867"><span class="lineNum">   11867 </span><span class="lineCov">          1 :   assign_op-&gt;set_rhs_operand(buildVarRefExp(ivar2_name,scope));</span></a>
<a name="11868"><span class="lineNum">   11868 </span>            :     // ub&lt; var_i+tileSize-1? ub:var_i+tileSize-1</a>
<a name="11869"><span class="lineNum">   11869 </span><span class="lineCov">          1 :   SgBinaryOp* bin_op = isSgBinaryOp(ub-&gt;get_parent());</span></a>
<a name="11870"><span class="lineNum">   11870 </span><span class="lineCov">          1 :   ROSE_ASSERT(bin_op);</span></a>
<a name="11871"><span class="lineNum">   11871 </span><span class="lineCov">          1 :   SgExpression* ub2;</span></a>
<a name="11872"><span class="lineNum">   11872 </span><span class="lineCov">          1 :   if (is_simd) {</span></a>
<a name="11873"><span class="lineNum">   11873 </span><span class="lineNoCov">          0 :     SgMultiplyOp *mul = buildMultiplyOp(inc_var_ref, buildIntVal(tileSize));</span></a>
<a name="11874"><span class="lineNum">   11874 </span><span class="lineNoCov">          0 :     ub2 = buildSubtractOp(buildAddOp(buildVarRefExp(ivar2_name,scope), mul), buildIntVal(1));</span></a>
<a name="11875"><span class="lineNum">   11875 </span>            :   } else {</a>
<a name="11876"><span class="lineNum">   11876 </span><span class="lineCov">          1 :     ub2 = buildSubtractOp(buildAddOp(buildVarRefExp(ivar2_name,scope), buildIntVal(tileSize)), buildIntVal(1));</span></a>
<a name="11877"><span class="lineNum">   11877 </span>            :   }</a>
<a name="11878"><span class="lineNum">   11878 </span><span class="lineCov">          1 :   SgExpression* test_exp = buildLessThanOp(copyExpression(ub),ub2);</span></a>
<a name="11879"><span class="lineNum">   11879 </span><span class="lineCov">          1 :   test_exp-&gt;set_need_paren(true);</span></a>
<a name="11880"><span class="lineNum">   11880 </span><span class="lineCov">          1 :   ub-&gt;set_need_paren(true);</span></a>
<a name="11881"><span class="lineNum">   11881 </span><span class="lineCov">          1 :   ub2-&gt;set_need_paren(true);</span></a>
<a name="11882"><span class="lineNum">   11882 </span><span class="lineCov">          1 :   SgConditionalExp * triple_exp = buildConditionalExp(test_exp,copyExpression(ub), copyExpression(ub2));</span></a>
<a name="11883"><span class="lineNum">   11883 </span><span class="lineCov">          1 :   bin_op-&gt;set_rhs_operand(triple_exp);</span></a>
<a name="11884"><span class="lineNum">   11884 </span>            :   // constant folding</a>
<a name="11885"><span class="lineNum">   11885 </span>            :   // folding entire loop may decrease the accuracy of floating point calculation</a>
<a name="11886"><span class="lineNum">   11886 </span>            :   // we fold loop control expressions only</a>
<a name="11887"><span class="lineNum">   11887 </span>            :   //constantFolding(control_loop-&gt;get_scope());</a>
<a name="11888"><span class="lineNum">   11888 </span><span class="lineCov">          1 :   constantFolding(control_loop-&gt;get_test());</span></a>
<a name="11889"><span class="lineNum">   11889 </span><span class="lineCov">          1 :   constantFolding(control_loop-&gt;get_increment());</span></a>
<a name="11890"><span class="lineNum">   11890 </span><span class="lineCov">          1 :   return true;</span></a>
<a name="11891"><span class="lineNum">   11891 </span>            : }</a>
<a name="11892"><span class="lineNum">   11892 </span>            : </a>
<a name="11893"><span class="lineNum">   11893 </span>            : //! Interchange/Permutate a n-level perfectly-nested loop rooted at 'loop' using a lexicographical order number within [0,depth!)</a>
<a name="11894"><span class="lineNum">   11894 </span><span class="lineCov">          1 : bool SageInterface::loopInterchange(SgForStatement* loop, size_t depth, size_t lexicoOrder)</span></a>
<a name="11895"><span class="lineNum">   11895 </span>            : {</a>
<a name="11896"><span class="lineNum">   11896 </span><span class="lineCov">          1 :   if (lexicoOrder == 0) // allow 0 to mean no interchange at all</span></a>
<a name="11897"><span class="lineNum">   11897 </span>            :     return true;</a>
<a name="11898"><span class="lineNum">   11898 </span>            :   // parameter verification</a>
<a name="11899"><span class="lineNum">   11899 </span><span class="lineCov">          1 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="11900"><span class="lineNum">   11900 </span>            :   //must have at least two levels</a>
<a name="11901"><span class="lineNum">   11901 </span><span class="lineCov">          1 :   ROSE_ASSERT (depth &gt;1);</span></a>
<a name="11902"><span class="lineNum">   11902 </span><span class="lineCov">          2 :   ROSE_ASSERT(lexicoOrder&lt;myfactorial(depth));</span></a>
<a name="11903"><span class="lineNum">   11903 </span>            :   //TODO need to verify the input loop has n perfectly-nested children loops inside</a>
<a name="11904"><span class="lineNum">   11904 </span>            :   // save the loop nest's headers: init, test, and increment</a>
<a name="11905"><span class="lineNum">   11905 </span><span class="lineCov">          2 :   std::vector&lt;SgForStatement* &gt; loopNest = SageInterface::querySubTree&lt;SgForStatement&gt;(loop,V_SgForStatement);</span></a>
<a name="11906"><span class="lineNum">   11906 </span><span class="lineCov">          1 :   ROSE_ASSERT(loopNest.size()&gt;=depth);</span></a>
<a name="11907"><span class="lineNum">   11907 </span><span class="lineCov">          2 :   std::vector&lt;std::vector&lt;SgNode*&gt; &gt; loopHeads;</span></a>
<a name="11908"><span class="lineNum">   11908 </span><span class="lineCov">          5 :   for (std::vector&lt;SgForStatement* &gt; ::iterator i = loopNest.begin(); i!= loopNest.end(); i++)</span></a>
<a name="11909"><span class="lineNum">   11909 </span>            :   {</a>
<a name="11910"><span class="lineNum">   11910 </span><span class="lineCov">          4 :     SgForStatement* cur_loop = *i;</span></a>
<a name="11911"><span class="lineNum">   11911 </span><span class="lineCov">          8 :     std::vector&lt;SgNode*&gt; head;</span></a>
<a name="11912"><span class="lineNum">   11912 </span><span class="lineCov">          4 :     head.push_back(cur_loop-&gt;get_for_init_stmt());</span></a>
<a name="11913"><span class="lineNum">   11913 </span><span class="lineCov">          4 :     head.push_back(cur_loop-&gt;get_test());</span></a>
<a name="11914"><span class="lineNum">   11914 </span><span class="lineCov">          4 :     head.push_back(cur_loop-&gt;get_increment());</span></a>
<a name="11915"><span class="lineNum">   11915 </span><span class="lineCov">          4 :     loopHeads.push_back(head);</span></a>
<a name="11916"><span class="lineNum">   11916 </span>            :   }</a>
<a name="11917"><span class="lineNum">   11917 </span>            : </a>
<a name="11918"><span class="lineNum">   11918 </span>            :   // convert the lexicographical number to a permutation order array permutation[depth]</a>
<a name="11919"><span class="lineNum">   11919 </span><span class="lineCov">          2 :   std::vector&lt;size_t&gt; changedOrder = getPermutationOrder (depth, lexicoOrder);</span></a>
<a name="11920"><span class="lineNum">   11920 </span>            :   // rewrite the loop nest to reflect the permutation</a>
<a name="11921"><span class="lineNum">   11921 </span>            :   // set the header to the new header based on the permutation array</a>
<a name="11922"><span class="lineNum">   11922 </span><span class="lineCov">          5 :   for (size_t i=0; i&lt;depth; i++)</span></a>
<a name="11923"><span class="lineNum">   11923 </span>            :   {</a>
<a name="11924"><span class="lineNum">   11924 </span>            :     // only rewrite if necessary</a>
<a name="11925"><span class="lineNum">   11925 </span><span class="lineCov">          4 :     if (i != changedOrder[i])</span></a>
<a name="11926"><span class="lineNum">   11926 </span>            :     {</a>
<a name="11927"><span class="lineNum">   11927 </span><span class="lineCov">          2 :       SgForStatement* cur_loop = loopNest[i];</span></a>
<a name="11928"><span class="lineNum">   11928 </span><span class="lineCov">          4 :       std::vector&lt;SgNode*&gt; newhead = loopHeads[changedOrder[i]];</span></a>
<a name="11929"><span class="lineNum">   11929 </span>            : </a>
<a name="11930"><span class="lineNum">   11930 </span><span class="lineCov">          2 :       SgForInitStatement* init = isSgForInitStatement(newhead[0]);</span></a>
<a name="11931"><span class="lineNum">   11931 </span>            :       //ROSE_ASSERT(init != NULL) // could be NULL?</a>
<a name="11932"><span class="lineNum">   11932 </span><span class="lineCov">          2 :       ROSE_ASSERT(init != cur_loop-&gt;get_for_init_stmt());</span></a>
<a name="11933"><span class="lineNum">   11933 </span><span class="lineCov">          2 :       cur_loop-&gt;set_for_init_stmt(init);</span></a>
<a name="11934"><span class="lineNum">   11934 </span><span class="lineCov">          2 :       if (init)</span></a>
<a name="11935"><span class="lineNum">   11935 </span>            :       {</a>
<a name="11936"><span class="lineNum">   11936 </span><span class="lineCov">          2 :         init-&gt;set_parent(cur_loop);</span></a>
<a name="11937"><span class="lineNum">   11937 </span><span class="lineCov">          2 :         setSourcePositionForTransformation(init);</span></a>
<a name="11938"><span class="lineNum">   11938 </span>            :       }</a>
<a name="11939"><span class="lineNum">   11939 </span>            : </a>
<a name="11940"><span class="lineNum">   11940 </span><span class="lineCov">          2 :       SgStatement* test = isSgStatement(newhead[1]);</span></a>
<a name="11941"><span class="lineNum">   11941 </span><span class="lineCov">          2 :       cur_loop-&gt;set_test(test);</span></a>
<a name="11942"><span class="lineNum">   11942 </span><span class="lineCov">          2 :       if (test)</span></a>
<a name="11943"><span class="lineNum">   11943 </span>            :       {</a>
<a name="11944"><span class="lineNum">   11944 </span><span class="lineCov">          2 :         test-&gt;set_parent(cur_loop);</span></a>
<a name="11945"><span class="lineNum">   11945 </span><span class="lineCov">          2 :         setSourcePositionForTransformation(test);</span></a>
<a name="11946"><span class="lineNum">   11946 </span>            :       }</a>
<a name="11947"><span class="lineNum">   11947 </span>            : </a>
<a name="11948"><span class="lineNum">   11948 </span><span class="lineCov">          2 :       SgExpression* incr = isSgExpression(newhead[2]);</span></a>
<a name="11949"><span class="lineNum">   11949 </span><span class="lineCov">          2 :       cur_loop-&gt;set_increment(incr);</span></a>
<a name="11950"><span class="lineNum">   11950 </span><span class="lineCov">          2 :       if (incr)</span></a>
<a name="11951"><span class="lineNum">   11951 </span>            :       {</a>
<a name="11952"><span class="lineNum">   11952 </span><span class="lineCov">          2 :         incr-&gt;set_parent(cur_loop);</span></a>
<a name="11953"><span class="lineNum">   11953 </span><span class="lineCov">          2 :         setSourcePositionForTransformation(incr);</span></a>
<a name="11954"><span class="lineNum">   11954 </span>            :       }</a>
<a name="11955"><span class="lineNum">   11955 </span>            :     }</a>
<a name="11956"><span class="lineNum">   11956 </span>            :   }</a>
<a name="11957"><span class="lineNum">   11957 </span><span class="lineCov">          1 :   return true;</span></a>
<a name="11958"><span class="lineNum">   11958 </span>            : }</a>
<a name="11959"><span class="lineNum">   11959 </span>            : </a>
<a name="11960"><span class="lineNum">   11960 </span>            : //!Return the loop index variable for a C/C++ for or Fortran Do loop</a>
<a name="11961"><span class="lineNum">   11961 </span><span class="lineNoCov">          0 : SgInitializedName* SageInterface::getLoopIndexVariable(SgNode* loop)</span></a>
<a name="11962"><span class="lineNum">   11962 </span>            : {</a>
<a name="11963"><span class="lineNum">   11963 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="11964"><span class="lineNum">   11964 </span><span class="lineNoCov">          0 :   SgInitializedName* ivarname=NULL;</span></a>
<a name="11965"><span class="lineNum">   11965 </span>            : </a>
<a name="11966"><span class="lineNum">   11966 </span>            :   // Fortran case ------------------</a>
<a name="11967"><span class="lineNum">   11967 </span><span class="lineNoCov">          0 :   if (SgFortranDo * do_loop = isSgFortranDo(loop))</span></a>
<a name="11968"><span class="lineNum">   11968 </span>            :   {</a>
<a name="11969"><span class="lineNum">   11969 </span><span class="lineNoCov">          0 :     SgAssignOp* assign_op = isSgAssignOp (do_loop-&gt;get_initialization());</span></a>
<a name="11970"><span class="lineNum">   11970 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (assign_op != NULL);</span></a>
<a name="11971"><span class="lineNum">   11971 </span><span class="lineNoCov">          0 :     SgVarRefExp* var = isSgVarRefExp(assign_op-&gt;get_lhs_operand());</span></a>
<a name="11972"><span class="lineNum">   11972 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (var != NULL);</span></a>
<a name="11973"><span class="lineNum">   11973 </span><span class="lineNoCov">          0 :     ivarname = var-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="11974"><span class="lineNum">   11974 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (ivarname != NULL);</span></a>
<a name="11975"><span class="lineNum">   11975 </span><span class="lineNoCov">          0 :     return ivarname;</span></a>
<a name="11976"><span class="lineNum">   11976 </span>            :   }</a>
<a name="11977"><span class="lineNum">   11977 </span>            :   // C/C++ case ------------------------------</a>
<a name="11978"><span class="lineNum">   11978 </span><span class="lineNoCov">          0 :   SgForStatement* fs = isSgForStatement(loop);</span></a>
<a name="11979"><span class="lineNum">   11979 </span><span class="lineNoCov">          0 :   if (fs == NULL)</span></a>
<a name="11980"><span class="lineNum">   11980 </span>            :   {</a>
<a name="11981"><span class="lineNum">   11981 </span>            :     return NULL;</a>
<a name="11982"><span class="lineNum">   11982 </span>            :   }</a>
<a name="11983"><span class="lineNum">   11983 </span>            :   // we only handle C/C++ for loops and Fortran Do loops.</a>
<a name="11984"><span class="lineNum">   11984 </span>            :   // Any other kinds of loops (while, do-while,etc.) are skipped and return NULL;</a>
<a name="11985"><span class="lineNum">   11985 </span>            :   // ROSE_ASSERT (fs != NULL);</a>
<a name="11986"><span class="lineNum">   11986 </span>            : </a>
<a name="11987"><span class="lineNum">   11987 </span>            :   //Check initialization statement is something like i=xx;</a>
<a name="11988"><span class="lineNum">   11988 </span><span class="lineNoCov">          0 :   SgStatementPtrList &amp; init = fs-&gt;get_init_stmt();</span></a>
<a name="11989"><span class="lineNum">   11989 </span><span class="lineNoCov">          0 :   if (init.size() !=1)</span></a>
<a name="11990"><span class="lineNum">   11990 </span>            :   {</a>
<a name="11991"><span class="lineNum">   11991 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;SageInterface::getLoopIndexVariable(), no or more than one initialization statements are encountered. Not supported yet &quot;&lt;&lt;endl;</span></a>
<a name="11992"><span class="lineNum">   11992 </span>            :     //ROSE_ASSERT(false);</a>
<a name="11993"><span class="lineNum">   11993 </span><span class="lineNoCov">          0 :     return NULL;</span></a>
<a name="11994"><span class="lineNum">   11994 </span>            :   }</a>
<a name="11995"><span class="lineNum">   11995 </span><span class="lineNoCov">          0 :   SgStatement* init1 = init.front();</span></a>
<a name="11996"><span class="lineNum">   11996 </span><span class="lineNoCov">          0 :   SgExpression* ivarast=NULL;</span></a>
<a name="11997"><span class="lineNum">   11997 </span>            : </a>
<a name="11998"><span class="lineNum">   11998 </span>            :   // DQ (3/20/2016): Note that GNU compiler reports these variables are set but not used.</a>
<a name="11999"><span class="lineNum">   11999 </span>            :   //bool isCase1=false, isCase2=false;</a>
<a name="12000"><span class="lineNum">   12000 </span>            : </a>
<a name="12001"><span class="lineNum">   12001 </span>            :   //consider C99 style: for (int i=0;...)</a>
<a name="12002"><span class="lineNum">   12002 </span><span class="lineNoCov">          0 :   if (isSgVariableDeclaration(init1))</span></a>
<a name="12003"><span class="lineNum">   12003 </span>            :   {</a>
<a name="12004"><span class="lineNum">   12004 </span><span class="lineNoCov">          0 :     SgVariableDeclaration* decl = isSgVariableDeclaration(init1);</span></a>
<a name="12005"><span class="lineNum">   12005 </span><span class="lineNoCov">          0 :     ivarname = decl-&gt;get_variables().front();</span></a>
<a name="12006"><span class="lineNum">   12006 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(ivarname != NULL);</span></a>
<a name="12007"><span class="lineNum">   12007 </span>            :     //SgInitializer * initor = ivarname-&gt;get_initializer();</a>
<a name="12008"><span class="lineNum">   12008 </span>            :    // if (isSgAssignInitializer(initor))</a>
<a name="12009"><span class="lineNum">   12009 </span>            :    //   isCase1 = true;</a>
<a name="12010"><span class="lineNum">   12010 </span>            :   }// other regular case: for (i=0;..)</a>
<a name="12011"><span class="lineNum">   12011 </span><span class="lineNoCov">          0 :   else if (isAssignmentStatement(init1, &amp;ivarast))</span></a>
<a name="12012"><span class="lineNum">   12012 </span>            :   {</a>
<a name="12013"><span class="lineNum">   12013 </span><span class="lineNoCov">          0 :     SgVarRefExp* var = isSgVarRefExp(SkipCasting(ivarast));</span></a>
<a name="12014"><span class="lineNum">   12014 </span><span class="lineNoCov">          0 :     if (var)</span></a>
<a name="12015"><span class="lineNum">   12015 </span>            :     {</a>
<a name="12016"><span class="lineNum">   12016 </span><span class="lineNoCov">          0 :       ivarname = var-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="12017"><span class="lineNum">   12017 </span>            :       //isCase2 = true;</a>
<a name="12018"><span class="lineNum">   12018 </span>            :     }</a>
<a name="12019"><span class="lineNum">   12019 </span>            :   }</a>
<a name="12020"><span class="lineNum">   12020 </span><span class="lineNoCov">          0 :   else if (SgExprStatement* exp_stmt = isSgExprStatement(init1))</span></a>
<a name="12021"><span class="lineNum">   12021 </span>            :   { //case like: for (i = 1, len1 = 0, len2=0; i &lt;= n; i++)</a>
<a name="12022"><span class="lineNum">   12022 </span>            :      // AST is: SgCommaOpExp -&gt; SgAssignOp -&gt; SgVarRefExp</a>
<a name="12023"><span class="lineNum">   12023 </span><span class="lineNoCov">          0 :     if (SgCommaOpExp* comma_exp = isSgCommaOpExp(exp_stmt-&gt;get_expression()))</span></a>
<a name="12024"><span class="lineNum">   12024 </span>            :     {</a>
<a name="12025"><span class="lineNum">   12025 </span>            :       SgCommaOpExp* leaf_exp = comma_exp;</a>
<a name="12026"><span class="lineNum">   12026 </span><span class="lineNoCov">          0 :       while (isSgCommaOpExp(leaf_exp-&gt;get_lhs_operand()))</span></a>
<a name="12027"><span class="lineNum">   12027 </span><span class="lineNoCov">          0 :         leaf_exp = isSgCommaOpExp(leaf_exp-&gt;get_lhs_operand());</span></a>
<a name="12028"><span class="lineNum">   12028 </span><span class="lineNoCov">          0 :       if (SgAssignOp* assign_op = isSgAssignOp(leaf_exp-&gt;get_lhs_operand()))</span></a>
<a name="12029"><span class="lineNum">   12029 </span>            :       {</a>
<a name="12030"><span class="lineNum">   12030 </span><span class="lineNoCov">          0 :         SgVarRefExp* var = isSgVarRefExp(assign_op-&gt;get_lhs_operand());</span></a>
<a name="12031"><span class="lineNum">   12031 </span><span class="lineNoCov">          0 :         if (var)</span></a>
<a name="12032"><span class="lineNum">   12032 </span>            :         {</a>
<a name="12033"><span class="lineNum">   12033 </span><span class="lineNoCov">          0 :           ivarname = var-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="12034"><span class="lineNum">   12034 </span>            :         }</a>
<a name="12035"><span class="lineNum">   12035 </span>            :       }</a>
<a name="12036"><span class="lineNum">   12036 </span>            :     }</a>
<a name="12037"><span class="lineNum">   12037 </span>            :   }</a>
<a name="12038"><span class="lineNum">   12038 </span>            :   else</a>
<a name="12039"><span class="lineNum">   12039 </span>            :   {</a>
<a name="12040"><span class="lineNum">   12040 </span>            : </a>
<a name="12041"><span class="lineNum">   12041 </span><span class="lineNoCov">          0 :     mlog[Sawyer::Message::Common::WARN] &lt;&lt;&quot;Warning: SageInterface::getLoopIndexVariable(). Unhandled init_stmt type of SgForStatement&quot;&lt;&lt;endl;</span></a>
<a name="12042"><span class="lineNum">   12042 </span><span class="lineNoCov">          0 :     mlog[Sawyer::Message::Common::WARN] &lt;&lt;&quot;Init statement is :&quot;&lt;&lt;init1-&gt;class_name() &lt;&lt;&quot; &quot; &lt;&lt;init1-&gt;unparseToString()&lt;&lt;endl;</span></a>
<a name="12043"><span class="lineNum">   12043 </span><span class="lineNoCov">          0 :     init1-&gt;get_file_info()-&gt;display(&quot;Debug&quot;);</span></a>
<a name="12044"><span class="lineNum">   12044 </span>            : </a>
<a name="12045"><span class="lineNum">   12045 </span><span class="lineNoCov">          0 :     return NULL;</span></a>
<a name="12046"><span class="lineNum">   12046 </span>            :     //ROSE_ASSERT (false);</a>
<a name="12047"><span class="lineNum">   12047 </span>            :   }</a>
<a name="12048"><span class="lineNum">   12048 </span>            :   // Cannot be both true</a>
<a name="12049"><span class="lineNum">   12049 </span>            :  // ROSE_ASSERT(!(isCase1&amp;&amp;isCase2));</a>
<a name="12050"><span class="lineNum">   12050 </span>            : </a>
<a name="12051"><span class="lineNum">   12051 </span>            :   //Check loop index's type</a>
<a name="12052"><span class="lineNum">   12052 </span>            :   //ROSE_ASSERT(isStrictIntegerType(ivarname-&gt;get_type()));</a>
<a name="12053"><span class="lineNum">   12053 </span>            :   return ivarname;</a>
<a name="12054"><span class="lineNum">   12054 </span>            : }</a>
<a name="12055"><span class="lineNum">   12055 </span>            : </a>
<a name="12056"><span class="lineNum">   12056 </span>            : //!Check if a SgInitializedName is used as a loop index within a AST subtree</a>
<a name="12057"><span class="lineNum">   12057 </span>            : //! This function will use a bottom-up traverse starting from the subtree to find all enclosing loops and check if ivar is used as an index for either of them.</a>
<a name="12058"><span class="lineNum">   12058 </span><span class="lineNoCov">          0 : bool SageInterface::isLoopIndexVariable(SgInitializedName* ivar, SgNode* subtree_root)</span></a>
<a name="12059"><span class="lineNum">   12059 </span>            : {</a>
<a name="12060"><span class="lineNum">   12060 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ivar != NULL);</span></a>
<a name="12061"><span class="lineNum">   12061 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (subtree_root != NULL);</span></a>
<a name="12062"><span class="lineNum">   12062 </span><span class="lineNoCov">          0 :   bool result = false;</span></a>
<a name="12063"><span class="lineNum">   12063 </span><span class="lineNoCov">          0 :   SgScopeStatement * cur_loop = findEnclosingLoop (getEnclosingStatement(subtree_root));</span></a>
<a name="12064"><span class="lineNum">   12064 </span><span class="lineNoCov">          0 :   while (cur_loop)</span></a>
<a name="12065"><span class="lineNum">   12065 </span>            :   {</a>
<a name="12066"><span class="lineNum">   12066 </span><span class="lineNoCov">          0 :     SgInitializedName * i_index = getLoopIndexVariable (cur_loop);</span></a>
<a name="12067"><span class="lineNum">   12067 </span><span class="lineNoCov">          0 :     if (i_index == ivar)</span></a>
<a name="12068"><span class="lineNum">   12068 </span>            :     {</a>
<a name="12069"><span class="lineNum">   12069 </span>            :       result = true;</a>
<a name="12070"><span class="lineNum">   12070 </span>            :       break;</a>
<a name="12071"><span class="lineNum">   12071 </span>            :     }</a>
<a name="12072"><span class="lineNum">   12072 </span>            :     else</a>
<a name="12073"><span class="lineNum">   12073 </span>            :     { // findEnclosingLoop() is inclusive.</a>
<a name="12074"><span class="lineNum">   12074 </span><span class="lineNoCov">          0 :       cur_loop = findEnclosingLoop (getEnclosingStatement(cur_loop-&gt;get_parent()));</span></a>
<a name="12075"><span class="lineNum">   12075 </span>            :     }</a>
<a name="12076"><span class="lineNum">   12076 </span>            :   }</a>
<a name="12077"><span class="lineNum">   12077 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="12078"><span class="lineNum">   12078 </span>            : }</a>
<a name="12079"><span class="lineNum">   12079 </span>            : </a>
<a name="12080"><span class="lineNum">   12080 </span>            : //! Check if a for loop uses C99 style initialization statement with multiple expressions like for (int i=0, j=0; ..) or for (i=0,j=0;...)</a>
<a name="12081"><span class="lineNum">   12081 </span>            : /*!</a>
<a name="12082"><span class="lineNum">   12082 </span>            :    for (int i=0, j=0; ..) is stored as two variable declarations under SgForInitStatement's init_stmt member</a>
<a name="12083"><span class="lineNum">   12083 </span>            :    for (i=0,j=0;...) is stored as a single expression statement, with comma expression (i=0,j=0).</a>
<a name="12084"><span class="lineNum">   12084 </span>            : */</a>
<a name="12085"><span class="lineNum">   12085 </span><span class="lineNoCov">          0 : bool SageInterface::hasMultipleInitStatmentsOrExpressions (SgForStatement* loop)</span></a>
<a name="12086"><span class="lineNum">   12086 </span>            : {</a>
<a name="12087"><span class="lineNum">   12087 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (loop !=NULL);</span></a>
<a name="12088"><span class="lineNum">   12088 </span><span class="lineNoCov">          0 :   SgStatementPtrList&amp; stmt_list = loop-&gt;get_init_stmt();</span></a>
<a name="12089"><span class="lineNum">   12089 </span><span class="lineNoCov">          0 :   if (stmt_list.size() &gt;1) return true; // two var decl statements</span></a>
<a name="12090"><span class="lineNum">   12090 </span><span class="lineNoCov">          0 :   if (stmt_list.size() == 0) return false;</span></a>
<a name="12091"><span class="lineNum">   12091 </span>            : </a>
<a name="12092"><span class="lineNum">   12092 </span>            : //  generateDOTforMultipleFile(*getProject());</a>
<a name="12093"><span class="lineNum">   12093 </span>            :   //single variable declaration statement, like int i;</a>
<a name="12094"><span class="lineNum">   12094 </span><span class="lineNoCov">          0 :   SgVariableDeclaration* decl_stmt = isSgVariableDeclaration(stmt_list[0]);</span></a>
<a name="12095"><span class="lineNum">   12095 </span><span class="lineNoCov">          0 :   if (decl_stmt != NULL)</span></a>
<a name="12096"><span class="lineNum">   12096 </span>            :     return false;</a>
<a name="12097"><span class="lineNum">   12097 </span>            : </a>
<a name="12098"><span class="lineNum">   12098 </span>            :   // single statement, but with comma expression (i=0, j=0)</a>
<a name="12099"><span class="lineNum">   12099 </span><span class="lineNoCov">          0 :   SgExprStatement* exp_stmt = isSgExprStatement(stmt_list[0]);</span></a>
<a name="12100"><span class="lineNum">   12100 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (exp_stmt != NULL);</span></a>
<a name="12101"><span class="lineNum">   12101 </span><span class="lineNoCov">          0 :   if (isSgCommaOpExp (exp_stmt-&gt;get_expression()) )</span></a>
<a name="12102"><span class="lineNum">   12102 </span>            :   {</a>
<a name="12103"><span class="lineNum">   12103 </span><span class="lineNoCov">          0 :      return true;</span></a>
<a name="12104"><span class="lineNum">   12104 </span>            :   }</a>
<a name="12105"><span class="lineNum">   12105 </span>            : </a>
<a name="12106"><span class="lineNum">   12106 </span>            :     return false;</a>
<a name="12107"><span class="lineNum">   12107 </span>            : }</a>
<a name="12108"><span class="lineNum">   12108 </span>            : //! Get Fortran Do loop's key features</a>
<a name="12109"><span class="lineNum">   12109 </span><span class="lineNoCov">          0 : bool SageInterface::isCanonicalDoLoop(SgFortranDo* loop,SgInitializedName** ivar/*=NULL*/, SgExpression** lb/*=NULL*/, SgExpression** ub/*=NULL*/, SgExpression** step/*=NULL*/, SgStatement** body/*=NULL*/, bool *hasIncrementalIterationSpace/*= NULL*/, bool* isInclusiveUpperBound/*=NULL*/)</span></a>
<a name="12110"><span class="lineNum">   12110 </span>            : {</a>
<a name="12111"><span class="lineNum">   12111 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="12112"><span class="lineNum">   12112 </span><span class="lineNoCov">          0 :   SgFortranDo* fs = isSgFortranDo(loop);</span></a>
<a name="12113"><span class="lineNum">   12113 </span><span class="lineNoCov">          0 :   if (fs == NULL)</span></a>
<a name="12114"><span class="lineNum">   12114 </span>            :     return false;</a>
<a name="12115"><span class="lineNum">   12115 </span>            :   // 1. Check initialization statement is something like i=xx;</a>
<a name="12116"><span class="lineNum">   12116 </span><span class="lineNoCov">          0 :   SgExpression * init = fs-&gt;get_initialization();</span></a>
<a name="12117"><span class="lineNum">   12117 </span><span class="lineNoCov">          0 :   if (init == NULL)</span></a>
<a name="12118"><span class="lineNum">   12118 </span>            :     return false;</a>
<a name="12119"><span class="lineNum">   12119 </span><span class="lineNoCov">          0 :   SgAssignOp* init_assign = isSgAssignOp (init);</span></a>
<a name="12120"><span class="lineNum">   12120 </span><span class="lineNoCov">          0 :   SgExpression *lbast=NULL, *ubast=NULL;</span></a>
<a name="12121"><span class="lineNum">   12121 </span>            :  // SgExpression* ivarast=NULL, *stepast=NULL;</a>
<a name="12122"><span class="lineNum">   12122 </span><span class="lineNoCov">          0 :   SgInitializedName* ivarname=NULL;</span></a>
<a name="12123"><span class="lineNum">   12123 </span>            : </a>
<a name="12124"><span class="lineNum">   12124 </span><span class="lineNoCov">          0 :   bool isCase1=false;</span></a>
<a name="12125"><span class="lineNum">   12125 </span><span class="lineNoCov">          0 :   if (init_assign)</span></a>
<a name="12126"><span class="lineNum">   12126 </span>            :    {</a>
<a name="12127"><span class="lineNum">   12127 </span><span class="lineNoCov">          0 :      SgVarRefExp* var = isSgVarRefExp(init_assign-&gt;get_lhs_operand());</span></a>
<a name="12128"><span class="lineNum">   12128 </span><span class="lineNoCov">          0 :      if (var)</span></a>
<a name="12129"><span class="lineNum">   12129 </span><span class="lineNoCov">          0 :        ivarname = var-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="12130"><span class="lineNum">   12130 </span><span class="lineNoCov">          0 :      lbast = init_assign-&gt;get_rhs_operand();</span></a>
<a name="12131"><span class="lineNum">   12131 </span><span class="lineNoCov">          0 :      if (ivarname &amp;&amp; lbast )</span></a>
<a name="12132"><span class="lineNum">   12132 </span><span class="lineNoCov">          0 :        isCase1 = true;</span></a>
<a name="12133"><span class="lineNum">   12133 </span>            :    }</a>
<a name="12134"><span class="lineNum">   12134 </span>            :    // if not i=1</a>
<a name="12135"><span class="lineNum">   12135 </span><span class="lineNoCov">          0 :     if (!isCase1)</span></a>
<a name="12136"><span class="lineNum">   12136 </span>            :       return false;</a>
<a name="12137"><span class="lineNum">   12137 </span>            : </a>
<a name="12138"><span class="lineNum">   12138 </span>            :   //Check loop index's type</a>
<a name="12139"><span class="lineNum">   12139 </span><span class="lineNoCov">          0 :   if (!SageInterface::isStrictIntegerType(ivarname-&gt;get_type()))</span></a>
<a name="12140"><span class="lineNum">   12140 </span>            :     return false;</a>
<a name="12141"><span class="lineNum">   12141 </span>            : #if 0</a>
<a name="12142"><span class="lineNum">   12142 </span>            :   //2. Check test expression i [&lt;=, &gt;=, &lt;, &gt; ,!=] bound</a>
<a name="12143"><span class="lineNum">   12143 </span>            :   SgBinaryOp* test = isSgBinaryOp(fs-&gt;get_test_expr());</a>
<a name="12144"><span class="lineNum">   12144 </span>            :   if (test == NULL)</a>
<a name="12145"><span class="lineNum">   12145 </span>            :     return false;</a>
<a name="12146"><span class="lineNum">   12146 </span>            :   switch (test-&gt;variantT()) {</a>
<a name="12147"><span class="lineNum">   12147 </span>            :     case V_SgLessOrEqualOp:</a>
<a name="12148"><span class="lineNum">   12148 </span>            :        if (isInclusiveUpperBound != NULL)</a>
<a name="12149"><span class="lineNum">   12149 </span>            :          *isInclusiveUpperBound = true;</a>
<a name="12150"><span class="lineNum">   12150 </span>            :        if (hasIncrementalIterationSpace != NULL)</a>
<a name="12151"><span class="lineNum">   12151 </span>            :          *hasIncrementalIterationSpace = true;</a>
<a name="12152"><span class="lineNum">   12152 </span>            :        break;</a>
<a name="12153"><span class="lineNum">   12153 </span>            :     case V_SgLessThanOp:</a>
<a name="12154"><span class="lineNum">   12154 </span>            :        if (isInclusiveUpperBound != NULL)</a>
<a name="12155"><span class="lineNum">   12155 </span>            :          *isInclusiveUpperBound = false;</a>
<a name="12156"><span class="lineNum">   12156 </span>            :        if (hasIncrementalIterationSpace != NULL)</a>
<a name="12157"><span class="lineNum">   12157 </span>            :          *hasIncrementalIterationSpace = true;</a>
<a name="12158"><span class="lineNum">   12158 </span>            :        break;</a>
<a name="12159"><span class="lineNum">   12159 </span>            :     case V_SgGreaterOrEqualOp:</a>
<a name="12160"><span class="lineNum">   12160 </span>            :        if (isInclusiveUpperBound != NULL)</a>
<a name="12161"><span class="lineNum">   12161 </span>            :          *isInclusiveUpperBound = true;</a>
<a name="12162"><span class="lineNum">   12162 </span>            :         if (hasIncrementalIterationSpace != NULL)</a>
<a name="12163"><span class="lineNum">   12163 </span>            :          *hasIncrementalIterationSpace = false;</a>
<a name="12164"><span class="lineNum">   12164 </span>            :       break;</a>
<a name="12165"><span class="lineNum">   12165 </span>            :     case V_SgGreaterThanOp:</a>
<a name="12166"><span class="lineNum">   12166 </span>            :        if (isInclusiveUpperBound != NULL)</a>
<a name="12167"><span class="lineNum">   12167 </span>            :          *isInclusiveUpperBound = false;</a>
<a name="12168"><span class="lineNum">   12168 </span>            :        if (hasIncrementalIterationSpace != NULL)</a>
<a name="12169"><span class="lineNum">   12169 </span>            :          *hasIncrementalIterationSpace = false;</a>
<a name="12170"><span class="lineNum">   12170 </span>            :       break;</a>
<a name="12171"><span class="lineNum">   12171 </span>            : //    case V_SgNotEqualOp: // Do we really want to allow this != operator ?</a>
<a name="12172"><span class="lineNum">   12172 </span>            :       break;</a>
<a name="12173"><span class="lineNum">   12173 </span>            :     default:</a>
<a name="12174"><span class="lineNum">   12174 </span>            :       return false;</a>
<a name="12175"><span class="lineNum">   12175 </span>            :   }</a>
<a name="12176"><span class="lineNum">   12176 </span>            :   // check the tested variable is the same as the loop index</a>
<a name="12177"><span class="lineNum">   12177 </span>            :   SgVarRefExp* testvar = isSgVarRefExp(SkipCasting(test-&gt;get_lhs_operand()));</a>
<a name="12178"><span class="lineNum">   12178 </span>            :   if (testvar == NULL)</a>
<a name="12179"><span class="lineNum">   12179 </span>            :     return false;</a>
<a name="12180"><span class="lineNum">   12180 </span>            :   if (testvar-&gt;get_symbol() != ivarname-&gt;get_symbol_from_symbol_table ())</a>
<a name="12181"><span class="lineNum">   12181 </span>            :     return false;</a>
<a name="12182"><span class="lineNum">   12182 </span>            : #endif</a>
<a name="12183"><span class="lineNum">   12183 </span>            :  //grab the upper bound</a>
<a name="12184"><span class="lineNum">   12184 </span><span class="lineNoCov">          0 :   ubast = loop-&gt;get_bound();</span></a>
<a name="12185"><span class="lineNum">   12185 </span>            :   // Fortran Do loops always have inclusive upper bound</a>
<a name="12186"><span class="lineNum">   12186 </span><span class="lineNoCov">          0 :   if (isInclusiveUpperBound != NULL)</span></a>
<a name="12187"><span class="lineNum">   12187 </span><span class="lineNoCov">          0 :      *isInclusiveUpperBound = true;</span></a>
<a name="12188"><span class="lineNum">   12188 </span>            :   //3. Check the increment expression</a>
<a name="12189"><span class="lineNum">   12189 </span><span class="lineNoCov">          0 :   SgExpression* incr = fs-&gt;get_increment();</span></a>
<a name="12190"><span class="lineNum">   12190 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (incr != NULL);</span></a>
<a name="12191"><span class="lineNum">   12191 </span><span class="lineNoCov">          0 :   if (isSgNullExpression(incr))</span></a>
<a name="12192"><span class="lineNum">   12192 </span>            :   {</a>
<a name="12193"><span class="lineNum">   12193 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error:isCanonicalDoLoop() found NULL increment expression. Please call doLoopNormalization() first!&quot;&lt;&lt;endl;</span></a>
<a name="12194"><span class="lineNum">   12194 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (false);</span></a>
<a name="12195"><span class="lineNum">   12195 </span>            :   }</a>
<a name="12196"><span class="lineNum">   12196 </span><span class="lineNoCov">          0 :   if (hasIncrementalIterationSpace != NULL)</span></a>
<a name="12197"><span class="lineNum">   12197 </span>            :   {</a>
<a name="12198"><span class="lineNum">   12198 </span><span class="lineNoCov">          0 :      *hasIncrementalIterationSpace = true;</span></a>
<a name="12199"><span class="lineNum">   12199 </span>            :     // We can only tell a few cases</a>
<a name="12200"><span class="lineNum">   12200 </span><span class="lineNoCov">          0 :     if (SgIntVal* i_v = isSgIntVal(incr))</span></a>
<a name="12201"><span class="lineNum">   12201 </span>            :     {</a>
<a name="12202"><span class="lineNum">   12202 </span><span class="lineNoCov">          0 :       if (i_v-&gt;get_value()&lt;0)</span></a>
<a name="12203"><span class="lineNum">   12203 </span><span class="lineNoCov">          0 :      *hasIncrementalIterationSpace = false;</span></a>
<a name="12204"><span class="lineNum">   12204 </span>            :     }</a>
<a name="12205"><span class="lineNum">   12205 </span>            :   }</a>
<a name="12206"><span class="lineNum">   12206 </span>            : #if 0</a>
<a name="12207"><span class="lineNum">   12207 </span>            :   SgVarRefExp* incr_var = NULL;</a>
<a name="12208"><span class="lineNum">   12208 </span>            :   switch (incr-&gt;variantT()) {</a>
<a name="12209"><span class="lineNum">   12209 </span>            :     case V_SgPlusAssignOp: //+=</a>
<a name="12210"><span class="lineNum">   12210 </span>            :     case V_SgMinusAssignOp://-=</a>
<a name="12211"><span class="lineNum">   12211 </span>            :       incr_var = isSgVarRefExp(SkipCasting(isSgBinaryOp(incr)-&gt;get_lhs_operand()));</a>
<a name="12212"><span class="lineNum">   12212 </span>            :       stepast = isSgBinaryOp(incr)-&gt;get_rhs_operand();</a>
<a name="12213"><span class="lineNum">   12213 </span>            :       break;</a>
<a name="12214"><span class="lineNum">   12214 </span>            :     case V_SgPlusPlusOp:   //++</a>
<a name="12215"><span class="lineNum">   12215 </span>            :     case V_SgMinusMinusOp:  //--</a>
<a name="12216"><span class="lineNum">   12216 </span>            :       incr_var = isSgVarRefExp(SkipCasting(isSgUnaryOp(incr)-&gt;get_operand()));</a>
<a name="12217"><span class="lineNum">   12217 </span>            :       stepast = buildIntVal(1); // will this dangling SgNode cause any problem?</a>
<a name="12218"><span class="lineNum">   12218 </span>            :       break;</a>
<a name="12219"><span class="lineNum">   12219 </span>            :     default:</a>
<a name="12220"><span class="lineNum">   12220 </span>            :       return false;</a>
<a name="12221"><span class="lineNum">   12221 </span>            :   }</a>
<a name="12222"><span class="lineNum">   12222 </span>            :   if (incr_var == NULL)</a>
<a name="12223"><span class="lineNum">   12223 </span>            :     return false;</a>
<a name="12224"><span class="lineNum">   12224 </span>            :   if (incr_var-&gt;get_symbol() != ivarname-&gt;get_symbol_from_symbol_table ())</a>
<a name="12225"><span class="lineNum">   12225 </span>            :     return false;</a>
<a name="12226"><span class="lineNum">   12226 </span>            : #endif</a>
<a name="12227"><span class="lineNum">   12227 </span>            :   // return loop information if requested</a>
<a name="12228"><span class="lineNum">   12228 </span><span class="lineNoCov">          0 :   if (ivar != NULL)</span></a>
<a name="12229"><span class="lineNum">   12229 </span><span class="lineNoCov">          0 :     *ivar = ivarname;</span></a>
<a name="12230"><span class="lineNum">   12230 </span><span class="lineNoCov">          0 :   if (lb != NULL)</span></a>
<a name="12231"><span class="lineNum">   12231 </span><span class="lineNoCov">          0 :     *lb = lbast;</span></a>
<a name="12232"><span class="lineNum">   12232 </span><span class="lineNoCov">          0 :   if (ub != NULL)</span></a>
<a name="12233"><span class="lineNum">   12233 </span><span class="lineNoCov">          0 :     *ub = ubast;</span></a>
<a name="12234"><span class="lineNum">   12234 </span><span class="lineNoCov">          0 :   if (step != NULL)</span></a>
<a name="12235"><span class="lineNum">   12235 </span><span class="lineNoCov">          0 :     *step = incr;</span></a>
<a name="12236"><span class="lineNum">   12236 </span><span class="lineNoCov">          0 :   if (body != NULL) {</span></a>
<a name="12237"><span class="lineNum">   12237 </span><span class="lineNoCov">          0 :     *body = fs-&gt;get_body();</span></a>
<a name="12238"><span class="lineNum">   12238 </span>            :   }</a>
<a name="12239"><span class="lineNum">   12239 </span>            :   return true;</a>
<a name="12240"><span class="lineNum">   12240 </span>            : }</a>
<a name="12241"><span class="lineNum">   12241 </span>            : //TODO: expose it to the namespace once it matures.</a>
<a name="12242"><span class="lineNum">   12242 </span>            : //! Check if an executable statement (possibly compound), is a structured block</a>
<a name="12243"><span class="lineNum">   12243 </span>            : //  with a single entry at the top and a single exit at the bottom, or an OpenMP construct.</a>
<a name="12244"><span class="lineNum">   12244 </span>            : /*</a>
<a name="12245"><span class="lineNum">   12245 </span>            : From OpenMP 4.5 Specification</a>
<a name="12246"><span class="lineNum">   12246 </span>            : </a>
<a name="12247"><span class="lineNum">   12247 </span>            : 1.2.2 OpenMP Language Terminology</a>
<a name="12248"><span class="lineNum">   12248 </span>            : </a>
<a name="12249"><span class="lineNum">   12249 </span>            : For C/C++, an executable statement, possibly compound, with a single entry at the</a>
<a name="12250"><span class="lineNum">   12250 </span>            : top and a single exit at the bottom, or an OpenMP construct.</a>
<a name="12251"><span class="lineNum">   12251 </span>            : </a>
<a name="12252"><span class="lineNum">   12252 </span>            : For Fortran, a block of executable statements with a single entry at the top and a</a>
<a name="12253"><span class="lineNum">   12253 </span>            : single exit at the bottom, or an OpenMP construct.</a>
<a name="12254"><span class="lineNum">   12254 </span>            : </a>
<a name="12255"><span class="lineNum">   12255 </span>            : COMMENTS:</a>
<a name="12256"><span class="lineNum">   12256 </span>            : </a>
<a name="12257"><span class="lineNum">   12257 </span>            : For all base languages:</a>
<a name="12258"><span class="lineNum">   12258 </span>            : * Access to the structured block must not be the result of a branch; and</a>
<a name="12259"><span class="lineNum">   12259 </span>            : * The point of exit cannot be a branch out of the structured block.</a>
<a name="12260"><span class="lineNum">   12260 </span>            : </a>
<a name="12261"><span class="lineNum">   12261 </span>            :  For C/C++:</a>
<a name="12262"><span class="lineNum">   12262 </span>            : * The point of entry must not be a call to setjmp();</a>
<a name="12263"><span class="lineNum">   12263 </span>            : * longjmp() and throw() must not violate the entry/exit criteria;</a>
<a name="12264"><span class="lineNum">   12264 </span>            : * Calls to exit() are allowed in a structured block; and</a>
<a name="12265"><span class="lineNum">   12265 </span>            : * An expression statement, iteration statement, selection statement, or try block is considered to be a structured block if the corresponding compound statement obtained by enclosing it in { and } would be a structured block.</a>
<a name="12266"><span class="lineNum">   12266 </span>            : </a>
<a name="12267"><span class="lineNum">   12267 </span>            : For Fortran:</a>
<a name="12268"><span class="lineNum">   12268 </span>            : * STOP statements are allowed in a structured block.</a>
<a name="12269"><span class="lineNum">   12269 </span>            : </a>
<a name="12270"><span class="lineNum">   12270 </span>            : */</a>
<a name="12271"><span class="lineNum">   12271 </span><span class="lineCov">         21 : bool isStructuredBlock(SgStatement* s)</span></a>
<a name="12272"><span class="lineNum">   12272 </span>            : {</a>
<a name="12273"><span class="lineNum">   12273 </span><span class="lineCov">         21 :   bool rt = true;</span></a>
<a name="12274"><span class="lineNum">   12274 </span><span class="lineCov">         21 :   ROSE_ASSERT (s != NULL);</span></a>
<a name="12275"><span class="lineNum">   12275 </span>            : </a>
<a name="12276"><span class="lineNum">   12276 </span>            :   // contain break;</a>
<a name="12277"><span class="lineNum">   12277 </span><span class="lineCov">         21 :   std::set&lt;SgNode*&gt;  bset = SgNodeHelper::loopRelevantBreakStmtNodes (s);</span></a>
<a name="12278"><span class="lineNum">   12278 </span><span class="lineCov">         21 :   if (bset.size()!=0 )</span></a>
<a name="12279"><span class="lineNum">   12279 </span><span class="lineNoCov">          0 :     rt = false;</span></a>
<a name="12280"><span class="lineNum">   12280 </span>            :   //TODO: contain goto statement, jumping to outside targets</a>
<a name="12281"><span class="lineNum">   12281 </span>            :   // longjump(), throw(),</a>
<a name="12282"><span class="lineNum">   12282 </span>            :   // calls to exit() are allowed.</a>
<a name="12283"><span class="lineNum">   12283 </span>            : </a>
<a name="12284"><span class="lineNum">   12284 </span><span class="lineCov">         21 :   return rt;</span></a>
<a name="12285"><span class="lineNum">   12285 </span>            : </a>
<a name="12286"><span class="lineNum">   12286 </span>            : }</a>
<a name="12287"><span class="lineNum">   12287 </span>            : </a>
<a name="12288"><span class="lineNum">   12288 </span>            : //! Based on AstInterface::IsFortranLoop() and ASTtools::getLoopIndexVar()</a>
<a name="12289"><span class="lineNum">   12289 </span>            : //TODO check the loop index is not being written in the loop body</a>
<a name="12290"><span class="lineNum">   12290 </span><span class="lineCov">         21 : bool SageInterface::isCanonicalForLoop(SgNode* loop,SgInitializedName** ivar/*=NULL*/, SgExpression** lb/*=NULL*/, SgExpression** ub/*=NULL*/, SgExpression** step/*=NULL*/, SgStatement** body/*=NULL*/, bool *hasIncrementalIterationSpace/*= NULL*/, bool* isInclusiveUpperBound/*=NULL*/)</span></a>
<a name="12291"><span class="lineNum">   12291 </span>            : {</a>
<a name="12292"><span class="lineNum">   12292 </span><span class="lineCov">         21 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="12293"><span class="lineNum">   12293 </span><span class="lineCov">         21 :   SgForStatement* fs = isSgForStatement(loop);</span></a>
<a name="12294"><span class="lineNum">   12294 </span>            :   //SgFortranDo* fs2 = isSgFortranDo(loop);</a>
<a name="12295"><span class="lineNum">   12295 </span><span class="lineCov">         21 :   if (fs == NULL)</span></a>
<a name="12296"><span class="lineNum">   12296 </span>            :   {</a>
<a name="12297"><span class="lineNum">   12297 </span>            :    // if (fs2)</a>
<a name="12298"><span class="lineNum">   12298 </span>            :    //   return isCanonicalDoLoop (fs2, ivar, lb, ub, step, body, hasIncrementalIterationSpace, isInclusiveUpperBound);</a>
<a name="12299"><span class="lineNum">   12299 </span>            :    // else</a>
<a name="12300"><span class="lineNum">   12300 </span>            :       return false;</a>
<a name="12301"><span class="lineNum">   12301 </span>            :    }</a>
<a name="12302"><span class="lineNum">   12302 </span>            :   // 1. Check initialization statement is something like i=xx;</a>
<a name="12303"><span class="lineNum">   12303 </span><span class="lineCov">         21 :   SgStatementPtrList &amp; init = fs-&gt;get_init_stmt();</span></a>
<a name="12304"><span class="lineNum">   12304 </span><span class="lineCov">         21 :   if (init.size() !=1)</span></a>
<a name="12305"><span class="lineNum">   12305 </span>            :     return false;</a>
<a name="12306"><span class="lineNum">   12306 </span><span class="lineCov">         21 :   SgStatement* init1 = init.front();</span></a>
<a name="12307"><span class="lineNum">   12307 </span><span class="lineCov">         21 :   SgExpression* ivarast=NULL, *lbast=NULL, *ubast=NULL, *stepast=NULL;</span></a>
<a name="12308"><span class="lineNum">   12308 </span><span class="lineCov">         21 :   SgInitializedName* ivarname=NULL;</span></a>
<a name="12309"><span class="lineNum">   12309 </span>            : </a>
<a name="12310"><span class="lineNum">   12310 </span><span class="lineCov">         21 :   bool isCase1=false, isCase2=false;</span></a>
<a name="12311"><span class="lineNum">   12311 </span>            :   //consider C99 style: for (int i=0;...)</a>
<a name="12312"><span class="lineNum">   12312 </span><span class="lineCov">         21 :   if (isSgVariableDeclaration(init1))</span></a>
<a name="12313"><span class="lineNum">   12313 </span>            :    {</a>
<a name="12314"><span class="lineNum">   12314 </span><span class="lineCov">          1 :      SgVariableDeclaration* decl = isSgVariableDeclaration(init1);</span></a>
<a name="12315"><span class="lineNum">   12315 </span><span class="lineCov">          1 :      ivarname = decl-&gt;get_variables().front();</span></a>
<a name="12316"><span class="lineNum">   12316 </span><span class="lineCov">          1 :      ROSE_ASSERT(ivarname != NULL);</span></a>
<a name="12317"><span class="lineNum">   12317 </span><span class="lineCov">          1 :      SgInitializer * initor = ivarname-&gt;get_initializer();</span></a>
<a name="12318"><span class="lineNum">   12318 </span><span class="lineCov">          1 :      if (isSgAssignInitializer(initor))</span></a>
<a name="12319"><span class="lineNum">   12319 </span>            :      {</a>
<a name="12320"><span class="lineNum">   12320 </span><span class="lineCov">          1 :        lbast = isSgAssignInitializer(initor)-&gt;get_operand();</span></a>
<a name="12321"><span class="lineNum">   12321 </span><span class="lineCov">          1 :        isCase1 = true;</span></a>
<a name="12322"><span class="lineNum">   12322 </span>            :      }</a>
<a name="12323"><span class="lineNum">   12323 </span>            :    }// other regular case: for (i=0;..)</a>
<a name="12324"><span class="lineNum">   12324 </span><span class="lineCov">         20 :    else if (isAssignmentStatement(init1, &amp;ivarast, &amp;lbast))</span></a>
<a name="12325"><span class="lineNum">   12325 </span>            :    {</a>
<a name="12326"><span class="lineNum">   12326 </span><span class="lineCov">         20 :      SgVarRefExp* var = isSgVarRefExp(SkipCasting(ivarast));</span></a>
<a name="12327"><span class="lineNum">   12327 </span><span class="lineCov">         20 :      if (var)</span></a>
<a name="12328"><span class="lineNum">   12328 </span>            :      {</a>
<a name="12329"><span class="lineNum">   12329 </span><span class="lineCov">         20 :        ivarname = var-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="12330"><span class="lineNum">   12330 </span>            :        isCase2 = true;</a>
<a name="12331"><span class="lineNum">   12331 </span>            :      }</a>
<a name="12332"><span class="lineNum">   12332 </span>            :    }</a>
<a name="12333"><span class="lineNum">   12333 </span>            :    // Cannot be both true</a>
<a name="12334"><span class="lineNum">   12334 </span><span class="lineCov">         21 :    ROSE_ASSERT(!(isCase1&amp;&amp;isCase2));</span></a>
<a name="12335"><span class="lineNum">   12335 </span>            :    // if not either case is true</a>
<a name="12336"><span class="lineNum">   12336 </span><span class="lineCov">         21 :     if (!(isCase1||isCase2))</span></a>
<a name="12337"><span class="lineNum">   12337 </span>            :       return false;</a>
<a name="12338"><span class="lineNum">   12338 </span>            : </a>
<a name="12339"><span class="lineNum">   12339 </span>            :   //Check loop index's type</a>
<a name="12340"><span class="lineNum">   12340 </span><span class="lineCov">         21 :   if (!isStrictIntegerType(ivarname-&gt;get_type()))</span></a>
<a name="12341"><span class="lineNum">   12341 </span>            :     return false;</a>
<a name="12342"><span class="lineNum">   12342 </span>            : </a>
<a name="12343"><span class="lineNum">   12343 </span>            :   //2. Check test expression i [&lt;=, &gt;=, &lt;, &gt; ,!=] bound</a>
<a name="12344"><span class="lineNum">   12344 </span><span class="lineCov">         21 :   SgBinaryOp* test = isSgBinaryOp(fs-&gt;get_test_expr());</span></a>
<a name="12345"><span class="lineNum">   12345 </span><span class="lineCov">         21 :   if (test == NULL)</span></a>
<a name="12346"><span class="lineNum">   12346 </span>            :     return false;</a>
<a name="12347"><span class="lineNum">   12347 </span><span class="lineCov">         21 :   switch (test-&gt;variantT()) {</span></a>
<a name="12348"><span class="lineNum">   12348 </span><span class="lineCov">         16 :     case V_SgLessOrEqualOp:</span></a>
<a name="12349"><span class="lineNum">   12349 </span><span class="lineCov">         16 :        if (isInclusiveUpperBound != NULL)</span></a>
<a name="12350"><span class="lineNum">   12350 </span><span class="lineNoCov">          0 :          *isInclusiveUpperBound = true;</span></a>
<a name="12351"><span class="lineNum">   12351 </span><span class="lineCov">         16 :        if (hasIncrementalIterationSpace != NULL)</span></a>
<a name="12352"><span class="lineNum">   12352 </span><span class="lineCov">         13 :          *hasIncrementalIterationSpace = true;</span></a>
<a name="12353"><span class="lineNum">   12353 </span>            :        break;</a>
<a name="12354"><span class="lineNum">   12354 </span><span class="lineCov">          2 :     case V_SgLessThanOp:</span></a>
<a name="12355"><span class="lineNum">   12355 </span><span class="lineCov">          2 :        if (isInclusiveUpperBound != NULL)</span></a>
<a name="12356"><span class="lineNum">   12356 </span><span class="lineNoCov">          0 :          *isInclusiveUpperBound = false;</span></a>
<a name="12357"><span class="lineNum">   12357 </span><span class="lineCov">          2 :        if (hasIncrementalIterationSpace != NULL)</span></a>
<a name="12358"><span class="lineNum">   12358 </span><span class="lineCov">          1 :          *hasIncrementalIterationSpace = true;</span></a>
<a name="12359"><span class="lineNum">   12359 </span>            :        break;</a>
<a name="12360"><span class="lineNum">   12360 </span><span class="lineCov">          3 :     case V_SgGreaterOrEqualOp:</span></a>
<a name="12361"><span class="lineNum">   12361 </span><span class="lineCov">          3 :        if (isInclusiveUpperBound != NULL)</span></a>
<a name="12362"><span class="lineNum">   12362 </span><span class="lineNoCov">          0 :          *isInclusiveUpperBound = true;</span></a>
<a name="12363"><span class="lineNum">   12363 </span><span class="lineCov">          3 :         if (hasIncrementalIterationSpace != NULL)</span></a>
<a name="12364"><span class="lineNum">   12364 </span><span class="lineCov">          3 :          *hasIncrementalIterationSpace = false;</span></a>
<a name="12365"><span class="lineNum">   12365 </span>            :       break;</a>
<a name="12366"><span class="lineNum">   12366 </span><span class="lineNoCov">          0 :     case V_SgGreaterThanOp:</span></a>
<a name="12367"><span class="lineNum">   12367 </span><span class="lineNoCov">          0 :        if (isInclusiveUpperBound != NULL)</span></a>
<a name="12368"><span class="lineNum">   12368 </span><span class="lineNoCov">          0 :          *isInclusiveUpperBound = false;</span></a>
<a name="12369"><span class="lineNum">   12369 </span><span class="lineNoCov">          0 :        if (hasIncrementalIterationSpace != NULL)</span></a>
<a name="12370"><span class="lineNum">   12370 </span><span class="lineNoCov">          0 :          *hasIncrementalIterationSpace = false;</span></a>
<a name="12371"><span class="lineNum">   12371 </span>            :       break;</a>
<a name="12372"><span class="lineNum">   12372 </span>            : //    case V_SgNotEqualOp: // Do we really want to allow this != operator ?</a>
<a name="12373"><span class="lineNum">   12373 </span>            :       break;</a>
<a name="12374"><span class="lineNum">   12374 </span>            :     default:</a>
<a name="12375"><span class="lineNum">   12375 </span>            :       return false;</a>
<a name="12376"><span class="lineNum">   12376 </span>            :   }</a>
<a name="12377"><span class="lineNum">   12377 </span>            :   // check the tested variable is the same as the loop index</a>
<a name="12378"><span class="lineNum">   12378 </span><span class="lineCov">         21 :   SgVarRefExp* testvar = isSgVarRefExp(SkipCasting(test-&gt;get_lhs_operand()));</span></a>
<a name="12379"><span class="lineNum">   12379 </span><span class="lineCov">         21 :   if (testvar == NULL)</span></a>
<a name="12380"><span class="lineNum">   12380 </span>            :     return false;</a>
<a name="12381"><span class="lineNum">   12381 </span><span class="lineCov">         21 :   if (testvar-&gt;get_symbol() != ivarname-&gt;get_symbol_from_symbol_table ())</span></a>
<a name="12382"><span class="lineNum">   12382 </span>            :     return false;</a>
<a name="12383"><span class="lineNum">   12383 </span>            :   //grab the upper bound</a>
<a name="12384"><span class="lineNum">   12384 </span><span class="lineCov">         21 :   ubast = test-&gt;get_rhs_operand();</span></a>
<a name="12385"><span class="lineNum">   12385 </span>            : </a>
<a name="12386"><span class="lineNum">   12386 </span>            :   //3. Check the increment expression</a>
<a name="12387"><span class="lineNum">   12387 </span>            :   /* Allowed forms</a>
<a name="12388"><span class="lineNum">   12388 </span>            :      ++var</a>
<a name="12389"><span class="lineNum">   12389 </span>            :      var++</a>
<a name="12390"><span class="lineNum">   12390 </span>            :      --var</a>
<a name="12391"><span class="lineNum">   12391 </span>            :      var--</a>
<a name="12392"><span class="lineNum">   12392 </span>            : </a>
<a name="12393"><span class="lineNum">   12393 </span>            :      var += incr</a>
<a name="12394"><span class="lineNum">   12394 </span>            :      var -= incr</a>
<a name="12395"><span class="lineNum">   12395 </span>            : </a>
<a name="12396"><span class="lineNum">   12396 </span>            :      var = var + incr</a>
<a name="12397"><span class="lineNum">   12397 </span>            :      var = incr + var</a>
<a name="12398"><span class="lineNum">   12398 </span>            :      var = var - incr</a>
<a name="12399"><span class="lineNum">   12399 </span>            :   */</a>
<a name="12400"><span class="lineNum">   12400 </span><span class="lineCov">         21 :   SgExpression* incr = fs-&gt;get_increment();</span></a>
<a name="12401"><span class="lineNum">   12401 </span><span class="lineCov">         21 :   SgVarRefExp* incr_var = NULL;</span></a>
<a name="12402"><span class="lineNum">   12402 </span><span class="lineCov">         21 :   switch (incr-&gt;variantT()) {</span></a>
<a name="12403"><span class="lineNum">   12403 </span><span class="lineCov">         21 :     case V_SgPlusAssignOp: //+=</span></a>
<a name="12404"><span class="lineNum">   12404 </span><span class="lineCov">         21 :     case V_SgMinusAssignOp://-=</span></a>
<a name="12405"><span class="lineNum">   12405 </span><span class="lineCov">         21 :       incr_var = isSgVarRefExp(SkipCasting(isSgBinaryOp(incr)-&gt;get_lhs_operand()));</span></a>
<a name="12406"><span class="lineNum">   12406 </span><span class="lineCov">         21 :       stepast = isSgBinaryOp(incr)-&gt;get_rhs_operand();</span></a>
<a name="12407"><span class="lineNum">   12407 </span>            :       break;</a>
<a name="12408"><span class="lineNum">   12408 </span><span class="lineNoCov">          0 :     case V_SgPlusPlusOp:   //++</span></a>
<a name="12409"><span class="lineNum">   12409 </span><span class="lineNoCov">          0 :     case V_SgMinusMinusOp:  //--</span></a>
<a name="12410"><span class="lineNum">   12410 </span><span class="lineNoCov">          0 :       incr_var = isSgVarRefExp(SkipCasting(isSgUnaryOp(incr)-&gt;get_operand()));</span></a>
<a name="12411"><span class="lineNum">   12411 </span><span class="lineNoCov">          0 :       stepast = buildIntVal(1); // will this dangling SgNode cause any problem?</span></a>
<a name="12412"><span class="lineNum">   12412 </span>            :       break;</a>
<a name="12413"><span class="lineNum">   12413 </span><span class="lineNoCov">          0 :     case V_SgAssignOp: { // cases : var + incr, var - incr, incr + var (not allowed: incr-var)</span></a>
<a name="12414"><span class="lineNum">   12414 </span><span class="lineNoCov">          0 :       incr_var=isSgVarRefExp(SkipCasting(isSgBinaryOp(incr)-&gt;get_lhs_operand()));</span></a>
<a name="12415"><span class="lineNum">   12415 </span><span class="lineNoCov">          0 :       if(incr_var == NULL)</span></a>
<a name="12416"><span class="lineNum">   12416 </span>            :         return false;</a>
<a name="12417"><span class="lineNum">   12417 </span><span class="lineNoCov">          0 :       SgAddOp* addOp=isSgAddOp(SkipCasting(isSgBinaryOp(incr)-&gt;get_rhs_operand()));</span></a>
<a name="12418"><span class="lineNum">   12418 </span><span class="lineNoCov">          0 :       SgSubtractOp* subtractOp=isSgSubtractOp(SkipCasting(isSgBinaryOp(incr)-&gt;get_rhs_operand()));</span></a>
<a name="12419"><span class="lineNum">   12419 </span><span class="lineNoCov">          0 :       SgBinaryOp* arithOp=0;</span></a>
<a name="12420"><span class="lineNum">   12420 </span><span class="lineNoCov">          0 :       if(addOp)</span></a>
<a name="12421"><span class="lineNum">   12421 </span>            :         arithOp=addOp;</a>
<a name="12422"><span class="lineNum">   12422 </span><span class="lineNoCov">          0 :       else if(subtractOp)</span></a>
<a name="12423"><span class="lineNum">   12423 </span>            :         arithOp=subtractOp;</a>
<a name="12424"><span class="lineNum">   12424 </span>            :       else</a>
<a name="12425"><span class="lineNum">   12425 </span>            :         return false;</a>
<a name="12426"><span class="lineNum">   12426 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(arithOp!=0);</span></a>
<a name="12427"><span class="lineNum">   12427 </span><span class="lineNoCov">          0 :       if(SgVarRefExp* varRefExp=isSgVarRefExp(SkipCasting(isSgBinaryOp(arithOp)-&gt;get_lhs_operand()))) {</span></a>
<a name="12428"><span class="lineNum">   12428 </span>            :         // cases : var + incr, var - incr</a>
<a name="12429"><span class="lineNum">   12429 </span><span class="lineNoCov">          0 :         incr_var=varRefExp;</span></a>
<a name="12430"><span class="lineNum">   12430 </span><span class="lineNoCov">          0 :         stepast=isSgBinaryOp(arithOp)-&gt;get_rhs_operand();</span></a>
<a name="12431"><span class="lineNum">   12431 </span><span class="lineNoCov">          0 :       } else if(SgVarRefExp* varRefExp=isSgVarRefExp(SkipCasting(isSgBinaryOp(arithOp)-&gt;get_rhs_operand()))) {</span></a>
<a name="12432"><span class="lineNum">   12432 </span><span class="lineNoCov">          0 :         if(isSgAddOp(arithOp)) {</span></a>
<a name="12433"><span class="lineNum">   12433 </span>            :           // case : incr + var (not allowed: incr-var)</a>
<a name="12434"><span class="lineNum">   12434 </span><span class="lineNoCov">          0 :           incr_var=varRefExp;</span></a>
<a name="12435"><span class="lineNum">   12435 </span><span class="lineNoCov">          0 :           stepast=isSgBinaryOp(arithOp)-&gt;get_lhs_operand();</span></a>
<a name="12436"><span class="lineNum">   12436 </span>            :         }</a>
<a name="12437"><span class="lineNum">   12437 </span>            :       }</a>
<a name="12438"><span class="lineNum">   12438 </span>            :       break;</a>
<a name="12439"><span class="lineNum">   12439 </span>            :     } // end of V_AssignOp</a>
<a name="12440"><span class="lineNum">   12440 </span>            :     default:</a>
<a name="12441"><span class="lineNum">   12441 </span>            :       return false;</a>
<a name="12442"><span class="lineNum">   12442 </span>            :   }</a>
<a name="12443"><span class="lineNum">   12443 </span>            : </a>
<a name="12444"><span class="lineNum">   12444 </span><span class="lineCov">         21 :   if (incr_var == NULL)</span></a>
<a name="12445"><span class="lineNum">   12445 </span>            :     return false;</a>
<a name="12446"><span class="lineNum">   12446 </span><span class="lineCov">         21 :   if (incr_var-&gt;get_symbol() != ivarname-&gt;get_symbol_from_symbol_table ())</span></a>
<a name="12447"><span class="lineNum">   12447 </span>            :     return false;</a>
<a name="12448"><span class="lineNum">   12448 </span>            : </a>
<a name="12449"><span class="lineNum">   12449 </span>            : </a>
<a name="12450"><span class="lineNum">   12450 </span>            :   // single entry and single exit?</a>
<a name="12451"><span class="lineNum">   12451 </span>            :   // only for C for loop for now</a>
<a name="12452"><span class="lineNum">   12452 </span>            :   // TODO: Fortran support later</a>
<a name="12453"><span class="lineNum">   12453 </span><span class="lineCov">         21 :   if (fs &amp;&amp; !isStructuredBlock(fs-&gt;get_loop_body()) )</span></a>
<a name="12454"><span class="lineNum">   12454 </span>            :     return false;</a>
<a name="12455"><span class="lineNum">   12455 </span>            : </a>
<a name="12456"><span class="lineNum">   12456 </span>            :   // return loop information if requested</a>
<a name="12457"><span class="lineNum">   12457 </span><span class="lineCov">         21 :   if (ivar != NULL)</span></a>
<a name="12458"><span class="lineNum">   12458 </span><span class="lineCov">         20 :     *ivar = ivarname;</span></a>
<a name="12459"><span class="lineNum">   12459 </span><span class="lineCov">         21 :   if (lb != NULL)</span></a>
<a name="12460"><span class="lineNum">   12460 </span><span class="lineCov">         20 :     *lb = lbast;</span></a>
<a name="12461"><span class="lineNum">   12461 </span><span class="lineCov">         21 :   if (ub != NULL)</span></a>
<a name="12462"><span class="lineNum">   12462 </span><span class="lineCov">         20 :     *ub = ubast;</span></a>
<a name="12463"><span class="lineNum">   12463 </span><span class="lineCov">         21 :   if (step != NULL)</span></a>
<a name="12464"><span class="lineNum">   12464 </span><span class="lineCov">         20 :     *step = stepast;</span></a>
<a name="12465"><span class="lineNum">   12465 </span><span class="lineCov">         21 :   if (body != NULL) {</span></a>
<a name="12466"><span class="lineNum">   12466 </span><span class="lineCov">         19 :     *body = fs-&gt;get_loop_body();</span></a>
<a name="12467"><span class="lineNum">   12467 </span>            :   }</a>
<a name="12468"><span class="lineNum">   12468 </span>            :   return true;</a>
<a name="12469"><span class="lineNum">   12469 </span>            : }</a>
<a name="12470"><span class="lineNum">   12470 </span>            : </a>
<a name="12471"><span class="lineNum">   12471 </span>            : //! Set the lower bound of a loop header</a>
<a name="12472"><span class="lineNum">   12472 </span><span class="lineNoCov">          0 : void SageInterface::setLoopLowerBound(SgNode* loop, SgExpression* lb)</span></a>
<a name="12473"><span class="lineNum">   12473 </span>            : {</a>
<a name="12474"><span class="lineNum">   12474 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="12475"><span class="lineNum">   12475 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(lb != NULL);</span></a>
<a name="12476"><span class="lineNum">   12476 </span><span class="lineNoCov">          0 :   SgForStatement* forstmt = isSgForStatement(loop);</span></a>
<a name="12477"><span class="lineNum">   12477 </span><span class="lineNoCov">          0 :   SgFortranDo* dostmt = isSgFortranDo(loop);</span></a>
<a name="12478"><span class="lineNum">   12478 </span>            :   //  ROSE_ASSERT(forstmt!= NULL);</a>
<a name="12479"><span class="lineNum">   12479 </span>            : </a>
<a name="12480"><span class="lineNum">   12480 </span><span class="lineNoCov">          0 :   if (forstmt != NULL)</span></a>
<a name="12481"><span class="lineNum">   12481 </span>            :   {</a>
<a name="12482"><span class="lineNum">   12482 </span>            :     // two cases: init_stmt is</a>
<a name="12483"><span class="lineNum">   12483 </span>            :     //       SgExprStatement (assignment) like i=0;</a>
<a name="12484"><span class="lineNum">   12484 </span>            :     //       SgVariableDeclaration int i =0 or</a>
<a name="12485"><span class="lineNum">   12485 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode* &gt; testList = NodeQuery::querySubTree( *((forstmt-&gt;get_init_stmt()).begin()), V_SgAssignOp);</span></a>
<a name="12486"><span class="lineNum">   12486 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0) // assignment statement</span></a>
<a name="12487"><span class="lineNum">   12487 </span>            :     {</a>
<a name="12488"><span class="lineNum">   12488 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// only handle the case of 1 statement, canonical form</span></a>
<a name="12489"><span class="lineNum">   12489 </span><span class="lineNoCov">          0 :       SgAssignOp * assignop = isSgAssignOp((*testList.begin()));</span></a>
<a name="12490"><span class="lineNum">   12490 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(assignop);</span></a>
<a name="12491"><span class="lineNum">   12491 </span><span class="lineNoCov">          0 :       if( assignop-&gt;get_rhs_operand()-&gt;get_lvalue())</span></a>
<a name="12492"><span class="lineNum">   12492 </span><span class="lineNoCov">          0 :         lb-&gt;set_lvalue(true);</span></a>
<a name="12493"><span class="lineNum">   12493 </span><span class="lineNoCov">          0 :       assignop-&gt;set_rhs_operand(lb);</span></a>
<a name="12494"><span class="lineNum">   12494 </span><span class="lineNoCov">          0 :       lb-&gt;set_parent(assignop);</span></a>
<a name="12495"><span class="lineNum">   12495 </span>            :       //TODO what happens to the original rhs operand?</a>
<a name="12496"><span class="lineNum">   12496 </span>            :     }</a>
<a name="12497"><span class="lineNum">   12497 </span>            :     else // variable declaration case</a>
<a name="12498"><span class="lineNum">   12498 </span>            :     {</a>
<a name="12499"><span class="lineNum">   12499 </span>            :       // SgVariableDeclaration</a>
<a name="12500"><span class="lineNum">   12500 </span><span class="lineNoCov">          0 :       Rose_STL_Container&lt;SgNode* &gt; testList = NodeQuery::querySubTree( *((forstmt-&gt;get_init_stmt()).begin()),  V_SgAssignInitializer );</span></a>
<a name="12501"><span class="lineNum">   12501 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// only handle the case of 1 statement, canonical form</span></a>
<a name="12502"><span class="lineNum">   12502 </span><span class="lineNoCov">          0 :       SgAssignInitializer* init = isSgAssignInitializer((*testList.begin()));</span></a>
<a name="12503"><span class="lineNum">   12503 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(init != NULL);</span></a>
<a name="12504"><span class="lineNum">   12504 </span><span class="lineNoCov">          0 :       init-&gt;set_operand(lb);</span></a>
<a name="12505"><span class="lineNum">   12505 </span><span class="lineNoCov">          0 :       lb-&gt;set_parent(init);</span></a>
<a name="12506"><span class="lineNum">   12506 </span>            :       //TODO what happens to the original rhs operand?</a>
<a name="12507"><span class="lineNum">   12507 </span>            :     }</a>
<a name="12508"><span class="lineNum">   12508 </span>            :   }</a>
<a name="12509"><span class="lineNum">   12509 </span><span class="lineNoCov">          0 :   else if (dostmt != NULL)</span></a>
<a name="12510"><span class="lineNum">   12510 </span>            :   {</a>
<a name="12511"><span class="lineNum">   12511 </span><span class="lineNoCov">          0 :     SgExpression* init = dostmt-&gt;get_initialization();</span></a>
<a name="12512"><span class="lineNum">   12512 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (init != NULL);</span></a>
<a name="12513"><span class="lineNum">   12513 </span><span class="lineNoCov">          0 :     SgAssignOp * a_op = isSgAssignOp (init);</span></a>
<a name="12514"><span class="lineNum">   12514 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (a_op!=NULL);</span></a>
<a name="12515"><span class="lineNum">   12515 </span><span class="lineNoCov">          0 :     a_op-&gt;set_rhs_operand(lb);</span></a>
<a name="12516"><span class="lineNum">   12516 </span><span class="lineNoCov">          0 :     lb-&gt;set_parent(a_op);</span></a>
<a name="12517"><span class="lineNum">   12517 </span>            :     //TODO delete the previous operand?</a>
<a name="12518"><span class="lineNum">   12518 </span>            :   }</a>
<a name="12519"><span class="lineNum">   12519 </span>            :   else</a>
<a name="12520"><span class="lineNum">   12520 </span>            :   {</a>
<a name="12521"><span class="lineNum">   12521 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error. SageInterface::setLoopLowerBound(), illegal loop type:&quot;&lt;&lt; loop-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="12522"><span class="lineNum">   12522 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (false);</span></a>
<a name="12523"><span class="lineNum">   12523 </span>            :   }</a>
<a name="12524"><span class="lineNum">   12524 </span><span class="lineNoCov">          0 : }</span></a>
<a name="12525"><span class="lineNum">   12525 </span>            : </a>
<a name="12526"><span class="lineNum">   12526 </span>            : //! Set the upper bound of a loop header,regardless the condition expression type.  for (i=lb; i op up, ...)</a>
<a name="12527"><span class="lineNum">   12527 </span><span class="lineNoCov">          0 : void SageInterface::setLoopUpperBound(SgNode* loop, SgExpression* ub)</span></a>
<a name="12528"><span class="lineNum">   12528 </span>            : {</a>
<a name="12529"><span class="lineNum">   12529 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="12530"><span class="lineNum">   12530 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(ub != NULL);</span></a>
<a name="12531"><span class="lineNum">   12531 </span><span class="lineNoCov">          0 :   SgForStatement* forstmt = isSgForStatement(loop);</span></a>
<a name="12532"><span class="lineNum">   12532 </span>            :   //  ROSE_ASSERT(forstmt!= NULL);</a>
<a name="12533"><span class="lineNum">   12533 </span><span class="lineNoCov">          0 :   SgFortranDo* dostmt = isSgFortranDo(loop);</span></a>
<a name="12534"><span class="lineNum">   12534 </span><span class="lineNoCov">          0 :   if (forstmt != NULL)</span></a>
<a name="12535"><span class="lineNum">   12535 </span>            :   {</a>
<a name="12536"><span class="lineNum">   12536 </span>            :     // set upper bound expression</a>
<a name="12537"><span class="lineNum">   12537 </span><span class="lineNoCov">          0 :     SgBinaryOp * binop= isSgBinaryOp(isSgExprStatement(forstmt-&gt;get_test())-&gt;get_expression());</span></a>
<a name="12538"><span class="lineNum">   12538 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(binop != NULL);</span></a>
<a name="12539"><span class="lineNum">   12539 </span><span class="lineNoCov">          0 :     binop-&gt;set_rhs_operand(ub);</span></a>
<a name="12540"><span class="lineNum">   12540 </span><span class="lineNoCov">          0 :     ub-&gt;set_parent(binop);</span></a>
<a name="12541"><span class="lineNum">   12541 </span>            :   }</a>
<a name="12542"><span class="lineNum">   12542 </span><span class="lineNoCov">          0 :   else if (dostmt != NULL)</span></a>
<a name="12543"><span class="lineNum">   12543 </span>            :   {</a>
<a name="12544"><span class="lineNum">   12544 </span><span class="lineNoCov">          0 :     dostmt-&gt;set_bound(ub);</span></a>
<a name="12545"><span class="lineNum">   12545 </span><span class="lineNoCov">          0 :     ub-&gt;set_parent(dostmt);</span></a>
<a name="12546"><span class="lineNum">   12546 </span>            :     //TODO delete the original bound expression</a>
<a name="12547"><span class="lineNum">   12547 </span>            :   }</a>
<a name="12548"><span class="lineNum">   12548 </span>            :   else</a>
<a name="12549"><span class="lineNum">   12549 </span>            :   {</a>
<a name="12550"><span class="lineNum">   12550 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error. SageInterface::setLoopUpperBound(), illegal loop type:&quot;&lt;&lt; loop-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="12551"><span class="lineNum">   12551 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (false);</span></a>
<a name="12552"><span class="lineNum">   12552 </span>            :   }</a>
<a name="12553"><span class="lineNum">   12553 </span>            : </a>
<a name="12554"><span class="lineNum">   12554 </span><span class="lineNoCov">          0 : }</span></a>
<a name="12555"><span class="lineNum">   12555 </span>            : </a>
<a name="12556"><span class="lineNum">   12556 </span>            : //! Set the stride(step) of a loop 's incremental expression, regardless the expression types (i+=s; i= i+s, etc)</a>
<a name="12557"><span class="lineNum">   12557 </span><span class="lineNoCov">          0 : void SageInterface::setLoopStride(SgNode* loop, SgExpression* stride)</span></a>
<a name="12558"><span class="lineNum">   12558 </span>            : {</a>
<a name="12559"><span class="lineNum">   12559 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="12560"><span class="lineNum">   12560 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(stride != NULL);</span></a>
<a name="12561"><span class="lineNum">   12561 </span><span class="lineNoCov">          0 :   SgForStatement* forstmt = isSgForStatement(loop);</span></a>
<a name="12562"><span class="lineNum">   12562 </span><span class="lineNoCov">          0 :   SgFortranDo * dostmt = isSgFortranDo (loop);</span></a>
<a name="12563"><span class="lineNum">   12563 </span>            :   // ROSE_ASSERT(forstmt!= NULL);</a>
<a name="12564"><span class="lineNum">   12564 </span><span class="lineNoCov">          0 :   if (dostmt != NULL)</span></a>
<a name="12565"><span class="lineNum">   12565 </span>            :   {</a>
<a name="12566"><span class="lineNum">   12566 </span><span class="lineNoCov">          0 :     dostmt-&gt;set_increment(stride);</span></a>
<a name="12567"><span class="lineNum">   12567 </span><span class="lineNoCov">          0 :     stride-&gt;set_parent(dostmt);</span></a>
<a name="12568"><span class="lineNum">   12568 </span>            :     //TODO delete original increment expression</a>
<a name="12569"><span class="lineNum">   12569 </span>            :   }</a>
<a name="12570"><span class="lineNum">   12570 </span><span class="lineNoCov">          0 :   else  if (forstmt != NULL)</span></a>
<a name="12571"><span class="lineNum">   12571 </span>            :   {</a>
<a name="12572"><span class="lineNum">   12572 </span>            :     // set stride expression</a>
<a name="12573"><span class="lineNum">   12573 </span>            :     // case 1: i++ change to i+=stride</a>
<a name="12574"><span class="lineNum">   12574 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt; testList = NodeQuery::querySubTree( forstmt-&gt;get_increment(), V_SgPlusPlusOp);</span></a>
<a name="12575"><span class="lineNum">   12575 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12576"><span class="lineNum">   12576 </span>            :     {</a>
<a name="12577"><span class="lineNum">   12577 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size() == 1); // should have only one</span></a>
<a name="12578"><span class="lineNum">   12578 </span><span class="lineNoCov">          0 :       SgVarRefExp *loopvarexp = isSgVarRefExp(SageInterface::deepCopy</span></a>
<a name="12579"><span class="lineNum">   12579 </span><span class="lineNoCov">          0 :           (isSgPlusPlusOp( *testList.begin())-&gt;get_operand()));</span></a>
<a name="12580"><span class="lineNum">   12580 </span><span class="lineNoCov">          0 :       SgPlusAssignOp *plusassignop = buildPlusAssignOp(loopvarexp, stride);</span></a>
<a name="12581"><span class="lineNum">   12581 </span><span class="lineNoCov">          0 :       forstmt-&gt;set_increment(plusassignop);</span></a>
<a name="12582"><span class="lineNum">   12582 </span>            :     }</a>
<a name="12583"><span class="lineNum">   12583 </span>            : </a>
<a name="12584"><span class="lineNum">   12584 </span>            :     // case 1.5: i-- also changed to i+=stride</a>
<a name="12585"><span class="lineNum">   12585 </span><span class="lineNoCov">          0 :     testList = NodeQuery::querySubTree(forstmt-&gt;get_increment(), V_SgMinusMinusOp);</span></a>
<a name="12586"><span class="lineNum">   12586 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12587"><span class="lineNum">   12587 </span>            :     {</a>
<a name="12588"><span class="lineNum">   12588 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// should have only one</span></a>
<a name="12589"><span class="lineNum">   12589 </span><span class="lineNoCov">          0 :       SgVarRefExp *loopvarexp =isSgVarRefExp(SageInterface::deepCopy</span></a>
<a name="12590"><span class="lineNum">   12590 </span><span class="lineNoCov">          0 :           (isSgMinusMinusOp(*testList.begin())-&gt;get_operand()));</span></a>
<a name="12591"><span class="lineNum">   12591 </span><span class="lineNoCov">          0 :       SgPlusAssignOp *plusassignop = buildPlusAssignOp(loopvarexp, stride);</span></a>
<a name="12592"><span class="lineNum">   12592 </span><span class="lineNoCov">          0 :       forstmt-&gt;set_increment(plusassignop);</span></a>
<a name="12593"><span class="lineNum">   12593 </span>            :     }</a>
<a name="12594"><span class="lineNum">   12594 </span>            : </a>
<a name="12595"><span class="lineNum">   12595 </span>            :     // case 2: i+=X</a>
<a name="12596"><span class="lineNum">   12596 </span><span class="lineNoCov">          0 :     testList = NodeQuery::querySubTree( forstmt-&gt;get_increment(), V_SgPlusAssignOp);</span></a>
<a name="12597"><span class="lineNum">   12597 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12598"><span class="lineNum">   12598 </span>            :     {</a>
<a name="12599"><span class="lineNum">   12599 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// should have only one</span></a>
<a name="12600"><span class="lineNum">   12600 </span><span class="lineNoCov">          0 :       SgPlusAssignOp * assignop = isSgPlusAssignOp(*(testList.begin()));</span></a>
<a name="12601"><span class="lineNum">   12601 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(assignop!=NULL);</span></a>
<a name="12602"><span class="lineNum">   12602 </span><span class="lineNoCov">          0 :       assignop-&gt;set_rhs_operand(stride);</span></a>
<a name="12603"><span class="lineNum">   12603 </span>            :     }</a>
<a name="12604"><span class="lineNum">   12604 </span>            : </a>
<a name="12605"><span class="lineNum">   12605 </span>            :     // case 2.5: i-=X changed to i+=stride</a>
<a name="12606"><span class="lineNum">   12606 </span><span class="lineNoCov">          0 :     testList = NodeQuery::querySubTree(forstmt-&gt;get_increment(), V_SgMinusAssignOp);</span></a>
<a name="12607"><span class="lineNum">   12607 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12608"><span class="lineNum">   12608 </span>            :     {</a>
<a name="12609"><span class="lineNum">   12609 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// should have only one</span></a>
<a name="12610"><span class="lineNum">   12610 </span><span class="lineNoCov">          0 :       SgVarRefExp *loopvarexp =isSgVarRefExp(SageInterface::deepCopy</span></a>
<a name="12611"><span class="lineNum">   12611 </span><span class="lineNoCov">          0 :           (isSgMinusAssignOp(*testList.begin())-&gt;get_lhs_operand()));</span></a>
<a name="12612"><span class="lineNum">   12612 </span><span class="lineNoCov">          0 :       SgExprStatement* exprstmt = isSgExprStatement((*testList.begin())-&gt;get_parent());</span></a>
<a name="12613"><span class="lineNum">   12613 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(exprstmt !=NULL);</span></a>
<a name="12614"><span class="lineNum">   12614 </span><span class="lineNoCov">          0 :       SgPlusAssignOp *plusassignop = buildPlusAssignOp(loopvarexp, stride);</span></a>
<a name="12615"><span class="lineNum">   12615 </span><span class="lineNoCov">          0 :       exprstmt-&gt;set_expression(plusassignop);</span></a>
<a name="12616"><span class="lineNum">   12616 </span>            :     }</a>
<a name="12617"><span class="lineNum">   12617 </span>            : </a>
<a name="12618"><span class="lineNum">   12618 </span>            : #if 0 // [Robb Matzke 2021-03-17]</a>
<a name="12619"><span class="lineNum">   12619 </span>            :     // DQ (1/3/2007): I think this is a meaningless statement.</a>
<a name="12620"><span class="lineNum">   12620 </span>            :     testList.empty();</a>
<a name="12621"><span class="lineNum">   12621 </span>            : #endif</a>
<a name="12622"><span class="lineNum">   12622 </span>            :     // case 3: i=i + X or i =X +i  i</a>
<a name="12623"><span class="lineNum">   12623 </span>            :     // TODO; what if users use i*=,etc ??</a>
<a name="12624"><span class="lineNum">   12624 </span>            :     //      send out a warning: not canonical FOR/DO loop</a>
<a name="12625"><span class="lineNum">   12625 </span>            :     //      or do this in the real frontend. MUST conform to canonical form</a>
<a name="12626"><span class="lineNum">   12626 </span><span class="lineNoCov">          0 :     testList = NodeQuery::querySubTree(forstmt-&gt;get_increment(), V_SgAddOp);</span></a>
<a name="12627"><span class="lineNum">   12627 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12628"><span class="lineNum">   12628 </span>            :     {</a>
<a name="12629"><span class="lineNum">   12629 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// should have only one ??</span></a>
<a name="12630"><span class="lineNum">   12630 </span>            :       // consider only the top first one</a>
<a name="12631"><span class="lineNum">   12631 </span><span class="lineNoCov">          0 :       SgAddOp * addop = isSgAddOp(*(testList.begin()));</span></a>
<a name="12632"><span class="lineNum">   12632 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(addop!=NULL);</span></a>
<a name="12633"><span class="lineNum">   12633 </span><span class="lineNoCov">          0 :       string loopvar= (isSgVarRefExp(isSgAssignOp(addop-&gt;get_parent())-&gt;get_lhs_operand())-&gt;get_symbol()-&gt;get_name()).getString();</span></a>
<a name="12634"><span class="lineNum">   12634 </span><span class="lineNoCov">          0 :       if (isSgVarRefExp(addop-&gt;get_rhs_operand())!=NULL)</span></a>
<a name="12635"><span class="lineNum">   12635 </span>            :       {</a>
<a name="12636"><span class="lineNum">   12636 </span><span class="lineNoCov">          0 :         if ((isSgVarRefExp(addop-&gt;get_rhs_operand())-&gt;get_symbol()-&gt;get_name()).getString() ==loopvar)</span></a>
<a name="12637"><span class="lineNum">   12637 </span><span class="lineNoCov">          0 :           addop-&gt;set_lhs_operand(stride);</span></a>
<a name="12638"><span class="lineNum">   12638 </span>            :         else</a>
<a name="12639"><span class="lineNum">   12639 </span><span class="lineNoCov">          0 :           addop-&gt;set_rhs_operand(stride);</span></a>
<a name="12640"><span class="lineNum">   12640 </span>            :       }</a>
<a name="12641"><span class="lineNum">   12641 </span>            :       else</a>
<a name="12642"><span class="lineNum">   12642 </span><span class="lineNoCov">          0 :         addop-&gt;set_rhs_operand(stride);</span></a>
<a name="12643"><span class="lineNum">   12643 </span>            :     }</a>
<a name="12644"><span class="lineNum">   12644 </span>            : </a>
<a name="12645"><span class="lineNum">   12645 </span>            :     // case 3.5: i=i - X</a>
<a name="12646"><span class="lineNum">   12646 </span><span class="lineNoCov">          0 :     testList = NodeQuery::querySubTree(forstmt-&gt;get_increment(), V_SgSubtractOp);</span></a>
<a name="12647"><span class="lineNum">   12647 </span><span class="lineNoCov">          0 :     if (testList.size()&gt;0)</span></a>
<a name="12648"><span class="lineNum">   12648 </span>            :     {</a>
<a name="12649"><span class="lineNum">   12649 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(testList.size()==1);// should have only one ??</span></a>
<a name="12650"><span class="lineNum">   12650 </span>            :       // consider only the top first one</a>
<a name="12651"><span class="lineNum">   12651 </span><span class="lineNoCov">          0 :       SgSubtractOp * subtractop = isSgSubtractOp(*(testList.begin()));</span></a>
<a name="12652"><span class="lineNum">   12652 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(subtractop!=NULL);</span></a>
<a name="12653"><span class="lineNum">   12653 </span><span class="lineNoCov">          0 :       SgVarRefExp *loopvarexp =isSgVarRefExp(SageInterface::deepCopy</span></a>
<a name="12654"><span class="lineNum">   12654 </span><span class="lineNoCov">          0 :           (isSgSubtractOp(*testList.begin())-&gt;get_lhs_operand()));</span></a>
<a name="12655"><span class="lineNum">   12655 </span><span class="lineNoCov">          0 :       SgAssignOp *assignop = isSgAssignOp((*testList.begin())-&gt;get_parent());</span></a>
<a name="12656"><span class="lineNum">   12656 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(assignop !=NULL);</span></a>
<a name="12657"><span class="lineNum">   12657 </span><span class="lineNoCov">          0 :       SgPlusAssignOp *plusassignop = buildPlusAssignOp(loopvarexp, stride);</span></a>
<a name="12658"><span class="lineNum">   12658 </span><span class="lineNoCov">          0 :       assignop-&gt;set_rhs_operand(plusassignop);</span></a>
<a name="12659"><span class="lineNum">   12659 </span>            :     }</a>
<a name="12660"><span class="lineNum">   12660 </span>            :   }</a>
<a name="12661"><span class="lineNum">   12661 </span>            :   else</a>
<a name="12662"><span class="lineNum">   12662 </span>            :   {</a>
<a name="12663"><span class="lineNum">   12663 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error. SageInterface::setLoopStride(), illegal loop type:&quot;&lt;&lt; loop-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="12664"><span class="lineNum">   12664 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (false);</span></a>
<a name="12665"><span class="lineNum">   12665 </span>            : </a>
<a name="12666"><span class="lineNum">   12666 </span>            :   }</a>
<a name="12667"><span class="lineNum">   12667 </span><span class="lineNoCov">          0 : }</span></a>
<a name="12668"><span class="lineNum">   12668 </span>            : </a>
<a name="12669"><span class="lineNum">   12669 </span>            : //! Check if a SgNode _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc)</a>
<a name="12670"><span class="lineNum">   12670 </span>            : //!</a>
<a name="12671"><span class="lineNum">   12671 </span>            : //! Return the left hand, right hand expressions and if the left hand variable is also being read. This code is from AstInterface::IsAssignment()</a>
<a name="12672"><span class="lineNum">   12672 </span><span class="lineCov">         20 : bool SageInterface::isAssignmentStatement(SgNode* s, SgExpression** lhs/*=NULL*/, SgExpression** rhs/*=NULL*/, bool* readlhs/*=NULL*/)</span></a>
<a name="12673"><span class="lineNum">   12673 </span>            : {</a>
<a name="12674"><span class="lineNum">   12674 </span><span class="lineCov">         20 :   SgExprStatement *n = isSgExprStatement(s);</span></a>
<a name="12675"><span class="lineNum">   12675 </span><span class="lineCov">         20 :   SgExpression *exp = (n != 0)? n-&gt;get_expression() : isSgExpression(s);</span></a>
<a name="12676"><span class="lineNum">   12676 </span><span class="lineCov">         20 :   if (exp != 0) {</span></a>
<a name="12677"><span class="lineNum">   12677 </span><span class="lineCov">         20 :     switch (exp-&gt;variantT()) {</span></a>
<a name="12678"><span class="lineNum">   12678 </span><span class="lineCov">         20 :       case V_SgPlusAssignOp:</span></a>
<a name="12679"><span class="lineNum">   12679 </span><span class="lineCov">         20 :       case V_SgMinusAssignOp:</span></a>
<a name="12680"><span class="lineNum">   12680 </span><span class="lineCov">         20 :       case V_SgAndAssignOp:</span></a>
<a name="12681"><span class="lineNum">   12681 </span><span class="lineCov">         20 :       case V_SgIorAssignOp:</span></a>
<a name="12682"><span class="lineNum">   12682 </span><span class="lineCov">         20 :       case V_SgMultAssignOp:</span></a>
<a name="12683"><span class="lineNum">   12683 </span><span class="lineCov">         20 :       case V_SgDivAssignOp:</span></a>
<a name="12684"><span class="lineNum">   12684 </span><span class="lineCov">         20 :       case V_SgModAssignOp:</span></a>
<a name="12685"><span class="lineNum">   12685 </span><span class="lineCov">         20 :       case V_SgXorAssignOp:</span></a>
<a name="12686"><span class="lineNum">   12686 </span><span class="lineCov">         20 :       case V_SgAssignOp:</span></a>
<a name="12687"><span class="lineNum">   12687 </span><span class="lineCov">         20 :         {</span></a>
<a name="12688"><span class="lineNum">   12688 </span><span class="lineCov">         20 :           SgBinaryOp* s2 = isSgBinaryOp(exp);</span></a>
<a name="12689"><span class="lineNum">   12689 </span><span class="lineCov">         20 :           if (lhs != 0)</span></a>
<a name="12690"><span class="lineNum">   12690 </span><span class="lineCov">         20 :             *lhs = s2-&gt;get_lhs_operand();</span></a>
<a name="12691"><span class="lineNum">   12691 </span><span class="lineCov">         20 :           if (rhs != 0) {</span></a>
<a name="12692"><span class="lineNum">   12692 </span><span class="lineCov">         20 :             SgExpression* init = s2-&gt;get_rhs_operand();</span></a>
<a name="12693"><span class="lineNum">   12693 </span><span class="lineCov">         20 :             if ( init-&gt;variantT() == V_SgAssignInitializer)</span></a>
<a name="12694"><span class="lineNum">   12694 </span><span class="lineNoCov">          0 :               init = isSgAssignInitializer(init)-&gt;get_operand();</span></a>
<a name="12695"><span class="lineNum">   12695 </span><span class="lineCov">         20 :             *rhs = init;</span></a>
<a name="12696"><span class="lineNum">   12696 </span>            :           }</a>
<a name="12697"><span class="lineNum">   12697 </span><span class="lineCov">         20 :           if (readlhs != 0)</span></a>
<a name="12698"><span class="lineNum">   12698 </span><span class="lineNoCov">          0 :             *readlhs = (exp-&gt;variantT() != V_SgAssignOp);</span></a>
<a name="12699"><span class="lineNum">   12699 </span><span class="lineCov">         20 :           return true;</span></a>
<a name="12700"><span class="lineNum">   12700 </span>            :         }</a>
<a name="12701"><span class="lineNum">   12701 </span>            :       default:</a>
<a name="12702"><span class="lineNum">   12702 </span>            :          return false;</a>
<a name="12703"><span class="lineNum">   12703 </span>            :     }</a>
<a name="12704"><span class="lineNum">   12704 </span>            :   }</a>
<a name="12705"><span class="lineNum">   12705 </span>            :   return false;</a>
<a name="12706"><span class="lineNum">   12706 </span>            : }</a>
<a name="12707"><span class="lineNum">   12707 </span>            : </a>
<a name="12708"><span class="lineNum">   12708 </span>            : </a>
<a name="12709"><span class="lineNum">   12709 </span>            : void</a>
<a name="12710"><span class="lineNum">   12710 </span><span class="lineCov">       2271 : SageInterface::removeConsecutiveLabels(SgNode* top)</span></a>
<a name="12711"><span class="lineNum">   12711 </span>            :    {</a>
<a name="12712"><span class="lineNum">   12712 </span><span class="lineCov">       2271 :      Rose_STL_Container&lt;SgNode*&gt; gotos = NodeQuery::querySubTree(top,V_SgGotoStatement);</span></a>
<a name="12713"><span class="lineNum">   12713 </span><span class="lineCov">       2272 :      for (size_t i = 0; i &lt; gotos.size(); ++i)</span></a>
<a name="12714"><span class="lineNum">   12714 </span>            :         {</a>
<a name="12715"><span class="lineNum">   12715 </span><span class="lineCov">          1 :           SgGotoStatement* gs = isSgGotoStatement(gotos[i]);</span></a>
<a name="12716"><span class="lineNum">   12716 </span><span class="lineCov">          1 :           SgLabelStatement* ls = gs-&gt;get_label();</span></a>
<a name="12717"><span class="lineNum">   12717 </span><span class="lineCov">          1 :           SgBasicBlock* lsParent = isSgBasicBlock(ls-&gt;get_parent());</span></a>
<a name="12718"><span class="lineNum">   12718 </span><span class="lineCov">          1 :           if (!lsParent) continue;</span></a>
<a name="12719"><span class="lineNum">   12719 </span><span class="lineNoCov">          0 :           SgStatementPtrList&amp; bbStatements = lsParent-&gt;get_statements();</span></a>
<a name="12720"><span class="lineNum">   12720 </span>            : </a>
<a name="12721"><span class="lineNum">   12721 </span><span class="lineNoCov">          0 :           size_t j = std::find(bbStatements.begin(), bbStatements.end(), ls) - bbStatements.begin();</span></a>
<a name="12722"><span class="lineNum">   12722 </span>            : </a>
<a name="12723"><span class="lineNum">   12723 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (j != bbStatements.size());</span></a>
<a name="12724"><span class="lineNum">   12724 </span>            : </a>
<a name="12725"><span class="lineNum">   12725 </span><span class="lineNoCov">          0 :           while (j &lt; bbStatements.size() - 1 &amp;&amp; isSgLabelStatement(bbStatements[j + 1]))</span></a>
<a name="12726"><span class="lineNum">   12726 </span>            :              {</a>
<a name="12727"><span class="lineNum">   12727 </span>            :                ++j;</a>
<a name="12728"><span class="lineNum">   12728 </span>            :              }</a>
<a name="12729"><span class="lineNum">   12729 </span><span class="lineNoCov">          0 :           gs-&gt;set_label(isSgLabelStatement(bbStatements[j]));</span></a>
<a name="12730"><span class="lineNum">   12730 </span>            :         }</a>
<a name="12731"><span class="lineNum">   12731 </span><span class="lineCov">       2271 :    }</span></a>
<a name="12732"><span class="lineNum">   12732 </span>            : </a>
<a name="12733"><span class="lineNum">   12733 </span><span class="lineNoCov">          0 : bool SageInterface::mergeDeclarationAndAssignment (SgVariableDeclaration* decl, SgExprStatement* assign_stmt, bool removeAssignStmt /*= true*/)</span></a>
<a name="12734"><span class="lineNum">   12734 </span>            : {</a>
<a name="12735"><span class="lineNum">   12735 </span><span class="lineNoCov">          0 :    return  mergeAssignmentWithDeclaration (assign_stmt, decl, removeAssignStmt);</span></a>
<a name="12736"><span class="lineNum">   12736 </span>            : }</a>
<a name="12737"><span class="lineNum">   12737 </span>            : //! Merge a variable assignment statement into a matching variable declaration statement</a>
<a name="12738"><span class="lineNum">   12738 </span>            : /*!</a>
<a name="12739"><span class="lineNum">   12739 </span>            :  *  e.g.  int i;  i=10;  becomes int i=10;  the original i=10 will be deleted after the merge</a>
<a name="12740"><span class="lineNum">   12740 </span>            :  *  if success, return true, otherwise return false (e.g. variable declaration does not match or already has an initializer)</a>
<a name="12741"><span class="lineNum">   12741 </span>            :  */</a>
<a name="12742"><span class="lineNum">   12742 </span><span class="lineNoCov">          0 : bool SageInterface::mergeAssignmentWithDeclaration(SgExprStatement* assign_stmt, SgVariableDeclaration* decl, bool removeAssignStmt /*= true*/)</span></a>
<a name="12743"><span class="lineNum">   12743 </span>            : {</a>
<a name="12744"><span class="lineNum">   12744 </span><span class="lineNoCov">          0 :   bool rt= true;</span></a>
<a name="12745"><span class="lineNum">   12745 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(decl != NULL);</span></a>
<a name="12746"><span class="lineNum">   12746 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(assign_stmt != NULL);</span></a>
<a name="12747"><span class="lineNum">   12747 </span>            : </a>
<a name="12748"><span class="lineNum">   12748 </span>            :   // Sanity check of assign statement: must be a form of var = xxx;</a>
<a name="12749"><span class="lineNum">   12749 </span><span class="lineNoCov">          0 :   SgAssignOp * assign_op = isSgAssignOp (assign_stmt-&gt;get_expression());</span></a>
<a name="12750"><span class="lineNum">   12750 </span><span class="lineNoCov">          0 :   if (assign_op == NULL)</span></a>
<a name="12751"><span class="lineNum">   12751 </span>            :     return false;</a>
<a name="12752"><span class="lineNum">   12752 </span><span class="lineNoCov">          0 :   SgVarRefExp* assign_op_var = isSgVarRefExp(assign_op-&gt;get_lhs_operand());</span></a>
<a name="12753"><span class="lineNum">   12753 </span><span class="lineNoCov">          0 :   if (assign_op_var == NULL) return false;</span></a>
<a name="12754"><span class="lineNum">   12754 </span>            : </a>
<a name="12755"><span class="lineNum">   12755 </span>            :   // Sanity check of the variable declaration: it should not have an existing initializer</a>
<a name="12756"><span class="lineNum">   12756 </span><span class="lineNoCov">          0 :   SgInitializedName * decl_var = SageInterface::getFirstInitializedName (decl);</span></a>
<a name="12757"><span class="lineNum">   12757 </span><span class="lineNoCov">          0 :   if (decl_var-&gt;get_initptr()!= NULL ) return false;</span></a>
<a name="12758"><span class="lineNum">   12758 </span>            : </a>
<a name="12759"><span class="lineNum">   12759 </span>            :   // check if two variables match</a>
<a name="12760"><span class="lineNum">   12760 </span>            :   // In translation, it is possible the declaration has not yet been inserted into its scope.</a>
<a name="12761"><span class="lineNum">   12761 </span>            :   // finding its symbol can return NULL.</a>
<a name="12762"><span class="lineNum">   12762 </span>            :   // But we still want to do the merge.</a>
<a name="12763"><span class="lineNum">   12763 </span><span class="lineNoCov">          0 :   SgSymbol* decl_var_symbol = decl_var-&gt;get_symbol_from_symbol_table();</span></a>
<a name="12764"><span class="lineNum">   12764 </span><span class="lineNoCov">          0 :   if (decl_var_symbol!=NULL)</span></a>
<a name="12765"><span class="lineNum">   12765 </span>            :   {</a>
<a name="12766"><span class="lineNum">   12766 </span>            :     // DQ (3/25/2017): Fixed Clang warning: warning: implicit conversion of NULL constant to 'bool' [-Wnull-conversion]</a>
<a name="12767"><span class="lineNum">   12767 </span>            :     // if (assign_op_var-&gt;get_symbol() != decl_var_symbol)  return NULL;</a>
<a name="12768"><span class="lineNum">   12768 </span><span class="lineNoCov">          0 :     if (assign_op_var-&gt;get_symbol() != decl_var_symbol)  return false;</span></a>
<a name="12769"><span class="lineNum">   12769 </span>            :   }</a>
<a name="12770"><span class="lineNum">   12770 </span>            :   else</a>
<a name="12771"><span class="lineNum">   12771 </span>            :   { // fallback to comparing variable names instead</a>
<a name="12772"><span class="lineNum">   12772 </span>            :     // DQ (3/25/2017): Fixed Clang warning: warning: implicit conversion of NULL constant to 'bool' [-Wnull-conversion]</a>
<a name="12773"><span class="lineNum">   12773 </span>            :     // if (assign_op_var-&gt;get_symbol()-&gt;get_name() != decl_var -&gt;get_name()) return NULL;</a>
<a name="12774"><span class="lineNum">   12774 </span><span class="lineNoCov">          0 :     if (assign_op_var-&gt;get_symbol()-&gt;get_name() != decl_var -&gt;get_name()) return false;</span></a>
<a name="12775"><span class="lineNum">   12775 </span>            :   }</a>
<a name="12776"><span class="lineNum">   12776 </span>            : </a>
<a name="12777"><span class="lineNum">   12777 </span>            :   // Everything looks fine now. Do the merge.</a>
<a name="12778"><span class="lineNum">   12778 </span><span class="lineNoCov">          0 :   SgExpression * rhs_copy = SageInterface::copyExpression(assign_op-&gt;get_rhs_operand());</span></a>
<a name="12779"><span class="lineNum">   12779 </span>            : </a>
<a name="12780"><span class="lineNum">   12780 </span>            :   // Must preserve the proprecessing information of the original assign_stmt</a>
<a name="12781"><span class="lineNum">   12781 </span>            :   // use appending (not prepending) so the order of decl's comments and assign_stmt's comments can be preserved</a>
<a name="12782"><span class="lineNum">   12782 </span><span class="lineNoCov">          0 :    SageInterface::movePreprocessingInfo(assign_stmt, decl, PreprocessingInfo::before, PreprocessingInfo::before, false);</span></a>
<a name="12783"><span class="lineNum">   12783 </span>            : </a>
<a name="12784"><span class="lineNum">   12784 </span>            :   // removeStatement() does not support removing a statement which is not inside a container.</a>
<a name="12785"><span class="lineNum">   12785 </span>            :   // But sometimes we do need to remove such a statement and replace it with a new one.</a>
<a name="12786"><span class="lineNum">   12786 </span>            :   // As a workaround, we allow users to optionally disabling removing here and handle the removal on their own.</a>
<a name="12787"><span class="lineNum">   12787 </span>            :   // TODO: improve removeStatement() which uses low level rewritting.</a>
<a name="12788"><span class="lineNum">   12788 </span><span class="lineNoCov">          0 :   if (removeAssignStmt)</span></a>
<a name="12789"><span class="lineNum">   12789 </span><span class="lineNoCov">          0 :     SageInterface::removeStatement (assign_stmt);</span></a>
<a name="12790"><span class="lineNum">   12790 </span>            : //  SageInterface::deepDelete (assign_stmt);</a>
<a name="12791"><span class="lineNum">   12791 </span><span class="lineNoCov">          0 :   SgAssignInitializer * initor = SageBuilder::buildAssignInitializer (rhs_copy);</span></a>
<a name="12792"><span class="lineNum">   12792 </span><span class="lineNoCov">          0 :   decl_var-&gt;set_initptr(initor);</span></a>
<a name="12793"><span class="lineNum">   12793 </span><span class="lineNoCov">          0 :   initor-&gt;set_parent(decl_var);</span></a>
<a name="12794"><span class="lineNum">   12794 </span>            : </a>
<a name="12795"><span class="lineNum">   12795 </span><span class="lineNoCov">          0 :   return rt;</span></a>
<a name="12796"><span class="lineNum">   12796 </span>            : }</a>
<a name="12797"><span class="lineNum">   12797 </span>            : </a>
<a name="12798"><span class="lineNum">   12798 </span><span class="lineNoCov">          0 : bool SageInterface::mergeDeclarationWithAssignment(SgVariableDeclaration* decl, SgExprStatement* assign_stmt)</span></a>
<a name="12799"><span class="lineNum">   12799 </span>            : {</a>
<a name="12800"><span class="lineNum">   12800 </span><span class="lineNoCov">          0 :   bool rt= true;</span></a>
<a name="12801"><span class="lineNum">   12801 </span>            : </a>
<a name="12802"><span class="lineNum">   12802 </span>            :   // Sanity check of assign statement: must be a form of var = xxx;</a>
<a name="12803"><span class="lineNum">   12803 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(assign_stmt != NULL);</span></a>
<a name="12804"><span class="lineNum">   12804 </span><span class="lineNoCov">          0 :   SgAssignOp * assign_op = isSgAssignOp (assign_stmt-&gt;get_expression());</span></a>
<a name="12805"><span class="lineNum">   12805 </span><span class="lineNoCov">          0 :   if (assign_op == NULL)</span></a>
<a name="12806"><span class="lineNum">   12806 </span>            :     return false;</a>
<a name="12807"><span class="lineNum">   12807 </span><span class="lineNoCov">          0 :   SgVarRefExp* assign_op_var = isSgVarRefExp(assign_op-&gt;get_lhs_operand());</span></a>
<a name="12808"><span class="lineNum">   12808 </span><span class="lineNoCov">          0 :   if (assign_op_var == NULL)</span></a>
<a name="12809"><span class="lineNum">   12809 </span>            :     return false;</a>
<a name="12810"><span class="lineNum">   12810 </span>            : </a>
<a name="12811"><span class="lineNum">   12811 </span>            :   // Sanity check of the variable declaration: it should not have an existing initializer</a>
<a name="12812"><span class="lineNum">   12812 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(decl != NULL);</span></a>
<a name="12813"><span class="lineNum">   12813 </span><span class="lineNoCov">          0 :   SgInitializedName * decl_var = SageInterface::getFirstInitializedName (decl);</span></a>
<a name="12814"><span class="lineNum">   12814 </span><span class="lineNoCov">          0 :   if (decl_var-&gt;get_initptr()!= NULL)</span></a>
<a name="12815"><span class="lineNum">   12815 </span>            :      return false;</a>
<a name="12816"><span class="lineNum">   12816 </span>            : </a>
<a name="12817"><span class="lineNum">   12817 </span>            :   // check if two variables match</a>
<a name="12818"><span class="lineNum">   12818 </span>            :   // In translation, it is possible the declaration has not yet been inserted into its scope.</a>
<a name="12819"><span class="lineNum">   12819 </span>            :   // finding its symbol can return NULL.</a>
<a name="12820"><span class="lineNum">   12820 </span>            :   // But we still want to do the merge.</a>
<a name="12821"><span class="lineNum">   12821 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(decl_var != NULL);</span></a>
<a name="12822"><span class="lineNum">   12822 </span><span class="lineNoCov">          0 :   SgSymbol* decl_var_symbol = decl_var-&gt;get_symbol_from_symbol_table();</span></a>
<a name="12823"><span class="lineNum">   12823 </span><span class="lineNoCov">          0 :   if (decl_var_symbol != NULL) {</span></a>
<a name="12824"><span class="lineNum">   12824 </span>            :     // DQ (3/25/2017): Fixed Clang warning: warning: implicit conversion of NULL constant to 'bool' [-Wnull-conversion]</a>
<a name="12825"><span class="lineNum">   12825 </span>            :     // if (assign_op_var-&gt;get_symbol() != decl_var_symbol)</a>
<a name="12826"><span class="lineNum">   12826 </span>            :     //    return NULL;</a>
<a name="12827"><span class="lineNum">   12827 </span><span class="lineNoCov">          0 :     if (assign_op_var-&gt;get_symbol() != decl_var_symbol)</span></a>
<a name="12828"><span class="lineNum">   12828 </span>            :        return false;</a>
<a name="12829"><span class="lineNum">   12829 </span>            :   }</a>
<a name="12830"><span class="lineNum">   12830 </span>            :   else</a>
<a name="12831"><span class="lineNum">   12831 </span>            :   { // fallback to comparing variable names instead</a>
<a name="12832"><span class="lineNum">   12832 </span>            :     // DQ (3/25/2017): Fixed Clang warning: warning: implicit conversion of NULL constant to 'bool' [-Wnull-conversion]</a>
<a name="12833"><span class="lineNum">   12833 </span>            :     // if (assign_op_var-&gt;get_symbol()-&gt;get_name() != decl_var -&gt;get_name()) return NULL;</a>
<a name="12834"><span class="lineNum">   12834 </span><span class="lineNoCov">          0 :     if (assign_op_var-&gt;get_symbol()-&gt;get_name() != decl_var -&gt;get_name())</span></a>
<a name="12835"><span class="lineNum">   12835 </span>            :        return false;</a>
<a name="12836"><span class="lineNum">   12836 </span>            :   }</a>
<a name="12837"><span class="lineNum">   12837 </span>            : </a>
<a name="12838"><span class="lineNum">   12838 </span>            :   // Everything looks fine now. Do the merge.</a>
<a name="12839"><span class="lineNum">   12839 </span>            :   // It is implemented by</a>
<a name="12840"><span class="lineNum">   12840 </span>            :   // 1. copy rhs to the decl's rhs,</a>
<a name="12841"><span class="lineNum">   12841 </span>            :   // 2. then move the decl to the place of the assignment,</a>
<a name="12842"><span class="lineNum">   12842 </span>            :   // 3. then remove the assignment</a>
<a name="12843"><span class="lineNum">   12843 </span>            :   //</a>
<a name="12844"><span class="lineNum">   12844 </span>            :   // Copy rhs to be initializer</a>
<a name="12845"><span class="lineNum">   12845 </span><span class="lineNoCov">          0 :   SgExpression * rhs_copy = SageInterface::copyExpression(assign_op-&gt;get_rhs_operand());</span></a>
<a name="12846"><span class="lineNum">   12846 </span><span class="lineNoCov">          0 :   SgAssignInitializer * initor = SageBuilder::buildAssignInitializer (rhs_copy);</span></a>
<a name="12847"><span class="lineNum">   12847 </span><span class="lineNoCov">          0 :   decl_var-&gt;set_initptr(initor);</span></a>
<a name="12848"><span class="lineNum">   12848 </span><span class="lineNoCov">          0 :   initor-&gt;set_parent(decl_var);</span></a>
<a name="12849"><span class="lineNum">   12849 </span>            : </a>
<a name="12850"><span class="lineNum">   12850 </span>            :   // move proprocessing info. attached before decl to its next statement's front, using prepending to preserve the original order</a>
<a name="12851"><span class="lineNum">   12851 </span><span class="lineNoCov">          0 :   SgStatement* next_stmt = SageInterface::getNextStatement (decl);</span></a>
<a name="12852"><span class="lineNum">   12852 </span><span class="lineNoCov">          0 :   SageInterface::movePreprocessingInfo(decl, next_stmt, PreprocessingInfo::before, PreprocessingInfo::before, true);</span></a>
<a name="12853"><span class="lineNum">   12853 </span>            : </a>
<a name="12854"><span class="lineNum">   12854 </span>            :   // removeStatement() does not support removing a statement which is not inside a container.</a>
<a name="12855"><span class="lineNum">   12855 </span>            :   // But sometimes we do need to remove such a statement and replace it with a new one.</a>
<a name="12856"><span class="lineNum">   12856 </span>            :   // As a workaround, we allow users to optionally disabling removing here and handle the removal on their own.</a>
<a name="12857"><span class="lineNum">   12857 </span>            :   // TODO: improve removeStatement() which uses low level rewritting.</a>
<a name="12858"><span class="lineNum">   12858 </span>            : </a>
<a name="12859"><span class="lineNum">   12859 </span>            :   // Now move the declaration to a new position, right before the assignment statement</a>
<a name="12860"><span class="lineNum">   12860 </span><span class="lineNoCov">          0 :   SageInterface::removeStatement (decl);</span></a>
<a name="12861"><span class="lineNum">   12861 </span><span class="lineNoCov">          0 :   SageInterface::insertStatementBefore(assign_stmt, decl, false);</span></a>
<a name="12862"><span class="lineNum">   12862 </span>            : </a>
<a name="12863"><span class="lineNum">   12863 </span>            :   // preserve preprocessing info. attached to assign_stmt before removing it  , using append (last false)</a>
<a name="12864"><span class="lineNum">   12864 </span><span class="lineNoCov">          0 :   SageInterface::movePreprocessingInfo(assign_stmt, decl, PreprocessingInfo::before, PreprocessingInfo::before, false);</span></a>
<a name="12865"><span class="lineNum">   12865 </span>            : </a>
<a name="12866"><span class="lineNum">   12866 </span>            :   // Original assignment statement should be removed</a>
<a name="12867"><span class="lineNum">   12867 </span><span class="lineNoCov">          0 :   SageInterface::removeStatement (assign_stmt);</span></a>
<a name="12868"><span class="lineNum">   12868 </span>            :   //  SageInterface::deepDelete (decl);</a>
<a name="12869"><span class="lineNum">   12869 </span>            : </a>
<a name="12870"><span class="lineNum">   12870 </span><span class="lineNoCov">          0 :   return rt;</span></a>
<a name="12871"><span class="lineNum">   12871 </span>            : }</a>
<a name="12872"><span class="lineNum">   12872 </span>            : // Split a variable declaration with an rhs assignment into two statements: a declaration and an assignment.</a>
<a name="12873"><span class="lineNum">   12873 </span>            : // Return the generated assignment statement, if any</a>
<a name="12874"><span class="lineNum">   12874 </span><span class="lineNoCov">          0 : SgExprStatement* SageInterface::splitVariableDeclaration (SgVariableDeclaration* decl)</span></a>
<a name="12875"><span class="lineNum">   12875 </span>            : {</a>
<a name="12876"><span class="lineNum">   12876 </span><span class="lineNoCov">          0 :   SgExprStatement* rt = NULL;</span></a>
<a name="12877"><span class="lineNum">   12877 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (decl != NULL);</span></a>
<a name="12878"><span class="lineNum">   12878 </span>            : </a>
<a name="12879"><span class="lineNum">   12879 </span><span class="lineNoCov">          0 :   SgInitializedName * decl_var = SageInterface::getFirstInitializedName (decl);</span></a>
<a name="12880"><span class="lineNum">   12880 </span><span class="lineNoCov">          0 :   SgInitializer* initor = decl_var -&gt;get_initptr();</span></a>
<a name="12881"><span class="lineNum">   12881 </span><span class="lineNoCov">          0 :   if (initor == NULL)</span></a>
<a name="12882"><span class="lineNum">   12882 </span>            :     rt = NULL;</a>
<a name="12883"><span class="lineNum">   12883 </span>            :   else</a>
<a name="12884"><span class="lineNum">   12884 </span>            :   {</a>
<a name="12885"><span class="lineNum">   12885 </span>            :     // Liao, 2021/10/21, we have to support all sorts of initializers, including aggregate initializer</a>
<a name="12886"><span class="lineNum">   12886 </span><span class="lineNoCov">          0 :     SgExpression * rhs=NULL;</span></a>
<a name="12887"><span class="lineNum">   12887 </span><span class="lineNoCov">          0 :     if (SgAssignInitializer * ainitor = isSgAssignInitializer (initor))</span></a>
<a name="12888"><span class="lineNum">   12888 </span><span class="lineNoCov">          0 :       rhs = ainitor-&gt;get_operand();</span></a>
<a name="12889"><span class="lineNum">   12889 </span>            :     else</a>
<a name="12890"><span class="lineNum">   12890 </span>            :       rhs = initor;</a>
<a name="12891"><span class="lineNum">   12891 </span>            : </a>
<a name="12892"><span class="lineNum">   12892 </span>            :     // we deep copy the rhs operand</a>
<a name="12893"><span class="lineNum">   12893 </span><span class="lineNoCov">          0 :     rt = buildAssignStatement (buildVarRefExp(decl_var) , deepCopy(rhs));</span></a>
<a name="12894"><span class="lineNum">   12894 </span><span class="lineNoCov">          0 :     decl_var-&gt;set_initptr(NULL);</span></a>
<a name="12895"><span class="lineNum">   12895 </span>            :     //TODO clean up initor</a>
<a name="12896"><span class="lineNum">   12896 </span><span class="lineNoCov">          0 :     insertStatementAfter ( decl, rt );</span></a>
<a name="12897"><span class="lineNum">   12897 </span>            :   }</a>
<a name="12898"><span class="lineNum">   12898 </span><span class="lineNoCov">          0 :   return rt;</span></a>
<a name="12899"><span class="lineNum">   12899 </span>            : }</a>
<a name="12900"><span class="lineNum">   12900 </span>            : //! Split declarations within a scope into declarations and assignment statements, by default only top level declarations are considered.</a>
<a name="12901"><span class="lineNum">   12901 </span><span class="lineCov">       2271 : ROSE_DLL_API int SageInterface::splitVariableDeclaration (SgScopeStatement* scope, bool topLevelOnly /* = true */)</span></a>
<a name="12902"><span class="lineNum">   12902 </span>            : {</a>
<a name="12903"><span class="lineNum">   12903 </span><span class="lineCov">       2271 :   int count = 0;</span></a>
<a name="12904"><span class="lineNum">   12904 </span><span class="lineCov">       2271 :   if (!topLevelOnly)</span></a>
<a name="12905"><span class="lineNum">   12905 </span>            :   {</a>
<a name="12906"><span class="lineNum">   12906 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;SageInterface::splitVariableDeclaration() topLevelOnly == false is not yet implemented.&quot;&lt;&lt;endl;</span></a>
<a name="12907"><span class="lineNum">   12907 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (false);</span></a>
<a name="12908"><span class="lineNum">   12908 </span>            :   }</a>
<a name="12909"><span class="lineNum">   12909 </span>            : </a>
<a name="12910"><span class="lineNum">   12910 </span><span class="lineCov">       2271 :   Rose_STL_Container&lt;SgNode*&gt; nodeList = NodeQuery::querySubTree(scope, V_SgVariableDeclaration);</span></a>
<a name="12911"><span class="lineNum">   12911 </span><span class="lineCov">       3885 :   for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i != nodeList.end(); i++)</span></a>
<a name="12912"><span class="lineNum">   12912 </span>            :   {</a>
<a name="12913"><span class="lineNum">   12913 </span><span class="lineCov">       1614 :     SgVariableDeclaration *decl= isSgVariableDeclaration(*i);</span></a>
<a name="12914"><span class="lineNum">   12914 </span><span class="lineCov">       1614 :     if (topLevelOnly)</span></a>
<a name="12915"><span class="lineNum">   12915 </span>            :     {</a>
<a name="12916"><span class="lineNum">   12916 </span><span class="lineCov">       1614 :       ROSE_ASSERT(decl != NULL);</span></a>
<a name="12917"><span class="lineNum">   12917 </span><span class="lineCov">       1614 :       if (decl-&gt;get_scope() == scope)</span></a>
<a name="12918"><span class="lineNum">   12918 </span>            :       {</a>
<a name="12919"><span class="lineNum">   12919 </span><span class="lineNoCov">          0 :         splitVariableDeclaration (decl);</span></a>
<a name="12920"><span class="lineNum">   12920 </span><span class="lineNoCov">          0 :         count ++;</span></a>
<a name="12921"><span class="lineNum">   12921 </span>            :       }</a>
<a name="12922"><span class="lineNum">   12922 </span>            :     }</a>
<a name="12923"><span class="lineNum">   12923 </span>            :   }</a>
<a name="12924"><span class="lineNum">   12924 </span><span class="lineCov">       2759 :   return count;</span></a>
<a name="12925"><span class="lineNum">   12925 </span>            : }</a>
<a name="12926"><span class="lineNum">   12926 </span>            : </a>
<a name="12927"><span class="lineNum">   12927 </span><span class="lineCov">         60 : void SageInterface::collectVarRefs(SgLocatedNode* root, std::vector&lt;SgVarRefExp* &gt; &amp; result)</span></a>
<a name="12928"><span class="lineNum">   12928 </span>            : {</a>
<a name="12929"><span class="lineNum">   12929 </span><span class="lineCov">         60 :   ROSE_ASSERT (root != NULL);</span></a>
<a name="12930"><span class="lineNum">   12930 </span>            : //  std::vector&lt;SgVarRefExp* &gt; result;</a>
<a name="12931"><span class="lineNum">   12931 </span>            : </a>
<a name="12932"><span class="lineNum">   12932 </span><span class="lineCov">         60 :   Rose_STL_Container&lt;SgNode*&gt; nodeList = NodeQuery::querySubTree(root, V_SgVarRefExp);</span></a>
<a name="12933"><span class="lineNum">   12933 </span>            :   // AST query won't find variables used in types</a>
<a name="12934"><span class="lineNum">   12934 </span><span class="lineCov">         60 :   collectVariableReferencesInArrayTypes (root, nodeList);</span></a>
<a name="12935"><span class="lineNum">   12935 </span>            : </a>
<a name="12936"><span class="lineNum">   12936 </span><span class="lineCov">         63 :   for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i != nodeList.end(); i++)</span></a>
<a name="12937"><span class="lineNum">   12937 </span>            :   {</a>
<a name="12938"><span class="lineNum">   12938 </span><span class="lineCov">          3 :     SgVarRefExp *vRef = isSgVarRefExp(*i);</span></a>
<a name="12939"><span class="lineNum">   12939 </span><span class="lineCov">          3 :     ROSE_ASSERT (vRef != NULL);</span></a>
<a name="12940"><span class="lineNum">   12940 </span><span class="lineCov">          3 :     result.push_back(vRef);</span></a>
<a name="12941"><span class="lineNum">   12941 </span>            :   }</a>
<a name="12942"><span class="lineNum">   12942 </span><span class="lineCov">         60 : }</span></a>
<a name="12943"><span class="lineNum">   12943 </span>            : </a>
<a name="12944"><span class="lineNum">   12944 </span><span class="lineCov">       2331 : int SageInterface::collectVariableReferencesInArrayTypes(SgLocatedNode* root, Rose_STL_Container&lt;SgNode*&gt; &amp; currentVarRefList)</span></a>
<a name="12945"><span class="lineNum">   12945 </span>            : {</a>
<a name="12946"><span class="lineNum">   12946 </span><span class="lineCov">       2331 :   int rt = 0;</span></a>
<a name="12947"><span class="lineNum">   12947 </span><span class="lineCov">       2331 :   ROSE_ASSERT (root != NULL);</span></a>
<a name="12948"><span class="lineNum">   12948 </span><span class="lineCov">       2331 :   Rose_STL_Container&lt;SgNode*&gt; constructorList= NodeQuery::querySubTree(root, V_SgConstructorInitializer);</span></a>
<a name="12949"><span class="lineNum">   12949 </span><span class="lineCov">       2698 :   for (size_t i =0; i&lt; constructorList.size(); i++)</span></a>
<a name="12950"><span class="lineNum">   12950 </span>            :   {</a>
<a name="12951"><span class="lineNum">   12951 </span><span class="lineCov">        367 :     SgConstructorInitializer * c_init = isSgConstructorInitializer (constructorList[i]);</span></a>
<a name="12952"><span class="lineNum">   12952 </span><span class="lineCov">        367 :     if (SgArrayType* a_type = isSgArrayType(c_init-&gt;get_expression_type()))</span></a>
<a name="12953"><span class="lineNum">   12953 </span>            :     {</a>
<a name="12954"><span class="lineNum">   12954 </span><span class="lineCov">         12 :       Rose_STL_Container&lt;SgNode*&gt; varList = NodeQuery::querySubTree (a_type-&gt;get_index(),V_SgVarRefExp);</span></a>
<a name="12955"><span class="lineNum">   12955 </span><span class="lineCov">         12 :       for (size_t j =0 ; j&lt; varList.size(); j++)</span></a>
<a name="12956"><span class="lineNum">   12956 </span>            :       {</a>
<a name="12957"><span class="lineNum">   12957 </span><span class="lineCov">          6 :         SgVarRefExp* var_exp =  isSgVarRefExp(varList[j]) ;</span></a>
<a name="12958"><span class="lineNum">   12958 </span>            : //        if (debug)</a>
<a name="12959"><span class="lineNum">   12959 </span>            : //        {</a>
<a name="12960"><span class="lineNum">   12960 </span>            : //          cout&lt;&lt;&quot;Found a var ref in array type:&quot;&lt;&lt;var_exp-&gt;get_symbol()-&gt;get_name()&lt;&lt;endl;</a>
<a name="12961"><span class="lineNum">   12961 </span>            : //        }</a>
<a name="12962"><span class="lineNum">   12962 </span><span class="lineCov">          6 :         currentVarRefList.push_back(var_exp);</span></a>
<a name="12963"><span class="lineNum">   12963 </span>            : //TODO: these variable references do have special scopes, how to communicate to users?</a>
<a name="12964"><span class="lineNum">   12964 </span>            : //        specialVarRefScopeExp[var_exp] = c_init ;</a>
<a name="12965"><span class="lineNum">   12965 </span><span class="lineCov">          6 :         rt ++;</span></a>
<a name="12966"><span class="lineNum">   12966 </span>            :       }</a>
<a name="12967"><span class="lineNum">   12967 </span>            :     }</a>
<a name="12968"><span class="lineNum">   12968 </span>            :   }</a>
<a name="12969"><span class="lineNum">   12969 </span><span class="lineCov">       2634 :   return rt;</span></a>
<a name="12970"><span class="lineNum">   12970 </span>            : }</a>
<a name="12971"><span class="lineNum">   12971 </span>            : </a>
<a name="12972"><span class="lineNum">   12972 </span>            : namespace SageInterface { // A few internal helper classes</a>
<a name="12973"><span class="lineNum">   12973 </span>            : </a>
<a name="12974"><span class="lineNum">   12974 </span>            : class AndOpGenerator: public StatementGenerator</a>
<a name="12975"><span class="lineNum">   12975 </span>            :    {</a>
<a name="12976"><span class="lineNum">   12976 </span>            :      SgAndOp* op;</a>
<a name="12977"><span class="lineNum">   12977 </span>            : </a>
<a name="12978"><span class="lineNum">   12978 </span>            :      public:</a>
<a name="12979"><span class="lineNum">   12979 </span><span class="lineNoCov">          0 :           AndOpGenerator(SgAndOp* op): op(op) {}</span></a>
<a name="12980"><span class="lineNum">   12980 </span>            : </a>
<a name="12981"><span class="lineNum">   12981 </span><span class="lineNoCov">          0 :           virtual SgStatement* generate(SgExpression* lhs)</span></a>
<a name="12982"><span class="lineNum">   12982 </span>            :              {</a>
<a name="12983"><span class="lineNum">   12983 </span><span class="lineNoCov">          0 :                SgTreeCopy treeCopy;</span></a>
<a name="12984"><span class="lineNum">   12984 </span><span class="lineNoCov">          0 :                SgExpression* lhsCopy = isSgExpression(lhs-&gt;copy(treeCopy));</span></a>
<a name="12985"><span class="lineNum">   12985 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (lhsCopy);</span></a>
<a name="12986"><span class="lineNum">   12986 </span><span class="lineNoCov">          0 :                SgIfStmt* tree =</span></a>
<a name="12987"><span class="lineNum">   12987 </span><span class="lineNoCov">          0 :                  SageBuilder::buildIfStmt(</span></a>
<a name="12988"><span class="lineNum">   12988 </span><span class="lineNoCov">          0 :                      SageBuilder::buildExprStatement(op-&gt;get_lhs_operand()),</span></a>
<a name="12989"><span class="lineNum">   12989 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="12990"><span class="lineNum">   12990 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhs, op-&gt;get_rhs_operand())),</span></a>
<a name="12991"><span class="lineNum">   12991 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="12992"><span class="lineNum">   12992 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhsCopy, SageBuilder::buildBoolValExp(false))));</span></a>
<a name="12993"><span class="lineNum">   12993 </span><span class="lineNoCov">          0 :                return tree;</span></a>
<a name="12994"><span class="lineNum">   12994 </span>            :              }</a>
<a name="12995"><span class="lineNum">   12995 </span>            :    };</a>
<a name="12996"><span class="lineNum">   12996 </span>            : </a>
<a name="12997"><span class="lineNum">   12997 </span>            : class OrOpGenerator: public StatementGenerator</a>
<a name="12998"><span class="lineNum">   12998 </span>            :    {</a>
<a name="12999"><span class="lineNum">   12999 </span>            :      SgOrOp* op;</a>
<a name="13000"><span class="lineNum">   13000 </span>            : </a>
<a name="13001"><span class="lineNum">   13001 </span>            :      public:</a>
<a name="13002"><span class="lineNum">   13002 </span><span class="lineNoCov">          0 :           OrOpGenerator(SgOrOp* op): op(op) {}</span></a>
<a name="13003"><span class="lineNum">   13003 </span>            : </a>
<a name="13004"><span class="lineNum">   13004 </span><span class="lineNoCov">          0 :           virtual SgStatement* generate(SgExpression* lhs)</span></a>
<a name="13005"><span class="lineNum">   13005 </span>            :              {</a>
<a name="13006"><span class="lineNum">   13006 </span><span class="lineNoCov">          0 :                SgTreeCopy treeCopy;</span></a>
<a name="13007"><span class="lineNum">   13007 </span><span class="lineNoCov">          0 :                SgExpression* lhsCopy = isSgExpression(lhs-&gt;copy(treeCopy));</span></a>
<a name="13008"><span class="lineNum">   13008 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (lhsCopy);</span></a>
<a name="13009"><span class="lineNum">   13009 </span><span class="lineNoCov">          0 :                SgIfStmt* tree =</span></a>
<a name="13010"><span class="lineNum">   13010 </span><span class="lineNoCov">          0 :                  SageBuilder::buildIfStmt(</span></a>
<a name="13011"><span class="lineNum">   13011 </span><span class="lineNoCov">          0 :                      SageBuilder::buildExprStatement(op-&gt;get_lhs_operand()),</span></a>
<a name="13012"><span class="lineNum">   13012 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="13013"><span class="lineNum">   13013 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhs, SageBuilder::buildBoolValExp(true))),</span></a>
<a name="13014"><span class="lineNum">   13014 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="13015"><span class="lineNum">   13015 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhsCopy, op-&gt;get_rhs_operand())));</span></a>
<a name="13016"><span class="lineNum">   13016 </span><span class="lineNoCov">          0 :                return tree;</span></a>
<a name="13017"><span class="lineNum">   13017 </span>            :              }</a>
<a name="13018"><span class="lineNum">   13018 </span>            :    };</a>
<a name="13019"><span class="lineNum">   13019 </span>            : </a>
<a name="13020"><span class="lineNum">   13020 </span>            : class ConditionalExpGenerator: public StatementGenerator</a>
<a name="13021"><span class="lineNum">   13021 </span>            :    {</a>
<a name="13022"><span class="lineNum">   13022 </span>            :      SgConditionalExp* op;</a>
<a name="13023"><span class="lineNum">   13023 </span>            : </a>
<a name="13024"><span class="lineNum">   13024 </span>            :      public:</a>
<a name="13025"><span class="lineNum">   13025 </span><span class="lineNoCov">          0 :           ConditionalExpGenerator(SgConditionalExp* op): op(op) {}</span></a>
<a name="13026"><span class="lineNum">   13026 </span>            : </a>
<a name="13027"><span class="lineNum">   13027 </span><span class="lineNoCov">          0 :           virtual SgStatement* generate(SgExpression* lhs)</span></a>
<a name="13028"><span class="lineNum">   13028 </span>            :              {</a>
<a name="13029"><span class="lineNum">   13029 </span><span class="lineNoCov">          0 :                SgTreeCopy treeCopy;</span></a>
<a name="13030"><span class="lineNum">   13030 </span><span class="lineNoCov">          0 :                SgExpression* lhsCopy = isSgExpression(lhs-&gt;copy(treeCopy));</span></a>
<a name="13031"><span class="lineNum">   13031 </span><span class="lineNoCov">          0 :                ROSE_ASSERT (lhsCopy);</span></a>
<a name="13032"><span class="lineNum">   13032 </span><span class="lineNoCov">          0 :                SgIfStmt* tree =</span></a>
<a name="13033"><span class="lineNum">   13033 </span><span class="lineNoCov">          0 :                  SageBuilder::buildIfStmt(</span></a>
<a name="13034"><span class="lineNum">   13034 </span><span class="lineNoCov">          0 :                      SageBuilder::buildExprStatement(op-&gt;get_conditional_exp()),</span></a>
<a name="13035"><span class="lineNum">   13035 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="13036"><span class="lineNum">   13036 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhs, op-&gt;get_true_exp())),</span></a>
<a name="13037"><span class="lineNum">   13037 </span><span class="lineNoCov">          0 :                      SageBuilder::buildBasicBlock(</span></a>
<a name="13038"><span class="lineNum">   13038 </span><span class="lineNoCov">          0 :                        SageBuilder::buildAssignStatement(lhsCopy, op-&gt;get_false_exp())));</span></a>
<a name="13039"><span class="lineNum">   13039 </span><span class="lineNoCov">          0 :                return tree;</span></a>
<a name="13040"><span class="lineNum">   13040 </span>            :              }</a>
<a name="13041"><span class="lineNum">   13041 </span>            :    };</a>
<a name="13042"><span class="lineNum">   13042 </span>            : </a>
<a name="13043"><span class="lineNum">   13043 </span>            : } // end of namespace for the helper classes</a>
<a name="13044"><span class="lineNum">   13044 </span>            : </a>
<a name="13045"><span class="lineNum">   13045 </span>            : //! Merged from replaceExpressionWithStatement.C</a>
<a name="13046"><span class="lineNum">   13046 </span><span class="lineCov">          2 : SgAssignInitializer* SageInterface::splitExpression(SgExpression* from, string newName/* =&quot;&quot; */)</span></a>
<a name="13047"><span class="lineNum">   13047 </span>            : {</a>
<a name="13048"><span class="lineNum">   13048 </span><span class="lineCov">          2 :   ROSE_ASSERT(from != NULL);</span></a>
<a name="13049"><span class="lineNum">   13049 </span>            : </a>
<a name="13050"><span class="lineNum">   13050 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="13051"><span class="lineNum">   13051 </span>            : #if 0  // This is not accurate for template class specializations. We disable this assertion for now. The worst case is compilation error later.</a>
<a name="13052"><span class="lineNum">   13052 </span>            :   if (!SageInterface::isCopyConstructible(from-&gt;get_type())) {</a>
<a name="13053"><span class="lineNum">   13053 </span>            :     std::cerr &lt;&lt; &quot;Type &quot; &lt;&lt; from-&gt;get_type()-&gt;unparseToString() &lt;&lt; &quot; of expression &quot; &lt;&lt; from-&gt;unparseToString() &lt;&lt; &quot; is not copy constructible&quot; &lt;&lt; std::endl;</a>
<a name="13054"><span class="lineNum">   13054 </span>            :     ROSE_ASSERT (false);</a>
<a name="13055"><span class="lineNum">   13055 </span>            :   }</a>
<a name="13056"><span class="lineNum">   13056 </span>            : </a>
<a name="13057"><span class="lineNum">   13057 </span>            :   assert (SageInterface::isCopyConstructible(from-&gt;get_type())); // How do we report errors?</a>
<a name="13058"><span class="lineNum">   13058 </span>            : #endif</a>
<a name="13059"><span class="lineNum">   13059 </span><span class="lineCov">          2 :   SgStatement* stmt = getStatementOfExpression(from);</span></a>
<a name="13060"><span class="lineNum">   13060 </span><span class="lineCov">          2 :   assert (stmt);</span></a>
<a name="13061"><span class="lineNum">   13061 </span><span class="lineCov">          2 :   if (!isSgForInitStatement(stmt-&gt;get_parent())) {</span></a>
<a name="13062"><span class="lineNum">   13062 </span>            :     //SageInterface::ensureBasicBlockAsParent(stmt);</a>
<a name="13063"><span class="lineNum">   13063 </span>            :     // no return value is accepted. Only the optional transformation matters</a>
<a name="13064"><span class="lineNum">   13064 </span><span class="lineCov">          2 :     if (isBodyStatement(stmt) &amp;&amp; !isSgBasicBlock(stmt))</span></a>
<a name="13065"><span class="lineNum">   13065 </span><span class="lineCov">          2 :       makeSingleStatementBodyToBlock (stmt);</span></a>
<a name="13066"><span class="lineNum">   13066 </span>            :   }</a>
<a name="13067"><span class="lineNum">   13067 </span>            : </a>
<a name="13068"><span class="lineNum">   13068 </span><span class="lineCov">          2 :   SgScopeStatement* parent = isSgScopeStatement(stmt-&gt;get_parent());</span></a>
<a name="13069"><span class="lineNum">   13069 </span>            :   // cout &lt;&lt; &quot;parent is a &quot; &lt;&lt; (parent ? parent-&gt;sage_class_name() : &quot;NULL&quot;) &lt;&lt; endl;</a>
<a name="13070"><span class="lineNum">   13070 </span><span class="lineCov">          2 :   if (!parent &amp;&amp; isSgForInitStatement(stmt-&gt;get_parent()))</span></a>
<a name="13071"><span class="lineNum">   13071 </span><span class="lineNoCov">          0 :     parent = isSgScopeStatement(stmt-&gt;get_parent()-&gt;get_parent()-&gt;get_parent());</span></a>
<a name="13072"><span class="lineNum">   13072 </span><span class="lineCov">          2 :   assert (parent);</span></a>
<a name="13073"><span class="lineNum">   13073 </span>            :   // cout &lt;&lt; &quot;parent is a &quot; &lt;&lt; parent-&gt;sage_class_name() &lt;&lt; endl;</a>
<a name="13074"><span class="lineNum">   13074 </span>            :   // cout &lt;&lt; &quot;parent is &quot; &lt;&lt; parent-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="13075"><span class="lineNum">   13075 </span>            :   // cout &lt;&lt; &quot;stmt is &quot; &lt;&lt; stmt-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="13076"><span class="lineNum">   13076 </span><span class="lineCov">          2 :   SgName varname = &quot;rose_temp__&quot;;</span></a>
<a name="13077"><span class="lineNum">   13077 </span><span class="lineCov">          2 :   if (newName == &quot;&quot;) {</span></a>
<a name="13078"><span class="lineNum">   13078 </span><span class="lineCov">          2 :     varname &lt;&lt; ++SageInterface::gensym_counter;</span></a>
<a name="13079"><span class="lineNum">   13079 </span>            :   } else {</a>
<a name="13080"><span class="lineNum">   13080 </span><span class="lineNoCov">          0 :     varname = newName;</span></a>
<a name="13081"><span class="lineNum">   13081 </span>            :   }</a>
<a name="13082"><span class="lineNum">   13082 </span>            : </a>
<a name="13083"><span class="lineNum">   13083 </span><span class="lineCov">          2 :   SgType* vartype = from-&gt;get_type();</span></a>
<a name="13084"><span class="lineNum">   13084 </span><span class="lineCov">          2 :   SgNode* fromparent = from-&gt;get_parent();</span></a>
<a name="13085"><span class="lineNum">   13085 </span><span class="lineCov">          4 :   vector&lt;SgExpression*&gt; ancestors;</span></a>
<a name="13086"><span class="lineNum">   13086 </span><span class="lineCov">          2 :   for (SgExpression *expr = from, *anc = isSgExpression(fromparent); anc != 0;</span></a>
<a name="13087"><span class="lineNum">   13087 </span><span class="lineNoCov">          0 :       expr = anc, anc = isSgExpression(anc-&gt;get_parent()))</span></a>
<a name="13088"><span class="lineNum">   13088 </span>            :   {</a>
<a name="13089"><span class="lineNum">   13089 </span><span class="lineNoCov">          0 :     if ((isSgAndOp(anc) &amp;&amp; expr != isSgAndOp(anc)-&gt;get_lhs_operand()) ||</span></a>
<a name="13090"><span class="lineNum">   13090 </span><span class="lineNoCov">          0 :         (isSgOrOp(anc) &amp;&amp; expr != isSgOrOp(anc)-&gt;get_lhs_operand()) ||</span></a>
<a name="13091"><span class="lineNum">   13091 </span><span class="lineNoCov">          0 :         (isSgConditionalExp(anc) &amp;&amp; expr != isSgConditionalExp(anc)-&gt;get_conditional_exp()))</span></a>
<a name="13092"><span class="lineNum">   13092 </span><span class="lineNoCov">          0 :       ancestors.push_back(anc); // Closest first</span></a>
<a name="13093"><span class="lineNum">   13093 </span>            :   }</a>
<a name="13094"><span class="lineNum">   13094 </span>            :   // cout &lt;&lt; &quot;This expression to split has &quot; &lt;&lt; ancestors.size() &lt;&lt; &quot; ancestor(s)&quot; &lt;&lt; endl;</a>
<a name="13095"><span class="lineNum">   13095 </span><span class="lineCov">          2 :   for (vector&lt;SgExpression*&gt;::reverse_iterator ai = ancestors.rbegin(); ai != ancestors.rend(); ++ai)</span></a>
<a name="13096"><span class="lineNum">   13096 </span>            :   {</a>
<a name="13097"><span class="lineNum">   13097 </span><span class="lineNoCov">          0 :     StatementGenerator* gen;</span></a>
<a name="13098"><span class="lineNum">   13098 </span><span class="lineNoCov">          0 :     switch ((*ai)-&gt;variantT()) {</span></a>
<a name="13099"><span class="lineNum">   13099 </span><span class="lineNoCov">          0 :       case V_SgAndOp:</span></a>
<a name="13100"><span class="lineNum">   13100 </span><span class="lineNoCov">          0 :         gen = new AndOpGenerator(isSgAndOp(*ai)); break;</span></a>
<a name="13101"><span class="lineNum">   13101 </span><span class="lineNoCov">          0 :       case V_SgOrOp:</span></a>
<a name="13102"><span class="lineNum">   13102 </span><span class="lineNoCov">          0 :         gen = new OrOpGenerator(isSgOrOp(*ai)); break;</span></a>
<a name="13103"><span class="lineNum">   13103 </span><span class="lineNoCov">          0 :       case V_SgConditionalExp:</span></a>
<a name="13104"><span class="lineNum">   13104 </span><span class="lineNoCov">          0 :         gen = new ConditionalExpGenerator(isSgConditionalExp(*ai)); break;</span></a>
<a name="13105"><span class="lineNum">   13105 </span><span class="lineNoCov">          0 :       default: assert (!&quot;Should not happen&quot;); abort();</span></a>
<a name="13106"><span class="lineNum">   13106 </span>            :     }</a>
<a name="13107"><span class="lineNum">   13107 </span><span class="lineNoCov">          0 :     replaceExpressionWithStatement(*ai, gen);</span></a>
<a name="13108"><span class="lineNum">   13108 </span><span class="lineNoCov">          0 :     delete gen;</span></a>
<a name="13109"><span class="lineNum">   13109 </span>            :   } // for</a>
<a name="13110"><span class="lineNum">   13110 </span><span class="lineCov">          2 :   if (ancestors.size() != 0) {</span></a>
<a name="13111"><span class="lineNum">   13111 </span><span class="lineNoCov">          0 :     return splitExpression(from);</span></a>
<a name="13112"><span class="lineNum">   13112 </span>            :     // Need to recompute everything if there were ancestors</a>
<a name="13113"><span class="lineNum">   13113 </span>            :   }</a>
<a name="13114"><span class="lineNum">   13114 </span><span class="lineCov">          2 :   SgVariableDeclaration* vardecl = SageBuilder::buildVariableDeclaration(varname, vartype, NULL, parent);</span></a>
<a name="13115"><span class="lineNum">   13115 </span><span class="lineCov">          2 :   SgVariableSymbol* sym = SageInterface::getFirstVarSym(vardecl);</span></a>
<a name="13116"><span class="lineNum">   13116 </span><span class="lineCov">          2 :   ROSE_ASSERT (sym);</span></a>
<a name="13117"><span class="lineNum">   13117 </span><span class="lineCov">          2 :   SgInitializedName* initname = sym-&gt;get_declaration();</span></a>
<a name="13118"><span class="lineNum">   13118 </span><span class="lineCov">          2 :   ROSE_ASSERT (initname);</span></a>
<a name="13119"><span class="lineNum">   13119 </span><span class="lineCov">          2 :   SgVarRefExp* varref = SageBuilder::buildVarRefExp(sym);</span></a>
<a name="13120"><span class="lineNum">   13120 </span><span class="lineCov">          2 :   replaceExpressionWithExpression(from, varref);</span></a>
<a name="13121"><span class="lineNum">   13121 </span>            :   // std::cout &lt;&lt; &quot;Unparsed 3: &quot; &lt;&lt; fromparent-&gt;sage_class_name() &lt;&lt; &quot; --- &quot; &lt;&lt; fromparent-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="13122"><span class="lineNum">   13122 </span>            :   // cout &lt;&lt; &quot;From is a &quot; &lt;&lt; from-&gt;sage_class_name() &lt;&lt; endl;</a>
<a name="13123"><span class="lineNum">   13123 </span><span class="lineCov">          2 :   SgAssignInitializer* ai = SageBuilder::buildAssignInitializer(from);</span></a>
<a name="13124"><span class="lineNum">   13124 </span><span class="lineCov">          2 :   initname-&gt;set_initializer(ai);</span></a>
<a name="13125"><span class="lineNum">   13125 </span><span class="lineCov">          2 :   ai-&gt;set_parent(initname);</span></a>
<a name="13126"><span class="lineNum">   13126 </span><span class="lineCov">          2 :   myStatementInsert(stmt, vardecl, true);</span></a>
<a name="13127"><span class="lineNum">   13127 </span>            :   // vardecl-&gt;set_parent(stmt-&gt;get_parent());</a>
<a name="13128"><span class="lineNum">   13128 </span>            :   // FixSgTree(vardecl);</a>
<a name="13129"><span class="lineNum">   13129 </span>            :   // FixSgTree(parent);</a>
<a name="13130"><span class="lineNum">   13130 </span>            :   return ai;</a>
<a name="13131"><span class="lineNum">   13131 </span>            : </a>
<a name="13132"><span class="lineNum">   13132 </span>            : #else</a>
<a name="13133"><span class="lineNum">   13133 </span>            :   return NULL;</a>
<a name="13134"><span class="lineNum">   13134 </span>            : #endif</a>
<a name="13135"><span class="lineNum">   13135 </span>            : </a>
<a name="13136"><span class="lineNum">   13136 </span>            : } //splitExpression()</a>
<a name="13137"><span class="lineNum">   13137 </span>            : </a>
<a name="13138"><span class="lineNum">   13138 </span>            :   //! This generalizes the normal splitExpression to allow loop tests and</a>
<a name="13139"><span class="lineNum">   13139 </span><span class="lineNoCov">          0 :   void SageInterface::splitExpressionIntoBasicBlock(SgExpression* expr) {</span></a>
<a name="13140"><span class="lineNum">   13140 </span><span class="lineNoCov">          0 :    struct SplitStatementGenerator: public StatementGenerator {</span></a>
<a name="13141"><span class="lineNum">   13141 </span>            :      SgExpression* expr;</a>
<a name="13142"><span class="lineNum">   13142 </span><span class="lineNoCov">          0 :      virtual SgStatement* generate(SgExpression* answer) {</span></a>
<a name="13143"><span class="lineNum">   13143 </span><span class="lineNoCov">          0 :        using namespace SageBuilder;</span></a>
<a name="13144"><span class="lineNum">   13144 </span><span class="lineNoCov">          0 :        return buildBasicBlock(buildAssignStatement(answer, expr));</span></a>
<a name="13145"><span class="lineNum">   13145 </span>            :      }</a>
<a name="13146"><span class="lineNum">   13146 </span>            :    };</a>
<a name="13147"><span class="lineNum">   13147 </span><span class="lineNoCov">          0 :    SplitStatementGenerator gen;</span></a>
<a name="13148"><span class="lineNum">   13148 </span><span class="lineNoCov">          0 :    gen.expr = expr;</span></a>
<a name="13149"><span class="lineNum">   13149 </span><span class="lineNoCov">          0 :    replaceExpressionWithStatement(expr, &amp;gen);</span></a>
<a name="13150"><span class="lineNum">   13150 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="13151"><span class="lineNum">   13151 </span>            : </a>
<a name="13152"><span class="lineNum">   13152 </span><span class="lineCov">       2271 :   void SageInterface::removeLabeledGotos(SgNode* top) {</span></a>
<a name="13153"><span class="lineNum">   13153 </span><span class="lineCov">       2271 :    Rose_STL_Container&lt;SgNode*&gt; gotos = NodeQuery::querySubTree(top,</span></a>
<a name="13154"><span class="lineNum">   13154 </span><span class="lineCov">       2271 :   V_SgGotoStatement);</span></a>
<a name="13155"><span class="lineNum">   13155 </span><span class="lineCov">       4543 :    map&lt;SgLabelStatement*, SgLabelStatement*&gt; labelsToReplace;   for</span></a>
<a name="13156"><span class="lineNum">   13156 </span><span class="lineCov">       2272 :   (size_t i = 0; i &lt; gotos.size(); ++i) {</span></a>
<a name="13157"><span class="lineNum">   13157 </span><span class="lineCov">          1 :      SgGotoStatement* gs = isSgGotoStatement(gotos[i]);</span></a>
<a name="13158"><span class="lineNum">   13158 </span><span class="lineCov">          1 :      SgBasicBlock* gsParent = isSgBasicBlock(gs-&gt;get_parent());</span></a>
<a name="13159"><span class="lineNum">   13159 </span><span class="lineCov">          1 :      if (!gsParent) continue;</span></a>
<a name="13160"><span class="lineNum">   13160 </span><span class="lineCov">          1 :      SgStatementPtrList&amp; bbStatements = gsParent-&gt;get_statements();</span></a>
<a name="13161"><span class="lineNum">   13161 </span><span class="lineCov">          1 :      size_t j = std::find(bbStatements.begin(), bbStatements.end(), gs)</span></a>
<a name="13162"><span class="lineNum">   13162 </span><span class="lineCov">          1 :   - bbStatements.begin();</span></a>
<a name="13163"><span class="lineNum">   13163 </span><span class="lineCov">          1 :      ROSE_ASSERT (j != bbStatements.size());</span></a>
<a name="13164"><span class="lineNum">   13164 </span><span class="lineCov">          1 :      if (j == 0) continue;</span></a>
<a name="13165"><span class="lineNum">   13165 </span><span class="lineCov">          1 :      if (isSgLabelStatement(bbStatements[j - 1])) {</span></a>
<a name="13166"><span class="lineNum">   13166 </span><span class="lineNoCov">          0 :        labelsToReplace[isSgLabelStatement(bbStatements[j - 1])] =</span></a>
<a name="13167"><span class="lineNum">   13167 </span><span class="lineNoCov">          0 :   gs-&gt;get_label();</span></a>
<a name="13168"><span class="lineNum">   13168 </span>            :      }</a>
<a name="13169"><span class="lineNum">   13169 </span>            :    }</a>
<a name="13170"><span class="lineNum">   13170 </span><span class="lineCov">       2272 :    for (size_t i = 0; i &lt; gotos.size(); ++i) {</span></a>
<a name="13171"><span class="lineNum">   13171 </span><span class="lineCov">          1 :      SgGotoStatement* gs = isSgGotoStatement(gotos[i]);</span></a>
<a name="13172"><span class="lineNum">   13172 </span><span class="lineCov">          1 :      SgLabelStatement* oldLabel = gs-&gt;get_label();</span></a>
<a name="13173"><span class="lineNum">   13173 </span><span class="lineCov">          2 :      while (labelsToReplace.find(oldLabel) != labelsToReplace.end()) {</span></a>
<a name="13174"><span class="lineNum">   13174 </span><span class="lineNoCov">          0 :        oldLabel = labelsToReplace[oldLabel];</span></a>
<a name="13175"><span class="lineNum">   13175 </span>            :      }</a>
<a name="13176"><span class="lineNum">   13176 </span><span class="lineCov">          1 :      gs-&gt;set_label(oldLabel);</span></a>
<a name="13177"><span class="lineNum">   13177 </span>            :    }</a>
<a name="13178"><span class="lineNum">   13178 </span><span class="lineCov">       2271 :   }</span></a>
<a name="13179"><span class="lineNum">   13179 </span>            : </a>
<a name="13180"><span class="lineNum">   13180 </span><span class="lineCov">      51317 :   bool SageInterface::isConstantTrue(SgExpression* e) {</span></a>
<a name="13181"><span class="lineNum">   13181 </span><span class="lineCov">      55603 :   switch (e-&gt;variantT()) {</span></a>
<a name="13182"><span class="lineNum">   13182 </span>            : #ifdef _MSC_VER</a>
<a name="13183"><span class="lineNum">   13183 </span>            :   // DQ (11/28/2009): This fixes a warning in MSVC (likely p_value should be a &quot;bool&quot; instead of an &quot;int&quot;).</a>
<a name="13184"><span class="lineNum">   13184 </span>            :     case V_SgBoolValExp: return (isSgBoolValExp(e)-&gt;get_value() != 0);</a>
<a name="13185"><span class="lineNum">   13185 </span>            : #else</a>
<a name="13186"><span class="lineNum">   13186 </span><span class="lineCov">        500 :     case V_SgBoolValExp: return (isSgBoolValExp(e)-&gt;get_value() == true);</span></a>
<a name="13187"><span class="lineNum">   13187 </span>            : #endif</a>
<a name="13188"><span class="lineNum">   13188 </span><span class="lineCov">       2705 :     case V_SgIntVal: return isSgIntVal(e)-&gt;get_value() != 0;</span></a>
<a name="13189"><span class="lineNum">   13189 </span><span class="lineCov">       4286 :     case V_SgCastExp: return isConstantTrue(isSgCastExp(e)-&gt;get_operand());</span></a>
<a name="13190"><span class="lineNum">   13190 </span><span class="lineCov">        572 :     case V_SgNotOp: return isConstantFalse(isSgNotOp(e)-&gt;get_operand());</span></a>
<a name="13191"><span class="lineNum">   13191 </span>            :     case V_SgAddressOfOp: return true;</a>
<a name="13192"><span class="lineNum">   13192 </span><span class="lineCov">      47423 :     default: return false;</span></a>
<a name="13193"><span class="lineNum">   13193 </span>            :   }</a>
<a name="13194"><span class="lineNum">   13194 </span>            :   }</a>
<a name="13195"><span class="lineNum">   13195 </span>            : </a>
<a name="13196"><span class="lineNum">   13196 </span><span class="lineCov">      51317 :   bool SageInterface::isConstantFalse(SgExpression* e) {</span></a>
<a name="13197"><span class="lineNum">   13197 </span><span class="lineCov">      55603 :     switch (e-&gt;variantT()) {</span></a>
<a name="13198"><span class="lineNum">   13198 </span><span class="lineCov">        500 :       case V_SgBoolValExp: return isSgBoolValExp(e)-&gt;get_value() == false;</span></a>
<a name="13199"><span class="lineNum">   13199 </span><span class="lineCov">       2705 :       case V_SgIntVal: return isSgIntVal(e)-&gt;get_value() == 0;</span></a>
<a name="13200"><span class="lineNum">   13200 </span><span class="lineCov">       4286 :       case V_SgCastExp: return</span></a>
<a name="13201"><span class="lineNum">   13201 </span><span class="lineCov">       4286 :   isConstantFalse(isSgCastExp(e)-&gt;get_operand());</span></a>
<a name="13202"><span class="lineNum">   13202 </span><span class="lineCov">        572 :       case V_SgNotOp: return isConstantTrue(isSgNotOp(e)-&gt;get_operand());</span></a>
<a name="13203"><span class="lineNum">   13203 </span>            :       default: return false;</a>
<a name="13204"><span class="lineNum">   13204 </span>            :     }</a>
<a name="13205"><span class="lineNum">   13205 </span>            :   }</a>
<a name="13206"><span class="lineNum">   13206 </span>            : </a>
<a name="13207"><span class="lineNum">   13207 </span><span class="lineCov">          1 :   bool SageInterface::isCallToParticularFunction(SgFunctionDeclaration* decl,</span></a>
<a name="13208"><span class="lineNum">   13208 </span>            :   SgExpression* e) {</a>
<a name="13209"><span class="lineNum">   13209 </span><span class="lineCov">          1 :     SgFunctionCallExp* fc = isSgFunctionCallExp(e);</span></a>
<a name="13210"><span class="lineNum">   13210 </span><span class="lineCov">          1 :     if (!fc) return false;</span></a>
<a name="13211"><span class="lineNum">   13211 </span><span class="lineCov">          1 :     SgFunctionRefExp* fr = isSgFunctionRefExp(fc-&gt;get_function());</span></a>
<a name="13212"><span class="lineNum">   13212 </span><span class="lineCov">          1 :     if (fr == NULL) return false;</span></a>
<a name="13213"><span class="lineNum">   13213 </span><span class="lineCov">          1 :     return fr-&gt;get_symbol()-&gt;get_declaration() == decl;</span></a>
<a name="13214"><span class="lineNum">   13214 </span>            :   }</a>
<a name="13215"><span class="lineNum">   13215 </span>            : </a>
<a name="13216"><span class="lineNum">   13216 </span><span class="lineCov">       4955 :   bool SageInterface::isCallToParticularFunction(const std::string&amp; qualifiedName, size_t</span></a>
<a name="13217"><span class="lineNum">   13217 </span>            :   arity, SgExpression* e) {</a>
<a name="13218"><span class="lineNum">   13218 </span><span class="lineCov">       4955 :     SgFunctionCallExp* fc = isSgFunctionCallExp(e);</span></a>
<a name="13219"><span class="lineNum">   13219 </span><span class="lineCov">       4955 :     if (!fc) return false;</span></a>
<a name="13220"><span class="lineNum">   13220 </span><span class="lineCov">       4955 :     SgFunctionRefExp* fr = isSgFunctionRefExp(fc-&gt;get_function());</span></a>
<a name="13221"><span class="lineNum">   13221 </span><span class="lineCov">       4955 :     if (fr == NULL) return false;</span></a>
<a name="13222"><span class="lineNum">   13222 </span><span class="lineCov">        756 :     string name =</span></a>
<a name="13223"><span class="lineNum">   13223 </span><span class="lineCov">       6467 :   fr-&gt;get_symbol()-&gt;get_declaration()-&gt;get_qualified_name().getString();</span></a>
<a name="13224"><span class="lineNum">   13224 </span><span class="lineCov">        756 :     return (name == qualifiedName &amp;&amp;</span></a>
<a name="13225"><span class="lineNum">   13225 </span><span class="lineCov">        756 :   fc-&gt;get_args()-&gt;get_expressions().size() == arity);</span></a>
<a name="13226"><span class="lineNum">   13226 </span>            :   }</a>
<a name="13227"><span class="lineNum">   13227 </span>            : </a>
<a name="13228"><span class="lineNum">   13228 </span><span class="lineCov">       1588 :   SgExpression* SageInterface::copyExpression(SgExpression* e)</span></a>
<a name="13229"><span class="lineNum">   13229 </span>            :   {</a>
<a name="13230"><span class="lineNum">   13230 </span><span class="lineCov">       1588 :     ROSE_ASSERT( e != NULL);</span></a>
<a name="13231"><span class="lineNum">   13231 </span>            :     // We enforce that the source expression is fully attached to the AST</a>
<a name="13232"><span class="lineNum">   13232 </span>            :     // Too strict, the source expression can be just built and not attached.</a>
<a name="13233"><span class="lineNum">   13233 </span>            :     // Liao, 9/21/2009</a>
<a name="13234"><span class="lineNum">   13234 </span>            : //    ROSE_ASSERT( e-&gt;get_parent() != NULL);</a>
<a name="13235"><span class="lineNum">   13235 </span><span class="lineCov">       1588 :     return deepCopy(e);</span></a>
<a name="13236"><span class="lineNum">   13236 </span>            :   }</a>
<a name="13237"><span class="lineNum">   13237 </span>            : </a>
<a name="13238"><span class="lineNum">   13238 </span><span class="lineCov">          5 :   SgStatement* SageInterface::copyStatement(SgStatement* s)</span></a>
<a name="13239"><span class="lineNum">   13239 </span>            :   {</a>
<a name="13240"><span class="lineNum">   13240 </span><span class="lineCov">          5 :     return deepCopy(s);</span></a>
<a name="13241"><span class="lineNum">   13241 </span>            :   }</a>
<a name="13242"><span class="lineNum">   13242 </span>            : </a>
<a name="13243"><span class="lineNum">   13243 </span>            :   //----------------- add into AST tree --------------------</a>
<a name="13244"><span class="lineNum">   13244 </span><span class="lineCov">      40895 :   void SageInterface::appendExpression(SgExprListExp *expList, SgExpression* exp)</span></a>
<a name="13245"><span class="lineNum">   13245 </span>            :   {</a>
<a name="13246"><span class="lineNum">   13246 </span><span class="lineCov">      40895 :     ROSE_ASSERT(expList);</span></a>
<a name="13247"><span class="lineNum">   13247 </span><span class="lineCov">      40895 :     ROSE_ASSERT(exp);</span></a>
<a name="13248"><span class="lineNum">   13248 </span><span class="lineCov">      40895 :     expList-&gt;append_expression(exp);</span></a>
<a name="13249"><span class="lineNum">   13249 </span><span class="lineCov">      40895 :     exp-&gt;set_parent(expList);</span></a>
<a name="13250"><span class="lineNum">   13250 </span><span class="lineCov">      40895 :   }</span></a>
<a name="13251"><span class="lineNum">   13251 </span>            : </a>
<a name="13252"><span class="lineNum">   13252 </span><span class="lineNoCov">          0 :   void SageInterface::appendExpressionList(SgExprListExp *expList, const std::vector&lt;SgExpression*&gt;&amp; exp)</span></a>
<a name="13253"><span class="lineNum">   13253 </span>            :   {</a>
<a name="13254"><span class="lineNum">   13254 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; exp.size(); ++i)</span></a>
<a name="13255"><span class="lineNum">   13255 </span><span class="lineNoCov">          0 :       appendExpression(expList, exp[i]);</span></a>
<a name="13256"><span class="lineNum">   13256 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="13257"><span class="lineNum">   13257 </span>            : </a>
<a name="13258"><span class="lineNum">   13258 </span>            : # if 0</a>
<a name="13259"><span class="lineNum">   13259 </span>            :   // DQ (11/25/2011): Moved to the header file so that it could be seen as a template function.</a>
<a name="13260"><span class="lineNum">   13260 </span>            : </a>
<a name="13261"><span class="lineNum">   13261 </span>            :   // TODO consider the difference between C++ and Fortran</a>
<a name="13262"><span class="lineNum">   13262 </span>            :   // fixup the scope of arguments,no symbols for nondefining function declaration's arguments</a>
<a name="13263"><span class="lineNum">   13263 </span>            : template &lt;class actualFunction&gt;</a>
<a name="13264"><span class="lineNum">   13264 </span>            : void</a>
<a name="13265"><span class="lineNum">   13265 </span>            : // SageInterface::setParameterList(SgFunctionDeclaration * func,SgFunctionParameterList * paralist)</a>
<a name="13266"><span class="lineNum">   13266 </span>            : SageInterface::setParameterList(actualFunction * func,SgFunctionParameterList * paralist)</a>
<a name="13267"><span class="lineNum">   13267 </span>            :    {</a>
<a name="13268"><span class="lineNum">   13268 </span>            :   // DQ (11/25/2011): Modified this to be a templated function so that we can handle both</a>
<a name="13269"><span class="lineNum">   13269 </span>            :   // SgFunctionDeclaration and SgTemplateFunctionDeclaration (and their associated member</a>
<a name="13270"><span class="lineNum">   13270 </span>            :   // function derived classes).</a>
<a name="13271"><span class="lineNum">   13271 </span>            : </a>
<a name="13272"><span class="lineNum">   13272 </span>            :      ROSE_ASSERT(func);</a>
<a name="13273"><span class="lineNum">   13273 </span>            :      ROSE_ASSERT(paralist);</a>
<a name="13274"><span class="lineNum">   13274 </span>            : </a>
<a name="13275"><span class="lineNum">   13275 </span>            :   // Warn to users if a paralist is being shared</a>
<a name="13276"><span class="lineNum">   13276 </span>            :      if (paralist-&gt;get_parent() !=NULL)</a>
<a name="13277"><span class="lineNum">   13277 </span>            :         {</a>
<a name="13278"><span class="lineNum">   13278 </span>            :           cerr &lt;&lt; &quot;Waring! Setting a used SgFunctionParameterList to function: &quot;</a>
<a name="13279"><span class="lineNum">   13279 </span>            :                &lt;&lt; (func-&gt;get_name()).getString()&lt;&lt;endl</a>
<a name="13280"><span class="lineNum">   13280 </span>            :                &lt;&lt; &quot; Sharing parameter lists can corrupt symbol tables!&quot;&lt;&lt;endl</a>
<a name="13281"><span class="lineNum">   13281 </span>            :                &lt;&lt; &quot; Please use deepCopy() to get an exclusive parameter list for each function declaration!&quot;&lt;&lt;endl;</a>
<a name="13282"><span class="lineNum">   13282 </span>            :        // ROSE_ASSERT(false);</a>
<a name="13283"><span class="lineNum">   13283 </span>            :         }</a>
<a name="13284"><span class="lineNum">   13284 </span>            : </a>
<a name="13285"><span class="lineNum">   13285 </span>            :   // Liao,2/5/2008  constructor of SgFunctionDeclaration will automatically generate SgFunctionParameterList, so be cautious when set new paralist!!</a>
<a name="13286"><span class="lineNum">   13286 </span>            :      if (func-&gt;get_parameterList() != NULL)</a>
<a name="13287"><span class="lineNum">   13287 </span>            :           if (func-&gt;get_parameterList() != paralist)</a>
<a name="13288"><span class="lineNum">   13288 </span>            :                delete func-&gt;get_parameterList();</a>
<a name="13289"><span class="lineNum">   13289 </span>            : </a>
<a name="13290"><span class="lineNum">   13290 </span>            :      func-&gt;set_parameterList(paralist);</a>
<a name="13291"><span class="lineNum">   13291 </span>            :      paralist-&gt;set_parent(func);</a>
<a name="13292"><span class="lineNum">   13292 </span>            :    }</a>
<a name="13293"><span class="lineNum">   13293 </span>            : #endif</a>
<a name="13294"><span class="lineNum">   13294 </span>            : </a>
<a name="13295"><span class="lineNum">   13295 </span>            : // static</a>
<a name="13296"><span class="lineNum">   13296 </span><span class="lineCov">    6327960 : SgVariableSymbol* addArg(SgFunctionParameterList *paraList, SgInitializedName* initName, bool isPrepend)</span></a>
<a name="13297"><span class="lineNum">   13297 </span>            :    {</a>
<a name="13298"><span class="lineNum">   13298 </span><span class="lineCov">    6327960 :      ROSE_ASSERT(paraList != NULL);</span></a>
<a name="13299"><span class="lineNum">   13299 </span><span class="lineCov">    6327960 :      ROSE_ASSERT(initName != NULL);</span></a>
<a name="13300"><span class="lineNum">   13300 </span>            : </a>
<a name="13301"><span class="lineNum">   13301 </span><span class="lineCov">    6327960 :      if (isPrepend == true)</span></a>
<a name="13302"><span class="lineNum">   13302 </span><span class="lineNoCov">          0 :           paraList-&gt;prepend_arg(initName);</span></a>
<a name="13303"><span class="lineNum">   13303 </span>            :        else</a>
<a name="13304"><span class="lineNum">   13304 </span><span class="lineCov">    6327960 :           paraList-&gt;append_arg(initName);</span></a>
<a name="13305"><span class="lineNum">   13305 </span>            : </a>
<a name="13306"><span class="lineNum">   13306 </span>            :   // DQ (12/4/2011): If this is going to be set, make sure it will not be over written.</a>
<a name="13307"><span class="lineNum">   13307 </span>            :   // initName-&gt;set_parent(paraList);</a>
<a name="13308"><span class="lineNum">   13308 </span><span class="lineCov">    6327960 :      if (initName-&gt;get_parent() == NULL)</span></a>
<a name="13309"><span class="lineNum">   13309 </span><span class="lineNoCov">          0 :           initName-&gt;set_parent(paraList);</span></a>
<a name="13310"><span class="lineNum">   13310 </span>            : </a>
<a name="13311"><span class="lineNum">   13311 </span><span class="lineCov">    6327960 :      ROSE_ASSERT(initName-&gt;get_parent() == paraList);</span></a>
<a name="13312"><span class="lineNum">   13312 </span>            : </a>
<a name="13313"><span class="lineNum">   13313 </span><span class="lineCov">    6327960 :      SgFunctionDeclaration* func_decl= isSgFunctionDeclaration(paraList-&gt;get_parent());</span></a>
<a name="13314"><span class="lineNum">   13314 </span>            : </a>
<a name="13315"><span class="lineNum">   13315 </span>            :   // DQ (12/4/2011): This will not be true for function parameter lists in SgTemplateFunctionDeclaration cases.</a>
<a name="13316"><span class="lineNum">   13316 </span>            :   // Also in typical use the SgFunctionDeclaration is not known yet so the parent is not set.</a>
<a name="13317"><span class="lineNum">   13317 </span>            :   // ROSE_ASSERT(paraList-&gt;get_parent() != NULL);</a>
<a name="13318"><span class="lineNum">   13318 </span>            :   // ROSE_ASSERT(func_decl != NULL);</a>
<a name="13319"><span class="lineNum">   13319 </span>            : </a>
<a name="13320"><span class="lineNum">   13320 </span><span class="lineCov">    6327960 :      SgScopeStatement* scope = NULL;</span></a>
<a name="13321"><span class="lineNum">   13321 </span><span class="lineCov">    6327960 :      if (func_decl != NULL)</span></a>
<a name="13322"><span class="lineNum">   13322 </span>            :         {</a>
<a name="13323"><span class="lineNum">   13323 </span><span class="lineNoCov">          0 :           if ((func_decl-&gt;get_definingDeclaration()) == func_decl )</span></a>
<a name="13324"><span class="lineNum">   13324 </span>            :              {</a>
<a name="13325"><span class="lineNum">   13325 </span>            :             // defining function declaration, set scope and symbol table</a>
<a name="13326"><span class="lineNum">   13326 </span><span class="lineNoCov">          0 :                SgFunctionDefinition* func_def = func_decl-&gt;get_definition();</span></a>
<a name="13327"><span class="lineNum">   13327 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(func_def);</span></a>
<a name="13328"><span class="lineNum">   13328 </span><span class="lineNoCov">          0 :                scope = func_def;</span></a>
<a name="13329"><span class="lineNum">   13329 </span>            :              }</a>
<a name="13330"><span class="lineNum">   13330 </span>            :             else</a>
<a name="13331"><span class="lineNum">   13331 </span>            :              {</a>
<a name="13332"><span class="lineNum">   13332 </span>            :             // nondefining declaration, set scope only, currently set to decl's scope, TODO</a>
<a name="13333"><span class="lineNum">   13333 </span><span class="lineNoCov">          0 :                scope = func_decl-&gt;get_scope();</span></a>
<a name="13334"><span class="lineNum">   13334 </span>            :              }</a>
<a name="13335"><span class="lineNum">   13335 </span>            : </a>
<a name="13336"><span class="lineNum">   13336 </span>            :        // fix up declptr of the init name</a>
<a name="13337"><span class="lineNum">   13337 </span><span class="lineNoCov">          0 :           initName-&gt;set_declptr(func_decl);</span></a>
<a name="13338"><span class="lineNum">   13338 </span>            :         }</a>
<a name="13339"><span class="lineNum">   13339 </span>            : </a>
<a name="13340"><span class="lineNum">   13340 </span>            :   // Liao 11/21/2012. Part of this function's work is to set scope for initName which is freshly created. So we should not assert</a>
<a name="13341"><span class="lineNum">   13341 </span>            :   // that initName already has a scope.</a>
<a name="13342"><span class="lineNum">   13342 </span>            :   //</a>
<a name="13343"><span class="lineNum">   13343 </span>            :   // DQ (12/4/2011): Added check...(fails for case of SgTypeEllipse).</a>
<a name="13344"><span class="lineNum">   13344 </span>            :   // ROSE_ASSERT(initName-&gt;get_scope() != NULL);</a>
<a name="13345"><span class="lineNum">   13345 </span>            :   //   ROSE_ASSERT(initName-&gt;get_scope() != NULL || isSgTypeEllipse(initName-&gt;get_type()) != NULL);</a>
<a name="13346"><span class="lineNum">   13346 </span>            : </a>
<a name="13347"><span class="lineNum">   13347 </span>            :   // ROSE_ASSERT (scope); -- scope may not be set because the function declaration may not have been inserted anywhere</a>
<a name="13348"><span class="lineNum">   13348 </span>            : </a>
<a name="13349"><span class="lineNum">   13349 </span><span class="lineCov">    6327960 :      initName-&gt;set_scope(scope);</span></a>
<a name="13350"><span class="lineNum">   13350 </span><span class="lineCov">    6327960 :      if (scope != NULL)</span></a>
<a name="13351"><span class="lineNum">   13351 </span>            :         {</a>
<a name="13352"><span class="lineNum">   13352 </span><span class="lineNoCov">          0 :           SgVariableSymbol* sym = isSgVariableSymbol(initName-&gt;get_symbol_from_symbol_table());</span></a>
<a name="13353"><span class="lineNum">   13353 </span><span class="lineNoCov">          0 :           if (sym == NULL)</span></a>
<a name="13354"><span class="lineNum">   13354 </span>            :              {</a>
<a name="13355"><span class="lineNum">   13355 </span><span class="lineNoCov">          0 :                sym = new SgVariableSymbol(initName);</span></a>
<a name="13356"><span class="lineNum">   13356 </span><span class="lineNoCov">          0 :                scope-&gt;insert_symbol(initName-&gt;get_name(), sym);</span></a>
<a name="13357"><span class="lineNum">   13357 </span><span class="lineNoCov">          0 :                sym-&gt;set_parent(scope-&gt;get_symbol_table());</span></a>
<a name="13358"><span class="lineNum">   13358 </span>            :              }</a>
<a name="13359"><span class="lineNum">   13359 </span><span class="lineNoCov">          0 :           return sym;</span></a>
<a name="13360"><span class="lineNum">   13360 </span>            :         }</a>
<a name="13361"><span class="lineNum">   13361 </span>            :        else</a>
<a name="13362"><span class="lineNum">   13362 </span>            :         {</a>
<a name="13363"><span class="lineNum">   13363 </span>            :           return NULL;</a>
<a name="13364"><span class="lineNum">   13364 </span>            :         }</a>
<a name="13365"><span class="lineNum">   13365 </span>            :    }</a>
<a name="13366"><span class="lineNum">   13366 </span>            : </a>
<a name="13367"><span class="lineNum">   13367 </span><span class="lineCov">    6327960 : SgVariableSymbol* SageInterface::appendArg(SgFunctionParameterList *paraList, SgInitializedName* initName)</span></a>
<a name="13368"><span class="lineNum">   13368 </span>            : {</a>
<a name="13369"><span class="lineNum">   13369 </span><span class="lineCov">    6327960 :   return addArg(paraList,initName,false);</span></a>
<a name="13370"><span class="lineNum">   13370 </span>            : }</a>
<a name="13371"><span class="lineNum">   13371 </span>            : </a>
<a name="13372"><span class="lineNum">   13372 </span><span class="lineNoCov">          0 : SgVariableSymbol* SageInterface::prependArg(SgFunctionParameterList *paraList, SgInitializedName* initName)</span></a>
<a name="13373"><span class="lineNum">   13373 </span>            : {</a>
<a name="13374"><span class="lineNum">   13374 </span><span class="lineNoCov">          0 :   return addArg(paraList,initName,true);</span></a>
<a name="13375"><span class="lineNum">   13375 </span>            : }</a>
<a name="13376"><span class="lineNum">   13376 </span>            : </a>
<a name="13377"><span class="lineNum">   13377 </span><span class="lineNoCov">          0 : void SageInterface::setPragma(SgPragmaDeclaration* decl, SgPragma *pragma)</span></a>
<a name="13378"><span class="lineNum">   13378 </span>            : {</a>
<a name="13379"><span class="lineNum">   13379 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(decl);</span></a>
<a name="13380"><span class="lineNum">   13380 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(pragma);</span></a>
<a name="13381"><span class="lineNum">   13381 </span><span class="lineNoCov">          0 :   if (decl-&gt;get_pragma()!=NULL) delete (decl-&gt;get_pragma());</span></a>
<a name="13382"><span class="lineNum">   13382 </span><span class="lineNoCov">          0 :   decl-&gt;set_pragma(pragma);</span></a>
<a name="13383"><span class="lineNum">   13383 </span><span class="lineNoCov">          0 :   pragma-&gt;set_parent(decl);</span></a>
<a name="13384"><span class="lineNum">   13384 </span><span class="lineNoCov">          0 : }</span></a>
<a name="13385"><span class="lineNum">   13385 </span>            : </a>
<a name="13386"><span class="lineNum">   13386 </span>            : </a>
<a name="13387"><span class="lineNum">   13387 </span>            : //! SageInterface::appendStatement()</a>
<a name="13388"><span class="lineNum">   13388 </span>            : //TODO should we ensureBasicBlockAsScope(scope) ? like ensureBasicBlockAsParent(targetStmt);</a>
<a name="13389"><span class="lineNum">   13389 </span>            : //It might be well legal to append the first and only statement in a scope!</a>
<a name="13390"><span class="lineNum">   13390 </span><span class="lineCov">    1320350 : void SageInterface::appendStatement(SgStatement *stmt, SgScopeStatement* scope)</span></a>
<a name="13391"><span class="lineNum">   13391 </span>            :    {</a>
<a name="13392"><span class="lineNum">   13392 </span>            :   // DQ (4/3/2012): Simple globally visible function to call (used for debugging in ROSE).</a>
<a name="13393"><span class="lineNum">   13393 </span><span class="lineCov">    1320350 :      void testAstForUniqueNodes ( SgNode* node );</span></a>
<a name="13394"><span class="lineNum">   13394 </span>            : </a>
<a name="13395"><span class="lineNum">   13395 </span>            : #if 0</a>
<a name="13396"><span class="lineNum">   13396 </span>            :      printf (&quot;In SageInterface::appendStatement(): stmt = %p = %s scope = %p \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope);</a>
<a name="13397"><span class="lineNum">   13397 </span>            : #endif</a>
<a name="13398"><span class="lineNum">   13398 </span>            : </a>
<a name="13399"><span class="lineNum">   13399 </span>            :   // DQ (6/19/2012): Exit as a test...</a>
<a name="13400"><span class="lineNum">   13400 </span>            :   // ROSE_ASSERT(isSgClassDeclaration(stmt) == NULL);</a>
<a name="13401"><span class="lineNum">   13401 </span>            : </a>
<a name="13402"><span class="lineNum">   13402 </span><span class="lineCov">    1320350 :      if (scope == NULL)</span></a>
<a name="13403"><span class="lineNum">   13403 </span>            :         {</a>
<a name="13404"><span class="lineNum">   13404 </span>            : #if 0</a>
<a name="13405"><span class="lineNum">   13405 </span>            :           printf (&quot;   --- scope was not specified as input! \n&quot;);</a>
<a name="13406"><span class="lineNum">   13406 </span>            : #endif</a>
<a name="13407"><span class="lineNum">   13407 </span><span class="lineCov">         29 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="13408"><span class="lineNum">   13408 </span>            :         }</a>
<a name="13409"><span class="lineNum">   13409 </span>            : </a>
<a name="13410"><span class="lineNum">   13410 </span><span class="lineCov">    1320350 :      ROSE_ASSERT(stmt  != NULL);</span></a>
<a name="13411"><span class="lineNum">   13411 </span><span class="lineCov">    1320350 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="13412"><span class="lineNum">   13412 </span>            : </a>
<a name="13413"><span class="lineNum">   13413 </span>            : #if 0</a>
<a name="13414"><span class="lineNum">   13414 </span>            :      printf (&quot;In SageInterface::appendStatement(): stmt = %p = %s scope = %p = %s \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13415"><span class="lineNum">   13415 </span>            : #endif</a>
<a name="13416"><span class="lineNum">   13416 </span>            : </a>
<a name="13417"><span class="lineNum">   13417 </span>            : #if 0</a>
<a name="13418"><span class="lineNum">   13418 </span>            :   // DQ (2/2/2010): This fails in the projects/OpenMP_Translator &quot;make check&quot; tests.</a>
<a name="13419"><span class="lineNum">   13419 </span>            :   // DQ (1/2/2010): Introducing test that are enforced at lower levels to catch errors as early as possible.</a>
<a name="13420"><span class="lineNum">   13420 </span>            :      SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(stmt);</a>
<a name="13421"><span class="lineNum">   13421 </span>            :      if (declarationStatement != NULL)</a>
<a name="13422"><span class="lineNum">   13422 </span>            :         {</a>
<a name="13423"><span class="lineNum">   13423 </span>            :           ROSE_ASSERT(declarationStatement-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="13424"><span class="lineNum">   13424 </span>            :           ROSE_ASSERT(declarationStatement-&gt;get_definingDeclaration() != NULL);</a>
<a name="13425"><span class="lineNum">   13425 </span>            :         }</a>
<a name="13426"><span class="lineNum">   13426 </span>            : #endif</a>
<a name="13427"><span class="lineNum">   13427 </span>            : </a>
<a name="13428"><span class="lineNum">   13428 </span>            : #if 0</a>
<a name="13429"><span class="lineNum">   13429 </span>            :     // This fix breaks other transformations.</a>
<a name="13430"><span class="lineNum">   13430 </span>            :     // It is better to do this explicitly as needed before calling appendStatement();</a>
<a name="13431"><span class="lineNum">   13431 </span>            :     // Liao 10/19/2010</a>
<a name="13432"><span class="lineNum">   13432 </span>            :     // In rare cases, we are moving the statement from its original scope to another scope</a>
<a name="13433"><span class="lineNum">   13433 </span>            :     // We have to remove it from its original scope before append it to the new scope</a>
<a name="13434"><span class="lineNum">   13434 </span>            :     SgNode* old_parent=  stmt-&gt;get_parent();</a>
<a name="13435"><span class="lineNum">   13435 </span>            :     if (old_parent)</a>
<a name="13436"><span class="lineNum">   13436 </span>            :        {</a>
<a name="13437"><span class="lineNum">   13437 </span>            :          removeStatement(stmt);</a>
<a name="13438"><span class="lineNum">   13438 </span>            :        }</a>
<a name="13439"><span class="lineNum">   13439 </span>            : #endif</a>
<a name="13440"><span class="lineNum">   13440 </span>            : </a>
<a name="13441"><span class="lineNum">   13441 </span>            : #if 0</a>
<a name="13442"><span class="lineNum">   13442 </span>            :   // catch-all for statement fixup</a>
<a name="13443"><span class="lineNum">   13443 </span>            :   // Must fix it before insert it into the scope,</a>
<a name="13444"><span class="lineNum">   13444 </span>            :      fixStatement(stmt,scope);</a>
<a name="13445"><span class="lineNum">   13445 </span>            : </a>
<a name="13446"><span class="lineNum">   13446 </span>            :   //-----------------------</a>
<a name="13447"><span class="lineNum">   13447 </span>            :   // append the statement finally</a>
<a name="13448"><span class="lineNum">   13448 </span>            :   // scope-&gt;append_statement (stmt);</a>
<a name="13449"><span class="lineNum">   13449 </span>            :      scope-&gt;insertStatementInScope(stmt,false);</a>
<a name="13450"><span class="lineNum">   13450 </span>            :      stmt-&gt;set_parent(scope); // needed?</a>
<a name="13451"><span class="lineNum">   13451 </span>            : #else</a>
<a name="13452"><span class="lineNum">   13452 </span>            :   // DQ (7/12/2012): Skip adding when this is a non-autonomous type declaration.</a>
<a name="13453"><span class="lineNum">   13453 </span><span class="lineCov">    1320350 :      bool skipAddingStatement = false;</span></a>
<a name="13454"><span class="lineNum">   13454 </span><span class="lineCov">    1320350 :      SgClassDeclaration* classDeclaration = isSgClassDeclaration(stmt);</span></a>
<a name="13455"><span class="lineNum">   13455 </span><span class="lineCov">    1320350 :      if (classDeclaration != NULL)</span></a>
<a name="13456"><span class="lineNum">   13456 </span>            :         {</a>
<a name="13457"><span class="lineNum">   13457 </span>            :        // DQ (7/9/2012): We only skip the attachment of the class declaration to the scope if it is NOT and autonomous declaration.</a>
<a name="13458"><span class="lineNum">   13458 </span>            : #if 0</a>
<a name="13459"><span class="lineNum">   13459 </span>            :           if (classDeclaration-&gt;get_parent() != NULL)</a>
<a name="13460"><span class="lineNum">   13460 </span>            :              {</a>
<a name="13461"><span class="lineNum">   13461 </span>            :                printf (&quot;Since the parent of this SgClassDeclaration is set, it must have been previously added to the AST: classDeclaration = %p = %s \n&quot;,classDeclaration,classDeclaration-&gt;class_name().c_str());</a>
<a name="13462"><span class="lineNum">   13462 </span>            :              }</a>
<a name="13463"><span class="lineNum">   13463 </span>            : #endif</a>
<a name="13464"><span class="lineNum">   13464 </span>            : </a>
<a name="13465"><span class="lineNum">   13465 </span>            : #if 1</a>
<a name="13466"><span class="lineNum">   13466 </span>            :        // DQ (6/9/2013): This is the original code...</a>
<a name="13467"><span class="lineNum">   13467 </span><span class="lineCov">      18507 :           skipAddingStatement = (classDeclaration-&gt;get_isAutonomousDeclaration() == false);</span></a>
<a name="13468"><span class="lineNum">   13468 </span>            : #else</a>
<a name="13469"><span class="lineNum">   13469 </span>            :        // DQ (6/9/2013): We have no other way to detect if the SgClassDeclaration has previously been added to the AST (short of searching the AST directly).</a>
<a name="13470"><span class="lineNum">   13470 </span>            :        // This fails to add enough statements to the AST.</a>
<a name="13471"><span class="lineNum">   13471 </span>            :           skipAddingStatement = (classDeclaration-&gt;get_isAutonomousDeclaration() == false) || (classDeclaration-&gt;get_parent() != NULL);</a>
<a name="13472"><span class="lineNum">   13472 </span>            : #endif</a>
<a name="13473"><span class="lineNum">   13473 </span>            : </a>
<a name="13474"><span class="lineNum">   13474 </span>            :        // DQ (6/26/2013): Don't just check for SgTemplateInstantiationDecl, but also for SgClassDeclaration.</a>
<a name="13475"><span class="lineNum">   13475 </span>            :        // DQ (6/9/2013): Check if this is a SgTemplateInstantiationDecl, since it might be appearing</a>
<a name="13476"><span class="lineNum">   13476 </span>            :        // twice as a result of a template argument being instantiated and we only want to add it into</a>
<a name="13477"><span class="lineNum">   13477 </span>            :        // the scope once.  This happens for test2013_198.C and I can't find a better solution.</a>
<a name="13478"><span class="lineNum">   13478 </span>            :        // if (isSgTemplateInstantiationDecl(classDeclaration) != NULL &amp;&amp; scope-&gt;containsOnlyDeclarations() == true)</a>
<a name="13479"><span class="lineNum">   13479 </span><span class="lineCov">      18507 :           if (classDeclaration != NULL &amp;&amp; scope-&gt;containsOnlyDeclarations() == true)</span></a>
<a name="13480"><span class="lineNum">   13480 </span>            :              {</a>
<a name="13481"><span class="lineNum">   13481 </span>            :             // Check if this instnatiated template has already been added to the scope.</a>
<a name="13482"><span class="lineNum">   13482 </span>            : </a>
<a name="13483"><span class="lineNum">   13483 </span>            :             // DQ (6/26/2013): This is a newer alternative to test for an existing statement in a scope.</a>
<a name="13484"><span class="lineNum">   13484 </span>            :             // const SgDeclarationStatementPtrList &amp; declarationList = scope-&gt;getDeclarationList();</a>
<a name="13485"><span class="lineNum">   13485 </span>            :             // SgDeclarationStatementPtrList::const_iterator existingDeclaration = find(declarationList.begin(),declarationList.end(),classDeclaration);</a>
<a name="13486"><span class="lineNum">   13486 </span>            :             // if (existingDeclaration != declarationList.end())</a>
<a name="13487"><span class="lineNum">   13487 </span><span class="lineCov">      18371 :                bool statementAlreadyExistsInScope = scope-&gt;statementExistsInScope(classDeclaration);</span></a>
<a name="13488"><span class="lineNum">   13488 </span><span class="lineCov">      18371 :                if (statementAlreadyExistsInScope == true)</span></a>
<a name="13489"><span class="lineNum">   13489 </span>            :                   {</a>
<a name="13490"><span class="lineNum">   13490 </span><span class="lineNoCov">          0 :                     if (isSgTemplateInstantiationDecl(classDeclaration) != NULL)</span></a>
<a name="13491"><span class="lineNum">   13491 </span>            :                        {</a>
<a name="13492"><span class="lineNum">   13492 </span>            : // DQ (9/13/2014): Clean up this output when not printing developer warnings.</a>
<a name="13493"><span class="lineNum">   13493 </span>            : // #if 1</a>
<a name="13494"><span class="lineNum">   13494 </span>            : #if PRINT_DEVELOPER_WARNINGS</a>
<a name="13495"><span class="lineNum">   13495 </span>            :                          printf (&quot;RARE ISSUE #1: In SageInterface::appendStatement(): This template instantiation has previously been added to the scope, so avoid doing so again (see test2013_198.C): classDeclaration = %p = %s scope = %p = %s \n&quot;,</a>
<a name="13496"><span class="lineNum">   13496 </span>            :                               classDeclaration,classDeclaration-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13497"><span class="lineNum">   13497 </span>            : #endif</a>
<a name="13498"><span class="lineNum">   13498 </span>            :                        }</a>
<a name="13499"><span class="lineNum">   13499 </span>            : #if 1</a>
<a name="13500"><span class="lineNum">   13500 </span>            :                       else</a>
<a name="13501"><span class="lineNum">   13501 </span>            :                        {</a>
<a name="13502"><span class="lineNum">   13502 </span>            : #if 1</a>
<a name="13503"><span class="lineNum">   13503 </span><span class="lineNoCov">          0 :                          printf (&quot;RARE ISSUE #2: In SageInterface::appendStatement(): This statement has previously been added to the scope, so avoid doing so again (see rose.h): stmt = %p = %s scope = %p = %s \n&quot;,</span></a>
<a name="13504"><span class="lineNum">   13504 </span><span class="lineNoCov">          0 :                               stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</span></a>
<a name="13505"><span class="lineNum">   13505 </span>            : #endif</a>
<a name="13506"><span class="lineNum">   13506 </span>            :                        }</a>
<a name="13507"><span class="lineNum">   13507 </span>            : #endif</a>
<a name="13508"><span class="lineNum">   13508 </span>            :                     skipAddingStatement = true;</a>
<a name="13509"><span class="lineNum">   13509 </span>            :                   }</a>
<a name="13510"><span class="lineNum">   13510 </span>            :              }</a>
<a name="13511"><span class="lineNum">   13511 </span>            :         }</a>
<a name="13512"><span class="lineNum">   13512 </span>            :        else</a>
<a name="13513"><span class="lineNum">   13513 </span>            :         {</a>
<a name="13514"><span class="lineNum">   13514 </span><span class="lineCov">    1301840 :           SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(stmt);</span></a>
<a name="13515"><span class="lineNum">   13515 </span><span class="lineCov">    1301840 :           if (enumDeclaration != NULL)</span></a>
<a name="13516"><span class="lineNum">   13516 </span>            :              {</a>
<a name="13517"><span class="lineNum">   13517 </span>            :             // DQ (7/12/2012): We only skip the attachment of the class declaration to the scope if it is NOT and autonomous declaration.</a>
<a name="13518"><span class="lineNum">   13518 </span><span class="lineCov">       1490 :                skipAddingStatement = (enumDeclaration-&gt;get_isAutonomousDeclaration() == false);</span></a>
<a name="13519"><span class="lineNum">   13519 </span>            :              }</a>
<a name="13520"><span class="lineNum">   13520 </span>            :         }</a>
<a name="13521"><span class="lineNum">   13521 </span>            : </a>
<a name="13522"><span class="lineNum">   13522 </span>            : #if 0</a>
<a name="13523"><span class="lineNum">   13523 </span>            :   // DQ (6/26/2013): This is an attempt to support better testing of possible redundant statements</a>
<a name="13524"><span class="lineNum">   13524 </span>            :   // that would be inserted into the current scope. This is however a bit expensive so we are using</a>
<a name="13525"><span class="lineNum">   13525 </span>            :   // this as a way to also debug the new cases where this happens.</a>
<a name="13526"><span class="lineNum">   13526 </span>            :      bool statementAlreadyExistsInScope = scope-&gt;statementExistsInScope(stmt);</a>
<a name="13527"><span class="lineNum">   13527 </span>            :      if (skipAddingStatement == false &amp;&amp; statementAlreadyExistsInScope == true)</a>
<a name="13528"><span class="lineNum">   13528 </span>            :         {</a>
<a name="13529"><span class="lineNum">   13529 </span>            : #if 0</a>
<a name="13530"><span class="lineNum">   13530 </span>            :           printf (&quot;RARE ISSUE #2: In SageInterface::appendStatement(): This statement has previously been added to the scope, so avoid doing so again (see rose.h): stmt = %p = %s scope = %p = %s \n&quot;,</a>
<a name="13531"><span class="lineNum">   13531 </span>            :                stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13532"><span class="lineNum">   13532 </span>            : #endif</a>
<a name="13533"><span class="lineNum">   13533 </span>            : #if 0</a>
<a name="13534"><span class="lineNum">   13534 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="13535"><span class="lineNum">   13535 </span>            :           ROSE_ABORT();</a>
<a name="13536"><span class="lineNum">   13536 </span>            : #endif</a>
<a name="13537"><span class="lineNum">   13537 </span>            :           skipAddingStatement = true;</a>
<a name="13538"><span class="lineNum">   13538 </span>            :         }</a>
<a name="13539"><span class="lineNum">   13539 </span>            : #endif</a>
<a name="13540"><span class="lineNum">   13540 </span>            : </a>
<a name="13541"><span class="lineNum">   13541 </span>            : #if 0</a>
<a name="13542"><span class="lineNum">   13542 </span>            :      printf (&quot;   --- skipAddingStatement = %s \n&quot;,skipAddingStatement ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13543"><span class="lineNum">   13543 </span>            : #endif</a>
<a name="13544"><span class="lineNum">   13544 </span>            : </a>
<a name="13545"><span class="lineNum">   13545 </span><span class="lineCov">      19997 :      if (skipAddingStatement == false)</span></a>
<a name="13546"><span class="lineNum">   13546 </span>            :         {</a>
<a name="13547"><span class="lineNum">   13547 </span>            :        // catch-all for statement fixup</a>
<a name="13548"><span class="lineNum">   13548 </span>            :        // Must fix it before insert it into the scope,</a>
<a name="13549"><span class="lineNum">   13549 </span>            :        // printf (&quot;In appendStatementList(): Calling fixStatement() \n&quot;);</a>
<a name="13550"><span class="lineNum">   13550 </span><span class="lineCov">    1319260 :           fixStatement(stmt,scope);</span></a>
<a name="13551"><span class="lineNum">   13551 </span>            :        // printf (&quot;DONE: In appendStatementList(): Calling fixStatement() \n&quot;);</a>
<a name="13552"><span class="lineNum">   13552 </span>            : </a>
<a name="13553"><span class="lineNum">   13553 </span>            :        //-----------------------</a>
<a name="13554"><span class="lineNum">   13554 </span>            :        // append the statement finally</a>
<a name="13555"><span class="lineNum">   13555 </span>            :        // scope-&gt;append_statement (stmt);</a>
<a name="13556"><span class="lineNum">   13556 </span>            : #if 0</a>
<a name="13557"><span class="lineNum">   13557 </span>            :           printf (&quot;   --- calling insertStatementInScope(): scope = %p = %s stmt = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str(),stmt,stmt-&gt;class_name().c_str());</a>
<a name="13558"><span class="lineNum">   13558 </span>            : #endif</a>
<a name="13559"><span class="lineNum">   13559 </span><span class="lineCov">    1319260 :           scope-&gt;insertStatementInScope(stmt,false);</span></a>
<a name="13560"><span class="lineNum">   13560 </span>            : </a>
<a name="13561"><span class="lineNum">   13561 </span>            :        // DQ (6/9/2013): Added comment only: This is needed because some declaration have to have the</a>
<a name="13562"><span class="lineNum">   13562 </span>            :        // setting of there paremtn pointes delayed until now based on if they appear nested inside of</a>
<a name="13563"><span class="lineNum">   13563 </span>            :        // other declarations (e.g. &quot;typedef struct { int x; } y;&quot;).</a>
<a name="13564"><span class="lineNum">   13564 </span><span class="lineCov">    1319260 :           stmt-&gt;set_parent(scope); // needed?</span></a>
<a name="13565"><span class="lineNum">   13565 </span>            :         }</a>
<a name="13566"><span class="lineNum">   13566 </span>            : #endif</a>
<a name="13567"><span class="lineNum">   13567 </span>            : </a>
<a name="13568"><span class="lineNum">   13568 </span>            :   // DQ (11/19/2012): If we are building the AST within the front-end then don't do this expensive</a>
<a name="13569"><span class="lineNum">   13569 </span>            :   // fixup (we already set it properly in the AST construction within the frontend so we don't need</a>
<a name="13570"><span class="lineNum">   13570 </span>            :   // this).  Also since this is only operating within a single scope it is likely too specific to C</a>
<a name="13571"><span class="lineNum">   13571 </span>            :   // instead of addressing the details of C++ where functions can be placed in alternative scopes and</a>
<a name="13572"><span class="lineNum">   13572 </span>            :   // use name qualification).</a>
<a name="13573"><span class="lineNum">   13573 </span>            :   // update the links after insertion!</a>
<a name="13574"><span class="lineNum">   13574 </span>            :   // if (isSgFunctionDeclaration(stmt))</a>
<a name="13575"><span class="lineNum">   13575 </span><span class="lineCov">    1320350 :      SourcePositionClassification scp = getSourcePositionClassificationMode();</span></a>
<a name="13576"><span class="lineNum">   13576 </span><span class="lineCov">    1320350 :      if ( (scp != e_sourcePositionFrontendConstruction) &amp;&amp; (isSgFunctionDeclaration(stmt) != NULL) )</span></a>
<a name="13577"><span class="lineNum">   13577 </span>            :         {</a>
<a name="13578"><span class="lineNum">   13578 </span><span class="lineCov">         17 :           updateDefiningNondefiningLinks(isSgFunctionDeclaration(stmt),scope);</span></a>
<a name="13579"><span class="lineNum">   13579 </span>            :         }</a>
<a name="13580"><span class="lineNum">   13580 </span>            : </a>
<a name="13581"><span class="lineNum">   13581 </span>            : #if 0</a>
<a name="13582"><span class="lineNum">   13582 </span>            :   // DQ (6/26/2013): Turn on this test for debugging ROSE compiling rose.h header file.</a>
<a name="13583"><span class="lineNum">   13583 </span>            :   // Note that this is a stronger AST subtree test and not the weaker test for a redundant</a>
<a name="13584"><span class="lineNum">   13584 </span>            :   // statement in a single scope.</a>
<a name="13585"><span class="lineNum">   13585 </span>            :   // DQ (9/1/2012): this is a debugging mode that we need to more easily turn on and off.</a>
<a name="13586"><span class="lineNum">   13586 </span>            :   // DQ (4/3/2012): Added test to make sure that the pointers are unique.</a>
<a name="13587"><span class="lineNum">   13587 </span>            :      testAstForUniqueNodes(scope);</a>
<a name="13588"><span class="lineNum">   13588 </span>            : #else</a>
<a name="13589"><span class="lineNum">   13589 </span>            :   // printf (&quot;In SageInterface::appendStatement(): Skipping test for unique statements in subtree \n&quot;);</a>
<a name="13590"><span class="lineNum">   13590 </span>            : #endif</a>
<a name="13591"><span class="lineNum">   13591 </span><span class="lineCov">    1320350 :    }</span></a>
<a name="13592"><span class="lineNum">   13592 </span>            : </a>
<a name="13593"><span class="lineNum">   13593 </span>            : //! Append a statement to the end of SgForInitStatement</a>
<a name="13594"><span class="lineNum">   13594 </span><span class="lineNoCov">          0 : void SageInterface::appendStatement(SgStatement *stmt, SgForInitStatement* for_init_stmt)</span></a>
<a name="13595"><span class="lineNum">   13595 </span>            : {</a>
<a name="13596"><span class="lineNum">   13596 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (stmt != NULL);</span></a>
<a name="13597"><span class="lineNum">   13597 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (for_init_stmt != NULL);</span></a>
<a name="13598"><span class="lineNum">   13598 </span>            : </a>
<a name="13599"><span class="lineNum">   13599 </span>            : #if 0</a>
<a name="13600"><span class="lineNum">   13600 </span>            :      printf (&quot;In SageInterface::appendStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: stmt) \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13601"><span class="lineNum">   13601 </span>            : #endif</a>
<a name="13602"><span class="lineNum">   13602 </span>            : </a>
<a name="13603"><span class="lineNum">   13603 </span>            :   // DQ (12/2/2015): If this is a moved statement then cause it to update internal data structures</a>
<a name="13604"><span class="lineNum">   13604 </span>            :   // to record it being moved (and thus the macroExpansions that it might be associated with having</a>
<a name="13605"><span class="lineNum">   13605 </span>            :   // to force the macroExpansion's associated statements to be marked as a transformation.</a>
<a name="13606"><span class="lineNum">   13606 </span><span class="lineNoCov">          0 :      resetInternalMapsForTargetStatement(stmt);</span></a>
<a name="13607"><span class="lineNum">   13607 </span>            : </a>
<a name="13608"><span class="lineNum">   13608 </span>            : #if 0</a>
<a name="13609"><span class="lineNum">   13609 </span>            :      printf (&quot;In SageInterface::appendStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: scope) \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13610"><span class="lineNum">   13610 </span>            : #endif</a>
<a name="13611"><span class="lineNum">   13611 </span>            : </a>
<a name="13612"><span class="lineNum">   13612 </span>            :   // DQ (12/2/2015): Also look at the statements on either side of the location where this statement</a>
<a name="13613"><span class="lineNum">   13613 </span>            :   // is being inserted to make sure that they are not a part of a macro expansion. In the case of</a>
<a name="13614"><span class="lineNum">   13614 </span>            :   // prepend, we only need to look at the scope.</a>
<a name="13615"><span class="lineNum">   13615 </span><span class="lineNoCov">          0 :      resetInternalMapsForTargetStatement(for_init_stmt);</span></a>
<a name="13616"><span class="lineNum">   13616 </span>            : </a>
<a name="13617"><span class="lineNum">   13617 </span><span class="lineNoCov">          0 :   for_init_stmt-&gt;append_init_stmt (stmt);</span></a>
<a name="13618"><span class="lineNum">   13618 </span><span class="lineNoCov">          0 : }</span></a>
<a name="13619"><span class="lineNum">   13619 </span>            : </a>
<a name="13620"><span class="lineNum">   13620 </span>            : void</a>
<a name="13621"><span class="lineNum">   13621 </span><span class="lineCov">      27650 : SageInterface::appendStatementList(const std::vector&lt;SgStatement*&gt;&amp; stmts, SgScopeStatement* scope)</span></a>
<a name="13622"><span class="lineNum">   13622 </span>            :    {</a>
<a name="13623"><span class="lineNum">   13623 </span><span class="lineCov">      73996 :      for (size_t i = 0; i &lt; stmts.size(); ++i)</span></a>
<a name="13624"><span class="lineNum">   13624 </span>            :         {</a>
<a name="13625"><span class="lineNum">   13625 </span>            : #if 0</a>
<a name="13626"><span class="lineNum">   13626 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13627"><span class="lineNum">   13627 </span>            :           printf (&quot;In appendStatementList(): stmts[i = %&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,stmts[i],stmts[i]-&gt;class_name().c_str());</a>
<a name="13628"><span class="lineNum">   13628 </span>            :        // printf (&quot;In appendStatementList(): stmts[i = %&quot; PRIuPTR &quot;]-&gt;get_parent() = %p \n&quot;,i,stmts[i]-&gt;get_parent());</a>
<a name="13629"><span class="lineNum">   13629 </span>            : #endif</a>
<a name="13630"><span class="lineNum">   13630 </span>            : #endif</a>
<a name="13631"><span class="lineNum">   13631 </span><span class="lineCov">      46346 :         appendStatement(stmts[i], scope); // Liao 5/15/2013, defer the logic of checking parent pointers to appendStatement()</span></a>
<a name="13632"><span class="lineNum">   13632 </span>            : #if 0</a>
<a name="13633"><span class="lineNum">   13633 </span>            :           if (stmts[i]-&gt;get_parent() != NULL)</a>
<a name="13634"><span class="lineNum">   13634 </span>            :              {</a>
<a name="13635"><span class="lineNum">   13635 </span>            : #if 0</a>
<a name="13636"><span class="lineNum">   13636 </span>            : #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION</a>
<a name="13637"><span class="lineNum">   13637 </span>            :                printf (&quot;   --- In appendStatementList(): stmts[i = %&quot; PRIuPTR &quot;] will be added to scope (because stmts[i]-&gt;get_parent() != NULL (= %p = %s) \n&quot;,i,stmts[i]-&gt;get_parent(),stmts[i]-&gt;get_parent()-&gt;class_name().c_str());</a>
<a name="13638"><span class="lineNum">   13638 </span>            : #endif</a>
<a name="13639"><span class="lineNum">   13639 </span>            : #endif</a>
<a name="13640"><span class="lineNum">   13640 </span>            :                appendStatement(stmts[i], scope);</a>
<a name="13641"><span class="lineNum">   13641 </span>            :              }</a>
<a name="13642"><span class="lineNum">   13642 </span>            :             else</a>
<a name="13643"><span class="lineNum">   13643 </span>            :              {</a>
<a name="13644"><span class="lineNum">   13644 </span>            :                printf (&quot;   --- WARNING: In appendStatementList(): stmts[i = %&quot; PRIuPTR &quot;] not added to scope (because stmts[i]-&gt;get_parent() == NULL) \n&quot;,i);</a>
<a name="13645"><span class="lineNum">   13645 </span>            :              }</a>
<a name="13646"><span class="lineNum">   13646 </span>            : #endif</a>
<a name="13647"><span class="lineNum">   13647 </span>            :         }</a>
<a name="13648"><span class="lineNum">   13648 </span><span class="lineCov">      27650 :    }</span></a>
<a name="13649"><span class="lineNum">   13649 </span>            : </a>
<a name="13650"><span class="lineNum">   13650 </span>            : //!SageInterface::prependStatement()</a>
<a name="13651"><span class="lineNum">   13651 </span><span class="lineCov">         94 : void SageInterface::prependStatement(SgStatement *stmt, SgScopeStatement* scope)</span></a>
<a name="13652"><span class="lineNum">   13652 </span>            :    {</a>
<a name="13653"><span class="lineNum">   13653 </span><span class="lineCov">         94 :      ROSE_ASSERT (stmt != NULL);</span></a>
<a name="13654"><span class="lineNum">   13654 </span>            : </a>
<a name="13655"><span class="lineNum">   13655 </span>            : #if 0</a>
<a name="13656"><span class="lineNum">   13656 </span>            :      printf (&quot;In SageInterface::prependStatement(): stmt = %p = %s scope = %p \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope);</a>
<a name="13657"><span class="lineNum">   13657 </span>            : #endif</a>
<a name="13658"><span class="lineNum">   13658 </span>            : </a>
<a name="13659"><span class="lineNum">   13659 </span><span class="lineCov">         94 :      if (scope == NULL)</span></a>
<a name="13660"><span class="lineNum">   13660 </span>            :         {</a>
<a name="13661"><span class="lineNum">   13661 </span><span class="lineCov">          6 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="13662"><span class="lineNum">   13662 </span>            :         }</a>
<a name="13663"><span class="lineNum">   13663 </span>            : </a>
<a name="13664"><span class="lineNum">   13664 </span><span class="lineCov">         94 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="13665"><span class="lineNum">   13665 </span>            :   // TODO handle side effect like SageBuilder::appendStatement() does</a>
<a name="13666"><span class="lineNum">   13666 </span>            : </a>
<a name="13667"><span class="lineNum">   13667 </span>            :   // Must fix it before insert it into the scope,</a>
<a name="13668"><span class="lineNum">   13668 </span>            :   // otherwise assertions in insertStatementInScope() would fail</a>
<a name="13669"><span class="lineNum">   13669 </span><span class="lineCov">         94 :      fixStatement(stmt,scope);</span></a>
<a name="13670"><span class="lineNum">   13670 </span>            : </a>
<a name="13671"><span class="lineNum">   13671 </span>            : #if 0</a>
<a name="13672"><span class="lineNum">   13672 </span>            :      printf (&quot;In SageInterface::prependStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: stmt) \n&quot;,</a>
<a name="13673"><span class="lineNum">   13673 </span>            :           stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13674"><span class="lineNum">   13674 </span>            : #endif</a>
<a name="13675"><span class="lineNum">   13675 </span>            : </a>
<a name="13676"><span class="lineNum">   13676 </span>            :   // DQ (12/1/2015): If this is a moved statement then cause it to update internal data structures</a>
<a name="13677"><span class="lineNum">   13677 </span>            :   // to record it being moved (and thus the macroExpansions that it might be associated with having</a>
<a name="13678"><span class="lineNum">   13678 </span>            :   // to force the macroExpansion's associated statements to be marked as a transformation.</a>
<a name="13679"><span class="lineNum">   13679 </span><span class="lineCov">         94 :      resetInternalMapsForTargetStatement(stmt);</span></a>
<a name="13680"><span class="lineNum">   13680 </span>            : </a>
<a name="13681"><span class="lineNum">   13681 </span>            : #if 0</a>
<a name="13682"><span class="lineNum">   13682 </span>            :      printf (&quot;In SageInterface::prependStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: scope) \n&quot;,</a>
<a name="13683"><span class="lineNum">   13683 </span>            :           stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13684"><span class="lineNum">   13684 </span>            : #endif</a>
<a name="13685"><span class="lineNum">   13685 </span>            : </a>
<a name="13686"><span class="lineNum">   13686 </span>            :   // DQ (12/1/2015): Also look at the statements on either side of the location where this statement</a>
<a name="13687"><span class="lineNum">   13687 </span>            :   // is being inserted to make sure that they are not a part of a macro expansion. In the case of</a>
<a name="13688"><span class="lineNum">   13688 </span>            :   // prepend, we only need to look at the scope.</a>
<a name="13689"><span class="lineNum">   13689 </span><span class="lineCov">         94 :      resetInternalMapsForTargetStatement(scope);</span></a>
<a name="13690"><span class="lineNum">   13690 </span>            : </a>
<a name="13691"><span class="lineNum">   13691 </span>            : #if 0</a>
<a name="13692"><span class="lineNum">   13692 </span>            :      printf (&quot;Calling insertStatementInScope() \n&quot;);</a>
<a name="13693"><span class="lineNum">   13693 </span>            : #endif</a>
<a name="13694"><span class="lineNum">   13694 </span>            : </a>
<a name="13695"><span class="lineNum">   13695 </span><span class="lineCov">         94 :      scope-&gt;insertStatementInScope(stmt,true);</span></a>
<a name="13696"><span class="lineNum">   13696 </span><span class="lineCov">         94 :      stmt-&gt;set_parent(scope); // needed?</span></a>
<a name="13697"><span class="lineNum">   13697 </span>            : </a>
<a name="13698"><span class="lineNum">   13698 </span>            :   // DQ (11/19/2012): If we are building the AST within the front-end then don't do this expensive</a>
<a name="13699"><span class="lineNum">   13699 </span>            :   // fixup (we already set it properly in the AST construction within the frontend so we don't need</a>
<a name="13700"><span class="lineNum">   13700 </span>            :   // this).  Also since this is only operating within a single scope it is likely too specific to C</a>
<a name="13701"><span class="lineNum">   13701 </span>            :   // instead of addessing the details of C++ where functions can be placed in alternative scopes and</a>
<a name="13702"><span class="lineNum">   13702 </span>            :   // use name qualification).</a>
<a name="13703"><span class="lineNum">   13703 </span>            :   // update the links after insertion!</a>
<a name="13704"><span class="lineNum">   13704 </span>            :   // if (isSgFunctionDeclaration(stmt))</a>
<a name="13705"><span class="lineNum">   13705 </span><span class="lineCov">         94 :      SourcePositionClassification scp = getSourcePositionClassificationMode();</span></a>
<a name="13706"><span class="lineNum">   13706 </span><span class="lineCov">         94 :      if ( (scp != e_sourcePositionFrontendConstruction) &amp;&amp; (isSgFunctionDeclaration(stmt) != NULL) )</span></a>
<a name="13707"><span class="lineNum">   13707 </span>            :         {</a>
<a name="13708"><span class="lineNum">   13708 </span><span class="lineCov">          3 :           updateDefiningNondefiningLinks(isSgFunctionDeclaration(stmt),scope);</span></a>
<a name="13709"><span class="lineNum">   13709 </span>            :         }</a>
<a name="13710"><span class="lineNum">   13710 </span>            : </a>
<a name="13711"><span class="lineNum">   13711 </span>            : #if 0</a>
<a name="13712"><span class="lineNum">   13712 </span>            :      printf (&quot;Leaving SageInterface::prependStatement() \n&quot;);</a>
<a name="13713"><span class="lineNum">   13713 </span>            : #endif</a>
<a name="13714"><span class="lineNum">   13714 </span><span class="lineCov">         94 :    } // prependStatement()</span></a>
<a name="13715"><span class="lineNum">   13715 </span>            : </a>
<a name="13716"><span class="lineNum">   13716 </span>            : </a>
<a name="13717"><span class="lineNum">   13717 </span>            : //! Prepend a statement to the beginning of SgForInitStatement</a>
<a name="13718"><span class="lineNum">   13718 </span><span class="lineNoCov">          0 : void SageInterface::prependStatement(SgStatement *stmt, SgForInitStatement* for_init_stmt)</span></a>
<a name="13719"><span class="lineNum">   13719 </span>            : {</a>
<a name="13720"><span class="lineNum">   13720 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (stmt != NULL);</span></a>
<a name="13721"><span class="lineNum">   13721 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (for_init_stmt != NULL);</span></a>
<a name="13722"><span class="lineNum">   13722 </span>            : </a>
<a name="13723"><span class="lineNum">   13723 </span>            : #if 0</a>
<a name="13724"><span class="lineNum">   13724 </span>            :      printf (&quot;In SageInterface::prependStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: stmt) \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13725"><span class="lineNum">   13725 </span>            : #endif</a>
<a name="13726"><span class="lineNum">   13726 </span>            : </a>
<a name="13727"><span class="lineNum">   13727 </span>            :   // DQ (12/2/2015): If this is a moved statement then cause it to update internal data structures</a>
<a name="13728"><span class="lineNum">   13728 </span>            :   // to record it being moved (and thus the macroExpansions that it might be associated with having</a>
<a name="13729"><span class="lineNum">   13729 </span>            :   // to force the macroExpansion's associated statements to be marked as a transformation.</a>
<a name="13730"><span class="lineNum">   13730 </span><span class="lineNoCov">          0 :      resetInternalMapsForTargetStatement(stmt);</span></a>
<a name="13731"><span class="lineNum">   13731 </span>            : </a>
<a name="13732"><span class="lineNum">   13732 </span>            : #if 0</a>
<a name="13733"><span class="lineNum">   13733 </span>            :      printf (&quot;In SageInterface::prependStatement(): stmt = %p = %s scope = %p = %s (resetInternalMapsForTargetStatement: scope) \n&quot;,stmt,stmt-&gt;class_name().c_str(),scope,scope-&gt;class_name().c_str());</a>
<a name="13734"><span class="lineNum">   13734 </span>            : #endif</a>
<a name="13735"><span class="lineNum">   13735 </span>            : </a>
<a name="13736"><span class="lineNum">   13736 </span>            :   // DQ (12/2/2015): Also look at the statements on either side of the location where this statement</a>
<a name="13737"><span class="lineNum">   13737 </span>            :   // is being inserted to make sure that they are not a part of a macro expansion. In the case of</a>
<a name="13738"><span class="lineNum">   13738 </span>            :   // prepend, we only need to look at the scope.</a>
<a name="13739"><span class="lineNum">   13739 </span><span class="lineNoCov">          0 :      resetInternalMapsForTargetStatement(for_init_stmt);</span></a>
<a name="13740"><span class="lineNum">   13740 </span>            : </a>
<a name="13741"><span class="lineNum">   13741 </span><span class="lineNoCov">          0 :   for_init_stmt-&gt;prepend_init_stmt (stmt);</span></a>
<a name="13742"><span class="lineNum">   13742 </span><span class="lineNoCov">          0 : }</span></a>
<a name="13743"><span class="lineNum">   13743 </span>            : </a>
<a name="13744"><span class="lineNum">   13744 </span><span class="lineCov">          5 : void SageInterface::prependStatementList(const std::vector&lt;SgStatement*&gt;&amp; stmts, SgScopeStatement* scope)</span></a>
<a name="13745"><span class="lineNum">   13745 </span>            :    {</a>
<a name="13746"><span class="lineNum">   13746 </span><span class="lineCov">         27 :      for (size_t i = stmts.size(); i &gt; 0; --i)</span></a>
<a name="13747"><span class="lineNum">   13747 </span>            :         {</a>
<a name="13748"><span class="lineNum">   13748 </span><span class="lineCov">         22 :           prependStatement(stmts[i - 1], scope);</span></a>
<a name="13749"><span class="lineNum">   13749 </span>            :         }</a>
<a name="13750"><span class="lineNum">   13750 </span><span class="lineCov">          5 :    }</span></a>
<a name="13751"><span class="lineNum">   13751 </span>            : </a>
<a name="13752"><span class="lineNum">   13752 </span>            :   //! Check if a scope statement has a simple children statement list (SgStatementPtrList)</a>
<a name="13753"><span class="lineNum">   13753 </span>            :   //! so insert additional statements under the scope is straightforward and unambiguous .</a>
<a name="13754"><span class="lineNum">   13754 </span>            :   //! for example, SgBasicBlock has a simple statement list while IfStmt does not.</a>
<a name="13755"><span class="lineNum">   13755 </span><span class="lineCov">      15256 : bool  SageInterface::hasSimpleChildrenList (SgScopeStatement* scope)</span></a>
<a name="13756"><span class="lineNum">   13756 </span>            : {</a>
<a name="13757"><span class="lineNum">   13757 </span><span class="lineCov">      15256 :   bool rt = false;</span></a>
<a name="13758"><span class="lineNum">   13758 </span><span class="lineCov">      15256 :   ROSE_ASSERT (scope != NULL);</span></a>
<a name="13759"><span class="lineNum">   13759 </span><span class="lineCov">      15256 :   switch (scope-&gt;variantT())</span></a>
<a name="13760"><span class="lineNum">   13760 </span>            :   {</a>
<a name="13761"><span class="lineNum">   13761 </span>            :     case V_SgBasicBlock:</a>
<a name="13762"><span class="lineNum">   13762 </span>            :     case V_SgClassDefinition:</a>
<a name="13763"><span class="lineNum">   13763 </span>            :     case V_SgFunctionDefinition:</a>
<a name="13764"><span class="lineNum">   13764 </span>            :     case V_SgGlobal:</a>
<a name="13765"><span class="lineNum">   13765 </span>            :     case V_SgNamespaceDefinitionStatement: //?</a>
<a name="13766"><span class="lineNum">   13766 </span>            :       rt = true;</a>
<a name="13767"><span class="lineNum">   13767 </span>            :       break;</a>
<a name="13768"><span class="lineNum">   13768 </span>            : </a>
<a name="13769"><span class="lineNum">   13769 </span><span class="lineCov">        932 :      case V_SgAssociateStatement :</span></a>
<a name="13770"><span class="lineNum">   13770 </span><span class="lineCov">        932 :      case V_SgBlockDataStatement :</span></a>
<a name="13771"><span class="lineNum">   13771 </span><span class="lineCov">        932 :      case V_SgCatchOptionStmt:</span></a>
<a name="13772"><span class="lineNum">   13772 </span><span class="lineCov">        932 :      case V_SgDoWhileStmt:</span></a>
<a name="13773"><span class="lineNum">   13773 </span><span class="lineCov">        932 :      case V_SgForAllStatement:</span></a>
<a name="13774"><span class="lineNum">   13774 </span><span class="lineCov">        932 :      case V_SgForStatement:</span></a>
<a name="13775"><span class="lineNum">   13775 </span><span class="lineCov">        932 :      case V_SgFortranDo:</span></a>
<a name="13776"><span class="lineNum">   13776 </span><span class="lineCov">        932 :      case V_SgIfStmt:</span></a>
<a name="13777"><span class="lineNum">   13777 </span><span class="lineCov">        932 :      case V_SgSwitchStatement:</span></a>
<a name="13778"><span class="lineNum">   13778 </span><span class="lineCov">        932 :      case V_SgUpcForAllStatement:</span></a>
<a name="13779"><span class="lineNum">   13779 </span><span class="lineCov">        932 :      case V_SgWhileStmt:</span></a>
<a name="13780"><span class="lineNum">   13780 </span><span class="lineCov">        932 :       rt = false;</span></a>
<a name="13781"><span class="lineNum">   13781 </span><span class="lineCov">        932 :       break;</span></a>
<a name="13782"><span class="lineNum">   13782 </span>            : </a>
<a name="13783"><span class="lineNum">   13783 </span><span class="lineCov">       8656 :     default:</span></a>
<a name="13784"><span class="lineNum">   13784 </span><span class="lineCov">       8656 :       cout&lt;&lt;&quot;unrecognized or unhandled scope type for SageInterface::hasSimpleChildrenList() &quot;&lt;&lt;endl;</span></a>
<a name="13785"><span class="lineNum">   13785 </span>            :     break;</a>
<a name="13786"><span class="lineNum">   13786 </span>            :   }</a>
<a name="13787"><span class="lineNum">   13787 </span><span class="lineCov">      15256 :   return rt;</span></a>
<a name="13788"><span class="lineNum">   13788 </span>            : }</a>
<a name="13789"><span class="lineNum">   13789 </span>            : </a>
<a name="13790"><span class="lineNum">   13790 </span>            : </a>
<a name="13791"><span class="lineNum">   13791 </span>            : // DQ (11/21/2018): We need to sometimes insert something after the last statement of the collection from rose_edg_required_macros_and_functions.h.</a>
<a name="13792"><span class="lineNum">   13792 </span><span class="lineNoCov">          0 : SgStatement* SageInterface::lastFrontEndSpecificStatement( SgGlobal* globalScope )</span></a>
<a name="13793"><span class="lineNum">   13793 </span>            :    {</a>
<a name="13794"><span class="lineNum">   13794 </span>            :   // When inserting a statement into global scope, if inserting at the top of scope it is best to insert</a>
<a name="13795"><span class="lineNum">   13795 </span>            :   // after the last statement from the preinclude file rose_edg_required_macros_and_functions.h.</a>
<a name="13796"><span class="lineNum">   13796 </span>            : </a>
<a name="13797"><span class="lineNum">   13797 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList &amp; declarationList = globalScope-&gt;get_declarations();</span></a>
<a name="13798"><span class="lineNum">   13798 </span>            : </a>
<a name="13799"><span class="lineNum">   13799 </span><span class="lineNoCov">          0 :      SgStatement* last_statement = NULL;</span></a>
<a name="13800"><span class="lineNum">   13800 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList::iterator i = declarationList.begin();</span></a>
<a name="13801"><span class="lineNum">   13801 </span>            :   // while (i != declarationList.end())</a>
<a name="13802"><span class="lineNum">   13802 </span><span class="lineNoCov">          0 :      while (i != declarationList.end() &amp;&amp; (*i)-&gt;get_file_info() != NULL &amp;&amp; (*i)-&gt;get_file_info()-&gt;isFrontendSpecific() == true)</span></a>
<a name="13803"><span class="lineNum">   13803 </span>            :         {</a>
<a name="13804"><span class="lineNum">   13804 </span>            : #if 0</a>
<a name="13805"><span class="lineNum">   13805 </span>            :           printf (&quot;(*i)-&gt;get_file_info()-&gt;get_file_id() = %d isFrontendSpecific = %s \n&quot;,(*i)-&gt;get_file_info()-&gt;get_file_id(),(*i)-&gt;get_file_info()-&gt;isFrontendSpecific() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13806"><span class="lineNum">   13806 </span>            : #endif</a>
<a name="13807"><span class="lineNum">   13807 </span><span class="lineNoCov">          0 :           last_statement = *i;</span></a>
<a name="13808"><span class="lineNum">   13808 </span>            : </a>
<a name="13809"><span class="lineNum">   13809 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="13810"><span class="lineNum">   13810 </span>            :         }</a>
<a name="13811"><span class="lineNum">   13811 </span>            : </a>
<a name="13812"><span class="lineNum">   13812 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(last_statement != NULL);</span></a>
<a name="13813"><span class="lineNum">   13813 </span>            : #if 1</a>
<a name="13814"><span class="lineNum">   13814 </span><span class="lineNoCov">          0 :      printf (&quot;last_statement = %p = %s \n&quot;,last_statement,last_statement-&gt;class_name().c_str());</span></a>
<a name="13815"><span class="lineNum">   13815 </span>            : #endif</a>
<a name="13816"><span class="lineNum">   13816 </span>            : #if 0</a>
<a name="13817"><span class="lineNum">   13817 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="13818"><span class="lineNum">   13818 </span>            :      ROSE_ABORT();</a>
<a name="13819"><span class="lineNum">   13819 </span>            : #endif</a>
<a name="13820"><span class="lineNum">   13820 </span>            : </a>
<a name="13821"><span class="lineNum">   13821 </span><span class="lineNoCov">          0 :      return last_statement;</span></a>
<a name="13822"><span class="lineNum">   13822 </span>            :    }</a>
<a name="13823"><span class="lineNum">   13823 </span>            : </a>
<a name="13824"><span class="lineNum">   13824 </span>            : </a>
<a name="13825"><span class="lineNum">   13825 </span>            :   //TODO handle more side effect like SageBuilder::append_statement() does</a>
<a name="13826"><span class="lineNum">   13826 </span>            :   //Merge myStatementInsert()</a>
<a name="13827"><span class="lineNum">   13827 </span>            :   // insert  SageInterface::insertStatement()</a>
<a name="13828"><span class="lineNum">   13828 </span><span class="lineCov">        984 : void SageInterface::insertStatement(SgStatement *targetStmt, SgStatement* newStmt, bool insertBefore, bool autoMovePreprocessingInfo /*= true */)</span></a>
<a name="13829"><span class="lineNum">   13829 </span>            :    {</a>
<a name="13830"><span class="lineNum">   13830 </span><span class="lineCov">        984 :      ROSE_ASSERT(targetStmt &amp;&amp;newStmt);</span></a>
<a name="13831"><span class="lineNum">   13831 </span><span class="lineCov">        984 :      ROSE_ASSERT(targetStmt != newStmt); // should not share statement nodes!</span></a>
<a name="13832"><span class="lineNum">   13832 </span><span class="lineCov">        984 :      SgNode* parent = targetStmt-&gt;get_parent();</span></a>
<a name="13833"><span class="lineNum">   13833 </span><span class="lineCov">        984 :      if (parent == NULL)</span></a>
<a name="13834"><span class="lineNum">   13834 </span>            :         {</a>
<a name="13835"><span class="lineNum">   13835 </span><span class="lineNoCov">          0 :           cerr &lt;&lt; &quot;Empty parent pointer for target statement. May be caused by the wrong order of target and new statements in insertStatement(targetStmt, newStmt)&quot;&lt;&lt;endl;</span></a>
<a name="13836"><span class="lineNum">   13836 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(parent);</span></a>
<a name="13837"><span class="lineNum">   13837 </span>            :         }</a>
<a name="13838"><span class="lineNum">   13838 </span>            : </a>
<a name="13839"><span class="lineNum">   13839 </span><span class="lineCov">        984 :      if (isSgLabelStatement(parent) != NULL)</span></a>
<a name="13840"><span class="lineNum">   13840 </span>            :         {</a>
<a name="13841"><span class="lineNum">   13841 </span>            : #if 0</a>
<a name="13842"><span class="lineNum">   13842 </span>            :           printf (&quot;In SageInterface::insertStatement(): Detected case of label statement as parent, using parent of label statement \n&quot;);</a>
<a name="13843"><span class="lineNum">   13843 </span>            : #endif</a>
<a name="13844"><span class="lineNum">   13844 </span><span class="lineNoCov">          0 :           SgLabelStatement* labelStatement = isSgLabelStatement(parent);</span></a>
<a name="13845"><span class="lineNum">   13845 </span>            :        // parent = labelStatement-&gt;get_scope();</a>
<a name="13846"><span class="lineNum">   13846 </span><span class="lineNoCov">          0 :           parent = labelStatement-&gt;get_parent();</span></a>
<a name="13847"><span class="lineNum">   13847 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(isSgLabelStatement(parent) == NULL);</span></a>
<a name="13848"><span class="lineNum">   13848 </span>            :         }</a>
<a name="13849"><span class="lineNum">   13849 </span>            : </a>
<a name="13850"><span class="lineNum">   13850 </span>            : #if 0</a>
<a name="13851"><span class="lineNum">   13851 </span>            :      printf (&quot;In SageInterface::insertStatement(): insert newStmt = %p = %s before/after targetStmt = %p = %s \n&quot;,newStmt,newStmt-&gt;class_name().c_str(),targetStmt,targetStmt-&gt;class_name().c_str());</a>
<a name="13852"><span class="lineNum">   13852 </span>            : #endif</a>
<a name="13853"><span class="lineNum">   13853 </span>            : </a>
<a name="13854"><span class="lineNum">   13854 </span>            :   // DQ (12/2/2014): Not sure why this was here in the first place (likely debugging code from the fix for the SgLableStatement insertion.</a>
<a name="13855"><span class="lineNum">   13855 </span>            :   // SgFunctionDefinition* functionDefinition = SageInterface::getEnclosingProcedure(targetStmt);</a>
<a name="13856"><span class="lineNum">   13856 </span>            :   // ROSE_ASSERT(functionDefinition != NULL);</a>
<a name="13857"><span class="lineNum">   13857 </span>            : </a>
<a name="13858"><span class="lineNum">   13858 </span>            :   // Liao 3/2/2012. The semantics of ensureBasicBlockAsParent() are messy. input targetStmt may be</a>
<a name="13859"><span class="lineNum">   13859 </span>            :   // returned as it is if it is already a basic block as a body of if/while/catch/ etc.</a>
<a name="13860"><span class="lineNum">   13860 </span>            :   // We now have single statement true/false body for IfStmt etc</a>
<a name="13861"><span class="lineNum">   13861 </span>            :   // However, IfStmt::insert_child() is ambiguous and not implemented</a>
<a name="13862"><span class="lineNum">   13862 </span>            :   // So we make SgBasicBlock out of the single statement and</a>
<a name="13863"><span class="lineNum">   13863 </span>            :   // essentially call SgBasicBlock::insert_child() instead.</a>
<a name="13864"><span class="lineNum">   13864 </span>            :   // TODO: add test cases for If, variable, variable/struct inside if, etc</a>
<a name="13865"><span class="lineNum">   13865 </span>            :     // parent = ensureBasicBlockAsParent(targetStmt);</a>
<a name="13866"><span class="lineNum">   13866 </span>            : </a>
<a name="13867"><span class="lineNum">   13867 </span>            :   // must get the new scope after ensureBasicBlockAsParent ()</a>
<a name="13868"><span class="lineNum">   13868 </span><span class="lineCov">        984 :      SgScopeStatement* scope = targetStmt-&gt;get_scope();</span></a>
<a name="13869"><span class="lineNum">   13869 </span><span class="lineCov">        984 :      ROSE_ASSERT(scope);</span></a>
<a name="13870"><span class="lineNum">   13870 </span>            : </a>
<a name="13871"><span class="lineNum">   13871 </span>            : #if 0</a>
<a name="13872"><span class="lineNum">   13872 </span>            :      printf (&quot;targetStmt = %p = %s \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str());</a>
<a name="13873"><span class="lineNum">   13873 </span>            :      printf (&quot;scope      = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="13874"><span class="lineNum">   13874 </span>            : #endif</a>
<a name="13875"><span class="lineNum">   13875 </span>            : </a>
<a name="13876"><span class="lineNum">   13876 </span>            :   // DQ (11/16/2014): This step is problematic if the targetStmt has been transformed to be associated with a SgLabelStatement.</a>
<a name="13877"><span class="lineNum">   13877 </span>            :   // The reason is that the targetStmt's parent will have been reset to be the SgLabelStatement and the logic in the set_parent()</a>
<a name="13878"><span class="lineNum">   13878 </span>            :   // function will assert fail when the parent is being set to itself (which is a good idea in general).  A better solution might</a>
<a name="13879"><span class="lineNum">   13879 </span>            :   // be to set the parent to the scope of the target instead.  This would be just as correct in the general case, but also make</a>
<a name="13880"><span class="lineNum">   13880 </span>            :   // more sense in this special case of a SgLabelStatement.</a>
<a name="13881"><span class="lineNum">   13881 </span>            :   // newStmt-&gt;set_parent(targetStmt-&gt;get_parent());</a>
<a name="13882"><span class="lineNum">   13882 </span><span class="lineCov">        984 :      newStmt-&gt;set_parent(scope);</span></a>
<a name="13883"><span class="lineNum">   13883 </span>            : </a>
<a name="13884"><span class="lineNum">   13884 </span>            :   // DQ (11/16/2014): This function had a bug that is now fixed.  It allowed a 2nd SgLableSymbol to be built when an initial one was found.</a>
<a name="13885"><span class="lineNum">   13885 </span>            :   // The fix was the reuse the one that was found.</a>
<a name="13886"><span class="lineNum">   13886 </span><span class="lineCov">        984 :      fixStatement(newStmt,scope);</span></a>
<a name="13887"><span class="lineNum">   13887 </span>            : </a>
<a name="13888"><span class="lineNum">   13888 </span>            :   // DQ (9/16/2010): Added assertion that appears to be required to be true.</a>
<a name="13889"><span class="lineNum">   13889 </span>            :   // However, if this is required to be true then what about statements in</a>
<a name="13890"><span class="lineNum">   13890 </span>            :   // SgStatementExpression IR nodes?</a>
<a name="13891"><span class="lineNum">   13891 </span><span class="lineCov">        984 :      ROSE_ASSERT(isSgStatement(parent) != NULL);</span></a>
<a name="13892"><span class="lineNum">   13892 </span>            : </a>
<a name="13893"><span class="lineNum">   13893 </span>            :   // DQ (9/16/2010): Added support to move comments and CPP directives marked to</a>
<a name="13894"><span class="lineNum">   13894 </span>            :   // appear before the statement to be attached to the inserted statement (and marked</a>
<a name="13895"><span class="lineNum">   13895 </span>            :   // to appear before that statement).</a>
<a name="13896"><span class="lineNum">   13896 </span><span class="lineCov">        984 :      ROSE_ASSERT(targetStmt != NULL);</span></a>
<a name="13897"><span class="lineNum">   13897 </span><span class="lineCov">        984 :      AttachedPreprocessingInfoType* comments = targetStmt-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="13898"><span class="lineNum">   13898 </span>            : </a>
<a name="13899"><span class="lineNum">   13899 </span>            : #if 0</a>
<a name="13900"><span class="lineNum">   13900 </span>            :      printf (&quot;In SageInterface::insertStatement(): after checking for associated comments \n&quot;);</a>
<a name="13901"><span class="lineNum">   13901 </span>            :      reportNodesMarkedAsModified(scope);</a>
<a name="13902"><span class="lineNum">   13902 </span>            : #endif</a>
<a name="13903"><span class="lineNum">   13903 </span>            : </a>
<a name="13904"><span class="lineNum">   13904 </span>            :   // TODO refactor this portion of code into a separate function</a>
<a name="13905"><span class="lineNum">   13905 </span>            :   // DQ (9/17/2010): Trying to eliminate failing case in OpenMP projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu.c</a>
<a name="13906"><span class="lineNum">   13906 </span>            :   // I think that special rules apply to inserting a SgBasicBlock so disable comment reloation when inserting a SgBasicBlock.</a>
<a name="13907"><span class="lineNum">   13907 </span>            :   // if (comments != NULL &amp;&amp; newStmt-&gt;getAttachedPreprocessingInfo() == NULL)</a>
<a name="13908"><span class="lineNum">   13908 </span>            :   // if (comments != NULL)</a>
<a name="13909"><span class="lineNum">   13909 </span><span class="lineCov">        984 :      if (autoMovePreprocessingInfo) // Do this only if automatically handling of preprocessing information is request by users</span></a>
<a name="13910"><span class="lineNum">   13910 </span>            :      {</a>
<a name="13911"><span class="lineNum">   13911 </span><span class="lineCov">        852 :      if (comments != NULL &amp;&amp; isSgBasicBlock(newStmt) == NULL)</span></a>
<a name="13912"><span class="lineNum">   13912 </span>            :         {</a>
<a name="13913"><span class="lineNum">   13913 </span><span class="lineCov">          4 :           vector&lt;int&gt; captureList;</span></a>
<a name="13914"><span class="lineNum">   13914 </span>            : #if 0</a>
<a name="13915"><span class="lineNum">   13915 </span>            :           printf (&quot;Found attached comments (at %p = %s, inserting %p = %s insertBefore = %s): comments-&gt;size() = %&quot; PRIuPTR &quot; \n&quot;,</a>
<a name="13916"><span class="lineNum">   13916 </span>            :                targetStmt,targetStmt-&gt;class_name().c_str(),newStmt,newStmt-&gt;class_name().c_str(),insertBefore ? &quot;true&quot; : &quot;false&quot;,comments-&gt;size());</a>
<a name="13917"><span class="lineNum">   13917 </span>            : #endif</a>
<a name="13918"><span class="lineNum">   13918 </span>            :        // DQ (9/17/2010): Assert that the new statement being inserted has no attached comments or CPP directives.</a>
<a name="13919"><span class="lineNum">   13919 </span><span class="lineCov">          2 :           if (newStmt-&gt;getAttachedPreprocessingInfo() != NULL &amp;&amp; newStmt-&gt;getAttachedPreprocessingInfo()-&gt;empty() == false)</span></a>
<a name="13920"><span class="lineNum">   13920 </span>            :              {</a>
<a name="13921"><span class="lineNum">   13921 </span>            :             // If the inserted statment has attached comments or CPP directives then this is gets a little</a>
<a name="13922"><span class="lineNum">   13922 </span>            :             // bit more comple and we don't support that at present.</a>
<a name="13923"><span class="lineNum">   13923 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: at present statements being inserted should not have attached comments of CPP directives (could be a problem, but comment relocation is not disabled). \n&quot;);</span></a>
<a name="13924"><span class="lineNum">   13924 </span>            :              }</a>
<a name="13925"><span class="lineNum">   13925 </span>            :        // DQ (9/17/2010): commented out because it fails test in projects/OpenMP_Translator/for_firstprivate.c</a>
<a name="13926"><span class="lineNum">   13926 </span><span class="lineCov">          2 :           ROSE_ASSERT((newStmt-&gt;getAttachedPreprocessingInfo() == NULL) || (newStmt-&gt;getAttachedPreprocessingInfo() != NULL &amp;&amp; newStmt-&gt;getAttachedPreprocessingInfo()-&gt;empty() == false));</span></a>
<a name="13927"><span class="lineNum">   13927 </span>            : </a>
<a name="13928"><span class="lineNum">   13928 </span><span class="lineCov">          2 :           int commentIndex = 0;</span></a>
<a name="13929"><span class="lineNum">   13929 </span><span class="lineCov">          2 :           AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="13930"><span class="lineNum">   13930 </span><span class="lineCov">         15 :           for (i = comments-&gt;begin(); i != comments-&gt;end(); i++)</span></a>
<a name="13931"><span class="lineNum">   13931 </span>            :              {</a>
<a name="13932"><span class="lineNum">   13932 </span><span class="lineCov">         13 :                ROSE_ASSERT ( (*i) != NULL );</span></a>
<a name="13933"><span class="lineNum">   13933 </span>            : #if 0</a>
<a name="13934"><span class="lineNum">   13934 </span>            :                printf (&quot;          Attached Comment (relativePosition=%s): %s\n&quot;,</a>
<a name="13935"><span class="lineNum">   13935 </span>            :                     ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="13936"><span class="lineNum">   13936 </span>            :                     (*i)-&gt;getString().c_str());</a>
<a name="13937"><span class="lineNum">   13937 </span>            :                printf (&quot;Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*i)-&gt;getNumberOfLines(),(*i)-&gt;getColumnNumberOfEndOfString());</a>
<a name="13938"><span class="lineNum">   13938 </span>            :                (*i)-&gt;get_file_info()-&gt;display(&quot;comment/directive location&quot;);</a>
<a name="13939"><span class="lineNum">   13939 </span>            : #endif</a>
<a name="13940"><span class="lineNum">   13940 </span><span class="lineCov">         13 :                PreprocessingInfo::RelativePositionType relativePosition = (insertBefore == true) ? PreprocessingInfo::before : PreprocessingInfo::after;</span></a>
<a name="13941"><span class="lineNum">   13941 </span><span class="lineCov">         13 :                if ((*i)-&gt;getRelativePosition() == relativePosition)</span></a>
<a name="13942"><span class="lineNum">   13942 </span>            :                   {</a>
<a name="13943"><span class="lineNum">   13943 </span>            :                  // accumulate into list</a>
<a name="13944"><span class="lineNum">   13944 </span><span class="lineCov">         12 :                     captureList.push_back(commentIndex);</span></a>
<a name="13945"><span class="lineNum">   13945 </span>            :                   }</a>
<a name="13946"><span class="lineNum">   13946 </span>            : </a>
<a name="13947"><span class="lineNum">   13947 </span><span class="lineCov">         13 :                commentIndex++;</span></a>
<a name="13948"><span class="lineNum">   13948 </span>            :              }</a>
<a name="13949"><span class="lineNum">   13949 </span>            : </a>
<a name="13950"><span class="lineNum">   13950 </span>            :        // printf (&quot;captureList.size() = %&quot; PRIuPTR &quot; \n&quot;,captureList.size());</a>
<a name="13951"><span class="lineNum">   13951 </span><span class="lineCov">          2 :           if (captureList.empty() == false)</span></a>
<a name="13952"><span class="lineNum">   13952 </span>            :              {</a>
<a name="13953"><span class="lineNum">   13953 </span>            :             // Remove these comments and/or CPP directives and put them into the previous statement (marked to be output after the statement).</a>
<a name="13954"><span class="lineNum">   13954 </span>            :             // SgStatement* surroundingStatement = (insertBefore == true) ? getPreviousStatement(targetStmt) : getNextStatement(targetStmt);</a>
<a name="13955"><span class="lineNum">   13955 </span>            :             // SgStatement* surroundingStatement = (insertBefore == true) ? newStmt : newStmt;</a>
<a name="13956"><span class="lineNum">   13956 </span><span class="lineCov">          2 :                SgStatement* surroundingStatement = newStmt;</span></a>
<a name="13957"><span class="lineNum">   13957 </span><span class="lineCov">          2 :                ROSE_ASSERT(surroundingStatement != targetStmt);</span></a>
<a name="13958"><span class="lineNum">   13958 </span><span class="lineCov">          2 :                ROSE_ASSERT(surroundingStatement != NULL);</span></a>
<a name="13959"><span class="lineNum">   13959 </span>            : #if 0</a>
<a name="13960"><span class="lineNum">   13960 </span>            :                if (surroundingStatement == NULL)</a>
<a name="13961"><span class="lineNum">   13961 </span>            :                   {</a>
<a name="13962"><span class="lineNum">   13962 </span>            :                  // printf (&quot;Warning: the surrounding statement for insertBefore = %s is NULL (so use the newStmt) \n&quot;,insertBefore ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13963"><span class="lineNum">   13963 </span>            :                     surroundingStatement = (insertBefore == true) ? newStmt : newStmt;</a>
<a name="13964"><span class="lineNum">   13964 </span>            :                   }</a>
<a name="13965"><span class="lineNum">   13965 </span>            : #endif</a>
<a name="13966"><span class="lineNum">   13966 </span>            :             // Now add the entries from the captureList to the surroundingStatement and remove them from the targetStmt.</a>
<a name="13967"><span class="lineNum">   13967 </span>            :             // printf (&quot;This is a valid surrounding statement = %s for insertBefore = %s \n&quot;,surroundingStatement-&gt;class_name().c_str(),insertBefore ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="13968"><span class="lineNum">   13968 </span><span class="lineCov">          2 :                vector&lt;int&gt;::iterator j = captureList.begin();</span></a>
<a name="13969"><span class="lineNum">   13969 </span><span class="lineCov">         14 :                while (j != captureList.end())</span></a>
<a name="13970"><span class="lineNum">   13970 </span>            :                   {</a>
<a name="13971"><span class="lineNum">   13971 </span>            :                  // Add the captured comments to the new statement. Likely we need to make sure that the order is preserved.</a>
<a name="13972"><span class="lineNum">   13972 </span>            :                  // printf (&quot;Attaching comments to newStmt = %p = %s \n&quot;,newStmt,newStmt-&gt;class_name().c_str());</a>
<a name="13973"><span class="lineNum">   13973 </span><span class="lineCov">         12 :                     newStmt-&gt;addToAttachedPreprocessingInfo((*comments)[*j]);</span></a>
<a name="13974"><span class="lineNum">   13974 </span>            : </a>
<a name="13975"><span class="lineNum">   13975 </span>            :                  // Remove them from the targetStmt. (set them to NULL and then remove them in a separate step).</a>
<a name="13976"><span class="lineNum">   13976 </span>            :                  // printf (&quot;Removing entry from comments list on targetStmt = %p = %s \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str());</a>
<a name="13977"><span class="lineNum">   13977 </span><span class="lineCov">         12 :                     (*comments)[*j] = NULL;</span></a>
<a name="13978"><span class="lineNum">   13978 </span>            : </a>
<a name="13979"><span class="lineNum">   13979 </span><span class="lineCov">         12 :                     j++;</span></a>
<a name="13980"><span class="lineNum">   13980 </span>            :                   }</a>
<a name="13981"><span class="lineNum">   13981 </span>            : </a>
<a name="13982"><span class="lineNum">   13982 </span>            :             // Now remove each NULL entries in the comments vector.</a>
<a name="13983"><span class="lineNum">   13983 </span>            :             // Because of iterator invalidation we must reset the iterators after each call to erase (I think).</a>
<a name="13984"><span class="lineNum">   13984 </span><span class="lineCov">         14 :                for (size_t n = 0; n &lt; captureList.size(); n++)</span></a>
<a name="13985"><span class="lineNum">   13985 </span>            :                   {</a>
<a name="13986"><span class="lineNum">   13986 </span><span class="lineCov">         12 :                     AttachedPreprocessingInfoType::iterator k = comments-&gt;begin();</span></a>
<a name="13987"><span class="lineNum">   13987 </span><span class="lineCov">         16 :                     while (k != comments-&gt;end())</span></a>
<a name="13988"><span class="lineNum">   13988 </span>            :                        {</a>
<a name="13989"><span class="lineNum">   13989 </span>            :                       // Only modify the list once per iteration over the captureList</a>
<a name="13990"><span class="lineNum">   13990 </span><span class="lineCov">         16 :                          if (*k == NULL)</span></a>
<a name="13991"><span class="lineNum">   13991 </span>            :                             {</a>
<a name="13992"><span class="lineNum">   13992 </span><span class="lineCov">         12 :                               comments-&gt;erase(k);</span></a>
<a name="13993"><span class="lineNum">   13993 </span><span class="lineCov">         12 :                                                           break;</span></a>
<a name="13994"><span class="lineNum">   13994 </span>            :                             }</a>
<a name="13995"><span class="lineNum">   13995 </span><span class="lineCov">          4 :                              k++;</span></a>
<a name="13996"><span class="lineNum">   13996 </span>            :                        }</a>
<a name="13997"><span class="lineNum">   13997 </span>            :                   }</a>
<a name="13998"><span class="lineNum">   13998 </span>            :              }</a>
<a name="13999"><span class="lineNum">   13999 </span>            :         }</a>
<a name="14000"><span class="lineNum">   14000 </span>            :        else</a>
<a name="14001"><span class="lineNum">   14001 </span>            :         {</a>
<a name="14002"><span class="lineNum">   14002 </span>            :        // printf (&quot;No attached comments (at %p of type: %s): \n&quot;,targetStmt,targetStmt-&gt;class_name().c_str());</a>
<a name="14003"><span class="lineNum">   14003 </span>            :        // DQ (9/17/2010): Trying to eliminate failing case in OpenMP projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu.c</a>
<a name="14004"><span class="lineNum">   14004 </span>            :        // I think that special rules apply to inserting a SgBasicBlock so disable comment relocation when inserting a SgBasicBlock.</a>
<a name="14005"><span class="lineNum">   14005 </span><span class="lineCov">        850 :           if (comments != NULL)</span></a>
<a name="14006"><span class="lineNum">   14006 </span>            :              {</a>
<a name="14007"><span class="lineNum">   14007 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: special rules appear to apply to the insertion of a SgBasicBlock which has attached comments and/or CPP directives (comment relocation disabled). \n&quot;);</span></a>
<a name="14008"><span class="lineNum">   14008 </span>            :              }</a>
<a name="14009"><span class="lineNum">   14009 </span>            :         }</a>
<a name="14010"><span class="lineNum">   14010 </span>            :      } // end if autoMovePreprocessingInfo</a>
<a name="14011"><span class="lineNum">   14011 </span>            : </a>
<a name="14012"><span class="lineNum">   14012 </span>            : </a>
<a name="14013"><span class="lineNum">   14013 </span>            : #if 0</a>
<a name="14014"><span class="lineNum">   14014 </span>            :      printf (&quot;In SageInterface::insertStatement(): after processing associated comments \n&quot;);</a>
<a name="14015"><span class="lineNum">   14015 </span>            :      reportNodesMarkedAsModified(scope);</a>
<a name="14016"><span class="lineNum">   14016 </span>            : #endif</a>
<a name="14017"><span class="lineNum">   14017 </span>            : </a>
<a name="14018"><span class="lineNum">   14018 </span><span class="lineCov">        984 :      if (isSgIfStmt(parent))</span></a>
<a name="14019"><span class="lineNum">   14019 </span>            :         {</a>
<a name="14020"><span class="lineNum">   14020 </span><span class="lineCov">         66 :           if (isSgIfStmt(parent)-&gt;get_conditional()==targetStmt)</span></a>
<a name="14021"><span class="lineNum">   14021 </span>            :              {</a>
<a name="14022"><span class="lineNum">   14022 </span><span class="lineNoCov">          0 :                insertStatement(isSgStatement(parent),newStmt,insertBefore);</span></a>
<a name="14023"><span class="lineNum">   14023 </span>            :              }</a>
<a name="14024"><span class="lineNum">   14024 </span>            :             else</a>
<a name="14025"><span class="lineNum">   14025 </span>            :              {</a>
<a name="14026"><span class="lineNum">   14026 </span><span class="lineCov">         66 :                if (isSgIfStmt(parent)-&gt;get_true_body()==targetStmt)</span></a>
<a name="14027"><span class="lineNum">   14027 </span>            :                   {</a>
<a name="14028"><span class="lineNum">   14028 </span>            :                     // Liao 3/2/2012</a>
<a name="14029"><span class="lineNum">   14029 </span>            :                     // We have some choices:</a>
<a name="14030"><span class="lineNum">   14030 </span>            :                     // 1) if the targeStmt is a basic block, we can append/prepend the new stmt</a>
<a name="14031"><span class="lineNum">   14031 </span>            :                     // within the targetStmt. But this is not the exact semantics of insertStatment. It will break the outliner.</a>
<a name="14032"><span class="lineNum">   14032 </span>            :                     // Since the targetStmt will have new content inside of it, which is not the semantics of</a>
<a name="14033"><span class="lineNum">   14033 </span>            :                     // inserting anything before/or after it.</a>
<a name="14034"><span class="lineNum">   14034 </span>            :                     // 2) always insert a padding basic block between parent and targetStmt</a>
<a name="14035"><span class="lineNum">   14035 </span>            :                     //   and we can legally insert before/after the target statement within the</a>
<a name="14036"><span class="lineNum">   14036 </span>            :                     //   padding basic block.</a>
<a name="14037"><span class="lineNum">   14037 </span>            :                     //TODO: this insertion of padding basic block should ideally go into some AST normalization phase</a>
<a name="14038"><span class="lineNum">   14038 </span>            :                     // so the transformation function (insertStatement) only does what it means to do, no more and no less.</a>
<a name="14039"><span class="lineNum">   14039 </span><span class="lineCov">          4 :                     SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14040"><span class="lineNum">   14040 </span><span class="lineCov">          4 :                     isSgIfStmt(parent)-&gt;set_true_body(newparent);</span></a>
<a name="14041"><span class="lineNum">   14041 </span><span class="lineCov">          4 :                     newparent-&gt;set_parent(parent);</span></a>
<a name="14042"><span class="lineNum">   14042 </span><span class="lineCov">          4 :                     insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14043"><span class="lineNum">   14043 </span>            :                   }</a>
<a name="14044"><span class="lineNum">   14044 </span>            :                  else</a>
<a name="14045"><span class="lineNum">   14045 </span>            :                   {</a>
<a name="14046"><span class="lineNum">   14046 </span><span class="lineCov">         62 :                     if (isSgIfStmt(parent)-&gt;get_false_body()==targetStmt)</span></a>
<a name="14047"><span class="lineNum">   14047 </span>            :                        {</a>
<a name="14048"><span class="lineNum">   14048 </span>            :                       // ensureBasicBlockAsParent(targetStmt);</a>
<a name="14049"><span class="lineNum">   14049 </span><span class="lineCov">         62 :                          SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14050"><span class="lineNum">   14050 </span><span class="lineCov">         62 :                          isSgIfStmt(parent)-&gt;set_false_body(newparent);</span></a>
<a name="14051"><span class="lineNum">   14051 </span><span class="lineCov">         62 :                          newparent-&gt;set_parent(parent);</span></a>
<a name="14052"><span class="lineNum">   14052 </span><span class="lineCov">         62 :                          insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14053"><span class="lineNum">   14053 </span>            :                       // insertStatement(isSgStatement(parent),newStmt,insertBefore);</a>
<a name="14054"><span class="lineNum">   14054 </span>            :                        }</a>
<a name="14055"><span class="lineNum">   14055 </span>            :                   }</a>
<a name="14056"><span class="lineNum">   14056 </span>            :              }</a>
<a name="14057"><span class="lineNum">   14057 </span>            :         }</a>
<a name="14058"><span class="lineNum">   14058 </span>            :        else</a>
<a name="14059"><span class="lineNum">   14059 </span>            :         {</a>
<a name="14060"><span class="lineNum">   14060 </span><span class="lineCov">        918 :           if (isSgWhileStmt(parent))</span></a>
<a name="14061"><span class="lineNum">   14061 </span>            :              {</a>
<a name="14062"><span class="lineNum">   14062 </span><span class="lineNoCov">          0 :                if (isSgWhileStmt(parent)-&gt;get_condition()==targetStmt)</span></a>
<a name="14063"><span class="lineNum">   14063 </span>            :                   {</a>
<a name="14064"><span class="lineNum">   14064 </span><span class="lineNoCov">          0 :                     insertStatement(isSgStatement(parent),newStmt,insertBefore);</span></a>
<a name="14065"><span class="lineNum">   14065 </span>            :                   }</a>
<a name="14066"><span class="lineNum">   14066 </span>            :                  else</a>
<a name="14067"><span class="lineNum">   14067 </span>            :                   {</a>
<a name="14068"><span class="lineNum">   14068 </span><span class="lineNoCov">          0 :                     if (isSgWhileStmt(parent)-&gt;get_body()==targetStmt)</span></a>
<a name="14069"><span class="lineNum">   14069 </span>            :                        {</a>
<a name="14070"><span class="lineNum">   14070 </span><span class="lineNoCov">          0 :                          SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14071"><span class="lineNum">   14071 </span><span class="lineNoCov">          0 :                          isSgWhileStmt(parent)-&gt;set_body(newparent);</span></a>
<a name="14072"><span class="lineNum">   14072 </span><span class="lineNoCov">          0 :                          newparent-&gt;set_parent(parent);</span></a>
<a name="14073"><span class="lineNum">   14073 </span><span class="lineNoCov">          0 :                          insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14074"><span class="lineNum">   14074 </span>            :                       // ensureBasicBlockAsParent(targetStmt);</a>
<a name="14075"><span class="lineNum">   14075 </span>            :                       // insertStatement(isSgStatement(parent),newStmt,insertBefore);</a>
<a name="14076"><span class="lineNum">   14076 </span>            :                        }</a>
<a name="14077"><span class="lineNum">   14077 </span>            :                   }</a>
<a name="14078"><span class="lineNum">   14078 </span>            :              }</a>
<a name="14079"><span class="lineNum">   14079 </span>            :             else</a>
<a name="14080"><span class="lineNum">   14080 </span>            :              {</a>
<a name="14081"><span class="lineNum">   14081 </span><span class="lineCov">        918 :                if (isSgDoWhileStmt(parent))</span></a>
<a name="14082"><span class="lineNum">   14082 </span>            :                   {</a>
<a name="14083"><span class="lineNum">   14083 </span><span class="lineNoCov">          0 :                     if (isSgDoWhileStmt(parent)-&gt;get_condition()==targetStmt)</span></a>
<a name="14084"><span class="lineNum">   14084 </span>            :                        {</a>
<a name="14085"><span class="lineNum">   14085 </span><span class="lineNoCov">          0 :                          insertStatement(isSgStatement(parent),newStmt,insertBefore);</span></a>
<a name="14086"><span class="lineNum">   14086 </span>            :                        }</a>
<a name="14087"><span class="lineNum">   14087 </span>            :                       else</a>
<a name="14088"><span class="lineNum">   14088 </span>            :                        {</a>
<a name="14089"><span class="lineNum">   14089 </span><span class="lineNoCov">          0 :                          if (isSgDoWhileStmt(parent)-&gt;get_body()==targetStmt)</span></a>
<a name="14090"><span class="lineNum">   14090 </span>            :                             {</a>
<a name="14091"><span class="lineNum">   14091 </span><span class="lineNoCov">          0 :                               SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14092"><span class="lineNum">   14092 </span><span class="lineNoCov">          0 :                               isSgDoWhileStmt(parent)-&gt;set_body(newparent);</span></a>
<a name="14093"><span class="lineNum">   14093 </span><span class="lineNoCov">          0 :                               newparent-&gt;set_parent(parent);</span></a>
<a name="14094"><span class="lineNum">   14094 </span><span class="lineNoCov">          0 :                               insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14095"><span class="lineNum">   14095 </span>            :                            // ensureBasicBlockAsParent(targetStmt);</a>
<a name="14096"><span class="lineNum">   14096 </span>            :                            // insertStatement(isSgStatement(parent),newStmt,insertBefore);</a>
<a name="14097"><span class="lineNum">   14097 </span>            :                             }</a>
<a name="14098"><span class="lineNum">   14098 </span>            :                        }</a>
<a name="14099"><span class="lineNum">   14099 </span>            :                   }</a>
<a name="14100"><span class="lineNum">   14100 </span>            :                  else</a>
<a name="14101"><span class="lineNum">   14101 </span>            :                   {</a>
<a name="14102"><span class="lineNum">   14102 </span><span class="lineCov">        918 :                     if (isSgForStatement(parent))</span></a>
<a name="14103"><span class="lineNum">   14103 </span>            :                        {</a>
<a name="14104"><span class="lineNum">   14104 </span><span class="lineCov">         15 :                          if (isSgForStatement(parent)-&gt;get_loop_body()==targetStmt)</span></a>
<a name="14105"><span class="lineNum">   14105 </span>            :                             {</a>
<a name="14106"><span class="lineNum">   14106 </span><span class="lineCov">         15 :                               SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14107"><span class="lineNum">   14107 </span><span class="lineCov">         15 :                               isSgForStatement(parent)-&gt;set_loop_body(newparent);</span></a>
<a name="14108"><span class="lineNum">   14108 </span><span class="lineCov">         15 :                               newparent-&gt;set_parent(parent);</span></a>
<a name="14109"><span class="lineNum">   14109 </span><span class="lineCov">         15 :                               insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14110"><span class="lineNum">   14110 </span>            :                            // ensureBasicBlockAsParent(targetStmt);</a>
<a name="14111"><span class="lineNum">   14111 </span>            :                            // insertStatement(isSgStatement(parent),newStmt,insertBefore);</a>
<a name="14112"><span class="lineNum">   14112 </span>            :                             }</a>
<a name="14113"><span class="lineNum">   14113 </span>            :                            else</a>
<a name="14114"><span class="lineNum">   14114 </span>            :                             {</a>
<a name="14115"><span class="lineNum">   14115 </span><span class="lineNoCov">          0 :                               if (isSgForStatement(parent)-&gt;get_test()==targetStmt)</span></a>
<a name="14116"><span class="lineNum">   14116 </span>            :                                  {</a>
<a name="14117"><span class="lineNum">   14117 </span><span class="lineNoCov">          0 :                                    insertStatement(isSgStatement(parent),newStmt,insertBefore);</span></a>
<a name="14118"><span class="lineNum">   14118 </span>            :                                  }</a>
<a name="14119"><span class="lineNum">   14119 </span>            :                             }</a>
<a name="14120"><span class="lineNum">   14120 </span>            :                        }</a>
<a name="14121"><span class="lineNum">   14121 </span>            :                       else // \pp (2/24/2011) added support for UpcForAll</a>
<a name="14122"><span class="lineNum">   14122 </span>            :                        {</a>
<a name="14123"><span class="lineNum">   14123 </span><span class="lineCov">        903 :                          if (SgUpcForAllStatement* p = isSgUpcForAllStatement(parent))</span></a>
<a name="14124"><span class="lineNum">   14124 </span>            :                             {</a>
<a name="14125"><span class="lineNum">   14125 </span>            :                               //const bool stmt_present = (p-&gt;get_loop_body() == targetStmt || p-&gt;get_test() == targetStmt);</a>
<a name="14126"><span class="lineNum">   14126 </span>            : </a>
<a name="14127"><span class="lineNum">   14127 </span>            :                           // \pp \todo what if !stmt_present</a>
<a name="14128"><span class="lineNum">   14128 </span>            :                            // ROSE_ASSERT(stmt_present != NULL);</a>
<a name="14129"><span class="lineNum">   14129 </span><span class="lineNoCov">          0 :                               insertStatement(p, newStmt, insertBefore);</span></a>
<a name="14130"><span class="lineNum">   14130 </span>            :                             }</a>
<a name="14131"><span class="lineNum">   14131 </span>            :                            else</a>
<a name="14132"><span class="lineNum">   14132 </span>            :                             {</a>
<a name="14133"><span class="lineNum">   14133 </span><span class="lineCov">        903 :                               if (SgUpirBodyStatement * p = isSgUpirBodyStatement (parent))</span></a>
<a name="14134"><span class="lineNum">   14134 </span>            :                                  {</a>
<a name="14135"><span class="lineNum">   14135 </span><span class="lineNoCov">          0 :                                    SgBasicBlock* newparent = buildBasicBlock (targetStmt);</span></a>
<a name="14136"><span class="lineNum">   14136 </span><span class="lineNoCov">          0 :                                    p-&gt;set_body(newparent);</span></a>
<a name="14137"><span class="lineNum">   14137 </span><span class="lineNoCov">          0 :                                    newparent-&gt;set_parent(parent);</span></a>
<a name="14138"><span class="lineNum">   14138 </span><span class="lineNoCov">          0 :                                    insertStatement(targetStmt, newStmt,insertBefore);</span></a>
<a name="14139"><span class="lineNum">   14139 </span>            :                                  }</a>
<a name="14140"><span class="lineNum">   14140 </span>            :                                else</a>
<a name="14141"><span class="lineNum">   14141 </span>            :                                  {</a>
<a name="14142"><span class="lineNum">   14142 </span>            :                                 // It appears that all of the recursive calls are untimately calling this location.</a>
<a name="14143"><span class="lineNum">   14143 </span><span class="lineCov">        903 :                                    SgStatement* stmnt = isSgStatement(parent);</span></a>
<a name="14144"><span class="lineNum">   14144 </span><span class="lineCov">        903 :                                    ROSE_ASSERT(stmnt != NULL);</span></a>
<a name="14145"><span class="lineNum">   14145 </span><span class="lineCov">        903 :                                    stmnt-&gt;insert_statement(targetStmt,newStmt,insertBefore);</span></a>
<a name="14146"><span class="lineNum">   14146 </span>            :                                  }</a>
<a name="14147"><span class="lineNum">   14147 </span>            :                             }</a>
<a name="14148"><span class="lineNum">   14148 </span>            :                        }</a>
<a name="14149"><span class="lineNum">   14149 </span>            :                   }</a>
<a name="14150"><span class="lineNum">   14150 </span>            :              }</a>
<a name="14151"><span class="lineNum">   14151 </span>            :         }</a>
<a name="14152"><span class="lineNum">   14152 </span>            : </a>
<a name="14153"><span class="lineNum">   14153 </span>            :   // DQ (11/19/2012): If we are building the AST within the front-end then don't do this expensive</a>
<a name="14154"><span class="lineNum">   14154 </span>            :   // fixup (we already set it properly in the AST construction within the frontend so we don't need</a>
<a name="14155"><span class="lineNum">   14155 </span>            :   // this).  Also since this is only operating within a single scope it is likely too specific to C</a>
<a name="14156"><span class="lineNum">   14156 </span>            :   // instead of addessing the details of C++ where functions can be placed in alternative scopes and</a>
<a name="14157"><span class="lineNum">   14157 </span>            :   // use name qualification).</a>
<a name="14158"><span class="lineNum">   14158 </span>            :   // update the links after insertion!</a>
<a name="14159"><span class="lineNum">   14159 </span>            :   // if (isSgFunctionDeclaration(newStmt))</a>
<a name="14160"><span class="lineNum">   14160 </span><span class="lineCov">        984 :      SourcePositionClassification scp = getSourcePositionClassificationMode();</span></a>
<a name="14161"><span class="lineNum">   14161 </span><span class="lineCov">        984 :      if ( (scp != e_sourcePositionFrontendConstruction) &amp;&amp; (isSgFunctionDeclaration(newStmt) != NULL) )</span></a>
<a name="14162"><span class="lineNum">   14162 </span>            :         {</a>
<a name="14163"><span class="lineNum">   14163 </span><span class="lineNoCov">          0 :           updateDefiningNondefiningLinks(isSgFunctionDeclaration(newStmt),scope);</span></a>
<a name="14164"><span class="lineNum">   14164 </span>            :         }</a>
<a name="14165"><span class="lineNum">   14165 </span>            : </a>
<a name="14166"><span class="lineNum">   14166 </span>            : #if 0</a>
<a name="14167"><span class="lineNum">   14167 </span>            :      printf (&quot;In SageInterface::insertStatement(): at BASE of function \n&quot;);</a>
<a name="14168"><span class="lineNum">   14168 </span>            :      reportNodesMarkedAsModified(scope);</a>
<a name="14169"><span class="lineNum">   14169 </span>            : #endif</a>
<a name="14170"><span class="lineNum">   14170 </span><span class="lineCov">        984 :    }</span></a>
<a name="14171"><span class="lineNum">   14171 </span>            : </a>
<a name="14172"><span class="lineNum">   14172 </span>            : </a>
<a name="14173"><span class="lineNum">   14173 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementList(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmts, bool insertBefore)</span></a>
<a name="14174"><span class="lineNum">   14174 </span>            :    {</a>
<a name="14175"><span class="lineNum">   14175 </span><span class="lineNoCov">          0 :      if (insertBefore)</span></a>
<a name="14176"><span class="lineNum">   14176 </span>            :         {</a>
<a name="14177"><span class="lineNum">   14177 </span><span class="lineNoCov">          0 :           for (size_t i = 0; i &lt; newStmts.size(); ++i)</span></a>
<a name="14178"><span class="lineNum">   14178 </span>            :              {</a>
<a name="14179"><span class="lineNum">   14179 </span><span class="lineNoCov">          0 :                insertStatementBefore(targetStmt, newStmts[i]);</span></a>
<a name="14180"><span class="lineNum">   14180 </span>            :              }</a>
<a name="14181"><span class="lineNum">   14181 </span>            :         }</a>
<a name="14182"><span class="lineNum">   14182 </span>            :        else</a>
<a name="14183"><span class="lineNum">   14183 </span>            :         {</a>
<a name="14184"><span class="lineNum">   14184 </span><span class="lineNoCov">          0 :           for (size_t i = newStmts.size(); i &gt; 0; --i)</span></a>
<a name="14185"><span class="lineNum">   14185 </span>            :              {</a>
<a name="14186"><span class="lineNum">   14186 </span><span class="lineNoCov">          0 :                insertStatementAfter(targetStmt, newStmts[i - 1]);</span></a>
<a name="14187"><span class="lineNum">   14187 </span>            :              }</a>
<a name="14188"><span class="lineNum">   14188 </span>            :         }</a>
<a name="14189"><span class="lineNum">   14189 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="14190"><span class="lineNum">   14190 </span>            : </a>
<a name="14191"><span class="lineNum">   14191 </span><span class="lineCov">         44 : void SageInterface::insertStatementAfter(SgStatement *targetStmt, SgStatement* newStmt, bool autoMovePreprocessingInfo /*= true*/)</span></a>
<a name="14192"><span class="lineNum">   14192 </span>            :   {</a>
<a name="14193"><span class="lineNum">   14193 </span><span class="lineCov">         44 :     insertStatement(targetStmt,newStmt,false, autoMovePreprocessingInfo);</span></a>
<a name="14194"><span class="lineNum">   14194 </span><span class="lineCov">         44 :   }</span></a>
<a name="14195"><span class="lineNum">   14195 </span>            : </a>
<a name="14196"><span class="lineNum">   14196 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementListAfter(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmts)</span></a>
<a name="14197"><span class="lineNum">   14197 </span>            :   {</a>
<a name="14198"><span class="lineNum">   14198 </span><span class="lineNoCov">          0 :     insertStatementList(targetStmt,newStmts,false);</span></a>
<a name="14199"><span class="lineNum">   14199 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="14200"><span class="lineNum">   14200 </span>            : </a>
<a name="14201"><span class="lineNum">   14201 </span>            : //! Insert a statement after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found</a>
<a name="14202"><span class="lineNum">   14202 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementAfterLastDeclaration(SgStatement* stmt, SgScopeStatement* scope)</span></a>
<a name="14203"><span class="lineNum">   14203 </span>            :   {</a>
<a name="14204"><span class="lineNum">   14204 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (stmt != NULL);</span></a>
<a name="14205"><span class="lineNum">   14205 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (scope != NULL);</span></a>
<a name="14206"><span class="lineNum">   14206 </span>            :     // Insert to be the declaration after current declaration sequence, if any</a>
<a name="14207"><span class="lineNum">   14207 </span><span class="lineNoCov">          0 :     SgStatement* l_stmt = findLastDeclarationStatement (scope);</span></a>
<a name="14208"><span class="lineNum">   14208 </span><span class="lineNoCov">          0 :     if (l_stmt)</span></a>
<a name="14209"><span class="lineNum">   14209 </span><span class="lineNoCov">          0 :       insertStatementAfter(l_stmt,stmt);</span></a>
<a name="14210"><span class="lineNum">   14210 </span>            :     else</a>
<a name="14211"><span class="lineNum">   14211 </span><span class="lineNoCov">          0 :       prependStatement(stmt, scope);</span></a>
<a name="14212"><span class="lineNum">   14212 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="14213"><span class="lineNum">   14213 </span>            : </a>
<a name="14214"><span class="lineNum">   14214 </span>            : //! Insert a list of statements after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found</a>
<a name="14215"><span class="lineNum">   14215 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementAfterLastDeclaration(std::vector&lt;SgStatement*&gt; stmt_list, SgScopeStatement* scope)</span></a>
<a name="14216"><span class="lineNum">   14216 </span>            :   {</a>
<a name="14217"><span class="lineNum">   14217 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (scope != NULL);</span></a>
<a name="14218"><span class="lineNum">   14218 </span><span class="lineNoCov">          0 :     vector &lt;SgStatement* &gt;::iterator iter;</span></a>
<a name="14219"><span class="lineNum">   14219 </span><span class="lineNoCov">          0 :     SgStatement* prev_stmt = NULL;</span></a>
<a name="14220"><span class="lineNum">   14220 </span><span class="lineNoCov">          0 :     for (iter= stmt_list.begin(); iter != stmt_list.end(); iter++)</span></a>
<a name="14221"><span class="lineNum">   14221 </span>            :     {</a>
<a name="14222"><span class="lineNum">   14222 </span><span class="lineNoCov">          0 :       if (iter == stmt_list.begin())</span></a>
<a name="14223"><span class="lineNum">   14223 </span>            :       {</a>
<a name="14224"><span class="lineNum">   14224 </span><span class="lineNoCov">          0 :         insertStatementAfterLastDeclaration (*iter, scope);</span></a>
<a name="14225"><span class="lineNum">   14225 </span>            :       }</a>
<a name="14226"><span class="lineNum">   14226 </span>            :       else</a>
<a name="14227"><span class="lineNum">   14227 </span>            :       {</a>
<a name="14228"><span class="lineNum">   14228 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (prev_stmt != NULL);</span></a>
<a name="14229"><span class="lineNum">   14229 </span><span class="lineNoCov">          0 :         insertStatementAfter (prev_stmt, *iter);</span></a>
<a name="14230"><span class="lineNum">   14230 </span>            :       }</a>
<a name="14231"><span class="lineNum">   14231 </span><span class="lineNoCov">          0 :       prev_stmt = *iter;</span></a>
<a name="14232"><span class="lineNum">   14232 </span>            :     }</a>
<a name="14233"><span class="lineNum">   14233 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="14234"><span class="lineNum">   14234 </span>            : </a>
<a name="14235"><span class="lineNum">   14235 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementBeforeFirstNonDeclaration(SgStatement *newStmt, SgScopeStatement *scope, bool movePreprocessingInfo)</span></a>
<a name="14236"><span class="lineNum">   14236 </span>            : {</a>
<a name="14237"><span class="lineNum">   14237 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(newStmt!=NULL);</span></a>
<a name="14238"><span class="lineNum">   14238 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(scope!=NULL);</span></a>
<a name="14239"><span class="lineNum">   14239 </span><span class="lineNoCov">          0 :     BOOST_FOREACH (SgStatement *targetStmt, scope-&gt;generateStatementList()) {</span></a>
<a name="14240"><span class="lineNum">   14240 </span><span class="lineNoCov">          0 :         if (!isSgDeclarationStatement(targetStmt)) {</span></a>
<a name="14241"><span class="lineNum">   14241 </span><span class="lineNoCov">          0 :             insertStatementBefore(targetStmt, newStmt, movePreprocessingInfo);</span></a>
<a name="14242"><span class="lineNum">   14242 </span><span class="lineNoCov">          0 :             return;</span></a>
<a name="14243"><span class="lineNum">   14243 </span>            :         }</a>
<a name="14244"><span class="lineNum">   14244 </span>            :     }</a>
<a name="14245"><span class="lineNum">   14245 </span><span class="lineNoCov">          0 :     appendStatement(newStmt, scope);</span></a>
<a name="14246"><span class="lineNum">   14246 </span>            : }</a>
<a name="14247"><span class="lineNum">   14247 </span>            : </a>
<a name="14248"><span class="lineNum">   14248 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementListBeforeFirstNonDeclaration(const std::vector&lt;SgStatement*&gt; &amp;newStmts,SgScopeStatement *scope)</span></a>
<a name="14249"><span class="lineNum">   14249 </span>            : {</a>
<a name="14250"><span class="lineNum">   14250 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(scope!=NULL);</span></a>
<a name="14251"><span class="lineNum">   14251 </span><span class="lineNoCov">          0 :     BOOST_FOREACH (SgStatement *targetStmt, scope-&gt;generateStatementList()) {</span></a>
<a name="14252"><span class="lineNum">   14252 </span><span class="lineNoCov">          0 :         if (!isSgDeclarationStatement(targetStmt)) {</span></a>
<a name="14253"><span class="lineNum">   14253 </span><span class="lineNoCov">          0 :             insertStatementListBefore(targetStmt, newStmts);</span></a>
<a name="14254"><span class="lineNum">   14254 </span><span class="lineNoCov">          0 :             return;</span></a>
<a name="14255"><span class="lineNum">   14255 </span>            :         }</a>
<a name="14256"><span class="lineNum">   14256 </span>            :     }</a>
<a name="14257"><span class="lineNum">   14257 </span><span class="lineNoCov">          0 :     appendStatementList(newStmts, scope);</span></a>
<a name="14258"><span class="lineNum">   14258 </span>            : }</a>
<a name="14259"><span class="lineNum">   14259 </span>            : </a>
<a name="14260"><span class="lineNum">   14260 </span><span class="lineCov">        851 : void SageInterface::insertStatementBefore(SgStatement *targetStmt, SgStatement* newStmt, bool autoMovePreprocessingInfo /*= true */)</span></a>
<a name="14261"><span class="lineNum">   14261 </span>            :   {</a>
<a name="14262"><span class="lineNum">   14262 </span><span class="lineCov">        851 :     insertStatement(targetStmt,newStmt,true, autoMovePreprocessingInfo);</span></a>
<a name="14263"><span class="lineNum">   14263 </span><span class="lineCov">        851 :   }</span></a>
<a name="14264"><span class="lineNum">   14264 </span>            : </a>
<a name="14265"><span class="lineNum">   14265 </span><span class="lineNoCov">          0 : void SageInterface::insertStatementListBefore(SgStatement *targetStmt, const std::vector&lt;SgStatement*&gt;&amp; newStmts)</span></a>
<a name="14266"><span class="lineNum">   14266 </span>            :   {</a>
<a name="14267"><span class="lineNum">   14267 </span><span class="lineNoCov">          0 :     insertStatementList(targetStmt,newStmts,true);</span></a>
<a name="14268"><span class="lineNum">   14268 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="14269"><span class="lineNum">   14269 </span>            : </a>
<a name="14270"><span class="lineNum">   14270 </span>            :   //a wrapper for set_expression(), set_operand(), set_operand_exp() etc</a>
<a name="14271"><span class="lineNum">   14271 </span>            :   // special concern for lvalue, parent,</a>
<a name="14272"><span class="lineNum">   14272 </span>            :   // todo: warning overwriting existing operands</a>
<a name="14273"><span class="lineNum">   14273 </span><span class="lineCov">          1 : void SageInterface::setOperand(SgExpression* target, SgExpression* operand)</span></a>
<a name="14274"><span class="lineNum">   14274 </span>            :   {</a>
<a name="14275"><span class="lineNum">   14275 </span><span class="lineCov">          1 :     ROSE_ASSERT(target);</span></a>
<a name="14276"><span class="lineNum">   14276 </span><span class="lineCov">          1 :     ROSE_ASSERT(operand);</span></a>
<a name="14277"><span class="lineNum">   14277 </span><span class="lineCov">          1 :     ROSE_ASSERT(target!=operand);</span></a>
<a name="14278"><span class="lineNum">   14278 </span><span class="lineCov">          1 :     switch (target-&gt;variantT())</span></a>
<a name="14279"><span class="lineNum">   14279 </span>            :     {</a>
<a name="14280"><span class="lineNum">   14280 </span><span class="lineNoCov">          0 :       case V_SgActualArgumentExpression:</span></a>
<a name="14281"><span class="lineNum">   14281 </span><span class="lineNoCov">          0 :         isSgActualArgumentExpression(target)-&gt;set_expression(operand);</span></a>
<a name="14282"><span class="lineNum">   14282 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14283"><span class="lineNum">   14283 </span><span class="lineNoCov">          0 :       case V_SgAsmOp:</span></a>
<a name="14284"><span class="lineNum">   14284 </span><span class="lineNoCov">          0 :         isSgAsmOp(target)-&gt;set_expression(operand);</span></a>
<a name="14285"><span class="lineNum">   14285 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14286"><span class="lineNum">   14286 </span><span class="lineNoCov">          0 :       case V_SgSizeOfOp:</span></a>
<a name="14287"><span class="lineNum">   14287 </span><span class="lineNoCov">          0 :         isSgSizeOfOp(target)-&gt;set_operand_expr(operand);</span></a>
<a name="14288"><span class="lineNum">   14288 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14289"><span class="lineNum">   14289 </span><span class="lineNoCov">          0 :       case V_SgTypeIdOp:</span></a>
<a name="14290"><span class="lineNum">   14290 </span><span class="lineNoCov">          0 :         isSgTypeIdOp(target)-&gt;set_operand_expr(operand);</span></a>
<a name="14291"><span class="lineNum">   14291 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14292"><span class="lineNum">   14292 </span><span class="lineNoCov">          0 :       case V_SgVarArgOp:</span></a>
<a name="14293"><span class="lineNum">   14293 </span><span class="lineNoCov">          0 :         isSgVarArgOp(target)-&gt;set_operand_expr(operand);</span></a>
<a name="14294"><span class="lineNum">   14294 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14295"><span class="lineNum">   14295 </span><span class="lineNoCov">          0 :       case V_SgVarArgStartOneOperandOp:</span></a>
<a name="14296"><span class="lineNum">   14296 </span><span class="lineNoCov">          0 :         isSgVarArgStartOneOperandOp(target)-&gt;set_operand_expr(operand);</span></a>
<a name="14297"><span class="lineNum">   14297 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="14298"><span class="lineNum">   14298 </span><span class="lineCov">          1 :       case V_SgAssignInitializer:</span></a>
<a name="14299"><span class="lineNum">   14299 </span><span class="lineCov">          1 :          isSgAssignInitializer (target)-&gt;set_operand(operand);</span></a>
<a name="14300"><span class="lineNum">   14300 </span><span class="lineCov">          1 :          break;</span></a>
<a name="14301"><span class="lineNum">   14301 </span><span class="lineNoCov">          0 :       default:</span></a>
<a name="14302"><span class="lineNum">   14302 </span><span class="lineNoCov">          0 :         if (isSgUnaryOp(target)!=NULL)</span></a>
<a name="14303"><span class="lineNum">   14303 </span><span class="lineNoCov">          0 :           isSgUnaryOp(target)-&gt;set_operand_i(operand);</span></a>
<a name="14304"><span class="lineNum">   14304 </span>            :         else</a>
<a name="14305"><span class="lineNum">   14305 </span>            :           {</a>
<a name="14306"><span class="lineNum">   14306 </span><span class="lineNoCov">          0 :             cerr&lt;&lt;&quot;\tSageInterface::setOperand(): unhandled case for target expression of type &quot;</span></a>
<a name="14307"><span class="lineNum">   14307 </span><span class="lineNoCov">          0 :                 &lt;&lt;target-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="14308"><span class="lineNum">   14308 </span><span class="lineNoCov">          0 :             ROSE_ABORT();</span></a>
<a name="14309"><span class="lineNum">   14309 </span>            :           }</a>
<a name="14310"><span class="lineNum">   14310 </span>            :     }// end switch</a>
<a name="14311"><span class="lineNum">   14311 </span><span class="lineCov">          1 :     operand-&gt;set_parent(target);</span></a>
<a name="14312"><span class="lineNum">   14312 </span><span class="lineCov">          1 :     markLhsValues(target);</span></a>
<a name="14313"><span class="lineNum">   14313 </span><span class="lineCov">          1 :   }</span></a>
<a name="14314"><span class="lineNum">   14314 </span>            : </a>
<a name="14315"><span class="lineNum">   14315 </span>            :   // binary and SgVarArgCopyOp, SgVarArgStartOp</a>
<a name="14316"><span class="lineNum">   14316 </span><span class="lineCov">          1 : void SageInterface::setLhsOperand(SgExpression* target, SgExpression* lhs)</span></a>
<a name="14317"><span class="lineNum">   14317 </span>            :   {</a>
<a name="14318"><span class="lineNum">   14318 </span><span class="lineCov">          1 :     ROSE_ASSERT(target);</span></a>
<a name="14319"><span class="lineNum">   14319 </span><span class="lineCov">          1 :     ROSE_ASSERT(lhs);</span></a>
<a name="14320"><span class="lineNum">   14320 </span><span class="lineCov">          1 :     ROSE_ASSERT(target!=lhs);</span></a>
<a name="14321"><span class="lineNum">   14321 </span><span class="lineCov">          1 :     bool hasrhs = false;</span></a>
<a name="14322"><span class="lineNum">   14322 </span>            : </a>
<a name="14323"><span class="lineNum">   14323 </span><span class="lineCov">          1 :     SgVarArgCopyOp* varargcopy = isSgVarArgCopyOp(target);</span></a>
<a name="14324"><span class="lineNum">   14324 </span><span class="lineCov">          1 :     SgVarArgStartOp* varargstart = isSgVarArgStartOp(target);</span></a>
<a name="14325"><span class="lineNum">   14325 </span><span class="lineCov">          1 :     SgBinaryOp* binary = isSgBinaryOp(target);</span></a>
<a name="14326"><span class="lineNum">   14326 </span>            : </a>
<a name="14327"><span class="lineNum">   14327 </span><span class="lineCov">          1 :     if (varargcopy!=NULL)</span></a>
<a name="14328"><span class="lineNum">   14328 </span>            :     {</a>
<a name="14329"><span class="lineNum">   14329 </span><span class="lineNoCov">          0 :       varargcopy-&gt;set_lhs_operand(lhs);</span></a>
<a name="14330"><span class="lineNum">   14330 </span><span class="lineNoCov">          0 :        if( varargcopy-&gt;get_rhs_operand()!=NULL) hasrhs= true;</span></a>
<a name="14331"><span class="lineNum">   14331 </span>            :     }</a>
<a name="14332"><span class="lineNum">   14332 </span><span class="lineCov">          1 :     else if(varargstart!=NULL)</span></a>
<a name="14333"><span class="lineNum">   14333 </span>            :     {</a>
<a name="14334"><span class="lineNum">   14334 </span><span class="lineNoCov">          0 :       varargstart-&gt;set_lhs_operand(lhs);</span></a>
<a name="14335"><span class="lineNum">   14335 </span><span class="lineNoCov">          0 :       if( varargstart-&gt;get_rhs_operand()!=NULL) hasrhs= true;</span></a>
<a name="14336"><span class="lineNum">   14336 </span>            :     }</a>
<a name="14337"><span class="lineNum">   14337 </span><span class="lineCov">          1 :     else if(binary!=NULL)</span></a>
<a name="14338"><span class="lineNum">   14338 </span>            :     {</a>
<a name="14339"><span class="lineNum">   14339 </span><span class="lineCov">          1 :       binary-&gt;set_lhs_operand(lhs);</span></a>
<a name="14340"><span class="lineNum">   14340 </span><span class="lineCov">          1 :       if( binary-&gt;get_rhs_operand()!=NULL) hasrhs= true;</span></a>
<a name="14341"><span class="lineNum">   14341 </span>            :     }</a>
<a name="14342"><span class="lineNum">   14342 </span>            :     else</a>
<a name="14343"><span class="lineNum">   14343 </span>            :     {</a>
<a name="14344"><span class="lineNum">   14344 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;SageInterface::setLhsOperand(): unhandled case for target expression of type &quot;</span></a>
<a name="14345"><span class="lineNum">   14345 </span><span class="lineNoCov">          0 :                 &lt;&lt;target-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="14346"><span class="lineNum">   14346 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="14347"><span class="lineNum">   14347 </span>            :     }</a>
<a name="14348"><span class="lineNum">   14348 </span><span class="lineCov">          1 :     lhs-&gt;set_parent(target);</span></a>
<a name="14349"><span class="lineNum">   14349 </span>            : // only when both lhs and rhs are available, can we set lvalue</a>
<a name="14350"><span class="lineNum">   14350 </span>            : // there is assertion(rhs!=NULL) in markLhsValues()</a>
<a name="14351"><span class="lineNum">   14351 </span><span class="lineCov">          1 :    if (hasrhs)</span></a>
<a name="14352"><span class="lineNum">   14352 </span><span class="lineNoCov">          0 :       markLhsValues(target);</span></a>
<a name="14353"><span class="lineNum">   14353 </span><span class="lineCov">          1 :   }</span></a>
<a name="14354"><span class="lineNum">   14354 </span>            : </a>
<a name="14355"><span class="lineNum">   14355 </span><span class="lineCov">          1 :   void SageInterface::setRhsOperand(SgExpression* target, SgExpression* rhs)</span></a>
<a name="14356"><span class="lineNum">   14356 </span>            :   {</a>
<a name="14357"><span class="lineNum">   14357 </span><span class="lineCov">          1 :     ROSE_ASSERT(target);</span></a>
<a name="14358"><span class="lineNum">   14358 </span><span class="lineCov">          1 :     ROSE_ASSERT(rhs);</span></a>
<a name="14359"><span class="lineNum">   14359 </span><span class="lineCov">          1 :     ROSE_ASSERT(target!=rhs);</span></a>
<a name="14360"><span class="lineNum">   14360 </span><span class="lineCov">          1 :     bool haslhs = false;</span></a>
<a name="14361"><span class="lineNum">   14361 </span>            : </a>
<a name="14362"><span class="lineNum">   14362 </span><span class="lineCov">          1 :     SgVarArgCopyOp* varargcopy = isSgVarArgCopyOp(target);</span></a>
<a name="14363"><span class="lineNum">   14363 </span><span class="lineCov">          1 :     SgVarArgStartOp* varargstart = isSgVarArgStartOp(target);</span></a>
<a name="14364"><span class="lineNum">   14364 </span><span class="lineCov">          1 :     SgBinaryOp* binary = isSgBinaryOp(target);</span></a>
<a name="14365"><span class="lineNum">   14365 </span>            : </a>
<a name="14366"><span class="lineNum">   14366 </span><span class="lineCov">          1 :     if (varargcopy!=NULL)</span></a>
<a name="14367"><span class="lineNum">   14367 </span>            :     {</a>
<a name="14368"><span class="lineNum">   14368 </span><span class="lineNoCov">          0 :        varargcopy-&gt;set_rhs_operand(rhs);</span></a>
<a name="14369"><span class="lineNum">   14369 </span><span class="lineNoCov">          0 :        if( varargcopy-&gt;get_lhs_operand()!=NULL) haslhs= true;</span></a>
<a name="14370"><span class="lineNum">   14370 </span>            :     }</a>
<a name="14371"><span class="lineNum">   14371 </span><span class="lineCov">          1 :     else if(varargstart!=NULL)</span></a>
<a name="14372"><span class="lineNum">   14372 </span>            :     {</a>
<a name="14373"><span class="lineNum">   14373 </span><span class="lineNoCov">          0 :       varargstart-&gt;set_rhs_operand(rhs);</span></a>
<a name="14374"><span class="lineNum">   14374 </span><span class="lineNoCov">          0 :       if( varargstart-&gt;get_lhs_operand()!=NULL) haslhs= true;</span></a>
<a name="14375"><span class="lineNum">   14375 </span>            :     }</a>
<a name="14376"><span class="lineNum">   14376 </span><span class="lineCov">          1 :     else if(binary!=NULL)</span></a>
<a name="14377"><span class="lineNum">   14377 </span>            :     {</a>
<a name="14378"><span class="lineNum">   14378 </span><span class="lineCov">          1 :       binary-&gt;set_rhs_operand(rhs);</span></a>
<a name="14379"><span class="lineNum">   14379 </span><span class="lineCov">          1 :       if( binary-&gt;get_lhs_operand()!=NULL) haslhs= true;</span></a>
<a name="14380"><span class="lineNum">   14380 </span>            :     }</a>
<a name="14381"><span class="lineNum">   14381 </span>            :     else</a>
<a name="14382"><span class="lineNum">   14382 </span>            :     {</a>
<a name="14383"><span class="lineNum">   14383 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;SageInterface::setRhsOperand(): unhandled case for target expression of type &quot;</span></a>
<a name="14384"><span class="lineNum">   14384 </span><span class="lineNoCov">          0 :                 &lt;&lt;target-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="14385"><span class="lineNum">   14385 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="14386"><span class="lineNum">   14386 </span>            :     }</a>
<a name="14387"><span class="lineNum">   14387 </span><span class="lineCov">          1 :     rhs-&gt;set_parent(target);</span></a>
<a name="14388"><span class="lineNum">   14388 </span>            : // only when both lhs and rhs are available, can we set lvalue</a>
<a name="14389"><span class="lineNum">   14389 </span><span class="lineCov">          1 :    if (haslhs)</span></a>
<a name="14390"><span class="lineNum">   14390 </span><span class="lineCov">          1 :       markLhsValues(target);</span></a>
<a name="14391"><span class="lineNum">   14391 </span><span class="lineCov">          1 :   }</span></a>
<a name="14392"><span class="lineNum">   14392 </span>            : </a>
<a name="14393"><span class="lineNum">   14393 </span>            : // DQ (1/25/2010): Added to simplify handling of directories (e.g. for code generation).</a>
<a name="14394"><span class="lineNum">   14394 </span><span class="lineNoCov">          0 : void SageInterface::moveToSubdirectory ( std::string directoryName, SgFile* file )</span></a>
<a name="14395"><span class="lineNum">   14395 </span>            :    {</a>
<a name="14396"><span class="lineNum">   14396 </span>            :   // This support makes use of the new SgDirectory IR node.  It causes the unparser to</a>
<a name="14397"><span class="lineNum">   14397 </span>            :   // generate a subdirectory and unparse the file into the subdirectory.  It works</a>
<a name="14398"><span class="lineNum">   14398 </span>            :   // by internally calling the system function &quot;system()&quot; to call &quot;mkdir directoryName&quot;</a>
<a name="14399"><span class="lineNum">   14399 </span>            :   // and then chdir()&quot; to change the current directory.  These steps are handled by the</a>
<a name="14400"><span class="lineNum">   14400 </span>            :   // unparser.</a>
<a name="14401"><span class="lineNum">   14401 </span>            : </a>
<a name="14402"><span class="lineNum">   14402 </span>            :   // This function just does the transformation to insert a SgDirectory IR node between</a>
<a name="14403"><span class="lineNum">   14403 </span>            :   // the referenced SgFile and it's project (fixing up parents and file lists etc.).</a>
<a name="14404"><span class="lineNum">   14404 </span>            : </a>
<a name="14405"><span class="lineNum">   14405 </span>            :   // Add a directory and unparse the code (to the new directory)</a>
<a name="14406"><span class="lineNum">   14406 </span><span class="lineNoCov">          0 :      SgDirectory* directory = new SgDirectory(directoryName);</span></a>
<a name="14407"><span class="lineNum">   14407 </span>            : </a>
<a name="14408"><span class="lineNum">   14408 </span><span class="lineNoCov">          0 :      SgFileList* parentFileList = isSgFileList(file-&gt;get_parent());</span></a>
<a name="14409"><span class="lineNum">   14409 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(parentFileList != NULL);</span></a>
<a name="14410"><span class="lineNum">   14410 </span><span class="lineNoCov">          0 :      directory-&gt;set_parent(file-&gt;get_parent());</span></a>
<a name="14411"><span class="lineNum">   14411 </span>            : </a>
<a name="14412"><span class="lineNum">   14412 </span><span class="lineNoCov">          0 :      SgProject* project           = NULL;</span></a>
<a name="14413"><span class="lineNum">   14413 </span><span class="lineNoCov">          0 :      SgDirectory* parentDirectory = isSgDirectory(parentFileList-&gt;get_parent());</span></a>
<a name="14414"><span class="lineNum">   14414 </span>            : </a>
<a name="14415"><span class="lineNum">   14415 </span><span class="lineNoCov">          0 :      if (parentDirectory != NULL)</span></a>
<a name="14416"><span class="lineNum">   14416 </span>            :         {</a>
<a name="14417"><span class="lineNum">   14417 </span>            :        // Add a directory to the list in the SgDirectory node.</a>
<a name="14418"><span class="lineNum">   14418 </span><span class="lineNoCov">          0 :           parentDirectory-&gt;get_directoryList()-&gt;get_listOfDirectories().push_back(directory);</span></a>
<a name="14419"><span class="lineNum">   14419 </span>            : </a>
<a name="14420"><span class="lineNum">   14420 </span>            :        // Erase the reference to the file in the project's file list.</a>
<a name="14421"><span class="lineNum">   14421 </span>            :        // parentDirectory-&gt;get_fileList().erase(find(parentDirectory-&gt;get_fileList().begin(),parentDirectory-&gt;get_fileList().end(),file));</a>
<a name="14422"><span class="lineNum">   14422 </span>            :         }</a>
<a name="14423"><span class="lineNum">   14423 </span>            :        else</a>
<a name="14424"><span class="lineNum">   14424 </span>            :         {</a>
<a name="14425"><span class="lineNum">   14425 </span><span class="lineNoCov">          0 :           project = isSgProject(parentFileList-&gt;get_parent());</span></a>
<a name="14426"><span class="lineNum">   14426 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(project != NULL);</span></a>
<a name="14427"><span class="lineNum">   14427 </span>            : </a>
<a name="14428"><span class="lineNum">   14428 </span>            :        // Add a directory to the list in the SgProject node.</a>
<a name="14429"><span class="lineNum">   14429 </span><span class="lineNoCov">          0 :           project-&gt;get_directoryList()-&gt;get_listOfDirectories().push_back(directory);</span></a>
<a name="14430"><span class="lineNum">   14430 </span>            : </a>
<a name="14431"><span class="lineNum">   14431 </span>            :        // Erase the reference to the file in the project's file list.</a>
<a name="14432"><span class="lineNum">   14432 </span>            :        // project-&gt;get_fileList().erase(find(project-&gt;get_fileList().begin(),project-&gt;get_fileList().end(),file));</a>
<a name="14433"><span class="lineNum">   14433 </span>            :         }</a>
<a name="14434"><span class="lineNum">   14434 </span>            : </a>
<a name="14435"><span class="lineNum">   14435 </span>            :   // Put the file into the new directory.</a>
<a name="14436"><span class="lineNum">   14436 </span><span class="lineNoCov">          0 :      directory-&gt;get_fileList()-&gt;get_listOfFiles().push_back(file);</span></a>
<a name="14437"><span class="lineNum">   14437 </span>            : </a>
<a name="14438"><span class="lineNum">   14438 </span>            :   // Erase the reference to the file in the project's file list.</a>
<a name="14439"><span class="lineNum">   14439 </span><span class="lineNoCov">          0 :      parentFileList-&gt;get_listOfFiles().erase(find(parentFileList-&gt;get_listOfFiles().begin(),parentFileList-&gt;get_listOfFiles().end(),file));</span></a>
<a name="14440"><span class="lineNum">   14440 </span>            : </a>
<a name="14441"><span class="lineNum">   14441 </span><span class="lineNoCov">          0 :      file-&gt;set_parent(directory);</span></a>
<a name="14442"><span class="lineNum">   14442 </span><span class="lineNoCov">          0 : }</span></a>
<a name="14443"><span class="lineNum">   14443 </span>            : </a>
<a name="14444"><span class="lineNum">   14444 </span>            : </a>
<a name="14445"><span class="lineNum">   14445 </span>            : //------------------------- AST repair----------------------------</a>
<a name="14446"><span class="lineNum">   14446 </span>            : //----------------------------------------------------------------</a>
<a name="14447"><span class="lineNum">   14447 </span><span class="lineCov">      42457 : void SageInterface::fixStructDeclaration(SgClassDeclaration* structDecl, SgScopeStatement* scope)</span></a>
<a name="14448"><span class="lineNum">   14448 </span>            :    {</a>
<a name="14449"><span class="lineNum">   14449 </span><span class="lineCov">      42457 :      ROSE_ASSERT(structDecl != NULL);</span></a>
<a name="14450"><span class="lineNum">   14450 </span><span class="lineCov">      42457 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="14451"><span class="lineNum">   14451 </span><span class="lineCov">      42457 :      SgClassDeclaration* nondefdecl = isSgClassDeclaration(structDecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="14452"><span class="lineNum">   14452 </span><span class="lineCov">      42457 :      ROSE_ASSERT(nondefdecl != NULL);</span></a>
<a name="14453"><span class="lineNum">   14453 </span>            : </a>
<a name="14454"><span class="lineNum">   14454 </span>            :   // ROSE_ASSERT(structDecl-&gt;get_definingDeclaration() != NULL);</a>
<a name="14455"><span class="lineNum">   14455 </span><span class="lineCov">      42457 :      SgClassDeclaration* defdecl = isSgClassDeclaration(structDecl-&gt;get_definingDeclaration());</span></a>
<a name="14456"><span class="lineNum">   14456 </span>            :   // ROSE_ASSERT(defdecl != NULL);</a>
<a name="14457"><span class="lineNum">   14457 </span>            : </a>
<a name="14458"><span class="lineNum">   14458 </span>            :   // Liao, 9/2/2009</a>
<a name="14459"><span class="lineNum">   14459 </span>            :   // fixup missing scope when bottomup AST building is used</a>
<a name="14460"><span class="lineNum">   14460 </span><span class="lineCov">      42457 :      if (structDecl-&gt;get_scope() == NULL)</span></a>
<a name="14461"><span class="lineNum">   14461 </span><span class="lineCov">      12209 :           structDecl-&gt;set_scope(scope);</span></a>
<a name="14462"><span class="lineNum">   14462 </span><span class="lineCov">      42457 :      if (nondefdecl-&gt;get_scope() == NULL)</span></a>
<a name="14463"><span class="lineNum">   14463 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_scope(scope);</span></a>
<a name="14464"><span class="lineNum">   14464 </span>            : </a>
<a name="14465"><span class="lineNum">   14465 </span>            : #if 0</a>
<a name="14466"><span class="lineNum">   14466 </span>            :      if (structDecl-&gt;get_parent() == NULL)</a>
<a name="14467"><span class="lineNum">   14467 </span>            :           structDecl-&gt;set_parent(scope);</a>
<a name="14468"><span class="lineNum">   14468 </span>            :      if (nondefdecl-&gt;get_parent() == NULL)</a>
<a name="14469"><span class="lineNum">   14469 </span>            :           nondefdecl-&gt;set_parent(scope);</a>
<a name="14470"><span class="lineNum">   14470 </span>            : #else</a>
<a name="14471"><span class="lineNum">   14471 </span>            :   // printf (&quot;*** WARNING: In SageInterface::fixStructDeclaration(): Commented out the setting of the parent (of input class declaration and the nondefining declaration) to be the same as the scope (set only if NULL) \n&quot;);</a>
<a name="14472"><span class="lineNum">   14472 </span>            : </a>
<a name="14473"><span class="lineNum">   14473 </span>            :   // DQ (7/21/2012): Can we assert this here? NO!</a>
<a name="14474"><span class="lineNum">   14474 </span>            :   // ROSE_ASSERT(structDecl-&gt;get_parent() == NULL);</a>
<a name="14475"><span class="lineNum">   14475 </span>            :   // ROSE_ASSERT(nondefdecl-&gt;get_parent() == NULL);</a>
<a name="14476"><span class="lineNum">   14476 </span>            : #endif</a>
<a name="14477"><span class="lineNum">   14477 </span>            : </a>
<a name="14478"><span class="lineNum">   14478 </span><span class="lineCov">      84914 :      SgName name = structDecl-&gt;get_name();</span></a>
<a name="14479"><span class="lineNum">   14479 </span>            : </a>
<a name="14480"><span class="lineNum">   14480 </span>            :   // This is rare case (translation error) when scope-&gt;lookup_class_symbol(name) will find something</a>
<a name="14481"><span class="lineNum">   14481 </span>            :   // but nondefdecl-&gt;get_symbol_from_symbol_table() returns NULL</a>
<a name="14482"><span class="lineNum">   14482 </span>            :   // But symbols are associated with nondefining declarations whenever possible</a>
<a name="14483"><span class="lineNum">   14483 </span>            :   // and AST consistent check will check the nondefining declarations first</a>
<a name="14484"><span class="lineNum">   14484 </span>            :   // Liao, 9/2/2009</a>
<a name="14485"><span class="lineNum">   14485 </span>            :   // SgClassSymbol* mysymbol = scope-&gt;lookup_class_symbol(name);</a>
<a name="14486"><span class="lineNum">   14486 </span><span class="lineCov">      42457 :      SgClassSymbol* mysymbol = isSgClassSymbol(nondefdecl-&gt;get_symbol_from_symbol_table());</span></a>
<a name="14487"><span class="lineNum">   14487 </span>            : </a>
<a name="14488"><span class="lineNum">   14488 </span>            :   // DQ (3/14/2014): This is false for a copy of a class declaration being inserted into the AST.</a>
<a name="14489"><span class="lineNum">   14489 </span>            :   // DQ (9/4/2012): I want to assert this for the new EDG/ROSE connection code (at least).</a>
<a name="14490"><span class="lineNum">   14490 </span>            :   // ROSE_ASSERT(mysymbol != NULL);</a>
<a name="14491"><span class="lineNum">   14491 </span>            : </a>
<a name="14492"><span class="lineNum">   14492 </span><span class="lineCov">      42457 :      if (mysymbol == NULL)</span></a>
<a name="14493"><span class="lineNum">   14493 </span>            :         {</a>
<a name="14494"><span class="lineNum">   14494 </span><span class="lineNoCov">          0 :           printf (&quot;Note: SageInterface::fixStructDeclaration(): structDecl = %p nondefdecl = %p (mysymbol == NULL) \n&quot;,structDecl,nondefdecl);</span></a>
<a name="14495"><span class="lineNum">   14495 </span>            : </a>
<a name="14496"><span class="lineNum">   14496 </span>            :        // DQ (12/3/2011): This will be an error for C++ if the scope of the statment is different from the scope where it is located structurally...</a>
<a name="14497"><span class="lineNum">   14497 </span>            :        // DQ (12/4/2011): Only generate symbols and set the scope if this is the correct scope.</a>
<a name="14498"><span class="lineNum">   14498 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(structDecl-&gt;get_scope() != NULL);</span></a>
<a name="14499"><span class="lineNum">   14499 </span>            : </a>
<a name="14500"><span class="lineNum">   14500 </span><span class="lineNoCov">          0 :           if (scope == structDecl-&gt;get_scope())</span></a>
<a name="14501"><span class="lineNum">   14501 </span>            :              {</a>
<a name="14502"><span class="lineNum">   14502 </span><span class="lineNoCov">          0 :                mysymbol = new SgClassSymbol(nondefdecl);</span></a>
<a name="14503"><span class="lineNum">   14503 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(mysymbol);</span></a>
<a name="14504"><span class="lineNum">   14504 </span>            : </a>
<a name="14505"><span class="lineNum">   14505 </span>            :             // I need to check the rest of these functions.</a>
<a name="14506"><span class="lineNum">   14506 </span><span class="lineNoCov">          0 :                printf (&quot;############## DANGER:DANGER:DANGER ################\n&quot;);</span></a>
<a name="14507"><span class="lineNum">   14507 </span>            : </a>
<a name="14508"><span class="lineNum">   14508 </span><span class="lineNoCov">          0 :                printf (&quot;In SageInterface::fixStructDeclaration(): Adding class symbol to scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="14509"><span class="lineNum">   14509 </span><span class="lineNoCov">          0 :                scope-&gt;insert_symbol(name, mysymbol);</span></a>
<a name="14510"><span class="lineNum">   14510 </span>            : </a>
<a name="14511"><span class="lineNum">   14511 </span>            :             // ROSE_ASSERT(defdecl != NULL);</a>
<a name="14512"><span class="lineNum">   14512 </span><span class="lineNoCov">          0 :                if (defdecl)</span></a>
<a name="14513"><span class="lineNum">   14513 </span><span class="lineNoCov">          0 :                     defdecl-&gt;set_scope(scope);</span></a>
<a name="14514"><span class="lineNum">   14514 </span><span class="lineNoCov">          0 :                nondefdecl-&gt;set_scope(scope);</span></a>
<a name="14515"><span class="lineNum">   14515 </span>            : </a>
<a name="14516"><span class="lineNum">   14516 </span><span class="lineNoCov">          0 :                printf (&quot;*** WARNING: In SageInterface::fixStructDeclaration(): (mysymbol == NULL) Commented out the setting of the parent to be the same as the scope \n&quot;);</span></a>
<a name="14517"><span class="lineNum">   14517 </span>            : #if 0</a>
<a name="14518"><span class="lineNum">   14518 </span>            :                if (defdecl)</a>
<a name="14519"><span class="lineNum">   14519 </span>            :                     defdecl-&gt;set_parent(scope);</a>
<a name="14520"><span class="lineNum">   14520 </span>            :                nondefdecl-&gt;set_parent(scope);</a>
<a name="14521"><span class="lineNum">   14521 </span>            : #endif</a>
<a name="14522"><span class="lineNum">   14522 </span>            :              }</a>
<a name="14523"><span class="lineNum">   14523 </span>            :             else</a>
<a name="14524"><span class="lineNum">   14524 </span>            :              {</a>
<a name="14525"><span class="lineNum">   14525 </span><span class="lineNoCov">          0 :                printf (&quot;In SageInterface::fixStructDeclaration(): (mysymbol == NULL) Skipped building an associated symbol! \n&quot;);</span></a>
<a name="14526"><span class="lineNum">   14526 </span>            :              }</a>
<a name="14527"><span class="lineNum">   14527 </span>            :         }</a>
<a name="14528"><span class="lineNum">   14528 </span>            : </a>
<a name="14529"><span class="lineNum">   14529 </span>            :   // DQ (9/4/2012): I want to assert this for the new EDG/ROSE connection code (at least).</a>
<a name="14530"><span class="lineNum">   14530 </span><span class="lineCov">      42457 :      ROSE_ASSERT(nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14531"><span class="lineNum">   14531 </span>            : </a>
<a name="14532"><span class="lineNum">   14532 </span>            :   // DQ (9/4/2012): This is a sign that the pointer to the type was deleted.</a>
<a name="14533"><span class="lineNum">   14533 </span><span class="lineCov">      42457 :      ROSE_ASSERT(nondefdecl-&gt;get_type()-&gt;variantT() != V_SgNode);</span></a>
<a name="14534"><span class="lineNum">   14534 </span>            : </a>
<a name="14535"><span class="lineNum">   14535 </span>            :   // DQ (9/4/2012): This should be a SgClassType IR node.</a>
<a name="14536"><span class="lineNum">   14536 </span><span class="lineCov">      42457 :      ROSE_ASSERT(isSgClassType(nondefdecl-&gt;get_type()) != NULL);</span></a>
<a name="14537"><span class="lineNum">   14537 </span>            : </a>
<a name="14538"><span class="lineNum">   14538 </span>            :   // fixup SgClassType, which is associated with the first non-defining declaration only</a>
<a name="14539"><span class="lineNum">   14539 </span>            :   // and the other declarations share it.</a>
<a name="14540"><span class="lineNum">   14540 </span><span class="lineCov">      42457 :      if (nondefdecl-&gt;get_type() == NULL)</span></a>
<a name="14541"><span class="lineNum">   14541 </span>            :         {</a>
<a name="14542"><span class="lineNum">   14542 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_type(SgClassType::createType(nondefdecl));</span></a>
<a name="14543"><span class="lineNum">   14543 </span>            :         }</a>
<a name="14544"><span class="lineNum">   14544 </span><span class="lineCov">      42457 :      ROSE_ASSERT (nondefdecl-&gt;get_type() != NULL);</span></a>
<a name="14545"><span class="lineNum">   14545 </span>            : </a>
<a name="14546"><span class="lineNum">   14546 </span>            :   // DQ (9/4/2012): If defDecl != NULL, I want to assert this for the new EDG/ROSE connection code (at least).</a>
<a name="14547"><span class="lineNum">   14547 </span><span class="lineCov">      42457 :      if (defdecl != NULL)</span></a>
<a name="14548"><span class="lineNum">   14548 </span>            :         {</a>
<a name="14549"><span class="lineNum">   14549 </span>            :        // DQ (9/4/2012): This is a sign that the pointer to the type was deleted.</a>
<a name="14550"><span class="lineNum">   14550 </span><span class="lineCov">      37592 :           ROSE_ASSERT(defdecl-&gt;get_type()-&gt;variantT() != V_SgNode);</span></a>
<a name="14551"><span class="lineNum">   14551 </span>            : </a>
<a name="14552"><span class="lineNum">   14552 </span>            :        // DQ (9/4/2012): This should be a SgClassType IR node.</a>
<a name="14553"><span class="lineNum">   14553 </span><span class="lineCov">      37592 :           ROSE_ASSERT(isSgClassType(defdecl-&gt;get_type()) != NULL);</span></a>
<a name="14554"><span class="lineNum">   14554 </span>            :         }</a>
<a name="14555"><span class="lineNum">   14555 </span>            : </a>
<a name="14556"><span class="lineNum">   14556 </span>            :   // ROSE_ASSERT(defdecl != NULL);</a>
<a name="14557"><span class="lineNum">   14557 </span><span class="lineCov">      42457 :      if (defdecl != NULL)</span></a>
<a name="14558"><span class="lineNum">   14558 </span>            :         {</a>
<a name="14559"><span class="lineNum">   14559 </span>            :        // DQ (9/4/2012): If defDecl != NULL, I want to assert this for the new EDG/ROSE connection code (at least).</a>
<a name="14560"><span class="lineNum">   14560 </span><span class="lineCov">      37592 :           ROSE_ASSERT(defdecl-&gt;get_type() != NULL);</span></a>
<a name="14561"><span class="lineNum">   14561 </span><span class="lineCov">      37592 :           if (defdecl-&gt;get_type() != nondefdecl-&gt;get_type())</span></a>
<a name="14562"><span class="lineNum">   14562 </span>            :              {</a>
<a name="14563"><span class="lineNum">   14563 </span><span class="lineNoCov">          0 :                printf (&quot;ERROR: defdecl-&gt;get_type() != nondefdecl-&gt;get_type(): what are these: \n&quot;);</span></a>
<a name="14564"><span class="lineNum">   14564 </span><span class="lineNoCov">          0 :                printf (&quot;   defdecl-&gt;get_type()    = %p = %s \n&quot;,defdecl   -&gt;get_type(),defdecl   -&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="14565"><span class="lineNum">   14565 </span><span class="lineNoCov">          0 :                SgNamedType* namedType_definingDecl = isSgNamedType(defdecl-&gt;get_type());</span></a>
<a name="14566"><span class="lineNum">   14566 </span><span class="lineNoCov">          0 :                if (namedType_definingDecl != NULL)</span></a>
<a name="14567"><span class="lineNum">   14567 </span>            :                   {</a>
<a name="14568"><span class="lineNum">   14568 </span><span class="lineNoCov">          0 :                     printf (&quot;namedType_definingDecl-&gt;get_declaration() = %p = %s \n&quot;,namedType_definingDecl-&gt;get_declaration(),namedType_definingDecl-&gt;get_declaration()-&gt;class_name().c_str());</span></a>
<a name="14569"><span class="lineNum">   14569 </span>            :                   }</a>
<a name="14570"><span class="lineNum">   14570 </span><span class="lineNoCov">          0 :                printf (&quot;   nondefdecl-&gt;get_type() = %p = %s \n&quot;,nondefdecl-&gt;get_type(),nondefdecl-&gt;get_type()-&gt;class_name().c_str());</span></a>
<a name="14571"><span class="lineNum">   14571 </span><span class="lineNoCov">          0 :                SgNamedType* namedType_nondefiningDecl = isSgNamedType(nondefdecl-&gt;get_type());</span></a>
<a name="14572"><span class="lineNum">   14572 </span><span class="lineNoCov">          0 :                if (namedType_nondefiningDecl != NULL)</span></a>
<a name="14573"><span class="lineNum">   14573 </span>            :                   {</a>
<a name="14574"><span class="lineNum">   14574 </span><span class="lineNoCov">          0 :                     printf (&quot;namedType_nondefiningDecl-&gt;get_declaration() = %p = %s \n&quot;,namedType_nondefiningDecl-&gt;get_declaration(),namedType_nondefiningDecl-&gt;get_declaration()-&gt;class_name().c_str());</span></a>
<a name="14575"><span class="lineNum">   14575 </span>            :                   }</a>
<a name="14576"><span class="lineNum">   14576 </span>            :              }</a>
<a name="14577"><span class="lineNum">   14577 </span>            :           //ROSE_ASSERT(defdecl-&gt;get_type() == nondefdecl-&gt;get_type());</a>
<a name="14578"><span class="lineNum">   14578 </span>            :         }</a>
<a name="14579"><span class="lineNum">   14579 </span><span class="lineCov">      42457 :    }</span></a>
<a name="14580"><span class="lineNum">   14580 </span>            : </a>
<a name="14581"><span class="lineNum">   14581 </span>            : </a>
<a name="14582"><span class="lineNum">   14582 </span><span class="lineCov">       8243 : void SageInterface::fixClassDeclaration(SgClassDeclaration* classDecl, SgScopeStatement* scope)</span></a>
<a name="14583"><span class="lineNum">   14583 </span>            :   {</a>
<a name="14584"><span class="lineNum">   14584 </span><span class="lineCov">       8243 :     fixStructDeclaration(classDecl,scope);</span></a>
<a name="14585"><span class="lineNum">   14585 </span><span class="lineCov">       8243 :   }</span></a>
<a name="14586"><span class="lineNum">   14586 </span>            : </a>
<a name="14587"><span class="lineNum">   14587 </span>            : </a>
<a name="14588"><span class="lineNum">   14588 </span><span class="lineCov">       2254 : void SageInterface::fixNamespaceDeclaration(SgNamespaceDeclarationStatement* structDecl, SgScopeStatement* scope)</span></a>
<a name="14589"><span class="lineNum">   14589 </span>            :    {</a>
<a name="14590"><span class="lineNum">   14590 </span><span class="lineCov">       2254 :      ROSE_ASSERT(structDecl);</span></a>
<a name="14591"><span class="lineNum">   14591 </span><span class="lineCov">       2254 :      ROSE_ASSERT(scope);</span></a>
<a name="14592"><span class="lineNum">   14592 </span><span class="lineCov">       2254 :      SgNamespaceDeclarationStatement* nondefdecl = isSgNamespaceDeclarationStatement(structDecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="14593"><span class="lineNum">   14593 </span><span class="lineCov">       2254 :      ROSE_ASSERT(nondefdecl);</span></a>
<a name="14594"><span class="lineNum">   14594 </span>            :   // Liao, 9/2/2009</a>
<a name="14595"><span class="lineNum">   14595 </span>            :   // fixup missing scope when bottomup AST building is used</a>
<a name="14596"><span class="lineNum">   14596 </span><span class="lineCov">       2254 :      if (structDecl-&gt;get_parent() == NULL)</span></a>
<a name="14597"><span class="lineNum">   14597 </span><span class="lineCov">        978 :           structDecl-&gt;set_parent(scope);</span></a>
<a name="14598"><span class="lineNum">   14598 </span><span class="lineCov">       2254 :      if (nondefdecl-&gt;get_parent() == NULL)</span></a>
<a name="14599"><span class="lineNum">   14599 </span><span class="lineNoCov">          0 :           nondefdecl-&gt;set_parent(scope);</span></a>
<a name="14600"><span class="lineNum">   14600 </span>            : </a>
<a name="14601"><span class="lineNum">   14601 </span>            :   // tps : (09/03/2009) Namespace should not have a scope</a>
<a name="14602"><span class="lineNum">   14602 </span>            :     /*</a>
<a name="14603"><span class="lineNum">   14603 </span>            :     if (structDecl-&gt;get_scope() == NULL)</a>
<a name="14604"><span class="lineNum">   14604 </span>            :       structDecl-&gt;set_scope(scope);</a>
<a name="14605"><span class="lineNum">   14605 </span>            :     if (nondefdecl-&gt;get_scope() == NULL)</a>
<a name="14606"><span class="lineNum">   14606 </span>            :       nondefdecl-&gt;set_scope(scope);</a>
<a name="14607"><span class="lineNum">   14607 </span>            :     */</a>
<a name="14608"><span class="lineNum">   14608 </span>            : </a>
<a name="14609"><span class="lineNum">   14609 </span><span class="lineCov">       4508 :      SgName name= structDecl-&gt;get_name();</span></a>
<a name="14610"><span class="lineNum">   14610 </span>            :   // SgNamespaceSymbol* mysymbol = scope-&gt;lookup_namespace_symbol(name);</a>
<a name="14611"><span class="lineNum">   14611 </span><span class="lineCov">       2254 :      SgNamespaceSymbol* mysymbol = isSgNamespaceSymbol(nondefdecl-&gt;get_symbol_from_symbol_table());</span></a>
<a name="14612"><span class="lineNum">   14612 </span><span class="lineCov">       2254 :      if (mysymbol==NULL)</span></a>
<a name="14613"><span class="lineNum">   14613 </span>            :         {</a>
<a name="14614"><span class="lineNum">   14614 </span>            :        // DQ (12/4/2011): This code is modified to try to only insert the symbol into the correct scope.  It used to</a>
<a name="14615"><span class="lineNum">   14615 </span>            :        // just insert the symbol into whatever scope structureally held the declaration (not good enough for C++).</a>
<a name="14616"><span class="lineNum">   14616 </span><span class="lineNoCov">          0 :           if (scope == structDecl-&gt;get_scope())</span></a>
<a name="14617"><span class="lineNum">   14617 </span>            :              {</a>
<a name="14618"><span class="lineNum">   14618 </span><span class="lineNoCov">          0 :                mysymbol = new SgNamespaceSymbol(name,nondefdecl);</span></a>
<a name="14619"><span class="lineNum">   14619 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(mysymbol);</span></a>
<a name="14620"><span class="lineNum">   14620 </span>            : </a>
<a name="14621"><span class="lineNum">   14621 </span><span class="lineNoCov">          0 :                printf (&quot;In SageInterface::fixNamespaceDeclaration(): inserting namespace symbol into scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="14622"><span class="lineNum">   14622 </span><span class="lineNoCov">          0 :                scope-&gt;insert_symbol(name, mysymbol);</span></a>
<a name="14623"><span class="lineNum">   14623 </span>            : </a>
<a name="14624"><span class="lineNum">   14624 </span><span class="lineNoCov">          0 :                SgNamespaceDeclarationStatement* defdecl = isSgNamespaceDeclarationStatement(structDecl-&gt;get_definingDeclaration());</span></a>
<a name="14625"><span class="lineNum">   14625 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(defdecl);</span></a>
<a name="14626"><span class="lineNum">   14626 </span><span class="lineNoCov">          0 :                defdecl-&gt;set_scope(scope);</span></a>
<a name="14627"><span class="lineNum">   14627 </span><span class="lineNoCov">          0 :                nondefdecl-&gt;set_scope(scope);</span></a>
<a name="14628"><span class="lineNum">   14628 </span>            : </a>
<a name="14629"><span class="lineNum">   14629 </span><span class="lineNoCov">          0 :                defdecl-&gt;set_parent(scope);</span></a>
<a name="14630"><span class="lineNum">   14630 </span><span class="lineNoCov">          0 :                nondefdecl-&gt;set_parent(scope);</span></a>
<a name="14631"><span class="lineNum">   14631 </span>            :              }</a>
<a name="14632"><span class="lineNum">   14632 </span>            :         }</a>
<a name="14633"><span class="lineNum">   14633 </span><span class="lineCov">       2254 :    }</span></a>
<a name="14634"><span class="lineNum">   14634 </span>            : </a>
<a name="14635"><span class="lineNum">   14635 </span><span class="lineCov">      66155 : void SageInterface::fixVariableDeclaration(SgVariableDeclaration* varDecl, SgScopeStatement* scope)</span></a>
<a name="14636"><span class="lineNum">   14636 </span>            :    {</a>
<a name="14637"><span class="lineNum">   14637 </span><span class="lineCov">      66155 :      ROSE_ASSERT(varDecl != NULL);</span></a>
<a name="14638"><span class="lineNum">   14638 </span><span class="lineCov">      66155 :      ROSE_ASSERT(scope   != NULL);</span></a>
<a name="14639"><span class="lineNum">   14639 </span>            : </a>
<a name="14640"><span class="lineNum">   14640 </span><span class="lineCov">      66155 :      SgInitializedNamePtrList namelist = varDecl-&gt;get_variables();</span></a>
<a name="14641"><span class="lineNum">   14641 </span>            : </a>
<a name="14642"><span class="lineNum">   14642 </span>            :   // printf (&quot;In SageInterface::fixVariableDeclaration(): Is this a recursive call! \n&quot;);</a>
<a name="14643"><span class="lineNum">   14643 </span>            : </a>
<a name="14644"><span class="lineNum">   14644 </span>            : #if 0</a>
<a name="14645"><span class="lineNum">   14645 </span>            :      printf (&quot;In SageInterface::fixVariableDeclaration(): varDecl = %p scope = %p = %s \n&quot;,varDecl,scope,scope-&gt;class_name().c_str());</a>
<a name="14646"><span class="lineNum">   14646 </span>            : #endif</a>
<a name="14647"><span class="lineNum">   14647 </span>            : </a>
<a name="14648"><span class="lineNum">   14648 </span><span class="lineCov">      66155 :      ROSE_ASSERT(namelist.size() &gt; 0);</span></a>
<a name="14649"><span class="lineNum">   14649 </span>            : </a>
<a name="14650"><span class="lineNum">   14650 </span><span class="lineCov">      66155 :      SgInitializedNamePtrList::iterator i;</span></a>
<a name="14651"><span class="lineNum">   14651 </span><span class="lineCov">     132310 :      for (i = namelist.begin(); i != namelist.end(); i++)</span></a>
<a name="14652"><span class="lineNum">   14652 </span>            :         {</a>
<a name="14653"><span class="lineNum">   14653 </span><span class="lineCov">      66155 :           SgInitializedName *initName = *i;</span></a>
<a name="14654"><span class="lineNum">   14654 </span><span class="lineCov">      66155 :           ROSE_ASSERT(initName != NULL);</span></a>
<a name="14655"><span class="lineNum">   14655 </span>            : </a>
<a name="14656"><span class="lineNum">   14656 </span><span class="lineCov">     132310 :           SgName name = initName-&gt;get_name();</span></a>
<a name="14657"><span class="lineNum">   14657 </span>            : #if 0</a>
<a name="14658"><span class="lineNum">   14658 </span>            :           printf (&quot;  -- initName = %p : %s\n&quot;, initName, name.str());</a>
<a name="14659"><span class="lineNum">   14659 </span>            :           printf (&quot;  -- initName-&gt;get_scope() = %p (%s)\n&quot;, initName-&gt;get_scope(), initName-&gt;get_scope() ? initName-&gt;get_scope()-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="14660"><span class="lineNum">   14660 </span>            : #endif</a>
<a name="14661"><span class="lineNum">   14661 </span>            : </a>
<a name="14662"><span class="lineNum">   14662 </span>            :        // DQ (11/19/2011): When used with C++, the variable may already have an associated scope</a>
<a name="14663"><span class="lineNum">   14663 </span>            :        // and be using name qualification, so might not be associated with the current scope.</a>
<a name="14664"><span class="lineNum">   14664 </span><span class="lineCov">      66155 :           SgScopeStatement* requiredScope = scope;</span></a>
<a name="14665"><span class="lineNum">   14665 </span><span class="lineCov">      66155 :           SgScopeStatement* preAssociatedScope = initName-&gt;get_scope();</span></a>
<a name="14666"><span class="lineNum">   14666 </span>            :        // printf (&quot;In SageInterface::fixVariableDeclaration() preAssociatedScope = %p \n&quot;,preAssociatedScope);</a>
<a name="14667"><span class="lineNum">   14667 </span>            : </a>
<a name="14668"><span class="lineNum">   14668 </span><span class="lineCov">      66155 :           if (preAssociatedScope != NULL)</span></a>
<a name="14669"><span class="lineNum">   14669 </span>            :              {</a>
<a name="14670"><span class="lineNum">   14670 </span>            : #if 0</a>
<a name="14671"><span class="lineNum">   14671 </span>            :                printf (&quot;In SageInterface::fixVariableDeclaration(): Note that this variable already has an associated scope! preAssociatedScope = %p = %s (but will be reset below) \n&quot;,preAssociatedScope,preAssociatedScope-&gt;class_name().c_str());</a>
<a name="14672"><span class="lineNum">   14672 </span>            : #endif</a>
<a name="14673"><span class="lineNum">   14673 </span>            :             // ROSE_ASSERT(preAssociatedScope == scope);</a>
<a name="14674"><span class="lineNum">   14674 </span><span class="lineCov">      33133 :                requiredScope = preAssociatedScope;</span></a>
<a name="14675"><span class="lineNum">   14675 </span>            :              }</a>
<a name="14676"><span class="lineNum">   14676 </span>            : </a>
<a name="14677"><span class="lineNum">   14677 </span>            :        // DQ (11/19/2011): C++ can have a different scope than that of the current scope.</a>
<a name="14678"><span class="lineNum">   14678 </span>            :        // initName-&gt;set_scope(scope);</a>
<a name="14679"><span class="lineNum">   14679 </span><span class="lineCov">      66155 :           initName-&gt;set_scope(requiredScope);</span></a>
<a name="14680"><span class="lineNum">   14680 </span>            : </a>
<a name="14681"><span class="lineNum">   14681 </span>            :        // optional?</a>
<a name="14682"><span class="lineNum">   14682 </span>            :        // DQ (7/9/2012): Don't set this since it will be set later (see test2012_107.C) (LATER) Putting this back (mark declarations to not be output as compiler generated -- and not to be output).</a>
<a name="14683"><span class="lineNum">   14683 </span>            :        // DQ (7/12/2012): This is not correct for C++, so don't set it here (unless we use the current scope instead of scope).</a>
<a name="14684"><span class="lineNum">   14684 </span>            :        // Yes, let's set it to the current top of the scope stack.  This might be a problem if the scope stack is not being used...</a>
<a name="14685"><span class="lineNum">   14685 </span>            :        // varDecl-&gt;set_parent(scope);</a>
<a name="14686"><span class="lineNum">   14686 </span><span class="lineCov">      66155 :         if (topScopeStack() != NULL)</span></a>
<a name="14687"><span class="lineNum">   14687 </span>            :         {</a>
<a name="14688"><span class="lineNum">   14688 </span><span class="lineCov">      64535 :           varDecl-&gt;set_parent(topScopeStack());</span></a>
<a name="14689"><span class="lineNum">   14689 </span><span class="lineCov">      64535 :           ROSE_ASSERT(varDecl-&gt;get_parent() != NULL);</span></a>
<a name="14690"><span class="lineNum">   14690 </span>            :         }</a>
<a name="14691"><span class="lineNum">   14691 </span>            : </a>
<a name="14692"><span class="lineNum">   14692 </span>            :        // DQ (11/19/2011): C++ can have a different scope than that of the current scope.</a>
<a name="14693"><span class="lineNum">   14693 </span>            :        // symbol table</a>
<a name="14694"><span class="lineNum">   14694 </span>            :        // ROSE_ASSERT(scope != NULL);</a>
<a name="14695"><span class="lineNum">   14695 </span>            :        // SgVariableSymbol* varSymbol = scope-&gt;lookup_variable_symbol(name);</a>
<a name="14696"><span class="lineNum">   14696 </span><span class="lineCov">      66155 :           ROSE_ASSERT(requiredScope != NULL);</span></a>
<a name="14697"><span class="lineNum">   14697 </span><span class="lineCov">      66155 :           SgVariableSymbol* varSymbol = requiredScope-&gt;lookup_variable_symbol(name);</span></a>
<a name="14698"><span class="lineNum">   14698 </span>            : #if 0</a>
<a name="14699"><span class="lineNum">   14699 </span>            :           printf (&quot;  -- varSymbol = %p (%s)\n&quot;, varSymbol, varSymbol ? varSymbol-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="14700"><span class="lineNum">   14700 </span>            : #endif</a>
<a name="14701"><span class="lineNum">   14701 </span>            : </a>
<a name="14702"><span class="lineNum">   14702 </span><span class="lineCov">      66155 :           if (varSymbol == NULL)</span></a>
<a name="14703"><span class="lineNum">   14703 </span>            :              {</a>
<a name="14704"><span class="lineNum">   14704 </span>            :             // DQ (12/4/2011): This code is modified to try to only insert the symbol into the correct scope.  It used to</a>
<a name="14705"><span class="lineNum">   14705 </span>            :             // just insert the symbol into whatever scope structureally held the declaration (not good enough for C++).</a>
<a name="14706"><span class="lineNum">   14706 </span><span class="lineCov">      32871 :                if (scope == initName-&gt;get_scope())</span></a>
<a name="14707"><span class="lineNum">   14707 </span>            :                   {</a>
<a name="14708"><span class="lineNum">   14708 </span><span class="lineCov">      32871 :                     if (isSgTemplateVariableDeclaration(varDecl)) {</span></a>
<a name="14709"><span class="lineNum">   14709 </span><span class="lineCov">        759 :                       varSymbol = new SgTemplateVariableSymbol(initName);</span></a>
<a name="14710"><span class="lineNum">   14710 </span>            :                     } else {</a>
<a name="14711"><span class="lineNum">   14711 </span><span class="lineCov">      32112 :                       varSymbol = new SgVariableSymbol(initName);</span></a>
<a name="14712"><span class="lineNum">   14712 </span>            :                     }</a>
<a name="14713"><span class="lineNum">   14713 </span><span class="lineCov">      32871 :                     ROSE_ASSERT(varSymbol);</span></a>
<a name="14714"><span class="lineNum">   14714 </span>            : </a>
<a name="14715"><span class="lineNum">   14715 </span>            :                  // DQ (5/16/2013): We now want to use the SgScopeStatement::insert_symbol() functions since we put</a>
<a name="14716"><span class="lineNum">   14716 </span>            :                  // the complexity of handling namespaces into the implementation of that function.</a>
<a name="14717"><span class="lineNum">   14717 </span><span class="lineCov">      32871 :                     scope-&gt;insert_symbol(name, varSymbol);</span></a>
<a name="14718"><span class="lineNum">   14718 </span>            :                   }</a>
<a name="14719"><span class="lineNum">   14719 </span>            :              }</a>
<a name="14720"><span class="lineNum">   14720 </span>            :             else</a>
<a name="14721"><span class="lineNum">   14721 </span>            :              {</a>
<a name="14722"><span class="lineNum">   14722 </span>            :             // TODO consider prepend() and insert(), prev_decl_time is position dependent.</a>
<a name="14723"><span class="lineNum">   14723 </span>            :             // cout&lt;&lt;&quot;sageInterface.C:5130 debug: found a previous var declaration!!....&quot;&lt;&lt;endl;</a>
<a name="14724"><span class="lineNum">   14724 </span><span class="lineCov">      33284 :                SgInitializedName* prev_decl = varSymbol-&gt;get_declaration();</span></a>
<a name="14725"><span class="lineNum">   14725 </span><span class="lineCov">      33284 :                ROSE_ASSERT(prev_decl);</span></a>
<a name="14726"><span class="lineNum">   14726 </span>            : </a>
<a name="14727"><span class="lineNum">   14727 </span>            :             // DQ (11/19/2011): Don't let prev_decl_item point be a self reference.</a>
<a name="14728"><span class="lineNum">   14728 </span>            :             // initName-&gt;set_prev_decl_item(prev_decl);</a>
<a name="14729"><span class="lineNum">   14729 </span><span class="lineCov">      33284 :                if (initName != prev_decl)</span></a>
<a name="14730"><span class="lineNum">   14730 </span><span class="lineCov">        428 :                     initName-&gt;set_prev_decl_item(prev_decl);</span></a>
<a name="14731"><span class="lineNum">   14731 </span>            : </a>
<a name="14732"><span class="lineNum">   14732 </span><span class="lineCov">      33284 :                ROSE_ASSERT(initName-&gt;get_prev_decl_item() != initName);</span></a>
<a name="14733"><span class="lineNum">   14733 </span>            : </a>
<a name="14734"><span class="lineNum">   14734 </span>            :              } //end if</a>
<a name="14735"><span class="lineNum">   14735 </span>            :         } //end for</a>
<a name="14736"><span class="lineNum">   14736 </span>            : </a>
<a name="14737"><span class="lineNum">   14737 </span>            :   // Liao 12/8/2010</a>
<a name="14738"><span class="lineNum">   14738 </span>            :   // For Fortran, a common statement may refer to a variable which is declared later.</a>
<a name="14739"><span class="lineNum">   14739 </span>            :   // In this case, a fake symbol is used for that variable reference.</a>
<a name="14740"><span class="lineNum">   14740 </span>            :   // But we have to replace the fake one with the real one once the variable declaration is inserted into AST</a>
<a name="14741"><span class="lineNum">   14741 </span><span class="lineCov">      66155 :      if (SageInterface::is_Fortran_language() == true)</span></a>
<a name="14742"><span class="lineNum">   14742 </span>            :         {</a>
<a name="14743"><span class="lineNum">   14743 </span><span class="lineCov">          2 :           fixVariableReferences(scope);</span></a>
<a name="14744"><span class="lineNum">   14744 </span>            :         }</a>
<a name="14745"><span class="lineNum">   14745 </span><span class="lineCov">      66155 :    }</span></a>
<a name="14746"><span class="lineNum">   14746 </span>            : </a>
<a name="14747"><span class="lineNum">   14747 </span><span class="lineCov">          7 : int SageInterface::fixVariableReferences(SgNode* root, bool cleanUnusedSymbols/*=true*/)</span></a>
<a name="14748"><span class="lineNum">   14748 </span>            : {</a>
<a name="14749"><span class="lineNum">   14749 </span><span class="lineCov">          7 :   ROSE_ASSERT(root);</span></a>
<a name="14750"><span class="lineNum">   14750 </span><span class="lineCov">          7 :   int counter=0;</span></a>
<a name="14751"><span class="lineNum">   14751 </span><span class="lineCov">          7 :   Rose_STL_Container&lt;SgNode*&gt; varList;</span></a>
<a name="14752"><span class="lineNum">   14752 </span>            : </a>
<a name="14753"><span class="lineNum">   14753 </span><span class="lineCov">          7 :   SgVarRefExp* varRef=NULL;</span></a>
<a name="14754"><span class="lineNum">   14754 </span><span class="lineCov">         14 :   Rose_STL_Container&lt;SgNode*&gt; reflist = NodeQuery::querySubTree(root, V_SgVarRefExp);</span></a>
<a name="14755"><span class="lineNum">   14755 </span><span class="lineCov">         27 :   for (Rose_STL_Container&lt;SgNode*&gt;::iterator i=reflist.begin();i!=reflist.end();i++)</span></a>
<a name="14756"><span class="lineNum">   14756 </span>            :   {</a>
<a name="14757"><span class="lineNum">   14757 </span><span class="lineCov">         20 :     varRef= isSgVarRefExp(*i);</span></a>
<a name="14758"><span class="lineNum">   14758 </span><span class="lineCov">         20 :     ROSE_ASSERT(varRef-&gt;get_symbol());</span></a>
<a name="14759"><span class="lineNum">   14759 </span><span class="lineCov">         20 :     SgInitializedName* initname= varRef-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="14760"><span class="lineNum">   14760 </span>            : </a>
<a name="14761"><span class="lineNum">   14761 </span><span class="lineCov">         20 :     ROSE_ASSERT (initname != NULL);</span></a>
<a name="14762"><span class="lineNum">   14762 </span><span class="lineCov">         20 :     if (initname-&gt;get_type()==SgTypeUnknown::createType())</span></a>
<a name="14763"><span class="lineNum">   14763 </span>            :       //    if ((initname-&gt;get_scope()==NULL) &amp;&amp; (initname-&gt;get_type()==SgTypeUnknown::createType()))</a>
<a name="14764"><span class="lineNum">   14764 </span>            :     {</a>
<a name="14765"><span class="lineNum">   14765 </span><span class="lineCov">         18 :       SgName varName=initname-&gt;get_name();</span></a>
<a name="14766"><span class="lineNum">   14766 </span><span class="lineCov">          9 :       SgSymbol* realSymbol = NULL;</span></a>
<a name="14767"><span class="lineNum">   14767 </span>            : </a>
<a name="14768"><span class="lineNum">   14768 </span>            : #if 1</a>
<a name="14769"><span class="lineNum">   14769 </span>            :       // CH (5/7/2010): Before searching SgVarRefExp objects, we should first deal with class/structure</a>
<a name="14770"><span class="lineNum">   14770 </span>            :       // members. Or else, it is possible that we assign the wrong symbol to those members if there is another</a>
<a name="14771"><span class="lineNum">   14771 </span>            :       // variable with the same name in parent scopes. Those members include normal member referenced using . or -&gt;</a>
<a name="14772"><span class="lineNum">   14772 </span>            :       // operators, and static members using :: operators.</a>
<a name="14773"><span class="lineNum">   14773 </span>            :       //</a>
<a name="14774"><span class="lineNum">   14774 </span><span class="lineCov">          9 :       if (SgArrowExp* arrowExp = isSgArrowExp(varRef-&gt;get_parent()))</span></a>
<a name="14775"><span class="lineNum">   14775 </span>            :       {</a>
<a name="14776"><span class="lineNum">   14776 </span><span class="lineCov">          2 :         if (varRef == arrowExp-&gt;get_rhs_operand_i())</span></a>
<a name="14777"><span class="lineNum">   14777 </span>            :         {</a>
<a name="14778"><span class="lineNum">   14778 </span>            :             // make sure the lhs operand has been fixed</a>
<a name="14779"><span class="lineNum">   14779 </span><span class="lineCov">          1 :             counter += fixVariableReferences(arrowExp-&gt;get_lhs_operand_i());</span></a>
<a name="14780"><span class="lineNum">   14780 </span><span class="lineCov">          1 :             SgType* lhs_type = arrowExp-&gt;get_lhs_operand_i()-&gt;get_type() ;</span></a>
<a name="14781"><span class="lineNum">   14781 </span><span class="lineCov">          1 :             lhs_type = lhs_type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</span></a>
<a name="14782"><span class="lineNum">   14782 </span><span class="lineCov">          1 :             SgPointerType* ptrType = isSgPointerType(lhs_type);</span></a>
<a name="14783"><span class="lineNum">   14783 </span><span class="lineCov">          1 :             ROSE_ASSERT(ptrType);</span></a>
<a name="14784"><span class="lineNum">   14784 </span><span class="lineCov">          1 :             SgClassType* clsType = isSgClassType(ptrType-&gt;get_base_type()-&gt; stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE));</span></a>
<a name="14785"><span class="lineNum">   14785 </span><span class="lineCov">          1 :             ROSE_ASSERT(clsType);</span></a>
<a name="14786"><span class="lineNum">   14786 </span><span class="lineCov">          1 :             SgClassDeclaration* decl = isSgClassDeclaration(clsType-&gt;get_declaration());</span></a>
<a name="14787"><span class="lineNum">   14787 </span><span class="lineCov">          1 :             decl = isSgClassDeclaration(decl-&gt;get_definingDeclaration());</span></a>
<a name="14788"><span class="lineNum">   14788 </span><span class="lineCov">          1 :             ROSE_ASSERT(decl);</span></a>
<a name="14789"><span class="lineNum">   14789 </span>            : </a>
<a name="14790"><span class="lineNum">   14790 </span>            :          // DQ (8/16/2013): We want to lookup variable symbols not just any symbol.</a>
<a name="14791"><span class="lineNum">   14791 </span>            :          // realSymbol = lookupSymbolInParentScopes(varName, decl-&gt;get_definition());</a>
<a name="14792"><span class="lineNum">   14792 </span><span class="lineCov">          1 :             realSymbol = lookupVariableSymbolInParentScopes(varName, decl-&gt;get_definition());</span></a>
<a name="14793"><span class="lineNum">   14793 </span>            :         }</a>
<a name="14794"><span class="lineNum">   14794 </span>            :         else</a>
<a name="14795"><span class="lineNum">   14795 </span>            :         {</a>
<a name="14796"><span class="lineNum">   14796 </span>            :          // DQ (8/16/2013): We want to lookup variable symbols not just any symbol.</a>
<a name="14797"><span class="lineNum">   14797 </span>            :          // realSymbol = lookupSymbolInParentScopes(varName,getScope(varRef));</a>
<a name="14798"><span class="lineNum">   14798 </span><span class="lineCov">          1 :             realSymbol = lookupVariableSymbolInParentScopes(varName, getScope(varRef));</span></a>
<a name="14799"><span class="lineNum">   14799 </span>            :         }</a>
<a name="14800"><span class="lineNum">   14800 </span>            :       }</a>
<a name="14801"><span class="lineNum">   14801 </span><span class="lineCov">          7 :       else if (SgDotExp* dotExp = isSgDotExp(varRef-&gt;get_parent()))</span></a>
<a name="14802"><span class="lineNum">   14802 </span>            :       {</a>
<a name="14803"><span class="lineNum">   14803 </span><span class="lineNoCov">          0 :         if (varRef == dotExp-&gt;get_rhs_operand_i())</span></a>
<a name="14804"><span class="lineNum">   14804 </span>            :         {</a>
<a name="14805"><span class="lineNum">   14805 </span>            :             // make sure the lhs operand has been fixed</a>
<a name="14806"><span class="lineNum">   14806 </span><span class="lineNoCov">          0 :             counter += fixVariableReferences(dotExp-&gt;get_lhs_operand_i());</span></a>
<a name="14807"><span class="lineNum">   14807 </span>            : </a>
<a name="14808"><span class="lineNum">   14808 </span><span class="lineNoCov">          0 :             SgType* lhs_type = dotExp-&gt;get_lhs_operand_i()-&gt;get_type() ;</span></a>
<a name="14809"><span class="lineNum">   14809 </span><span class="lineNoCov">          0 :             lhs_type = lhs_type-&gt;stripType(SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_RVALUE_REFERENCE_TYPE | SgType::STRIP_TYPEDEF_TYPE);</span></a>
<a name="14810"><span class="lineNum">   14810 </span><span class="lineNoCov">          0 :             SgClassType* clsType = isSgClassType(lhs_type);</span></a>
<a name="14811"><span class="lineNum">   14811 </span><span class="lineNoCov">          0 :             ROSE_ASSERT(clsType);</span></a>
<a name="14812"><span class="lineNum">   14812 </span><span class="lineNoCov">          0 :             SgClassDeclaration* decl = isSgClassDeclaration(clsType-&gt;get_declaration());</span></a>
<a name="14813"><span class="lineNum">   14813 </span><span class="lineNoCov">          0 :             decl = isSgClassDeclaration(decl-&gt;get_definingDeclaration());</span></a>
<a name="14814"><span class="lineNum">   14814 </span><span class="lineNoCov">          0 :             ROSE_ASSERT(decl);</span></a>
<a name="14815"><span class="lineNum">   14815 </span>            : </a>
<a name="14816"><span class="lineNum">   14816 </span>            :          // DQ (8/16/2013): We want to lookup variable symbols not just any symbol.</a>
<a name="14817"><span class="lineNum">   14817 </span>            :          // realSymbol = lookupSymbolInParentScopes(varName, decl-&gt;get_definition());</a>
<a name="14818"><span class="lineNum">   14818 </span><span class="lineNoCov">          0 :             realSymbol = lookupVariableSymbolInParentScopes(varName, decl-&gt;get_definition());</span></a>
<a name="14819"><span class="lineNum">   14819 </span>            :         }</a>
<a name="14820"><span class="lineNum">   14820 </span>            :         else</a>
<a name="14821"><span class="lineNum">   14821 </span>            :          // DQ (8/16/2013): We want to lookup variable symbols not just any symbol.</a>
<a name="14822"><span class="lineNum">   14822 </span>            :          // realSymbol = lookupSymbolInParentScopes(varName,getScope(varRef));</a>
<a name="14823"><span class="lineNum">   14823 </span><span class="lineNoCov">          0 :             realSymbol = lookupVariableSymbolInParentScopes(varName, getScope(varRef));</span></a>
<a name="14824"><span class="lineNum">   14824 </span>            :       }</a>
<a name="14825"><span class="lineNum">   14825 </span>            :       else</a>
<a name="14826"><span class="lineNum">   14826 </span>            : #endif</a>
<a name="14827"><span class="lineNum">   14827 </span>            :       {</a>
<a name="14828"><span class="lineNum">   14828 </span>            :          // DQ (8/16/2013): We want to lookup variable symbols not just any symbol.</a>
<a name="14829"><span class="lineNum">   14829 </span>            :          // realSymbol = lookupSymbolInParentScopes(varName,getScope(varRef));</a>
<a name="14830"><span class="lineNum">   14830 </span><span class="lineCov">          7 :             realSymbol = lookupVariableSymbolInParentScopes(varName, getScope(varRef));</span></a>
<a name="14831"><span class="lineNum">   14831 </span>            :       }</a>
<a name="14832"><span class="lineNum">   14832 </span>            : </a>
<a name="14833"><span class="lineNum">   14833 </span>            :       // should find a real symbol at this final fixing stage!</a>
<a name="14834"><span class="lineNum">   14834 </span>            :       // This function can be called any time, not just final fixing stage</a>
<a name="14835"><span class="lineNum">   14835 </span><span class="lineCov">          9 :       if (realSymbol==NULL)</span></a>
<a name="14836"><span class="lineNum">   14836 </span>            :       {</a>
<a name="14837"><span class="lineNum">   14837 </span>            :         //cerr&lt;&lt;&quot;Error: cannot find a symbol for &quot;&lt;&lt;varName.getString()&lt;&lt;endl;</a>
<a name="14838"><span class="lineNum">   14838 </span>            :         //ROSE_ASSERT(realSymbol);</a>
<a name="14839"><span class="lineNum">   14839 </span>            :       }</a>
<a name="14840"><span class="lineNum">   14840 </span>            :       else {</a>
<a name="14841"><span class="lineNum">   14841 </span>            :         // release placeholder initname and symbol</a>
<a name="14842"><span class="lineNum">   14842 </span><span class="lineCov">          8 :         ROSE_ASSERT(realSymbol!=(varRef-&gt;get_symbol()));</span></a>
<a name="14843"><span class="lineNum">   14843 </span>            : #if 0</a>
<a name="14844"><span class="lineNum">   14844 </span>            :         // CH (5/12/2010):</a>
<a name="14845"><span class="lineNum">   14845 </span>            :         // To delete a symbol node, first check if there is any node in memory</a>
<a name="14846"><span class="lineNum">   14846 </span>            :         // pool which points to this symbol node. Only if no such node exists,</a>
<a name="14847"><span class="lineNum">   14847 </span>            :         // this symbol together with its initialized name can be deleted.</a>
<a name="14848"><span class="lineNum">   14848 </span>            :         //</a>
<a name="14849"><span class="lineNum">   14849 </span>            :         bool toDelete = true;</a>
<a name="14850"><span class="lineNum">   14850 </span>            : </a>
<a name="14851"><span class="lineNum">   14851 </span>            :         SgSymbol* symbolToDelete = varRef-&gt;get_symbol();</a>
<a name="14852"><span class="lineNum">   14852 </span>            :         varRef-&gt;set_symbol(isSgVariableSymbol(realSymbol));</a>
<a name="14853"><span class="lineNum">   14853 </span>            :         counter ++;</a>
<a name="14854"><span class="lineNum">   14854 </span>            : </a>
<a name="14855"><span class="lineNum">   14855 </span>            :         if (varList.empty())</a>
<a name="14856"><span class="lineNum">   14856 </span>            :         {</a>
<a name="14857"><span class="lineNum">   14857 </span>            :             VariantVector vv(V_SgVarRefExp);</a>
<a name="14858"><span class="lineNum">   14858 </span>            :             varList = NodeQuery::queryMemoryPool(vv);</a>
<a name="14859"><span class="lineNum">   14859 </span>            :         }</a>
<a name="14860"><span class="lineNum">   14860 </span>            : </a>
<a name="14861"><span class="lineNum">   14861 </span>            :         for (Rose_STL_Container&lt;SgNode*&gt;::iterator i = varList.begin();</a>
<a name="14862"><span class="lineNum">   14862 </span>            :                 i != varList.end(); ++i)</a>
<a name="14863"><span class="lineNum">   14863 </span>            :         {</a>
<a name="14864"><span class="lineNum">   14864 </span>            :             if (SgVarRefExp* var = isSgVarRefExp(*i))</a>
<a name="14865"><span class="lineNum">   14865 </span>            :             {</a>
<a name="14866"><span class="lineNum">   14866 </span>            :                 if (var-&gt;get_symbol() == symbolToDelete)</a>
<a name="14867"><span class="lineNum">   14867 </span>            :                 {</a>
<a name="14868"><span class="lineNum">   14868 </span>            :                     toDelete = false;</a>
<a name="14869"><span class="lineNum">   14869 </span>            :                     break;</a>
<a name="14870"><span class="lineNum">   14870 </span>            :                 }</a>
<a name="14871"><span class="lineNum">   14871 </span>            :             }</a>
<a name="14872"><span class="lineNum">   14872 </span>            :         }</a>
<a name="14873"><span class="lineNum">   14873 </span>            :         if (toDelete)</a>
<a name="14874"><span class="lineNum">   14874 </span>            :         {</a>
<a name="14875"><span class="lineNum">   14875 </span>            :             delete initname; // TODO deleteTree(), release File_Info nodes etc.</a>
<a name="14876"><span class="lineNum">   14876 </span>            :             delete symbolToDelete;</a>
<a name="14877"><span class="lineNum">   14877 </span>            :         }</a>
<a name="14878"><span class="lineNum">   14878 </span>            : </a>
<a name="14879"><span class="lineNum">   14879 </span>            : #else</a>
<a name="14880"><span class="lineNum">   14880 </span>            : </a>
<a name="14881"><span class="lineNum">   14881 </span>            :         // CH (2010/7/26): We cannot delete those initname and symbol here, since there may be other variable references</a>
<a name="14882"><span class="lineNum">   14882 </span>            :         // which point to them. We will delay this clear just before AstTests.</a>
<a name="14883"><span class="lineNum">   14883 </span>            : #if 0</a>
<a name="14884"><span class="lineNum">   14884 </span>            :         delete initname; // TODO deleteTree(), release File_Info nodes etc.</a>
<a name="14885"><span class="lineNum">   14885 </span>            :         delete (varRef-&gt;get_symbol());</a>
<a name="14886"><span class="lineNum">   14886 </span>            : #endif</a>
<a name="14887"><span class="lineNum">   14887 </span>            : </a>
<a name="14888"><span class="lineNum">   14888 </span>            :         //std::cout &lt;&lt; &quot;Fixed variable reference: &quot; &lt;&lt; realSymbol-&gt;get_name().str() &lt;&lt; std::endl;</a>
<a name="14889"><span class="lineNum">   14889 </span><span class="lineCov">          8 :         varRef-&gt;set_symbol(isSgVariableSymbol(realSymbol));</span></a>
<a name="14890"><span class="lineNum">   14890 </span><span class="lineCov">          8 :         counter ++;</span></a>
<a name="14891"><span class="lineNum">   14891 </span>            : #endif</a>
<a name="14892"><span class="lineNum">   14892 </span>            :       }</a>
<a name="14893"><span class="lineNum">   14893 </span>            :     }</a>
<a name="14894"><span class="lineNum">   14894 </span>            :   } // end for</a>
<a name="14895"><span class="lineNum">   14895 </span>            :   // Liao 2/1/2013: delete unused initname and symbol, considering possible use by the current subtree from root node</a>
<a name="14896"><span class="lineNum">   14896 </span><span class="lineCov">          7 :   if (cleanUnusedSymbols)</span></a>
<a name="14897"><span class="lineNum">   14897 </span><span class="lineCov">          7 :     clearUnusedVariableSymbols(root);</span></a>
<a name="14898"><span class="lineNum">   14898 </span><span class="lineCov">         14 :   return counter;</span></a>
<a name="14899"><span class="lineNum">   14899 </span>            : }</a>
<a name="14900"><span class="lineNum">   14900 </span>            : </a>
<a name="14901"><span class="lineNum">   14901 </span><span class="lineCov">          7 : void SageInterface::clearUnusedVariableSymbols(SgNode* root /*= NULL */)</span></a>
<a name="14902"><span class="lineNum">   14902 </span>            : {</a>
<a name="14903"><span class="lineNum">   14903 </span><span class="lineCov">          7 :     Rose_STL_Container&lt;SgNode*&gt; symbolList;</span></a>
<a name="14904"><span class="lineNum">   14904 </span><span class="lineCov">         14 :     VariantVector sym_vv(V_SgVariableSymbol);</span></a>
<a name="14905"><span class="lineNum">   14905 </span><span class="lineCov">          7 :     symbolList = NodeQuery::queryMemoryPool(sym_vv);</span></a>
<a name="14906"><span class="lineNum">   14906 </span>            : </a>
<a name="14907"><span class="lineNum">   14907 </span><span class="lineCov">         14 :     Rose_STL_Container&lt;SgNode*&gt; varList;</span></a>
<a name="14908"><span class="lineNum">   14908 </span><span class="lineCov">         14 :     VariantVector var_vv(V_SgVarRefExp);</span></a>
<a name="14909"><span class="lineNum">   14909 </span>            :     //varList = NodeQuery::queryMemoryPool(var_vv);</a>
<a name="14910"><span class="lineNum">   14910 </span><span class="lineCov">          7 :     if (root != NULL)</span></a>
<a name="14911"><span class="lineNum">   14911 </span>            :     {</a>
<a name="14912"><span class="lineNum">   14912 </span><span class="lineCov">          7 :       varList = NodeQuery::querySubTree(root, V_SgVarRefExp);</span></a>
<a name="14913"><span class="lineNum">   14913 </span>            :     }</a>
<a name="14914"><span class="lineNum">   14914 </span>            : </a>
<a name="14915"><span class="lineNum">   14915 </span><span class="lineCov">         32 :     for (Rose_STL_Container&lt;SgNode*&gt;::iterator i = symbolList.begin();</span></a>
<a name="14916"><span class="lineNum">   14916 </span><span class="lineCov">         32 :             i != symbolList.end(); ++i)</span></a>
<a name="14917"><span class="lineNum">   14917 </span>            :     {</a>
<a name="14918"><span class="lineNum">   14918 </span><span class="lineCov">         25 :         SgVariableSymbol* symbolToDelete = isSgVariableSymbol(*i);</span></a>
<a name="14919"><span class="lineNum">   14919 </span><span class="lineCov">         25 :         ROSE_ASSERT(symbolToDelete);</span></a>
<a name="14920"><span class="lineNum">   14920 </span><span class="lineCov">         25 :         if (symbolToDelete-&gt;get_declaration()-&gt;get_type() != SgTypeUnknown::createType())</span></a>
<a name="14921"><span class="lineNum">   14921 </span><span class="lineCov">         16 :             continue;</span></a>
<a name="14922"><span class="lineNum">   14922 </span>            :         // symbol with a declaration of SgTypeUnknown will be deleted</a>
<a name="14923"><span class="lineNum">   14923 </span><span class="lineCov">          9 :         bool toDelete = true;</span></a>
<a name="14924"><span class="lineNum">   14924 </span>            : </a>
<a name="14925"><span class="lineNum">   14925 </span><span class="lineCov">          9 :         if (root != NULL) // if root is specified. We further check if the symbol is referenced by any nodes of the tree rooted at &quot;root&quot;</span></a>
<a name="14926"><span class="lineNum">   14926 </span>            :         {</a>
<a name="14927"><span class="lineNum">   14927 </span><span class="lineCov">         21 :           for (Rose_STL_Container&lt;SgNode*&gt;::iterator j = varList.begin();</span></a>
<a name="14928"><span class="lineNum">   14928 </span><span class="lineCov">         30 :               j != varList.end(); ++j)</span></a>
<a name="14929"><span class="lineNum">   14929 </span>            :           {</a>
<a name="14930"><span class="lineNum">   14930 </span><span class="lineCov">         22 :             SgVarRefExp* var = isSgVarRefExp(*j);</span></a>
<a name="14931"><span class="lineNum">   14931 </span><span class="lineCov">         22 :             ROSE_ASSERT(var);</span></a>
<a name="14932"><span class="lineNum">   14932 </span>            : </a>
<a name="14933"><span class="lineNum">   14933 </span><span class="lineCov">         22 :             if (var-&gt;get_symbol() == symbolToDelete)</span></a>
<a name="14934"><span class="lineNum">   14934 </span>            :             {</a>
<a name="14935"><span class="lineNum">   14935 </span>            :               toDelete = false;</a>
<a name="14936"><span class="lineNum">   14936 </span>            :               break;</a>
<a name="14937"><span class="lineNum">   14937 </span>            :             }</a>
<a name="14938"><span class="lineNum">   14938 </span>            :           }</a>
<a name="14939"><span class="lineNum">   14939 </span>            :         }</a>
<a name="14940"><span class="lineNum">   14940 </span>            : </a>
<a name="14941"><span class="lineNum">   14941 </span><span class="lineCov">          9 :         if (toDelete)</span></a>
<a name="14942"><span class="lineNum">   14942 </span>            :         {</a>
<a name="14943"><span class="lineNum">   14943 </span>            : #if 0</a>
<a name="14944"><span class="lineNum">   14944 </span>            :             std::cout &lt;&lt; &quot;Symbol &quot; &lt;&lt; symbolToDelete-&gt;get_name().str() &lt;&lt; ' ' &lt;&lt; symbolToDelete &lt;&lt;</a>
<a name="14945"><span class="lineNum">   14945 </span>            :                ' ' &lt;&lt; symbolToDelete-&gt;get_declaration() &lt;&lt;  &quot; is deleted.&quot; &lt;&lt; std::endl;</a>
<a name="14946"><span class="lineNum">   14946 </span>            : #endif</a>
<a name="14947"><span class="lineNum">   14947 </span><span class="lineCov">          8 :             delete symbolToDelete-&gt;get_declaration();</span></a>
<a name="14948"><span class="lineNum">   14948 </span><span class="lineCov">          8 :             delete symbolToDelete;</span></a>
<a name="14949"><span class="lineNum">   14949 </span>            :         }</a>
<a name="14950"><span class="lineNum">   14950 </span>            :     }</a>
<a name="14951"><span class="lineNum">   14951 </span><span class="lineCov">          7 : }</span></a>
<a name="14952"><span class="lineNum">   14952 </span>            : </a>
<a name="14953"><span class="lineNum">   14953 </span>            : </a>
<a name="14954"><span class="lineNum">   14954 </span>            : //! fixup symbol table for SgLableStatement. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL.</a>
<a name="14955"><span class="lineNum">   14955 </span>            : /*</a>
<a name="14956"><span class="lineNum">   14956 </span>            :  * label statement has special scope: the closest function definition , not SgBasicBlock or others!</a>
<a name="14957"><span class="lineNum">   14957 </span>            :  */</a>
<a name="14958"><span class="lineNum">   14958 </span><span class="lineCov">         12 : void SageInterface::fixLabelStatement(SgLabelStatement* stmt, SgScopeStatement* scope)</span></a>
<a name="14959"><span class="lineNum">   14959 </span>            :    {</a>
<a name="14960"><span class="lineNum">   14960 </span><span class="lineCov">         12 :      SgLabelStatement* label_stmt = isSgLabelStatement(stmt);</span></a>
<a name="14961"><span class="lineNum">   14961 </span><span class="lineCov">         12 :      ROSE_ASSERT(label_stmt);</span></a>
<a name="14962"><span class="lineNum">   14962 </span><span class="lineCov">         24 :      SgName name = label_stmt-&gt;get_label();</span></a>
<a name="14963"><span class="lineNum">   14963 </span>            : </a>
<a name="14964"><span class="lineNum">   14964 </span><span class="lineCov">         12 :      SgScopeStatement* label_scope = getEnclosingFunctionDefinition(scope,true);</span></a>
<a name="14965"><span class="lineNum">   14965 </span>            : </a>
<a name="14966"><span class="lineNum">   14966 </span>            :   // DQ (11/16/2014): Added error checking for when the input scope is the SgFunctionDefinition instead of a nested scope.</a>
<a name="14967"><span class="lineNum">   14967 </span><span class="lineCov">         12 :      if (isSgFunctionDefinition(scope) != NULL)</span></a>
<a name="14968"><span class="lineNum">   14968 </span>            :         {</a>
<a name="14969"><span class="lineNum">   14969 </span><span class="lineCov">          2 :           ROSE_ASSERT(label_scope == scope);</span></a>
<a name="14970"><span class="lineNum">   14970 </span>            :         }</a>
<a name="14971"><span class="lineNum">   14971 </span>            : </a>
<a name="14972"><span class="lineNum">   14972 </span><span class="lineCov">         12 :      if (label_scope) //Should we assert this instead? No for bottom up AST building</span></a>
<a name="14973"><span class="lineNum">   14973 </span>            :         {</a>
<a name="14974"><span class="lineNum">   14974 </span><span class="lineCov">         12 :           label_stmt-&gt;set_scope(label_scope);</span></a>
<a name="14975"><span class="lineNum">   14975 </span><span class="lineCov">         12 :           SgLabelSymbol* lsymbol = label_scope-&gt;lookup_label_symbol(name);</span></a>
<a name="14976"><span class="lineNum">   14976 </span>            : </a>
<a name="14977"><span class="lineNum">   14977 </span>            :        // DQ (11/15/2014): I think this is a bug, the precicate should be (lsymbol == NULL), instead of (lsymbol != NULL)</a>
<a name="14978"><span class="lineNum">   14978 </span>            :        // if (lsymbol != NULL)</a>
<a name="14979"><span class="lineNum">   14979 </span><span class="lineCov">         12 :           if (lsymbol == NULL)</span></a>
<a name="14980"><span class="lineNum">   14980 </span>            :              {</a>
<a name="14981"><span class="lineNum">   14981 </span>            : #if 0</a>
<a name="14982"><span class="lineNum">   14982 </span>            :                printf (&quot;WARNING: In SageInterface::fixLabelStatement(): We already found a SgLabelSymbol, so why are we adding another one (this bug is now fixed) \n&quot;);</a>
<a name="14983"><span class="lineNum">   14983 </span>            : #endif</a>
<a name="14984"><span class="lineNum">   14984 </span>            :             // DQ (12/4/2011): This is the correct handling for SgLabelStatement (always in the function scope).</a>
<a name="14985"><span class="lineNum">   14985 </span><span class="lineCov">          7 :                lsymbol= new SgLabelSymbol(label_stmt);</span></a>
<a name="14986"><span class="lineNum">   14986 </span><span class="lineCov">          7 :                ROSE_ASSERT(lsymbol);</span></a>
<a name="14987"><span class="lineNum">   14987 </span><span class="lineCov">          7 :                label_scope-&gt;insert_symbol(lsymbol-&gt;get_name(), lsymbol);</span></a>
<a name="14988"><span class="lineNum">   14988 </span>            :              }</a>
<a name="14989"><span class="lineNum">   14989 </span>            :             else</a>
<a name="14990"><span class="lineNum">   14990 </span>            :              {</a>
<a name="14991"><span class="lineNum">   14991 </span>            : #if 0</a>
<a name="14992"><span class="lineNum">   14992 </span>            :                printf (&quot;In SageInterface::fixLabelStatement(): We already found a SgLabelSymbol (bug causing additional symbol to be built is now fixed) \n&quot;);</a>
<a name="14993"><span class="lineNum">   14993 </span>            : #endif</a>
<a name="14994"><span class="lineNum">   14994 </span>            :              }</a>
<a name="14995"><span class="lineNum">   14995 </span>            :         }</a>
<a name="14996"><span class="lineNum">   14996 </span><span class="lineCov">         12 :    }</span></a>
<a name="14997"><span class="lineNum">   14997 </span>            : </a>
<a name="14998"><span class="lineNum">   14998 </span>            : </a>
<a name="14999"><span class="lineNum">   14999 </span>            : //! Set a numerical label for a Fortran statement. The statement should have a enclosing function definition already. SgLabelSymbol and SgLabelR</a>
<a name="15000"><span class="lineNum">   15000 </span>            : //efExp are created transparently as needed.</a>
<a name="15001"><span class="lineNum">   15001 </span><span class="lineCov">          2 : void SageInterface::setFortranNumericLabel(SgStatement* stmt, int label_value,</span></a>
<a name="15002"><span class="lineNum">   15002 </span>            :                                            SgLabelSymbol::label_type_enum label_type, SgScopeStatement* label_scope)</a>
<a name="15003"><span class="lineNum">   15003 </span>            :    {</a>
<a name="15004"><span class="lineNum">   15004 </span><span class="lineCov">          2 :      ROSE_ASSERT (stmt != NULL);</span></a>
<a name="15005"><span class="lineNum">   15005 </span><span class="lineCov">          2 :      ROSE_ASSERT (label_value &gt;0 &amp;&amp; label_value &lt;=99999); //five digits for Fortran label</span></a>
<a name="15006"><span class="lineNum">   15006 </span>            : </a>
<a name="15007"><span class="lineNum">   15007 </span>            :   // Added optional label_type and label_scope [Rasmussen 2019.01.20]</a>
<a name="15008"><span class="lineNum">   15008 </span><span class="lineCov">          2 :      if (label_scope == NULL)</span></a>
<a name="15009"><span class="lineNum">   15009 </span>            :         {</a>
<a name="15010"><span class="lineNum">   15010 </span><span class="lineCov">          2 :            label_scope = getEnclosingFunctionDefinition(stmt);</span></a>
<a name="15011"><span class="lineNum">   15011 </span>            :         }</a>
<a name="15012"><span class="lineNum">   15012 </span><span class="lineCov">          2 :      ROSE_ASSERT (label_scope != NULL);</span></a>
<a name="15013"><span class="lineNum">   15013 </span><span class="lineCov">          4 :      SgName label_name(StringUtility::numberToString(label_value));</span></a>
<a name="15014"><span class="lineNum">   15014 </span><span class="lineCov">          2 :      SgLabelSymbol * symbol = label_scope-&gt;lookup_label_symbol (label_name);</span></a>
<a name="15015"><span class="lineNum">   15015 </span><span class="lineCov">          2 :      if (symbol == NULL)</span></a>
<a name="15016"><span class="lineNum">   15016 </span>            :         {</a>
<a name="15017"><span class="lineNum">   15017 </span>            :        // DQ (12/4/2011): This is the correct handling for SgLabelStatement (always in the function scope, same as C and C++).</a>
<a name="15018"><span class="lineNum">   15018 </span>            :        // DQ (2/2/2011): We want to call the old constructor (we now have another constructor that takes a SgInitializedName pointer).</a>
<a name="15019"><span class="lineNum">   15019 </span>            :        // symbol = new SgLabelSymbol(NULL);</a>
<a name="15020"><span class="lineNum">   15020 </span><span class="lineCov">          2 :           symbol = new SgLabelSymbol((SgLabelStatement*) NULL);</span></a>
<a name="15021"><span class="lineNum">   15021 </span><span class="lineCov">          2 :           ROSE_ASSERT(symbol != NULL);</span></a>
<a name="15022"><span class="lineNum">   15022 </span><span class="lineCov">          2 :           symbol-&gt;set_fortran_statement(stmt);</span></a>
<a name="15023"><span class="lineNum">   15023 </span><span class="lineCov">          2 :           symbol-&gt;set_numeric_label_value(label_value);</span></a>
<a name="15024"><span class="lineNum">   15024 </span><span class="lineCov">          2 :           label_scope-&gt;insert_symbol(label_name,symbol);</span></a>
<a name="15025"><span class="lineNum">   15025 </span>            :         }</a>
<a name="15026"><span class="lineNum">   15026 </span>            :        else</a>
<a name="15027"><span class="lineNum">   15027 </span>            :         {</a>
<a name="15028"><span class="lineNum">   15028 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;Error. SageInterface::setFortranNumericLabel() tries to set a duplicated label value!&quot;&lt;&lt;endl;</span></a>
<a name="15029"><span class="lineNum">   15029 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (false);</span></a>
<a name="15030"><span class="lineNum">   15030 </span>            :         }</a>
<a name="15031"><span class="lineNum">   15031 </span>            : </a>
<a name="15032"><span class="lineNum">   15032 </span>            :   // SgLabelRefExp</a>
<a name="15033"><span class="lineNum">   15033 </span><span class="lineCov">          2 :      SgLabelRefExp* ref_exp = buildLabelRefExp(symbol);</span></a>
<a name="15034"><span class="lineNum">   15034 </span><span class="lineCov">          2 :      ref_exp-&gt;set_parent(stmt);</span></a>
<a name="15035"><span class="lineNum">   15035 </span>            : </a>
<a name="15036"><span class="lineNum">   15036 </span><span class="lineCov">          2 :      switch(label_type)</span></a>
<a name="15037"><span class="lineNum">   15037 </span>            :        {</a>
<a name="15038"><span class="lineNum">   15038 </span><span class="lineCov">          2 :          case SgLabelSymbol::e_start_label_type:</span></a>
<a name="15039"><span class="lineNum">   15039 </span><span class="lineCov">          2 :             {</span></a>
<a name="15040"><span class="lineNum">   15040 </span><span class="lineCov">          2 :               stmt-&gt;set_numeric_label(ref_exp);</span></a>
<a name="15041"><span class="lineNum">   15041 </span>            :               break;</a>
<a name="15042"><span class="lineNum">   15042 </span>            :             }</a>
<a name="15043"><span class="lineNum">   15043 </span><span class="lineNoCov">          0 :          case SgLabelSymbol::e_end_label_type:</span></a>
<a name="15044"><span class="lineNum">   15044 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="15045"><span class="lineNum">   15045 </span><span class="lineNoCov">          0 :               stmt-&gt;set_end_numeric_label(ref_exp);</span></a>
<a name="15046"><span class="lineNum">   15046 </span>            :               break;</a>
<a name="15047"><span class="lineNum">   15047 </span>            :             }</a>
<a name="15048"><span class="lineNum">   15048 </span><span class="lineNoCov">          0 :          default:</span></a>
<a name="15049"><span class="lineNum">   15049 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="15050"><span class="lineNum">   15050 </span><span class="lineNoCov">          0 :                std::cerr &lt;&lt; &quot;SageInterface::setFortranNumericLabel: unimplemented for label_type &quot; &lt;&lt; label_type &lt;&lt; &quot;\n&quot;;</span></a>
<a name="15051"><span class="lineNum">   15051 </span><span class="lineNoCov">          0 :                ROSE_ABORT();  // NOT IMPLEMENTED</span></a>
<a name="15052"><span class="lineNum">   15052 </span>            :             }</a>
<a name="15053"><span class="lineNum">   15053 </span>            :        }</a>
<a name="15054"><span class="lineNum">   15054 </span>            : </a>
<a name="15055"><span class="lineNum">   15055 </span><span class="lineCov">          2 :    }</span></a>
<a name="15056"><span class="lineNum">   15056 </span>            : </a>
<a name="15057"><span class="lineNum">   15057 </span>            : </a>
<a name="15058"><span class="lineNum">   15058 </span>            : //! Suggest next usable (non-conflicting) numeric label value for a Fortran function definition scope</a>
<a name="15059"><span class="lineNum">   15059 </span><span class="lineCov">          2 : int  SageInterface::suggestNextNumericLabel(SgFunctionDefinition* func_def)</span></a>
<a name="15060"><span class="lineNum">   15060 </span>            : {</a>
<a name="15061"><span class="lineNum">   15061 </span><span class="lineCov">          2 :   int result =10;</span></a>
<a name="15062"><span class="lineNum">   15062 </span><span class="lineCov">          2 :   ROSE_ASSERT (func_def != NULL);</span></a>
<a name="15063"><span class="lineNum">   15063 </span><span class="lineCov">          2 :   ROSE_ASSERT (SageInterface::is_Fortran_language()== true);</span></a>
<a name="15064"><span class="lineNum">   15064 </span><span class="lineCov">          2 :   std::set&lt;SgNode*&gt; symbols = func_def-&gt;get_symbol_table()-&gt;get_symbols();</span></a>
<a name="15065"><span class="lineNum">   15065 </span>            : </a>
<a name="15066"><span class="lineNum">   15066 </span>            :   // find the max label value, +10 to be the suggested next label value</a>
<a name="15067"><span class="lineNum">   15067 </span><span class="lineCov">          2 :   std::set&lt;SgNode*&gt;::iterator iter ;</span></a>
<a name="15068"><span class="lineNum">   15068 </span><span class="lineCov">          5 :   for (iter=symbols.begin(); iter !=symbols.end(); iter++)</span></a>
<a name="15069"><span class="lineNum">   15069 </span>            :   {</a>
<a name="15070"><span class="lineNum">   15070 </span><span class="lineCov">          3 :     SgLabelSymbol * l_symbol = isSgLabelSymbol(*iter);</span></a>
<a name="15071"><span class="lineNum">   15071 </span><span class="lineCov">          3 :     if (l_symbol)</span></a>
<a name="15072"><span class="lineNum">   15072 </span>            :     {</a>
<a name="15073"><span class="lineNum">   15073 </span><span class="lineCov">          3 :       int cur_val = l_symbol-&gt;get_numeric_label_value();</span></a>
<a name="15074"><span class="lineNum">   15074 </span><span class="lineCov">          3 :       if (result &lt;=cur_val)</span></a>
<a name="15075"><span class="lineNum">   15075 </span><span class="lineCov">          1 :         result = cur_val +10;</span></a>
<a name="15076"><span class="lineNum">   15076 </span>            :     }</a>
<a name="15077"><span class="lineNum">   15077 </span>            :   }</a>
<a name="15078"><span class="lineNum">   15078 </span>            : </a>
<a name="15079"><span class="lineNum">   15079 </span><span class="lineCov">          2 :   ROSE_ASSERT (result &lt;= 99999); // max 5 digits for F77 label</span></a>
<a name="15080"><span class="lineNum">   15080 </span><span class="lineCov">          2 :   return result;</span></a>
<a name="15081"><span class="lineNum">   15081 </span>            : }</a>
<a name="15082"><span class="lineNum">   15082 </span>            : </a>
<a name="15083"><span class="lineNum">   15083 </span>            : //! fixup symbol table for SgFunctionDeclaration (and template instantiations, member functions, and member function template instantiations). Used Internally when the function is built without knowing its target scope. Both parameters cannot be NULL.</a>
<a name="15084"><span class="lineNum">   15084 </span>            : /*</a>
<a name="15085"><span class="lineNum">   15085 </span>            :  * function declarations can have a scope that is different from their structural location (e.g. member functions declared outside of the defining class declaration.</a>
<a name="15086"><span class="lineNum">   15086 </span>            :  */</a>
<a name="15087"><span class="lineNum">   15087 </span><span class="lineCov">    1167920 : void SageInterface::fixFunctionDeclaration(SgFunctionDeclaration* stmt, SgScopeStatement* scope)</span></a>
<a name="15088"><span class="lineNum">   15088 </span>            :    {</a>
<a name="15089"><span class="lineNum">   15089 </span>            :  // DQ (3/5/2012): Added test.</a>
<a name="15090"><span class="lineNum">   15090 </span><span class="lineCov">    1167920 :     ROSE_ASSERT(scope != NULL);</span></a>
<a name="15091"><span class="lineNum">   15091 </span>            : </a>
<a name="15092"><span class="lineNum">   15092 </span>            :  // fix function type table's parent edge</a>
<a name="15093"><span class="lineNum">   15093 </span>            :  // Liao 5/4/2010</a>
<a name="15094"><span class="lineNum">   15094 </span><span class="lineCov">    1167920 :     SgFunctionTypeTable * fTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="15095"><span class="lineNum">   15095 </span><span class="lineCov">    1167920 :     ROSE_ASSERT(fTable != NULL);</span></a>
<a name="15096"><span class="lineNum">   15096 </span>            : </a>
<a name="15097"><span class="lineNum">   15097 </span><span class="lineCov">    1167920 :     if (fTable-&gt;get_parent() == NULL)</span></a>
<a name="15098"><span class="lineNum">   15098 </span>            :        {</a>
<a name="15099"><span class="lineNum">   15099 </span>            :       // DQ (3/5/2012): This is a problem for test2012_13.C (test code taken from test2004_42.C).</a>
<a name="15100"><span class="lineNum">   15100 </span>            :       // fTable-&gt;set_parent(getGlobalScope(scope));</a>
<a name="15101"><span class="lineNum">   15101 </span>            : #if 0</a>
<a name="15102"><span class="lineNum">   15102 </span>            :          printf (&quot;WARNING: Skip setting the scope of the SgFunctionTypeTable scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="15103"><span class="lineNum">   15103 </span>            : #endif</a>
<a name="15104"><span class="lineNum">   15104 </span><span class="lineCov">        315 :          fTable-&gt;set_parent(getGlobalScope(scope));</span></a>
<a name="15105"><span class="lineNum">   15105 </span>            :        }</a>
<a name="15106"><span class="lineNum">   15106 </span>            : </a>
<a name="15107"><span class="lineNum">   15107 </span>            : #if 0</a>
<a name="15108"><span class="lineNum">   15108 </span>            :      printf (&quot;In SageInterface::fixStatement(): stmt = %p = %s \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="15109"><span class="lineNum">   15109 </span>            : #endif</a>
<a name="15110"><span class="lineNum">   15110 </span>            : </a>
<a name="15111"><span class="lineNum">   15111 </span>            :   // Liao 4/23/2010,  Fix function symbol</a>
<a name="15112"><span class="lineNum">   15112 </span>            :   // This could happen when users copy a function, then rename it (func-&gt;set_name()), and finally insert it to a scope</a>
<a name="15113"><span class="lineNum">   15113 </span>            :   // Added SgProgramHeaderStatement [Rasmussen, 2020.01.19]</a>
<a name="15114"><span class="lineNum">   15114 </span><span class="lineCov">    1167920 :      SgFunctionDeclaration               * func         = isSgFunctionDeclaration(stmt);</span></a>
<a name="15115"><span class="lineNum">   15115 </span><span class="lineCov">    1167920 :      SgMemberFunctionDeclaration         * mfunc        = isSgMemberFunctionDeclaration(stmt);</span></a>
<a name="15116"><span class="lineNum">   15116 </span><span class="lineCov">    1167920 :      SgTemplateFunctionDeclaration       * tfunc        = isSgTemplateFunctionDeclaration(stmt);</span></a>
<a name="15117"><span class="lineNum">   15117 </span><span class="lineCov">    1167920 :      SgTemplateMemberFunctionDeclaration * tmfunc       = isSgTemplateMemberFunctionDeclaration(stmt);</span></a>
<a name="15118"><span class="lineNum">   15118 </span><span class="lineCov">    1167920 :      SgProcedureHeaderStatement          * procfunc     = isSgProcedureHeaderStatement(stmt);</span></a>
<a name="15119"><span class="lineNum">   15119 </span><span class="lineCov">    1167920 :      SgProgramHeaderStatement            * progfunc     = isSgProgramHeaderStatement(stmt);</span></a>
<a name="15120"><span class="lineNum">   15120 </span>            : </a>
<a name="15121"><span class="lineNum">   15121 </span><span class="lineCov">    1167920 :      if (tmfunc != NULL)</span></a>
<a name="15122"><span class="lineNum">   15122 </span><span class="lineCov">      15881 :        assert(tmfunc-&gt;variantT() == V_SgTemplateMemberFunctionDeclaration);</span></a>
<a name="15123"><span class="lineNum">   15123 </span><span class="lineCov">    1152040 :      else if (mfunc != NULL)</span></a>
<a name="15124"><span class="lineNum">   15124 </span><span class="lineCov">      17896 :        assert(mfunc-&gt;variantT() == V_SgMemberFunctionDeclaration || mfunc-&gt;variantT() == V_SgTemplateInstantiationMemberFunctionDecl);</span></a>
<a name="15125"><span class="lineNum">   15125 </span><span class="lineCov">    1134140 :      else if (tfunc != NULL)</span></a>
<a name="15126"><span class="lineNum">   15126 </span><span class="lineCov">       3831 :        assert(tfunc-&gt;variantT() == V_SgTemplateFunctionDeclaration);</span></a>
<a name="15127"><span class="lineNum">   15127 </span><span class="lineCov">    1130310 :      else if (procfunc != NULL)</span></a>
<a name="15128"><span class="lineNum">   15128 </span><span class="lineCov">          5 :         assert(procfunc-&gt;variantT() == V_SgProcedureHeaderStatement);</span></a>
<a name="15129"><span class="lineNum">   15129 </span><span class="lineCov">    1130300 :      else if (progfunc != NULL)</span></a>
<a name="15130"><span class="lineNum">   15130 </span><span class="lineNoCov">          0 :         assert(progfunc-&gt;variantT() == V_SgProgramHeaderStatement);</span></a>
<a name="15131"><span class="lineNum">   15131 </span><span class="lineCov">    1130300 :      else if (func != NULL)</span></a>
<a name="15132"><span class="lineNum">   15132 </span><span class="lineCov">    1130300 :        assert(func-&gt;variantT() == V_SgFunctionDeclaration || func-&gt;variantT() == V_SgTemplateInstantiationFunctionDecl);</span></a>
<a name="15133"><span class="lineNum">   15133 </span><span class="lineNoCov">          0 :      else ROSE_ABORT();</span></a>
<a name="15134"><span class="lineNum">   15134 </span>            : </a>
<a name="15135"><span class="lineNum">   15135 </span>            : #if 0</a>
<a name="15136"><span class="lineNum">   15136 </span>            :      printf (&quot;In SageInterface::fixStatement(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="15137"><span class="lineNum">   15137 </span>            :      printf (&quot;In SageInterface::fixStatement(): stmt-&gt;get_scope() = %p \n&quot;,stmt-&gt;get_scope());</a>
<a name="15138"><span class="lineNum">   15138 </span>            : #endif</a>
<a name="15139"><span class="lineNum">   15139 </span>            : </a>
<a name="15140"><span class="lineNum">   15140 </span>            :   // DQ (12/3/2011): This is a scary piece of code, but I think it is OK now!</a>
<a name="15141"><span class="lineNum">   15141 </span>            :   // It is an error to put the symbol for a function into the current scope if the function's scope</a>
<a name="15142"><span class="lineNum">   15142 </span>            :   // is explicitly set to be different.  So this should be allowed only if the function's scope is</a>
<a name="15143"><span class="lineNum">   15143 </span>            :   // not explicitly set, or if the scopes match.  This is an example of something different for C++</a>
<a name="15144"><span class="lineNum">   15144 </span>            :   // than for C or other simpler languages.</a>
<a name="15145"><span class="lineNum">   15145 </span>            :   // If the scope of the function is not set, or if it matches the current scope then allow this step.</a>
<a name="15146"><span class="lineNum">   15146 </span><span class="lineCov">    1167920 :      if (stmt-&gt;get_scope() == NULL || scope == stmt-&gt;get_scope())</span></a>
<a name="15147"><span class="lineNum">   15147 </span>            :         {</a>
<a name="15148"><span class="lineNum">   15148 </span>            : #if 0</a>
<a name="15149"><span class="lineNum">   15149 </span>            :           printf (&quot;Looking up the function symbol using name = %s and type = %p = %s \n&quot;,func-&gt;get_name().str(),func-&gt;get_type(),func-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="15150"><span class="lineNum">   15150 </span>            : #endif</a>
<a name="15151"><span class="lineNum">   15151 </span><span class="lineCov">    1151480 :           SgFunctionSymbol* func_symbol = NULL;</span></a>
<a name="15152"><span class="lineNum">   15152 </span>            : </a>
<a name="15153"><span class="lineNum">   15153 </span>            :        // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.</a>
<a name="15154"><span class="lineNum">   15154 </span>            :        // In this case these are unavailable from this point.</a>
<a name="15155"><span class="lineNum">   15155 </span><span class="lineCov">    1151480 :           if (tmfunc != NULL)</span></a>
<a name="15156"><span class="lineNum">   15156 </span>            :           {</a>
<a name="15157"><span class="lineNum">   15157 </span><span class="lineCov">       8470 :             SgTemplateParameterPtrList &amp; templateParameterList = tmfunc-&gt;get_templateParameters();</span></a>
<a name="15158"><span class="lineNum">   15158 </span>            :          // func_symbol = scope-&gt;lookup_template_member_function_symbol (func-&gt;get_name(), func-&gt;get_type());</a>
<a name="15159"><span class="lineNum">   15159 </span>            :          // func_symbol = scope-&gt;lookup_template_member_function_symbol (func-&gt;get_name(), func-&gt;get_type(),NULL);</a>
<a name="15160"><span class="lineNum">   15160 </span><span class="lineCov">       8470 :             func_symbol = scope-&gt;lookup_template_member_function_symbol (func-&gt;get_name(), func-&gt;get_type(),&amp;templateParameterList);</span></a>
<a name="15161"><span class="lineNum">   15161 </span>            :           }</a>
<a name="15162"><span class="lineNum">   15162 </span><span class="lineCov">    1143010 :           else if (mfunc != NULL)</span></a>
<a name="15163"><span class="lineNum">   15163 </span>            :           {</a>
<a name="15164"><span class="lineNum">   15164 </span><span class="lineCov">      15896 :             SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(mfunc);</span></a>
<a name="15165"><span class="lineNum">   15165 </span><span class="lineCov">      15896 :             SgTemplateArgumentPtrList* templateArgumentList = (templateInstantiationMemberFunctionDecl != NULL) ? &amp;(templateInstantiationMemberFunctionDecl-&gt;get_templateArguments()) : NULL;</span></a>
<a name="15166"><span class="lineNum">   15166 </span>            :          // func_symbol = scope-&gt;lookup_nontemplate_member_function_symbol (func-&gt;get_name(), func-&gt;get_type(),NULL);</a>
<a name="15167"><span class="lineNum">   15167 </span><span class="lineCov">      15896 :             func_symbol = scope-&gt;lookup_nontemplate_member_function_symbol (func-&gt;get_name(), func-&gt;get_type(),templateArgumentList);</span></a>
<a name="15168"><span class="lineNum">   15168 </span>            :           }</a>
<a name="15169"><span class="lineNum">   15169 </span><span class="lineCov">    1127110 :           else if (tfunc != NULL)</span></a>
<a name="15170"><span class="lineNum">   15170 </span>            :           {</a>
<a name="15171"><span class="lineNum">   15171 </span><span class="lineCov">        114 :             SgTemplateParameterPtrList &amp; templateParameterList = tfunc-&gt;get_templateParameters();</span></a>
<a name="15172"><span class="lineNum">   15172 </span>            : #if 0</a>
<a name="15173"><span class="lineNum">   15173 </span>            :             printf (&quot;In SageInterface::fixStatement(): templateParameterList.size() = %&quot; PRIuPTR &quot; \n&quot;,templateParameterList.size());</a>
<a name="15174"><span class="lineNum">   15174 </span>            : #endif</a>
<a name="15175"><span class="lineNum">   15175 </span>            :          // func_symbol = scope-&gt;lookup_template_function_symbol (func-&gt;get_name(), func-&gt;get_type());</a>
<a name="15176"><span class="lineNum">   15176 </span>            :          // func_symbol = scope-&gt;lookup_template_function_symbol (func-&gt;get_name(), func-&gt;get_type(),NULL);</a>
<a name="15177"><span class="lineNum">   15177 </span><span class="lineCov">        114 :             func_symbol = scope-&gt;lookup_template_function_symbol (func-&gt;get_name(), func-&gt;get_type(),&amp;templateParameterList);</span></a>
<a name="15178"><span class="lineNum">   15178 </span>            :           }</a>
<a name="15179"><span class="lineNum">   15179 </span><span class="lineCov">    1127000 :           else if (procfunc != NULL)</span></a>
<a name="15180"><span class="lineNum">   15180 </span>            :           {</a>
<a name="15181"><span class="lineNum">   15181 </span>            : #if 0</a>
<a name="15182"><span class="lineNum">   15182 </span>            :             printf (&quot;In SageInterface::fixStatement(): procfunc-&gt;get_name() = %s calling lookup_function_symbol() \n&quot;,procfunc-&gt;get_name().str());</a>
<a name="15183"><span class="lineNum">   15183 </span>            : #endif</a>
<a name="15184"><span class="lineNum">   15184 </span><span class="lineCov">          5 :             func_symbol = scope-&gt;lookup_function_symbol (procfunc-&gt;get_name(), procfunc-&gt;get_type());</span></a>
<a name="15185"><span class="lineNum">   15185 </span><span class="lineCov">          5 :             assert(func_symbol != NULL);</span></a>
<a name="15186"><span class="lineNum">   15186 </span>            :           }</a>
<a name="15187"><span class="lineNum">   15187 </span><span class="lineCov">    1126990 :           else if (progfunc != NULL)</span></a>
<a name="15188"><span class="lineNum">   15188 </span>            :           {</a>
<a name="15189"><span class="lineNum">   15189 </span><span class="lineNoCov">          0 :             func_symbol = scope-&gt;lookup_function_symbol (progfunc-&gt;get_name(), progfunc-&gt;get_type());</span></a>
<a name="15190"><span class="lineNum">   15190 </span><span class="lineNoCov">          0 :             assert(func_symbol != NULL);</span></a>
<a name="15191"><span class="lineNum">   15191 </span>            :           }</a>
<a name="15192"><span class="lineNum">   15192 </span><span class="lineCov">    1126990 :           else if (func != NULL)</span></a>
<a name="15193"><span class="lineNum">   15193 </span>            :           {</a>
<a name="15194"><span class="lineNum">   15194 </span>            : #if 0</a>
<a name="15195"><span class="lineNum">   15195 </span>            :             printf (&quot;In SageInterface::fixStatement(): func-&gt;get_name() = %s calling lookup_function_symbol() \n&quot;,func-&gt;get_name().str());</a>
<a name="15196"><span class="lineNum">   15196 </span>            : #endif</a>
<a name="15197"><span class="lineNum">   15197 </span><span class="lineCov">    1126990 :             SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(func);</span></a>
<a name="15198"><span class="lineNum">   15198 </span><span class="lineCov">    1126990 :             SgTemplateArgumentPtrList* templateArgumentList = (templateInstantiationFunctionDecl != NULL) ? &amp;(templateInstantiationFunctionDecl-&gt;get_templateArguments()) : NULL;</span></a>
<a name="15199"><span class="lineNum">   15199 </span>            :          // func_symbol = scope-&gt;lookup_function_symbol (func-&gt;get_name(), func-&gt;get_type(),NULL);</a>
<a name="15200"><span class="lineNum">   15200 </span><span class="lineCov">    1126990 :             func_symbol = scope-&gt;lookup_function_symbol (func-&gt;get_name(), func-&gt;get_type(),templateArgumentList);</span></a>
<a name="15201"><span class="lineNum">   15201 </span>            : </a>
<a name="15202"><span class="lineNum">   15202 </span>            :          // DQ (8/23/2013): Adding support for when the symbol is not present.  This can happen when building a new function as a copy of an existing</a>
<a name="15203"><span class="lineNum">   15203 </span>            :          // function the symantics of the copy is that it will not add the symbol (since it does not know the scope). So this function is the first</a>
<a name="15204"><span class="lineNum">   15204 </span>            :          // opportunity to fixup the function to have a symbol in the scope's symbol table.</a>
<a name="15205"><span class="lineNum">   15205 </span><span class="lineCov">    1126990 :             if (func_symbol == NULL)</span></a>
<a name="15206"><span class="lineNum">   15206 </span>            :                {</a>
<a name="15207"><span class="lineNum">   15207 </span>            :               // scope-&gt;print_symboltable(&quot;In SageInterface::fixStatement()&quot;);</a>
<a name="15208"><span class="lineNum">   15208 </span><span class="lineCov">          1 :                  func_symbol = new SgFunctionSymbol(func);</span></a>
<a name="15209"><span class="lineNum">   15209 </span><span class="lineCov">          1 :                  scope-&gt;insert_symbol(func-&gt;get_name(), func_symbol);</span></a>
<a name="15210"><span class="lineNum">   15210 </span>            :                }</a>
<a name="15211"><span class="lineNum">   15211 </span>            :           }</a>
<a name="15212"><span class="lineNum">   15212 </span>            :           else</a>
<a name="15213"><span class="lineNum">   15213 </span>            :           {</a>
<a name="15214"><span class="lineNum">   15214 </span><span class="lineNoCov">          0 :             ROSE_ABORT();</span></a>
<a name="15215"><span class="lineNum">   15215 </span>            :           }</a>
<a name="15216"><span class="lineNum">   15216 </span>            : #if 0</a>
<a name="15217"><span class="lineNum">   15217 </span>            :           printf (&quot;In SageInterface::fixStatement(): func_symbol = %p \n&quot;,func_symbol);</a>
<a name="15218"><span class="lineNum">   15218 </span>            : #endif</a>
<a name="15219"><span class="lineNum">   15219 </span><span class="lineCov">    1151480 :           assert(func_symbol != NULL);</span></a>
<a name="15220"><span class="lineNum">   15220 </span>            :         }</a>
<a name="15221"><span class="lineNum">   15221 </span><span class="lineCov">    1167920 :    }</span></a>
<a name="15222"><span class="lineNum">   15222 </span>            : </a>
<a name="15223"><span class="lineNum">   15223 </span>            : //! fixup symbol table for SgFunctionDeclaration (and template instantiations, member functions, and member function template instantiations). Used Internally when the function is built without knowing its target scope. Both parameters cannot be NULL.</a>
<a name="15224"><span class="lineNum">   15224 </span>            : /*</a>
<a name="15225"><span class="lineNum">   15225 </span>            :  * function declarations can have a scope that is different from their structural location (e.g. member functions declared outside of the defining class declaration.</a>
<a name="15226"><span class="lineNum">   15226 </span>            :  */</a>
<a name="15227"><span class="lineNum">   15227 </span><span class="lineNoCov">          0 : void SageInterface::fixTemplateDeclaration(SgTemplateDeclaration* stmt, SgScopeStatement* scope)</span></a>
<a name="15228"><span class="lineNum">   15228 </span>            :    {</a>
<a name="15229"><span class="lineNum">   15229 </span>            :   // DQ (12/4/2011): This function has not been implemented yet.  It will assert fail if it is required.</a>
<a name="15230"><span class="lineNum">   15230 </span><span class="lineNoCov">          0 :      printf (&quot;Need to handle SgTemplateDeclaration IR nodes as well...(implement later) \n&quot;);</span></a>
<a name="15231"><span class="lineNum">   15231 </span>            :   // ROSE_ASSERT(false);</a>
<a name="15232"><span class="lineNum">   15232 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="15233"><span class="lineNum">   15233 </span>            : </a>
<a name="15234"><span class="lineNum">   15234 </span>            : </a>
<a name="15235"><span class="lineNum">   15235 </span>            : //! A wrapper containing fixes (fixVariableDeclaration(),fixStructDeclaration(), fixLabelStatement(), etc) for all kinds statements.</a>
<a name="15236"><span class="lineNum">   15236 </span><span class="lineCov">    1320340 : void SageInterface::fixStatement(SgStatement* stmt, SgScopeStatement* scope)</span></a>
<a name="15237"><span class="lineNum">   15237 </span>            :    {</a>
<a name="15238"><span class="lineNum">   15238 </span>            :   // fix symbol table</a>
<a name="15239"><span class="lineNum">   15239 </span><span class="lineCov">    1320340 :      if (isSgVariableDeclaration(stmt))</span></a>
<a name="15240"><span class="lineNum">   15240 </span>            :         {</a>
<a name="15241"><span class="lineNum">   15241 </span><span class="lineCov">      32837 :           fixVariableDeclaration(isSgVariableDeclaration(stmt), scope);</span></a>
<a name="15242"><span class="lineNum">   15242 </span>            :         }</a>
<a name="15243"><span class="lineNum">   15243 </span><span class="lineCov">    1287500 :        else if (isStructDeclaration(stmt))</span></a>
<a name="15244"><span class="lineNum">   15244 </span>            :         {</a>
<a name="15245"><span class="lineNum">   15245 </span>            :        // DQ (1/2/2010): Enforce some rules as early as possible.</a>
<a name="15246"><span class="lineNum">   15246 </span>            :        // fixStructDeclaration(isSgClassDeclaration(stmt),scope);</a>
<a name="15247"><span class="lineNum">   15247 </span><span class="lineCov">       9796 :           SgClassDeclaration* classDeclaration = isSgClassDeclaration(stmt);</span></a>
<a name="15248"><span class="lineNum">   15248 </span><span class="lineCov">       9796 :           ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="15249"><span class="lineNum">   15249 </span>            : #if 0</a>
<a name="15250"><span class="lineNum">   15250 </span>            :           ROSE_ASSERT(classDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="15251"><span class="lineNum">   15251 </span>            :           ROSE_ASSERT(classDeclaration-&gt;get_definingDeclaration() != NULL);</a>
<a name="15252"><span class="lineNum">   15252 </span>            : #endif</a>
<a name="15253"><span class="lineNum">   15253 </span><span class="lineCov">       9796 :           fixStructDeclaration(classDeclaration,scope);</span></a>
<a name="15254"><span class="lineNum">   15254 </span>            :         }</a>
<a name="15255"><span class="lineNum">   15255 </span><span class="lineCov">    1277700 :        else if (isSgClassDeclaration(stmt))</span></a>
<a name="15256"><span class="lineNum">   15256 </span>            :         {</a>
<a name="15257"><span class="lineNum">   15257 </span><span class="lineCov">       8243 :           fixClassDeclaration(isSgClassDeclaration(stmt),scope);</span></a>
<a name="15258"><span class="lineNum">   15258 </span>            :         }</a>
<a name="15259"><span class="lineNum">   15259 </span><span class="lineCov">    1269460 :       else if (isSgLabelStatement(stmt))</span></a>
<a name="15260"><span class="lineNum">   15260 </span>            :         {</a>
<a name="15261"><span class="lineNum">   15261 </span><span class="lineCov">          7 :           fixLabelStatement(isSgLabelStatement(stmt),scope);</span></a>
<a name="15262"><span class="lineNum">   15262 </span>            :         }</a>
<a name="15263"><span class="lineNum">   15263 </span><span class="lineCov">    1269450 :        else if (isSgFunctionDeclaration(stmt))</span></a>
<a name="15264"><span class="lineNum">   15264 </span>            :         {</a>
<a name="15265"><span class="lineNum">   15265 </span>            : #if 1</a>
<a name="15266"><span class="lineNum">   15266 </span><span class="lineCov">    1167920 :           fixFunctionDeclaration(isSgFunctionDeclaration(stmt),scope);</span></a>
<a name="15267"><span class="lineNum">   15267 </span>            : #else</a>
<a name="15268"><span class="lineNum">   15268 </span>            :        // fix function type table's parent edge</a>
<a name="15269"><span class="lineNum">   15269 </span>            :        // Liao 5/4/2010</a>
<a name="15270"><span class="lineNum">   15270 </span>            :           SgFunctionTypeTable * fTable = SgNode::get_globalFunctionTypeTable();</a>
<a name="15271"><span class="lineNum">   15271 </span>            :           ROSE_ASSERT(fTable);</a>
<a name="15272"><span class="lineNum">   15272 </span>            :           if (fTable-&gt;get_parent() == NULL)</a>
<a name="15273"><span class="lineNum">   15273 </span>            :                fTable-&gt;set_parent(getGlobalScope(scope));</a>
<a name="15274"><span class="lineNum">   15274 </span>            : </a>
<a name="15275"><span class="lineNum">   15275 </span>            :        // Liao 4/23/2010,  Fix function symbol</a>
<a name="15276"><span class="lineNum">   15276 </span>            :        // This could happen when users copy a function, then rename it (func-&gt;set_name()), and finally insert it to a scope</a>
<a name="15277"><span class="lineNum">   15277 </span>            :           SgFunctionDeclaration*       func        = isSgFunctionDeclaration(stmt);</a>
<a name="15278"><span class="lineNum">   15278 </span>            :           SgMemberFunctionDeclaration* mfunc       = isSgMemberFunctionDeclaration(stmt);</a>
<a name="15279"><span class="lineNum">   15279 </span>            : </a>
<a name="15280"><span class="lineNum">   15280 </span>            :           printf (&quot;In SageInterface::fixStatement(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="15281"><span class="lineNum">   15281 </span>            :           printf (&quot;In SageInterface::fixStatement(): stmt-&gt;get_scope() = %p \n&quot;,stmt-&gt;get_scope());</a>
<a name="15282"><span class="lineNum">   15282 </span>            : </a>
<a name="15283"><span class="lineNum">   15283 </span>            :        // DQ (12/3/2011): This is a scary piece of code, but I think it is OK now!</a>
<a name="15284"><span class="lineNum">   15284 </span>            :        // It is an error to put the symbol for a function into the current scope if the function's scope</a>
<a name="15285"><span class="lineNum">   15285 </span>            :        // is explicitly set to be different.  So this should be allowed only if the function's scope is</a>
<a name="15286"><span class="lineNum">   15286 </span>            :        // not explicitly set, or if the scopes match.  This is an example of something different for C++</a>
<a name="15287"><span class="lineNum">   15287 </span>            :        // than for C or other simpler languages.</a>
<a name="15288"><span class="lineNum">   15288 </span>            :        // If the scope of the function is not set, or if it matches the current scope then allow this step.</a>
<a name="15289"><span class="lineNum">   15289 </span>            :           if (stmt-&gt;get_scope() == NULL || scope == stmt-&gt;get_scope())</a>
<a name="15290"><span class="lineNum">   15290 </span>            :              {</a>
<a name="15291"><span class="lineNum">   15291 </span>            : #if 0</a>
<a name="15292"><span class="lineNum">   15292 </span>            :                printf (&quot;Looking up the function symbol using name = %s and type = %p = %s \n&quot;,func-&gt;get_name().str(),func-&gt;get_type(),func-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="15293"><span class="lineNum">   15293 </span>            : #endif</a>
<a name="15294"><span class="lineNum">   15294 </span>            :                SgFunctionSymbol*            func_symbol = scope-&gt;lookup_function_symbol (func-&gt;get_name(), func-&gt;get_type());</a>
<a name="15295"><span class="lineNum">   15295 </span>            : </a>
<a name="15296"><span class="lineNum">   15296 </span>            :                printf (&quot;In SageInterface::fixStatement(): func_symbol = %p \n&quot;,func_symbol);</a>
<a name="15297"><span class="lineNum">   15297 </span>            :                if (func_symbol == NULL)</a>
<a name="15298"><span class="lineNum">   15298 </span>            :                   {</a>
<a name="15299"><span class="lineNum">   15299 </span>            :                  // DQ (12/3/2011): Added support for C++ member functions.</a>
<a name="15300"><span class="lineNum">   15300 </span>            :                  // func_symbol = new SgFunctionSymbol (func);</a>
<a name="15301"><span class="lineNum">   15301 </span>            :                     if (mfunc != NULL)</a>
<a name="15302"><span class="lineNum">   15302 </span>            :                        {</a>
<a name="15303"><span class="lineNum">   15303 </span>            :                          func_symbol = new SgMemberFunctionSymbol (func);</a>
<a name="15304"><span class="lineNum">   15304 </span>            :                        }</a>
<a name="15305"><span class="lineNum">   15305 </span>            :                       else</a>
<a name="15306"><span class="lineNum">   15306 </span>            :                        {</a>
<a name="15307"><span class="lineNum">   15307 </span>            :                          func_symbol = new SgFunctionSymbol (func);</a>
<a name="15308"><span class="lineNum">   15308 </span>            :                        }</a>
<a name="15309"><span class="lineNum">   15309 </span>            :                     ROSE_ASSERT (func_symbol != NULL);</a>
<a name="15310"><span class="lineNum">   15310 </span>            : </a>
<a name="15311"><span class="lineNum">   15311 </span>            :                     scope-&gt;insert_symbol(func-&gt;get_name(), func_symbol);</a>
<a name="15312"><span class="lineNum">   15312 </span>            :                   }</a>
<a name="15313"><span class="lineNum">   15313 </span>            :                  else</a>
<a name="15314"><span class="lineNum">   15314 </span>            :                   {</a>
<a name="15315"><span class="lineNum">   15315 </span>            :                     printf (&quot;In SageInterface::fixStatement(): found a valid function so no need to insert new symbol \n&quot;);</a>
<a name="15316"><span class="lineNum">   15316 </span>            :                   }</a>
<a name="15317"><span class="lineNum">   15317 </span>            :              }</a>
<a name="15318"><span class="lineNum">   15318 </span>            : #if 0</a>
<a name="15319"><span class="lineNum">   15319 </span>            :        // Fix local symbol, a symbol directly refer to this function declaration</a>
<a name="15320"><span class="lineNum">   15320 </span>            :        // This could happen when a non-defining func decl is copied, the corresonding symbol will point to the original source func</a>
<a name="15321"><span class="lineNum">   15321 </span>            :        // symbolTable-&gt;find(this) used inside get_symbol_from_symbol_table()  won't find the copied decl</a>
<a name="15322"><span class="lineNum">   15322 </span>            :           SgSymbol* local_symbol = func -&gt;get_symbol_from_symbol_table();</a>
<a name="15323"><span class="lineNum">   15323 </span>            :           if (local_symbol == NULL) //</a>
<a name="15324"><span class="lineNum">   15324 </span>            :              {</a>
<a name="15325"><span class="lineNum">   15325 </span>            :                if (func-&gt;get_definingDeclaration() == NULL) // prototype function</a>
<a name="15326"><span class="lineNum">   15326 </span>            :                   {</a>
<a name="15327"><span class="lineNum">   15327 </span>            :                     SgFunctionDeclaration * src_func = func_symbol-&gt;get_declaration();</a>
<a name="15328"><span class="lineNum">   15328 </span>            :                     if (func != src_func )</a>
<a name="15329"><span class="lineNum">   15329 </span>            :                        {</a>
<a name="15330"><span class="lineNum">   15330 </span>            :                          ROSE_ASSERT (src_func-&gt;get_firstNondefiningDeclaration () == src_func);</a>
<a name="15331"><span class="lineNum">   15331 </span>            :                          func-&gt;set_firstNondefiningDeclaration (func_symbol-&gt;get_declaration());</a>
<a name="15332"><span class="lineNum">   15332 </span>            :                        }</a>
<a name="15333"><span class="lineNum">   15333 </span>            :                   }</a>
<a name="15334"><span class="lineNum">   15334 </span>            :              }</a>
<a name="15335"><span class="lineNum">   15335 </span>            : #endif</a>
<a name="15336"><span class="lineNum">   15336 </span>            : #endif</a>
<a name="15337"><span class="lineNum">   15337 </span>            :         }</a>
<a name="15338"><span class="lineNum">   15338 </span><span class="lineCov">     101538 :        else if (isSgTemplateDeclaration(stmt) != NULL)</span></a>
<a name="15339"><span class="lineNum">   15339 </span>            :         {</a>
<a name="15340"><span class="lineNum">   15340 </span>            :        // DQ (12/3/2011): Added new case for SgTemplateDeclaration (adding template declarations to the AST).</a>
<a name="15341"><span class="lineNum">   15341 </span><span class="lineNoCov">          0 :           fixTemplateDeclaration(isSgTemplateDeclaration(stmt),scope);</span></a>
<a name="15342"><span class="lineNum">   15342 </span>            :         }</a>
<a name="15343"><span class="lineNum">   15343 </span>            : </a>
<a name="15344"><span class="lineNum">   15344 </span>            : #if 0</a>
<a name="15345"><span class="lineNum">   15345 </span>            :   // DQ (12/4/2011): This WAS not the correct behavior for C++ since declarations can appear structureally in different</a>
<a name="15346"><span class="lineNum">   15346 </span>            :   // scopes than where the are positioned (e.g. member functions defined outside of there associated class).</a>
<a name="15347"><span class="lineNum">   15347 </span>            :   // This this code is very dangerous.</a>
<a name="15348"><span class="lineNum">   15348 </span>            : </a>
<a name="15349"><span class="lineNum">   15349 </span>            :   // fix scope pointer for statements explicitly storing scope pointer</a>
<a name="15350"><span class="lineNum">   15350 </span>            :      switch (stmt-&gt;variantT())</a>
<a name="15351"><span class="lineNum">   15351 </span>            :         {</a>
<a name="15352"><span class="lineNum">   15352 </span>            :        // The case of SgLabelStatement should maybe be included.</a>
<a name="15353"><span class="lineNum">   15353 </span>            :           case V_SgEnumDeclaration:</a>
<a name="15354"><span class="lineNum">   15354 </span>            :           case V_SgTemplateDeclaration:</a>
<a name="15355"><span class="lineNum">   15355 </span>            :           case V_SgTypedefDeclaration:</a>
<a name="15356"><span class="lineNum">   15356 </span>            :           case V_SgFunctionDeclaration:</a>
<a name="15357"><span class="lineNum">   15357 </span>            :           case V_SgMemberFunctionDeclaration:</a>
<a name="15358"><span class="lineNum">   15358 </span>            :           case V_SgTemplateInstantiationFunctionDecl:</a>
<a name="15359"><span class="lineNum">   15359 </span>            :              {</a>
<a name="15360"><span class="lineNum">   15360 </span>            :             // DQ (12/4/2011): We can't just set the scope this simily (except in C).  In C++ the scope should have</a>
<a name="15361"><span class="lineNum">   15361 </span>            :             // already been set or we can let it default to the current scope where it si located structurally.</a>
<a name="15362"><span class="lineNum">   15362 </span>            :             // stmt-&gt;set_scope(scope);</a>
<a name="15363"><span class="lineNum">   15363 </span>            :                 if ( (stmt-&gt;hasExplicitScope() == true) &amp;&amp; (stmt-&gt;get_scope() == NULL) )</a>
<a name="15364"><span class="lineNum">   15364 </span>            :                   {</a>
<a name="15365"><span class="lineNum">   15365 </span>            :                     stmt-&gt;set_scope(scope);</a>
<a name="15366"><span class="lineNum">   15366 </span>            :                   }</a>
<a name="15367"><span class="lineNum">   15367 </span>            :                break;</a>
<a name="15368"><span class="lineNum">   15368 </span>            :              }</a>
<a name="15369"><span class="lineNum">   15369 </span>            : </a>
<a name="15370"><span class="lineNum">   15370 </span>            :           default:</a>
<a name="15371"><span class="lineNum">   15371 </span>            :              {</a>
<a name="15372"><span class="lineNum">   15372 </span>            :             // debugging support...</a>
<a name="15373"><span class="lineNum">   15373 </span>            :                printf (&quot;In SageInterface::fixStatement(): switch default case used (likely OK): stmt = %p = %s \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="15374"><span class="lineNum">   15374 </span>            :                ROSE_ASSERT(stmt-&gt;hasExplicitScope() == false);</a>
<a name="15375"><span class="lineNum">   15375 </span>            : #if 0</a>
<a name="15376"><span class="lineNum">   15376 </span>            :                printf (&quot;switch case not handled properly: stmt = %p = %s \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="15377"><span class="lineNum">   15377 </span>            :                ROSE_ABORT();</a>
<a name="15378"><span class="lineNum">   15378 </span>            : #endif</a>
<a name="15379"><span class="lineNum">   15379 </span>            :                break;</a>
<a name="15380"><span class="lineNum">   15380 </span>            :              }</a>
<a name="15381"><span class="lineNum">   15381 </span>            :         }</a>
<a name="15382"><span class="lineNum">   15382 </span>            : #else</a>
<a name="15383"><span class="lineNum">   15383 </span>            :   // If the scoep has to be set and it has not yet been set, then set it directly.</a>
<a name="15384"><span class="lineNum">   15384 </span><span class="lineCov">    1320340 :      if ( (stmt-&gt;hasExplicitScope() == true) &amp;&amp; (stmt-&gt;get_scope() == NULL) )</span></a>
<a name="15385"><span class="lineNum">   15385 </span>            :         {</a>
<a name="15386"><span class="lineNum">   15386 </span><span class="lineNoCov">          0 :           stmt-&gt;set_scope(scope);</span></a>
<a name="15387"><span class="lineNum">   15387 </span>            :         }</a>
<a name="15388"><span class="lineNum">   15388 </span>            : #endif</a>
<a name="15389"><span class="lineNum">   15389 </span><span class="lineCov">    1320340 :    }</span></a>
<a name="15390"><span class="lineNum">   15390 </span>            : </a>
<a name="15391"><span class="lineNum">   15391 </span>            : </a>
<a name="15392"><span class="lineNum">   15392 </span>            : /*! Liao, 7/3/2008</a>
<a name="15393"><span class="lineNum">   15393 </span>            :  * Update a list of function declarations inside a scope according to a newly introduced one</a>
<a name="15394"><span class="lineNum">   15394 </span>            :  *</a>
<a name="15395"><span class="lineNum">   15395 </span>            :  * Algorithm:</a>
<a name="15396"><span class="lineNum">   15396 </span>            :  * iterate declaration list for the same functions</a>
<a name="15397"><span class="lineNum">   15397 </span>            :  * func is defining:</a>
<a name="15398"><span class="lineNum">   15398 </span>            :  *       set_defining for all</a>
<a name="15399"><span class="lineNum">   15399 </span>            :  * func is nondefining:</a>
<a name="15400"><span class="lineNum">   15400 </span>            :  *       is first ?  set_first_nondefining for all</a>
<a name="15401"><span class="lineNum">   15401 </span>            :  *       not the first ? set first nondefining for itself only</a>
<a name="15402"><span class="lineNum">   15402 </span>            :  */</a>
<a name="15403"><span class="lineNum">   15403 </span><span class="lineCov">         20 : void SageInterface::updateDefiningNondefiningLinks(SgFunctionDeclaration* func, SgScopeStatement* scope)</span></a>
<a name="15404"><span class="lineNum">   15404 </span>            :    {</a>
<a name="15405"><span class="lineNum">   15405 </span>            :   // DQ (11/19/2012): Note that this appears to be an expensive function presently taking 22.5% of the total time</a>
<a name="15406"><span class="lineNum">   15406 </span>            :   // to process the tests/CompilerTests/Cxx_tests/rosePerformance.C file.  So this is a performance problem.</a>
<a name="15407"><span class="lineNum">   15407 </span>            : </a>
<a name="15408"><span class="lineNum">   15408 </span><span class="lineCov">         20 :      ROSE_ASSERT(func != NULL &amp;&amp; scope != NULL);</span></a>
<a name="15409"><span class="lineNum">   15409 </span>            : </a>
<a name="15410"><span class="lineNum">   15410 </span><span class="lineCov">         20 :      ROSE_ASSERT(func  != NULL);</span></a>
<a name="15411"><span class="lineNum">   15411 </span><span class="lineCov">         20 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="15412"><span class="lineNum">   15412 </span>            : </a>
<a name="15413"><span class="lineNum">   15413 </span><span class="lineCov">         40 :      SgStatementPtrList stmtList, sameFuncList;</span></a>
<a name="15414"><span class="lineNum">   15414 </span>            : </a>
<a name="15415"><span class="lineNum">   15415 </span>            :   // SgFunctionDeclaration* first_nondef = NULL;</a>
<a name="15416"><span class="lineNum">   15416 </span>            :   // Some annoying part of scope</a>
<a name="15417"><span class="lineNum">   15417 </span><span class="lineCov">         20 :      if (scope-&gt;containsOnlyDeclarations())</span></a>
<a name="15418"><span class="lineNum">   15418 </span>            :         {</a>
<a name="15419"><span class="lineNum">   15419 </span><span class="lineCov">         40 :           SgDeclarationStatementPtrList declList = scope-&gt;getDeclarationList();</span></a>
<a name="15420"><span class="lineNum">   15420 </span><span class="lineCov">         20 :           SgDeclarationStatementPtrList::iterator i;</span></a>
<a name="15421"><span class="lineNum">   15421 </span><span class="lineCov">      50588 :           for (i=declList.begin();i!=declList.end();i++)</span></a>
<a name="15422"><span class="lineNum">   15422 </span><span class="lineCov">      50568 :                stmtList.push_back(*i);</span></a>
<a name="15423"><span class="lineNum">   15423 </span>            :         }</a>
<a name="15424"><span class="lineNum">   15424 </span>            :        else</a>
<a name="15425"><span class="lineNum">   15425 </span>            :         {</a>
<a name="15426"><span class="lineNum">   15426 </span><span class="lineNoCov">          0 :           stmtList = scope-&gt;getStatementList();</span></a>
<a name="15427"><span class="lineNum">   15427 </span>            :         }</a>
<a name="15428"><span class="lineNum">   15428 </span>            : </a>
<a name="15429"><span class="lineNum">   15429 </span><span class="lineCov">         20 :      SgFunctionDeclaration* firstNondefiningFunctionDeclaration = isSgFunctionDeclaration(func-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="15430"><span class="lineNum">   15430 </span><span class="lineCov">         20 :      if (firstNondefiningFunctionDeclaration != NULL)</span></a>
<a name="15431"><span class="lineNum">   15431 </span>            :         {</a>
<a name="15432"><span class="lineNum">   15432 </span>            :        // If there exists a non-NULL reference to a firstNondefiningFunctionDeclaration</a>
<a name="15433"><span class="lineNum">   15433 </span>            :        // then use it (unless we want to handle where it might be set wrong).</a>
<a name="15434"><span class="lineNum">   15434 </span>            : #if 0</a>
<a name="15435"><span class="lineNum">   15435 </span>            :           printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): func = %p Found a valid pointer to a firstNondefiningFunctionDeclaration = %p \n&quot;,func,firstNondefiningFunctionDeclaration);</a>
<a name="15436"><span class="lineNum">   15436 </span>            : #endif</a>
<a name="15437"><span class="lineNum">   15437 </span>            :         }</a>
<a name="15438"><span class="lineNum">   15438 </span>            : </a>
<a name="15439"><span class="lineNum">   15439 </span>            :   // DQ (3/12/2012): Added assertion</a>
<a name="15440"><span class="lineNum">   15440 </span>            :   // ROSE_ASSERT(scope == func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope());</a>
<a name="15441"><span class="lineNum">   15441 </span><span class="lineCov">         20 :      ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope() != NULL);</span></a>
<a name="15442"><span class="lineNum">   15442 </span>            : </a>
<a name="15443"><span class="lineNum">   15443 </span>            :   // DQ (5/25/2013): This test fails for the astInterface test: buildStructDeclaration.C, since this is a new test, make it a warning for now.</a>
<a name="15444"><span class="lineNum">   15444 </span><span class="lineCov">         20 :      if (func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope()-&gt;lookup_function_symbol(func-&gt;get_name(),func-&gt;get_type()) == NULL)</span></a>
<a name="15445"><span class="lineNum">   15445 </span>            :         {</a>
<a name="15446"><span class="lineNum">   15446 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: symbol for func-&gt;get_firstNondefiningDeclaration() = %p = %s = %s is not present in the scope = %p = %s associated with the firstNondefiningDeclaration \n&quot;,</span></a>
<a name="15447"><span class="lineNum">   15447 </span><span class="lineNoCov">          0 :                func-&gt;get_firstNondefiningDeclaration(),func-&gt;get_firstNondefiningDeclaration()-&gt;class_name().c_str(),func-&gt;get_name().str(),</span></a>
<a name="15448"><span class="lineNum">   15448 </span><span class="lineNoCov">          0 :                func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope(),func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope()-&gt;class_name().c_str());</span></a>
<a name="15449"><span class="lineNum">   15449 </span>            :         }</a>
<a name="15450"><span class="lineNum">   15450 </span>            :   // ROSE_ASSERT(func-&gt;get_firstNondefiningDeclaration()-&gt;get_scope()-&gt;lookup_function_symbol(func-&gt;get_name(),func-&gt;get_type()) != NULL);</a>
<a name="15451"><span class="lineNum">   15451 </span>            : </a>
<a name="15452"><span class="lineNum">   15452 </span>            : #if 0</a>
<a name="15453"><span class="lineNum">   15453 </span>            :   // It would be better to find the first non-defining declaration via the symbol.</a>
<a name="15454"><span class="lineNum">   15454 </span>            :      SgSymbol* functionSymbol = scope-&gt;lookup_function_symbol(func-&gt;get_name(),func-&gt;get_type());</a>
<a name="15455"><span class="lineNum">   15455 </span>            :      if (functionSymbol != NULL)</a>
<a name="15456"><span class="lineNum">   15456 </span>            :         {</a>
<a name="15457"><span class="lineNum">   15457 </span>            :           printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): func = %p Found a valid symbol = %p \n&quot;,func,functionSymbol);</a>
<a name="15458"><span class="lineNum">   15458 </span>            :         }</a>
<a name="15459"><span class="lineNum">   15459 </span>            :        else</a>
<a name="15460"><span class="lineNum">   15460 </span>            :         {</a>
<a name="15461"><span class="lineNum">   15461 </span>            :           printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): func = %p functionSymbol == NULL \n&quot;,func);</a>
<a name="15462"><span class="lineNum">   15462 </span>            :         }</a>
<a name="15463"><span class="lineNum">   15463 </span>            : #endif</a>
<a name="15464"><span class="lineNum">   15464 </span>            : </a>
<a name="15465"><span class="lineNum">   15465 </span>            :   // Find the same function declaration list, including func itself</a>
<a name="15466"><span class="lineNum">   15466 </span><span class="lineCov">         20 :      SgStatementPtrList::iterator j;</span></a>
<a name="15467"><span class="lineNum">   15467 </span><span class="lineCov">      50588 :      for (j = stmtList.begin(); j != stmtList.end(); j++)</span></a>
<a name="15468"><span class="lineNum">   15468 </span>            :         {</a>
<a name="15469"><span class="lineNum">   15469 </span><span class="lineCov">      50568 :           SgFunctionDeclaration* func_decl = isSgFunctionDeclaration(*j);</span></a>
<a name="15470"><span class="lineNum">   15470 </span><span class="lineCov">      50568 :           if (func_decl != NULL)</span></a>
<a name="15471"><span class="lineNum">   15471 </span>            :              {</a>
<a name="15472"><span class="lineNum">   15472 </span>            :             // DQ (11/19/2012): This call to the isSameFunction() function is taking a total of 22.1%</a>
<a name="15473"><span class="lineNum">   15473 </span>            :             // of the total execution time of the tests/CompilerTests/Cxx_tests/rosePerformance.C file.</a>
<a name="15474"><span class="lineNum">   15474 </span><span class="lineCov">      48752 :                if (isSameFunction(func_decl, func))</span></a>
<a name="15475"><span class="lineNum">   15475 </span>            :                   {</a>
<a name="15476"><span class="lineNum">   15476 </span>            :                  // Assume all defining functions have definingdeclaration links set properly already!!</a>
<a name="15477"><span class="lineNum">   15477 </span>            :                  // if ((first_nondef == NULL) &amp;&amp; (func_decl-&gt;get_definingDeclaration() == NULL))</a>
<a name="15478"><span class="lineNum">   15478 </span>            :                  //      first_nondef = func_decl;</a>
<a name="15479"><span class="lineNum">   15479 </span><span class="lineCov">         30 :                     sameFuncList.push_back(func_decl);</span></a>
<a name="15480"><span class="lineNum">   15480 </span>            :                   }</a>
<a name="15481"><span class="lineNum">   15481 </span>            :              }</a>
<a name="15482"><span class="lineNum">   15482 </span>            :         }</a>
<a name="15483"><span class="lineNum">   15483 </span>            : </a>
<a name="15484"><span class="lineNum">   15484 </span>            : #if 1</a>
<a name="15485"><span class="lineNum">   15485 </span><span class="lineCov">         20 :      printf (&quot;func                            = %p \n&quot;,func);</span></a>
<a name="15486"><span class="lineNum">   15486 </span><span class="lineCov">         20 :      printf (&quot;func-&gt;get_definingDeclaration() = %p \n&quot;,func-&gt;get_definingDeclaration());</span></a>
<a name="15487"><span class="lineNum">   15487 </span><span class="lineCov">         20 :      printf (&quot;func                            = %p \n&quot;,func);</span></a>
<a name="15488"><span class="lineNum">   15488 </span>            : #endif</a>
<a name="15489"><span class="lineNum">   15489 </span>            : </a>
<a name="15490"><span class="lineNum">   15490 </span><span class="lineCov">         20 :      ROSE_ASSERT(func != NULL);</span></a>
<a name="15491"><span class="lineNum">   15491 </span>            : </a>
<a name="15492"><span class="lineNum">   15492 </span><span class="lineCov">         20 :      if (func-&gt;get_definingDeclaration() == func)</span></a>
<a name="15493"><span class="lineNum">   15493 </span>            :         {</a>
<a name="15494"><span class="lineNum">   15494 </span><span class="lineCov">         24 :           for (j = sameFuncList.begin(); j != sameFuncList.end(); j++)</span></a>
<a name="15495"><span class="lineNum">   15495 </span><span class="lineCov">         13 :                isSgFunctionDeclaration(*j)-&gt;set_definingDeclaration(func);</span></a>
<a name="15496"><span class="lineNum">   15496 </span>            :         }</a>
<a name="15497"><span class="lineNum">   15497 </span>            :        else</a>
<a name="15498"><span class="lineNum">   15498 </span>            :         {</a>
<a name="15499"><span class="lineNum">   15499 </span><span class="lineCov">          9 :           ROSE_ASSERT(func  != NULL);</span></a>
<a name="15500"><span class="lineNum">   15500 </span>            : </a>
<a name="15501"><span class="lineNum">   15501 </span>            :        // DQ (3/9/2012): Added assertion to avoid empty list that would be an error in both cases below.</a>
<a name="15502"><span class="lineNum">   15502 </span><span class="lineCov">          9 :           ROSE_ASSERT(sameFuncList.empty() == false);</span></a>
<a name="15503"><span class="lineNum">   15503 </span>            : </a>
<a name="15504"><span class="lineNum">   15504 </span><span class="lineCov">          9 :           if (func == isSgFunctionDeclaration(*(sameFuncList.begin()))) // is first_nondefining declaration</span></a>
<a name="15505"><span class="lineNum">   15505 </span>            :              {</a>
<a name="15506"><span class="lineNum">   15506 </span><span class="lineCov">         11 :                for (j = sameFuncList.begin(); j != sameFuncList.end(); j++)</span></a>
<a name="15507"><span class="lineNum">   15507 </span>            :                   {</a>
<a name="15508"><span class="lineNum">   15508 </span><span class="lineCov">          6 :                     SgFunctionDeclaration* func_decl = isSgFunctionDeclaration(*j);</span></a>
<a name="15509"><span class="lineNum">   15509 </span>            : #if 0</a>
<a name="15510"><span class="lineNum">   15510 </span>            :                     printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): (case 1) Testing j = %p set_firstNondefiningDeclaration(%p) \n&quot;,*j,func);</a>
<a name="15511"><span class="lineNum">   15511 </span>            : #endif</a>
<a name="15512"><span class="lineNum">   15512 </span>            :                  // DQ (3/9/2012): Avoid setting the function to be it's own firstNondefiningDeclaration.</a>
<a name="15513"><span class="lineNum">   15513 </span>            :                  // isSgFunctionDeclaration(*j)-&gt;set_firstNondefiningDeclaration(func);</a>
<a name="15514"><span class="lineNum">   15514 </span>            :                  // if (*j != func)</a>
<a name="15515"><span class="lineNum">   15515 </span><span class="lineCov">          6 :                     if (func_decl != func)</span></a>
<a name="15516"><span class="lineNum">   15516 </span>            :                        {</a>
<a name="15517"><span class="lineNum">   15517 </span>            :                       // DQ (11/18/2013): Modified to only set if not already set (see buildIfStmt.C in tests/nonsmoke/functional/roseTests/astInterface_tests).</a>
<a name="15518"><span class="lineNum">   15518 </span>            :                       // isSgFunctionDeclaration(*j)-&gt;set_firstNondefiningDeclaration(func);</a>
<a name="15519"><span class="lineNum">   15519 </span><span class="lineCov">          1 :                          if (func_decl-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="15520"><span class="lineNum">   15520 </span>            :                             {</a>
<a name="15521"><span class="lineNum">   15521 </span>            : #if 0</a>
<a name="15522"><span class="lineNum">   15522 </span>            :                               printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): (case 1) Calling j = %p set_firstNondefiningDeclaration(%p) \n&quot;,*j,func);</a>
<a name="15523"><span class="lineNum">   15523 </span>            : #endif</a>
<a name="15524"><span class="lineNum">   15524 </span><span class="lineNoCov">          0 :                               func_decl-&gt;set_firstNondefiningDeclaration(func);</span></a>
<a name="15525"><span class="lineNum">   15525 </span>            :                             }</a>
<a name="15526"><span class="lineNum">   15526 </span>            :                        }</a>
<a name="15527"><span class="lineNum">   15527 </span>            :                   }</a>
<a name="15528"><span class="lineNum">   15528 </span>            :              }</a>
<a name="15529"><span class="lineNum">   15529 </span>            :             else // is a following nondefining declaration, grab any other's first nondefining link then</a>
<a name="15530"><span class="lineNum">   15530 </span>            :              {</a>
<a name="15531"><span class="lineNum">   15531 </span>            : #if 0</a>
<a name="15532"><span class="lineNum">   15532 </span>            :                printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): (case 2) Testing func = %p set_firstNondefiningDeclaration(%p) \n&quot;,func,isSgFunctionDeclaration(*(sameFuncList.begin()))-&gt;get_firstNondefiningDeclaration());</a>
<a name="15533"><span class="lineNum">   15533 </span>            : #endif</a>
<a name="15534"><span class="lineNum">   15534 </span>            :             // DQ (11/18/2013): Modified to only set if not already set (see buildIfStmt.C in tests/nonsmoke/functional/roseTests/astInterface_tests).</a>
<a name="15535"><span class="lineNum">   15535 </span>            :             // func-&gt;set_firstNondefiningDeclaration(isSgFunctionDeclaration(*(sameFuncList.begin()))-&gt;get_firstNondefiningDeclaration());</a>
<a name="15536"><span class="lineNum">   15536 </span><span class="lineCov">          4 :                if (func-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="15537"><span class="lineNum">   15537 </span>            :                   {</a>
<a name="15538"><span class="lineNum">   15538 </span>            : #if 0</a>
<a name="15539"><span class="lineNum">   15539 </span>            :                     printf (&quot;In SageInterface::updateDefiningNondefiningLinks(): (case 2) Calling func = %p set_firstNondefiningDeclaration(%p) \n&quot;,func,isSgFunctionDeclaration(*(sameFuncList.begin()))-&gt;get_firstNondefiningDeclaration());</a>
<a name="15540"><span class="lineNum">   15540 </span>            : #endif</a>
<a name="15541"><span class="lineNum">   15541 </span><span class="lineNoCov">          0 :                     func-&gt;set_firstNondefiningDeclaration(isSgFunctionDeclaration(*(sameFuncList.begin()))-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="15542"><span class="lineNum">   15542 </span>            :                   }</a>
<a name="15543"><span class="lineNum">   15543 </span>            :              }</a>
<a name="15544"><span class="lineNum">   15544 </span>            :         }</a>
<a name="15545"><span class="lineNum">   15545 </span><span class="lineCov">         20 :    }</span></a>
<a name="15546"><span class="lineNum">   15546 </span>            : </a>
<a name="15547"><span class="lineNum">   15547 </span><span class="lineNoCov">          0 : PreprocessingInfo* SageInterface::attachComment(SgSourceFile * source_file, const std::string &amp; content, PreprocessingInfo::DirectiveType directive_type, PreprocessingInfo::RelativePositionType  position) {</span></a>
<a name="15548"><span class="lineNum">   15548 </span><span class="lineNoCov">          0 :   assert(source_file != NULL);</span></a>
<a name="15549"><span class="lineNum">   15549 </span><span class="lineNoCov">          0 :   assert(position == PreprocessingInfo::before || position ==  PreprocessingInfo::after);</span></a>
<a name="15550"><span class="lineNum">   15550 </span>            : </a>
<a name="15551"><span class="lineNum">   15551 </span><span class="lineNoCov">          0 :   SgGlobal * global_scope = source_file-&gt;get_globalScope();</span></a>
<a name="15552"><span class="lineNum">   15552 </span>            : </a>
<a name="15553"><span class="lineNum">   15553 </span><span class="lineNoCov">          0 :   PreprocessingInfo* result = new PreprocessingInfo(directive_type, content, &quot;Transformation generated&quot;,0, 0, 0, position);</span></a>
<a name="15554"><span class="lineNum">   15554 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(result);</span></a>
<a name="15555"><span class="lineNum">   15555 </span>            : </a>
<a name="15556"><span class="lineNum">   15556 </span>            :   // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="15557"><span class="lineNum">   15557 </span>            :   // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="15558"><span class="lineNum">   15558 </span>            :   // when multiple files are used on the command line.</a>
<a name="15559"><span class="lineNum">   15559 </span><span class="lineNoCov">          0 :   result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15560"><span class="lineNum">   15560 </span>            : </a>
<a name="15561"><span class="lineNum">   15561 </span><span class="lineNoCov">          0 :   global_scope-&gt;addToAttachedPreprocessingInfo(result, position);</span></a>
<a name="15562"><span class="lineNum">   15562 </span>            : </a>
<a name="15563"><span class="lineNum">   15563 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="15564"><span class="lineNum">   15564 </span>            : }</a>
<a name="15565"><span class="lineNum">   15565 </span>            : </a>
<a name="15566"><span class="lineNum">   15566 </span>            : //---------------------------------------------------------------</a>
<a name="15567"><span class="lineNum">   15567 </span><span class="lineCov">          5 : PreprocessingInfo* SageInterface::attachComment(</span></a>
<a name="15568"><span class="lineNum">   15568 </span>            :            SgLocatedNode* target, const string&amp; content,</a>
<a name="15569"><span class="lineNum">   15569 </span>            :            PreprocessingInfo::RelativePositionType  position /*=PreprocessingInfo::before*/,</a>
<a name="15570"><span class="lineNum">   15570 </span>            :            PreprocessingInfo::DirectiveType dtype /* PreprocessingInfo::CpreprocessorUnknownDeclaration */)</a>
<a name="15571"><span class="lineNum">   15571 </span>            :    {</a>
<a name="15572"><span class="lineNum">   15572 </span><span class="lineCov">          5 :      ROSE_ASSERT(target); //dangling comment is not allowed</span></a>
<a name="15573"><span class="lineNum">   15573 </span>            : </a>
<a name="15574"><span class="lineNum">   15574 </span><span class="lineCov">          5 :      PreprocessingInfo* result = NULL;</span></a>
<a name="15575"><span class="lineNum">   15575 </span><span class="lineCov">          5 :      PreprocessingInfo::DirectiveType mytype=dtype;</span></a>
<a name="15576"><span class="lineNum">   15576 </span><span class="lineCov">          5 :      string comment;</span></a>
<a name="15577"><span class="lineNum">   15577 </span>            : </a>
<a name="15578"><span class="lineNum">   15578 </span>            :   // Rasmussen (11/3/2020): Added Ada and Jovial style comments</a>
<a name="15579"><span class="lineNum">   15579 </span>            :   // DQ (5/5/2010): infer comment type from target's language</a>
<a name="15580"><span class="lineNum">   15580 </span><span class="lineCov">          5 :      if (mytype == PreprocessingInfo::CpreprocessorUnknownDeclaration)</span></a>
<a name="15581"><span class="lineNum">   15581 </span>            :         {</a>
<a name="15582"><span class="lineNum">   15582 </span>            :        // This is a rather expensive way to detect the language type (chases pointers back to the SgFile object).</a>
<a name="15583"><span class="lineNum">   15583 </span><span class="lineCov">          5 :           if (is_C_language() || is_C99_language())</span></a>
<a name="15584"><span class="lineNum">   15584 </span>            :              {</a>
<a name="15585"><span class="lineNum">   15585 </span>            :              // Comment = &quot;/* &quot;+ content + &quot; */&quot;;</a>
<a name="15586"><span class="lineNum">   15586 </span>            :                 mytype = PreprocessingInfo::C_StyleComment;</a>
<a name="15587"><span class="lineNum">   15587 </span>            :              }</a>
<a name="15588"><span class="lineNum">   15588 </span><span class="lineCov">          5 :           else if (is_Cxx_language())</span></a>
<a name="15589"><span class="lineNum">   15589 </span>            :              {</a>
<a name="15590"><span class="lineNum">   15590 </span>            :              // Comment = &quot;// &quot;+ content;</a>
<a name="15591"><span class="lineNum">   15591 </span>            :                 mytype = PreprocessingInfo::CplusplusStyleComment;</a>
<a name="15592"><span class="lineNum">   15592 </span>            :              }</a>
<a name="15593"><span class="lineNum">   15593 </span><span class="lineNoCov">          0 :           else if (is_Fortran_language()) //FMZ:3/23/2009</span></a>
<a name="15594"><span class="lineNum">   15594 </span>            :              {</a>
<a name="15595"><span class="lineNum">   15595 </span>            :              // Comment = &quot;! &quot;+ content;</a>
<a name="15596"><span class="lineNum">   15596 </span>            :                 mytype = PreprocessingInfo::F90StyleComment;</a>
<a name="15597"><span class="lineNum">   15597 </span>            :              }</a>
<a name="15598"><span class="lineNum">   15598 </span>            :           else</a>
<a name="15599"><span class="lineNum">   15599 </span>            :              {</a>
<a name="15600"><span class="lineNum">   15600 </span><span class="lineNoCov">          0 :                cout &lt;&lt; &quot;WARNING: SageInterface::attachComment(): Unknown programming language \n&quot;;</span></a>
<a name="15601"><span class="lineNum">   15601 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15602"><span class="lineNum">   15602 </span>            :              }</a>
<a name="15603"><span class="lineNum">   15603 </span>            :         }</a>
<a name="15604"><span class="lineNum">   15604 </span>            : </a>
<a name="15605"><span class="lineNum">   15605 </span>            :   // Once the langauge type is set (discovered automatically or more directly specified by the user).</a>
<a name="15606"><span class="lineNum">   15606 </span><span class="lineCov">          5 :      bool resetPositionInfo = false;</span></a>
<a name="15607"><span class="lineNum">   15607 </span><span class="lineNoCov">          0 :      switch (mytype)</span></a>
<a name="15608"><span class="lineNum">   15608 </span>            :         {</a>
<a name="15609"><span class="lineNum">   15609 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::C_StyleComment:        comment = &quot;/* &quot; + content + &quot; */&quot;; break;</span></a>
<a name="15610"><span class="lineNum">   15610 </span><span class="lineCov">          5 :           case PreprocessingInfo::CplusplusStyleComment: comment = &quot;// &quot; + content;         break;</span></a>
<a name="15611"><span class="lineNum">   15611 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::FortranStyleComment:   comment = &quot;      C &quot; + content;    break;</span></a>
<a name="15612"><span class="lineNum">   15612 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::F90StyleComment:       comment = &quot;!&quot;   + content;         break;</span></a>
<a name="15613"><span class="lineNum">   15613 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorLineDeclaration:</span></a>
<a name="15614"><span class="lineNum">   15614 </span><span class="lineNoCov">          0 :                comment = &quot;#myline &quot; + content;</span></a>
<a name="15615"><span class="lineNum">   15615 </span><span class="lineNoCov">          0 :                mytype = PreprocessingInfo::CplusplusStyleComment;</span></a>
<a name="15616"><span class="lineNum">   15616 </span><span class="lineNoCov">          0 :                resetPositionInfo = true;</span></a>
<a name="15617"><span class="lineNum">   15617 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="15618"><span class="lineNum">   15618 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorIfndefDeclaration: comment = &quot;#ifndef &quot; + content + &quot;\n&quot;; break;</span></a>
<a name="15619"><span class="lineNum">   15619 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorDefineDeclaration: comment = &quot;#define &quot; + content + &quot;\n&quot;; break;</span></a>
<a name="15620"><span class="lineNum">   15620 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorEndifDeclaration:  comment = &quot;#endif&quot; + (content.empty() ? &quot;\n&quot; : (&quot; /* &quot; + content + &quot; */\n&quot;)); break;</span></a>
<a name="15621"><span class="lineNum">   15621 </span><span class="lineNoCov">          0 :           case PreprocessingInfo::CpreprocessorEnd_ifDeclaration:  comment = &quot;#end if&quot; + (content.empty() ? &quot;\n&quot; : (&quot; /* &quot; + content + &quot; */\n&quot;)); break;</span></a>
<a name="15622"><span class="lineNum">   15622 </span>            : </a>
<a name="15623"><span class="lineNum">   15623 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="15624"><span class="lineNum">   15624 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="15625"><span class="lineNum">   15625 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default in switch reached in SageInterface::attachComment() PreprocessingInfo::DirectiveType == %d \n&quot;,mytype);</span></a>
<a name="15626"><span class="lineNum">   15626 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="15627"><span class="lineNum">   15627 </span>            :              }</a>
<a name="15628"><span class="lineNum">   15628 </span>            :         }</a>
<a name="15629"><span class="lineNum">   15629 </span>            : </a>
<a name="15630"><span class="lineNum">   15630 </span><span class="lineCov">          5 :      result = new PreprocessingInfo (mytype,comment, &quot;transformation-generated&quot;, 0, 0, 0, position);</span></a>
<a name="15631"><span class="lineNum">   15631 </span>            : </a>
<a name="15632"><span class="lineNum">   15632 </span>            :   // If this is a Cpp Line declaration then we have to set the position to match the statement.</a>
<a name="15633"><span class="lineNum">   15633 </span>            :   // if (mytype == PreprocessingInfo::CpreprocessorLineDeclaration)</a>
<a name="15634"><span class="lineNum">   15634 </span><span class="lineCov">          5 :      if (resetPositionInfo == true)</span></a>
<a name="15635"><span class="lineNum">   15635 </span>            :         {</a>
<a name="15636"><span class="lineNum">   15636 </span>            :        // Call the Sg_File_Info::operator=() member function.</a>
<a name="15637"><span class="lineNum">   15637 </span><span class="lineNoCov">          0 :           *(result-&gt;get_file_info()) = *(target-&gt;get_file_info());</span></a>
<a name="15638"><span class="lineNum">   15638 </span>            :         }</a>
<a name="15639"><span class="lineNum">   15639 </span>            :        else</a>
<a name="15640"><span class="lineNum">   15640 </span>            :         {</a>
<a name="15641"><span class="lineNum">   15641 </span>            :        // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="15642"><span class="lineNum">   15642 </span>            :        // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="15643"><span class="lineNum">   15643 </span>            :        // when multiple files are used on the command line.</a>
<a name="15644"><span class="lineNum">   15644 </span><span class="lineCov">          5 :           result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15645"><span class="lineNum">   15645 </span>            :         }</a>
<a name="15646"><span class="lineNum">   15646 </span>            : </a>
<a name="15647"><span class="lineNum">   15647 </span><span class="lineCov">          5 :      ROSE_ASSERT(result);</span></a>
<a name="15648"><span class="lineNum">   15648 </span><span class="lineCov">          5 :      target-&gt;addToAttachedPreprocessingInfo(result);</span></a>
<a name="15649"><span class="lineNum">   15649 </span><span class="lineCov">         10 :      return result;</span></a>
<a name="15650"><span class="lineNum">   15650 </span>            :    }</a>
<a name="15651"><span class="lineNum">   15651 </span>            : </a>
<a name="15652"><span class="lineNum">   15652 </span><span class="lineNoCov">          0 : void SageInterface::guardNode(SgLocatedNode * target, std::string guard) {</span></a>
<a name="15653"><span class="lineNum">   15653 </span><span class="lineNoCov">          0 :   PreprocessingInfo * if_macro = new PreprocessingInfo(</span></a>
<a name="15654"><span class="lineNum">   15654 </span>            :     PreprocessingInfo::CpreprocessorIfDeclaration,</a>
<a name="15655"><span class="lineNum">   15655 </span><span class="lineNoCov">          0 :     &quot;#if &quot; + guard,</span></a>
<a name="15656"><span class="lineNum">   15656 </span>            :     &quot;transformation-generated&quot;, 0, 0, 0,</a>
<a name="15657"><span class="lineNum">   15657 </span>            :     PreprocessingInfo::before</a>
<a name="15658"><span class="lineNum">   15658 </span><span class="lineNoCov">          0 :   );</span></a>
<a name="15659"><span class="lineNum">   15659 </span><span class="lineNoCov">          0 :   target-&gt;addToAttachedPreprocessingInfo(if_macro);</span></a>
<a name="15660"><span class="lineNum">   15660 </span>            : </a>
<a name="15661"><span class="lineNum">   15661 </span><span class="lineNoCov">          0 :   PreprocessingInfo * endif_macro = new PreprocessingInfo(</span></a>
<a name="15662"><span class="lineNum">   15662 </span>            :     PreprocessingInfo::CpreprocessorEndifDeclaration,</a>
<a name="15663"><span class="lineNum">   15663 </span>            :     &quot;#endif&quot;,</a>
<a name="15664"><span class="lineNum">   15664 </span>            :     &quot;transformation-generated&quot;, 0, 0, 0,</a>
<a name="15665"><span class="lineNum">   15665 </span>            :     PreprocessingInfo::after</a>
<a name="15666"><span class="lineNum">   15666 </span><span class="lineNoCov">          0 :   );</span></a>
<a name="15667"><span class="lineNum">   15667 </span><span class="lineNoCov">          0 :   target-&gt;addToAttachedPreprocessingInfo(endif_macro);</span></a>
<a name="15668"><span class="lineNum">   15668 </span>            : </a>
<a name="15669"><span class="lineNum">   15669 </span>            : // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="15670"><span class="lineNum">   15670 </span>            : // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="15671"><span class="lineNum">   15671 </span>            : // when multiple files are used on the command line.</a>
<a name="15672"><span class="lineNum">   15672 </span><span class="lineNoCov">          0 :   if_macro-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15673"><span class="lineNum">   15673 </span><span class="lineNoCov">          0 :   endif_macro-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15674"><span class="lineNum">   15674 </span><span class="lineNoCov">          0 : }</span></a>
<a name="15675"><span class="lineNum">   15675 </span>            : </a>
<a name="15676"><span class="lineNum">   15676 </span>            : // internal hash table to cache the results: fileHeaderDict[file][header-key]</a>
<a name="15677"><span class="lineNum">   15677 </span>            : // header-key:</a>
<a name="15678"><span class="lineNum">   15678 </span>            : //    system header : &lt;header.h&gt;</a>
<a name="15679"><span class="lineNum">   15679 </span>            : //    non-system headers : &quot;header.h&quot;</a>
<a name="15680"><span class="lineNum">   15680 </span>            : static map&lt;SgSourceFile*, map&lt;string, PreprocessingInfo*&gt; &gt; fileHeaderDict;</a>
<a name="15681"><span class="lineNum">   15681 </span>            : //! Find the preprocessingInfo node representing #include &lt;header.h&gt; or #include &quot;header.h&quot; within a source file. Return NULL if not found.</a>
<a name="15682"><span class="lineNum">   15682 </span><span class="lineNoCov">          0 : PreprocessingInfo * SageInterface::findHeader(SgSourceFile * source_file, const std::string &amp; header_file_name, bool isSystemHeader)</span></a>
<a name="15683"><span class="lineNum">   15683 </span>            : {</a>
<a name="15684"><span class="lineNum">   15684 </span><span class="lineNoCov">          0 :   string header_key;</span></a>
<a name="15685"><span class="lineNum">   15685 </span><span class="lineNoCov">          0 :   if (isSystemHeader)</span></a>
<a name="15686"><span class="lineNum">   15686 </span><span class="lineNoCov">          0 :     header_key=&quot;&lt;&quot;+header_file_name+&quot;&gt;&quot;;</span></a>
<a name="15687"><span class="lineNum">   15687 </span>            :   else</a>
<a name="15688"><span class="lineNum">   15688 </span><span class="lineNoCov">          0 :     header_key=&quot;\&quot;&quot;+header_file_name+&quot;\&quot;&quot;;</span></a>
<a name="15689"><span class="lineNum">   15689 </span>            : </a>
<a name="15690"><span class="lineNum">   15690 </span><span class="lineNoCov">          0 :   if (fileHeaderDict.count(source_file) &amp;&amp; fileHeaderDict[source_file].count(header_key))</span></a>
<a name="15691"><span class="lineNum">   15691 </span><span class="lineNoCov">          0 :     return fileHeaderDict[source_file][header_key];</span></a>
<a name="15692"><span class="lineNum">   15692 </span>            : </a>
<a name="15693"><span class="lineNum">   15693 </span><span class="lineNoCov">          0 :   vector&lt;SgLocatedNode*&gt; candidates;</span></a>
<a name="15694"><span class="lineNum">   15694 </span>            :   // do a fresh check. we only check global scope's declarations since we insert header into global scope</a>
<a name="15695"><span class="lineNum">   15695 </span>            :   // check SgGlobal</a>
<a name="15696"><span class="lineNum">   15696 </span><span class="lineNoCov">          0 :   SgGlobal* global= source_file -&gt; get_globalScope();</span></a>
<a name="15697"><span class="lineNum">   15697 </span>            : </a>
<a name="15698"><span class="lineNum">   15698 </span><span class="lineNoCov">          0 :   candidates.push_back(global);</span></a>
<a name="15699"><span class="lineNum">   15699 </span>            : </a>
<a name="15700"><span class="lineNum">   15700 </span>            :   //check declarations within the global scope</a>
<a name="15701"><span class="lineNum">   15701 </span><span class="lineNoCov">          0 :   SgDeclarationStatementPtrList decl_stmt_list = global-&gt;get_declarations();</span></a>
<a name="15702"><span class="lineNum">   15702 </span><span class="lineNoCov">          0 :   for (SgDeclarationStatementPtrList::iterator iter= decl_stmt_list.begin(); iter!=decl_stmt_list.end(); iter++)</span></a>
<a name="15703"><span class="lineNum">   15703 </span><span class="lineNoCov">          0 :     candidates.push_back(*iter);</span></a>
<a name="15704"><span class="lineNum">   15704 </span>            : </a>
<a name="15705"><span class="lineNum">   15705 </span>            :   bool found = false;</a>
<a name="15706"><span class="lineNum">   15706 </span><span class="lineNoCov">          0 :   for (size_t ci=0; ci&lt;candidates.size(); ci++)</span></a>
<a name="15707"><span class="lineNum">   15707 </span>            :   {</a>
<a name="15708"><span class="lineNum">   15708 </span><span class="lineNoCov">          0 :     SgLocatedNode* locatedNode= candidates[ci];</span></a>
<a name="15709"><span class="lineNum">   15709 </span><span class="lineNoCov">          0 :     AttachedPreprocessingInfoType *comments = locatedNode-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="15710"><span class="lineNum">   15710 </span>            : </a>
<a name="15711"><span class="lineNum">   15711 </span><span class="lineNoCov">          0 :     if (comments == NULL) continue;</span></a>
<a name="15712"><span class="lineNum">   15712 </span><span class="lineNoCov">          0 :     AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="15713"><span class="lineNum">   15713 </span><span class="lineNoCov">          0 :     for (i = comments-&gt;begin (); i != comments-&gt;end (); i++)</span></a>
<a name="15714"><span class="lineNum">   15714 </span>            :     {</a>
<a name="15715"><span class="lineNum">   15715 </span><span class="lineNoCov">          0 :       if ((*i)-&gt;getTypeOfDirective () != PreprocessingInfo::CpreprocessorIncludeDeclaration) continue;</span></a>
<a name="15716"><span class="lineNum">   15716 </span><span class="lineNoCov">          0 :       string content = (*i)-&gt;getString ();</span></a>
<a name="15717"><span class="lineNum">   15717 </span><span class="lineNoCov">          0 :       if (content.find(header_key) != string::npos)</span></a>
<a name="15718"><span class="lineNum">   15718 </span>            :       {</a>
<a name="15719"><span class="lineNum">   15719 </span><span class="lineNoCov">          0 :         fileHeaderDict[source_file][header_key] = *i;</span></a>
<a name="15720"><span class="lineNum">   15720 </span><span class="lineNoCov">          0 :         found =true;</span></a>
<a name="15721"><span class="lineNum">   15721 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="15722"><span class="lineNum">   15722 </span>            :       }</a>
<a name="15723"><span class="lineNum">   15723 </span>            : </a>
<a name="15724"><span class="lineNum">   15724 </span>            :     } // each comment</a>
<a name="15725"><span class="lineNum">   15725 </span>            : </a>
<a name="15726"><span class="lineNum">   15726 </span><span class="lineNoCov">          0 :     if (found) break;</span></a>
<a name="15727"><span class="lineNum">   15727 </span>            :   } // each node</a>
<a name="15728"><span class="lineNum">   15728 </span>            : </a>
<a name="15729"><span class="lineNum">   15729 </span><span class="lineNoCov">          0 :   if (found)</span></a>
<a name="15730"><span class="lineNum">   15730 </span><span class="lineNoCov">          0 :     return fileHeaderDict[source_file][header_key];</span></a>
<a name="15731"><span class="lineNum">   15731 </span>            :   return NULL;</a>
<a name="15732"><span class="lineNum">   15732 </span>            : }</a>
<a name="15733"><span class="lineNum">   15733 </span>            : </a>
<a name="15734"><span class="lineNum">   15734 </span>            : PreprocessingInfo*</a>
<a name="15735"><span class="lineNum">   15735 </span><span class="lineCov">          1 : SageInterface::insertHeader(SgSourceFile * source_file, const string &amp; header_file_name, bool isSystemHeader, PreprocessingInfo::RelativePositionType position)</span></a>
<a name="15736"><span class="lineNum">   15736 </span>            :    {</a>
<a name="15737"><span class="lineNum">   15737 </span>            :   // DQ (3/22/2019): If we are using the token based unparsing, then this will not work, since the global scope will not</a>
<a name="15738"><span class="lineNum">   15738 </span>            :   // be marked as a transformation.  So it might be better to implement this with an option to support the token based</a>
<a name="15739"><span class="lineNum">   15739 </span>            :   // unparsing, and specifically add a null declaration so that we can attach the #include directive directly to that statement.</a>
<a name="15740"><span class="lineNum">   15740 </span><span class="lineCov">          1 :      bool supportTokenUnparsing = false;</span></a>
<a name="15741"><span class="lineNum">   15741 </span>            : </a>
<a name="15742"><span class="lineNum">   15742 </span><span class="lineCov">          1 :      assert(source_file != NULL);</span></a>
<a name="15743"><span class="lineNum">   15743 </span><span class="lineCov">          1 :      assert(position == PreprocessingInfo::before || position ==  PreprocessingInfo::after);</span></a>
<a name="15744"><span class="lineNum">   15744 </span>            : </a>
<a name="15745"><span class="lineNum">   15745 </span><span class="lineCov">          1 :      SgGlobal * global_scope = source_file-&gt;get_globalScope();</span></a>
<a name="15746"><span class="lineNum">   15746 </span>            : </a>
<a name="15747"><span class="lineNum">   15747 </span><span class="lineCov">          1 :      string content;</span></a>
<a name="15748"><span class="lineNum">   15748 </span><span class="lineCov">          1 :      if (isSystemHeader)</span></a>
<a name="15749"><span class="lineNum">   15749 </span><span class="lineCov">          1 :         content = &quot;#include &lt;&quot; + header_file_name + &quot;&gt; \n&quot;;</span></a>
<a name="15750"><span class="lineNum">   15750 </span>            :      else</a>
<a name="15751"><span class="lineNum">   15751 </span><span class="lineNoCov">          0 :         content = &quot;#include \&quot;&quot; + header_file_name + &quot;\&quot; \n&quot;;</span></a>
<a name="15752"><span class="lineNum">   15752 </span>            : </a>
<a name="15753"><span class="lineNum">   15753 </span><span class="lineCov">          1 :      PreprocessingInfo* result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration, content, &quot;Transformation generated&quot;,0, 0, 0, position);</span></a>
<a name="15754"><span class="lineNum">   15754 </span><span class="lineCov">          1 :      ROSE_ASSERT(result);</span></a>
<a name="15755"><span class="lineNum">   15755 </span>            : </a>
<a name="15756"><span class="lineNum">   15756 </span>            :   // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="15757"><span class="lineNum">   15757 </span>            :   // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="15758"><span class="lineNum">   15758 </span>            :   // when multiple files are used on the command line.</a>
<a name="15759"><span class="lineNum">   15759 </span><span class="lineCov">          1 :      result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15760"><span class="lineNum">   15760 </span>            : </a>
<a name="15761"><span class="lineNum">   15761 </span>            :   // DQ (11/21/2019): Need to set supportTokenUnparsing.</a>
<a name="15762"><span class="lineNum">   15762 </span><span class="lineCov">          1 :      supportTokenUnparsing = source_file-&gt;get_unparse_tokens();</span></a>
<a name="15763"><span class="lineNum">   15763 </span><span class="lineCov">          1 :      bool supportUnparseHeaders = source_file-&gt;get_unparseHeaderFiles();</span></a>
<a name="15764"><span class="lineNum">   15764 </span>            : </a>
<a name="15765"><span class="lineNum">   15765 </span>            : #if 0</a>
<a name="15766"><span class="lineNum">   15766 </span>            :      printf (&quot;supportTokenUnparsing = %s \n&quot;,supportTokenUnparsing ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15767"><span class="lineNum">   15767 </span>            :      printf (&quot;supportUnparseHeaders = %s \n&quot;,supportUnparseHeaders ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15768"><span class="lineNum">   15768 </span>            :      printf (&quot;source_file           = %p \n&quot;,source_file);</a>
<a name="15769"><span class="lineNum">   15769 </span>            :      printf (&quot;global_scope          = %p \n&quot;,global_scope);</a>
<a name="15770"><span class="lineNum">   15770 </span>            : #endif</a>
<a name="15771"><span class="lineNum">   15771 </span>            : #if 0</a>
<a name="15772"><span class="lineNum">   15772 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15773"><span class="lineNum">   15773 </span>            :      ROSE_ABORT();</a>
<a name="15774"><span class="lineNum">   15774 </span>            : #endif</a>
<a name="15775"><span class="lineNum">   15775 </span>            : </a>
<a name="15776"><span class="lineNum">   15776 </span>            :   // global_scope-&gt;addToAttachedPreprocessingInfo(result, position);</a>
<a name="15777"><span class="lineNum">   15777 </span><span class="lineCov">          1 :      if (supportTokenUnparsing == false)</span></a>
<a name="15778"><span class="lineNum">   15778 </span>            :         {</a>
<a name="15779"><span class="lineNum">   15779 </span><span class="lineCov">          1 :           global_scope-&gt;addToAttachedPreprocessingInfo(result, position);</span></a>
<a name="15780"><span class="lineNum">   15780 </span>            :         }</a>
<a name="15781"><span class="lineNum">   15781 </span>            :        else</a>
<a name="15782"><span class="lineNum">   15782 </span>            :         {</a>
<a name="15783"><span class="lineNum">   15783 </span>            :        // global_scope-&gt;prepend_statement(null_statement);</a>
<a name="15784"><span class="lineNum">   15784 </span><span class="lineNoCov">          0 :           SgEmptyDeclaration* emptyDeclaration = buildEmptyDeclaration();</span></a>
<a name="15785"><span class="lineNum">   15785 </span>            : </a>
<a name="15786"><span class="lineNum">   15786 </span><span class="lineNoCov">          0 :           if (supportUnparseHeaders == true)</span></a>
<a name="15787"><span class="lineNum">   15787 </span>            :               {</a>
<a name="15788"><span class="lineNum">   15788 </span>            :              // In this case we need to set the physical_file_id to match the target file to be unparsed.</a>
<a name="15789"><span class="lineNum">   15789 </span><span class="lineNoCov">          0 :                 int physical_file_id = global_scope-&gt;get_startOfConstruct()-&gt;get_physical_file_id();</span></a>
<a name="15790"><span class="lineNum">   15790 </span>            : #if 0</a>
<a name="15791"><span class="lineNum">   15791 </span>            :                 printf (&quot;physical_file_id = %d \n&quot;,physical_file_id);</a>
<a name="15792"><span class="lineNum">   15792 </span>            : #endif</a>
<a name="15793"><span class="lineNum">   15793 </span><span class="lineNoCov">          0 :                 emptyDeclaration-&gt;get_startOfConstruct()-&gt;set_physical_file_id(physical_file_id);</span></a>
<a name="15794"><span class="lineNum">   15794 </span><span class="lineNoCov">          0 :                 emptyDeclaration-&gt;get_endOfConstruct()-&gt;set_physical_file_id(physical_file_id);</span></a>
<a name="15795"><span class="lineNum">   15795 </span>            : #if 0</a>
<a name="15796"><span class="lineNum">   15796 </span>            :                 printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15797"><span class="lineNum">   15797 </span>            :                 ROSE_ABORT();</a>
<a name="15798"><span class="lineNum">   15798 </span>            : #endif</a>
<a name="15799"><span class="lineNum">   15799 </span>            :               }</a>
<a name="15800"><span class="lineNum">   15800 </span>            : </a>
<a name="15801"><span class="lineNum">   15801 </span><span class="lineNoCov">          0 :           emptyDeclaration-&gt;addToAttachedPreprocessingInfo(result, position);</span></a>
<a name="15802"><span class="lineNum">   15802 </span>            : </a>
<a name="15803"><span class="lineNum">   15803 </span><span class="lineNoCov">          0 :           global_scope-&gt;prepend_statement(emptyDeclaration);</span></a>
<a name="15804"><span class="lineNum">   15804 </span>            :         }</a>
<a name="15805"><span class="lineNum">   15805 </span>            : </a>
<a name="15806"><span class="lineNum">   15806 </span>            : #if 0</a>
<a name="15807"><span class="lineNum">   15807 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15808"><span class="lineNum">   15808 </span>            :      ROSE_ASSERT(false);</a>
<a name="15809"><span class="lineNum">   15809 </span>            : #endif</a>
<a name="15810"><span class="lineNum">   15810 </span>            : </a>
<a name="15811"><span class="lineNum">   15811 </span><span class="lineCov">          2 :      return result;</span></a>
<a name="15812"><span class="lineNum">   15812 </span>            :    }</a>
<a name="15813"><span class="lineNum">   15813 </span>            : </a>
<a name="15814"><span class="lineNum">   15814 </span><span class="lineCov">          2 : PreprocessingInfo* SageInterface::insertHeader(const string&amp; filename, PreprocessingInfo::RelativePositionType position /*=after*/, bool isSystemHeader /*=false*/, SgScopeStatement* scope /*=NULL*/)</span></a>
<a name="15815"><span class="lineNum">   15815 </span>            :    {</a>
<a name="15816"><span class="lineNum">   15816 </span>            :   // DQ (3/22/2019): If we are using the token based unparsing, then this will not work, since the global scope will not</a>
<a name="15817"><span class="lineNum">   15817 </span>            :   // be marked as a transformation.  So it might be better to implement this with an option to support the token based</a>
<a name="15818"><span class="lineNum">   15818 </span>            :   // unparsing, and specifically add a null declaration so that we can attach the #include directive directly to that statement.</a>
<a name="15819"><span class="lineNum">   15819 </span><span class="lineCov">          2 :      bool supportTokenUnparsing = false;</span></a>
<a name="15820"><span class="lineNum">   15820 </span>            : </a>
<a name="15821"><span class="lineNum">   15821 </span>            :  // DQ (8/12/2020): This is a compiler warning.</a>
<a name="15822"><span class="lineNum">   15822 </span>            :  // bool successful = false;</a>
<a name="15823"><span class="lineNum">   15823 </span>            : </a>
<a name="15824"><span class="lineNum">   15824 </span>            : #if 0</a>
<a name="15825"><span class="lineNum">   15825 </span>            :      printf (&quot;In SageInterface::insertHeader(): filename = %s \n&quot;,filename.c_str());</a>
<a name="15826"><span class="lineNum">   15826 </span>            :      printf (&quot; --- position = %s \n&quot;,PreprocessingInfo::relativePositionName(position).c_str());</a>
<a name="15827"><span class="lineNum">   15827 </span>            : #endif</a>
<a name="15828"><span class="lineNum">   15828 </span>            : </a>
<a name="15829"><span class="lineNum">   15829 </span><span class="lineCov">          2 :      if (scope == NULL)</span></a>
<a name="15830"><span class="lineNum">   15830 </span><span class="lineNoCov">          0 :           scope = SageBuilder::topScopeStack();</span></a>
<a name="15831"><span class="lineNum">   15831 </span>            : </a>
<a name="15832"><span class="lineNum">   15832 </span><span class="lineCov">          2 :      ROSE_ASSERT(scope);</span></a>
<a name="15833"><span class="lineNum">   15833 </span>            : </a>
<a name="15834"><span class="lineNum">   15834 </span><span class="lineCov">          2 :      SgGlobal* globalScope = getGlobalScope(scope);</span></a>
<a name="15835"><span class="lineNum">   15835 </span><span class="lineCov">          2 :      ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="15836"><span class="lineNum">   15836 </span>            : </a>
<a name="15837"><span class="lineNum">   15837 </span>            :   // To support inserting a header file into a header file, we need this srcScope to indicate the src file in which to insert the header</a>
<a name="15838"><span class="lineNum">   15838 </span>            :   // if the input scope is within a header file,</a>
<a name="15839"><span class="lineNum">   15839 </span>            :   // its global scope will jump to a .cpp file. Later looping will not find a match.</a>
<a name="15840"><span class="lineNum">   15840 </span><span class="lineCov">          2 :      SgScopeStatement* srcScope = globalScope;</span></a>
<a name="15841"><span class="lineNum">   15841 </span><span class="lineCov">          2 :      PreprocessingInfo* result=NULL;</span></a>
<a name="15842"><span class="lineNum">   15842 </span><span class="lineCov">          2 :      string content;</span></a>
<a name="15843"><span class="lineNum">   15843 </span><span class="lineCov">          2 :      if (isSystemHeader)</span></a>
<a name="15844"><span class="lineNum">   15844 </span><span class="lineCov">          1 :           content = &quot;#include &lt;&quot; + filename + &quot;&gt; \n&quot;;</span></a>
<a name="15845"><span class="lineNum">   15845 </span>            :        else</a>
<a name="15846"><span class="lineNum">   15846 </span><span class="lineCov">          1 :           content = &quot;#include \&quot;&quot; + filename + &quot;\&quot; \n&quot;;</span></a>
<a name="15847"><span class="lineNum">   15847 </span>            : </a>
<a name="15848"><span class="lineNum">   15848 </span>            :   // DQ (11/21/2019): Token based unparsing has an additional requirement, we need to mark that the</a>
<a name="15849"><span class="lineNum">   15849 </span>            :   // whitespace around the statement has been modified.  This will trigger the unparser to output</a>
<a name="15850"><span class="lineNum">   15850 </span>            :   // the comments and CPP directives when using the token-based unparsing. The insertion of a header</a>
<a name="15851"><span class="lineNum">   15851 </span>            :   // file requires this support else the original token stream will not have the added header file.</a>
<a name="15852"><span class="lineNum">   15852 </span>            : </a>
<a name="15853"><span class="lineNum">   15853 </span>            :   // DQ (11/21/2019): Need to set supportTokenUnparsing.</a>
<a name="15854"><span class="lineNum">   15854 </span><span class="lineCov">          2 :      SgSourceFile* sourceFile = getEnclosingSourceFile(scope);</span></a>
<a name="15855"><span class="lineNum">   15855 </span><span class="lineCov">          2 :      ROSE_ASSERT(sourceFile != NULL);</span></a>
<a name="15856"><span class="lineNum">   15856 </span>            : </a>
<a name="15857"><span class="lineNum">   15857 </span><span class="lineCov">          2 :      supportTokenUnparsing      = sourceFile-&gt;get_unparse_tokens();</span></a>
<a name="15858"><span class="lineNum">   15858 </span>            : </a>
<a name="15859"><span class="lineNum">   15859 </span><span class="lineCov">          2 :      bool supportUnparseHeaders = sourceFile-&gt;get_unparseHeaderFiles();</span></a>
<a name="15860"><span class="lineNum">   15860 </span>            :      // if unparsing header and the scope is within a header file, we adjust srcScope to be scope, not its enclosing global scope</a>
<a name="15861"><span class="lineNum">   15861 </span><span class="lineCov">          2 :      if (supportUnparseHeaders)</span></a>
<a name="15862"><span class="lineNum">   15862 </span>            :         {</a>
<a name="15863"><span class="lineNum">   15863 </span><span class="lineNoCov">          0 :           string filename= scope-&gt;get_file_info()-&gt;get_filename();</span></a>
<a name="15864"><span class="lineNum">   15864 </span><span class="lineNoCov">          0 :           string suffix = Rose::StringUtility ::fileNameSuffix(filename);</span></a>
<a name="15865"><span class="lineNum">   15865 </span>            : </a>
<a name="15866"><span class="lineNum">   15866 </span>            :        // vector.tcc: This is an internal header file, included by other library headers</a>
<a name="15867"><span class="lineNum">   15867 </span><span class="lineNoCov">          0 :           if (suffix==&quot;h&quot; ||suffix==&quot;hpp&quot;|| suffix==&quot;hh&quot;||suffix==&quot;H&quot; ||suffix==&quot;hxx&quot;||suffix==&quot;h++&quot; ||suffix==&quot;tcc&quot;)</span></a>
<a name="15868"><span class="lineNum">   15868 </span>            :                srcScope = scope;</a>
<a name="15869"><span class="lineNum">   15869 </span>            :         }</a>
<a name="15870"><span class="lineNum">   15870 </span>            : </a>
<a name="15871"><span class="lineNum">   15871 </span>            : #if 0</a>
<a name="15872"><span class="lineNum">   15872 </span>            :      printf (&quot;supportTokenUnparsing = %s \n&quot;,supportTokenUnparsing ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15873"><span class="lineNum">   15873 </span>            :      printf (&quot;supportUnparseHeaders = %s \n&quot;,supportUnparseHeaders ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15874"><span class="lineNum">   15874 </span>            :      printf (&quot;sourceFile  = %p \n&quot;,sourceFile);</a>
<a name="15875"><span class="lineNum">   15875 </span>            :      printf (&quot;globalScope = %p \n&quot;,globalScope);</a>
<a name="15876"><span class="lineNum">   15876 </span>            : #endif</a>
<a name="15877"><span class="lineNum">   15877 </span>            : #if 0</a>
<a name="15878"><span class="lineNum">   15878 </span>            :      printf (&quot;supportTokenUnparsing = %s \n&quot;,supportTokenUnparsing ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15879"><span class="lineNum">   15879 </span>            : #endif</a>
<a name="15880"><span class="lineNum">   15880 </span>            : #if 0</a>
<a name="15881"><span class="lineNum">   15881 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15882"><span class="lineNum">   15882 </span>            :      ROSE_ABORT();</a>
<a name="15883"><span class="lineNum">   15883 </span>            : #endif</a>
<a name="15884"><span class="lineNum">   15884 </span>            : </a>
<a name="15885"><span class="lineNum">   15885 </span><span class="lineCov">          2 :      SgDeclarationStatementPtrList &amp; stmtList = globalScope-&gt;get_declarations();</span></a>
<a name="15886"><span class="lineNum">   15886 </span>            : </a>
<a name="15887"><span class="lineNum">   15887 </span>            : #if 0</a>
<a name="15888"><span class="lineNum">   15888 </span>            :      printf (&quot;stmtList.size() = %zu \n&quot;,stmtList.size());</a>
<a name="15889"><span class="lineNum">   15889 </span>            : #endif</a>
<a name="15890"><span class="lineNum">   15890 </span>            : </a>
<a name="15891"><span class="lineNum">   15891 </span><span class="lineCov">          2 :      if (stmtList.size() &gt; 0) // the source file is not empty</span></a>
<a name="15892"><span class="lineNum">   15892 </span>            :         {</a>
<a name="15893"><span class="lineNum">   15893 </span><span class="lineCov">       7128 :           for (SgDeclarationStatementPtrList::iterator j = stmtList.begin (); j != stmtList.end (); j++)</span></a>
<a name="15894"><span class="lineNum">   15894 </span>            :              {</a>
<a name="15895"><span class="lineNum">   15895 </span>            :             // must have this judgement, otherwise wrong file will be modified!</a>
<a name="15896"><span class="lineNum">   15896 </span>            :             // It could also be the transformation generated statements with #include attached</a>
<a name="15897"><span class="lineNum">   15897 </span><span class="lineCov">       7128 :                if ( ((*j)-&gt;get_file_info())-&gt;isSameFile(srcScope-&gt;get_file_info ()) || ((*j)-&gt;get_file_info ())-&gt;isTransformation() )</span></a>
<a name="15898"><span class="lineNum">   15898 </span>            :                   {</a>
<a name="15899"><span class="lineNum">   15899 </span><span class="lineCov">          2 :                     result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration, content, &quot;Transformation generated&quot;,0, 0, 0, PreprocessingInfo::before);</span></a>
<a name="15900"><span class="lineNum">   15900 </span><span class="lineCov">          2 :                     ROSE_ASSERT(result != NULL);</span></a>
<a name="15901"><span class="lineNum">   15901 </span>            : #if 0</a>
<a name="15902"><span class="lineNum">   15902 </span>            :                     printf (&quot;Building a PreprocessingInfo: result = %p \n&quot;,result);</a>
<a name="15903"><span class="lineNum">   15903 </span>            : #endif</a>
<a name="15904"><span class="lineNum">   15904 </span>            :                  // DQ (3/22/2019): Fixing this to work with the token-based unparsing.</a>
<a name="15905"><span class="lineNum">   15905 </span>            :                  // add to the last position</a>
<a name="15906"><span class="lineNum">   15906 </span>            :                  // TODO: support to add to the first,</a>
<a name="15907"><span class="lineNum">   15907 </span>            :                  // TODO: support fine positioning with #include directives</a>
<a name="15908"><span class="lineNum">   15908 </span>            :                  // (*j)-&gt;addToAttachedPreprocessingInfo(result,position);</a>
<a name="15909"><span class="lineNum">   15909 </span>            : </a>
<a name="15910"><span class="lineNum">   15910 </span><span class="lineCov">          2 :                     if (supportTokenUnparsing == false)</span></a>
<a name="15911"><span class="lineNum">   15911 </span>            :                        {</a>
<a name="15912"><span class="lineNum">   15912 </span><span class="lineCov">          2 :                          (*j)-&gt;addToAttachedPreprocessingInfo(result,position);</span></a>
<a name="15913"><span class="lineNum">   15913 </span>            :                        }</a>
<a name="15914"><span class="lineNum">   15914 </span>            :                       else</a>
<a name="15915"><span class="lineNum">   15915 </span>            :                        {</a>
<a name="15916"><span class="lineNum">   15916 </span><span class="lineNoCov">          0 :                          (*j)-&gt;addToAttachedPreprocessingInfo(result,position);</span></a>
<a name="15917"><span class="lineNum">   15917 </span>            : #if 0</a>
<a name="15918"><span class="lineNum">   15918 </span>            :                          printf (&quot;In SageInterface::insertHeader(): Calling set_containsTransformationToSurroundingWhitespace(true) \n&quot;);</a>
<a name="15919"><span class="lineNum">   15919 </span>            : #endif</a>
<a name="15920"><span class="lineNum">   15920 </span>            : #if 1</a>
<a name="15921"><span class="lineNum">   15921 </span>            :                       // DQ (12/31/2020): Set the whitespace around the statement as being modified.</a>
<a name="15922"><span class="lineNum">   15922 </span><span class="lineNoCov">          0 :                          (*j)-&gt;set_containsTransformationToSurroundingWhitespace(true);</span></a>
<a name="15923"><span class="lineNum">   15923 </span>            : #endif</a>
<a name="15924"><span class="lineNum">   15924 </span>            : #if 0</a>
<a name="15925"><span class="lineNum">   15925 </span>            :                          SgDeclarationStatement* declarationStatement = *j;</a>
<a name="15926"><span class="lineNum">   15926 </span>            : </a>
<a name="15927"><span class="lineNum">   15927 </span>            :                       // DQ (1/5/2021): Don't call unparseToString, since this triggers the unparer which then unparses</a>
<a name="15928"><span class="lineNum">   15928 </span>            :                       // from the token stream and makrs some token stream elements as already unparsed.</a>
<a name="15929"><span class="lineNum">   15929 </span>            :                       // printf (&quot;declarationStatement = %p = %s unparseToString() = %s \n&quot;,declarationStatement,</a>
<a name="15930"><span class="lineNum">   15930 </span>            :                       //     declarationStatement-&gt;class_name().c_str(),declarationStatement-&gt;unparseToString().c_str());</a>
<a name="15931"><span class="lineNum">   15931 </span>            :                          printf (&quot;In SageInterface::insertHeader(): declarationStatement = %p = %s \n&quot;,declarationStatement,declarationStatement-&gt;class_name().c_str());</a>
<a name="15932"><span class="lineNum">   15932 </span>            :                          printf (&quot;In SageInterface::insertHeader(): declarationStatement-&gt;get_containsTransformationToSurroundingWhitespace() = %s \n&quot;,</a>
<a name="15933"><span class="lineNum">   15933 </span>            :                               declarationStatement-&gt;get_containsTransformationToSurroundingWhitespace() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="15934"><span class="lineNum">   15934 </span>            : #endif</a>
<a name="15935"><span class="lineNum">   15935 </span>            : #if 0</a>
<a name="15936"><span class="lineNum">   15936 </span>            :                       // Liao, let's try the new way.</a>
<a name="15937"><span class="lineNum">   15937 </span>            :                       // global_scope-&gt;prepend_statement(null_statement);</a>
<a name="15938"><span class="lineNum">   15938 </span>            :                          SgEmptyDeclaration* emptyDeclaration = buildEmptyDeclaration();</a>
<a name="15939"><span class="lineNum">   15939 </span>            : </a>
<a name="15940"><span class="lineNum">   15940 </span>            :                          if (supportUnparseHeaders == true)</a>
<a name="15941"><span class="lineNum">   15941 </span>            :                             {</a>
<a name="15942"><span class="lineNum">   15942 </span>            :                            // In this case we need to set the physical_file_id to match the target file to be unparsed.</a>
<a name="15943"><span class="lineNum">   15943 </span>            :                               int physical_file_id = globalScope-&gt;get_startOfConstruct()-&gt;get_physical_file_id();</a>
<a name="15944"><span class="lineNum">   15944 </span>            : #if 0</a>
<a name="15945"><span class="lineNum">   15945 </span>            :                               printf (&quot;physical_file_id = %d \n&quot;,physical_file_id);</a>
<a name="15946"><span class="lineNum">   15946 </span>            : #endif</a>
<a name="15947"><span class="lineNum">   15947 </span>            :                               emptyDeclaration-&gt;get_startOfConstruct()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="15948"><span class="lineNum">   15948 </span>            :                               emptyDeclaration-&gt;get_endOfConstruct()-&gt;set_physical_file_id(physical_file_id);</a>
<a name="15949"><span class="lineNum">   15949 </span>            : #if 0</a>
<a name="15950"><span class="lineNum">   15950 </span>            :                               printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15951"><span class="lineNum">   15951 </span>            :                               ROSE_ASSERT(false);</a>
<a name="15952"><span class="lineNum">   15952 </span>            : #endif</a>
<a name="15953"><span class="lineNum">   15953 </span>            :                             }</a>
<a name="15954"><span class="lineNum">   15954 </span>            : </a>
<a name="15955"><span class="lineNum">   15955 </span>            :                          emptyDeclaration-&gt;addToAttachedPreprocessingInfo(result, position);</a>
<a name="15956"><span class="lineNum">   15956 </span>            : </a>
<a name="15957"><span class="lineNum">   15957 </span>            :                          globalScope-&gt;insert_statement(*j,emptyDeclaration);</a>
<a name="15958"><span class="lineNum">   15958 </span>            : #endif</a>
<a name="15959"><span class="lineNum">   15959 </span>            :                        }</a>
<a name="15960"><span class="lineNum">   15960 </span>            : #if 0</a>
<a name="15961"><span class="lineNum">   15961 </span>            :                     printf (&quot;break out of for loop: result = %p \n&quot;,result);</a>
<a name="15962"><span class="lineNum">   15962 </span>            : #endif</a>
<a name="15963"><span class="lineNum">   15963 </span>            :                  // DQ (8/12/2020): This is a compiler warning.</a>
<a name="15964"><span class="lineNum">   15964 </span>            :                  // successful = true;</a>
<a name="15965"><span class="lineNum">   15965 </span>            :                     break;</a>
<a name="15966"><span class="lineNum">   15966 </span>            :                   }</a>
<a name="15967"><span class="lineNum">   15967 </span>            :              }</a>
<a name="15968"><span class="lineNum">   15968 </span>            :         }</a>
<a name="15969"><span class="lineNum">   15969 </span>            :        else // empty file, attach it after SgGlobal,TODO it is not working for unknown reason!!</a>
<a name="15970"><span class="lineNum">   15970 </span>            :         {</a>
<a name="15971"><span class="lineNum">   15971 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;SageInterface::insertHeader() Empty file is found!&quot;&lt;&lt;endl;</span></a>
<a name="15972"><span class="lineNum">   15972 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;#include xxx is  preprocessing information which has to be attached  to some other  located node (a statement for example)&quot;&lt;&lt;endl;</span></a>
<a name="15973"><span class="lineNum">   15973 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;You may have to insert some statement first before inserting a header&quot;&lt;&lt;endl;</span></a>
<a name="15974"><span class="lineNum">   15974 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(false);</span></a>
<a name="15975"><span class="lineNum">   15975 </span>            :           result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration, content, &quot;Transformation generated&quot;,0, 0, 0, PreprocessingInfo::after);</a>
<a name="15976"><span class="lineNum">   15976 </span>            :           ROSE_ASSERT(result);</a>
<a name="15977"><span class="lineNum">   15977 </span>            :           globalScope-&gt;addToAttachedPreprocessingInfo(result,position);</a>
<a name="15978"><span class="lineNum">   15978 </span>            : </a>
<a name="15979"><span class="lineNum">   15979 </span>            :        // DQ (8/12/2020): This is a compiler warning.</a>
<a name="15980"><span class="lineNum">   15980 </span>            :        // successful = true;</a>
<a name="15981"><span class="lineNum">   15981 </span>            :         }</a>
<a name="15982"><span class="lineNum">   15982 </span>            : </a>
<a name="15983"><span class="lineNum">   15983 </span>            :   // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="15984"><span class="lineNum">   15984 </span>            :   // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="15985"><span class="lineNum">   15985 </span>            :   // when multiple files are used on the command line.</a>
<a name="15986"><span class="lineNum">   15986 </span>            :   // DQ (3/12/2019): This can be NULL for the omp tests.</a>
<a name="15987"><span class="lineNum">   15987 </span><span class="lineCov">          2 :      if (result != NULL)</span></a>
<a name="15988"><span class="lineNum">   15988 </span>            :         {</a>
<a name="15989"><span class="lineNum">   15989 </span><span class="lineCov">          2 :           result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="15990"><span class="lineNum">   15990 </span>            :         }</a>
<a name="15991"><span class="lineNum">   15991 </span>            : </a>
<a name="15992"><span class="lineNum">   15992 </span>            :   // must be inserted once somehow</a>
<a name="15993"><span class="lineNum">   15993 </span>            :   // Liao 3/11/2015. We allow failed insertion sometimes, for example when translating an empty file for OpenMP, we don't need to insert any headers</a>
<a name="15994"><span class="lineNum">   15994 </span>            :   // The caller function should decide what to do if insertion is failed: ignore vs. assert failure.</a>
<a name="15995"><span class="lineNum">   15995 </span>            :   // ROSE_ASSERT(successful==true);</a>
<a name="15996"><span class="lineNum">   15996 </span>            : </a>
<a name="15997"><span class="lineNum">   15997 </span>            : #if 0</a>
<a name="15998"><span class="lineNum">   15998 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="15999"><span class="lineNum">   15999 </span>            :      ROSE_ASSERT(false);</a>
<a name="16000"><span class="lineNum">   16000 </span>            : #endif</a>
<a name="16001"><span class="lineNum">   16001 </span>            : </a>
<a name="16002"><span class="lineNum">   16002 </span>            : #if 0</a>
<a name="16003"><span class="lineNum">   16003 </span>            :      printf (&quot;Leaving SageInterface::insertHeader(): filename = %s \n&quot;,filename.c_str());</a>
<a name="16004"><span class="lineNum">   16004 </span>            : #endif</a>
<a name="16005"><span class="lineNum">   16005 </span>            : </a>
<a name="16006"><span class="lineNum">   16006 </span>            : #if 0</a>
<a name="16007"><span class="lineNum">   16007 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16008"><span class="lineNum">   16008 </span>            :      ROSE_ASSERT(false);</a>
<a name="16009"><span class="lineNum">   16009 </span>            : #endif</a>
<a name="16010"><span class="lineNum">   16010 </span>            : </a>
<a name="16011"><span class="lineNum">   16011 </span><span class="lineCov">          4 :      return result;</span></a>
<a name="16012"><span class="lineNum">   16012 </span>            :    }</a>
<a name="16013"><span class="lineNum">   16013 </span>            : </a>
<a name="16014"><span class="lineNum">   16014 </span>            : </a>
<a name="16015"><span class="lineNum">   16015 </span>            : // insert a new header right before stmt,  if there are existing headers attached to stmt, insert it as the last or first header as specified by asLastHeader</a>
<a name="16016"><span class="lineNum">   16016 </span><span class="lineCov">          2 : void SageInterface::insertHeader (SgStatement* stmt, PreprocessingInfo* newheader, bool asLastHeader)</span></a>
<a name="16017"><span class="lineNum">   16017 </span>            : {</a>
<a name="16018"><span class="lineNum">   16018 </span><span class="lineCov">          2 :   ROSE_ASSERT (stmt != NULL);</span></a>
<a name="16019"><span class="lineNum">   16019 </span><span class="lineCov">          2 :   ROSE_ASSERT (newheader != NULL);</span></a>
<a name="16020"><span class="lineNum">   16020 </span>            : </a>
<a name="16021"><span class="lineNum">   16021 </span>            : #if 0</a>
<a name="16022"><span class="lineNum">   16022 </span>            :   printf (&quot;In SageInterface::insertHeader (SgStatement* stmt, PreprocessingInfo* newheader, bool asLastHeader) \n&quot;);</a>
<a name="16023"><span class="lineNum">   16023 </span>            : #endif</a>
<a name="16024"><span class="lineNum">   16024 </span>            : </a>
<a name="16025"><span class="lineNum">   16025 </span><span class="lineCov">          2 :   PreprocessingInfo::RelativePositionType position ;</span></a>
<a name="16026"><span class="lineNum">   16026 </span>            : </a>
<a name="16027"><span class="lineNum">   16027 </span><span class="lineCov">          2 :   if (asLastHeader )</span></a>
<a name="16028"><span class="lineNum">   16028 </span>            :     position = PreprocessingInfo::after;</a>
<a name="16029"><span class="lineNum">   16029 </span>            :   else</a>
<a name="16030"><span class="lineNum">   16030 </span><span class="lineNoCov">          0 :     position = PreprocessingInfo::before;</span></a>
<a name="16031"><span class="lineNum">   16031 </span>            : </a>
<a name="16032"><span class="lineNum">   16032 </span>            : </a>
<a name="16033"><span class="lineNum">   16033 </span>            :   // Find existing first and last header.</a>
<a name="16034"><span class="lineNum">   16034 </span><span class="lineCov">          2 :   AttachedPreprocessingInfoType *comments = stmt-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="16035"><span class="lineNum">   16035 </span>            : </a>
<a name="16036"><span class="lineNum">   16036 </span><span class="lineCov">          2 :   if (comments != NULL)</span></a>
<a name="16037"><span class="lineNum">   16037 </span>            :   {</a>
<a name="16038"><span class="lineNum">   16038 </span><span class="lineCov">          1 :     PreprocessingInfo * firstExistingHeader = NULL;</span></a>
<a name="16039"><span class="lineNum">   16039 </span><span class="lineCov">          1 :     PreprocessingInfo * lastExistingHeader  = NULL;</span></a>
<a name="16040"><span class="lineNum">   16040 </span><span class="lineCov">          1 :     PreprocessingInfo * firstExistingEndif  = NULL;</span></a>
<a name="16041"><span class="lineNum">   16041 </span>            : </a>
<a name="16042"><span class="lineNum">   16042 </span>            :  // DQ (10/27/2020): Fixed warning of unused variable by compiler.</a>
<a name="16043"><span class="lineNum">   16043 </span>            :  // PreprocessingInfo * lastExistingEndif   = NULL;</a>
<a name="16044"><span class="lineNum">   16044 </span>            : </a>
<a name="16045"><span class="lineNum">   16045 </span><span class="lineCov">          1 :     AttachedPreprocessingInfoType::iterator i, firsti, lasti;</span></a>
<a name="16046"><span class="lineNum">   16046 </span><span class="lineCov">          7 :     for (i = comments-&gt;begin (); i != comments-&gt;end (); i++)</span></a>
<a name="16047"><span class="lineNum">   16047 </span>            :     {</a>
<a name="16048"><span class="lineNum">   16048 </span>            :    // DQ (9/12/2020): this original code is not sufficent since when the final #include is enclosed in a</a>
<a name="16049"><span class="lineNum">   16049 </span>            :    // #ifdef #endif the added include directive might not be visible in the generated file.</a>
<a name="16050"><span class="lineNum">   16050 </span>            :    // This actually happened in the case of wget application: wget.c source file.</a>
<a name="16051"><span class="lineNum">   16051 </span>            : #if 0</a>
<a name="16052"><span class="lineNum">   16052 </span>            :    // Original version of code.</a>
<a name="16053"><span class="lineNum">   16053 </span>            :       if ((*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorIncludeDeclaration)</a>
<a name="16054"><span class="lineNum">   16054 </span>            :          {</a>
<a name="16055"><span class="lineNum">   16055 </span>            :         // Only set first header for the first time</a>
<a name="16056"><span class="lineNum">   16056 </span>            :            if ((*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorIncludeDeclaration)</a>
<a name="16057"><span class="lineNum">   16057 </span>            :               {</a>
<a name="16058"><span class="lineNum">   16058 </span>            :                 if (firstExistingHeader == NULL)</a>
<a name="16059"><span class="lineNum">   16059 </span>            :                    {</a>
<a name="16060"><span class="lineNum">   16060 </span>            :                      firstExistingHeader = (*i);</a>
<a name="16061"><span class="lineNum">   16061 </span>            :                      firsti = i;</a>
<a name="16062"><span class="lineNum">   16062 </span>            :                    }</a>
<a name="16063"><span class="lineNum">   16063 </span>            :              // always updates last header</a>
<a name="16064"><span class="lineNum">   16064 </span>            :                 lastExistingHeader = (*i);</a>
<a name="16065"><span class="lineNum">   16065 </span>            :                 lasti = i;</a>
<a name="16066"><span class="lineNum">   16066 </span>            :              }</a>
<a name="16067"><span class="lineNum">   16067 </span>            :         }</a>
<a name="16068"><span class="lineNum">   16068 </span>            : #else</a>
<a name="16069"><span class="lineNum">   16069 </span>            :    // DQ (9/12/2020): New version of code. Addresses insertion after last endif if it is after any #include.</a>
<a name="16070"><span class="lineNum">   16070 </span><span class="lineCov">          9 :       if ( (*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorIncludeDeclaration ||</span></a>
<a name="16071"><span class="lineNum">   16071 </span><span class="lineCov">          3 :            (*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorEndifDeclaration )</span></a>
<a name="16072"><span class="lineNum">   16072 </span>            :       {</a>
<a name="16073"><span class="lineNum">   16073 </span>            :         // Only set first header for the first time</a>
<a name="16074"><span class="lineNum">   16074 </span><span class="lineCov">          3 :         if ((*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorIncludeDeclaration)</span></a>
<a name="16075"><span class="lineNum">   16075 </span>            :            {</a>
<a name="16076"><span class="lineNum">   16076 </span><span class="lineCov">          3 :              if (firstExistingHeader == NULL)</span></a>
<a name="16077"><span class="lineNum">   16077 </span>            :              {</a>
<a name="16078"><span class="lineNum">   16078 </span><span class="lineCov">          1 :                firstExistingHeader = (*i);</span></a>
<a name="16079"><span class="lineNum">   16079 </span><span class="lineCov">          1 :                firsti = i;</span></a>
<a name="16080"><span class="lineNum">   16080 </span>            :              }</a>
<a name="16081"><span class="lineNum">   16081 </span>            :            // always updates last header</a>
<a name="16082"><span class="lineNum">   16082 </span><span class="lineCov">          3 :              lastExistingHeader = (*i);</span></a>
<a name="16083"><span class="lineNum">   16083 </span><span class="lineCov">          3 :              lasti = i;</span></a>
<a name="16084"><span class="lineNum">   16084 </span>            :            }</a>
<a name="16085"><span class="lineNum">   16085 </span><span class="lineCov">          3 :         if ((*i)-&gt;getTypeOfDirective () == PreprocessingInfo::CpreprocessorEndifDeclaration)</span></a>
<a name="16086"><span class="lineNum">   16086 </span>            :            {</a>
<a name="16087"><span class="lineNum">   16087 </span><span class="lineNoCov">          0 :              if (firstExistingEndif == NULL)</span></a>
<a name="16088"><span class="lineNum">   16088 </span>            :              {</a>
<a name="16089"><span class="lineNum">   16089 </span><span class="lineNoCov">          0 :                firstExistingEndif = (*i);</span></a>
<a name="16090"><span class="lineNum">   16090 </span><span class="lineNoCov">          0 :                firsti = i;</span></a>
<a name="16091"><span class="lineNum">   16091 </span>            :              }</a>
<a name="16092"><span class="lineNum">   16092 </span>            :           // always updates last header</a>
<a name="16093"><span class="lineNum">   16093 </span>            :           // DQ (10/27/2020): Fixed warning of unused variable by compiler.</a>
<a name="16094"><span class="lineNum">   16094 </span>            :           // lastExistingEndif = (*i);</a>
<a name="16095"><span class="lineNum">   16095 </span>            :              lasti = i;</a>
<a name="16096"><span class="lineNum">   16096 </span>            :            }</a>
<a name="16097"><span class="lineNum">   16097 </span>            :       }</a>
<a name="16098"><span class="lineNum">   16098 </span>            : #endif</a>
<a name="16099"><span class="lineNum">   16099 </span>            :     }</a>
<a name="16100"><span class="lineNum">   16100 </span>            : </a>
<a name="16101"><span class="lineNum">   16101 </span>            :     // based on existing header positions, insert the new header</a>
<a name="16102"><span class="lineNum">   16102 </span><span class="lineCov">          1 :     if (asLastHeader)</span></a>
<a name="16103"><span class="lineNum">   16103 </span>            :     {</a>
<a name="16104"><span class="lineNum">   16104 </span><span class="lineCov">          1 :       if (lastExistingHeader == NULL) // No last header at all, just append to after</span></a>
<a name="16105"><span class="lineNum">   16105 </span><span class="lineNoCov">          0 :         stmt-&gt;addToAttachedPreprocessingInfo(newheader, PreprocessingInfo::after);</span></a>
<a name="16106"><span class="lineNum">   16106 </span>            :       else</a>
<a name="16107"><span class="lineNum">   16107 </span>            :       {</a>
<a name="16108"><span class="lineNum">   16108 </span><span class="lineCov">          1 :         comments-&gt;insert (lasti+1, newheader);</span></a>
<a name="16109"><span class="lineNum">   16109 </span>            :       }</a>
<a name="16110"><span class="lineNum">   16110 </span>            :     }</a>
<a name="16111"><span class="lineNum">   16111 </span>            :     else // add as the first header</a>
<a name="16112"><span class="lineNum">   16112 </span>            :     {</a>
<a name="16113"><span class="lineNum">   16113 </span><span class="lineNoCov">          0 :       if (firstExistingHeader == NULL) // no existing header at all, just append to after</span></a>
<a name="16114"><span class="lineNum">   16114 </span><span class="lineNoCov">          0 :         stmt-&gt;addToAttachedPreprocessingInfo(newheader, PreprocessingInfo::after);</span></a>
<a name="16115"><span class="lineNum">   16115 </span>            :       else</a>
<a name="16116"><span class="lineNum">   16116 </span>            :       {</a>
<a name="16117"><span class="lineNum">   16117 </span><span class="lineNoCov">          0 :         comments-&gt;insert (firsti, newheader);</span></a>
<a name="16118"><span class="lineNum">   16118 </span>            :       }</a>
<a name="16119"><span class="lineNum">   16119 </span>            :     }</a>
<a name="16120"><span class="lineNum">   16120 </span>            :   }</a>
<a name="16121"><span class="lineNum">   16121 </span>            :   else // No comments at all, first and last header mean the same, just attach to the located node</a>
<a name="16122"><span class="lineNum">   16122 </span><span class="lineCov">          1 :     stmt-&gt;addToAttachedPreprocessingInfo(newheader, position);</span></a>
<a name="16123"><span class="lineNum">   16123 </span>            : </a>
<a name="16124"><span class="lineNum">   16124 </span>            : #if 0</a>
<a name="16125"><span class="lineNum">   16125 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16126"><span class="lineNum">   16126 </span>            :      ROSE_ASSERT(false);</a>
<a name="16127"><span class="lineNum">   16127 </span>            : #endif</a>
<a name="16128"><span class="lineNum">   16128 </span>            : </a>
<a name="16129"><span class="lineNum">   16129 </span><span class="lineCov">          2 : }</span></a>
<a name="16130"><span class="lineNum">   16130 </span>            : </a>
<a name="16131"><span class="lineNum">   16131 </span>            : </a>
<a name="16132"><span class="lineNum">   16132 </span>            : // The recommended version</a>
<a name="16133"><span class="lineNum">   16133 </span><span class="lineCov">          1 : PreprocessingInfo* SageInterface::insertHeader(SgSourceFile * source_file, const std::string &amp; filename, bool isSystemHeader , bool asLastHeader)</span></a>
<a name="16134"><span class="lineNum">   16134 </span>            : {</a>
<a name="16135"><span class="lineNum">   16135 </span><span class="lineCov">          1 :   ROSE_ASSERT (source_file != NULL);</span></a>
<a name="16136"><span class="lineNum">   16136 </span><span class="lineCov">          1 :   SgGlobal* globalScope = source_file-&gt;get_globalScope();</span></a>
<a name="16137"><span class="lineNum">   16137 </span><span class="lineCov">          1 :   ROSE_ASSERT (globalScope != NULL);</span></a>
<a name="16138"><span class="lineNum">   16138 </span>            : </a>
<a name="16139"><span class="lineNum">   16139 </span><span class="lineCov">          1 :   PreprocessingInfo* result=NULL;</span></a>
<a name="16140"><span class="lineNum">   16140 </span><span class="lineCov">          1 :   string content;</span></a>
<a name="16141"><span class="lineNum">   16141 </span><span class="lineCov">          1 :   if (isSystemHeader)</span></a>
<a name="16142"><span class="lineNum">   16142 </span><span class="lineCov">          1 :     content = &quot;#include &lt;&quot; + filename + &quot;&gt; \n&quot;;</span></a>
<a name="16143"><span class="lineNum">   16143 </span>            :   else</a>
<a name="16144"><span class="lineNum">   16144 </span><span class="lineNoCov">          0 :     content = &quot;#include \&quot;&quot; + filename + &quot;\&quot; \n&quot;;</span></a>
<a name="16145"><span class="lineNum">   16145 </span>            : </a>
<a name="16146"><span class="lineNum">   16146 </span>            : #if 0</a>
<a name="16147"><span class="lineNum">   16147 </span>            : // DQ (4/6/2021): This is a compiler warning, this variable is set but not used since some unreachable code is now commented out below.</a>
<a name="16148"><span class="lineNum">   16148 </span>            :   PreprocessingInfo::RelativePositionType position ;</a>
<a name="16149"><span class="lineNum">   16149 </span>            : </a>
<a name="16150"><span class="lineNum">   16150 </span>            :   if (asLastHeader )</a>
<a name="16151"><span class="lineNum">   16151 </span>            :      position = PreprocessingInfo::after;</a>
<a name="16152"><span class="lineNum">   16152 </span>            :   else</a>
<a name="16153"><span class="lineNum">   16153 </span>            :      position = PreprocessingInfo::before;</a>
<a name="16154"><span class="lineNum">   16154 </span>            : #endif</a>
<a name="16155"><span class="lineNum">   16155 </span>            : </a>
<a name="16156"><span class="lineNum">   16156 </span><span class="lineCov">          1 :   SgDeclarationStatementPtrList &amp; stmtList = globalScope-&gt;get_declarations ();</span></a>
<a name="16157"><span class="lineNum">   16157 </span><span class="lineCov">          1 :   if (stmtList.size()&gt;0) // the source file is not empty</span></a>
<a name="16158"><span class="lineNum">   16158 </span>            :   {</a>
<a name="16159"><span class="lineNum">   16159 </span><span class="lineCov">       5452 :     for (SgDeclarationStatementPtrList::iterator j = stmtList.begin (); j != stmtList.end (); j++)</span></a>
<a name="16160"><span class="lineNum">   16160 </span>            :     {</a>
<a name="16161"><span class="lineNum">   16161 </span>            :       // Attach to the first eligible located statement</a>
<a name="16162"><span class="lineNum">   16162 </span>            :       //must have this judgement, otherwise wrong file will be modified!</a>
<a name="16163"><span class="lineNum">   16163 </span>            :       //It could also be the transformation generated statements with #include attached</a>
<a name="16164"><span class="lineNum">   16164 </span><span class="lineCov">       5452 :       if ( (*j)-&gt;get_file_info()-&gt;isSameFile(globalScope-&gt;get_file_info()) || (*j)-&gt;get_file_info()-&gt;isTransformation() )</span></a>
<a name="16165"><span class="lineNum">   16165 </span>            :       {</a>
<a name="16166"><span class="lineNum">   16166 </span>            : #if 0</a>
<a name="16167"><span class="lineNum">   16167 </span>            :         printf (&quot;In SageInterface::insertHeader(): Found statement to attached #include: *j = %p = %s \n&quot;,*j,(*j)-&gt;class_name().c_str());</a>
<a name="16168"><span class="lineNum">   16168 </span>            :         printf (&quot; --- unparseToString() = %s \n&quot;,(*j)-&gt;unparseToString().c_str());</a>
<a name="16169"><span class="lineNum">   16169 </span>            : #endif</a>
<a name="16170"><span class="lineNum">   16170 </span><span class="lineCov">          1 :         result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration, content, &quot;Transformation generated&quot;,0, 0, 0, PreprocessingInfo::before);</span></a>
<a name="16171"><span class="lineNum">   16171 </span><span class="lineCov">          1 :         ROSE_ASSERT(result);</span></a>
<a name="16172"><span class="lineNum">   16172 </span><span class="lineCov">          1 :         insertHeader (*j, result, asLastHeader);</span></a>
<a name="16173"><span class="lineNum">   16173 </span>            :         //successful = true;</a>
<a name="16174"><span class="lineNum">   16174 </span>            : #if 0</a>
<a name="16175"><span class="lineNum">   16175 </span>            :         printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16176"><span class="lineNum">   16176 </span>            :         ROSE_ABORT();</a>
<a name="16177"><span class="lineNum">   16177 </span>            : #endif</a>
<a name="16178"><span class="lineNum">   16178 </span>            :         break;</a>
<a name="16179"><span class="lineNum">   16179 </span>            :       }</a>
<a name="16180"><span class="lineNum">   16180 </span>            :     } // end for</a>
<a name="16181"><span class="lineNum">   16181 </span>            :   }</a>
<a name="16182"><span class="lineNum">   16182 </span>            :   else // empty file, attach it after SgGlobal,TODO it is not working for unknown reason!!</a>
<a name="16183"><span class="lineNum">   16183 </span>            :   {</a>
<a name="16184"><span class="lineNum">   16184 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;SageInterface::insertHeader() Empty file is found!&quot;&lt;&lt;endl;</span></a>
<a name="16185"><span class="lineNum">   16185 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;#include xxx is  preprocessing information which has to be attached  to some other  located node (a statement for example)&quot;&lt;&lt;endl;</span></a>
<a name="16186"><span class="lineNum">   16186 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;You may have to insert some statement first before inserting a header&quot;&lt;&lt;endl;</span></a>
<a name="16187"><span class="lineNum">   16187 </span><span class="lineNoCov">          0 :     ROSE_ABORT();</span></a>
<a name="16188"><span class="lineNum">   16188 </span>            : #if 0 // [Robb Matzke 2021-03-24]: unreachable</a>
<a name="16189"><span class="lineNum">   16189 </span>            :     result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration,</a>
<a name="16190"><span class="lineNum">   16190 </span>            :         content, &quot;Transformation generated&quot;,0, 0, 0, PreprocessingInfo::after);</a>
<a name="16191"><span class="lineNum">   16191 </span>            :     ROSE_ASSERT(result);</a>
<a name="16192"><span class="lineNum">   16192 </span>            :     globalScope-&gt;addToAttachedPreprocessingInfo(result,position);</a>
<a name="16193"><span class="lineNum">   16193 </span>            : #endif</a>
<a name="16194"><span class="lineNum">   16194 </span>            : //    successful = true;</a>
<a name="16195"><span class="lineNum">   16195 </span>            :   }</a>
<a name="16196"><span class="lineNum">   16196 </span>            : </a>
<a name="16197"><span class="lineNum">   16197 </span>            : #if 0</a>
<a name="16198"><span class="lineNum">   16198 </span>            :      printf (&quot;In SageInterface::insertHeader(): Marking include file for filename = %s as a transformation \n&quot;,filename.c_str());</a>
<a name="16199"><span class="lineNum">   16199 </span>            : #endif</a>
<a name="16200"><span class="lineNum">   16200 </span>            : </a>
<a name="16201"><span class="lineNum">   16201 </span>            :   // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="16202"><span class="lineNum">   16202 </span>            :   // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="16203"><span class="lineNum">   16203 </span>            :   // when multiple files are used on the command line.</a>
<a name="16204"><span class="lineNum">   16204 </span><span class="lineCov">          1 :      result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="16205"><span class="lineNum">   16205 </span>            : </a>
<a name="16206"><span class="lineNum">   16206 </span>            : #if 0</a>
<a name="16207"><span class="lineNum">   16207 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="16208"><span class="lineNum">   16208 </span>            :      ROSE_ASSERT(false);</a>
<a name="16209"><span class="lineNum">   16209 </span>            : #endif</a>
<a name="16210"><span class="lineNum">   16210 </span>            : </a>
<a name="16211"><span class="lineNum">   16211 </span>            :   // must be inserted once somehow</a>
<a name="16212"><span class="lineNum">   16212 </span>            :   // Liao 3/11/2015. We allow failed insertion sometimes, for example when translating an empty file for OpenMP, we don't need to insert any headers</a>
<a name="16213"><span class="lineNum">   16213 </span>            :   // The caller function should decide what to do if insertion is failed: ignore vs. assert failure.</a>
<a name="16214"><span class="lineNum">   16214 </span>            :   // ROSE_ASSERT(successful==true);</a>
<a name="16215"><span class="lineNum">   16215 </span><span class="lineCov">          2 :   return result;</span></a>
<a name="16216"><span class="lineNum">   16216 </span>            : </a>
<a name="16217"><span class="lineNum">   16217 </span>            : } // end insertHeader</a>
<a name="16218"><span class="lineNum">   16218 </span>            : </a>
<a name="16219"><span class="lineNum">   16219 </span>            : </a>
<a name="16220"><span class="lineNum">   16220 </span>            : //! Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes. We abuse CpreprocessorDefineDeclaration for this purpose.</a>
<a name="16221"><span class="lineNum">   16221 </span>            : PreprocessingInfo*</a>
<a name="16222"><span class="lineNum">   16222 </span><span class="lineCov">          2 : SageInterface::attachArbitraryText(SgLocatedNode* target, const std::string &amp; text, PreprocessingInfo::RelativePositionType position /*=PreprocessingInfo::before*/)</span></a>
<a name="16223"><span class="lineNum">   16223 </span>            :    {</a>
<a name="16224"><span class="lineNum">   16224 </span>            :   // DQ (1/13/2014): This function needs a better mechanism than attaching text to the AST unparser as a CPP directive.</a>
<a name="16225"><span class="lineNum">   16225 </span>            : </a>
<a name="16226"><span class="lineNum">   16226 </span><span class="lineCov">          2 :      ROSE_ASSERT(target != NULL); //dangling #define xxx is not allowed in the ROSE AST</span></a>
<a name="16227"><span class="lineNum">   16227 </span><span class="lineCov">          2 :      PreprocessingInfo* result = NULL;</span></a>
<a name="16228"><span class="lineNum">   16228 </span>            : </a>
<a name="16229"><span class="lineNum">   16229 </span>            :   // DQ (1/13/2014): It is a mistake to attach arbitrary test to the AST as a #define</a>
<a name="16230"><span class="lineNum">   16230 </span>            :   // (since we evaluate all #define CPP declarations to be a self-referential macro).</a>
<a name="16231"><span class="lineNum">   16231 </span>            :   // For now I will make it a #if CPP declaration, since these are not evaluated internally.</a>
<a name="16232"><span class="lineNum">   16232 </span>            :   // PreprocessingInfo::DirectiveType mytype = PreprocessingInfo::CpreprocessorDefineDeclaration;</a>
<a name="16233"><span class="lineNum">   16233 </span><span class="lineCov">          2 :      PreprocessingInfo::DirectiveType mytype = PreprocessingInfo::CpreprocessorIfDeclaration;</span></a>
<a name="16234"><span class="lineNum">   16234 </span>            : </a>
<a name="16235"><span class="lineNum">   16235 </span>            :   // DQ (1/13/2014): Output a warning so that this can be fixed whereever it is used.</a>
<a name="16236"><span class="lineNum">   16236 </span><span class="lineCov">          2 :      printf (&quot;Warning: attachArbitraryText(): attaching arbitrary text to the AST as a #if declaration: text = %s \n&quot;,text.c_str());</span></a>
<a name="16237"><span class="lineNum">   16237 </span>            : </a>
<a name="16238"><span class="lineNum">   16238 </span><span class="lineCov">          2 :      result = new PreprocessingInfo (mytype,text, &quot;transformation-generated&quot;, 0, 0, 0, position);</span></a>
<a name="16239"><span class="lineNum">   16239 </span><span class="lineCov">          2 :      ROSE_ASSERT(result);</span></a>
<a name="16240"><span class="lineNum">   16240 </span>            : </a>
<a name="16241"><span class="lineNum">   16241 </span>            :  // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="16242"><span class="lineNum">   16242 </span>            :  // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="16243"><span class="lineNum">   16243 </span>            :  // when multiple files are used on the command line.</a>
<a name="16244"><span class="lineNum">   16244 </span><span class="lineCov">          2 :     result-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="16245"><span class="lineNum">   16245 </span>            : </a>
<a name="16246"><span class="lineNum">   16246 </span><span class="lineCov">          2 :      target-&gt;addToAttachedPreprocessingInfo(result);</span></a>
<a name="16247"><span class="lineNum">   16247 </span>            : </a>
<a name="16248"><span class="lineNum">   16248 </span><span class="lineCov">          2 :      return result;</span></a>
<a name="16249"><span class="lineNum">   16249 </span>            :    }</a>
<a name="16250"><span class="lineNum">   16250 </span>            : </a>
<a name="16251"><span class="lineNum">   16251 </span>            : </a>
<a name="16252"><span class="lineNum">   16252 </span>            : //!Check if a target node has MacroCall attached, if yes, replace them with expanded strings</a>
<a name="16253"><span class="lineNum">   16253 </span>            : // TODO This is a dirty fix since the ideal solution would be having a preprocessed pragma text generated by the compiler. String matching and replacing is never safe.</a>
<a name="16254"><span class="lineNum">   16254 </span><span class="lineCov">       1279 : void SageInterface::replaceMacroCallsWithExpandedStrings(SgPragmaDeclaration* target)</span></a>
<a name="16255"><span class="lineNum">   16255 </span>            : {</a>
<a name="16256"><span class="lineNum">   16256 </span>            :   // This is part of Wave support in ROSE.</a>
<a name="16257"><span class="lineNum">   16257 </span>            : // #if CAN_NOT_COMPILE_WITH_ROSE != true</a>
<a name="16258"><span class="lineNum">   16258 </span>            : // #if CAN_NOT_COMPILE_WITH_ROSE == 0</a>
<a name="16259"><span class="lineNum">   16259 </span>            : #ifndef USE_ROSE</a>
<a name="16260"><span class="lineNum">   16260 </span><span class="lineCov">       1279 :   ROSE_ASSERT(target != NULL);</span></a>
<a name="16261"><span class="lineNum">   16261 </span><span class="lineCov">       1279 :   AttachedPreprocessingInfoType *info=  target-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="16262"><span class="lineNum">   16262 </span><span class="lineCov">       1383 :   if (info == NULL) return;</span></a>
<a name="16263"><span class="lineNum">   16263 </span><span class="lineCov">        104 :   AttachedPreprocessingInfoType::iterator j;</span></a>
<a name="16264"><span class="lineNum">   16264 </span><span class="lineCov">        255 :   for (j = info-&gt;begin (); j != info-&gt;end (); j++)</span></a>
<a name="16265"><span class="lineNum">   16265 </span>            :   {</a>
<a name="16266"><span class="lineNum">   16266 </span><span class="lineCov">        151 :     if ((*j)-&gt;getTypeOfDirective()==PreprocessingInfo::CMacroCall)</span></a>
<a name="16267"><span class="lineNum">   16267 </span>            :     {</a>
<a name="16268"><span class="lineNum">   16268 </span>            : #ifndef ROSE_SKIP_COMPILATION_OF_WAVE</a>
<a name="16269"><span class="lineNum">   16269 </span>            :    // DQ (2/17/2016): The token_container type is not defined if Wave is not available.</a>
<a name="16270"><span class="lineNum">   16270 </span><span class="lineNoCov">          0 :       std::ostringstream os;</span></a>
<a name="16271"><span class="lineNum">   16271 </span><span class="lineNoCov">          0 :       token_container tc = (*j)-&gt;get_macro_call()-&gt;expanded_macro;</span></a>
<a name="16272"><span class="lineNum">   16272 </span><span class="lineNoCov">          0 :       token_container::const_iterator iter;</span></a>
<a name="16273"><span class="lineNum">   16273 </span><span class="lineNoCov">          0 :       for (iter=tc.begin(); iter!=tc.end(); iter++)</span></a>
<a name="16274"><span class="lineNum">   16274 </span><span class="lineNoCov">          0 :         os&lt;&lt;(*iter).get_value();</span></a>
<a name="16275"><span class="lineNum">   16275 </span>            :       //cout&lt;&lt;&quot;Found a macro call: &quot;&lt;&lt;(*j)-&gt;getString()&lt;&lt;</a>
<a name="16276"><span class="lineNum">   16276 </span>            :       //&quot;\nexpanding it to: &quot;&lt;&lt;os.str()&lt;&lt;endl;</a>
<a name="16277"><span class="lineNum">   16277 </span><span class="lineNoCov">          0 :       string pragmaText = target-&gt;get_pragma()-&gt;get_pragma();</span></a>
<a name="16278"><span class="lineNum">   16278 </span><span class="lineNoCov">          0 :       string targetString = (*j)-&gt;getString();</span></a>
<a name="16279"><span class="lineNum">   16279 </span><span class="lineNoCov">          0 :       string replacement = os.str();</span></a>
<a name="16280"><span class="lineNum">   16280 </span>            :       // repeat until not found</a>
<a name="16281"><span class="lineNum">   16281 </span><span class="lineNoCov">          0 :       size_t pos1 = pragmaText.find(targetString);</span></a>
<a name="16282"><span class="lineNum">   16282 </span><span class="lineNoCov">          0 :       while (pos1 != string::npos)</span></a>
<a name="16283"><span class="lineNum">   16283 </span>            :       {</a>
<a name="16284"><span class="lineNum">   16284 </span><span class="lineNoCov">          0 :         pragmaText.replace(pos1, targetString.size(), replacement);</span></a>
<a name="16285"><span class="lineNum">   16285 </span><span class="lineNoCov">          0 :         pos1 = pragmaText.find(targetString);</span></a>
<a name="16286"><span class="lineNum">   16286 </span>            :       }</a>
<a name="16287"><span class="lineNum">   16287 </span><span class="lineNoCov">          0 :        delete target-&gt;get_pragma();</span></a>
<a name="16288"><span class="lineNum">   16288 </span><span class="lineNoCov">          0 :        target-&gt;set_pragma(buildPragma(pragmaText));</span></a>
<a name="16289"><span class="lineNum">   16289 </span>            : #endif</a>
<a name="16290"><span class="lineNum">   16290 </span>            :     } // end if</a>
<a name="16291"><span class="lineNum">   16291 </span>            :   } // end for</a>
<a name="16292"><span class="lineNum">   16292 </span>            : #endif</a>
<a name="16293"><span class="lineNum">   16293 </span>            : }</a>
<a name="16294"><span class="lineNum">   16294 </span>            : </a>
<a name="16295"><span class="lineNum">   16295 </span>            : //! If the given statement contains any break statements in its body, add a</a>
<a name="16296"><span class="lineNum">   16296 </span>            : //! new label below the statement and change the breaks into gotos to that</a>
<a name="16297"><span class="lineNum">   16297 </span>            : //! new label.</a>
<a name="16298"><span class="lineNum">   16298 </span><span class="lineNoCov">          0 : void SageInterface::changeBreakStatementsToGotos(SgStatement* loopOrSwitch) {</span></a>
<a name="16299"><span class="lineNum">   16299 </span><span class="lineNoCov">          0 :   using namespace SageBuilder;</span></a>
<a name="16300"><span class="lineNum">   16300 </span><span class="lineNoCov">          0 :   SgStatement* body = NULL;</span></a>
<a name="16301"><span class="lineNum">   16301 </span><span class="lineNoCov">          0 :   if (isSgWhileStmt(loopOrSwitch) || isSgDoWhileStmt(loopOrSwitch) ||</span></a>
<a name="16302"><span class="lineNum">   16302 </span><span class="lineNoCov">          0 :       isSgForStatement(loopOrSwitch)) {</span></a>
<a name="16303"><span class="lineNum">   16303 </span><span class="lineNoCov">          0 :     body = SageInterface::getLoopBody(isSgScopeStatement(loopOrSwitch));</span></a>
<a name="16304"><span class="lineNum">   16304 </span><span class="lineNoCov">          0 :   } else if (isSgSwitchStatement(loopOrSwitch)) {</span></a>
<a name="16305"><span class="lineNum">   16305 </span><span class="lineNoCov">          0 :     body = isSgSwitchStatement(loopOrSwitch)-&gt;get_body();</span></a>
<a name="16306"><span class="lineNum">   16306 </span>            :   }</a>
<a name="16307"><span class="lineNum">   16307 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (body);</span></a>
<a name="16308"><span class="lineNum">   16308 </span><span class="lineNoCov">          0 :   std::vector&lt;SgBreakStmt*&gt; breaks = SageInterface::findBreakStmts(body);</span></a>
<a name="16309"><span class="lineNum">   16309 </span><span class="lineNoCov">          0 :   if (!breaks.empty()) {</span></a>
<a name="16310"><span class="lineNum">   16310 </span><span class="lineNoCov">          0 :     static int breakLabelCounter = 0;</span></a>
<a name="16311"><span class="lineNum">   16311 </span><span class="lineNoCov">          0 :     SgLabelStatement* breakLabel =</span></a>
<a name="16312"><span class="lineNum">   16312 </span><span class="lineNoCov">          0 :       buildLabelStatement(&quot;breakLabel&quot; +</span></a>
<a name="16313"><span class="lineNum">   16313 </span><span class="lineNoCov">          0 : StringUtility::numberToString(++breakLabelCounter),</span></a>
<a name="16314"><span class="lineNum">   16314 </span><span class="lineNoCov">          0 :                           buildBasicBlock(),</span></a>
<a name="16315"><span class="lineNum">   16315 </span>            :                           isSgScopeStatement(loopOrSwitch-&gt;get_parent()));</a>
<a name="16316"><span class="lineNum">   16316 </span><span class="lineNoCov">          0 :     insertStatement(loopOrSwitch, breakLabel, false);</span></a>
<a name="16317"><span class="lineNum">   16317 </span><span class="lineNoCov">          0 :     for (size_t j = 0; j &lt; breaks.size(); ++j) {</span></a>
<a name="16318"><span class="lineNum">   16318 </span><span class="lineNoCov">          0 :       SgGotoStatement* newGoto = buildGotoStatement(breakLabel);</span></a>
<a name="16319"><span class="lineNum">   16319 </span>            : </a>
<a name="16320"><span class="lineNum">   16320 </span><span class="lineNoCov">          0 :   isSgStatement(breaks[j]-&gt;get_parent())-&gt;replace_statement(breaks[j],</span></a>
<a name="16321"><span class="lineNum">   16321 </span>            :   newGoto);</a>
<a name="16322"><span class="lineNum">   16322 </span><span class="lineNoCov">          0 :         newGoto-&gt;set_parent(breaks[j]-&gt;get_parent());</span></a>
<a name="16323"><span class="lineNum">   16323 </span>            :       }</a>
<a name="16324"><span class="lineNum">   16324 </span>            :     }</a>
<a name="16325"><span class="lineNum">   16325 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="16326"><span class="lineNum">   16326 </span>            : </a>
<a name="16327"><span class="lineNum">   16327 </span><span class="lineCov">    1287500 :   bool SageInterface::isStructDeclaration(SgNode* node)</span></a>
<a name="16328"><span class="lineNum">   16328 </span>            :   {</a>
<a name="16329"><span class="lineNum">   16329 </span><span class="lineCov">    1287500 :     ROSE_ASSERT(node!=NULL);</span></a>
<a name="16330"><span class="lineNum">   16330 </span><span class="lineCov">    1287500 :     SgClassDeclaration *decl = isSgClassDeclaration(node);</span></a>
<a name="16331"><span class="lineNum">   16331 </span><span class="lineCov">    1287500 :     if (decl==NULL)</span></a>
<a name="16332"><span class="lineNum">   16332 </span>            :       return false;</a>
<a name="16333"><span class="lineNum">   16333 </span>            :     else</a>
<a name="16334"><span class="lineNum">   16334 </span><span class="lineCov">      18039 :        return (decl-&gt;get_class_type() == SgClassDeclaration::e_struct)? true:false;</span></a>
<a name="16335"><span class="lineNum">   16335 </span>            :   }</a>
<a name="16336"><span class="lineNum">   16336 </span>            : </a>
<a name="16337"><span class="lineNum">   16337 </span><span class="lineNoCov">          0 :   bool SageInterface::isUnionDeclaration(SgNode* node)</span></a>
<a name="16338"><span class="lineNum">   16338 </span>            :   {</a>
<a name="16339"><span class="lineNum">   16339 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(node!=NULL);</span></a>
<a name="16340"><span class="lineNum">   16340 </span><span class="lineNoCov">          0 :     SgClassDeclaration *decl = isSgClassDeclaration(node);</span></a>
<a name="16341"><span class="lineNum">   16341 </span><span class="lineNoCov">          0 :     if (decl==NULL)</span></a>
<a name="16342"><span class="lineNum">   16342 </span>            :       return false;</a>
<a name="16343"><span class="lineNum">   16343 </span>            :     else</a>
<a name="16344"><span class="lineNum">   16344 </span><span class="lineNoCov">          0 :        return (decl-&gt;get_class_type() == SgClassDeclaration::e_union)? true:false;</span></a>
<a name="16345"><span class="lineNum">   16345 </span>            :   }</a>
<a name="16346"><span class="lineNum">   16346 </span>            : </a>
<a name="16347"><span class="lineNum">   16347 </span>            : </a>
<a name="16348"><span class="lineNum">   16348 </span>            : void</a>
<a name="16349"><span class="lineNum">   16349 </span><span class="lineCov">       1012 : SageInterface::movePreprocessingInfo (SgStatement* stmt_src,  SgStatement* stmt_dst, PreprocessingInfo::RelativePositionType src_position/* =PreprocessingInfo::undef */,</span></a>
<a name="16350"><span class="lineNum">   16350 </span>            :                                       PreprocessingInfo::RelativePositionType dst_position/* =PreprocessingInfo::undef */, bool usePrepend /*= false */)</a>
<a name="16351"><span class="lineNum">   16351 </span>            :    {</a>
<a name="16352"><span class="lineNum">   16352 </span><span class="lineCov">       1012 :      ROSE_ASSERT(stmt_src != NULL);</span></a>
<a name="16353"><span class="lineNum">   16353 </span><span class="lineCov">       1012 :      ROSE_ASSERT(stmt_dst != NULL);</span></a>
<a name="16354"><span class="lineNum">   16354 </span><span class="lineCov">       1012 :      AttachedPreprocessingInfoType* infoList = stmt_src-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="16355"><span class="lineNum">   16355 </span><span class="lineCov">       1012 :      AttachedPreprocessingInfoType* infoToRemoveList = new AttachedPreprocessingInfoType();</span></a>
<a name="16356"><span class="lineNum">   16356 </span>            : </a>
<a name="16357"><span class="lineNum">   16357 </span>            : #if 0</a>
<a name="16358"><span class="lineNum">   16358 </span>            :      printf (&quot;In SageInterface::movePreprocessingInfo(): \n&quot;);</a>
<a name="16359"><span class="lineNum">   16359 </span>            :      printf (&quot;   --- stmt_src = %p = %s src_position = %d \n&quot;,stmt_src,stmt_src-&gt;class_name().c_str(),src_position);</a>
<a name="16360"><span class="lineNum">   16360 </span>            :      SgDeclarationStatement* src_declarationStatement = isSgDeclarationStatement(stmt_src);</a>
<a name="16361"><span class="lineNum">   16361 </span>            :      if (src_declarationStatement != NULL)</a>
<a name="16362"><span class="lineNum">   16362 </span>            :         {</a>
<a name="16363"><span class="lineNum">   16363 </span>            :           printf (&quot;src_declarationStatement-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,src_declarationStatement-&gt;get_firstNondefiningDeclaration());</a>
<a name="16364"><span class="lineNum">   16364 </span>            :           printf (&quot;src_declarationStatement-&gt;get_definingDeclaration()         = %p \n&quot;,src_declarationStatement-&gt;get_definingDeclaration());</a>
<a name="16365"><span class="lineNum">   16365 </span>            :         }</a>
<a name="16366"><span class="lineNum">   16366 </span>            :      printf (&quot;   --- stmt_dst = %p = %s dst_position = %d \n&quot;,stmt_dst,stmt_dst-&gt;class_name().c_str(),dst_position);</a>
<a name="16367"><span class="lineNum">   16367 </span>            :      SgDeclarationStatement* dst_declarationStatement = isSgDeclarationStatement(stmt_dst);</a>
<a name="16368"><span class="lineNum">   16368 </span>            :      if (dst_declarationStatement != NULL)</a>
<a name="16369"><span class="lineNum">   16369 </span>            :         {</a>
<a name="16370"><span class="lineNum">   16370 </span>            :           printf (&quot;dst_declarationStatement-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,dst_declarationStatement-&gt;get_firstNondefiningDeclaration());</a>
<a name="16371"><span class="lineNum">   16371 </span>            :           printf (&quot;dst_declarationStatement-&gt;get_definingDeclaration()         = %p \n&quot;,dst_declarationStatement-&gt;get_definingDeclaration());</a>
<a name="16372"><span class="lineNum">   16372 </span>            :         }</a>
<a name="16373"><span class="lineNum">   16373 </span>            :      printf (&quot;   --- src_position                    = %s \n&quot;,PreprocessingInfo::relativePositionName(src_position).c_str());</a>
<a name="16374"><span class="lineNum">   16374 </span>            :      printf (&quot;   --- dst_position                    = %s \n&quot;,PreprocessingInfo::relativePositionName(dst_position).c_str());</a>
<a name="16375"><span class="lineNum">   16375 </span>            :      printf (&quot;   --- usePrepend                      = %s \n&quot;,usePrepend ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16376"><span class="lineNum">   16376 </span>            : </a>
<a name="16377"><span class="lineNum">   16377 </span>            :      printf (&quot;   --- infoList                        = %p \n&quot;,infoList);</a>
<a name="16378"><span class="lineNum">   16378 </span>            :      printf (&quot;   --- infoToRemoveList                = %p \n&quot;,infoToRemoveList);</a>
<a name="16379"><span class="lineNum">   16379 </span>            : </a>
<a name="16380"><span class="lineNum">   16380 </span>            :      AttachedPreprocessingInfoType* dst_infoList = stmt_dst-&gt;getAttachedPreprocessingInfo();</a>
<a name="16381"><span class="lineNum">   16381 </span>            :      printf (&quot;   --- dst_infoList                    = %p \n&quot;,dst_infoList);</a>
<a name="16382"><span class="lineNum">   16382 </span>            : #endif</a>
<a name="16383"><span class="lineNum">   16383 </span>            : #if 0</a>
<a name="16384"><span class="lineNum">   16384 </span>            :      printf (&quot;****************************************************************** \n&quot;);</a>
<a name="16385"><span class="lineNum">   16385 </span>            :      printf (&quot;In SageInterface::movePreprocessingInfo(): Attached comments and CPP directives: stmt_src \n&quot;);</a>
<a name="16386"><span class="lineNum">   16386 </span>            :      SageInterface::printOutComments (stmt_src);</a>
<a name="16387"><span class="lineNum">   16387 </span>            :      printf (&quot;In SageInterface::movePreprocessingInfo(): Attached comments and CPP directives: stmt_dst \n&quot;);</a>
<a name="16388"><span class="lineNum">   16388 </span>            :      SageInterface::printOutComments (stmt_dst);</a>
<a name="16389"><span class="lineNum">   16389 </span>            :      printf (&quot;****************************************************************** \n&quot;);</a>
<a name="16390"><span class="lineNum">   16390 </span>            : #endif</a>
<a name="16391"><span class="lineNum">   16391 </span>            : </a>
<a name="16392"><span class="lineNum">   16392 </span>            :   // DQ (11/22/2020): These can't be the same list else we will have a case of iterator invalidation.</a>
<a name="16393"><span class="lineNum">   16393 </span>            :   // This is a bug in the support for building a new prototype from a defining function declaration</a>
<a name="16394"><span class="lineNum">   16394 </span>            :   // and caused this problem. This assertion will prevent this sort of error from happening again.</a>
<a name="16395"><span class="lineNum">   16395 </span><span class="lineCov">       1012 :      ROSE_ASSERT(infoList == NULL || stmt_src-&gt;getAttachedPreprocessingInfo() != stmt_dst-&gt;getAttachedPreprocessingInfo());</span></a>
<a name="16396"><span class="lineNum">   16396 </span>            : </a>
<a name="16397"><span class="lineNum">   16397 </span><span class="lineCov">       1012 :      if (infoList == NULL)</span></a>
<a name="16398"><span class="lineNum">   16398 </span>            :         {</a>
<a name="16399"><span class="lineNum">   16399 </span>            : #if 0</a>
<a name="16400"><span class="lineNum">   16400 </span>            :           printf (&quot;In SageInterface::movePreprocessingInfo(): infoList == NULL: exiting movePreprocessingInfo() \n&quot;);</a>
<a name="16401"><span class="lineNum">   16401 </span>            : #endif</a>
<a name="16402"><span class="lineNum">   16402 </span><span class="lineCov">       1012 :           return;</span></a>
<a name="16403"><span class="lineNum">   16403 </span>            :         }</a>
<a name="16404"><span class="lineNum">   16404 </span>            : </a>
<a name="16405"><span class="lineNum">   16405 </span>            : #if 0</a>
<a name="16406"><span class="lineNum">   16406 </span>            :      printf (&quot;   --- infoList-&gt;size()                = %zu \n&quot;,infoList-&gt;size());</a>
<a name="16407"><span class="lineNum">   16407 </span>            :      printf (&quot;   --- infoToRemoveList-&gt;size()        = %zu \n&quot;,infoToRemoveList-&gt;size());</a>
<a name="16408"><span class="lineNum">   16408 </span>            : #endif</a>
<a name="16409"><span class="lineNum">   16409 </span>            : </a>
<a name="16410"><span class="lineNum">   16410 </span>            : #if 0</a>
<a name="16411"><span class="lineNum">   16411 </span>            :      int counter = 0;</a>
<a name="16412"><span class="lineNum">   16412 </span>            : </a>
<a name="16413"><span class="lineNum">   16413 </span>            :      for (Rose_STL_Container&lt;PreprocessingInfo*&gt;::iterator i = (*infoList).begin(); i != (*infoList).end(); i++)</a>
<a name="16414"><span class="lineNum">   16414 </span>            :         {</a>
<a name="16415"><span class="lineNum">   16415 </span>            :        // DQ (11/19/2020): Added assertion.</a>
<a name="16416"><span class="lineNum">   16416 </span>            :           ROSE_ASSERT(*i != NULL);</a>
<a name="16417"><span class="lineNum">   16417 </span>            : </a>
<a name="16418"><span class="lineNum">   16418 </span>            :        // DQ (11/19/2020): Why do we have a dynamic cast here.</a>
<a name="16419"><span class="lineNum">   16419 </span>            :        // PreprocessingInfo * info = dynamic_cast&lt;PreprocessingInfo*&gt; (*i);</a>
<a name="16420"><span class="lineNum">   16420 </span>            :           PreprocessingInfo * info = *i;</a>
<a name="16421"><span class="lineNum">   16421 </span>            :           ROSE_ASSERT(info != NULL);</a>
<a name="16422"><span class="lineNum">   16422 </span>            : </a>
<a name="16423"><span class="lineNum">   16423 </span>            :        // printf (&quot;counter = %d \n&quot;,counter);</a>
<a name="16424"><span class="lineNum">   16424 </span>            :           printf (&quot;counter = %d Processing PreprocessingInfo = %s \n&quot;,counter,info-&gt;getString().c_str());</a>
<a name="16425"><span class="lineNum">   16425 </span>            :           counter++;</a>
<a name="16426"><span class="lineNum">   16426 </span>            :         }</a>
<a name="16427"><span class="lineNum">   16427 </span>            : </a>
<a name="16428"><span class="lineNum">   16428 </span>            :      counter = 0;</a>
<a name="16429"><span class="lineNum">   16429 </span>            : #endif</a>
<a name="16430"><span class="lineNum">   16430 </span>            : </a>
<a name="16431"><span class="lineNum">   16431 </span><span class="lineCov">        124 :      PreprocessingInfo* prevItem = NULL;</span></a>
<a name="16432"><span class="lineNum">   16432 </span><span class="lineCov">        289 :      for (Rose_STL_Container&lt;PreprocessingInfo*&gt;::iterator i = (*infoList).begin(); i != (*infoList).end(); i++)</span></a>
<a name="16433"><span class="lineNum">   16433 </span>            :         {</a>
<a name="16434"><span class="lineNum">   16434 </span>            :        // DQ (11/19/2020): Added assertion.</a>
<a name="16435"><span class="lineNum">   16435 </span><span class="lineCov">        165 :           ROSE_ASSERT(*i != NULL);</span></a>
<a name="16436"><span class="lineNum">   16436 </span>            : </a>
<a name="16437"><span class="lineNum">   16437 </span>            :        // DQ (11/19/2020): Why do we have a dynamic cast here.</a>
<a name="16438"><span class="lineNum">   16438 </span>            :        // PreprocessingInfo * info = dynamic_cast&lt;PreprocessingInfo*&gt; (*i);</a>
<a name="16439"><span class="lineNum">   16439 </span><span class="lineCov">        165 :           PreprocessingInfo * info = *i;</span></a>
<a name="16440"><span class="lineNum">   16440 </span><span class="lineCov">        165 :           ROSE_ASSERT(info != NULL);</span></a>
<a name="16441"><span class="lineNum">   16441 </span>            : #if 0</a>
<a name="16442"><span class="lineNum">   16442 </span>            :           printf (&quot;counter = %d \n&quot;,counter);</a>
<a name="16443"><span class="lineNum">   16443 </span>            :           printf (&quot;counter = %d Processing PreprocessingInfo = %s \n&quot;,counter,info-&gt;getString().c_str());</a>
<a name="16444"><span class="lineNum">   16444 </span>            :           counter++;</a>
<a name="16445"><span class="lineNum">   16445 </span>            : #endif</a>
<a name="16446"><span class="lineNum">   16446 </span>            : #if 0</a>
<a name="16447"><span class="lineNum">   16447 </span>            :           printf (&quot;   --- TOP of loop: infoList-&gt;size()                = %zu \n&quot;,infoList-&gt;size());</a>
<a name="16448"><span class="lineNum">   16448 </span>            :           printf (&quot;   --- TOP of loop: infoToRemoveList-&gt;size()        = %zu \n&quot;,infoToRemoveList-&gt;size());</a>
<a name="16449"><span class="lineNum">   16449 </span>            :           printf (&quot;   --- TOP of loop: info-&gt;getTypeOfDirective()      = %s \n&quot;,PreprocessingInfo::directiveTypeName(info-&gt;getTypeOfDirective()).c_str());</a>
<a name="16450"><span class="lineNum">   16450 </span>            :           printf (&quot;   --- TOP of loop: info-&gt;getRelativePosition()     = %s \n&quot;,PreprocessingInfo::relativePositionName(info-&gt;getRelativePosition()).c_str());</a>
<a name="16451"><span class="lineNum">   16451 </span>            : #endif</a>
<a name="16452"><span class="lineNum">   16452 </span><span class="lineCov">        165 :           if (   // match enum values in http://rosecompiler.org/ROSE_HTML_Reference/classPreprocessingInfo.html</span></a>
<a name="16453"><span class="lineNum">   16453 </span><span class="lineCov">        276 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::C_StyleComment)||</span></a>
<a name="16454"><span class="lineNum">   16454 </span><span class="lineCov">        170 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CplusplusStyleComment)||</span></a>
<a name="16455"><span class="lineNum">   16455 </span><span class="lineCov">        114 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::FortranStyleComment)||</span></a>
<a name="16456"><span class="lineNum">   16456 </span><span class="lineCov">        110 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::F90StyleComment)||</span></a>
<a name="16457"><span class="lineNum">   16457 </span><span class="lineCov">         91 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorIncludeDeclaration )||</span></a>
<a name="16458"><span class="lineNum">   16458 </span><span class="lineCov">         72 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorIncludeNextDeclaration )||</span></a>
<a name="16459"><span class="lineNum">   16459 </span><span class="lineCov">         65 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorDefineDeclaration )||</span></a>
<a name="16460"><span class="lineNum">   16460 </span><span class="lineCov">         58 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorUndefDeclaration)||</span></a>
<a name="16461"><span class="lineNum">   16461 </span><span class="lineCov">         48 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfdefDeclaration )||</span></a>
<a name="16462"><span class="lineNum">   16462 </span><span class="lineCov">         38 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfndefDeclaration )||</span></a>
<a name="16463"><span class="lineNum">   16463 </span><span class="lineCov">         36 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfDeclaration )||</span></a>
<a name="16464"><span class="lineNum">   16464 </span><span class="lineCov">         34 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorDeadIfDeclaration )||</span></a>
<a name="16465"><span class="lineNum">   16465 </span><span class="lineCov">         31 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorElseDeclaration )||</span></a>
<a name="16466"><span class="lineNum">   16466 </span><span class="lineCov">         28 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorElifDeclaration )||</span></a>
<a name="16467"><span class="lineNum">   16467 </span><span class="lineCov">         14 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorEndifDeclaration ) ||</span></a>
<a name="16468"><span class="lineNum">   16468 </span><span class="lineNoCov">          0 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorEnd_ifDeclaration ) ||</span></a>
<a name="16469"><span class="lineNum">   16469 </span><span class="lineNoCov">          0 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorLineDeclaration) ||</span></a>
<a name="16470"><span class="lineNum">   16470 </span><span class="lineNoCov">          0 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorErrorDeclaration) ||</span></a>
<a name="16471"><span class="lineNum">   16471 </span><span class="lineNoCov">          0 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::CpreprocessorWarningDeclaration) ||</span></a>
<a name="16472"><span class="lineNum">   16472 </span>            :             // DQ (12/28/2020): Added support for C linkage specifications.</a>
<a name="16473"><span class="lineNum">   16473 </span><span class="lineCov">        165 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::ClinkageSpecificationStart) ||</span></a>
<a name="16474"><span class="lineNum">   16474 </span><span class="lineNoCov">          0 :                (info-&gt;getTypeOfDirective()==PreprocessingInfo::ClinkageSpecificationEnd)</span></a>
<a name="16475"><span class="lineNum">   16475 </span>            :              )</a>
<a name="16476"><span class="lineNum">   16476 </span>            :              {</a>
<a name="16477"><span class="lineNum">   16477 </span>            : #if 0</a>
<a name="16478"><span class="lineNum">   16478 </span>            :                printf (&quot;Processing PreprocessingInfo = %s \n&quot;,info-&gt;getString().c_str());</a>
<a name="16479"><span class="lineNum">   16479 </span>            : #endif</a>
<a name="16480"><span class="lineNum">   16480 </span>            : #if 0</a>
<a name="16481"><span class="lineNum">   16481 </span>            :             // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16482"><span class="lineNum">   16482 </span>            :                printf (&quot; --- Skip body of loop over the comments and CPP directives \n&quot;);</a>
<a name="16483"><span class="lineNum">   16483 </span>            : #else</a>
<a name="16484"><span class="lineNum">   16484 </span>            :             // move all source preprocessing info if the desired source type is not specified or matching</a>
<a name="16485"><span class="lineNum">   16485 </span>            :             // a specified desired source type</a>
<a name="16486"><span class="lineNum">   16486 </span><span class="lineCov">        165 :                if ( src_position == PreprocessingInfo::undef || info-&gt;getRelativePosition() == src_position)</span></a>
<a name="16487"><span class="lineNum">   16487 </span>            :                   {</a>
<a name="16488"><span class="lineNum">   16488 </span>            : #if 0</a>
<a name="16489"><span class="lineNum">   16489 </span>            :                  // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16490"><span class="lineNum">   16490 </span>            :                     printf (&quot; --- Skip upper inner body of loop over the comments and CPP directives \n&quot;);</a>
<a name="16491"><span class="lineNum">   16491 </span>            : #else</a>
<a name="16492"><span class="lineNum">   16492 </span>            : #if 0</a>
<a name="16493"><span class="lineNum">   16493 </span>            :                     printf (&quot;usePrepend = %s \n&quot;,usePrepend ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="16494"><span class="lineNum">   16494 </span>            : #endif</a>
<a name="16495"><span class="lineNum">   16495 </span><span class="lineCov">        165 :                     if (usePrepend == true)</span></a>
<a name="16496"><span class="lineNum">   16496 </span>            :                        {</a>
<a name="16497"><span class="lineNum">   16497 </span>            : #if 0</a>
<a name="16498"><span class="lineNum">   16498 </span>            :                       // This still fails.</a>
<a name="16499"><span class="lineNum">   16499 </span>            :                       // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16500"><span class="lineNum">   16500 </span>            :                          printf (&quot; --- Skip upper inner body (part 1) of loop over the comments and CPP directives \n&quot;);</a>
<a name="16501"><span class="lineNum">   16501 </span>            : #else</a>
<a name="16502"><span class="lineNum">   16502 </span>            : #if 0</a>
<a name="16503"><span class="lineNum">   16503 </span>            :                          printf (&quot;prevItem = %p \n&quot;,prevItem);</a>
<a name="16504"><span class="lineNum">   16504 </span>            : #endif</a>
<a name="16505"><span class="lineNum">   16505 </span>            :                       // Liao (1/27/2015):  modification to fix order of CPP directives when a list of them are moved.</a>
<a name="16506"><span class="lineNum">   16506 </span><span class="lineCov">          6 :                          if (prevItem == NULL)</span></a>
<a name="16507"><span class="lineNum">   16507 </span>            :                             {</a>
<a name="16508"><span class="lineNum">   16508 </span>            :                            // addToAttachedPreprocessingInfo() is poorly designed, the last parameter is used</a>
<a name="16509"><span class="lineNum">   16509 </span>            :                            // to indicate appending or prepending by reusing the type of relative position.</a>
<a name="16510"><span class="lineNum">   16510 </span>            :                            // this is very confusing for users</a>
<a name="16511"><span class="lineNum">   16511 </span>            : #if 0</a>
<a name="16512"><span class="lineNum">   16512 </span>            :                            // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16513"><span class="lineNum">   16513 </span>            :                               printf (&quot; --- Skip upper inner body (part 1.1) of loop over the comments and CPP directives \n&quot;);</a>
<a name="16514"><span class="lineNum">   16514 </span>            : #else</a>
<a name="16515"><span class="lineNum">   16515 </span><span class="lineCov">          6 :                               stmt_dst-&gt;addToAttachedPreprocessingInfo(info,PreprocessingInfo::before);</span></a>
<a name="16516"><span class="lineNum">   16516 </span>            : #endif</a>
<a name="16517"><span class="lineNum">   16517 </span>            :                             }</a>
<a name="16518"><span class="lineNum">   16518 </span>            :                            else // there is a previous item, insert after it</a>
<a name="16519"><span class="lineNum">   16519 </span>            :                             {</a>
<a name="16520"><span class="lineNum">   16520 </span>            : #if 0</a>
<a name="16521"><span class="lineNum">   16521 </span>            :                            // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16522"><span class="lineNum">   16522 </span>            :                               printf (&quot; --- Skip upper inner body (part 1.2) of loop over the comments and CPP directives \n&quot;);</a>
<a name="16523"><span class="lineNum">   16523 </span>            : #else</a>
<a name="16524"><span class="lineNum">   16524 </span><span class="lineNoCov">          0 :                               stmt_dst-&gt;insertToAttachedPreprocessingInfo(info, prevItem);</span></a>
<a name="16525"><span class="lineNum">   16525 </span>            : #endif</a>
<a name="16526"><span class="lineNum">   16526 </span>            :                             }</a>
<a name="16527"><span class="lineNum">   16527 </span>            : #if 0</a>
<a name="16528"><span class="lineNum">   16528 </span>            :                       // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16529"><span class="lineNum">   16529 </span>            :                          printf (&quot; --- Skip upper inner body (part 1.3) of loop over the comments and CPP directives \n&quot;);</a>
<a name="16530"><span class="lineNum">   16530 </span>            : #else</a>
<a name="16531"><span class="lineNum">   16531 </span>            :                          prevItem = info;</a>
<a name="16532"><span class="lineNum">   16532 </span>            : #if 0</a>
<a name="16533"><span class="lineNum">   16533 </span>            :                          printf (&quot;after being set: prevItem = %p \n&quot;,prevItem);</a>
<a name="16534"><span class="lineNum">   16534 </span>            : #endif</a>
<a name="16535"><span class="lineNum">   16535 </span>            : #endif</a>
<a name="16536"><span class="lineNum">   16536 </span>            : #endif</a>
<a name="16537"><span class="lineNum">   16537 </span>            :                        }</a>
<a name="16538"><span class="lineNum">   16538 </span>            :                       else</a>
<a name="16539"><span class="lineNum">   16539 </span>            :                        {</a>
<a name="16540"><span class="lineNum">   16540 </span>            : #if 1</a>
<a name="16541"><span class="lineNum">   16541 </span>            : #if 0</a>
<a name="16542"><span class="lineNum">   16542 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): calling addToAttachedPreprocessingInfo(): info                    = %s \n&quot;,info-&gt;getString().c_str());</a>
<a name="16543"><span class="lineNum">   16543 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): before addToAttachedPreprocessingInfo(): infoList-&gt;size()         = %zu \n&quot;,infoList-&gt;size());</a>
<a name="16544"><span class="lineNum">   16544 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): before addToAttachedPreprocessingInfo(): infoToRemoveList-&gt;size() = %zu \n&quot;,infoToRemoveList-&gt;size());</a>
<a name="16545"><span class="lineNum">   16545 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): before addToAttachedPreprocessingInfo(): stmt_dst                 = %p \n&quot;,stmt_dst);</a>
<a name="16546"><span class="lineNum">   16546 </span>            : #endif</a>
<a name="16547"><span class="lineNum">   16547 </span><span class="lineCov">        159 :                          stmt_dst-&gt;addToAttachedPreprocessingInfo(info,PreprocessingInfo::after);</span></a>
<a name="16548"><span class="lineNum">   16548 </span>            : #if 0</a>
<a name="16549"><span class="lineNum">   16549 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): after addToAttachedPreprocessingInfo(): infoList-&gt;size()          = %zu \n&quot;,infoList-&gt;size());</a>
<a name="16550"><span class="lineNum">   16550 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): after addToAttachedPreprocessingInfo(): infoToRemoveList-&gt;size()  = %zu \n&quot;,infoToRemoveList-&gt;size());</a>
<a name="16551"><span class="lineNum">   16551 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): after addToAttachedPreprocessingInfo(): stmt_dst                  = %p \n&quot;,stmt_dst);</a>
<a name="16552"><span class="lineNum">   16552 </span>            : #endif</a>
<a name="16553"><span class="lineNum">   16553 </span>            : #else</a>
<a name="16554"><span class="lineNum">   16554 </span>            :                       // DQ (11/22/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16555"><span class="lineNum">   16555 </span>            :                          printf (&quot; --- Skip usePrepend == false body of loop over the comments and CPP directives \n&quot;);</a>
<a name="16556"><span class="lineNum">   16556 </span>            : #endif</a>
<a name="16557"><span class="lineNum">   16557 </span>            :                        }</a>
<a name="16558"><span class="lineNum">   16558 </span>            : #endif</a>
<a name="16559"><span class="lineNum">   16559 </span>            : #if 0</a>
<a name="16560"><span class="lineNum">   16560 </span>            :                  // DQ (11/19/2020): Debugging moving of comments in replaceStatement() support.</a>
<a name="16561"><span class="lineNum">   16561 </span>            :                     printf (&quot; --- Skip lower inner body of loop over the comments and CPP directives \n&quot;);</a>
<a name="16562"><span class="lineNum">   16562 </span>            : #else</a>
<a name="16563"><span class="lineNum">   16563 </span>            :                  // DQ (1/15/2015): Added support to mark as transformations so that the token-based unparsing can know to NOT use the leading and trailing token stream for whitespace.</a>
<a name="16564"><span class="lineNum">   16564 </span><span class="lineCov">        165 :                     info-&gt;setAsTransformation();</span></a>
<a name="16565"><span class="lineNum">   16565 </span>            :                  // ROSE_ASSERT(stmt_dst-&gt;getAttachedPreprocessingInfo() != NULL);</a>
<a name="16566"><span class="lineNum">   16566 </span>            :                  // stmt_dst-&gt;getAttachedPreprocessingInfo()-&gt;setAsTransformation();</a>
<a name="16567"><span class="lineNum">   16567 </span>            : </a>
<a name="16568"><span class="lineNum">   16568 </span>            :                  // DQ (10/13/2015): This is a problem for the token-based unparsing since we don't want to have this</a>
<a name="16569"><span class="lineNum">   16569 </span>            :                  // set_containsTransformationToSurroundingWhitespace() function cause the isModified flag to be set.</a>
<a name="16570"><span class="lineNum">   16570 </span>            :                  // So we have to detect it being set and reset it as needed.  An alternative would be to have a</a>
<a name="16571"><span class="lineNum">   16571 </span>            :                  // non-ROSETTA generate function that didn't have the isModified flag set for the seter access function.</a>
<a name="16572"><span class="lineNum">   16572 </span>            :                  // Note that the inputmoveDeclarationToInnermostScope_test2015_123.C file demonstrates this problem.</a>
<a name="16573"><span class="lineNum">   16573 </span><span class="lineCov">        165 :                     bool isMarkedAsModified = stmt_dst-&gt;get_isModified();</span></a>
<a name="16574"><span class="lineNum">   16574 </span><span class="lineCov">        165 :                     stmt_dst-&gt;set_containsTransformationToSurroundingWhitespace(true);</span></a>
<a name="16575"><span class="lineNum">   16575 </span><span class="lineCov">        165 :                     if (isMarkedAsModified == false)</span></a>
<a name="16576"><span class="lineNum">   16576 </span>            :                        {</a>
<a name="16577"><span class="lineNum">   16577 </span><span class="lineCov">          4 :                          if (stmt_dst-&gt;get_isModified() == true)</span></a>
<a name="16578"><span class="lineNum">   16578 </span>            :                             {</a>
<a name="16579"><span class="lineNum">   16579 </span>            : #if 0</a>
<a name="16580"><span class="lineNum">   16580 </span>            :                               printf (&quot;In SageInterface::movePreprocessingInfo(): Reset isModified flag to FALSE: stmt_dst = %p = %s \n&quot;,stmt_dst,stmt_dst-&gt;class_name().c_str());</a>
<a name="16581"><span class="lineNum">   16581 </span>            : #endif</a>
<a name="16582"><span class="lineNum">   16582 </span><span class="lineNoCov">          0 :                               stmt_dst-&gt;set_isModified(false);</span></a>
<a name="16583"><span class="lineNum">   16583 </span>            :                             }</a>
<a name="16584"><span class="lineNum">   16584 </span>            :                        }</a>
<a name="16585"><span class="lineNum">   16585 </span>            :                       else</a>
<a name="16586"><span class="lineNum">   16586 </span>            :                        {</a>
<a name="16587"><span class="lineNum">   16587 </span>            : #if 0</a>
<a name="16588"><span class="lineNum">   16588 </span>            :                          printf (&quot;In SageInterface::movePreprocessingInfo(): This was already marked as isModified == TRUE: stmt_dst = %p = %s \n&quot;,stmt_dst,stmt_dst-&gt;class_name().c_str());</a>
<a name="16589"><span class="lineNum">   16589 </span>            : #endif</a>
<a name="16590"><span class="lineNum">   16590 </span>            :                        }</a>
<a name="16591"><span class="lineNum">   16591 </span>            : #endif</a>
<a name="16592"><span class="lineNum">   16592 </span>            : </a>
<a name="16593"><span class="lineNum">   16593 </span><span class="lineCov">        165 :                     (*infoToRemoveList).push_back(*i);</span></a>
<a name="16594"><span class="lineNum">   16594 </span>            :                   }</a>
<a name="16595"><span class="lineNum">   16595 </span>            : </a>
<a name="16596"><span class="lineNum">   16596 </span>            : #if 0</a>
<a name="16597"><span class="lineNum">   16597 </span>            :                  else if (info-&gt;getRelativePosition()==src_position)</a>
<a name="16598"><span class="lineNum">   16598 </span>            :                   {</a>
<a name="16599"><span class="lineNum">   16599 </span>            :                     if (usePrepend)</a>
<a name="16600"><span class="lineNum">   16600 </span>            :                        {</a>
<a name="16601"><span class="lineNum">   16601 </span>            :                        }</a>
<a name="16602"><span class="lineNum">   16602 </span>            :                       else</a>
<a name="16603"><span class="lineNum">   16603 </span>            :                          stmt_dst-&gt;addToAttachedPreprocessingInfo(info,PreprocessingInfo::after);</a>
<a name="16604"><span class="lineNum">   16604 </span>            : </a>
<a name="16605"><span class="lineNum">   16605 </span>            :                     (*infoToRemoveList).push_back(*i);</a>
<a name="16606"><span class="lineNum">   16606 </span>            :                   } // if src_position</a>
<a name="16607"><span class="lineNum">   16607 </span>            : #endif</a>
<a name="16608"><span class="lineNum">   16608 </span>            : </a>
<a name="16609"><span class="lineNum">   16609 </span>            :             // adjust dst position if needed</a>
<a name="16610"><span class="lineNum">   16610 </span><span class="lineCov">        165 :                if (dst_position != PreprocessingInfo::undef)</span></a>
<a name="16611"><span class="lineNum">   16611 </span>            :                   {</a>
<a name="16612"><span class="lineNum">   16612 </span>            : #if 0</a>
<a name="16613"><span class="lineNum">   16613 </span>            :                     printf (&quot;In SageInterface::movePreprocessingInfo(): adjust dst position: dst_position = %s \n&quot;,PreprocessingInfo::relativePositionName(dst_position).c_str());</a>
<a name="16614"><span class="lineNum">   16614 </span>            : #endif</a>
<a name="16615"><span class="lineNum">   16615 </span><span class="lineCov">          6 :                     info-&gt;setRelativePosition(dst_position);</span></a>
<a name="16616"><span class="lineNum">   16616 </span>            :                   }</a>
<a name="16617"><span class="lineNum">   16617 </span>            : #endif</a>
<a name="16618"><span class="lineNum">   16618 </span>            :              } // end if</a>
<a name="16619"><span class="lineNum">   16619 </span>            : </a>
<a name="16620"><span class="lineNum">   16620 </span>            : #if 0</a>
<a name="16621"><span class="lineNum">   16621 </span>            :           printf (&quot;   --- BOTTOM of loop: infoList-&gt;size()                = %zu \n&quot;,infoList-&gt;size());</a>
<a name="16622"><span class="lineNum">   16622 </span>            :           printf (&quot;   --- BOTTOM of loop: infoToRemoveList-&gt;size()        = %zu \n&quot;,infoToRemoveList-&gt;size());</a>
<a name="16623"><span class="lineNum">   16623 </span>            : #endif</a>
<a name="16624"><span class="lineNum">   16624 </span>            :         } // end for</a>
<a name="16625"><span class="lineNum">   16625 </span>            : </a>
<a name="16626"><span class="lineNum">   16626 </span>            : #if 0</a>
<a name="16627"><span class="lineNum">   16627 </span>            :      printf (&quot;In SageInterface::movePreprocessingInfo(): Remove the element transfered to the new statement from the old statement list \n&quot;);</a>
<a name="16628"><span class="lineNum">   16628 </span>            : #endif</a>
<a name="16629"><span class="lineNum">   16629 </span>            : </a>
<a name="16630"><span class="lineNum">   16630 </span>            :   // Remove the element from the list of comments at the current astNode</a>
<a name="16631"><span class="lineNum">   16631 </span><span class="lineCov">        124 :      AttachedPreprocessingInfoType::iterator j;</span></a>
<a name="16632"><span class="lineNum">   16632 </span><span class="lineCov">        289 :      for (j = (*infoToRemoveList).begin(); j != (*infoToRemoveList).end(); j++)</span></a>
<a name="16633"><span class="lineNum">   16633 </span>            :         {</a>
<a name="16634"><span class="lineNum">   16634 </span>            : #if 0</a>
<a name="16635"><span class="lineNum">   16635 </span>            :           printf (&quot;In SageInterface::movePreprocessingInfo(): Remove the element from the list of comments at the current astNode \n&quot;);</a>
<a name="16636"><span class="lineNum">   16636 </span>            : #endif</a>
<a name="16637"><span class="lineNum">   16637 </span><span class="lineCov">        165 :           infoList-&gt;erase( find(infoList-&gt;begin(),infoList-&gt;end(),*j) );</span></a>
<a name="16638"><span class="lineNum">   16638 </span>            :         }</a>
<a name="16639"><span class="lineNum">   16639 </span>            :    }</a>
<a name="16640"><span class="lineNum">   16640 </span>            : </a>
<a name="16641"><span class="lineNum">   16641 </span>            : </a>
<a name="16642"><span class="lineNum">   16642 </span>            : //----------------------------</a>
<a name="16643"><span class="lineNum">   16643 </span>            : // Sometimes, the preprocessing info attached to a declaration has to be</a>
<a name="16644"><span class="lineNum">   16644 </span>            : // moved 'up' if another declaration is inserted before it.</a>
<a name="16645"><span class="lineNum">   16645 </span>            : // This is a workaround for the broken LowLevelRewrite::insert() and the private</a>
<a name="16646"><span class="lineNum">   16646 </span>            : // LowLevelRewrite::reassociatePreprocessorDeclarations()</a>
<a name="16647"><span class="lineNum">   16647 </span>            : //</a>
<a name="16648"><span class="lineNum">   16648 </span>            : // input:</a>
<a name="16649"><span class="lineNum">   16649 </span>            : //     *stmt_dst: the new inserted declaration</a>
<a name="16650"><span class="lineNum">   16650 </span>            : //     *stmt_src: the existing declaration with preprocessing information</a>
<a name="16651"><span class="lineNum">   16651 </span>            : // tasks:</a>
<a name="16652"><span class="lineNum">   16652 </span>            : //     judge if stmt_src has propressingInfo with headers, ifdef, etc..</a>
<a name="16653"><span class="lineNum">   16653 </span>            : //     add them into stmt_dst</a>
<a name="16654"><span class="lineNum">   16654 </span>            : //     delete them from stmt_dst</a>
<a name="16655"><span class="lineNum">   16655 </span>            : // More general usage: move preprocessingInfo of stmt_src to stmt_dst, should used before any</a>
<a name="16656"><span class="lineNum">   16656 </span>            : //           LoweLevel::remove(stmt_src)</a>
<a name="16657"><span class="lineNum">   16657 </span><span class="lineCov">        907 : void SageInterface::moveUpPreprocessingInfo(SgStatement * stmt_dst, SgStatement * stmt_src,</span></a>
<a name="16658"><span class="lineNum">   16658 </span>            :       PreprocessingInfo::RelativePositionType src_position/*=PreprocessingInfo::undef*/,</a>
<a name="16659"><span class="lineNum">   16659 </span>            :       PreprocessingInfo::RelativePositionType dst_position/*=PreprocessingInfo::undef*/,</a>
<a name="16660"><span class="lineNum">   16660 </span>            :       bool usePrepend /*= false */)</a>
<a name="16661"><span class="lineNum">   16661 </span>            :    {</a>
<a name="16662"><span class="lineNum">   16662 </span>            : #if 0</a>
<a name="16663"><span class="lineNum">   16663 </span>            :      printf (&quot;In SageInterface::moveUpPreprocessingInfo(): calling movePreprocessingInfo() \n&quot;);</a>
<a name="16664"><span class="lineNum">   16664 </span>            : #endif</a>
<a name="16665"><span class="lineNum">   16665 </span>            : </a>
<a name="16666"><span class="lineNum">   16666 </span><span class="lineCov">        907 :      movePreprocessingInfo (stmt_src, stmt_dst, src_position, dst_position, usePrepend);</span></a>
<a name="16667"><span class="lineNum">   16667 </span><span class="lineCov">        907 :    } // moveUpPreprocessingInfo()</span></a>
<a name="16668"><span class="lineNum">   16668 </span>            : </a>
<a name="16669"><span class="lineNum">   16669 </span>            : </a>
<a name="16670"><span class="lineNum">   16670 </span>            : /*!</a>
<a name="16671"><span class="lineNum">   16671 </span>            :  *  \brief Returns 'true' iff the given info object is valid and has</a>
<a name="16672"><span class="lineNum">   16672 </span>            :  *  the specified position.</a>
<a name="16673"><span class="lineNum">   16673 </span>            :  */</a>
<a name="16674"><span class="lineNum">   16674 </span><span class="lineNoCov">          0 : static bool isNotRelPos (const PreprocessingInfo* info,</span></a>
<a name="16675"><span class="lineNum">   16675 </span>            :              PreprocessingInfo::RelativePositionType pos)</a>
<a name="16676"><span class="lineNum">   16676 </span>            : {</a>
<a name="16677"><span class="lineNum">   16677 </span><span class="lineNoCov">          0 :   return info &amp;&amp; (info-&gt;getRelativePosition () != pos);</span></a>
<a name="16678"><span class="lineNum">   16678 </span>            : }</a>
<a name="16679"><span class="lineNum">   16679 </span>            : </a>
<a name="16680"><span class="lineNum">   16680 </span>            : /*!</a>
<a name="16681"><span class="lineNum">   16681 </span>            :  *  \brief Returns 'true' iff the given info object is valid and does</a>
<a name="16682"><span class="lineNum">   16682 </span>            :  *  not have the specified position.</a>
<a name="16683"><span class="lineNum">   16683 </span>            :  */</a>
<a name="16684"><span class="lineNum">   16684 </span><span class="lineNoCov">          0 : static bool isRelPos (const PreprocessingInfo* info,</span></a>
<a name="16685"><span class="lineNum">   16685 </span>            :              PreprocessingInfo::RelativePositionType pos)</a>
<a name="16686"><span class="lineNum">   16686 </span>            : {</a>
<a name="16687"><span class="lineNum">   16687 </span><span class="lineNoCov">          0 :   return info &amp;&amp; !isNotRelPos (info, pos);</span></a>
<a name="16688"><span class="lineNum">   16688 </span>            : }</a>
<a name="16689"><span class="lineNum">   16689 </span>            : </a>
<a name="16690"><span class="lineNum">   16690 </span>            : </a>
<a name="16691"><span class="lineNum">   16691 </span>            : //!Cut preprocessing information from a source node and save it into a buffer. Used in combination of pastePreprocessingInfo(). The cut-paste operaation is similar to moveUpPreprocessingInfo() but it is more flexible in that the destination node only need to be known until the paste action.</a>
<a name="16692"><span class="lineNum">   16692 </span><span class="lineNoCov">          0 : void SageInterface::cutPreprocessingInfo (SgLocatedNode* src_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType&amp; save_buf)</span></a>
<a name="16693"><span class="lineNum">   16693 </span>            : {</a>
<a name="16694"><span class="lineNum">   16694 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(src_node != NULL);</span></a>
<a name="16695"><span class="lineNum">   16695 </span>            : </a>
<a name="16696"><span class="lineNum">   16696 </span><span class="lineNoCov">          0 :   AttachedPreprocessingInfoType* info = src_node-&gt;get_attachedPreprocessingInfoPtr();</span></a>
<a name="16697"><span class="lineNum">   16697 </span><span class="lineNoCov">          0 :   if (info)</span></a>
<a name="16698"><span class="lineNum">   16698 </span>            :   {</a>
<a name="16699"><span class="lineNum">   16699 </span><span class="lineNoCov">          0 :     remove_copy_if (info-&gt;begin (), info-&gt;end (),</span></a>
<a name="16700"><span class="lineNum">   16700 </span>            :         back_inserter (save_buf),</a>
<a name="16701"><span class="lineNum">   16701 </span><span class="lineNoCov">          0 :         bind2nd (ptr_fun (isNotRelPos), pos));</span></a>
<a name="16702"><span class="lineNum">   16702 </span>            : </a>
<a name="16703"><span class="lineNum">   16703 </span>            :     // DQ (9/26/2007): Commented out as part of move from std::list to std::vector</a>
<a name="16704"><span class="lineNum">   16704 </span>            :     // info-&gt;remove_if (bind2nd (ptr_fun (isRelPos), pos));</a>
<a name="16705"><span class="lineNum">   16705 </span>            :     // Liao (10/3/2007), implement list::remove_if for vector, which lacks sth. like erase_if</a>
<a name="16706"><span class="lineNum">   16706 </span><span class="lineNoCov">          0 :     AttachedPreprocessingInfoType::iterator new_end =</span></a>
<a name="16707"><span class="lineNum">   16707 </span><span class="lineNoCov">          0 :       remove_if(info-&gt;begin(),info-&gt;end(),bind2nd(ptr_fun (isRelPos), pos));</span></a>
<a name="16708"><span class="lineNum">   16708 </span><span class="lineNoCov">          0 :     info-&gt;erase(new_end, info-&gt;end());</span></a>
<a name="16709"><span class="lineNum">   16709 </span>            :   }</a>
<a name="16710"><span class="lineNum">   16710 </span><span class="lineNoCov">          0 : }</span></a>
<a name="16711"><span class="lineNum">   16711 </span>            : </a>
<a name="16712"><span class="lineNum">   16712 </span>            : static AttachedPreprocessingInfoType *</a>
<a name="16713"><span class="lineNum">   16713 </span><span class="lineNoCov">          0 : createInfoList (SgLocatedNode* s)</span></a>
<a name="16714"><span class="lineNum">   16714 </span>            : {</a>
<a name="16715"><span class="lineNum">   16715 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (s);</span></a>
<a name="16716"><span class="lineNum">   16716 </span><span class="lineNoCov">          0 :   AttachedPreprocessingInfoType* info_list = s-&gt;get_attachedPreprocessingInfoPtr ();</span></a>
<a name="16717"><span class="lineNum">   16717 </span><span class="lineNoCov">          0 :   if (!info_list)</span></a>
<a name="16718"><span class="lineNum">   16718 </span>            :   {</a>
<a name="16719"><span class="lineNum">   16719 </span><span class="lineNoCov">          0 :     info_list = new AttachedPreprocessingInfoType;</span></a>
<a name="16720"><span class="lineNum">   16720 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (info_list);</span></a>
<a name="16721"><span class="lineNum">   16721 </span><span class="lineNoCov">          0 :     s-&gt;set_attachedPreprocessingInfoPtr (info_list);</span></a>
<a name="16722"><span class="lineNum">   16722 </span>            :   }</a>
<a name="16723"><span class="lineNum">   16723 </span>            : </a>
<a name="16724"><span class="lineNum">   16724 </span>            :   // Guarantee a non-NULL pointer.</a>
<a name="16725"><span class="lineNum">   16725 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (info_list);</span></a>
<a name="16726"><span class="lineNum">   16726 </span><span class="lineNoCov">          0 :   return info_list;</span></a>
<a name="16727"><span class="lineNum">   16727 </span>            : }</a>
<a name="16728"><span class="lineNum">   16728 </span>            : </a>
<a name="16729"><span class="lineNum">   16729 </span>            : //!Cut preprocessing information from a source node and save it into a buffer. Used in combination of pastePreprocessingInfo()</a>
<a name="16730"><span class="lineNum">   16730 </span><span class="lineNoCov">          0 : void SageInterface::pastePreprocessingInfo (SgLocatedNode* dst_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType&amp; save_buf)</span></a>
<a name="16731"><span class="lineNum">   16731 </span>            : {</a>
<a name="16732"><span class="lineNum">   16732 </span><span class="lineNoCov">          0 :   if (save_buf.size()==0) return;</span></a>
<a name="16733"><span class="lineNum">   16733 </span>            :   // if front</a>
<a name="16734"><span class="lineNum">   16734 </span><span class="lineNoCov">          0 :   AttachedPreprocessingInfoType* info = createInfoList (dst_node);</span></a>
<a name="16735"><span class="lineNum">   16735 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (info);</span></a>
<a name="16736"><span class="lineNum">   16736 </span>            : </a>
<a name="16737"><span class="lineNum">   16737 </span>            :   // DQ (9/26/2007): Commented out as part of move from std::list to std::vector</a>
<a name="16738"><span class="lineNum">   16738 </span>            :   // printf (&quot;Commented out front_inserter() as part of move from std::list to std::vector \n&quot;);</a>
<a name="16739"><span class="lineNum">   16739 </span>            :   // copy (save_buf.rbegin (), save_buf.rend (), front_inserter (*info));</a>
<a name="16740"><span class="lineNum">   16740 </span>            : </a>
<a name="16741"><span class="lineNum">   16741 </span>            :   // Liao (10/3/2007), vectors can only be appended at the rear</a>
<a name="16742"><span class="lineNum">   16742 </span><span class="lineNoCov">          0 :   if (pos==PreprocessingInfo::before)</span></a>
<a name="16743"><span class="lineNum">   16743 </span>            :   {</a>
<a name="16744"><span class="lineNum">   16744 </span><span class="lineNoCov">          0 :     for(AttachedPreprocessingInfoType::reverse_iterator i=save_buf.rbegin();i!=save_buf.rend();i++)</span></a>
<a name="16745"><span class="lineNum">   16745 </span><span class="lineNoCov">          0 :       info-&gt;insert(info-&gt;begin(),*i);</span></a>
<a name="16746"><span class="lineNum">   16746 </span>            :   }</a>
<a name="16747"><span class="lineNum">   16747 </span>            :   // if back</a>
<a name="16748"><span class="lineNum">   16748 </span><span class="lineNoCov">          0 :   else if (pos==PreprocessingInfo::after)</span></a>
<a name="16749"><span class="lineNum">   16749 </span><span class="lineNoCov">          0 :     copy (save_buf.begin (), save_buf.end (), back_inserter (*info));</span></a>
<a name="16750"><span class="lineNum">   16750 </span><span class="lineNoCov">          0 :   else if (pos==PreprocessingInfo::inside)</span></a>
<a name="16751"><span class="lineNum">   16751 </span>            :   {</a>
<a name="16752"><span class="lineNum">   16752 </span><span class="lineNoCov">          0 :     copy (save_buf.begin (), save_buf.end (), back_inserter (*info));</span></a>
<a name="16753"><span class="lineNum">   16753 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;SageInterface::pastePreprocessingInfo() pos==PreprocessingInfo::inside is not supported.&quot;&lt;&lt;endl;</span></a>
<a name="16754"><span class="lineNum">   16754 </span><span class="lineNoCov">          0 :     save_buf[0]-&gt;display(&quot;ttt&quot;);</span></a>
<a name="16755"><span class="lineNum">   16755 </span>            :   }</a>
<a name="16756"><span class="lineNum">   16756 </span>            : }</a>
<a name="16757"><span class="lineNum">   16757 </span>            : </a>
<a name="16758"><span class="lineNum">   16758 </span><span class="lineNoCov">          0 : void SageInterface::dumpPreprocInfo (SgLocatedNode* locatedNode)</span></a>
<a name="16759"><span class="lineNum">   16759 </span>            : {</a>
<a name="16760"><span class="lineNum">   16760 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="16761"><span class="lineNum">   16761 </span><span class="lineNoCov">          0 :   AttachedPreprocessingInfoType *comments =</span></a>
<a name="16762"><span class="lineNum">   16762 </span><span class="lineNoCov">          0 :     locatedNode-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="16763"><span class="lineNum">   16763 </span>            : </a>
<a name="16764"><span class="lineNum">   16764 </span><span class="lineNoCov">          0 :   if (comments != NULL)</span></a>
<a name="16765"><span class="lineNum">   16765 </span>            :   {</a>
<a name="16766"><span class="lineNum">   16766 </span><span class="lineNoCov">          0 :     printf (&quot;-----------------------------------------------\n&quot;);</span></a>
<a name="16767"><span class="lineNum">   16767 </span><span class="lineNoCov">          0 :     printf (&quot;Found an IR node (at %p of type: %s) in file %s \n&quot;,</span></a>
<a name="16768"><span class="lineNum">   16768 </span><span class="lineNoCov">          0 :         locatedNode, locatedNode-&gt;class_name ().c_str (),</span></a>
<a name="16769"><span class="lineNum">   16769 </span><span class="lineNoCov">          0 :         (locatedNode-&gt;get_file_info ()-&gt;get_filenameString ()).c_str ());</span></a>
<a name="16770"><span class="lineNum">   16770 </span><span class="lineNoCov">          0 :     int counter = 0;</span></a>
<a name="16771"><span class="lineNum">   16771 </span><span class="lineNoCov">          0 :     AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="16772"><span class="lineNum">   16772 </span><span class="lineNoCov">          0 :     for (i = comments-&gt;begin (); i != comments-&gt;end (); i++)</span></a>
<a name="16773"><span class="lineNum">   16773 </span>            :     {</a>
<a name="16774"><span class="lineNum">   16774 </span><span class="lineNoCov">          0 :       printf</span></a>
<a name="16775"><span class="lineNum">   16775 </span><span class="lineNoCov">          0 :         (&quot;with attached preprocessingInfo numbering #%d :------------- \nclassification= %s:\nString format:%s\n&quot;,</span></a>
<a name="16776"><span class="lineNum">   16776 </span>            :          counter++,</a>
<a name="16777"><span class="lineNum">   16777 </span><span class="lineNoCov">          0 :          PreprocessingInfo::directiveTypeName ((*i)-&gt;getTypeOfDirective ()).</span></a>
<a name="16778"><span class="lineNum">   16778 </span><span class="lineNoCov">          0 :          c_str (), (*i)-&gt;getString ().c_str ());</span></a>
<a name="16779"><span class="lineNum">   16779 </span><span class="lineNoCov">          0 :       if ((*i)-&gt;getRelativePosition () == PreprocessingInfo::inside)</span></a>
<a name="16780"><span class="lineNum">   16780 </span><span class="lineNoCov">          0 :         printf (&quot;relative position is: inside\n&quot;);</span></a>
<a name="16781"><span class="lineNum">   16781 </span>            :       else</a>
<a name="16782"><span class="lineNum">   16782 </span><span class="lineNoCov">          0 :         printf (&quot;relative position is: %s\n&quot;, \</span></a>
<a name="16783"><span class="lineNum">   16783 </span><span class="lineNoCov">          0 :             ((*i)-&gt;getRelativePosition () == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;);</span></a>
<a name="16784"><span class="lineNum">   16784 </span>            :     }</a>
<a name="16785"><span class="lineNum">   16785 </span>            :   }</a>
<a name="16786"><span class="lineNum">   16786 </span>            :   else</a>
<a name="16787"><span class="lineNum">   16787 </span>            :   {</a>
<a name="16788"><span class="lineNum">   16788 </span><span class="lineNoCov">          0 :     printf (&quot;No attached preprocessing info. (at %p of type: %s): \n&quot;, locatedNode,</span></a>
<a name="16789"><span class="lineNum">   16789 </span><span class="lineNoCov">          0 :         locatedNode-&gt;sage_class_name ());</span></a>
<a name="16790"><span class="lineNum">   16790 </span>            :   }</a>
<a name="16791"><span class="lineNum">   16791 </span><span class="lineNoCov">          0 : }</span></a>
<a name="16792"><span class="lineNum">   16792 </span>            : </a>
<a name="16793"><span class="lineNum">   16793 </span>            : /// \brief             helper function that ensures that a certain child node</a>
<a name="16794"><span class="lineNum">   16794 </span>            : ///                    of a statement is a basic block.</a>
<a name="16795"><span class="lineNum">   16795 </span>            : /// \tparam ParentNode the type of the statement</a>
<a name="16796"><span class="lineNum">   16796 </span>            : /// \param stmt        the parent statement</a>
<a name="16797"><span class="lineNum">   16797 </span>            : /// \param setter      the member function to retrieve the child node</a>
<a name="16798"><span class="lineNum">   16798 </span>            : /// \param getter      the member function to set the child node</a>
<a name="16799"><span class="lineNum">   16799 </span>            : /// \return            the pointer stmt.getter() if it is a basic block</a>
<a name="16800"><span class="lineNum">   16800 </span>            : ///                    a new basic block containing stmt.getter() otherewise</a>
<a name="16801"><span class="lineNum">   16801 </span>            : /// \details           if stmt.getter() is not a basic block,</a>
<a name="16802"><span class="lineNum">   16802 </span>            : ///                    ensureBasicBlock_aux also sets</a>
<a name="16803"><span class="lineNum">   16803 </span>            : ///                    stmt.setter(new basic block)</a>
<a name="16804"><span class="lineNum">   16804 </span>            : template &lt;class ParentNode&gt;</a>
<a name="16805"><span class="lineNum">   16805 </span>            : static</a>
<a name="16806"><span class="lineNum">   16806 </span><span class="lineNoCov">          0 : SgBasicBlock* ensureBasicBlock_aux( ParentNode&amp; stmt,</span></a>
<a name="16807"><span class="lineNum">   16807 </span>            :                                     SgStatement* (ParentNode::*getter) () const,</a>
<a name="16808"><span class="lineNum">   16808 </span>            :                                     void (ParentNode::*setter) (SgStatement*)</a>
<a name="16809"><span class="lineNum">   16809 </span>            :                                   )</a>
<a name="16810"><span class="lineNum">   16810 </span>            : {</a>
<a name="16811"><span class="lineNum">   16811 </span><span class="lineNoCov">          0 :   SgStatement* const body_stmt = (stmt.*getter)();</span></a>
<a name="16812"><span class="lineNum">   16812 </span><span class="lineNoCov">          0 :   SgBasicBlock*      basicblock = isSgBasicBlock(body_stmt);</span></a>
<a name="16813"><span class="lineNum">   16813 </span>            : </a>
<a name="16814"><span class="lineNum">   16814 </span><span class="lineNoCov">          0 :   if (basicblock == NULL) {</span></a>
<a name="16815"><span class="lineNum">   16815 </span><span class="lineNoCov">          0 :     basicblock = SageBuilder::buildBasicBlock(body_stmt);</span></a>
<a name="16816"><span class="lineNum">   16816 </span><span class="lineNoCov">          0 :     (stmt.*setter)(basicblock);</span></a>
<a name="16817"><span class="lineNum">   16817 </span><span class="lineNoCov">          0 :     basicblock-&gt;set_parent(&amp;stmt);</span></a>
<a name="16818"><span class="lineNum">   16818 </span>            :   }</a>
<a name="16819"><span class="lineNum">   16819 </span>            : </a>
<a name="16820"><span class="lineNum">   16820 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (basicblock != NULL);</span></a>
<a name="16821"><span class="lineNum">   16821 </span><span class="lineNoCov">          0 :   return basicblock;</span></a>
<a name="16822"><span class="lineNum">   16822 </span>            : }</a>
<a name="16823"><span class="lineNum">   16823 </span>            : </a>
<a name="16824"><span class="lineNum">   16824 </span><span class="lineCov">         22 : SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfFor(SgForStatement* fs)</span></a>
<a name="16825"><span class="lineNum">   16825 </span>            : {</a>
<a name="16826"><span class="lineNum">   16826 </span><span class="lineCov">         22 :   SgStatement* b = fs-&gt;get_loop_body();</span></a>
<a name="16827"><span class="lineNum">   16827 </span><span class="lineCov">         22 :   if (!isSgBasicBlock(b)) {</span></a>
<a name="16828"><span class="lineNum">   16828 </span><span class="lineCov">          4 :     b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16829"><span class="lineNum">   16829 </span><span class="lineCov">          4 :     fs-&gt;set_loop_body(b);</span></a>
<a name="16830"><span class="lineNum">   16830 </span><span class="lineCov">          4 :     b-&gt;set_parent(fs);</span></a>
<a name="16831"><span class="lineNum">   16831 </span>            : </a>
<a name="16832"><span class="lineNum">   16832 </span>            :  // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16833"><span class="lineNum">   16833 </span><span class="lineCov">          4 :     recordNormalizations(b);</span></a>
<a name="16834"><span class="lineNum">   16834 </span>            :   }</a>
<a name="16835"><span class="lineNum">   16835 </span><span class="lineCov">         22 :   ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16836"><span class="lineNum">   16836 </span><span class="lineCov">         22 :   return isSgBasicBlock(b);</span></a>
<a name="16837"><span class="lineNum">   16837 </span>            : }</a>
<a name="16838"><span class="lineNum">   16838 </span>            : </a>
<a name="16839"><span class="lineNum">   16839 </span><span class="lineNoCov">          0 : SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfCaseOption(SgCaseOptionStmt* cs)</span></a>
<a name="16840"><span class="lineNum">   16840 </span>            : {</a>
<a name="16841"><span class="lineNum">   16841 </span><span class="lineNoCov">          0 :   SgStatement* b = cs-&gt;get_body();</span></a>
<a name="16842"><span class="lineNum">   16842 </span><span class="lineNoCov">          0 :   if (!isSgBasicBlock(b)) {</span></a>
<a name="16843"><span class="lineNum">   16843 </span><span class="lineNoCov">          0 :     b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16844"><span class="lineNum">   16844 </span><span class="lineNoCov">          0 :     cs-&gt;set_body(b);</span></a>
<a name="16845"><span class="lineNum">   16845 </span><span class="lineNoCov">          0 :     b-&gt;set_parent(cs);</span></a>
<a name="16846"><span class="lineNum">   16846 </span>            : </a>
<a name="16847"><span class="lineNum">   16847 </span>            :  // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16848"><span class="lineNum">   16848 </span><span class="lineNoCov">          0 :     recordNormalizations(b);</span></a>
<a name="16849"><span class="lineNum">   16849 </span>            :   }</a>
<a name="16850"><span class="lineNum">   16850 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16851"><span class="lineNum">   16851 </span><span class="lineNoCov">          0 :   return isSgBasicBlock(b);</span></a>
<a name="16852"><span class="lineNum">   16852 </span>            : }</a>
<a name="16853"><span class="lineNum">   16853 </span>            : </a>
<a name="16854"><span class="lineNum">   16854 </span><span class="lineNoCov">          0 : SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfDefaultOption(SgDefaultOptionStmt * cs)</span></a>
<a name="16855"><span class="lineNum">   16855 </span>            : {</a>
<a name="16856"><span class="lineNum">   16856 </span><span class="lineNoCov">          0 :   SgStatement* b = cs-&gt;get_body();</span></a>
<a name="16857"><span class="lineNum">   16857 </span><span class="lineNoCov">          0 :   if (!isSgBasicBlock(b)) {</span></a>
<a name="16858"><span class="lineNum">   16858 </span><span class="lineNoCov">          0 :     b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16859"><span class="lineNum">   16859 </span><span class="lineNoCov">          0 :     cs-&gt;set_body(b);</span></a>
<a name="16860"><span class="lineNum">   16860 </span><span class="lineNoCov">          0 :     b-&gt;set_parent(cs);</span></a>
<a name="16861"><span class="lineNum">   16861 </span>            : </a>
<a name="16862"><span class="lineNum">   16862 </span>            :  // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16863"><span class="lineNum">   16863 </span><span class="lineNoCov">          0 :     recordNormalizations(b);</span></a>
<a name="16864"><span class="lineNum">   16864 </span>            :   }</a>
<a name="16865"><span class="lineNum">   16865 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16866"><span class="lineNum">   16866 </span><span class="lineNoCov">          0 :   return isSgBasicBlock(b);</span></a>
<a name="16867"><span class="lineNum">   16867 </span>            : }</a>
<a name="16868"><span class="lineNum">   16868 </span>            : </a>
<a name="16869"><span class="lineNum">   16869 </span><span class="lineNoCov">          0 : SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfUpcForAll(SgUpcForAllStatement* fs)</span></a>
<a name="16870"><span class="lineNum">   16870 </span>            : {</a>
<a name="16871"><span class="lineNum">   16871 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (fs != NULL);</span></a>
<a name="16872"><span class="lineNum">   16872 </span>            : </a>
<a name="16873"><span class="lineNum">   16873 </span><span class="lineNoCov">          0 :   return ensureBasicBlock_aux(*fs, &amp;SgUpcForAllStatement::get_loop_body, &amp;SgUpcForAllStatement::set_loop_body);</span></a>
<a name="16874"><span class="lineNum">   16874 </span>            : }</a>
<a name="16875"><span class="lineNum">   16875 </span>            : </a>
<a name="16876"><span class="lineNum">   16876 </span><span class="lineNoCov">          0 :   SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfWhile(SgWhileStmt* fs) {</span></a>
<a name="16877"><span class="lineNum">   16877 </span><span class="lineNoCov">          0 :     SgStatement* b = fs-&gt;get_body();</span></a>
<a name="16878"><span class="lineNum">   16878 </span><span class="lineNoCov">          0 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="16879"><span class="lineNum">   16879 </span><span class="lineNoCov">          0 :       b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16880"><span class="lineNum">   16880 </span><span class="lineNoCov">          0 :       fs-&gt;set_body(b);</span></a>
<a name="16881"><span class="lineNum">   16881 </span><span class="lineNoCov">          0 :       b-&gt;set_parent(fs);</span></a>
<a name="16882"><span class="lineNum">   16882 </span>            : </a>
<a name="16883"><span class="lineNum">   16883 </span>            :    // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16884"><span class="lineNum">   16884 </span><span class="lineNoCov">          0 :       recordNormalizations(b);</span></a>
<a name="16885"><span class="lineNum">   16885 </span>            :     }</a>
<a name="16886"><span class="lineNum">   16886 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16887"><span class="lineNum">   16887 </span><span class="lineNoCov">          0 :     return isSgBasicBlock(b);</span></a>
<a name="16888"><span class="lineNum">   16888 </span>            :   }</a>
<a name="16889"><span class="lineNum">   16889 </span>            : </a>
<a name="16890"><span class="lineNum">   16890 </span><span class="lineNoCov">          0 :   SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfDoWhile(SgDoWhileStmt* fs) {</span></a>
<a name="16891"><span class="lineNum">   16891 </span><span class="lineNoCov">          0 :     SgStatement* b = fs-&gt;get_body();</span></a>
<a name="16892"><span class="lineNum">   16892 </span><span class="lineNoCov">          0 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="16893"><span class="lineNum">   16893 </span><span class="lineNoCov">          0 :       b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16894"><span class="lineNum">   16894 </span><span class="lineNoCov">          0 :       fs-&gt;set_body(b);</span></a>
<a name="16895"><span class="lineNum">   16895 </span><span class="lineNoCov">          0 :       b-&gt;set_parent(fs);</span></a>
<a name="16896"><span class="lineNum">   16896 </span>            : </a>
<a name="16897"><span class="lineNum">   16897 </span>            :    // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16898"><span class="lineNum">   16898 </span><span class="lineNoCov">          0 :       recordNormalizations(b);</span></a>
<a name="16899"><span class="lineNum">   16899 </span>            :     }</a>
<a name="16900"><span class="lineNum">   16900 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16901"><span class="lineNum">   16901 </span><span class="lineNoCov">          0 :     return isSgBasicBlock(b);</span></a>
<a name="16902"><span class="lineNum">   16902 </span>            :   }</a>
<a name="16903"><span class="lineNum">   16903 </span>            : </a>
<a name="16904"><span class="lineNum">   16904 </span><span class="lineNoCov">          0 :   SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfSwitch(SgSwitchStatement* fs) {</span></a>
<a name="16905"><span class="lineNum">   16905 </span><span class="lineNoCov">          0 :     SgStatement* b = fs-&gt;get_body();</span></a>
<a name="16906"><span class="lineNum">   16906 </span><span class="lineNoCov">          0 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="16907"><span class="lineNum">   16907 </span><span class="lineNoCov">          0 :       b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16908"><span class="lineNum">   16908 </span><span class="lineNoCov">          0 :       fs-&gt;set_body(b);</span></a>
<a name="16909"><span class="lineNum">   16909 </span><span class="lineNoCov">          0 :       b-&gt;set_parent(fs);</span></a>
<a name="16910"><span class="lineNum">   16910 </span>            : </a>
<a name="16911"><span class="lineNum">   16911 </span>            :    // DQ (1/21/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16912"><span class="lineNum">   16912 </span><span class="lineNoCov">          0 :       recordNormalizations(b);</span></a>
<a name="16913"><span class="lineNum">   16913 </span>            :     }</a>
<a name="16914"><span class="lineNum">   16914 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16915"><span class="lineNum">   16915 </span><span class="lineNoCov">          0 :     return isSgBasicBlock(b);</span></a>
<a name="16916"><span class="lineNum">   16916 </span>            :   }</a>
<a name="16917"><span class="lineNum">   16917 </span>            : </a>
<a name="16918"><span class="lineNum">   16918 </span><span class="lineCov">          1 :   SgBasicBlock* SageInterface::ensureBasicBlockAsTrueBodyOfIf(SgIfStmt* fs) {</span></a>
<a name="16919"><span class="lineNum">   16919 </span><span class="lineCov">          1 :     SgStatement* b = fs-&gt;get_true_body();</span></a>
<a name="16920"><span class="lineNum">   16920 </span><span class="lineCov">          1 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="16921"><span class="lineNum">   16921 </span><span class="lineCov">          1 :       b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="16922"><span class="lineNum">   16922 </span><span class="lineCov">          1 :       fs-&gt;set_true_body(b);</span></a>
<a name="16923"><span class="lineNum">   16923 </span><span class="lineCov">          1 :       b-&gt;set_parent(fs);</span></a>
<a name="16924"><span class="lineNum">   16924 </span>            : </a>
<a name="16925"><span class="lineNum">   16925 </span>            :    // DQ (1/18/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="16926"><span class="lineNum">   16926 </span><span class="lineCov">          1 :       recordNormalizations(b);</span></a>
<a name="16927"><span class="lineNum">   16927 </span>            : #if 0</a>
<a name="16928"><span class="lineNum">   16928 </span>            :       printf (&quot;In SageInterface::ensureBasicBlockAsTrueBodyOfIf(): Added SgBasicBlock b = %p to addedBasicBlockNodes.size() = %zu \n&quot;,b,addedBasicBlockNodes.size());</a>
<a name="16929"><span class="lineNum">   16929 </span>            : #endif</a>
<a name="16930"><span class="lineNum">   16930 </span>            :     }</a>
<a name="16931"><span class="lineNum">   16931 </span><span class="lineCov">          1 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="16932"><span class="lineNum">   16932 </span><span class="lineCov">          1 :     return isSgBasicBlock(b);</span></a>
<a name="16933"><span class="lineNum">   16933 </span>            :   }</a>
<a name="16934"><span class="lineNum">   16934 </span>            : </a>
<a name="16935"><span class="lineNum">   16935 </span>            : // DQ (1/18/2015): This is added to support better quality token-based unparsing.</a>
<a name="16936"><span class="lineNum">   16936 </span><span class="lineCov">          6 : void SageInterface::recordNormalizations(SgStatement* s)</span></a>
<a name="16937"><span class="lineNum">   16937 </span>            :    {</a>
<a name="16938"><span class="lineNum">   16938 </span>            :   // Record where normalization have been done so that we can preform denormalizations as required</a>
<a name="16939"><span class="lineNum">   16939 </span>            :   // for the token-based unparsing to generate minimal diffs.</a>
<a name="16940"><span class="lineNum">   16940 </span>            : </a>
<a name="16941"><span class="lineNum">   16941 </span><span class="lineCov">          6 :      SgBasicBlock* bb = isSgBasicBlock(s);</span></a>
<a name="16942"><span class="lineNum">   16942 </span><span class="lineCov">          6 :      ROSE_ASSERT(bb != NULL);</span></a>
<a name="16943"><span class="lineNum">   16943 </span><span class="lineCov">          6 :      addedBasicBlockNodes.push_back(bb);</span></a>
<a name="16944"><span class="lineNum">   16944 </span>            : #if 0</a>
<a name="16945"><span class="lineNum">   16945 </span>            :      printf (&quot;In SageInterface::recordNormalizations(): Added SgBasicBlock = %p to addedBasicBlockNodes.size() = %zu \n&quot;,bb,addedBasicBlockNodes.size());</a>
<a name="16946"><span class="lineNum">   16946 </span>            : #endif</a>
<a name="16947"><span class="lineNum">   16947 </span><span class="lineCov">          6 :    }</span></a>
<a name="16948"><span class="lineNum">   16948 </span>            : </a>
<a name="16949"><span class="lineNum">   16949 </span>            : // DQ (1/18/2015): This is added to support better quality token-based unparsing.</a>
<a name="16950"><span class="lineNum">   16950 </span><span class="lineNoCov">          0 : void SageInterface::cleanupNontransformedBasicBlockNode()</span></a>
<a name="16951"><span class="lineNum">   16951 </span>            :    {</a>
<a name="16952"><span class="lineNum">   16952 </span>            :   // Remove unused basic block IR nodes added as part of normalization.</a>
<a name="16953"><span class="lineNum">   16953 </span>            :   // This function should be called before the unparse step.</a>
<a name="16954"><span class="lineNum">   16954 </span>            : </a>
<a name="16955"><span class="lineNum">   16955 </span>            : #if 0</a>
<a name="16956"><span class="lineNum">   16956 </span>            :      printf (&quot;In SageInterface::cleanupNontransformedBasicBlockNode(): addedBasicBlockNodes.size() = %zu \n&quot;,addedBasicBlockNodes.size());</a>
<a name="16957"><span class="lineNum">   16957 </span>            : #endif</a>
<a name="16958"><span class="lineNum">   16958 </span>            : </a>
<a name="16959"><span class="lineNum">   16959 </span><span class="lineNoCov">          0 :      for (vector&lt;SgBasicBlock*&gt;::iterator i = addedBasicBlockNodes.begin(); i != addedBasicBlockNodes.end(); i++)</span></a>
<a name="16960"><span class="lineNum">   16960 </span>            :         {</a>
<a name="16961"><span class="lineNum">   16961 </span><span class="lineNoCov">          0 :           SgBasicBlock* b = *i;</span></a>
<a name="16962"><span class="lineNum">   16962 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(b != NULL);</span></a>
<a name="16963"><span class="lineNum">   16963 </span><span class="lineNoCov">          0 :           if (b-&gt;get_statements().size() == 1)</span></a>
<a name="16964"><span class="lineNum">   16964 </span>            :              {</a>
<a name="16965"><span class="lineNum">   16965 </span>            : #if 0</a>
<a name="16966"><span class="lineNum">   16966 </span>            :                 printf (&quot;This SgBasicBlock can be denormalized: b = %p \n&quot;,b);</a>
<a name="16967"><span class="lineNum">   16967 </span>            : #endif</a>
<a name="16968"><span class="lineNum">   16968 </span><span class="lineNoCov">          0 :                 SgStatement* parentOfBlock = isSgStatement(b-&gt;get_parent());</span></a>
<a name="16969"><span class="lineNum">   16969 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(parentOfBlock != NULL);</span></a>
<a name="16970"><span class="lineNum">   16970 </span>            : </a>
<a name="16971"><span class="lineNum">   16971 </span><span class="lineNoCov">          0 :                 bool wasPreviouslyModified = parentOfBlock-&gt;get_isModified();</span></a>
<a name="16972"><span class="lineNum">   16972 </span>            : </a>
<a name="16973"><span class="lineNum">   16973 </span><span class="lineNoCov">          0 :                 SgStatement* s = b-&gt;get_statements()[0];</span></a>
<a name="16974"><span class="lineNum">   16974 </span><span class="lineNoCov">          0 :                 ROSE_ASSERT(s != NULL);</span></a>
<a name="16975"><span class="lineNum">   16975 </span>            : </a>
<a name="16976"><span class="lineNum">   16976 </span><span class="lineNoCov">          0 :                 switch (parentOfBlock-&gt;variantT())</span></a>
<a name="16977"><span class="lineNum">   16977 </span>            :                    {</a>
<a name="16978"><span class="lineNum">   16978 </span><span class="lineNoCov">          0 :                      case V_SgIfStmt:</span></a>
<a name="16979"><span class="lineNum">   16979 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="16980"><span class="lineNum">   16980 </span><span class="lineNoCov">          0 :                           SgIfStmt* ifStatement = isSgIfStmt(parentOfBlock);</span></a>
<a name="16981"><span class="lineNum">   16981 </span><span class="lineNoCov">          0 :                           if (b == ifStatement-&gt;get_true_body())</span></a>
<a name="16982"><span class="lineNum">   16982 </span>            :                              {</a>
<a name="16983"><span class="lineNum">   16983 </span>            : #if 0</a>
<a name="16984"><span class="lineNum">   16984 </span>            :                                printf (&quot;Calling set_true_body on ifStatement = %p = %s \n&quot;,ifStatement,ifStatement-&gt;class_name().c_str());</a>
<a name="16985"><span class="lineNum">   16985 </span>            : #endif</a>
<a name="16986"><span class="lineNum">   16986 </span>            :                             // DQ (10/6/2015): This member function call is causing the IR node to be marked as transformed.</a>
<a name="16987"><span class="lineNum">   16987 </span><span class="lineNoCov">          0 :                                ifStatement-&gt;set_true_body(s);</span></a>
<a name="16988"><span class="lineNum">   16988 </span>            : #if 0</a>
<a name="16989"><span class="lineNum">   16989 </span>            :                                printf (&quot;Calling set_parent on s = %p = %n \n&quot;,s,s-&gt;class_name().c_str());</a>
<a name="16990"><span class="lineNum">   16990 </span>            : #endif</a>
<a name="16991"><span class="lineNum">   16991 </span>            :                             // DQ (10/6/2015): Calls to the set_parent member function do NOT cause the either node to be marked as isModfied.</a>
<a name="16992"><span class="lineNum">   16992 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(ifStatement);</span></a>
<a name="16993"><span class="lineNum">   16993 </span>            : #if 0</a>
<a name="16994"><span class="lineNum">   16994 </span>            :                                printf (&quot;DONE: Calling set_parent on s = %p = %n \n&quot;,s,s-&gt;class_name().c_str());</a>
<a name="16995"><span class="lineNum">   16995 </span>            : #endif</a>
<a name="16996"><span class="lineNum">   16996 </span><span class="lineNoCov">          0 :                                *i = NULL;</span></a>
<a name="16997"><span class="lineNum">   16997 </span>            :                             // delete b;</a>
<a name="16998"><span class="lineNum">   16998 </span>            :                              }</a>
<a name="16999"><span class="lineNum">   16999 </span>            :                             else</a>
<a name="17000"><span class="lineNum">   17000 </span>            :                              {</a>
<a name="17001"><span class="lineNum">   17001 </span><span class="lineNoCov">          0 :                                ROSE_ASSERT(b == ifStatement-&gt;get_false_body());</span></a>
<a name="17002"><span class="lineNum">   17002 </span>            : #if 0</a>
<a name="17003"><span class="lineNum">   17003 </span>            :                                printf (&quot;Calling set_false_body on ifStatement = %p = %s \n&quot;,ifStatement,ifStatement-&gt;class_name().c_str());</a>
<a name="17004"><span class="lineNum">   17004 </span>            : #endif</a>
<a name="17005"><span class="lineNum">   17005 </span>            :                             // DQ (10/6/2015): This member function call is causing the IR node to be marked as transformed.</a>
<a name="17006"><span class="lineNum">   17006 </span><span class="lineNoCov">          0 :                                ifStatement-&gt;set_false_body(s);</span></a>
<a name="17007"><span class="lineNum">   17007 </span>            : #if 0</a>
<a name="17008"><span class="lineNum">   17008 </span>            :                                printf (&quot;Calling set_parent on s = %p = %n \n&quot;,s,s-&gt;class_name().c_str());</a>
<a name="17009"><span class="lineNum">   17009 </span>            : #endif</a>
<a name="17010"><span class="lineNum">   17010 </span>            :                             // DQ (10/6/2015): Calls to the set_parent member function do NOT cause the either node to be marked as isModfied.</a>
<a name="17011"><span class="lineNum">   17011 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(ifStatement);</span></a>
<a name="17012"><span class="lineNum">   17012 </span>            : #if 0</a>
<a name="17013"><span class="lineNum">   17013 </span>            :                                printf (&quot;DONE: Calling set_parent on s = %p = %n \n&quot;,s,s-&gt;class_name().c_str());</a>
<a name="17014"><span class="lineNum">   17014 </span>            : #endif</a>
<a name="17015"><span class="lineNum">   17015 </span><span class="lineNoCov">          0 :                                *i = NULL;</span></a>
<a name="17016"><span class="lineNum">   17016 </span>            : #if 0</a>
<a name="17017"><span class="lineNum">   17017 </span>            :                                printf (&quot;Mark as NOT modified after calling set_false_body on ifStatement = %p = %n \n&quot;,ifStatement,ifStatement-&gt;class_name().c_str());</a>
<a name="17018"><span class="lineNum">   17018 </span>            : #endif</a>
<a name="17019"><span class="lineNum">   17019 </span>            :                             // ifStatement-&gt;set_isModified(false);</a>
<a name="17020"><span class="lineNum">   17020 </span>            : #if 0</a>
<a name="17021"><span class="lineNum">   17021 </span>            :                                printf (&quot;Error: case not handled in case V_SgIfStmt: parentOfBlock = %p = %s \n&quot;,parentOfBlock,parentOfBlock-&gt;class_name().c_str());</a>
<a name="17022"><span class="lineNum">   17022 </span>            :                                ROSE_ABORT();</a>
<a name="17023"><span class="lineNum">   17023 </span>            : #endif</a>
<a name="17024"><span class="lineNum">   17024 </span>            :                              }</a>
<a name="17025"><span class="lineNum">   17025 </span>            :                           break;</a>
<a name="17026"><span class="lineNum">   17026 </span>            :                         }</a>
<a name="17027"><span class="lineNum">   17027 </span>            : </a>
<a name="17028"><span class="lineNum">   17028 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17029"><span class="lineNum">   17029 </span><span class="lineNoCov">          0 :                      case V_SgWhileStmt:</span></a>
<a name="17030"><span class="lineNum">   17030 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17031"><span class="lineNum">   17031 </span><span class="lineNoCov">          0 :                           SgWhileStmt* whileStatement = isSgWhileStmt(parentOfBlock);</span></a>
<a name="17032"><span class="lineNum">   17032 </span><span class="lineNoCov">          0 :                           if (b == whileStatement-&gt;get_body())</span></a>
<a name="17033"><span class="lineNum">   17033 </span>            :                              {</a>
<a name="17034"><span class="lineNum">   17034 </span><span class="lineNoCov">          0 :                                whileStatement-&gt;set_body(s);</span></a>
<a name="17035"><span class="lineNum">   17035 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(whileStatement);</span></a>
<a name="17036"><span class="lineNum">   17036 </span>            :                              }</a>
<a name="17037"><span class="lineNum">   17037 </span>            :                           break;</a>
<a name="17038"><span class="lineNum">   17038 </span>            :                         }</a>
<a name="17039"><span class="lineNum">   17039 </span>            : </a>
<a name="17040"><span class="lineNum">   17040 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17041"><span class="lineNum">   17041 </span><span class="lineNoCov">          0 :                      case V_SgSwitchStatement:</span></a>
<a name="17042"><span class="lineNum">   17042 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17043"><span class="lineNum">   17043 </span><span class="lineNoCov">          0 :                           SgSwitchStatement* switchStatement = isSgSwitchStatement(parentOfBlock);</span></a>
<a name="17044"><span class="lineNum">   17044 </span><span class="lineNoCov">          0 :                           if (b == switchStatement-&gt;get_body())</span></a>
<a name="17045"><span class="lineNum">   17045 </span>            :                              {</a>
<a name="17046"><span class="lineNum">   17046 </span><span class="lineNoCov">          0 :                                switchStatement-&gt;set_body(s);</span></a>
<a name="17047"><span class="lineNum">   17047 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(switchStatement);</span></a>
<a name="17048"><span class="lineNum">   17048 </span>            :                              }</a>
<a name="17049"><span class="lineNum">   17049 </span>            :                           break;</a>
<a name="17050"><span class="lineNum">   17050 </span>            :                         }</a>
<a name="17051"><span class="lineNum">   17051 </span>            : </a>
<a name="17052"><span class="lineNum">   17052 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17053"><span class="lineNum">   17053 </span><span class="lineNoCov">          0 :                      case V_SgForStatement:</span></a>
<a name="17054"><span class="lineNum">   17054 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17055"><span class="lineNum">   17055 </span><span class="lineNoCov">          0 :                           SgForStatement* forStatement = isSgForStatement(parentOfBlock);</span></a>
<a name="17056"><span class="lineNum">   17056 </span><span class="lineNoCov">          0 :                           if (b == forStatement-&gt;get_loop_body())</span></a>
<a name="17057"><span class="lineNum">   17057 </span>            :                              {</a>
<a name="17058"><span class="lineNum">   17058 </span><span class="lineNoCov">          0 :                                forStatement-&gt;set_loop_body(s);</span></a>
<a name="17059"><span class="lineNum">   17059 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(forStatement);</span></a>
<a name="17060"><span class="lineNum">   17060 </span>            :                              }</a>
<a name="17061"><span class="lineNum">   17061 </span>            :                           break;</a>
<a name="17062"><span class="lineNum">   17062 </span>            :                         }</a>
<a name="17063"><span class="lineNum">   17063 </span>            : </a>
<a name="17064"><span class="lineNum">   17064 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17065"><span class="lineNum">   17065 </span><span class="lineNoCov">          0 :                      case V_SgCaseOptionStmt:</span></a>
<a name="17066"><span class="lineNum">   17066 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17067"><span class="lineNum">   17067 </span><span class="lineNoCov">          0 :                           SgCaseOptionStmt* caseOptionStatement = isSgCaseOptionStmt(parentOfBlock);</span></a>
<a name="17068"><span class="lineNum">   17068 </span><span class="lineNoCov">          0 :                           if (b == caseOptionStatement-&gt;get_body())</span></a>
<a name="17069"><span class="lineNum">   17069 </span>            :                              {</a>
<a name="17070"><span class="lineNum">   17070 </span><span class="lineNoCov">          0 :                                caseOptionStatement-&gt;set_body(s);</span></a>
<a name="17071"><span class="lineNum">   17071 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(caseOptionStatement);</span></a>
<a name="17072"><span class="lineNum">   17072 </span>            :                              }</a>
<a name="17073"><span class="lineNum">   17073 </span>            :                           break;</a>
<a name="17074"><span class="lineNum">   17074 </span>            :                         }</a>
<a name="17075"><span class="lineNum">   17075 </span>            : </a>
<a name="17076"><span class="lineNum">   17076 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17077"><span class="lineNum">   17077 </span><span class="lineNoCov">          0 :                      case V_SgDefaultOptionStmt:</span></a>
<a name="17078"><span class="lineNum">   17078 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17079"><span class="lineNum">   17079 </span><span class="lineNoCov">          0 :                           SgDefaultOptionStmt* defaultOptionStatement = isSgDefaultOptionStmt(parentOfBlock);</span></a>
<a name="17080"><span class="lineNum">   17080 </span><span class="lineNoCov">          0 :                           if (b == defaultOptionStatement-&gt;get_body())</span></a>
<a name="17081"><span class="lineNum">   17081 </span>            :                              {</a>
<a name="17082"><span class="lineNum">   17082 </span><span class="lineNoCov">          0 :                                defaultOptionStatement-&gt;set_body(s);</span></a>
<a name="17083"><span class="lineNum">   17083 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(defaultOptionStatement);</span></a>
<a name="17084"><span class="lineNum">   17084 </span>            :                              }</a>
<a name="17085"><span class="lineNum">   17085 </span>            :                           break;</a>
<a name="17086"><span class="lineNum">   17086 </span>            :                         }</a>
<a name="17087"><span class="lineNum">   17087 </span>            : </a>
<a name="17088"><span class="lineNum">   17088 </span>            :                   // DQ (1/21/2015): Adding support for de-normalization of while statements with normalized bodies.</a>
<a name="17089"><span class="lineNum">   17089 </span><span class="lineNoCov">          0 :                      case V_SgDoWhileStmt:</span></a>
<a name="17090"><span class="lineNum">   17090 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17091"><span class="lineNum">   17091 </span><span class="lineNoCov">          0 :                           SgDoWhileStmt* doWhileStatement = isSgDoWhileStmt(parentOfBlock);</span></a>
<a name="17092"><span class="lineNum">   17092 </span><span class="lineNoCov">          0 :                           if (b == doWhileStatement-&gt;get_body())</span></a>
<a name="17093"><span class="lineNum">   17093 </span>            :                              {</a>
<a name="17094"><span class="lineNum">   17094 </span><span class="lineNoCov">          0 :                                doWhileStatement-&gt;set_body(s);</span></a>
<a name="17095"><span class="lineNum">   17095 </span><span class="lineNoCov">          0 :                                s-&gt;set_parent(doWhileStatement);</span></a>
<a name="17096"><span class="lineNum">   17096 </span>            :                              }</a>
<a name="17097"><span class="lineNum">   17097 </span>            :                           break;</a>
<a name="17098"><span class="lineNum">   17098 </span>            :                         }</a>
<a name="17099"><span class="lineNum">   17099 </span>            : </a>
<a name="17100"><span class="lineNum">   17100 </span><span class="lineNoCov">          0 :                      default:</span></a>
<a name="17101"><span class="lineNum">   17101 </span><span class="lineNoCov">          0 :                         {</span></a>
<a name="17102"><span class="lineNum">   17102 </span><span class="lineNoCov">          0 :                           printf (&quot;Error: case not handled in switch: parentOfBlock = %p = %s \n&quot;,parentOfBlock,parentOfBlock-&gt;class_name().c_str());</span></a>
<a name="17103"><span class="lineNum">   17103 </span><span class="lineNoCov">          0 :                           ROSE_ABORT();</span></a>
<a name="17104"><span class="lineNum">   17104 </span>            :                         }</a>
<a name="17105"><span class="lineNum">   17105 </span>            :                    }</a>
<a name="17106"><span class="lineNum">   17106 </span>            : </a>
<a name="17107"><span class="lineNum">   17107 </span>            :              // DQ (10/6/2015): Added code to reset isModified flag if it was only modified by this function.</a>
<a name="17108"><span class="lineNum">   17108 </span><span class="lineNoCov">          0 :                 if (wasPreviouslyModified == false)</span></a>
<a name="17109"><span class="lineNum">   17109 </span>            :                    {</a>
<a name="17110"><span class="lineNum">   17110 </span><span class="lineNoCov">          0 :                      if (parentOfBlock-&gt;get_isModified() == true)</span></a>
<a name="17111"><span class="lineNum">   17111 </span>            :                         {</a>
<a name="17112"><span class="lineNum">   17112 </span>            : #if 0</a>
<a name="17113"><span class="lineNum">   17113 </span>            :                           printf (&quot;In SageInterface::cleanupNontransformedBasicBlockNode(): parentOfBlock reset to FALSE after IR node member function call (e.g. set_body()): parentOfBlock = %p = %s \n&quot;,parentOfBlock,parentOfBlock-&gt;class_name().c_str());</a>
<a name="17114"><span class="lineNum">   17114 </span>            : #endif</a>
<a name="17115"><span class="lineNum">   17115 </span><span class="lineNoCov">          0 :                           parentOfBlock-&gt;set_isModified(false);</span></a>
<a name="17116"><span class="lineNum">   17116 </span>            :                         }</a>
<a name="17117"><span class="lineNum">   17117 </span>            : </a>
<a name="17118"><span class="lineNum">   17118 </span>            :                    }</a>
<a name="17119"><span class="lineNum">   17119 </span>            : #if 0</a>
<a name="17120"><span class="lineNum">   17120 </span>            :                 printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="17121"><span class="lineNum">   17121 </span>            :                 ROSE_ABORT();</a>
<a name="17122"><span class="lineNum">   17122 </span>            : #endif</a>
<a name="17123"><span class="lineNum">   17123 </span>            :              }</a>
<a name="17124"><span class="lineNum">   17124 </span>            :         }</a>
<a name="17125"><span class="lineNum">   17125 </span>            : </a>
<a name="17126"><span class="lineNum">   17126 </span>            : #if 0</a>
<a name="17127"><span class="lineNum">   17127 </span>            :      printf (&quot;Leaving SageInterface::cleanupNontransformedBasicBlockNode(): addedBasicBlockNodes.size() = %zu \n&quot;,addedBasicBlockNodes.size());</a>
<a name="17128"><span class="lineNum">   17128 </span>            : #endif</a>
<a name="17129"><span class="lineNum">   17129 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="17130"><span class="lineNum">   17130 </span>            : </a>
<a name="17131"><span class="lineNum">   17131 </span>            : </a>
<a name="17132"><span class="lineNum">   17132 </span><span class="lineCov">          1 :   SgBasicBlock* SageInterface::ensureBasicBlockAsFalseBodyOfIf(SgIfStmt* fs , bool createEmptyBody /* = true*/) {</span></a>
<a name="17133"><span class="lineNum">   17133 </span><span class="lineCov">          1 :     SgStatement* b = fs-&gt;get_false_body();</span></a>
<a name="17134"><span class="lineNum">   17134 </span>            :     // if no false body at all AND no-create-empty-body</a>
<a name="17135"><span class="lineNum">   17135 </span><span class="lineCov">          1 :     if (!createEmptyBody &amp;&amp; (b == NULL || isSgNullStatement(b)))</span></a>
<a name="17136"><span class="lineNum">   17136 </span><span class="lineNoCov">          0 :       return NULL;</span></a>
<a name="17137"><span class="lineNum">   17137 </span><span class="lineCov">          1 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="17138"><span class="lineNum">   17138 </span><span class="lineCov">          1 :       b = SageBuilder::buildBasicBlock(b); // This works if b is NULL as well (producing an empty block)</span></a>
<a name="17139"><span class="lineNum">   17139 </span><span class="lineCov">          1 :       fs-&gt;set_false_body(b);</span></a>
<a name="17140"><span class="lineNum">   17140 </span><span class="lineCov">          1 :       b-&gt;set_parent(fs);</span></a>
<a name="17141"><span class="lineNum">   17141 </span>            : </a>
<a name="17142"><span class="lineNum">   17142 </span>            :    // DQ (1/18/2015): Save the SgBasicBlock that has been added so that we can undo this transformation later.</a>
<a name="17143"><span class="lineNum">   17143 </span><span class="lineCov">          1 :       recordNormalizations(b);</span></a>
<a name="17144"><span class="lineNum">   17144 </span>            :     }</a>
<a name="17145"><span class="lineNum">   17145 </span><span class="lineCov">          1 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="17146"><span class="lineNum">   17146 </span><span class="lineCov">          1 :     return isSgBasicBlock(b);</span></a>
<a name="17147"><span class="lineNum">   17147 </span>            :   }</a>
<a name="17148"><span class="lineNum">   17148 </span>            : </a>
<a name="17149"><span class="lineNum">   17149 </span><span class="lineNoCov">          0 :   SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfCatch(SgCatchOptionStmt* fs) {</span></a>
<a name="17150"><span class="lineNum">   17150 </span><span class="lineNoCov">          0 :     SgStatement* b = fs-&gt;get_body();</span></a>
<a name="17151"><span class="lineNum">   17151 </span><span class="lineNoCov">          0 :     if (!isSgBasicBlock(b)) {</span></a>
<a name="17152"><span class="lineNum">   17152 </span><span class="lineNoCov">          0 :       b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="17153"><span class="lineNum">   17153 </span><span class="lineNoCov">          0 :       fs-&gt;set_body(b);</span></a>
<a name="17154"><span class="lineNum">   17154 </span><span class="lineNoCov">          0 :       b-&gt;set_parent(fs);</span></a>
<a name="17155"><span class="lineNum">   17155 </span>            :     }</a>
<a name="17156"><span class="lineNum">   17156 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="17157"><span class="lineNum">   17157 </span><span class="lineNoCov">          0 :     return isSgBasicBlock(b);</span></a>
<a name="17158"><span class="lineNum">   17158 </span>            :   }</a>
<a name="17159"><span class="lineNum">   17159 </span>            : </a>
<a name="17160"><span class="lineNum">   17160 </span><span class="lineNoCov">          0 : SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfOmpBodyStmt(SgUpirBodyStatement* fs)</span></a>
<a name="17161"><span class="lineNum">   17161 </span>            : {</a>
<a name="17162"><span class="lineNum">   17162 </span><span class="lineNoCov">          0 :   SgStatement* b = fs-&gt;get_body();</span></a>
<a name="17163"><span class="lineNum">   17163 </span><span class="lineNoCov">          0 :   if (!isSgBasicBlock(b)) {</span></a>
<a name="17164"><span class="lineNum">   17164 </span><span class="lineNoCov">          0 :     b = SageBuilder::buildBasicBlock(b);</span></a>
<a name="17165"><span class="lineNum">   17165 </span><span class="lineNoCov">          0 :     fs-&gt;set_body(b);</span></a>
<a name="17166"><span class="lineNum">   17166 </span><span class="lineNoCov">          0 :     b-&gt;set_parent(fs);</span></a>
<a name="17167"><span class="lineNum">   17167 </span>            :   }</a>
<a name="17168"><span class="lineNum">   17168 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (isSgBasicBlock(b));</span></a>
<a name="17169"><span class="lineNum">   17169 </span><span class="lineNoCov">          0 :   return isSgBasicBlock(b);</span></a>
<a name="17170"><span class="lineNum">   17170 </span>            : }</a>
<a name="17171"><span class="lineNum">   17171 </span>            : </a>
<a name="17172"><span class="lineNum">   17172 </span><span class="lineCov">          5 : bool SageInterface::isBodyStatement (SgStatement* s)</span></a>
<a name="17173"><span class="lineNum">   17173 </span>            : {</a>
<a name="17174"><span class="lineNum">   17174 </span><span class="lineCov">          5 :   bool rt = false;</span></a>
<a name="17175"><span class="lineNum">   17175 </span><span class="lineCov">          5 :   ROSE_ASSERT(s);</span></a>
<a name="17176"><span class="lineNum">   17176 </span><span class="lineCov">          5 :   SgLocatedNode* p = isSgLocatedNode(s-&gt;get_parent());</span></a>
<a name="17177"><span class="lineNum">   17177 </span><span class="lineCov">          5 :   ROSE_ASSERT(p);</span></a>
<a name="17178"><span class="lineNum">   17178 </span>            : </a>
<a name="17179"><span class="lineNum">   17179 </span><span class="lineCov">          5 :   switch (p-&gt;variantT())</span></a>
<a name="17180"><span class="lineNum">   17180 </span>            :   {</a>
<a name="17181"><span class="lineNum">   17181 </span><span class="lineNoCov">          0 :     case V_SgForStatement:</span></a>
<a name="17182"><span class="lineNum">   17182 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17183"><span class="lineNum">   17183 </span><span class="lineNoCov">          0 :         if (isSgForStatement(p)-&gt;get_loop_body() == s)</span></a>
<a name="17184"><span class="lineNum">   17184 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17185"><span class="lineNum">   17185 </span>            :         break;</a>
<a name="17186"><span class="lineNum">   17186 </span>            :       }</a>
<a name="17187"><span class="lineNum">   17187 </span><span class="lineNoCov">          0 :     case V_SgUpcForAllStatement: // PP</span></a>
<a name="17188"><span class="lineNum">   17188 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17189"><span class="lineNum">   17189 </span><span class="lineNoCov">          0 :         SgUpcForAllStatement&amp; upcforall = *isSgUpcForAllStatement(p);</span></a>
<a name="17190"><span class="lineNum">   17190 </span><span class="lineNoCov">          0 :         if (upcforall.get_loop_body() == s)</span></a>
<a name="17191"><span class="lineNum">   17191 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17192"><span class="lineNum">   17192 </span>            :         break;</a>
<a name="17193"><span class="lineNum">   17193 </span>            :       }</a>
<a name="17194"><span class="lineNum">   17194 </span><span class="lineNoCov">          0 :     case V_SgWhileStmt:</span></a>
<a name="17195"><span class="lineNum">   17195 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17196"><span class="lineNum">   17196 </span><span class="lineNoCov">          0 :         if (isSgWhileStmt(p)-&gt;get_body() == s)</span></a>
<a name="17197"><span class="lineNum">   17197 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17198"><span class="lineNum">   17198 </span>            :         break;</a>
<a name="17199"><span class="lineNum">   17199 </span>            :       }</a>
<a name="17200"><span class="lineNum">   17200 </span><span class="lineNoCov">          0 :     case V_SgDoWhileStmt:</span></a>
<a name="17201"><span class="lineNum">   17201 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17202"><span class="lineNum">   17202 </span><span class="lineNoCov">          0 :         if (isSgDoWhileStmt(p)-&gt;get_body() == s)</span></a>
<a name="17203"><span class="lineNum">   17203 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17204"><span class="lineNum">   17204 </span>            :         break;</a>
<a name="17205"><span class="lineNum">   17205 </span>            :       }</a>
<a name="17206"><span class="lineNum">   17206 </span><span class="lineNoCov">          0 :     case V_SgSwitchStatement:</span></a>
<a name="17207"><span class="lineNum">   17207 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17208"><span class="lineNum">   17208 </span><span class="lineNoCov">          0 :         if (isSgSwitchStatement(p)-&gt;get_body() == s)</span></a>
<a name="17209"><span class="lineNum">   17209 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17210"><span class="lineNum">   17210 </span>            :         break;</a>
<a name="17211"><span class="lineNum">   17211 </span>            :       }</a>
<a name="17212"><span class="lineNum">   17212 </span><span class="lineNoCov">          0 :     case V_SgCaseOptionStmt:</span></a>
<a name="17213"><span class="lineNum">   17213 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17214"><span class="lineNum">   17214 </span><span class="lineNoCov">          0 :           if (isSgCaseOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17215"><span class="lineNum">   17215 </span><span class="lineNoCov">          0 :               rt = true;</span></a>
<a name="17216"><span class="lineNum">   17216 </span>            :           break;</a>
<a name="17217"><span class="lineNum">   17217 </span>            :       }</a>
<a name="17218"><span class="lineNum">   17218 </span><span class="lineNoCov">          0 :     case V_SgDefaultOptionStmt:</span></a>
<a name="17219"><span class="lineNum">   17219 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17220"><span class="lineNum">   17220 </span><span class="lineNoCov">          0 :           if (isSgDefaultOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17221"><span class="lineNum">   17221 </span><span class="lineNoCov">          0 :               rt = true;</span></a>
<a name="17222"><span class="lineNum">   17222 </span>            :           break;</a>
<a name="17223"><span class="lineNum">   17223 </span>            :       }</a>
<a name="17224"><span class="lineNum">   17224 </span><span class="lineNoCov">          0 :     case V_SgCatchOptionStmt:</span></a>
<a name="17225"><span class="lineNum">   17225 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17226"><span class="lineNum">   17226 </span><span class="lineNoCov">          0 :         if (isSgCatchOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17227"><span class="lineNum">   17227 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17228"><span class="lineNum">   17228 </span>            :         break;</a>
<a name="17229"><span class="lineNum">   17229 </span>            :       }</a>
<a name="17230"><span class="lineNum">   17230 </span><span class="lineCov">          4 :     case V_SgIfStmt:</span></a>
<a name="17231"><span class="lineNum">   17231 </span><span class="lineCov">          4 :       {</span></a>
<a name="17232"><span class="lineNum">   17232 </span><span class="lineCov">          4 :         if (isSgIfStmt(p)-&gt;get_true_body() == s)</span></a>
<a name="17233"><span class="lineNum">   17233 </span>            :           rt = true;</a>
<a name="17234"><span class="lineNum">   17234 </span><span class="lineCov">          2 :         else if (isSgIfStmt(p)-&gt;get_false_body() == s)</span></a>
<a name="17235"><span class="lineNum">   17235 </span><span class="lineCov">          2 :           rt = true;</span></a>
<a name="17236"><span class="lineNum">   17236 </span>            :         break;</a>
<a name="17237"><span class="lineNum">   17237 </span>            :       }</a>
<a name="17238"><span class="lineNum">   17238 </span><span class="lineCov">          1 :     default:</span></a>
<a name="17239"><span class="lineNum">   17239 </span><span class="lineCov">          1 :       {</span></a>
<a name="17240"><span class="lineNum">   17240 </span><span class="lineCov">          1 :         if (isSgUpirBodyStatement(p))</span></a>
<a name="17241"><span class="lineNum">   17241 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="17242"><span class="lineNum">   17242 </span>            :         break;</a>
<a name="17243"><span class="lineNum">   17243 </span>            :       }</a>
<a name="17244"><span class="lineNum">   17244 </span>            :   }</a>
<a name="17245"><span class="lineNum">   17245 </span><span class="lineCov">          5 :   return rt;</span></a>
<a name="17246"><span class="lineNum">   17246 </span>            : }</a>
<a name="17247"><span class="lineNum">   17247 </span>            : </a>
<a name="17248"><span class="lineNum">   17248 </span>            : //! Make a single statement body to be a basic block. Its parent is if, while, catch, or upc_forall</a>
<a name="17249"><span class="lineNum">   17249 </span>            : //etc.</a>
<a name="17250"><span class="lineNum">   17250 </span><span class="lineCov">          2 : SgBasicBlock * SageInterface::makeSingleStatementBodyToBlock(SgStatement* singleStmt)</span></a>
<a name="17251"><span class="lineNum">   17251 </span>            : {</a>
<a name="17252"><span class="lineNum">   17252 </span><span class="lineCov">          2 :   ROSE_ASSERT (singleStmt != NULL); // not NULL</span></a>
<a name="17253"><span class="lineNum">   17253 </span><span class="lineCov">          2 :   ROSE_ASSERT (isSgBasicBlock(singleStmt) == NULL); //not a block</span></a>
<a name="17254"><span class="lineNum">   17254 </span><span class="lineCov">          2 :   ROSE_ASSERT (isBodyStatement(singleStmt) == true); // is a body statement</span></a>
<a name="17255"><span class="lineNum">   17255 </span>            : </a>
<a name="17256"><span class="lineNum">   17256 </span><span class="lineCov">          2 :   SgBasicBlock* rt = NULL;</span></a>
<a name="17257"><span class="lineNum">   17257 </span>            : </a>
<a name="17258"><span class="lineNum">   17258 </span>            : </a>
<a name="17259"><span class="lineNum">   17259 </span>            : </a>
<a name="17260"><span class="lineNum">   17260 </span><span class="lineCov">          2 :   SgStatement* s = singleStmt;</span></a>
<a name="17261"><span class="lineNum">   17261 </span><span class="lineCov">          2 :   SgLocatedNode* p = isSgLocatedNode(s-&gt;get_parent());</span></a>
<a name="17262"><span class="lineNum">   17262 </span><span class="lineCov">          2 :   ROSE_ASSERT(p);</span></a>
<a name="17263"><span class="lineNum">   17263 </span><span class="lineCov">          2 :   switch (p-&gt;variantT())</span></a>
<a name="17264"><span class="lineNum">   17264 </span>            :   {</a>
<a name="17265"><span class="lineNum">   17265 </span><span class="lineNoCov">          0 :     case V_SgForStatement:</span></a>
<a name="17266"><span class="lineNum">   17266 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17267"><span class="lineNum">   17267 </span><span class="lineNoCov">          0 :         if (isSgForStatement(p)-&gt;get_loop_body() == s)</span></a>
<a name="17268"><span class="lineNum">   17268 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfFor(isSgForStatement(p));</span></a>
<a name="17269"><span class="lineNum">   17269 </span>            :         break;</a>
<a name="17270"><span class="lineNum">   17270 </span>            :       }</a>
<a name="17271"><span class="lineNum">   17271 </span><span class="lineNoCov">          0 :     case V_SgUpcForAllStatement: // PP</span></a>
<a name="17272"><span class="lineNum">   17272 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17273"><span class="lineNum">   17273 </span><span class="lineNoCov">          0 :         SgUpcForAllStatement&amp; upcforall = *isSgUpcForAllStatement(p);</span></a>
<a name="17274"><span class="lineNum">   17274 </span>            : </a>
<a name="17275"><span class="lineNum">   17275 </span><span class="lineNoCov">          0 :         if (upcforall.get_loop_body() == s)</span></a>
<a name="17276"><span class="lineNum">   17276 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfUpcForAll(&amp;upcforall);</span></a>
<a name="17277"><span class="lineNum">   17277 </span>            :         break;</a>
<a name="17278"><span class="lineNum">   17278 </span>            :       }</a>
<a name="17279"><span class="lineNum">   17279 </span><span class="lineNoCov">          0 :     case V_SgWhileStmt:</span></a>
<a name="17280"><span class="lineNum">   17280 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17281"><span class="lineNum">   17281 </span><span class="lineNoCov">          0 :         if (isSgWhileStmt(p)-&gt;get_body() == s)</span></a>
<a name="17282"><span class="lineNum">   17282 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfWhile(isSgWhileStmt(p));</span></a>
<a name="17283"><span class="lineNum">   17283 </span>            :         break;</a>
<a name="17284"><span class="lineNum">   17284 </span>            :       }</a>
<a name="17285"><span class="lineNum">   17285 </span><span class="lineNoCov">          0 :     case V_SgDoWhileStmt:</span></a>
<a name="17286"><span class="lineNum">   17286 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17287"><span class="lineNum">   17287 </span><span class="lineNoCov">          0 :         if (isSgDoWhileStmt(p)-&gt;get_body() == s)</span></a>
<a name="17288"><span class="lineNum">   17288 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfDoWhile(isSgDoWhileStmt(p));</span></a>
<a name="17289"><span class="lineNum">   17289 </span>            :         break;</a>
<a name="17290"><span class="lineNum">   17290 </span>            :       }</a>
<a name="17291"><span class="lineNum">   17291 </span><span class="lineNoCov">          0 :     case V_SgSwitchStatement:</span></a>
<a name="17292"><span class="lineNum">   17292 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17293"><span class="lineNum">   17293 </span><span class="lineNoCov">          0 :         if (isSgSwitchStatement(p)-&gt;get_body() == s)</span></a>
<a name="17294"><span class="lineNum">   17294 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfSwitch(isSgSwitchStatement(p));</span></a>
<a name="17295"><span class="lineNum">   17295 </span>            :         break;</a>
<a name="17296"><span class="lineNum">   17296 </span>            :       }</a>
<a name="17297"><span class="lineNum">   17297 </span><span class="lineNoCov">          0 :     case V_SgCaseOptionStmt:</span></a>
<a name="17298"><span class="lineNum">   17298 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17299"><span class="lineNum">   17299 </span><span class="lineNoCov">          0 :           if (isSgCaseOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17300"><span class="lineNum">   17300 </span><span class="lineNoCov">          0 :             rt = ensureBasicBlockAsBodyOfCaseOption(isSgCaseOptionStmt(p));</span></a>
<a name="17301"><span class="lineNum">   17301 </span>            :           break;</a>
<a name="17302"><span class="lineNum">   17302 </span>            :       }</a>
<a name="17303"><span class="lineNum">   17303 </span><span class="lineNoCov">          0 :     case V_SgDefaultOptionStmt:</span></a>
<a name="17304"><span class="lineNum">   17304 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17305"><span class="lineNum">   17305 </span><span class="lineNoCov">          0 :           if (isSgDefaultOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17306"><span class="lineNum">   17306 </span><span class="lineNoCov">          0 :             rt = ensureBasicBlockAsBodyOfDefaultOption(isSgDefaultOptionStmt(p));</span></a>
<a name="17307"><span class="lineNum">   17307 </span>            :           break;</a>
<a name="17308"><span class="lineNum">   17308 </span>            :       }</a>
<a name="17309"><span class="lineNum">   17309 </span><span class="lineNoCov">          0 :     case V_SgCatchOptionStmt:</span></a>
<a name="17310"><span class="lineNum">   17310 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17311"><span class="lineNum">   17311 </span><span class="lineNoCov">          0 :         if (isSgCatchOptionStmt(p)-&gt;get_body() == s)</span></a>
<a name="17312"><span class="lineNum">   17312 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfCatch(isSgCatchOptionStmt(p));</span></a>
<a name="17313"><span class="lineNum">   17313 </span>            :         break;</a>
<a name="17314"><span class="lineNum">   17314 </span>            :       }</a>
<a name="17315"><span class="lineNum">   17315 </span><span class="lineCov">          2 :     case V_SgIfStmt:</span></a>
<a name="17316"><span class="lineNum">   17316 </span><span class="lineCov">          2 :       {</span></a>
<a name="17317"><span class="lineNum">   17317 </span><span class="lineCov">          2 :         if (isSgIfStmt(p)-&gt;get_true_body() == s)</span></a>
<a name="17318"><span class="lineNum">   17318 </span><span class="lineCov">          1 :           rt = ensureBasicBlockAsTrueBodyOfIf(isSgIfStmt(p));</span></a>
<a name="17319"><span class="lineNum">   17319 </span><span class="lineCov">          1 :         else if (isSgIfStmt(p)-&gt;get_false_body() == s)</span></a>
<a name="17320"><span class="lineNum">   17320 </span><span class="lineCov">          1 :           rt = ensureBasicBlockAsFalseBodyOfIf(isSgIfStmt(p));</span></a>
<a name="17321"><span class="lineNum">   17321 </span>            :         break;</a>
<a name="17322"><span class="lineNum">   17322 </span>            :       }</a>
<a name="17323"><span class="lineNum">   17323 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="17324"><span class="lineNum">   17324 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="17325"><span class="lineNum">   17325 </span><span class="lineNoCov">          0 :         if (isSgUpirBodyStatement(p))</span></a>
<a name="17326"><span class="lineNum">   17326 </span>            :         {</a>
<a name="17327"><span class="lineNum">   17327 </span><span class="lineNoCov">          0 :           rt = ensureBasicBlockAsBodyOfOmpBodyStmt(isSgUpirBodyStatement(p));</span></a>
<a name="17328"><span class="lineNum">   17328 </span>            :         }</a>
<a name="17329"><span class="lineNum">   17329 </span>            :         break;</a>
<a name="17330"><span class="lineNum">   17330 </span>            :       }</a>
<a name="17331"><span class="lineNum">   17331 </span>            :   }</a>
<a name="17332"><span class="lineNum">   17332 </span><span class="lineCov">          2 :   ROSE_ASSERT (rt != NULL); // the input statement has been confirmed to be a body statement, it must have being processed to be a basic block at this point.</span></a>
<a name="17333"><span class="lineNum">   17333 </span><span class="lineCov">          2 :   return rt;</span></a>
<a name="17334"><span class="lineNum">   17334 </span>            : }</a>
<a name="17335"><span class="lineNum">   17335 </span>            : </a>
<a name="17336"><span class="lineNum">   17336 </span>            : #if 0</a>
<a name="17337"><span class="lineNum">   17337 </span>            : SgLocatedNode* SageInterface::ensureBasicBlockAsParent(SgStatement* s)</a>
<a name="17338"><span class="lineNum">   17338 </span>            : {</a>
<a name="17339"><span class="lineNum">   17339 </span>            :         ROSE_ASSERT(s);</a>
<a name="17340"><span class="lineNum">   17340 </span>            : </a>
<a name="17341"><span class="lineNum">   17341 </span>            :         //Vulov: The parent of a statement is not necessarily a statement. It could be SgStatementExpression</a>
<a name="17342"><span class="lineNum">   17342 </span>            :         SgLocatedNode* p = isSgLocatedNode(s-&gt;get_parent());</a>
<a name="17343"><span class="lineNum">   17343 </span>            :         ROSE_ASSERT(p);</a>
<a name="17344"><span class="lineNum">   17344 </span>            :         switch (p-&gt;variantT())</a>
<a name="17345"><span class="lineNum">   17345 </span>            :         {</a>
<a name="17346"><span class="lineNum">   17346 </span>            :                 case V_SgBasicBlock: return isSgBasicBlock(p);</a>
<a name="17347"><span class="lineNum">   17347 </span>            :                 case V_SgForStatement:</a>
<a name="17348"><span class="lineNum">   17348 </span>            :                 {</a>
<a name="17349"><span class="lineNum">   17349 </span>            :                         if (isSgForStatement(p)-&gt;get_loop_body() == s)</a>
<a name="17350"><span class="lineNum">   17350 </span>            :                                 return ensureBasicBlockAsBodyOfFor(isSgForStatement(p));</a>
<a name="17351"><span class="lineNum">   17351 </span>            :                         else if (isSgForStatement(p)-&gt;get_test() == s)</a>
<a name="17352"><span class="lineNum">   17352 </span>            :                         {</a>
<a name="17353"><span class="lineNum">   17353 </span>            :                         }</a>
<a name="17354"><span class="lineNum">   17354 </span>            :                         else if (isSgForStatement(p)-&gt;get_for_init_stmt() == s)</a>
<a name="17355"><span class="lineNum">   17355 </span>            :                         {</a>
<a name="17356"><span class="lineNum">   17356 </span>            :                         }</a>
<a name="17357"><span class="lineNum">   17357 </span>            :                         else ROSE_ABORT();</a>
<a name="17358"><span class="lineNum">   17358 </span>            :                         break;</a>
<a name="17359"><span class="lineNum">   17359 </span>            :                 }</a>
<a name="17360"><span class="lineNum">   17360 </span>            :                 case V_SgUpcForAllStatement: // PP</a>
<a name="17361"><span class="lineNum">   17361 </span>            :                 {</a>
<a name="17362"><span class="lineNum">   17362 </span>            :                   SgUpcForAllStatement&amp; upcforall = *isSgUpcForAllStatement(p);</a>
<a name="17363"><span class="lineNum">   17363 </span>            : </a>
<a name="17364"><span class="lineNum">   17364 </span>            :                   if (upcforall.get_loop_body() == s)</a>
<a name="17365"><span class="lineNum">   17365 </span>            :                     return ensureBasicBlockAsBodyOfUpcForAll(&amp;upcforall);</a>
<a name="17366"><span class="lineNum">   17366 </span>            : </a>
<a name="17367"><span class="lineNum">   17367 </span>            :                   ROSE_ASSERT(  (s == upcforall.get_for_init_stmt())</a>
<a name="17368"><span class="lineNum">   17368 </span>            :                       || (s == upcforall.get_test())</a>
<a name="17369"><span class="lineNum">   17369 </span>            :                       );</a>
<a name="17370"><span class="lineNum">   17370 </span>            :                   break;</a>
<a name="17371"><span class="lineNum">   17371 </span>            :                 }</a>
<a name="17372"><span class="lineNum">   17372 </span>            :                 case V_SgWhileStmt:</a>
<a name="17373"><span class="lineNum">   17373 </span>            :                 {</a>
<a name="17374"><span class="lineNum">   17374 </span>            :                         if (isSgWhileStmt(p)-&gt;get_body() == s)</a>
<a name="17375"><span class="lineNum">   17375 </span>            :                                 return ensureBasicBlockAsBodyOfWhile(isSgWhileStmt(p));</a>
<a name="17376"><span class="lineNum">   17376 </span>            :                         else if (isSgWhileStmt(p)-&gt;get_condition() == s)</a>
<a name="17377"><span class="lineNum">   17377 </span>            :                         {</a>
<a name="17378"><span class="lineNum">   17378 </span>            :                         }</a>
<a name="17379"><span class="lineNum">   17379 </span>            :                         else ROSE_ABORT();</a>
<a name="17380"><span class="lineNum">   17380 </span>            :                         break;</a>
<a name="17381"><span class="lineNum">   17381 </span>            :                 }</a>
<a name="17382"><span class="lineNum">   17382 </span>            :                 case V_SgDoWhileStmt:</a>
<a name="17383"><span class="lineNum">   17383 </span>            :                 {</a>
<a name="17384"><span class="lineNum">   17384 </span>            :                         if (isSgDoWhileStmt(p)-&gt;get_body() == s)</a>
<a name="17385"><span class="lineNum">   17385 </span>            :                                 return ensureBasicBlockAsBodyOfDoWhile(isSgDoWhileStmt(p));</a>
<a name="17386"><span class="lineNum">   17386 </span>            :                         else if (isSgDoWhileStmt(p)-&gt;get_condition() == s)</a>
<a name="17387"><span class="lineNum">   17387 </span>            :                         {</a>
<a name="17388"><span class="lineNum">   17388 </span>            :                         }</a>
<a name="17389"><span class="lineNum">   17389 </span>            :                         else ROSE_ABORT();</a>
<a name="17390"><span class="lineNum">   17390 </span>            :                         break;</a>
<a name="17391"><span class="lineNum">   17391 </span>            :                 }</a>
<a name="17392"><span class="lineNum">   17392 </span>            :                 case V_SgSwitchStatement:</a>
<a name="17393"><span class="lineNum">   17393 </span>            :                 {</a>
<a name="17394"><span class="lineNum">   17394 </span>            :                         if (isSgSwitchStatement(p)-&gt;get_body() == s)</a>
<a name="17395"><span class="lineNum">   17395 </span>            :                                 return ensureBasicBlockAsBodyOfSwitch(isSgSwitchStatement(p));</a>
<a name="17396"><span class="lineNum">   17396 </span>            :                         else if (isSgSwitchStatement(p)-&gt;get_item_selector() == s)</a>
<a name="17397"><span class="lineNum">   17397 </span>            :                         {</a>
<a name="17398"><span class="lineNum">   17398 </span>            :                         }</a>
<a name="17399"><span class="lineNum">   17399 </span>            :                         else ROSE_ABORT();</a>
<a name="17400"><span class="lineNum">   17400 </span>            :                         break;</a>
<a name="17401"><span class="lineNum">   17401 </span>            :                 }</a>
<a name="17402"><span class="lineNum">   17402 </span>            :                 case V_SgCatchOptionStmt:</a>
<a name="17403"><span class="lineNum">   17403 </span>            :                 {</a>
<a name="17404"><span class="lineNum">   17404 </span>            :                         if (isSgCatchOptionStmt(p)-&gt;get_body() == s)</a>
<a name="17405"><span class="lineNum">   17405 </span>            :                                 return ensureBasicBlockAsBodyOfCatch(isSgCatchOptionStmt(p));</a>
<a name="17406"><span class="lineNum">   17406 </span>            :                         else if (isSgCatchOptionStmt(p)-&gt;get_condition() == s)</a>
<a name="17407"><span class="lineNum">   17407 </span>            :                         {</a>
<a name="17408"><span class="lineNum">   17408 </span>            :                         }</a>
<a name="17409"><span class="lineNum">   17409 </span>            :                         else ROSE_ABORT();</a>
<a name="17410"><span class="lineNum">   17410 </span>            :                         break;</a>
<a name="17411"><span class="lineNum">   17411 </span>            :                 }</a>
<a name="17412"><span class="lineNum">   17412 </span>            :                 case V_SgIfStmt:</a>
<a name="17413"><span class="lineNum">   17413 </span>            :                 {</a>
<a name="17414"><span class="lineNum">   17414 </span>            :                         if (isSgIfStmt(p)-&gt;get_true_body() == s)</a>
<a name="17415"><span class="lineNum">   17415 </span>            :                                 return ensureBasicBlockAsTrueBodyOfIf(isSgIfStmt(p));</a>
<a name="17416"><span class="lineNum">   17416 </span>            :                         else if (isSgIfStmt(p)-&gt;get_false_body() == s)</a>
<a name="17417"><span class="lineNum">   17417 </span>            :                                 return ensureBasicBlockAsFalseBodyOfIf(isSgIfStmt(p));</a>
<a name="17418"><span class="lineNum">   17418 </span>            :                         else if (isSgIfStmt(p)-&gt;get_conditional() == s)</a>
<a name="17419"><span class="lineNum">   17419 </span>            :                         {</a>
<a name="17420"><span class="lineNum">   17420 </span>            :                         }</a>
<a name="17421"><span class="lineNum">   17421 </span>            :                         else ROSE_ABORT();</a>
<a name="17422"><span class="lineNum">   17422 </span>            :                         break;</a>
<a name="17423"><span class="lineNum">   17423 </span>            :                 }</a>
<a name="17424"><span class="lineNum">   17424 </span>            :                 default:</a>
<a name="17425"><span class="lineNum">   17425 </span>            :                 {</a>
<a name="17426"><span class="lineNum">   17426 </span>            :                         if (isSgUpirBodyStatement(p))</a>
<a name="17427"><span class="lineNum">   17427 </span>            :                         {</a>
<a name="17428"><span class="lineNum">   17428 </span>            :                                 return ensureBasicBlockAsBodyOfOmpBodyStmt(isSgUpirBodyStatement(p));</a>
<a name="17429"><span class="lineNum">   17429 </span>            :                         }</a>
<a name="17430"><span class="lineNum">   17430 </span>            :                         else</a>
<a name="17431"><span class="lineNum">   17431 </span>            :                                 // Liao, 7/3/2008 We allow other conditions to fall through,</a>
<a name="17432"><span class="lineNum">   17432 </span>            :                                 // they are legal parents with list of statements as children.</a>
<a name="17433"><span class="lineNum">   17433 </span>            :                                 //cerr &lt;&lt; &quot;Unhandled parent block:&quot;&lt;&lt; p-&gt;class_name() &lt;&lt; endl;</a>
<a name="17434"><span class="lineNum">   17434 </span>            :                                 // ROSE_ASSERT (!&quot;Bad parent in ensureBasicBlockAsParent&quot;);</a>
<a name="17435"><span class="lineNum">   17435 </span>            :                                 break;</a>
<a name="17436"><span class="lineNum">   17436 </span>            :                 }</a>
<a name="17437"><span class="lineNum">   17437 </span>            :         }</a>
<a name="17438"><span class="lineNum">   17438 </span>            :         return p;</a>
<a name="17439"><span class="lineNum">   17439 </span>            : }</a>
<a name="17440"><span class="lineNum">   17440 </span>            : </a>
<a name="17441"><span class="lineNum">   17441 </span>            :   void SageInterface::changeAllLoopBodiesToBlocks(SgNode* top) {</a>
<a name="17442"><span class="lineNum">   17442 </span>            :     cerr&lt;&lt;&quot;Warning: SageInterface::changeAllLoopBodiesToBlocks() is being replaced by SageInterface::changeAllBodiesToBlocks().&quot;&lt;&lt;endl;</a>
<a name="17443"><span class="lineNum">   17443 </span>            :     cerr&lt;&lt;&quot;Please use SageInterface::changeAllBodiesToBlocks() if you can.&quot;&lt;&lt;endl;</a>
<a name="17444"><span class="lineNum">   17444 </span>            :         changeAllBodiesToBlocks(top) ;</a>
<a name="17445"><span class="lineNum">   17445 </span>            :   }</a>
<a name="17446"><span class="lineNum">   17446 </span>            : </a>
<a name="17447"><span class="lineNum">   17447 </span>            : #endif</a>
<a name="17448"><span class="lineNum">   17448 </span><span class="lineNoCov">          0 :   void SageInterface::changeAllBodiesToBlocks(SgNode* top, bool createEmptyBody /*= true*/ ) {</span></a>
<a name="17449"><span class="lineNum">   17449 </span><span class="lineNoCov">          0 :     class Visitor: public AstSimpleProcessing {</span></a>
<a name="17450"><span class="lineNum">   17450 </span>            :       public:</a>
<a name="17451"><span class="lineNum">   17451 </span>            :       bool allowEmptyBody;</a>
<a name="17452"><span class="lineNum">   17452 </span><span class="lineNoCov">          0 :       Visitor (bool flag):allowEmptyBody(flag) {}</span></a>
<a name="17453"><span class="lineNum">   17453 </span><span class="lineNoCov">          0 :       virtual void visit(SgNode* n) {</span></a>
<a name="17454"><span class="lineNum">   17454 </span>            : </a>
<a name="17455"><span class="lineNum">   17455 </span><span class="lineNoCov">          0 :         bool wasPreviouslyModified = n-&gt;get_isModified();</span></a>
<a name="17456"><span class="lineNum">   17456 </span>            : </a>
<a name="17457"><span class="lineNum">   17457 </span><span class="lineNoCov">          0 :         switch (n-&gt;variantT()) {</span></a>
<a name="17458"><span class="lineNum">   17458 </span><span class="lineNoCov">          0 :           case V_SgForStatement: {</span></a>
<a name="17459"><span class="lineNum">   17459 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfFor(isSgForStatement(n));</span></a>
<a name="17460"><span class="lineNum">   17460 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17461"><span class="lineNum">   17461 </span>            :           }</a>
<a name="17462"><span class="lineNum">   17462 </span><span class="lineNoCov">          0 :           case V_SgWhileStmt: {</span></a>
<a name="17463"><span class="lineNum">   17463 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfWhile(isSgWhileStmt(n));</span></a>
<a name="17464"><span class="lineNum">   17464 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17465"><span class="lineNum">   17465 </span>            :           }</a>
<a name="17466"><span class="lineNum">   17466 </span><span class="lineNoCov">          0 :           case V_SgDoWhileStmt: {</span></a>
<a name="17467"><span class="lineNum">   17467 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfDoWhile(isSgDoWhileStmt(n));</span></a>
<a name="17468"><span class="lineNum">   17468 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17469"><span class="lineNum">   17469 </span>            :           }</a>
<a name="17470"><span class="lineNum">   17470 </span><span class="lineNoCov">          0 :           case V_SgSwitchStatement: {</span></a>
<a name="17471"><span class="lineNum">   17471 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfSwitch(isSgSwitchStatement(n));</span></a>
<a name="17472"><span class="lineNum">   17472 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17473"><span class="lineNum">   17473 </span>            :           }</a>
<a name="17474"><span class="lineNum">   17474 </span><span class="lineNoCov">          0 :           case V_SgIfStmt: {</span></a>
<a name="17475"><span class="lineNum">   17475 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsTrueBodyOfIf(isSgIfStmt(n));</span></a>
<a name="17476"><span class="lineNum">   17476 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsFalseBodyOfIf(isSgIfStmt(n), allowEmptyBody);</span></a>
<a name="17477"><span class="lineNum">   17477 </span>            : #if 0</a>
<a name="17478"><span class="lineNum">   17478 </span>            :          // DQ (10/6/2015): Debugging why changes are being made to the AST for token-based unparsing.</a>
<a name="17479"><span class="lineNum">   17479 </span>            :             printf (&quot;In changeAllBodiesToBlocks(): case SgIfStmt: n-&gt;get_isModified() = %s \n&quot;,n-&gt;get_isModified() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17480"><span class="lineNum">   17480 </span>            : #endif</a>
<a name="17481"><span class="lineNum">   17481 </span>            : #if 0</a>
<a name="17482"><span class="lineNum">   17482 </span>            :          // Reset this to false as a test.</a>
<a name="17483"><span class="lineNum">   17483 </span>            :             if (n-&gt;get_isModified() == true)</a>
<a name="17484"><span class="lineNum">   17484 </span>            :                {</a>
<a name="17485"><span class="lineNum">   17485 </span>            :                  n-&gt;set_isModified(false);</a>
<a name="17486"><span class="lineNum">   17486 </span>            :                  printf (&quot;In changeAllBodiesToBlocks(): AFTER RESET: case SgIfStmt: n-&gt;get_isModified() = %s \n&quot;,n-&gt;get_isModified() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="17487"><span class="lineNum">   17487 </span>            :                }</a>
<a name="17488"><span class="lineNum">   17488 </span>            : #endif</a>
<a name="17489"><span class="lineNum">   17489 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17490"><span class="lineNum">   17490 </span>            :           }</a>
<a name="17491"><span class="lineNum">   17491 </span><span class="lineNoCov">          0 :           case V_SgCatchOptionStmt: {</span></a>
<a name="17492"><span class="lineNum">   17492 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfCatch(isSgCatchOptionStmt(n));</span></a>
<a name="17493"><span class="lineNum">   17493 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17494"><span class="lineNum">   17494 </span>            :           }</a>
<a name="17495"><span class="lineNum">   17495 </span><span class="lineNoCov">          0 :           case V_SgUpcForAllStatement: {</span></a>
<a name="17496"><span class="lineNum">   17496 </span><span class="lineNoCov">          0 :             ensureBasicBlockAsBodyOfUpcForAll(isSgUpcForAllStatement(n));</span></a>
<a name="17497"><span class="lineNum">   17497 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="17498"><span class="lineNum">   17498 </span>            :           }</a>
<a name="17499"><span class="lineNum">   17499 </span>            : </a>
<a name="17500"><span class="lineNum">   17500 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="17501"><span class="lineNum">   17501 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="17502"><span class="lineNum">   17502 </span><span class="lineNoCov">          0 :               if (isSgUpirBodyStatement(n))</span></a>
<a name="17503"><span class="lineNum">   17503 </span><span class="lineNoCov">          0 :                 ensureBasicBlockAsBodyOfOmpBodyStmt(isSgUpirBodyStatement(n));</span></a>
<a name="17504"><span class="lineNum">   17504 </span>            :               break;</a>
<a name="17505"><span class="lineNum">   17505 </span>            :             }</a>
<a name="17506"><span class="lineNum">   17506 </span>            :         }</a>
<a name="17507"><span class="lineNum">   17507 </span>            : </a>
<a name="17508"><span class="lineNum">   17508 </span>            :   // DQ (10/6/2015): Added code to reset isModified flag if it was only modified by this function.</a>
<a name="17509"><span class="lineNum">   17509 </span><span class="lineNoCov">          0 :      if (wasPreviouslyModified == false)</span></a>
<a name="17510"><span class="lineNum">   17510 </span>            :         {</a>
<a name="17511"><span class="lineNum">   17511 </span><span class="lineNoCov">          0 :           if (n-&gt;get_isModified() == true)</span></a>
<a name="17512"><span class="lineNum">   17512 </span>            :              {</a>
<a name="17513"><span class="lineNum">   17513 </span>            : #if 0</a>
<a name="17514"><span class="lineNum">   17514 </span>            :                printf (&quot;In SageInterface::changeAllBodiesToBlocks(): parentOfBlock reset to FALSE after IR node member function call (e.g. set_body()): parentOfBlock = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="17515"><span class="lineNum">   17515 </span>            : #endif</a>
<a name="17516"><span class="lineNum">   17516 </span><span class="lineNoCov">          0 :                n-&gt;set_isModified(false);</span></a>
<a name="17517"><span class="lineNum">   17517 </span>            :              }</a>
<a name="17518"><span class="lineNum">   17518 </span>            : </a>
<a name="17519"><span class="lineNum">   17519 </span>            :         }</a>
<a name="17520"><span class="lineNum">   17520 </span>            : </a>
<a name="17521"><span class="lineNum">   17521 </span><span class="lineNoCov">          0 :       }</span></a>
<a name="17522"><span class="lineNum">   17522 </span>            :     };</a>
<a name="17523"><span class="lineNum">   17523 </span><span class="lineNoCov">          0 :     Visitor(createEmptyBody).traverse(top, postorder);</span></a>
<a name="17524"><span class="lineNum">   17524 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="17525"><span class="lineNum">   17525 </span>            : </a>
<a name="17526"><span class="lineNum">   17526 </span>            : </a>
<a name="17527"><span class="lineNum">   17527 </span>            : // Replace a given expression with a list of statements produced by a</a>
<a name="17528"><span class="lineNum">   17528 </span>            : // generator.  The generator, when given a variable as input, must produce</a>
<a name="17529"><span class="lineNum">   17529 </span>            : // some code which leaves its result in the given variable.  The output</a>
<a name="17530"><span class="lineNum">   17530 </span>            : // from the generator is then inserted into the original program in such a</a>
<a name="17531"><span class="lineNum">   17531 </span>            : // way that whenever the expression had previously been evaluated, the</a>
<a name="17532"><span class="lineNum">   17532 </span>            : // statements produced by the generator are run instead and their result is</a>
<a name="17533"><span class="lineNum">   17533 </span>            : // used in place of the expression.</a>
<a name="17534"><span class="lineNum">   17534 </span>            : // Assumptions: not currently traversing from or the statement it is in</a>
<a name="17535"><span class="lineNum">   17535 </span>            : void</a>
<a name="17536"><span class="lineNum">   17536 </span><span class="lineNoCov">          0 : SageInterface::replaceExpressionWithStatement(SgExpression* from, StatementGenerator* to)</span></a>
<a name="17537"><span class="lineNum">   17537 </span>            :    {</a>
<a name="17538"><span class="lineNum">   17538 </span>            :   // DQ (3/11/2006): The problem here is that the test expression for a &quot;for loop&quot; (SgForStmt)</a>
<a name="17539"><span class="lineNum">   17539 </span>            :   // is assumed to be a SgExpression.  This was changed in Sage III as part of a bugfix and so</a>
<a name="17540"><span class="lineNum">   17540 </span>            :   // the original assumptions upon which this function was based are not incorrect, hence the bug!</a>
<a name="17541"><span class="lineNum">   17541 </span>            :   // Note that a number of cases were changed when this fix was made to SageIII (see documentation</a>
<a name="17542"><span class="lineNum">   17542 </span>            :   // for SgScopeStatement).</a>
<a name="17543"><span class="lineNum">   17543 </span>            : </a>
<a name="17544"><span class="lineNum">   17544 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="17545"><span class="lineNum">   17545 </span><span class="lineNoCov">          0 :      SgStatement*           enclosingStatement      = getStatementOfExpression(from);</span></a>
<a name="17546"><span class="lineNum">   17546 </span><span class="lineNoCov">          0 :      SgExprStatement*       exprStatement           = isSgExprStatement(enclosingStatement);</span></a>
<a name="17547"><span class="lineNum">   17547 </span>            : </a>
<a name="17548"><span class="lineNum">   17548 </span><span class="lineNoCov">          0 :      SgForStatement*        forStatement            = isSgForStatement(enclosingStatement);</span></a>
<a name="17549"><span class="lineNum">   17549 </span><span class="lineNoCov">          0 :      SgReturnStmt*          returnStatement         = isSgReturnStmt(enclosingStatement);</span></a>
<a name="17550"><span class="lineNum">   17550 </span><span class="lineNoCov">          0 :      SgVariableDeclaration* varDeclarationStatement = isSgVariableDeclaration(enclosingStatement);</span></a>
<a name="17551"><span class="lineNum">   17551 </span>            : </a>
<a name="17552"><span class="lineNum">   17552 </span>            : </a>
<a name="17553"><span class="lineNum">   17553 </span>            :   // DQ (3/11/2006): Bugfix for special cases of conditional that are either SgStatement or SgExpression IR nodes.</a>
<a name="17554"><span class="lineNum">   17554 </span>            : </a>
<a name="17555"><span class="lineNum">   17555 </span><span class="lineNoCov">          0 :      ROSE_ASSERT (exprStatement || forStatement || returnStatement || varDeclarationStatement);</span></a>
<a name="17556"><span class="lineNum">   17556 </span>            : </a>
<a name="17557"><span class="lineNum">   17557 </span><span class="lineNoCov">          0 :      if (varDeclarationStatement)</span></a>
<a name="17558"><span class="lineNum">   17558 </span>            :         {</a>
<a name="17559"><span class="lineNum">   17559 </span><span class="lineNoCov">          0 :           replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17560"><span class="lineNum">   17560 </span>            :         }</a>
<a name="17561"><span class="lineNum">   17561 </span>            :        else</a>
<a name="17562"><span class="lineNum">   17562 </span>            :         {</a>
<a name="17563"><span class="lineNum">   17563 </span><span class="lineNoCov">          0 :           SgExpression* root = getRootOfExpression(from);</span></a>
<a name="17564"><span class="lineNum">   17564 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (root);</span></a>
<a name="17565"><span class="lineNum">   17565 </span>            :        // printf (&quot;root = %p \n&quot;,root);</a>
<a name="17566"><span class="lineNum">   17566 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="17567"><span class="lineNum">   17567 </span><span class="lineNoCov">          0 :                if (forStatement &amp;&amp; forStatement-&gt;get_increment() == root)</span></a>
<a name="17568"><span class="lineNum">   17568 </span>            :                   {</a>
<a name="17569"><span class="lineNum">   17569 </span>            :                  // printf (&quot;Convert step of for statement \n&quot;);</a>
<a name="17570"><span class="lineNum">   17570 </span>            :                  // Convert step of for statement</a>
<a name="17571"><span class="lineNum">   17571 </span>            :                  // for (init; test; e) body; (where e contains from) becomes</a>
<a name="17572"><span class="lineNum">   17572 </span>            :                  // for (init; test; ) {</a>
<a name="17573"><span class="lineNum">   17573 </span>            :                  //   body (with &quot;continue&quot; changed to &quot;goto label&quot;);</a>
<a name="17574"><span class="lineNum">   17574 </span>            :                  //   label: e;</a>
<a name="17575"><span class="lineNum">   17575 </span>            :                  // }</a>
<a name="17576"><span class="lineNum">   17576 </span>            :                  // std::cout &lt;&lt; &quot;Converting for step&quot; &lt;&lt; std::endl;</a>
<a name="17577"><span class="lineNum">   17577 </span><span class="lineNoCov">          0 :                     SgExprStatement* incrStmt = SageBuilder::buildExprStatement(forStatement-&gt;get_increment());</span></a>
<a name="17578"><span class="lineNum">   17578 </span><span class="lineNoCov">          0 :                     forStatement-&gt;get_increment()-&gt;set_parent(incrStmt);</span></a>
<a name="17579"><span class="lineNum">   17579 </span>            : </a>
<a name="17580"><span class="lineNum">   17580 </span><span class="lineNoCov">          0 :                     SageInterface::addStepToLoopBody(forStatement, incrStmt);</span></a>
<a name="17581"><span class="lineNum">   17581 </span><span class="lineNoCov">          0 :                     SgNullExpression* ne = buildNullExpression();</span></a>
<a name="17582"><span class="lineNum">   17582 </span><span class="lineNoCov">          0 :                     forStatement-&gt;set_increment(ne);</span></a>
<a name="17583"><span class="lineNum">   17583 </span><span class="lineNoCov">          0 :                     ne-&gt;set_parent(forStatement);</span></a>
<a name="17584"><span class="lineNum">   17584 </span><span class="lineNoCov">          0 :                     replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17585"><span class="lineNum">   17585 </span>            :                   }</a>
<a name="17586"><span class="lineNum">   17586 </span>            :                  else</a>
<a name="17587"><span class="lineNum">   17587 </span>            :                   {</a>
<a name="17588"><span class="lineNum">   17588 </span><span class="lineNoCov">          0 :                     SgStatement* enclosingStmtParent = isSgStatement(enclosingStatement-&gt;get_parent());</span></a>
<a name="17589"><span class="lineNum">   17589 </span><span class="lineNoCov">          0 :                     assert (enclosingStmtParent);</span></a>
<a name="17590"><span class="lineNum">   17590 </span><span class="lineNoCov">          0 :                     SgWhileStmt* whileStatement = isSgWhileStmt(enclosingStmtParent);</span></a>
<a name="17591"><span class="lineNum">   17591 </span><span class="lineNoCov">          0 :                     SgDoWhileStmt* doWhileStatement = isSgDoWhileStmt(enclosingStmtParent);</span></a>
<a name="17592"><span class="lineNum">   17592 </span><span class="lineNoCov">          0 :                     SgIfStmt* ifStatement = isSgIfStmt(enclosingStmtParent);</span></a>
<a name="17593"><span class="lineNum">   17593 </span><span class="lineNoCov">          0 :                     SgSwitchStatement* switchStatement = isSgSwitchStatement(enclosingStmtParent);</span></a>
<a name="17594"><span class="lineNum">   17594 </span><span class="lineNoCov">          0 :                     SgForStatement* enclosingForStatement = isSgForStatement(enclosingStmtParent);</span></a>
<a name="17595"><span class="lineNum">   17595 </span><span class="lineNoCov">          0 :                   if (enclosingForStatement &amp;&amp; enclosingForStatement-&gt;get_test() == exprStatement)</span></a>
<a name="17596"><span class="lineNum">   17596 </span>            :                      {</a>
<a name="17597"><span class="lineNum">   17597 </span>            :                     // printf (&quot;Found the test in the for loop \n&quot;);</a>
<a name="17598"><span class="lineNum">   17598 </span>            :                     // ROSE_ASSERT(false);</a>
<a name="17599"><span class="lineNum">   17599 </span>            : </a>
<a name="17600"><span class="lineNum">   17600 </span>            :                     // Convert test of for statement:</a>
<a name="17601"><span class="lineNum">   17601 </span>            :                     // for (init; e; step) body; (where e contains from) becomes</a>
<a name="17602"><span class="lineNum">   17602 </span>            :                     // for (init; true; step) {</a>
<a name="17603"><span class="lineNum">   17603 </span>            :                     //   bool temp;</a>
<a name="17604"><span class="lineNum">   17604 </span>            :                     //   temp = e;</a>
<a name="17605"><span class="lineNum">   17605 </span>            :                     //   if (!temp) break;</a>
<a name="17606"><span class="lineNum">   17606 </span>            :                     //   body;</a>
<a name="17607"><span class="lineNum">   17607 </span>            :                     // }</a>
<a name="17608"><span class="lineNum">   17608 </span>            :                     // in which &quot;temp = e;&quot; is rewritten further</a>
<a name="17609"><span class="lineNum">   17609 </span>            :                     // std::cout &lt;&lt; &quot;Converting for test&quot; &lt;&lt; std::endl;</a>
<a name="17610"><span class="lineNum">   17610 </span><span class="lineNoCov">          0 :                        pushTestIntoBody(enclosingForStatement);</span></a>
<a name="17611"><span class="lineNum">   17611 </span><span class="lineNoCov">          0 :                        replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17612"><span class="lineNum">   17612 </span>            :                      }</a>
<a name="17613"><span class="lineNum">   17613 </span><span class="lineNoCov">          0 :                   else if (whileStatement &amp;&amp; whileStatement-&gt;get_condition() == exprStatement)</span></a>
<a name="17614"><span class="lineNum">   17614 </span>            :                      {</a>
<a name="17615"><span class="lineNum">   17615 </span>            :                     // printf (&quot;Convert while statements \n&quot;);</a>
<a name="17616"><span class="lineNum">   17616 </span>            :                     // Convert while statement:</a>
<a name="17617"><span class="lineNum">   17617 </span>            :                     // while (e) body; (where e contains from) becomes</a>
<a name="17618"><span class="lineNum">   17618 </span>            :                     // while (true) {</a>
<a name="17619"><span class="lineNum">   17619 </span>            :                     //   bool temp;</a>
<a name="17620"><span class="lineNum">   17620 </span>            :                     //   temp = e;</a>
<a name="17621"><span class="lineNum">   17621 </span>            :                     //   if (!temp) break;</a>
<a name="17622"><span class="lineNum">   17622 </span>            :                     //   body;</a>
<a name="17623"><span class="lineNum">   17623 </span>            :                     // }</a>
<a name="17624"><span class="lineNum">   17624 </span>            :                     // in which &quot;temp = e;&quot; is rewritten further</a>
<a name="17625"><span class="lineNum">   17625 </span>            :                     // std::cout &lt;&lt; &quot;Converting while test&quot; &lt;&lt; std::endl;</a>
<a name="17626"><span class="lineNum">   17626 </span><span class="lineNoCov">          0 :                        pushTestIntoBody(whileStatement);</span></a>
<a name="17627"><span class="lineNum">   17627 </span>            :                     // FixSgTree(whileStatement);</a>
<a name="17628"><span class="lineNum">   17628 </span><span class="lineNoCov">          0 :                        replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17629"><span class="lineNum">   17629 </span>            :                      }</a>
<a name="17630"><span class="lineNum">   17630 </span><span class="lineNoCov">          0 :                   else if (doWhileStatement &amp;&amp; doWhileStatement-&gt;get_condition() == exprStatement)</span></a>
<a name="17631"><span class="lineNum">   17631 </span>            :                     {</a>
<a name="17632"><span class="lineNum">   17632 </span>            :          // printf (&quot;Convert do-while statements \n&quot;);</a>
<a name="17633"><span class="lineNum">   17633 </span>            :                    // Convert do-while statement:</a>
<a name="17634"><span class="lineNum">   17634 </span>            :                    // do body; while (e); (where e contains from) becomes</a>
<a name="17635"><span class="lineNum">   17635 </span>            :                    // {bool temp = true;</a>
<a name="17636"><span class="lineNum">   17636 </span>            :                    //  do {</a>
<a name="17637"><span class="lineNum">   17637 </span>            :                    //    body (with &quot;continue&quot; changed to &quot;goto label&quot;;</a>
<a name="17638"><span class="lineNum">   17638 </span>            :                    //    label:</a>
<a name="17639"><span class="lineNum">   17639 </span>            :                    //    temp = e;} while (temp);}</a>
<a name="17640"><span class="lineNum">   17640 </span>            :                    // in which &quot;temp = e;&quot; is rewritten further</a>
<a name="17641"><span class="lineNum">   17641 </span>            :                    // std::cout &lt;&lt; &quot;Converting do-while test&quot; &lt;&lt; std::endl;</a>
<a name="17642"><span class="lineNum">   17642 </span><span class="lineNoCov">          0 :                       SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();</span></a>
<a name="17643"><span class="lineNum">   17643 </span>            :                    // printf (&quot;Building IR node #14: new SgBasicBlock = %p \n&quot;,new_statement);</a>
<a name="17644"><span class="lineNum">   17644 </span><span class="lineNoCov">          0 :                       assert (doWhileStatement-&gt;get_parent());</span></a>
<a name="17645"><span class="lineNum">   17645 </span><span class="lineNoCov">          0 :                       new_statement-&gt;set_parent(doWhileStatement-&gt;get_parent());</span></a>
<a name="17646"><span class="lineNum">   17646 </span><span class="lineNoCov">          0 :                       myStatementInsert(doWhileStatement, new_statement, false);</span></a>
<a name="17647"><span class="lineNum">   17647 </span><span class="lineNoCov">          0 :                       SageInterface::myRemoveStatement(doWhileStatement);</span></a>
<a name="17648"><span class="lineNum">   17648 </span><span class="lineNoCov">          0 :                       SgName varname = &quot;rose__temp1&quot;; // Does not need to be unique, but must not be used in user code anywhere</span></a>
<a name="17649"><span class="lineNum">   17649 </span><span class="lineNoCov">          0 :                       SgAssignInitializer* assignInitializer = buildAssignInitializer(</span></a>
<a name="17650"><span class="lineNum">   17650 </span><span class="lineNoCov">          0 :                           buildBoolValExp(true));</span></a>
<a name="17651"><span class="lineNum">   17651 </span>            :                       //SageInterface::getBoolType(doWhileStatement));</a>
<a name="17652"><span class="lineNum">   17652 </span><span class="lineNoCov">          0 :                       SgVariableDeclaration* new_decl = buildVariableDeclaration(</span></a>
<a name="17653"><span class="lineNum">   17653 </span><span class="lineNoCov">          0 :                         varname, buildBoolType(), assignInitializer, new_statement);</span></a>
<a name="17654"><span class="lineNum">   17654 </span>            : </a>
<a name="17655"><span class="lineNum">   17655 </span><span class="lineNoCov">          0 :                       SgInitializedName* initname = new_decl-&gt;get_variables().back();</span></a>
<a name="17656"><span class="lineNum">   17656 </span><span class="lineNoCov">          0 :                       initname-&gt;set_scope(new_statement);</span></a>
<a name="17657"><span class="lineNum">   17657 </span>            : </a>
<a name="17658"><span class="lineNum">   17658 </span>            :          // DQ (12/14/2006): set the parent of the SgAssignInitializer to the variable (SgInitializedName).</a>
<a name="17659"><span class="lineNum">   17659 </span><span class="lineNoCov">          0 :             assignInitializer-&gt;set_parent(initname);</span></a>
<a name="17660"><span class="lineNum">   17660 </span>            : </a>
<a name="17661"><span class="lineNum">   17661 </span>            : #if 1</a>
<a name="17662"><span class="lineNum">   17662 </span>            :                       // MS 7/3/2018: bugfix: above buildVariableDeclaration already creates var symbol</a>
<a name="17663"><span class="lineNum">   17663 </span><span class="lineNoCov">          0 :                       SgVariableSymbol* varsym = SageInterface::getFirstVarSym(new_decl);</span></a>
<a name="17664"><span class="lineNum">   17664 </span>            : #else</a>
<a name="17665"><span class="lineNum">   17665 </span>            :                       SgVariableSymbol* varsym = new SgVariableSymbol(initname);</a>
<a name="17666"><span class="lineNum">   17666 </span>            :                       new_statement-&gt;insert_symbol(varname, varsym);</a>
<a name="17667"><span class="lineNum">   17667 </span>            :                       varsym-&gt;set_parent(new_statement-&gt;get_symbol_table());</a>
<a name="17668"><span class="lineNum">   17668 </span>            : #endif</a>
<a name="17669"><span class="lineNum">   17669 </span>            : </a>
<a name="17670"><span class="lineNum">   17670 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(new_decl, new_statement);</span></a>
<a name="17671"><span class="lineNum">   17671 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(doWhileStatement, new_statement);</span></a>
<a name="17672"><span class="lineNum">   17672 </span><span class="lineNoCov">          0 :                       assert (varsym);</span></a>
<a name="17673"><span class="lineNum">   17673 </span><span class="lineNoCov">          0 :                       SgCastExp* castExp1 = buildCastExp(root,buildBoolType());</span></a>
<a name="17674"><span class="lineNum">   17674 </span><span class="lineNoCov">          0 :                       SgVarRefExp* vr = buildVarRefExp(varsym);</span></a>
<a name="17675"><span class="lineNum">   17675 </span><span class="lineNoCov">          0 :                       vr-&gt;set_lvalue(true);</span></a>
<a name="17676"><span class="lineNum">   17676 </span>            : </a>
<a name="17677"><span class="lineNum">   17677 </span><span class="lineNoCov">          0 :                       SgExprStatement* temp_setup = SageBuilder::buildAssignStatement(vr, castExp1);</span></a>
<a name="17678"><span class="lineNum">   17678 </span>            : </a>
<a name="17679"><span class="lineNum">   17679 </span><span class="lineNoCov">          0 :                       SageInterface::addStepToLoopBody(doWhileStatement, temp_setup);</span></a>
<a name="17680"><span class="lineNum">   17680 </span><span class="lineNoCov">          0 :                       SgVarRefExp* varsymVr = buildVarRefExp(varsym);</span></a>
<a name="17681"><span class="lineNum">   17681 </span>            : </a>
<a name="17682"><span class="lineNum">   17682 </span><span class="lineNoCov">          0 :                       SgExprStatement* condStmt = SageBuilder::buildExprStatement(varsymVr);</span></a>
<a name="17683"><span class="lineNum">   17683 </span><span class="lineNoCov">          0 :                       varsymVr-&gt;set_parent(condStmt);</span></a>
<a name="17684"><span class="lineNum">   17684 </span><span class="lineNoCov">          0 :                       doWhileStatement-&gt;set_condition(condStmt);</span></a>
<a name="17685"><span class="lineNum">   17685 </span><span class="lineNoCov">          0 :                       condStmt-&gt;set_parent(doWhileStatement);</span></a>
<a name="17686"><span class="lineNum">   17686 </span><span class="lineNoCov">          0 :                       replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17687"><span class="lineNum">   17687 </span>            :                     }</a>
<a name="17688"><span class="lineNum">   17688 </span><span class="lineNoCov">          0 :                   else if (ifStatement &amp;&amp; ifStatement-&gt;get_conditional() == exprStatement)</span></a>
<a name="17689"><span class="lineNum">   17689 </span>            :                     {</a>
<a name="17690"><span class="lineNum">   17690 </span><span class="lineNoCov">          0 :                       SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();</span></a>
<a name="17691"><span class="lineNum">   17691 </span>            :                    // printf (&quot;Building IR node #15: new SgBasicBlock = %p \n&quot;,new_statement);</a>
<a name="17692"><span class="lineNum">   17692 </span><span class="lineNoCov">          0 :                       assert (ifStatement-&gt;get_parent());</span></a>
<a name="17693"><span class="lineNum">   17693 </span><span class="lineNoCov">          0 :                       new_statement-&gt;set_parent(ifStatement-&gt;get_parent());</span></a>
<a name="17694"><span class="lineNum">   17694 </span><span class="lineNoCov">          0 :                       myStatementInsert(ifStatement, new_statement, false);</span></a>
<a name="17695"><span class="lineNum">   17695 </span><span class="lineNoCov">          0 :                       SageInterface::myRemoveStatement(ifStatement);</span></a>
<a name="17696"><span class="lineNum">   17696 </span><span class="lineNoCov">          0 :                       SgName varname = &quot;rose__temp2&quot;; // Does not need to be unique, but must not be used in user code anywhere</span></a>
<a name="17697"><span class="lineNum">   17697 </span><span class="lineNoCov">          0 :                       SgBoolValExp* trueVal = buildBoolValExp(true);</span></a>
<a name="17698"><span class="lineNum">   17698 </span>            : </a>
<a name="17699"><span class="lineNum">   17699 </span><span class="lineNoCov">          0 :                       SgAssignInitializer* ai = buildAssignInitializer(trueVal);</span></a>
<a name="17700"><span class="lineNum">   17700 </span>            : </a>
<a name="17701"><span class="lineNum">   17701 </span><span class="lineNoCov">          0 :                       SgVariableDeclaration* new_decl = buildVariableDeclaration(varname,</span></a>
<a name="17702"><span class="lineNum">   17702 </span><span class="lineNoCov">          0 :                          buildBoolType(), ai,new_statement);</span></a>
<a name="17703"><span class="lineNum">   17703 </span><span class="lineNoCov">          0 :                       SgInitializedName* initname = new_decl-&gt;get_variables().back();</span></a>
<a name="17704"><span class="lineNum">   17704 </span><span class="lineNoCov">          0 :                       ai-&gt;set_parent(initname);</span></a>
<a name="17705"><span class="lineNum">   17705 </span><span class="lineNoCov">          0 :                       initname-&gt;set_scope(new_statement);</span></a>
<a name="17706"><span class="lineNum">   17706 </span>            : #if 1</a>
<a name="17707"><span class="lineNum">   17707 </span>            :                       // MS 7/3/2018: bugfix: above buildVariableDeclaration already creates var symbol</a>
<a name="17708"><span class="lineNum">   17708 </span><span class="lineNoCov">          0 :                       SgVariableSymbol* varsym = SageInterface::getFirstVarSym(new_decl);</span></a>
<a name="17709"><span class="lineNum">   17709 </span>            : #else</a>
<a name="17710"><span class="lineNum">   17710 </span>            :                       SgVariableSymbol* varsym = new SgVariableSymbol(initname);</a>
<a name="17711"><span class="lineNum">   17711 </span>            :                       new_statement-&gt;insert_symbol(varname, varsym);</a>
<a name="17712"><span class="lineNum">   17712 </span>            :                       varsym-&gt;set_parent(new_statement-&gt;get_symbol_table());</a>
<a name="17713"><span class="lineNum">   17713 </span>            : #endif</a>
<a name="17714"><span class="lineNum">   17714 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(new_decl, new_statement);</span></a>
<a name="17715"><span class="lineNum">   17715 </span><span class="lineNoCov">          0 :                       ifStatement-&gt;set_parent(new_statement);</span></a>
<a name="17716"><span class="lineNum">   17716 </span><span class="lineNoCov">          0 :                       assert (varsym);</span></a>
<a name="17717"><span class="lineNum">   17717 </span>            : </a>
<a name="17718"><span class="lineNum">   17718 </span><span class="lineNoCov">          0 :                       SgCastExp* castExp2 = SageBuilder::buildCastExp(root, SageInterface::getBoolType(ifStatement));</span></a>
<a name="17719"><span class="lineNum">   17719 </span><span class="lineNoCov">          0 :                       SgVarRefExp* vr = buildVarRefExp(varsym);</span></a>
<a name="17720"><span class="lineNum">   17720 </span><span class="lineNoCov">          0 :                       vr-&gt;set_lvalue(true);</span></a>
<a name="17721"><span class="lineNum">   17721 </span><span class="lineNoCov">          0 :                       SgExprStatement* temp_setup = SageBuilder::buildAssignStatement(vr, castExp2 );</span></a>
<a name="17722"><span class="lineNum">   17722 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(temp_setup, new_statement);</span></a>
<a name="17723"><span class="lineNum">   17723 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(ifStatement, new_statement);</span></a>
<a name="17724"><span class="lineNum">   17724 </span><span class="lineNoCov">          0 :                       SgVarRefExp* vr2 = SageBuilder::buildVarRefExp(varsym);</span></a>
<a name="17725"><span class="lineNum">   17725 </span><span class="lineNoCov">          0 :                       SgExprStatement* es = SageBuilder::buildExprStatement(vr2);</span></a>
<a name="17726"><span class="lineNum">   17726 </span><span class="lineNoCov">          0 :                       ifStatement-&gt;set_conditional(es);</span></a>
<a name="17727"><span class="lineNum">   17727 </span><span class="lineNoCov">          0 :                       es-&gt;set_parent(ifStatement);</span></a>
<a name="17728"><span class="lineNum">   17728 </span><span class="lineNoCov">          0 :                       replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17729"><span class="lineNum">   17729 </span>            :                     }</a>
<a name="17730"><span class="lineNum">   17730 </span><span class="lineNoCov">          0 :                   else if (switchStatement &amp;&amp; switchStatement-&gt;get_item_selector() == exprStatement)</span></a>
<a name="17731"><span class="lineNum">   17731 </span>            :                     {</a>
<a name="17732"><span class="lineNum">   17732 </span><span class="lineNoCov">          0 :                       SgExpression* switchCond = exprStatement-&gt;get_expression();</span></a>
<a name="17733"><span class="lineNum">   17733 </span><span class="lineNoCov">          0 :                       ROSE_ASSERT (switchCond);</span></a>
<a name="17734"><span class="lineNum">   17734 </span><span class="lineNoCov">          0 :                       SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();</span></a>
<a name="17735"><span class="lineNum">   17735 </span>            :                    // printf (&quot;Building IR node #15: new SgBasicBlock = %p \n&quot;,new_statement);</a>
<a name="17736"><span class="lineNum">   17736 </span><span class="lineNoCov">          0 :                       assert (switchStatement-&gt;get_parent());</span></a>
<a name="17737"><span class="lineNum">   17737 </span><span class="lineNoCov">          0 :                       new_statement-&gt;set_parent(switchStatement-&gt;get_parent());</span></a>
<a name="17738"><span class="lineNum">   17738 </span><span class="lineNoCov">          0 :                       myStatementInsert(switchStatement, new_statement, false);</span></a>
<a name="17739"><span class="lineNum">   17739 </span><span class="lineNoCov">          0 :                       SageInterface::myRemoveStatement(switchStatement);</span></a>
<a name="17740"><span class="lineNum">   17740 </span><span class="lineNoCov">          0 :                       SgName varname = &quot;rose__temp3&quot;; // Does not need to be unique, but must not be used in user code anywhere</span></a>
<a name="17741"><span class="lineNum">   17741 </span><span class="lineNoCov">          0 :                       switchCond-&gt;set_parent(NULL);</span></a>
<a name="17742"><span class="lineNum">   17742 </span><span class="lineNoCov">          0 :                       SgVariableDeclaration* new_decl = SageBuilder::buildVariableDeclaration(varname, switchCond-&gt;get_type(), SageBuilder::buildAssignInitializer(switchCond), new_statement);</span></a>
<a name="17743"><span class="lineNum">   17743 </span><span class="lineNoCov">          0 :                       SgVariableSymbol* varsym = SageInterface::getFirstVarSym(new_decl);</span></a>
<a name="17744"><span class="lineNum">   17744 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(new_decl, new_statement);</span></a>
<a name="17745"><span class="lineNum">   17745 </span><span class="lineNoCov">          0 :                       switchStatement-&gt;set_parent(new_statement);</span></a>
<a name="17746"><span class="lineNum">   17746 </span><span class="lineNoCov">          0 :                       assert (varsym);</span></a>
<a name="17747"><span class="lineNum">   17747 </span>            : </a>
<a name="17748"><span class="lineNum">   17748 </span>            : </a>
<a name="17749"><span class="lineNum">   17749 </span><span class="lineNoCov">          0 :                       SageInterface::appendStatement(switchStatement, new_statement);</span></a>
<a name="17750"><span class="lineNum">   17750 </span><span class="lineNoCov">          0 :                       SgVarRefExp* vr2 = SageBuilder::buildVarRefExp(varsym);</span></a>
<a name="17751"><span class="lineNum">   17751 </span><span class="lineNoCov">          0 :                       SgExprStatement* es = SageBuilder::buildExprStatement(vr2);</span></a>
<a name="17752"><span class="lineNum">   17752 </span><span class="lineNoCov">          0 :                       switchStatement-&gt;set_item_selector(es);</span></a>
<a name="17753"><span class="lineNum">   17753 </span><span class="lineNoCov">          0 :                       es-&gt;set_parent(switchStatement);</span></a>
<a name="17754"><span class="lineNum">   17754 </span><span class="lineNoCov">          0 :                       replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17755"><span class="lineNum">   17755 </span>            :                     }</a>
<a name="17756"><span class="lineNum">   17756 </span>            :                   else</a>
<a name="17757"><span class="lineNum">   17757 </span>            :                     {</a>
<a name="17758"><span class="lineNum">   17758 </span>            :                       // printf (&quot;Handles expression and return statements \n&quot;);</a>
<a name="17759"><span class="lineNum">   17759 </span>            :                       // Handles expression and return statements</a>
<a name="17760"><span class="lineNum">   17760 </span>            :                       // std::cout &lt;&lt; &quot;Converting other statement&quot; &lt;&lt; std::endl;</a>
<a name="17761"><span class="lineNum">   17761 </span><span class="lineNoCov">          0 :                       replaceSubexpressionWithStatement(from, to);</span></a>
<a name="17762"><span class="lineNum">   17762 </span>            :                     }</a>
<a name="17763"><span class="lineNum">   17763 </span>            :                   }</a>
<a name="17764"><span class="lineNum">   17764 </span>            :              }</a>
<a name="17765"><span class="lineNum">   17765 </span>            :         }</a>
<a name="17766"><span class="lineNum">   17766 </span>            : </a>
<a name="17767"><span class="lineNum">   17767 </span>            : #endif</a>
<a name="17768"><span class="lineNum">   17768 </span>            : </a>
<a name="17769"><span class="lineNum">   17769 </span>            :   // printf (&quot;Leaving replaceExpressionWithStatement(from,to) \n&quot;);</a>
<a name="17770"><span class="lineNum">   17770 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="17771"><span class="lineNum">   17771 </span>            : </a>
<a name="17772"><span class="lineNum">   17772 </span>            : //! Replace a given expression with a list of statements produced by a</a>
<a name="17773"><span class="lineNum">   17773 </span>            : //! generator.  The generator, when given a variable as input, must produce</a>
<a name="17774"><span class="lineNum">   17774 </span>            : //! some code which leaves its result in the given variable.  The output</a>
<a name="17775"><span class="lineNum">   17775 </span>            : //! from the generator is then inserted into the original program in such a</a>
<a name="17776"><span class="lineNum">   17776 </span>            : //! way that whenever the expression had previously been evaluated, the</a>
<a name="17777"><span class="lineNum">   17777 </span>            : //! statements produced by the generator are run instead and their result is</a>
<a name="17778"><span class="lineNum">   17778 </span>            : //! used in place of the expression.</a>
<a name="17779"><span class="lineNum">   17779 </span>            : //! Assumptions: not currently traversing from or the statement it is in</a>
<a name="17780"><span class="lineNum">   17780 </span>            : </a>
<a name="17781"><span class="lineNum">   17781 </span>            : // Similar to replaceExpressionWithStatement, but with more restrictions.</a>
<a name="17782"><span class="lineNum">   17782 </span>            : // Assumptions: from is not within the test of a loop or if</a>
<a name="17783"><span class="lineNum">   17783 </span>            : //              not currently traversing from or the statement it is in</a>
<a name="17784"><span class="lineNum">   17784 </span><span class="lineNoCov">          0 : void SageInterface::replaceSubexpressionWithStatement(SgExpression* from, StatementGenerator* to)</span></a>
<a name="17785"><span class="lineNum">   17785 </span>            :    {</a>
<a name="17786"><span class="lineNum">   17786 </span>            : </a>
<a name="17787"><span class="lineNum">   17787 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="17788"><span class="lineNum">   17788 </span><span class="lineNoCov">          0 :      SgStatement* stmt = getStatementOfExpression(from);</span></a>
<a name="17789"><span class="lineNum">   17789 </span>            : </a>
<a name="17790"><span class="lineNum">   17790 </span><span class="lineNoCov">          0 :      if (isSgExprStatement(stmt))</span></a>
<a name="17791"><span class="lineNum">   17791 </span>            :         {</a>
<a name="17792"><span class="lineNum">   17792 </span><span class="lineNoCov">          0 :           SgExpression* top = getRootOfExpression(from);</span></a>
<a name="17793"><span class="lineNum">   17793 </span>            : </a>
<a name="17794"><span class="lineNum">   17794 </span>            : </a>
<a name="17795"><span class="lineNum">   17795 </span><span class="lineNoCov">          0 :           if (top == from)</span></a>
<a name="17796"><span class="lineNum">   17796 </span>            :              {</a>
<a name="17797"><span class="lineNum">   17797 </span><span class="lineNoCov">          0 :                SgStatement* generated = to-&gt;generate(0);</span></a>
<a name="17798"><span class="lineNum">   17798 </span><span class="lineNoCov">          0 :                isSgStatement(stmt-&gt;get_parent())-&gt;replace_statement(stmt, generated);</span></a>
<a name="17799"><span class="lineNum">   17799 </span><span class="lineNoCov">          0 :                generated-&gt;set_parent(stmt-&gt;get_parent());</span></a>
<a name="17800"><span class="lineNum">   17800 </span><span class="lineNoCov">          0 :                return;</span></a>
<a name="17801"><span class="lineNum">   17801 </span>            :              }</a>
<a name="17802"><span class="lineNum">   17802 </span>            :             else</a>
<a name="17803"><span class="lineNum">   17803 </span>            :              {</a>
<a name="17804"><span class="lineNum">   17804 </span><span class="lineNoCov">          0 :                if (isSgAssignOp(top) &amp;&amp; isSgAssignOp(top)-&gt;get_rhs_operand() == from)</span></a>
<a name="17805"><span class="lineNum">   17805 </span>            :                   {</a>
<a name="17806"><span class="lineNum">   17806 </span><span class="lineNoCov">          0 :                     SgAssignOp* t = isSgAssignOp(top);</span></a>
<a name="17807"><span class="lineNum">   17807 </span><span class="lineNoCov">          0 :                     SgStatement* generated = to-&gt;generate(t-&gt;get_lhs_operand());</span></a>
<a name="17808"><span class="lineNum">   17808 </span><span class="lineNoCov">          0 :                     isSgStatement(stmt-&gt;get_parent())-&gt;replace_statement(stmt, generated);</span></a>
<a name="17809"><span class="lineNum">   17809 </span><span class="lineNoCov">          0 :                     generated-&gt;set_parent(stmt-&gt;get_parent());</span></a>
<a name="17810"><span class="lineNum">   17810 </span><span class="lineNoCov">          0 :                     return;</span></a>
<a name="17811"><span class="lineNum">   17811 </span>            :                   }</a>
<a name="17812"><span class="lineNum">   17812 </span>            :                  else</a>
<a name="17813"><span class="lineNum">   17813 </span>            :                   {</a>
<a name="17814"><span class="lineNum">   17814 </span>            :                  // printf (&quot;In replaceSubexpressionWithStatement(): Statement not generated \n&quot;);</a>
<a name="17815"><span class="lineNum">   17815 </span>            :                   }</a>
<a name="17816"><span class="lineNum">   17816 </span>            :              }</a>
<a name="17817"><span class="lineNum">   17817 </span>            :         }</a>
<a name="17818"><span class="lineNum">   17818 </span>            : </a>
<a name="17819"><span class="lineNum">   17819 </span>            :   // cout &lt;&lt; &quot;1: &quot; &lt;&lt; getStatementOfExpression(from)-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="17820"><span class="lineNum">   17820 </span><span class="lineNoCov">          0 :      SgAssignInitializer* init = splitExpression(from);</span></a>
<a name="17821"><span class="lineNum">   17821 </span>            :   // cout &lt;&lt; &quot;2: &quot; &lt;&lt; getStatementOfExpression(from)-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="17822"><span class="lineNum">   17822 </span><span class="lineNoCov">          0 :      convertInitializerIntoAssignment(init);</span></a>
<a name="17823"><span class="lineNum">   17823 </span>            :   // cout &lt;&lt; &quot;3: &quot; &lt;&lt; getStatementOfExpression(from)-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="17824"><span class="lineNum">   17824 </span>            :   // cout &lt;&lt; &quot;3a: &quot; &lt;&lt; getStatementOfExpression(from)-&gt;get_parent()-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="17825"><span class="lineNum">   17825 </span><span class="lineNoCov">          0 :      SgExprStatement* new_stmt = isSgExprStatement(getStatementOfExpression(from));</span></a>
<a name="17826"><span class="lineNum">   17826 </span><span class="lineNoCov">          0 :      assert (new_stmt != NULL); // Should now have this form because of conversion</span></a>
<a name="17827"><span class="lineNum">   17827 </span><span class="lineNoCov">          0 :      replaceAssignmentStmtWithStatement(new_stmt, to);</span></a>
<a name="17828"><span class="lineNum">   17828 </span>            : </a>
<a name="17829"><span class="lineNum">   17829 </span>            :   // printf (&quot;In replaceSubexpressionWithStatement: new_stmt = %p = %s \n&quot;,new_stmt,new_stmt-&gt;class_name().c_str());</a>
<a name="17830"><span class="lineNum">   17830 </span>            :   // cout &lt;&lt; &quot;4: &quot; &lt;&lt; getStatementOfExpression(from)-&gt;get_parent()-&gt;unparseToString() &lt;&lt; endl;</a>
<a name="17831"><span class="lineNum">   17831 </span>            : </a>
<a name="17832"><span class="lineNum">   17832 </span>            : #endif</a>
<a name="17833"><span class="lineNum">   17833 </span>            :    }</a>
<a name="17834"><span class="lineNum">   17834 </span>            : </a>
<a name="17835"><span class="lineNum">   17835 </span>            : </a>
<a name="17836"><span class="lineNum">   17836 </span>            :   // Liao, 6/27/2008</a>
<a name="17837"><span class="lineNum">   17837 </span>            :   //Tasks</a>
<a name="17838"><span class="lineNum">   17838 </span>            :   //  find all return statements</a>
<a name="17839"><span class="lineNum">   17839 </span>            :   //  rewrite it to  temp = expression; return temp; if expression is not a single value.</a>
<a name="17840"><span class="lineNum">   17840 </span>            :   //  insert s right before 'return xxx;'</a>
<a name="17841"><span class="lineNum">   17841 </span><span class="lineCov">          1 :   int SageInterface::instrumentEndOfFunction(SgFunctionDeclaration * func, SgStatement* s)</span></a>
<a name="17842"><span class="lineNum">   17842 </span>            :   {</a>
<a name="17843"><span class="lineNum">   17843 </span><span class="lineCov">          1 :     int result = 0;</span></a>
<a name="17844"><span class="lineNum">   17844 </span><span class="lineCov">          1 :     ROSE_ASSERT(func&amp;&amp;s);</span></a>
<a name="17845"><span class="lineNum">   17845 </span>            :   //  vector&lt;SgReturnStmt* &gt; stmts = findReturnStmts(func);</a>
<a name="17846"><span class="lineNum">   17846 </span><span class="lineCov">          1 :     Rose_STL_Container &lt;SgNode* &gt; stmts = NodeQuery::querySubTree(func, V_SgReturnStmt);</span></a>
<a name="17847"><span class="lineNum">   17847 </span>            :     //vector&lt;SgReturnStmt*&gt;::iterator i;</a>
<a name="17848"><span class="lineNum">   17848 </span><span class="lineCov">          1 :     Rose_STL_Container&lt;SgNode*&gt;::iterator i;</span></a>
<a name="17849"><span class="lineNum">   17849 </span><span class="lineCov">          4 :     for (i=stmts.begin();i!=stmts.end();i++)</span></a>
<a name="17850"><span class="lineNum">   17850 </span>            :     {</a>
<a name="17851"><span class="lineNum">   17851 </span><span class="lineCov">          3 :       SgReturnStmt* cur_stmt = isSgReturnStmt(*i);</span></a>
<a name="17852"><span class="lineNum">   17852 </span><span class="lineCov">          3 :       ROSE_ASSERT(cur_stmt);</span></a>
<a name="17853"><span class="lineNum">   17853 </span><span class="lineCov">          3 :       SgExpression * exp = cur_stmt-&gt;get_expression();</span></a>
<a name="17854"><span class="lineNum">   17854 </span>            :    // TV (05/03/2011) Catch the case &quot;return ;&quot; where exp is NULL</a>
<a name="17855"><span class="lineNum">   17855 </span><span class="lineCov">          3 :       bool needRewrite = (exp != NULL) &amp;&amp; !(isSgValueExp(exp));</span></a>
<a name="17856"><span class="lineNum">   17856 </span><span class="lineCov">          2 :       if (needRewrite)</span></a>
<a name="17857"><span class="lineNum">   17857 </span>            :       {</a>
<a name="17858"><span class="lineNum">   17858 </span><span class="lineCov">          4 :         splitExpression(exp);</span></a>
<a name="17859"><span class="lineNum">   17859 </span>            :       }</a>
<a name="17860"><span class="lineNum">   17860 </span>            :        // avoid reusing the statement</a>
<a name="17861"><span class="lineNum">   17861 </span><span class="lineCov">          3 :       if (result&gt;=1 )</span></a>
<a name="17862"><span class="lineNum">   17862 </span><span class="lineCov">          2 :          s = copyStatement(s);</span></a>
<a name="17863"><span class="lineNum">   17863 </span><span class="lineCov">          3 :        insertStatementBefore(cur_stmt,s);</span></a>
<a name="17864"><span class="lineNum">   17864 </span><span class="lineCov">          3 :       result ++;</span></a>
<a name="17865"><span class="lineNum">   17865 </span>            :     } // for</a>
<a name="17866"><span class="lineNum">   17866 </span><span class="lineCov">          1 :     if (stmts.size()==0 ) // a function without any return at all,</span></a>
<a name="17867"><span class="lineNum">   17867 </span>            :     {</a>
<a name="17868"><span class="lineNum">   17868 </span><span class="lineNoCov">          0 :       SgBasicBlock * body = func-&gt;get_definition()-&gt;get_body();</span></a>
<a name="17869"><span class="lineNum">   17869 </span><span class="lineNoCov">          0 :       if (body== NULL)</span></a>
<a name="17870"><span class="lineNum">   17870 </span>            :        {</a>
<a name="17871"><span class="lineNum">   17871 </span><span class="lineNoCov">          0 :          cout&lt;&lt;&quot;In instrumentEndOfFunction(), found an empty function body.! &quot;&lt;&lt;endl;</span></a>
<a name="17872"><span class="lineNum">   17872 </span><span class="lineNoCov">          0 :          ROSE_ABORT();</span></a>
<a name="17873"><span class="lineNum">   17873 </span>            :        }</a>
<a name="17874"><span class="lineNum">   17874 </span><span class="lineNoCov">          0 :       appendStatement(s,body);</span></a>
<a name="17875"><span class="lineNum">   17875 </span><span class="lineNoCov">          0 :       result ++;</span></a>
<a name="17876"><span class="lineNum">   17876 </span>            :     }</a>
<a name="17877"><span class="lineNum">   17877 </span><span class="lineCov">          2 :     return result;</span></a>
<a name="17878"><span class="lineNum">   17878 </span>            :   } // instrumentEndOfFunction</a>
<a name="17879"><span class="lineNum">   17879 </span>            : </a>
<a name="17880"><span class="lineNum">   17880 </span><span class="lineNoCov">          0 :   bool SageInterface::isStatic(SgDeclarationStatement* stmt)</span></a>
<a name="17881"><span class="lineNum">   17881 </span>            :   {</a>
<a name="17882"><span class="lineNum">   17882 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(stmt);</span></a>
<a name="17883"><span class="lineNum">   17883 </span><span class="lineNoCov">          0 :     return ((stmt-&gt;get_declarationModifier()).get_storageModifier()).isStatic();</span></a>
<a name="17884"><span class="lineNum">   17884 </span>            :   } // isStatic()</a>
<a name="17885"><span class="lineNum">   17885 </span>            : </a>
<a name="17886"><span class="lineNum">   17886 </span>            :   //! Set a declaration as static</a>
<a name="17887"><span class="lineNum">   17887 </span><span class="lineNoCov">          0 :   void SageInterface::setStatic(SgDeclarationStatement* stmt)</span></a>
<a name="17888"><span class="lineNum">   17888 </span>            :   {</a>
<a name="17889"><span class="lineNum">   17889 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(stmt);</span></a>
<a name="17890"><span class="lineNum">   17890 </span><span class="lineNoCov">          0 :     return ((stmt-&gt;get_declarationModifier()).get_storageModifier()).setStatic();</span></a>
<a name="17891"><span class="lineNum">   17891 </span>            :   }</a>
<a name="17892"><span class="lineNum">   17892 </span>            : </a>
<a name="17893"><span class="lineNum">   17893 </span><span class="lineNoCov">          0 :   bool SageInterface::isExtern(SgDeclarationStatement* stmt)</span></a>
<a name="17894"><span class="lineNum">   17894 </span>            :   {</a>
<a name="17895"><span class="lineNum">   17895 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(stmt);</span></a>
<a name="17896"><span class="lineNum">   17896 </span><span class="lineNoCov">          0 :     return ((stmt-&gt;get_declarationModifier()).get_storageModifier()).isExtern();</span></a>
<a name="17897"><span class="lineNum">   17897 </span>            :   } // isExtern()</a>
<a name="17898"><span class="lineNum">   17898 </span>            : </a>
<a name="17899"><span class="lineNum">   17899 </span>            : </a>
<a name="17900"><span class="lineNum">   17900 </span>            :   //! Set a declaration as extern</a>
<a name="17901"><span class="lineNum">   17901 </span><span class="lineCov">          1 :   void SageInterface::setExtern(SgDeclarationStatement* stmt)</span></a>
<a name="17902"><span class="lineNum">   17902 </span>            :   {</a>
<a name="17903"><span class="lineNum">   17903 </span><span class="lineCov">          1 :     ROSE_ASSERT(stmt);</span></a>
<a name="17904"><span class="lineNum">   17904 </span><span class="lineCov">          1 :     return ((stmt-&gt;get_declarationModifier()).get_storageModifier()).setExtern();</span></a>
<a name="17905"><span class="lineNum">   17905 </span>            :   }</a>
<a name="17906"><span class="lineNum">   17906 </span>            : </a>
<a name="17907"><span class="lineNum">   17907 </span>            :   // Check if an SgInitializedName is &quot;mutable' (has storage modifier set)</a>
<a name="17908"><span class="lineNum">   17908 </span><span class="lineNoCov">          0 :   bool SageInterface::isMutable(SgInitializedName* name)</span></a>
<a name="17909"><span class="lineNum">   17909 </span>            :   {</a>
<a name="17910"><span class="lineNum">   17910 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(name);</span></a>
<a name="17911"><span class="lineNum">   17911 </span><span class="lineNoCov">          0 :     return name-&gt;get_storageModifier().isMutable();</span></a>
<a name="17912"><span class="lineNum">   17912 </span>            :   }</a>
<a name="17913"><span class="lineNum">   17913 </span>            : </a>
<a name="17914"><span class="lineNum">   17914 </span>            :   // Get a vector of Jovial input parameters from the function parameter list</a>
<a name="17915"><span class="lineNum">   17915 </span>            :   // TODO: Look into making this work for Fortran</a>
<a name="17916"><span class="lineNum">   17916 </span><span class="lineNoCov">          0 :   std::vector&lt;SgInitializedName*&gt; SageInterface::getInParameters(const SgInitializedNamePtrList &amp;params)</span></a>
<a name="17917"><span class="lineNum">   17917 </span>            :   {</a>
<a name="17918"><span class="lineNum">   17918 </span><span class="lineNoCov">          0 :     std::vector&lt;SgInitializedName*&gt; in_params;</span></a>
<a name="17919"><span class="lineNum">   17919 </span><span class="lineNoCov">          0 :     BOOST_FOREACH (SgInitializedName* name, params)</span></a>
<a name="17920"><span class="lineNum">   17920 </span>            :       {</a>
<a name="17921"><span class="lineNum">   17921 </span><span class="lineNoCov">          0 :         if (!isMutable(name)) in_params.push_back(name);</span></a>
<a name="17922"><span class="lineNum">   17922 </span>            :       }</a>
<a name="17923"><span class="lineNum">   17923 </span><span class="lineNoCov">          0 :     return in_params;</span></a>
<a name="17924"><span class="lineNum">   17924 </span>            :   }</a>
<a name="17925"><span class="lineNum">   17925 </span>            : </a>
<a name="17926"><span class="lineNum">   17926 </span>            :   // Get a list of Jovial output parameters from the function parameter list</a>
<a name="17927"><span class="lineNum">   17927 </span>            :   // TODO: Look into making this work for Fortran</a>
<a name="17928"><span class="lineNum">   17928 </span><span class="lineNoCov">          0 :   std::vector&lt;SgInitializedName*&gt; SageInterface::getOutParameters(const SgInitializedNamePtrList &amp;params)</span></a>
<a name="17929"><span class="lineNum">   17929 </span>            :   {</a>
<a name="17930"><span class="lineNum">   17930 </span><span class="lineNoCov">          0 :     std::vector&lt;SgInitializedName*&gt; out_params;</span></a>
<a name="17931"><span class="lineNum">   17931 </span><span class="lineNoCov">          0 :     BOOST_FOREACH (SgInitializedName* name, params)</span></a>
<a name="17932"><span class="lineNum">   17932 </span>            :       {</a>
<a name="17933"><span class="lineNum">   17933 </span><span class="lineNoCov">          0 :         if (isMutable(name)) out_params.push_back(name);</span></a>
<a name="17934"><span class="lineNum">   17934 </span>            :       }</a>
<a name="17935"><span class="lineNum">   17935 </span><span class="lineNoCov">          0 :     return out_params;</span></a>
<a name="17936"><span class="lineNum">   17936 </span>            :   }</a>
<a name="17937"><span class="lineNum">   17937 </span>            : </a>
<a name="17938"><span class="lineNum">   17938 </span><span class="lineCov">        162 :   unsigned long long SageInterface::getIntegerConstantValue(SgValueExp* expr) {</span></a>
<a name="17939"><span class="lineNum">   17939 </span><span class="lineCov">        162 :     switch (expr-&gt;variantT()) {</span></a>
<a name="17940"><span class="lineNum">   17940 </span><span class="lineCov">         87 :       case V_SgCharVal: return (long long)(isSgCharVal(expr)-&gt;get_value());</span></a>
<a name="17941"><span class="lineNum">   17941 </span><span class="lineNoCov">          0 :       case V_SgUnsignedCharVal: return isSgUnsignedCharVal(expr)-&gt;get_value();</span></a>
<a name="17942"><span class="lineNum">   17942 </span><span class="lineNoCov">          0 :       case V_SgShortVal: return (long long)(isSgShortVal(expr)-&gt;get_value());</span></a>
<a name="17943"><span class="lineNum">   17943 </span><span class="lineNoCov">          0 :       case V_SgUnsignedShortVal: return isSgUnsignedShortVal(expr)-&gt;get_value();</span></a>
<a name="17944"><span class="lineNum">   17944 </span><span class="lineCov">         30 :       case V_SgIntVal: return (long long)(isSgIntVal(expr)-&gt;get_value());</span></a>
<a name="17945"><span class="lineNum">   17945 </span><span class="lineCov">          8 :       case V_SgUnsignedIntVal: return isSgUnsignedIntVal(expr)-&gt;get_value();</span></a>
<a name="17946"><span class="lineNum">   17946 </span><span class="lineCov">         13 :       case V_SgLongIntVal: return (long long)(isSgLongIntVal(expr)-&gt;get_value());</span></a>
<a name="17947"><span class="lineNum">   17947 </span><span class="lineCov">         24 :       case V_SgUnsignedLongVal: return isSgUnsignedLongVal(expr)-&gt;get_value();</span></a>
<a name="17948"><span class="lineNum">   17948 </span><span class="lineNoCov">          0 :       case V_SgLongLongIntVal: return isSgLongLongIntVal(expr)-&gt;get_value();</span></a>
<a name="17949"><span class="lineNum">   17949 </span><span class="lineNoCov">          0 :       case V_SgUnsignedLongLongIntVal: return isSgUnsignedLongLongIntVal(expr)-&gt;get_value();</span></a>
<a name="17950"><span class="lineNum">   17950 </span><span class="lineNoCov">          0 :       case V_SgBoolValExp: return (long long )(isSgBoolValExp(expr)-&gt;get_value());</span></a>
<a name="17951"><span class="lineNum">   17951 </span>            : </a>
<a name="17952"><span class="lineNum">   17952 </span>            :    // DQ (2/18/2015): Make this a better error message.</a>
<a name="17953"><span class="lineNum">   17953 </span>            :    // default: ROSE_ASSERT (!&quot;Bad kind in getIntegerConstantValue&quot;);</a>
<a name="17954"><span class="lineNum">   17954 </span><span class="lineNoCov">          0 :       default:</span></a>
<a name="17955"><span class="lineNum">   17955 </span><span class="lineNoCov">          0 :          {</span></a>
<a name="17956"><span class="lineNum">   17956 </span><span class="lineNoCov">          0 :            printf (&quot;ERROR: In SageInterface::getIntegerConstantValue(): default reached: expr = %p = %s \n&quot;,expr,expr-&gt;class_name().c_str());</span></a>
<a name="17957"><span class="lineNum">   17957 </span><span class="lineNoCov">          0 :            ROSE_ASSERT (false);</span></a>
<a name="17958"><span class="lineNum">   17958 </span>            :          }</a>
<a name="17959"><span class="lineNum">   17959 </span>            : </a>
<a name="17960"><span class="lineNum">   17960 </span>            :     }</a>
<a name="17961"><span class="lineNum">   17961 </span>            : </a>
<a name="17962"><span class="lineNum">   17962 </span>            :     ROSE_ASSERT (!&quot;Bad kind return in getIntegerConstantValue&quot;);</a>
<a name="17963"><span class="lineNum">   17963 </span>            :         return 0;</a>
<a name="17964"><span class="lineNum">   17964 </span>            :   }</a>
<a name="17965"><span class="lineNum">   17965 </span>            : </a>
<a name="17966"><span class="lineNum">   17966 </span>            : class CollectDependentDeclarationsCopyType : public SgCopyHelp</a>
<a name="17967"><span class="lineNum">   17967 </span>            :    {</a>
<a name="17968"><span class="lineNum">   17968 </span>            :      public:</a>
<a name="17969"><span class="lineNum">   17969 </span>            :        // This is the simpliest possible version of a deep copy SgCopyHelp::copyAst() member function.</a>
<a name="17970"><span class="lineNum">   17970 </span>            :        // Note that the root of the does not have its file info set like its children.</a>
<a name="17971"><span class="lineNum">   17971 </span><span class="lineNoCov">          0 :           virtual SgNode *copyAst(const SgNode *n)</span></a>
<a name="17972"><span class="lineNum">   17972 </span>            :              {</a>
<a name="17973"><span class="lineNum">   17973 </span>            :             // DQ (2/26/2009): This defines a simple concept of &quot;deep&quot; copy. It forms a more testable building block, I hope.</a>
<a name="17974"><span class="lineNum">   17974 </span><span class="lineNoCov">          0 :                SgNode* copy = n-&gt;copy(*this);</span></a>
<a name="17975"><span class="lineNum">   17975 </span>            : </a>
<a name="17976"><span class="lineNum">   17976 </span>            :             // Also mark this as a transformation and to be output in unparsing (so it will be output by the code generator).</a>
<a name="17977"><span class="lineNum">   17977 </span><span class="lineNoCov">          0 :                Sg_File_Info* fileInfo = copy-&gt;get_file_info();</span></a>
<a name="17978"><span class="lineNum">   17978 </span><span class="lineNoCov">          0 :                if (fileInfo != NULL)</span></a>
<a name="17979"><span class="lineNum">   17979 </span>            :                   {</a>
<a name="17980"><span class="lineNum">   17980 </span>            :                  // Must make this for output (checked in unparser), marking as a transformation is not checked</a>
<a name="17981"><span class="lineNum">   17981 </span><span class="lineNoCov">          0 :                     fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="17982"><span class="lineNum">   17982 </span><span class="lineNoCov">          0 :                     fileInfo-&gt;setTransformation();</span></a>
<a name="17983"><span class="lineNum">   17983 </span>            :                   }</a>
<a name="17984"><span class="lineNum">   17984 </span>            : </a>
<a name="17985"><span class="lineNum">   17985 </span><span class="lineNoCov">          0 :                return copy;</span></a>
<a name="17986"><span class="lineNum">   17986 </span>            :              }</a>
<a name="17987"><span class="lineNum">   17987 </span>            :    } collectDependentDeclarationsCopyType;</a>
<a name="17988"><span class="lineNum">   17988 </span>            : </a>
<a name="17989"><span class="lineNum">   17989 </span>            : </a>
<a name="17990"><span class="lineNum">   17990 </span><span class="lineNoCov">          0 : class CollectCppDirectivesTraversal : public SgSimpleProcessing</span></a>
<a name="17991"><span class="lineNum">   17991 </span>            :    {</a>
<a name="17992"><span class="lineNum">   17992 </span>            :   // This traversal collects the includes at the top of a file.</a>
<a name="17993"><span class="lineNum">   17993 </span>            : </a>
<a name="17994"><span class="lineNum">   17994 </span>            :      public:</a>
<a name="17995"><span class="lineNum">   17995 </span>            :           vector&lt;PreprocessingInfo*&gt; cppDirectiveList;</a>
<a name="17996"><span class="lineNum">   17996 </span>            : </a>
<a name="17997"><span class="lineNum">   17997 </span>            :           void visit(SgNode *astNode);</a>
<a name="17998"><span class="lineNum">   17998 </span>            :    };</a>
<a name="17999"><span class="lineNum">   17999 </span>            : </a>
<a name="18000"><span class="lineNum">   18000 </span>            : </a>
<a name="18001"><span class="lineNum">   18001 </span>            : void</a>
<a name="18002"><span class="lineNum">   18002 </span><span class="lineNoCov">          0 : CollectCppDirectivesTraversal::visit(SgNode *astNode)</span></a>
<a name="18003"><span class="lineNum">   18003 </span>            :    {</a>
<a name="18004"><span class="lineNum">   18004 </span><span class="lineNoCov">          0 :      SgLocatedNode* locatedNode = isSgLocatedNode(astNode);</span></a>
<a name="18005"><span class="lineNum">   18005 </span><span class="lineNoCov">          0 :      if (locatedNode != NULL)</span></a>
<a name="18006"><span class="lineNum">   18006 </span>            :         {</a>
<a name="18007"><span class="lineNum">   18007 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType* comments = locatedNode-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="18008"><span class="lineNum">   18008 </span>            : </a>
<a name="18009"><span class="lineNum">   18009 </span><span class="lineNoCov">          0 :           if (comments != NULL)</span></a>
<a name="18010"><span class="lineNum">   18010 </span>            :              {</a>
<a name="18011"><span class="lineNum">   18011 </span>            : #if 0</a>
<a name="18012"><span class="lineNum">   18012 </span>            :                printf (&quot;Found attached comments (at %p of type: %s): \n&quot;,locatedNode,locatedNode-&gt;sage_class_name());</a>
<a name="18013"><span class="lineNum">   18013 </span>            : #endif</a>
<a name="18014"><span class="lineNum">   18014 </span><span class="lineNoCov">          0 :                AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="18015"><span class="lineNum">   18015 </span><span class="lineNoCov">          0 :                for (i = comments-&gt;begin(); i != comments-&gt;end(); i++)</span></a>
<a name="18016"><span class="lineNum">   18016 </span>            :                   {</a>
<a name="18017"><span class="lineNum">   18017 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT ( (*i) != NULL );</span></a>
<a name="18018"><span class="lineNum">   18018 </span>            : #if 0</a>
<a name="18019"><span class="lineNum">   18019 </span>            :                     printf (&quot;          Attached Comment (relativePosition=%s): %s\n&quot;,</a>
<a name="18020"><span class="lineNum">   18020 </span>            :                          ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="18021"><span class="lineNum">   18021 </span>            :                          (*i)-&gt;getString().c_str());</a>
<a name="18022"><span class="lineNum">   18022 </span>            :                     printf (&quot;Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*i)-&gt;getNumberOfLines(),(*i)-&gt;getColumnNumberOfEndOfString());</a>
<a name="18023"><span class="lineNum">   18023 </span>            :                     (*i)-&gt;get_file_info()-&gt;display(&quot;comment/directive location&quot;);</a>
<a name="18024"><span class="lineNum">   18024 </span>            : #endif</a>
<a name="18025"><span class="lineNum">   18025 </span>            : </a>
<a name="18026"><span class="lineNum">   18026 </span>            :                  // We only save the #include directives, but likely we should be collecting ALL directives to</a>
<a name="18027"><span class="lineNum">   18027 </span>            :                  // avoid the collection of #include that is meant to be hidden in an #if 0 ... #endif pairing.</a>
<a name="18028"><span class="lineNum">   18028 </span>            :                  // if ((*i)-&gt;getTypeOfDirective() == PreprocessingInfo::CpreprocessorIncludeDeclaration)</a>
<a name="18029"><span class="lineNum">   18029 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="18030"><span class="lineNum">   18030 </span>            :                       // This is an include directive.</a>
<a name="18031"><span class="lineNum">   18031 </span><span class="lineNoCov">          0 :                          cppDirectiveList.push_back(*i);</span></a>
<a name="18032"><span class="lineNum">   18032 </span>            : #if 0</a>
<a name="18033"><span class="lineNum">   18033 </span>            :                          printf (&quot;          Attached include directive (relativePosition=%s): %s\n&quot;,</a>
<a name="18034"><span class="lineNum">   18034 </span>            :                               ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="18035"><span class="lineNum">   18035 </span>            :                               (*i)-&gt;getString().c_str());</a>
<a name="18036"><span class="lineNum">   18036 </span>            : #endif</a>
<a name="18037"><span class="lineNum">   18037 </span>            :                        }</a>
<a name="18038"><span class="lineNum">   18038 </span>            :                   }</a>
<a name="18039"><span class="lineNum">   18039 </span>            :              }</a>
<a name="18040"><span class="lineNum">   18040 </span>            :             else</a>
<a name="18041"><span class="lineNum">   18041 </span>            :              {</a>
<a name="18042"><span class="lineNum">   18042 </span>            : #if 0</a>
<a name="18043"><span class="lineNum">   18043 </span>            :                printf (&quot;No attached comments (at %p of type: %s): \n&quot;,locatedNode,locatedNode-&gt;sage_class_name());</a>
<a name="18044"><span class="lineNum">   18044 </span>            : #endif</a>
<a name="18045"><span class="lineNum">   18045 </span>            :              }</a>
<a name="18046"><span class="lineNum">   18046 </span>            :         }</a>
<a name="18047"><span class="lineNum">   18047 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18048"><span class="lineNum">   18048 </span>            : </a>
<a name="18049"><span class="lineNum">   18049 </span>            : </a>
<a name="18050"><span class="lineNum">   18050 </span>            : // This is part of a mechanism to collect directives from code that is to be outlined.</a>
<a name="18051"><span class="lineNum">   18051 </span>            : // However if we collect include directives we likely should really be collecting ALL</a>
<a name="18052"><span class="lineNum">   18052 </span>            : // directives (since the #include could be inside of an #if 0 ... #endif pairing.</a>
<a name="18053"><span class="lineNum">   18053 </span>            : // This level of detail will be addressed later (in an iterative approach).</a>
<a name="18054"><span class="lineNum">   18054 </span>            : vector&lt;PreprocessingInfo*&gt;</a>
<a name="18055"><span class="lineNum">   18055 </span><span class="lineNoCov">          0 : collectCppDirectives ( SgSourceFile* file )</span></a>
<a name="18056"><span class="lineNum">   18056 </span>            :    {</a>
<a name="18057"><span class="lineNum">   18057 </span>            :   // This function is used to collect include directives from the whole file.</a>
<a name="18058"><span class="lineNum">   18058 </span><span class="lineNoCov">          0 :      CollectCppDirectivesTraversal t;</span></a>
<a name="18059"><span class="lineNum">   18059 </span><span class="lineNoCov">          0 :      t.traverse(file,preorder);</span></a>
<a name="18060"><span class="lineNum">   18060 </span>            : </a>
<a name="18061"><span class="lineNum">   18061 </span><span class="lineNoCov">          0 :      return t.cppDirectiveList;</span></a>
<a name="18062"><span class="lineNum">   18062 </span>            :    }</a>
<a name="18063"><span class="lineNum">   18063 </span>            : </a>
<a name="18064"><span class="lineNum">   18064 </span>            : </a>
<a name="18065"><span class="lineNum">   18065 </span>            : vector&lt;PreprocessingInfo*&gt;</a>
<a name="18066"><span class="lineNum">   18066 </span><span class="lineNoCov">          0 : collectCppDirectives ( SgLocatedNode* n )</span></a>
<a name="18067"><span class="lineNum">   18067 </span>            :    {</a>
<a name="18068"><span class="lineNum">   18068 </span>            :   // This function is used to collect include directives from specific dependent declarations.</a>
<a name="18069"><span class="lineNum">   18069 </span><span class="lineNoCov">          0 :      CollectCppDirectivesTraversal t;</span></a>
<a name="18070"><span class="lineNum">   18070 </span><span class="lineNoCov">          0 :      t.traverse(n,preorder);</span></a>
<a name="18071"><span class="lineNum">   18071 </span>            : </a>
<a name="18072"><span class="lineNum">   18072 </span><span class="lineNoCov">          0 :      return t.cppDirectiveList;</span></a>
<a name="18073"><span class="lineNum">   18073 </span>            :    }</a>
<a name="18074"><span class="lineNum">   18074 </span>            : </a>
<a name="18075"><span class="lineNum">   18075 </span>            : // Debugging support.</a>
<a name="18076"><span class="lineNum">   18076 </span>            : void</a>
<a name="18077"><span class="lineNum">   18077 </span><span class="lineNoCov">          0 : outputPreprocessingInfoList ( const vector&lt;PreprocessingInfo*&gt; &amp; l )</span></a>
<a name="18078"><span class="lineNum">   18078 </span>            :    {</a>
<a name="18079"><span class="lineNum">   18079 </span>            :   // This function support debugging the generated directive lists.</a>
<a name="18080"><span class="lineNum">   18080 </span>            : </a>
<a name="18081"><span class="lineNum">   18081 </span><span class="lineNoCov">          0 :      vector&lt;PreprocessingInfo*&gt;::const_iterator i = l.begin();</span></a>
<a name="18082"><span class="lineNum">   18082 </span><span class="lineNoCov">          0 :      while ( i != l.end() )</span></a>
<a name="18083"><span class="lineNum">   18083 </span>            :         {</a>
<a name="18084"><span class="lineNum">   18084 </span><span class="lineNoCov">          0 :           printf (&quot;          Attached include directive (relativePosition=%s): %s\n&quot;,</span></a>
<a name="18085"><span class="lineNum">   18085 </span><span class="lineNoCov">          0 :              ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</span></a>
<a name="18086"><span class="lineNum">   18086 </span><span class="lineNoCov">          0 :              (*i)-&gt;getString().c_str());</span></a>
<a name="18087"><span class="lineNum">   18087 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="18088"><span class="lineNum">   18088 </span>            :         }</a>
<a name="18089"><span class="lineNum">   18089 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18090"><span class="lineNum">   18090 </span>            : </a>
<a name="18091"><span class="lineNum">   18091 </span>            : </a>
<a name="18092"><span class="lineNum">   18092 </span>            : </a>
<a name="18093"><span class="lineNum">   18093 </span>            : SgDeclarationStatement*</a>
<a name="18094"><span class="lineNum">   18094 </span><span class="lineCov">          9 : getAssociatedDeclaration( SgScopeStatement* scope )</span></a>
<a name="18095"><span class="lineNum">   18095 </span>            :    {</a>
<a name="18096"><span class="lineNum">   18096 </span>            :   //TODO This should become a member of SgScopeStatement</a>
<a name="18097"><span class="lineNum">   18097 </span>            : </a>
<a name="18098"><span class="lineNum">   18098 </span><span class="lineCov">          9 :      SgDeclarationStatement* declaration = NULL;</span></a>
<a name="18099"><span class="lineNum">   18099 </span><span class="lineCov">          9 :      switch(scope-&gt;variantT())</span></a>
<a name="18100"><span class="lineNum">   18100 </span>            :         {</a>
<a name="18101"><span class="lineNum">   18101 </span><span class="lineCov">          6 :           case V_SgNamespaceDefinitionStatement:</span></a>
<a name="18102"><span class="lineNum">   18102 </span><span class="lineCov">          6 :              {</span></a>
<a name="18103"><span class="lineNum">   18103 </span><span class="lineCov">          6 :                SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);</span></a>
<a name="18104"><span class="lineNum">   18104 </span><span class="lineCov">          6 :                declaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="18105"><span class="lineNum">   18105 </span><span class="lineCov">          6 :                break;</span></a>
<a name="18106"><span class="lineNum">   18106 </span>            :              }</a>
<a name="18107"><span class="lineNum">   18107 </span>            : </a>
<a name="18108"><span class="lineNum">   18108 </span><span class="lineCov">          3 :           case V_SgClassDefinition:</span></a>
<a name="18109"><span class="lineNum">   18109 </span><span class="lineCov">          3 :           case V_SgTemplateInstantiationDefn: // Liao, 5/12/2009</span></a>
<a name="18110"><span class="lineNum">   18110 </span><span class="lineCov">          3 :              {</span></a>
<a name="18111"><span class="lineNum">   18111 </span><span class="lineCov">          3 :                SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="18112"><span class="lineNum">   18112 </span><span class="lineCov">          3 :                declaration = classDefinition-&gt;get_declaration();</span></a>
<a name="18113"><span class="lineNum">   18113 </span><span class="lineCov">          3 :                break;</span></a>
<a name="18114"><span class="lineNum">   18114 </span>            :              }</a>
<a name="18115"><span class="lineNum">   18115 </span>            : </a>
<a name="18116"><span class="lineNum">   18116 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="18117"><span class="lineNum">   18117 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="18118"><span class="lineNum">   18118 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached in getAssociatedDeclaration(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="18119"><span class="lineNum">   18119 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="18120"><span class="lineNum">   18120 </span>            :              }</a>
<a name="18121"><span class="lineNum">   18121 </span>            :         }</a>
<a name="18122"><span class="lineNum">   18122 </span>            : </a>
<a name="18123"><span class="lineNum">   18123 </span>            :   // There may be some scopes that don't have an associated declaration.</a>
<a name="18124"><span class="lineNum">   18124 </span><span class="lineCov">          9 :      ROSE_ASSERT(declaration != NULL);</span></a>
<a name="18125"><span class="lineNum">   18125 </span>            : </a>
<a name="18126"><span class="lineNum">   18126 </span><span class="lineCov">          9 :      return declaration;</span></a>
<a name="18127"><span class="lineNum">   18127 </span>            :    }</a>
<a name="18128"><span class="lineNum">   18128 </span>            : </a>
<a name="18129"><span class="lineNum">   18129 </span>            : </a>
<a name="18130"><span class="lineNum">   18130 </span><span class="lineCov">          2 : class CollectDependentDeclarationsTraversal : public SgSimpleProcessing</span></a>
<a name="18131"><span class="lineNum">   18131 </span>            :    {</a>
<a name="18132"><span class="lineNum">   18132 </span>            :      public:</a>
<a name="18133"><span class="lineNum">   18133 </span>            :        // Accumulate a list of copies of associated declarations referenced in the AST subtree</a>
<a name="18134"><span class="lineNum">   18134 </span>            :        // (usually of the outlined functions) to insert in the separate file to support outlining.</a>
<a name="18135"><span class="lineNum">   18135 </span>            :           vector&lt;SgDeclarationStatement*&gt; declarationList;</a>
<a name="18136"><span class="lineNum">   18136 </span>            : </a>
<a name="18137"><span class="lineNum">   18137 </span>            :        // Save the list of associated symbols of dependent declarations identified so that we can</a>
<a name="18138"><span class="lineNum">   18138 </span>            :        // support their replacement in the new AST.</a>
<a name="18139"><span class="lineNum">   18139 </span>            :           vector&lt;SgSymbol*&gt; symbolList;</a>
<a name="18140"><span class="lineNum">   18140 </span>            : </a>
<a name="18141"><span class="lineNum">   18141 </span>            :        // Keep track of declarations already copied so that we don't copy them more than once and try to insert them.</a>
<a name="18142"><span class="lineNum">   18142 </span>            :           set&lt;SgDeclarationStatement*&gt; alreadySavedDeclarations;</a>
<a name="18143"><span class="lineNum">   18143 </span>            : </a>
<a name="18144"><span class="lineNum">   18144 </span>            :        // Required visit function for the AST traversal</a>
<a name="18145"><span class="lineNum">   18145 </span>            :           void visit(SgNode *astNode);</a>
<a name="18146"><span class="lineNum">   18146 </span>            :      private:</a>
<a name="18147"><span class="lineNum">   18147 </span>            :        void addDeclaration(SgDeclarationStatement* decl);</a>
<a name="18148"><span class="lineNum">   18148 </span>            :    };</a>
<a name="18149"><span class="lineNum">   18149 </span>            : </a>
<a name="18150"><span class="lineNum">   18150 </span>            : SgDeclarationStatement*</a>
<a name="18151"><span class="lineNum">   18151 </span><span class="lineCov">          6 : getGlobalScopeDeclaration( SgDeclarationStatement* inputDeclaration )</span></a>
<a name="18152"><span class="lineNum">   18152 </span>            :    {</a>
<a name="18153"><span class="lineNum">   18153 </span>            :   // DQ (2/16/2009): Basically if a class is used from a namespace (or any outer scope) and we</a>
<a name="18154"><span class="lineNum">   18154 </span>            :   // outline the reference to the class, we have to declare not the class but the outer scope</a>
<a name="18155"><span class="lineNum">   18155 </span>            :   // (which will have the class included).</a>
<a name="18156"><span class="lineNum">   18156 </span>            : </a>
<a name="18157"><span class="lineNum">   18157 </span><span class="lineCov">          6 :      SgDeclarationStatement* returnDeclaration = inputDeclaration;</span></a>
<a name="18158"><span class="lineNum">   18158 </span>            : </a>
<a name="18159"><span class="lineNum">   18159 </span>            :   // I think that we have to copy the outer scope if the declaration's scope is not SgGlobal.</a>
<a name="18160"><span class="lineNum">   18160 </span><span class="lineCov">          6 :      SgScopeStatement* scope = inputDeclaration-&gt;get_scope();</span></a>
<a name="18161"><span class="lineNum">   18161 </span><span class="lineCov">          6 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="18162"><span class="lineNum">   18162 </span>            : </a>
<a name="18163"><span class="lineNum">   18163 </span>            :   // printf (&quot;inputDeclaration-&gt;get_scope() = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="18164"><span class="lineNum">   18164 </span>            : </a>
<a name="18165"><span class="lineNum">   18165 </span>            :   // If the input declaration is not in global scope then find the parent declaration that is in global scope!</a>
<a name="18166"><span class="lineNum">   18166 </span><span class="lineCov">          6 :      SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="18167"><span class="lineNum">   18167 </span><span class="lineCov">          6 :      if (globalScope == NULL)</span></a>
<a name="18168"><span class="lineNum">   18168 </span>            :         {</a>
<a name="18169"><span class="lineNum">   18169 </span>            :        // Traverse back to the global scope to include outer declarations which contain the &quot;declaration&quot;</a>
<a name="18170"><span class="lineNum">   18170 </span>            :        // printf (&quot;Traverse back to the global scope to include outer declarations \n&quot;);</a>
<a name="18171"><span class="lineNum">   18171 </span>            : </a>
<a name="18172"><span class="lineNum">   18172 </span><span class="lineCov">          4 :           SgScopeStatement* parentScope = scope;</span></a>
<a name="18173"><span class="lineNum">   18173 </span><span class="lineCov">          4 :           SgDeclarationStatement* associatedDeclaration = returnDeclaration;</span></a>
<a name="18174"><span class="lineNum">   18174 </span><span class="lineCov">          4 :           ROSE_ASSERT(parentScope != NULL);</span></a>
<a name="18175"><span class="lineNum">   18175 </span><span class="lineCov">         13 :           while (globalScope == NULL)</span></a>
<a name="18176"><span class="lineNum">   18176 </span>            :              {</a>
<a name="18177"><span class="lineNum">   18177 </span><span class="lineCov">          9 :                associatedDeclaration = getAssociatedDeclaration(parentScope);</span></a>
<a name="18178"><span class="lineNum">   18178 </span><span class="lineCov">          9 :                ROSE_ASSERT(associatedDeclaration != NULL);</span></a>
<a name="18179"><span class="lineNum">   18179 </span>            : </a>
<a name="18180"><span class="lineNum">   18180 </span><span class="lineCov">          9 :                parentScope = parentScope-&gt;get_scope();</span></a>
<a name="18181"><span class="lineNum">   18181 </span><span class="lineCov">          9 :                globalScope = isSgGlobal(parentScope);</span></a>
<a name="18182"><span class="lineNum">   18182 </span>            :              }</a>
<a name="18183"><span class="lineNum">   18183 </span>            : </a>
<a name="18184"><span class="lineNum">   18184 </span>            :           returnDeclaration = associatedDeclaration;</a>
<a name="18185"><span class="lineNum">   18185 </span>            :         }</a>
<a name="18186"><span class="lineNum">   18186 </span>            : </a>
<a name="18187"><span class="lineNum">   18187 </span><span class="lineCov">          6 :      return returnDeclaration;</span></a>
<a name="18188"><span class="lineNum">   18188 </span>            :    }</a>
<a name="18189"><span class="lineNum">   18189 </span>            : </a>
<a name="18190"><span class="lineNum">   18190 </span>            : </a>
<a name="18191"><span class="lineNum">   18191 </span>            : // Debugging support.</a>
<a name="18192"><span class="lineNum">   18192 </span>            : void</a>
<a name="18193"><span class="lineNum">   18193 </span><span class="lineNoCov">          0 : outputDeclarationList ( const vector&lt;SgDeclarationStatement*&gt; &amp; l )</span></a>
<a name="18194"><span class="lineNum">   18194 </span>            :    {</a>
<a name="18195"><span class="lineNum">   18195 </span>            :   // This function support debugging the generated declarations.</a>
<a name="18196"><span class="lineNum">   18196 </span>            : </a>
<a name="18197"><span class="lineNum">   18197 </span><span class="lineNoCov">          0 :      int counter = 0;</span></a>
<a name="18198"><span class="lineNum">   18198 </span><span class="lineNoCov">          0 :      vector&lt;SgDeclarationStatement*&gt;::const_iterator i = l.begin();</span></a>
<a name="18199"><span class="lineNum">   18199 </span><span class="lineNoCov">          0 :      while ( i != l.end() )</span></a>
<a name="18200"><span class="lineNum">   18200 </span>            :         {</a>
<a name="18201"><span class="lineNum">   18201 </span><span class="lineNoCov">          0 :           printf (&quot;In outputDeclarationList(): list[%d] = %p = %s = %s \n&quot;,counter++,*i,(*i)-&gt;class_name().c_str(),SageInterface::get_name(*i).c_str());</span></a>
<a name="18202"><span class="lineNum">   18202 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="18203"><span class="lineNum">   18203 </span>            :         }</a>
<a name="18204"><span class="lineNum">   18204 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18205"><span class="lineNum">   18205 </span>            : </a>
<a name="18206"><span class="lineNum">   18206 </span><span class="lineCov">          6 : void CollectDependentDeclarationsTraversal::addDeclaration(SgDeclarationStatement* declaration)</span></a>
<a name="18207"><span class="lineNum">   18207 </span>            : {</a>
<a name="18208"><span class="lineNum">   18208 </span>            :   // If there was a declaration found then handle it.</a>
<a name="18209"><span class="lineNum">   18209 </span><span class="lineCov">          6 :      if (declaration != NULL)</span></a>
<a name="18210"><span class="lineNum">   18210 </span>            :         {</a>
<a name="18211"><span class="lineNum">   18211 </span>            :        // Reset the defining declaration in case there is an outer declaration that is more important</a>
<a name="18212"><span class="lineNum">   18212 </span>            :        // to consider the dependent declaration (e.g. a class in a namespace).  In general this will</a>
<a name="18213"><span class="lineNum">   18213 </span>            :        // find the associated outer declaration in the global scope.</a>
<a name="18214"><span class="lineNum">   18214 </span><span class="lineCov">          6 :           SgDeclarationStatement* dependentDeclaration = getGlobalScopeDeclaration(declaration);</span></a>
<a name="18215"><span class="lineNum">   18215 </span>            : </a>
<a name="18216"><span class="lineNum">   18216 </span>            :        // This declaration is in global scope so we just copy the declaration</a>
<a name="18217"><span class="lineNum">   18217 </span>            :        // For namespace declarations: they may have the save name but they have to be saved separated.</a>
<a name="18218"><span class="lineNum">   18218 </span><span class="lineCov">         12 :           if (alreadySavedDeclarations.find(dependentDeclaration) == alreadySavedDeclarations.end())</span></a>
<a name="18219"><span class="lineNum">   18219 </span>            :              {</a>
<a name="18220"><span class="lineNum">   18220 </span>            : #if 0</a>
<a name="18221"><span class="lineNum">   18221 </span>            :                printf (&quot;In CollectDependentDeclarationsTraversal::visit(): selected dependentDeclaration = %p = %s = %s \n&quot;,</a>
<a name="18222"><span class="lineNum">   18222 </span>            :                     dependentDeclaration,dependentDeclaration-&gt;class_name().c_str(),SageInterface::get_name(dependentDeclaration).c_str());</a>
<a name="18223"><span class="lineNum">   18223 </span>            : #endif</a>
<a name="18224"><span class="lineNum">   18224 </span>            :             // DQ (2/22/2009): Semantics change for this function, just save the original declaration, not a copy of it.</a>
<a name="18225"><span class="lineNum">   18225 </span><span class="lineCov">          4 :                declarationList.push_back(dependentDeclaration);</span></a>
<a name="18226"><span class="lineNum">   18226 </span>            : </a>
<a name="18227"><span class="lineNum">   18227 </span>            :             // Record this as a copied declaration</a>
<a name="18228"><span class="lineNum">   18228 </span><span class="lineCov">         10 :                alreadySavedDeclarations.insert(dependentDeclaration);</span></a>
<a name="18229"><span class="lineNum">   18229 </span>            : #if 0</a>
<a name="18230"><span class="lineNum">   18230 </span>            :                printf (&quot;In CollectDependentDeclarationsTraversal::visit(): astNode = %p = %s = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),SageInterface::get_name(astNode).c_str());</a>
<a name="18231"><span class="lineNum">   18231 </span>            :                printf (&quot;############### ADDING dependentDeclaration = %p = %s to alreadySavedDeclarations set (size = %&quot; PRIuPTR &quot;) \n&quot;,</a>
<a name="18232"><span class="lineNum">   18232 </span>            :                     dependentDeclaration,dependentDeclaration-&gt;class_name().c_str(),alreadySavedDeclarations.size());</a>
<a name="18233"><span class="lineNum">   18233 </span>            : #endif</a>
<a name="18234"><span class="lineNum">   18234 </span>            :             // DQ (2/21/2009): Added assertions (will be inforced in SageInterface::appendStatementWithDependentDeclaration()).</a>
<a name="18235"><span class="lineNum">   18235 </span>            :             // ROSE_ASSERT(copy_definingDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</a>
<a name="18236"><span class="lineNum">   18236 </span>            :              }</a>
<a name="18237"><span class="lineNum">   18237 </span>            :             else</a>
<a name="18238"><span class="lineNum">   18238 </span>            :              {</a>
<a name="18239"><span class="lineNum">   18239 </span>            : #if 0</a>
<a name="18240"><span class="lineNum">   18240 </span>            :                printf (&quot;In CollectDependentDeclarationsTraversal::visit(): astNode = %p = %s = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),SageInterface::get_name(astNode).c_str());</a>
<a name="18241"><span class="lineNum">   18241 </span>            :                printf (&quot;############### EXISTING dependentDeclaration = %p = %s found in alreadySavedDeclarations set (size = %&quot; PRIuPTR &quot;) \n&quot;,</a>
<a name="18242"><span class="lineNum">   18242 </span>            :                     dependentDeclaration,dependentDeclaration-&gt;class_name().c_str(),alreadySavedDeclarations.size());</a>
<a name="18243"><span class="lineNum">   18243 </span>            : #endif</a>
<a name="18244"><span class="lineNum">   18244 </span>            :              }</a>
<a name="18245"><span class="lineNum">   18245 </span>            :         }</a>
<a name="18246"><span class="lineNum">   18246 </span><span class="lineCov">          6 : }</span></a>
<a name="18247"><span class="lineNum">   18247 </span>            : </a>
<a name="18248"><span class="lineNum">   18248 </span>            : //! Collect all typedef declarations used by an input type and its base types</a>
<a name="18249"><span class="lineNum">   18249 </span><span class="lineCov">          4 : static std::vector&lt;SgTypedefDeclaration*&gt; collectTypedefDeclarations(SgType* type)</span></a>
<a name="18250"><span class="lineNum">   18250 </span>            : {</a>
<a name="18251"><span class="lineNum">   18251 </span><span class="lineCov">          4 :   ROSE_ASSERT(type != NULL);</span></a>
<a name="18252"><span class="lineNum">   18252 </span><span class="lineCov">          4 :   std::vector&lt;SgTypedefDeclaration*&gt; result;</span></a>
<a name="18253"><span class="lineNum">   18253 </span><span class="lineCov">          4 :   SgType* currentType = type;</span></a>
<a name="18254"><span class="lineNum">   18254 </span>            : </a>
<a name="18255"><span class="lineNum">   18255 </span><span class="lineCov">          4 :   SgModifierType*  modType     = NULL;</span></a>
<a name="18256"><span class="lineNum">   18256 </span><span class="lineCov">          4 :   SgPointerType*   pointType   = NULL;</span></a>
<a name="18257"><span class="lineNum">   18257 </span><span class="lineCov">          4 :   SgReferenceType* refType     = NULL;</span></a>
<a name="18258"><span class="lineNum">   18258 </span><span class="lineCov">          4 :   SgArrayType*     arrayType   = NULL;</span></a>
<a name="18259"><span class="lineNum">   18259 </span><span class="lineCov">          4 :   SgTypedefType*   typedefType = NULL;</span></a>
<a name="18260"><span class="lineNum">   18260 </span>            : </a>
<a name="18261"><span class="lineNum">   18261 </span><span class="lineCov">          4 :   while (true)</span></a>
<a name="18262"><span class="lineNum">   18262 </span>            :   {</a>
<a name="18263"><span class="lineNum">   18263 </span><span class="lineCov">          4 :     modType = isSgModifierType(currentType);</span></a>
<a name="18264"><span class="lineNum">   18264 </span><span class="lineCov">          4 :     if(modType)</span></a>
<a name="18265"><span class="lineNum">   18265 </span>            :     {</a>
<a name="18266"><span class="lineNum">   18266 </span><span class="lineNoCov">          0 :       currentType = modType-&gt;get_base_type();</span></a>
<a name="18267"><span class="lineNum">   18267 </span>            :     }</a>
<a name="18268"><span class="lineNum">   18268 </span>            :     else</a>
<a name="18269"><span class="lineNum">   18269 </span>            :     {</a>
<a name="18270"><span class="lineNum">   18270 </span><span class="lineCov">          4 :       refType = isSgReferenceType(currentType);</span></a>
<a name="18271"><span class="lineNum">   18271 </span><span class="lineCov">          4 :       if(refType)</span></a>
<a name="18272"><span class="lineNum">   18272 </span>            :       {</a>
<a name="18273"><span class="lineNum">   18273 </span><span class="lineNoCov">          0 :         currentType = refType-&gt;get_base_type();</span></a>
<a name="18274"><span class="lineNum">   18274 </span>            :       }</a>
<a name="18275"><span class="lineNum">   18275 </span>            :       else</a>
<a name="18276"><span class="lineNum">   18276 </span>            :       {</a>
<a name="18277"><span class="lineNum">   18277 </span><span class="lineCov">          4 :          pointType = isSgPointerType(currentType);</span></a>
<a name="18278"><span class="lineNum">   18278 </span><span class="lineCov">          4 :         if ( pointType)</span></a>
<a name="18279"><span class="lineNum">   18279 </span>            :         {</a>
<a name="18280"><span class="lineNum">   18280 </span><span class="lineNoCov">          0 :           currentType = pointType-&gt;get_base_type();</span></a>
<a name="18281"><span class="lineNum">   18281 </span>            :         }</a>
<a name="18282"><span class="lineNum">   18282 </span>            :         else</a>
<a name="18283"><span class="lineNum">   18283 </span>            :         {</a>
<a name="18284"><span class="lineNum">   18284 </span><span class="lineCov">          4 :           arrayType = isSgArrayType(currentType);</span></a>
<a name="18285"><span class="lineNum">   18285 </span><span class="lineCov">          4 :           if  (arrayType)</span></a>
<a name="18286"><span class="lineNum">   18286 </span>            :           {</a>
<a name="18287"><span class="lineNum">   18287 </span><span class="lineNoCov">          0 :             currentType = arrayType-&gt;get_base_type();</span></a>
<a name="18288"><span class="lineNum">   18288 </span>            :           }</a>
<a name="18289"><span class="lineNum">   18289 </span>            :           else</a>
<a name="18290"><span class="lineNum">   18290 </span>            :           {</a>
<a name="18291"><span class="lineNum">   18291 </span><span class="lineCov">          4 :             typedefType = isSgTypedefType(currentType);</span></a>
<a name="18292"><span class="lineNum">   18292 </span><span class="lineCov">          4 :             if (typedefType)</span></a>
<a name="18293"><span class="lineNum">   18293 </span>            :             {</a>
<a name="18294"><span class="lineNum">   18294 </span><span class="lineNoCov">          0 :               currentType = typedefType-&gt;get_base_type();</span></a>
<a name="18295"><span class="lineNum">   18295 </span><span class="lineNoCov">          0 :               SgTypedefDeclaration* tdecl = isSgTypedefDeclaration(typedefType-&gt;get_declaration());</span></a>
<a name="18296"><span class="lineNum">   18296 </span>            :               // have to try to get the defining declaration for a defining typedef declaration</a>
<a name="18297"><span class="lineNum">   18297 </span>            :               // otherwise AST traversal will not visit the non-defining one for a defining typedef declaration</a>
<a name="18298"><span class="lineNum">   18298 </span>            :               // sortSgNodeListBasedOnAppearanceOrderInSource() won't work properly</a>
<a name="18299"><span class="lineNum">   18299 </span><span class="lineNoCov">          0 :               SgTypedefDeclaration* decl = isSgTypedefDeclaration(tdecl-&gt;get_definingDeclaration());</span></a>
<a name="18300"><span class="lineNum">   18300 </span><span class="lineNoCov">          0 :               if (decl ==NULL)</span></a>
<a name="18301"><span class="lineNum">   18301 </span><span class="lineNoCov">          0 :                 decl = tdecl;</span></a>
<a name="18302"><span class="lineNum">   18302 </span><span class="lineNoCov">          0 :               result.push_back(decl);</span></a>
<a name="18303"><span class="lineNum">   18303 </span>            :             }</a>
<a name="18304"><span class="lineNum">   18304 </span>            :             else</a>
<a name="18305"><span class="lineNum">   18305 </span>            :             {</a>
<a name="18306"><span class="lineNum">   18306 </span>            :               // Exit the while(true){} loop!</a>
<a name="18307"><span class="lineNum">   18307 </span>            :               break;</a>
<a name="18308"><span class="lineNum">   18308 </span>            :             }</a>
<a name="18309"><span class="lineNum">   18309 </span>            :           }</a>
<a name="18310"><span class="lineNum">   18310 </span>            :         }</a>
<a name="18311"><span class="lineNum">   18311 </span>            :       }</a>
<a name="18312"><span class="lineNum">   18312 </span>            :     }</a>
<a name="18313"><span class="lineNum">   18313 </span>            :   }</a>
<a name="18314"><span class="lineNum">   18314 </span>            : #if 0</a>
<a name="18315"><span class="lineNum">   18315 </span>            :   // debug here</a>
<a name="18316"><span class="lineNum">   18316 </span>            :   if (result.size()&gt;0)</a>
<a name="18317"><span class="lineNum">   18317 </span>            :   {</a>
<a name="18318"><span class="lineNum">   18318 </span>            :     cout&lt;&lt;&quot;------------Found a chain of typedef decls: count=&quot;&lt;&lt;result.size()&lt;&lt;endl;</a>
<a name="18319"><span class="lineNum">   18319 </span>            :     for (vector &lt;SgTypedefDeclaration*&gt;::const_iterator iter = result.begin();</a>
<a name="18320"><span class="lineNum">   18320 </span>            :           iter!=result.end(); iter ++)</a>
<a name="18321"><span class="lineNum">   18321 </span>            :       cout&lt;&lt;(*iter)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="18322"><span class="lineNum">   18322 </span>            :   }</a>
<a name="18323"><span class="lineNum">   18323 </span>            : #endif</a>
<a name="18324"><span class="lineNum">   18324 </span><span class="lineCov">          4 :   return result;</span></a>
<a name="18325"><span class="lineNum">   18325 </span>            : }</a>
<a name="18326"><span class="lineNum">   18326 </span>            : </a>
<a name="18327"><span class="lineNum">   18327 </span>            : //! visitor function for each node to collect non-builtin types' declarations</a>
<a name="18328"><span class="lineNum">   18328 </span>            : void</a>
<a name="18329"><span class="lineNum">   18329 </span><span class="lineCov">         48 : CollectDependentDeclarationsTraversal::visit(SgNode *astNode)</span></a>
<a name="18330"><span class="lineNum">   18330 </span>            :    {</a>
<a name="18331"><span class="lineNum">   18331 </span>            :   // Statements that can cause us to have declaration dependences:</a>
<a name="18332"><span class="lineNum">   18332 </span>            :   //    1) variable declarations (through their types)</a>
<a name="18333"><span class="lineNum">   18333 </span>            :   //    2) function calls</a>
<a name="18334"><span class="lineNum">   18334 </span>            :   //    3) typedefs (through their base types)</a>
<a name="18335"><span class="lineNum">   18335 </span>            :   //  Not implemented:</a>
<a name="18336"><span class="lineNum">   18336 </span>            :   //    4) static member functions (through their class)</a>
<a name="18337"><span class="lineNum">   18337 </span>            :   //    5) static data members (through their class)</a>
<a name="18338"><span class="lineNum">   18338 </span>            :   //    6) namespaces</a>
<a name="18339"><span class="lineNum">   18339 </span>            :   //    7) #include&lt;&gt; CPP directives.</a>
<a name="18340"><span class="lineNum">   18340 </span>            : </a>
<a name="18341"><span class="lineNum">   18341 </span>            :   // DQ (2/22/2009): Changing the semantics for this function,</a>
<a name="18342"><span class="lineNum">   18342 </span>            :   // just save the original declaration, not a copy of it.</a>
<a name="18343"><span class="lineNum">   18343 </span>            : </a>
<a name="18344"><span class="lineNum">   18344 </span>            : #if 0</a>
<a name="18345"><span class="lineNum">   18345 </span>            :   // Debugging support.</a>
<a name="18346"><span class="lineNum">   18346 </span>            :      Sg_File_Info* fileInfo = astNode-&gt;get_file_info();</a>
<a name="18347"><span class="lineNum">   18347 </span>            :      if (fileInfo != NULL &amp;&amp; fileInfo-&gt;isFrontendSpecific() == false &amp;&amp; (isSgStatement(astNode) != NULL) )</a>
<a name="18348"><span class="lineNum">   18348 </span>            :         {</a>
<a name="18349"><span class="lineNum">   18349 </span>            :           printf (&quot;\n\nIn CollectDependentDeclarationsTraversal::visit(): astNode = %p = %s = %s \n&quot;,astNode,astNode-&gt;class_name().c_str(),SageInterface::get_name(astNode).c_str());</a>
<a name="18350"><span class="lineNum">   18350 </span>            :        // fileInfo-&gt;display(&quot;In CollectDependentDeclarationsTraversal::visit()&quot;);</a>
<a name="18351"><span class="lineNum">   18351 </span>            :           int counter = 0;</a>
<a name="18352"><span class="lineNum">   18352 </span>            :           printf (&quot;alreadySavedDeclarations.size() = %&quot; PRIuPTR &quot; \n&quot;,alreadySavedDeclarations.size());</a>
<a name="18353"><span class="lineNum">   18353 </span>            :           for (set&lt;SgDeclarationStatement*&gt;::iterator i = alreadySavedDeclarations.begin(); i != alreadySavedDeclarations.end(); i++)</a>
<a name="18354"><span class="lineNum">   18354 </span>            :              {</a>
<a name="18355"><span class="lineNum">   18355 </span>            :                printf (&quot;alreadySavedDeclarations %d: %p = %s \n&quot;,counter++,*i,(*i)-&gt;class_name().c_str());</a>
<a name="18356"><span class="lineNum">   18356 </span>            :              }</a>
<a name="18357"><span class="lineNum">   18357 </span>            :         }</a>
<a name="18358"><span class="lineNum">   18358 </span>            : #endif</a>
<a name="18359"><span class="lineNum">   18359 </span>            : </a>
<a name="18360"><span class="lineNum">   18360 </span>            :   // The following conditionals set this variable</a>
<a name="18361"><span class="lineNum">   18361 </span><span class="lineCov">         48 :      SgDeclarationStatement* declaration = NULL;</span></a>
<a name="18362"><span class="lineNum">   18362 </span>            : </a>
<a name="18363"><span class="lineNum">   18363 </span>            :   // 1) ------------------------------------------------------------------</a>
<a name="18364"><span class="lineNum">   18364 </span>            :   // Collect the declarations associated with referenced types in variable declarations (or any types associated with SgInitializedName IR nodes)</a>
<a name="18365"><span class="lineNum">   18365 </span><span class="lineCov">         48 :      SgInitializedName* initializedname = isSgInitializedName(astNode);</span></a>
<a name="18366"><span class="lineNum">   18366 </span><span class="lineCov">         48 :      if (initializedname != NULL)</span></a>
<a name="18367"><span class="lineNum">   18367 </span>            :      {</a>
<a name="18368"><span class="lineNum">   18368 </span><span class="lineCov">          4 :        SgType* type = initializedname-&gt;get_type();</span></a>
<a name="18369"><span class="lineNum">   18369 </span>            : </a>
<a name="18370"><span class="lineNum">   18370 </span>            :        // handle all dependent typedef declarations, if any</a>
<a name="18371"><span class="lineNum">   18371 </span><span class="lineCov">          8 :        std::vector &lt;SgTypedefDeclaration*&gt; typedefVec = collectTypedefDeclarations(type);</span></a>
<a name="18372"><span class="lineNum">   18372 </span><span class="lineCov">          4 :         for (std::vector &lt;SgTypedefDeclaration*&gt;::const_iterator iter =typedefVec.begin();</span></a>
<a name="18373"><span class="lineNum">   18373 </span><span class="lineCov">          4 :                 iter != typedefVec.end(); iter++)</span></a>
<a name="18374"><span class="lineNum">   18374 </span>            :        {</a>
<a name="18375"><span class="lineNum">   18375 </span><span class="lineNoCov">          0 :          SgTypedefDeclaration* typedef_decl = *iter;</span></a>
<a name="18376"><span class="lineNum">   18376 </span><span class="lineNoCov">          0 :          addDeclaration(typedef_decl);</span></a>
<a name="18377"><span class="lineNum">   18377 </span><span class="lineNoCov">          0 :          symbolList.push_back(typedef_decl-&gt;get_symbol_from_symbol_table());</span></a>
<a name="18378"><span class="lineNum">   18378 </span>            :        }</a>
<a name="18379"><span class="lineNum">   18379 </span>            : </a>
<a name="18380"><span class="lineNum">   18380 </span>            :       // handle base type:</a>
<a name="18381"><span class="lineNum">   18381 </span><span class="lineCov">          4 :        SgType* strippedType = type;</span></a>
<a name="18382"><span class="lineNum">   18382 </span>            :        // We now can to strip typedefs since they are already handled by collectTypedefDeclarations()</a>
<a name="18383"><span class="lineNum">   18383 </span>            :        // this also reach to the defining body of a defining typedef declaration</a>
<a name="18384"><span class="lineNum">   18384 </span>            :        // and treat it as an independent declarations,</a>
<a name="18385"><span class="lineNum">   18385 </span>            :        // the assumption here is that a defining typedef declaration will only has its</a>
<a name="18386"><span class="lineNum">   18386 </span>            :        // nondefining declaration copied to avoid redefining of the struct.</a>
<a name="18387"><span class="lineNum">   18387 </span>            :        // This is also a workaround for an AST copy bug: defining body gets lost after copying</a>
<a name="18388"><span class="lineNum">   18388 </span>            :        // a defining typedef declaration.</a>
<a name="18389"><span class="lineNum">   18389 </span>            :        // Liao, 5/8/2009</a>
<a name="18390"><span class="lineNum">   18390 </span>            :        //</a>
<a name="18391"><span class="lineNum">   18391 </span>            :        // e.g. typedef struct hypre_BoxArray_struct</a>
<a name="18392"><span class="lineNum">   18392 </span>            :        // {</a>
<a name="18393"><span class="lineNum">   18393 </span>            :        //          int alloc_size;</a>
<a name="18394"><span class="lineNum">   18394 </span>            :        // } hypre_BoxArray;</a>
<a name="18395"><span class="lineNum">   18395 </span>            :        //</a>
<a name="18396"><span class="lineNum">   18396 </span>            :        // struct hypre_BoxArray_struct will be treated as a strippedType and its declaration</a>
<a name="18397"><span class="lineNum">   18397 </span>            :        // will be inserted.</a>
<a name="18398"><span class="lineNum">   18398 </span>            :        //</a>
<a name="18399"><span class="lineNum">   18399 </span><span class="lineCov">          4 :        strippedType = type-&gt;stripType();</span></a>
<a name="18400"><span class="lineNum">   18400 </span><span class="lineCov">          4 :        SgNamedType* namedType = isSgNamedType(strippedType);</span></a>
<a name="18401"><span class="lineNum">   18401 </span><span class="lineCov">          4 :        if (namedType != NULL)</span></a>
<a name="18402"><span class="lineNum">   18402 </span>            :        {</a>
<a name="18403"><span class="lineNum">   18403 </span>            :          // Note that since this was obtained via the types and types are shared, this is the non-defining</a>
<a name="18404"><span class="lineNum">   18404 </span>            :          // declaration in original program (not the separate file is this is to support outlining into a</a>
<a name="18405"><span class="lineNum">   18405 </span>            :          // separate file.</a>
<a name="18406"><span class="lineNum">   18406 </span><span class="lineCov">          1 :          SgDeclarationStatement* named_decl = namedType-&gt;get_declaration();</span></a>
<a name="18407"><span class="lineNum">   18407 </span>            :          // the case of class declaration, including struct, union</a>
<a name="18408"><span class="lineNum">   18408 </span><span class="lineCov">          1 :          SgClassDeclaration* classDeclaration = isSgClassDeclaration(named_decl);</span></a>
<a name="18409"><span class="lineNum">   18409 </span><span class="lineCov">          1 :          if (classDeclaration != NULL)</span></a>
<a name="18410"><span class="lineNum">   18410 </span>            :          {</a>
<a name="18411"><span class="lineNum">   18411 </span>            :            // printf (&quot;Found class declaration: classDeclaration = %p \n&quot;,classDeclaration);</a>
<a name="18412"><span class="lineNum">   18412 </span><span class="lineCov">          1 :            declaration = classDeclaration-&gt;get_definingDeclaration();</span></a>
<a name="18413"><span class="lineNum">   18413 </span>            :            // Liao, 12/09/2016.</a>
<a name="18414"><span class="lineNum">   18414 </span>            :            // In some cases, forward declaration of class types are used and sufficient, without providing defining declaration.</a>
<a name="18415"><span class="lineNum">   18415 </span>            :            // We should allow this.</a>
<a name="18416"><span class="lineNum">   18416 </span><span class="lineCov">          1 :            if (declaration != NULL)</span></a>
<a name="18417"><span class="lineNum">   18417 </span>            :            {</a>
<a name="18418"><span class="lineNum">   18418 </span>            :              //  ROSE_ASSERT(declaration != NULL);</a>
<a name="18419"><span class="lineNum">   18419 </span><span class="lineCov">          1 :              addDeclaration(declaration);</span></a>
<a name="18420"><span class="lineNum">   18420 </span>            :            }</a>
<a name="18421"><span class="lineNum">   18421 </span>            :            else</a>
<a name="18422"><span class="lineNum">   18422 </span><span class="lineNoCov">          0 :              addDeclaration (classDeclaration); // we use the original forward declaration.</span></a>
<a name="18423"><span class="lineNum">   18423 </span>            : </a>
<a name="18424"><span class="lineNum">   18424 </span>            :            // Note that since types are shared in the AST, the declaration for a named type may be (is)</a>
<a name="18425"><span class="lineNum">   18425 </span>            :            // associated with the class declaration in the original file. However, we want to associated</a>
<a name="18426"><span class="lineNum">   18426 </span>            :            // class declaration in the current file, but since the AST copy mechanism work top-down, this</a>
<a name="18427"><span class="lineNum">   18427 </span>            :            // mapping form the declaration in the original file to the new declaration in the copied AST</a>
<a name="18428"><span class="lineNum">   18428 </span>            :            // is available in the SgCopyHelp map of copied IR nodes.</a>
<a name="18429"><span class="lineNum">   18429 </span>            :            // DQ (3/3/2009): Added support for symbol references to be saved (symbols in the original file).</a>
<a name="18430"><span class="lineNum">   18430 </span>            :            // these symbols will be mapped to their new symbols.</a>
<a name="18431"><span class="lineNum">   18431 </span><span class="lineCov">          1 :            ROSE_ASSERT(classDeclaration-&gt;hasAssociatedSymbol() == true);</span></a>
<a name="18432"><span class="lineNum">   18432 </span><span class="lineCov">          1 :            SgSymbol* classSymbol = classDeclaration-&gt;get_symbol_from_symbol_table();</span></a>
<a name="18433"><span class="lineNum">   18433 </span><span class="lineCov">          1 :            ROSE_ASSERT(classSymbol != NULL);</span></a>
<a name="18434"><span class="lineNum">   18434 </span>            : </a>
<a name="18435"><span class="lineNum">   18435 </span>            :            // printf (&quot;Saving classSymbol = %p \n&quot;,classSymbol);</a>
<a name="18436"><span class="lineNum">   18436 </span><span class="lineCov">          1 :            symbolList.push_back(classSymbol);</span></a>
<a name="18437"><span class="lineNum">   18437 </span>            :          }</a>
<a name="18438"><span class="lineNum">   18438 </span>            : </a>
<a name="18439"><span class="lineNum">   18439 </span>            :          // handle Enum types</a>
<a name="18440"><span class="lineNum">   18440 </span><span class="lineCov">          1 :          SgEnumDeclaration* enum_decl = isSgEnumDeclaration(named_decl);</span></a>
<a name="18441"><span class="lineNum">   18441 </span><span class="lineCov">          1 :          if (enum_decl != NULL)</span></a>
<a name="18442"><span class="lineNum">   18442 </span>            :          {</a>
<a name="18443"><span class="lineNum">   18443 </span><span class="lineNoCov">          0 :            declaration = enum_decl-&gt;get_definingDeclaration();</span></a>
<a name="18444"><span class="lineNum">   18444 </span><span class="lineNoCov">          0 :            ROSE_ASSERT(declaration != NULL);</span></a>
<a name="18445"><span class="lineNum">   18445 </span><span class="lineNoCov">          0 :            addDeclaration(declaration);</span></a>
<a name="18446"><span class="lineNum">   18446 </span><span class="lineNoCov">          0 :            ROSE_ASSERT(enum_decl-&gt;hasAssociatedSymbol() == true);</span></a>
<a name="18447"><span class="lineNum">   18447 </span>            :            // Liao 12/14/2012. use search_for_symbol_from_symbol_table() instead to avoid the defining/nondefing decl issue</a>
<a name="18448"><span class="lineNum">   18448 </span>            :            //SgSymbol* esymbol = enum_decl-&gt;get_symbol_from_symbol_table();</a>
<a name="18449"><span class="lineNum">   18449 </span><span class="lineNoCov">          0 :            SgSymbol* esymbol = enum_decl-&gt;search_for_symbol_from_symbol_table();</span></a>
<a name="18450"><span class="lineNum">   18450 </span><span class="lineNoCov">          0 :            ROSE_ASSERT(esymbol!= NULL);</span></a>
<a name="18451"><span class="lineNum">   18451 </span><span class="lineNoCov">          0 :            symbolList.push_back(esymbol);</span></a>
<a name="18452"><span class="lineNum">   18452 </span>            :          }</a>
<a name="18453"><span class="lineNum">   18453 </span>            :        } // end if namedType</a>
<a name="18454"><span class="lineNum">   18454 </span>            : #if 0</a>
<a name="18455"><span class="lineNum">   18455 </span>            :        printf (&quot;Found reference to type = %p = %s strippedType = %p = %s \n&quot;,type,type-&gt;class_name().c_str(),strippedType,strippedType-&gt;class_name().c_str());</a>
<a name="18456"><span class="lineNum">   18456 </span>            : #endif</a>
<a name="18457"><span class="lineNum">   18457 </span>            :      }// end if (initializedname)</a>
<a name="18458"><span class="lineNum">   18458 </span>            : </a>
<a name="18459"><span class="lineNum">   18459 </span>            :   // 2) ------------------------------------------------------------------</a>
<a name="18460"><span class="lineNum">   18460 </span>            :   // Collect declarations associated with function calls.</a>
<a name="18461"><span class="lineNum">   18461 </span><span class="lineCov">         48 :      SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(astNode);</span></a>
<a name="18462"><span class="lineNum">   18462 </span><span class="lineCov">         48 :      if (functionCallExp != NULL)</span></a>
<a name="18463"><span class="lineNum">   18463 </span>            :         {</a>
<a name="18464"><span class="lineNum">   18464 </span><span class="lineCov">          4 :           declaration = functionCallExp-&gt;getAssociatedFunctionDeclaration();</span></a>
<a name="18465"><span class="lineNum">   18465 </span>            :           //ROSE_ASSERT(declaration != NULL);</a>
<a name="18466"><span class="lineNum">   18466 </span>            :           // We allow a function pointer to have no specific declaration associated.</a>
<a name="18467"><span class="lineNum">   18467 </span><span class="lineCov">          4 :           if (declaration != NULL)</span></a>
<a name="18468"><span class="lineNum">   18468 </span><span class="lineCov">          4 :             addDeclaration(declaration);</span></a>
<a name="18469"><span class="lineNum">   18469 </span>            : </a>
<a name="18470"><span class="lineNum">   18470 </span>            :        // DQ (3/2/2009): Added support for symbol references to be saved (this can be a SgFunctionSymbol or a SgMemberFunctionSymbol).</a>
<a name="18471"><span class="lineNum">   18471 </span><span class="lineCov">          4 :           SgSymbol* functionSymbol = functionCallExp-&gt;getAssociatedFunctionSymbol();</span></a>
<a name="18472"><span class="lineNum">   18472 </span>            :           //ROSE_ASSERT(functionSymbol != NULL);</a>
<a name="18473"><span class="lineNum">   18473 </span>            : </a>
<a name="18474"><span class="lineNum">   18474 </span>            :        // printf (&quot;Saving functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="18475"><span class="lineNum">   18475 </span><span class="lineCov">          4 :           if (functionSymbol)</span></a>
<a name="18476"><span class="lineNum">   18476 </span><span class="lineCov">          4 :             symbolList.push_back(functionSymbol);</span></a>
<a name="18477"><span class="lineNum">   18477 </span>            :         }</a>
<a name="18478"><span class="lineNum">   18478 </span>            : </a>
<a name="18479"><span class="lineNum">   18479 </span>            :     // 3) ------------------------------------------------------------------</a>
<a name="18480"><span class="lineNum">   18480 </span>            :     // Collect enumerate declarations associated with SgEnumVal</a>
<a name="18481"><span class="lineNum">   18481 </span><span class="lineCov">         48 :     SgEnumVal * eval = isSgEnumVal(astNode);</span></a>
<a name="18482"><span class="lineNum">   18482 </span><span class="lineCov">         48 :     if (eval != NULL)</span></a>
<a name="18483"><span class="lineNum">   18483 </span>            :     {</a>
<a name="18484"><span class="lineNum">   18484 </span><span class="lineCov">          1 :       declaration = eval-&gt;get_declaration();</span></a>
<a name="18485"><span class="lineNum">   18485 </span><span class="lineCov">          1 :       ROSE_ASSERT(declaration != NULL);</span></a>
<a name="18486"><span class="lineNum">   18486 </span><span class="lineCov">          1 :       addDeclaration(declaration);</span></a>
<a name="18487"><span class="lineNum">   18487 </span><span class="lineCov">          1 :       SgSymbol* symbol = declaration-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table();</span></a>
<a name="18488"><span class="lineNum">   18488 </span><span class="lineCov">          1 :       ROSE_ASSERT(symbol != NULL);</span></a>
<a name="18489"><span class="lineNum">   18489 </span><span class="lineCov">          1 :       symbolList.push_back(symbol);</span></a>
<a name="18490"><span class="lineNum">   18490 </span>            :     }</a>
<a name="18491"><span class="lineNum">   18491 </span>            : //       addDeclaration(declaration); // do it in different cases individually</a>
<a name="18492"><span class="lineNum">   18492 </span><span class="lineCov">         48 :    }</span></a>
<a name="18493"><span class="lineNum">   18493 </span>            : </a>
<a name="18494"><span class="lineNum">   18494 </span>            : static std::map&lt;const SgStatement*, bool&gt; visitedDeclMap; // avoid infinite recursion</a>
<a name="18495"><span class="lineNum">   18495 </span>            : </a>
<a name="18496"><span class="lineNum">   18496 </span>            : </a>
<a name="18497"><span class="lineNum">   18497 </span>            : //! Collect dependent type declarations and corresponding symbols used by a declaration statement with defining body.</a>
<a name="18498"><span class="lineNum">   18498 </span>            : // Used to separate a function to a new source file and add necessary type declarations into the new file.</a>
<a name="18499"><span class="lineNum">   18499 </span>            : // NOTICE: each call to this function has to have call visitedDeclMap.clear() first!!</a>
<a name="18500"><span class="lineNum">   18500 </span>            : static void</a>
<a name="18501"><span class="lineNum">   18501 </span><span class="lineCov">          2 : getDependentDeclarations (SgStatement* stmt, vector&lt;SgDeclarationStatement*&gt; &amp; declarationList, vector&lt;SgSymbol*&gt; &amp; symbolList )</span></a>
<a name="18502"><span class="lineNum">   18502 </span>            : {</a>
<a name="18503"><span class="lineNum">   18503 </span>            :   // This function returns a list of the dependent declaration for any input statement.</a>
<a name="18504"><span class="lineNum">   18504 </span>            :   // Dependent declaration are functions called, types referenced in variable declarations, etc.</a>
<a name="18505"><span class="lineNum">   18505 </span>            : #if 0</a>
<a name="18506"><span class="lineNum">   18506 </span>            :   printf (&quot;\n\n********************************************************** \n&quot;);</a>
<a name="18507"><span class="lineNum">   18507 </span>            :   printf (&quot; Inside of getDependentDeclarations(stmt = %p = %s) \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="18508"><span class="lineNum">   18508 </span>            :   printf (&quot;********************************************************** \n&quot;);</a>
<a name="18509"><span class="lineNum">   18509 </span>            : #endif</a>
<a name="18510"><span class="lineNum">   18510 </span><span class="lineCov">          2 :  visitedDeclMap[stmt]= true;</span></a>
<a name="18511"><span class="lineNum">   18511 </span><span class="lineCov">          4 :   CollectDependentDeclarationsTraversal t;</span></a>
<a name="18512"><span class="lineNum">   18512 </span><span class="lineCov">          2 :   t.traverse(stmt,preorder);</span></a>
<a name="18513"><span class="lineNum">   18513 </span>            : #if 0</a>
<a name="18514"><span class="lineNum">   18514 </span>            :      declarationList = t.declarationList;</a>
<a name="18515"><span class="lineNum">   18515 </span>            :      symbolList      = t.symbolList;</a>
<a name="18516"><span class="lineNum">   18516 </span>            : #else</a>
<a name="18517"><span class="lineNum">   18517 </span>            :   // Merge to the parent level list</a>
<a name="18518"><span class="lineNum">   18518 </span><span class="lineCov">          2 :   copy(t.declarationList.begin(),t.declarationList.end(), back_inserter(declarationList));</span></a>
<a name="18519"><span class="lineNum">   18519 </span><span class="lineCov">          2 :   copy(t.symbolList.begin(),t.symbolList.end(), back_inserter(symbolList));</span></a>
<a name="18520"><span class="lineNum">   18520 </span>            :     // make their elements unique</a>
<a name="18521"><span class="lineNum">   18521 </span><span class="lineCov">          2 :   sort (declarationList.begin(), declarationList.end());</span></a>
<a name="18522"><span class="lineNum">   18522 </span><span class="lineCov">          2 :   vector&lt;SgDeclarationStatement*&gt;::iterator new_end = unique(declarationList.begin(), declarationList.end());</span></a>
<a name="18523"><span class="lineNum">   18523 </span><span class="lineCov">          2 :   declarationList.erase(new_end, declarationList.end());</span></a>
<a name="18524"><span class="lineNum">   18524 </span>            : </a>
<a name="18525"><span class="lineNum">   18525 </span><span class="lineCov">          2 :   sort (symbolList.begin(), symbolList.end());</span></a>
<a name="18526"><span class="lineNum">   18526 </span><span class="lineCov">          2 :   vector&lt;SgSymbol*&gt;::iterator end2 = unique(symbolList.begin(), symbolList.end());</span></a>
<a name="18527"><span class="lineNum">   18527 </span><span class="lineCov">          2 :   symbolList.erase(end2, symbolList.end());</span></a>
<a name="18528"><span class="lineNum">   18528 </span>            : </a>
<a name="18529"><span class="lineNum">   18529 </span>            : </a>
<a name="18530"><span class="lineNum">   18530 </span>            :   // Liao, 5/7/2009 recursively call itself to get dependent declarations' dependent declarations</a>
<a name="18531"><span class="lineNum">   18531 </span><span class="lineCov">          2 :   for (vector&lt;SgDeclarationStatement*&gt;::const_iterator iter = t.declarationList.begin();</span></a>
<a name="18532"><span class="lineNum">   18532 </span><span class="lineCov">          6 :       iter !=t.declarationList.end(); iter++)</span></a>
<a name="18533"><span class="lineNum">   18533 </span>            :   {</a>
<a name="18534"><span class="lineNum">   18534 </span><span class="lineCov">          4 :     SgDeclarationStatement* decl = *iter;</span></a>
<a name="18535"><span class="lineNum">   18535 </span><span class="lineCov">          4 :     SgType* base_type = NULL;</span></a>
<a name="18536"><span class="lineNum">   18536 </span><span class="lineCov">          4 :     SgStatement* body_stmt= NULL;</span></a>
<a name="18537"><span class="lineNum">   18537 </span>            : </a>
<a name="18538"><span class="lineNum">   18538 </span>            :     // grab base type for a declaration</a>
<a name="18539"><span class="lineNum">   18539 </span>            :     // For class declaration: grab their</a>
<a name="18540"><span class="lineNum">   18540 </span><span class="lineCov">          4 :     if (isSgClassDeclaration(decl))</span></a>
<a name="18541"><span class="lineNum">   18541 </span>            :     {</a>
<a name="18542"><span class="lineNum">   18542 </span><span class="lineCov">          1 :       base_type =  isSgClassDeclaration(decl)-&gt;get_type();</span></a>
<a name="18543"><span class="lineNum">   18543 </span>            :     } else</a>
<a name="18544"><span class="lineNum">   18544 </span><span class="lineCov">          3 :     if (isSgTypedefDeclaration(decl))</span></a>
<a name="18545"><span class="lineNum">   18545 </span>            :     {</a>
<a name="18546"><span class="lineNum">   18546 </span>            : </a>
<a name="18547"><span class="lineNum">   18547 </span>            :       // we don't want to strip of nested typedef declarations</a>
<a name="18548"><span class="lineNum">   18548 </span><span class="lineNoCov">          0 :       base_type = isSgTypedefDeclaration(decl)-&gt;get_base_type()-&gt;stripType(SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_MODIFIER_TYPE);</span></a>
<a name="18549"><span class="lineNum">   18549 </span>            :     }</a>
<a name="18550"><span class="lineNum">   18550 </span>            : </a>
<a name="18551"><span class="lineNum">   18551 </span>            :     //TODO variable declaration, function declaration: parameter list types,</a>
<a name="18552"><span class="lineNum">   18552 </span>            :     // multiple base_type then</a>
<a name="18553"><span class="lineNum">   18553 </span>            : </a>
<a name="18554"><span class="lineNum">   18554 </span>            :     // is the base type associated with a defining body?</a>
<a name="18555"><span class="lineNum">   18555 </span>            :     // TODO enum type</a>
<a name="18556"><span class="lineNum">   18556 </span><span class="lineCov">          4 :       if (isSgClassType(base_type))</span></a>
<a name="18557"><span class="lineNum">   18557 </span>            :       {</a>
<a name="18558"><span class="lineNum">   18558 </span><span class="lineCov">          1 :         SgClassDeclaration* class_decl = isSgClassDeclaration(isSgClassType(base_type)-&gt;get_declaration()-&gt;get_definingDeclaration());</span></a>
<a name="18559"><span class="lineNum">   18559 </span><span class="lineCov">          1 :         if (class_decl!=NULL)</span></a>
<a name="18560"><span class="lineNum">   18560 </span>            :         {</a>
<a name="18561"><span class="lineNum">   18561 </span><span class="lineCov">          1 :           body_stmt = class_decl-&gt;get_definition();</span></a>
<a name="18562"><span class="lineNum">   18562 </span>            :         }</a>
<a name="18563"><span class="lineNum">   18563 </span>            :       }</a>
<a name="18564"><span class="lineNum">   18564 </span>            :     // recursively collect dependent declarations for the body stmt</a>
<a name="18565"><span class="lineNum">   18565 </span><span class="lineCov">          4 :     if ((body_stmt!=NULL) &amp;&amp;(!visitedDeclMap[body_stmt]))</span></a>
<a name="18566"><span class="lineNum">   18566 </span>            :       { // avoid infinite recursion</a>
<a name="18567"><span class="lineNum">   18567 </span><span class="lineCov">          1 :         getDependentDeclarations(body_stmt, declarationList, symbolList);</span></a>
<a name="18568"><span class="lineNum">   18568 </span>            :       }</a>
<a name="18569"><span class="lineNum">   18569 </span>            :     }</a>
<a name="18570"><span class="lineNum">   18570 </span>            : #endif</a>
<a name="18571"><span class="lineNum">   18571 </span><span class="lineCov">          2 : } // end void getDependentDeclarations()</span></a>
<a name="18572"><span class="lineNum">   18572 </span>            : </a>
<a name="18573"><span class="lineNum">   18573 </span>            : </a>
<a name="18574"><span class="lineNum">   18574 </span>            : // Reorder a list of declaration statements based on their appearance order in source files</a>
<a name="18575"><span class="lineNum">   18575 </span>            : // This is essential to insert their copies into a new file in a right order</a>
<a name="18576"><span class="lineNum">   18576 </span>            : // Liao, 5/7/2009</a>
<a name="18577"><span class="lineNum">   18577 </span>            : vector&lt;SgDeclarationStatement*&gt;</a>
<a name="18578"><span class="lineNum">   18578 </span><span class="lineCov">          1 : SageInterface::sortSgNodeListBasedOnAppearanceOrderInSource(const vector&lt;SgDeclarationStatement*&gt;&amp; nodevec)</span></a>
<a name="18579"><span class="lineNum">   18579 </span>            : {</a>
<a name="18580"><span class="lineNum">   18580 </span><span class="lineCov">          2 :   vector&lt;SgDeclarationStatement*&gt; sortedNode;</span></a>
<a name="18581"><span class="lineNum">   18581 </span>            : </a>
<a name="18582"><span class="lineNum">   18582 </span><span class="lineCov">          1 :   if (nodevec.size()==0 )</span></a>
<a name="18583"><span class="lineNum">   18583 </span><span class="lineNoCov">          0 :     return sortedNode;</span></a>
<a name="18584"><span class="lineNum">   18584 </span>            :   // no need to sort if there is only 1 element</a>
<a name="18585"><span class="lineNum">   18585 </span><span class="lineCov">          1 :   if (nodevec.size() ==1)</span></a>
<a name="18586"><span class="lineNum">   18586 </span><span class="lineNoCov">          0 :     return nodevec;</span></a>
<a name="18587"><span class="lineNum">   18587 </span>            : </a>
<a name="18588"><span class="lineNum">   18588 </span><span class="lineCov">          1 :   SgProject* project = SageInterface::getProject();</span></a>
<a name="18589"><span class="lineNum">   18589 </span><span class="lineCov">          2 :   Rose_STL_Container&lt;SgNode*&gt; queryResult = NodeQuery::querySubTree(project,V_SgDeclarationStatement);</span></a>
<a name="18590"><span class="lineNum">   18590 </span><span class="lineCov">          1 :   for (Rose_STL_Container&lt;SgNode*&gt;::const_iterator iter = queryResult.begin();</span></a>
<a name="18591"><span class="lineNum">   18591 </span><span class="lineCov">      27115 :       iter!= queryResult.end(); iter++)</span></a>
<a name="18592"><span class="lineNum">   18592 </span>            :   {</a>
<a name="18593"><span class="lineNum">   18593 </span>            :     //    cerr&lt;&lt;&quot;Trying to match:&quot;&lt;&lt;(*iter)&lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;class_name() &lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="18594"><span class="lineNum">   18594 </span><span class="lineCov">      27114 :     SgNode* cur_node = *iter;</span></a>
<a name="18595"><span class="lineNum">   18595 </span><span class="lineCov">      27114 :     SgDeclarationStatement* cur_stmt =  isSgDeclarationStatement(cur_node);</span></a>
<a name="18596"><span class="lineNum">   18596 </span><span class="lineCov">      27114 :     ROSE_ASSERT(cur_stmt!=NULL);</span></a>
<a name="18597"><span class="lineNum">   18597 </span>            :     // Liao 12/14/2012. It is possible nodevec contains a first non-defining function declaration since the function is called in the outlined function</a>
<a name="18598"><span class="lineNum">   18598 </span>            :     // This is true even if the AST only has a defining function declaration.</a>
<a name="18599"><span class="lineNum">   18599 </span>            :     //</a>
<a name="18600"><span class="lineNum">   18600 </span>            :     // But that first non-defining function declaration is not traversable in AST due to it is hidden.</a>
<a name="18601"><span class="lineNum">   18601 </span>            :     // The solution here is to for each defining function decl traversed, convert it to the first nondefining one to do the match.</a>
<a name="18602"><span class="lineNum">   18602 </span><span class="lineCov">      27114 :     SgFunctionDeclaration * func_decl = isSgFunctionDeclaration (cur_stmt);</span></a>
<a name="18603"><span class="lineNum">   18603 </span><span class="lineCov">      27114 :     if (func_decl)</span></a>
<a name="18604"><span class="lineNum">   18604 </span>            :     {</a>
<a name="18605"><span class="lineNum">   18605 </span><span class="lineCov">       8876 :       if (func_decl-&gt;get_definingDeclaration() == func_decl )</span></a>
<a name="18606"><span class="lineNum">   18606 </span>            :       {</a>
<a name="18607"><span class="lineNum">   18607 </span><span class="lineCov">       1891 :         cur_stmt = func_decl-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="18608"><span class="lineNum">   18608 </span><span class="lineCov">       1891 :         ROSE_ASSERT (cur_stmt != func_decl);</span></a>
<a name="18609"><span class="lineNum">   18609 </span>            :       }</a>
<a name="18610"><span class="lineNum">   18610 </span>            :     }</a>
<a name="18611"><span class="lineNum">   18611 </span><span class="lineCov">      27114 :     vector&lt;SgDeclarationStatement*&gt;::const_iterator i = find (nodevec.begin(), nodevec.end(), cur_stmt);</span></a>
<a name="18612"><span class="lineNum">   18612 </span><span class="lineCov">      27114 :     if (i!=nodevec.end())</span></a>
<a name="18613"><span class="lineNum">   18613 </span>            :     {</a>
<a name="18614"><span class="lineNum">   18614 </span>            :       // It is possible we already visited a real prototype func decl before, now we see a prototype converted from a defining declaration.</a>
<a name="18615"><span class="lineNum">   18615 </span>            :       // We have to make sure only one copy is inserted.</a>
<a name="18616"><span class="lineNum">   18616 </span><span class="lineCov">          4 :       vector&lt;SgDeclarationStatement*&gt;::const_iterator j = find (sortedNode.begin(), sortedNode.end(), *i);</span></a>
<a name="18617"><span class="lineNum">   18617 </span><span class="lineCov">          4 :       if (j == sortedNode.end())</span></a>
<a name="18618"><span class="lineNum">   18618 </span><span class="lineCov">          4 :         sortedNode.push_back(*i);</span></a>
<a name="18619"><span class="lineNum">   18619 </span>            :     }</a>
<a name="18620"><span class="lineNum">   18620 </span>            :   }</a>
<a name="18621"><span class="lineNum">   18621 </span>            : </a>
<a name="18622"><span class="lineNum">   18622 </span><span class="lineCov">          1 :   if (nodevec.size() != sortedNode.size())</span></a>
<a name="18623"><span class="lineNum">   18623 </span>            :   {</a>
<a name="18624"><span class="lineNum">   18624 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Fatal error in sortSgNodeListBasedOnAppearanceOrderInSource(): nodevec.size() != sortedNode.size()&quot;&lt;&lt;endl;</span></a>
<a name="18625"><span class="lineNum">   18625 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;nodevec() have &quot;&lt;&lt; nodevec.size()&lt;&lt;&quot; elements. They are:&quot;&lt;&lt;endl;</span></a>
<a name="18626"><span class="lineNum">   18626 </span><span class="lineNoCov">          0 :     for (vector&lt;SgDeclarationStatement*&gt;::const_iterator iter = nodevec.begin(); iter != nodevec.end(); iter++)</span></a>
<a name="18627"><span class="lineNum">   18627 </span>            :     {</a>
<a name="18628"><span class="lineNum">   18628 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;(*iter)&lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;class_name() &lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;unparseToString()&lt;&lt;endl;</span></a>
<a name="18629"><span class="lineNum">   18629 </span>            :     }</a>
<a name="18630"><span class="lineNum">   18630 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;sortedNode() have &quot; &lt;&lt; sortedNode.size() &lt;&lt;&quot; elements. They are:&quot;&lt;&lt;endl;</span></a>
<a name="18631"><span class="lineNum">   18631 </span><span class="lineNoCov">          0 :     for (vector&lt;SgDeclarationStatement*&gt;::const_iterator iter = sortedNode.begin(); iter != sortedNode.end(); iter++)</span></a>
<a name="18632"><span class="lineNum">   18632 </span>            :     {</a>
<a name="18633"><span class="lineNum">   18633 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;(*iter)&lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;class_name() &lt;&lt;&quot; &quot;&lt;&lt;(*iter)-&gt;unparseToString()&lt;&lt;endl;</span></a>
<a name="18634"><span class="lineNum">   18634 </span>            :     }</a>
<a name="18635"><span class="lineNum">   18635 </span>            : </a>
<a name="18636"><span class="lineNum">   18636 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(nodevec.size() == sortedNode.size());</span></a>
<a name="18637"><span class="lineNum">   18637 </span>            :   }</a>
<a name="18638"><span class="lineNum">   18638 </span><span class="lineCov">          1 :   return sortedNode;</span></a>
<a name="18639"><span class="lineNum">   18639 </span>            : }</a>
<a name="18640"><span class="lineNum">   18640 </span>            : </a>
<a name="18641"><span class="lineNum">   18641 </span>            : //! Please call this instead of calling getDependentDeclarations ( SgStatement* stmt, vector&lt;SgDeclarationStatement*&gt; &amp; declarationList, vector&lt;SgSymbol*&gt; &amp; symbolList )</a>
<a name="18642"><span class="lineNum">   18642 </span>            : // This function clears a history map transparently and return a sorted list of dependent declarations</a>
<a name="18643"><span class="lineNum">   18643 </span>            : std::vector&lt;SgDeclarationStatement*&gt;</a>
<a name="18644"><span class="lineNum">   18644 </span><span class="lineCov">          1 : SageInterface::getDependentDeclarations ( SgStatement* stmt )</span></a>
<a name="18645"><span class="lineNum">   18645 </span>            :    {</a>
<a name="18646"><span class="lineNum">   18646 </span>            :   // This function returns a list of the dependent declaration for any input statement.</a>
<a name="18647"><span class="lineNum">   18647 </span>            :   // Dependent declaration are functions called, types referenced in variable declarations, etc.</a>
<a name="18648"><span class="lineNum">   18648 </span>            : #if 0</a>
<a name="18649"><span class="lineNum">   18649 </span>            :      printf (&quot;\n\n********************************************************** \n&quot;);</a>
<a name="18650"><span class="lineNum">   18650 </span>            :      printf (&quot; Inside of getDependentDeclarations(stmt = %p = %s) \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="18651"><span class="lineNum">   18651 </span>            :      printf (&quot;********************************************************** \n&quot;);</a>
<a name="18652"><span class="lineNum">   18652 </span>            : </a>
<a name="18653"><span class="lineNum">   18653 </span>            :      CollectDependentDeclarationsTraversal t;</a>
<a name="18654"><span class="lineNum">   18654 </span>            :      t.traverse(stmt,preorder);</a>
<a name="18655"><span class="lineNum">   18655 </span>            : </a>
<a name="18656"><span class="lineNum">   18656 </span>            :      return t.declarationList;</a>
<a name="18657"><span class="lineNum">   18657 </span>            : #else</a>
<a name="18658"><span class="lineNum">   18658 </span>            :      // share a single implementation for recursive lookup for dependent declaration</a>
<a name="18659"><span class="lineNum">   18659 </span><span class="lineCov">          1 :    visitedDeclMap.clear();</span></a>
<a name="18660"><span class="lineNum">   18660 </span><span class="lineCov">          1 :    vector&lt;SgDeclarationStatement*&gt; declarationList;</span></a>
<a name="18661"><span class="lineNum">   18661 </span><span class="lineNoCov">          0 :    vector&lt;SgSymbol*&gt; symbolList;</span></a>
<a name="18662"><span class="lineNum">   18662 </span><span class="lineCov">          1 :    getDependentDeclarations(stmt, declarationList, symbolList);</span></a>
<a name="18663"><span class="lineNum">   18663 </span><span class="lineCov">          2 :    declarationList = sortSgNodeListBasedOnAppearanceOrderInSource(declarationList);</span></a>
<a name="18664"><span class="lineNum">   18664 </span>            : #if 0</a>
<a name="18665"><span class="lineNum">   18665 </span>            :      printf (&quot;\n\n ********************************************************** \n&quot;);</a>
<a name="18666"><span class="lineNum">   18666 </span>            :      cout&lt;&lt;&quot;Found dependent decl: count=&quot;&lt;&lt;declarationList.size()&lt;&lt;endl;</a>
<a name="18667"><span class="lineNum">   18667 </span>            :      for ( vector&lt;SgDeclarationStatement*&gt;::const_iterator iter = declarationList.begin();</a>
<a name="18668"><span class="lineNum">   18668 </span>            :           iter != declarationList.end(); iter++)</a>
<a name="18669"><span class="lineNum">   18669 </span>            :      {</a>
<a name="18670"><span class="lineNum">   18670 </span>            :        cout&lt;&lt;&quot;\t&quot;&lt;&lt;(*iter)-&gt;class_name()&lt;&lt;&quot; at line &quot;&lt;&lt;(*iter)-&gt;get_file_info()-&gt;get_line()&lt;&lt;endl;</a>
<a name="18671"><span class="lineNum">   18671 </span>            :        if ((*iter)-&gt;variantT()== V_SgFunctionDeclaration)</a>
<a name="18672"><span class="lineNum">   18672 </span>            :          cout&lt;&lt;&quot;func name is:&quot;&lt;&lt;isSgFunctionDeclaration(*iter)-&gt;get_name().getString()&lt;&lt;endl;</a>
<a name="18673"><span class="lineNum">   18673 </span>            :        //&lt;&lt;(*iter)-&gt;unparseToString()&lt;&lt;endl;  // unparseToString() won't work on outlined function</a>
<a name="18674"><span class="lineNum">   18674 </span>            :      }</a>
<a name="18675"><span class="lineNum">   18675 </span>            :      printf (&quot;\n ********************************************************** \n&quot;);</a>
<a name="18676"><span class="lineNum">   18676 </span>            : #endif</a>
<a name="18677"><span class="lineNum">   18677 </span>            : </a>
<a name="18678"><span class="lineNum">   18678 </span><span class="lineCov">          2 :    return declarationList;</span></a>
<a name="18679"><span class="lineNum">   18679 </span>            : </a>
<a name="18680"><span class="lineNum">   18680 </span>            : #endif</a>
<a name="18681"><span class="lineNum">   18681 </span>            :    }</a>
<a name="18682"><span class="lineNum">   18682 </span>            : </a>
<a name="18683"><span class="lineNum">   18683 </span>            : </a>
<a name="18684"><span class="lineNum">   18684 </span>            : bool</a>
<a name="18685"><span class="lineNum">   18685 </span><span class="lineCov">      50793 : SageInterface::isPrefixOperatorName( const SgName &amp; functionName )</span></a>
<a name="18686"><span class="lineNum">   18686 </span>            :    {</a>
<a name="18687"><span class="lineNum">   18687 </span><span class="lineCov">      50793 :      bool returnValue = false;</span></a>
<a name="18688"><span class="lineNum">   18688 </span>            : </a>
<a name="18689"><span class="lineNum">   18689 </span>            : #if 0</a>
<a name="18690"><span class="lineNum">   18690 </span>            :      printf (&quot;In SageInterface::isPrefixOperatorName(): functionName = %s (might have to check the return type to distinguish the deref operator from the multiply operator) \n&quot;,functionName.str());</a>
<a name="18691"><span class="lineNum">   18691 </span>            : #endif</a>
<a name="18692"><span class="lineNum">   18692 </span>            : </a>
<a name="18693"><span class="lineNum">   18693 </span><span class="lineCov">      50793 :      if (functionName.is_null() == false)</span></a>
<a name="18694"><span class="lineNum">   18694 </span>            :         {</a>
<a name="18695"><span class="lineNum">   18695 </span>            :        // DQ (1/20/2019): Add operator~() to this list (see test2019_10.C).</a>
<a name="18696"><span class="lineNum">   18696 </span>            :        // if ( functionName == &quot;operator++&quot; || functionName == &quot;operator--&quot; || functionName == &quot;operator&amp;&quot; ||</a>
<a name="18697"><span class="lineNum">   18697 </span>            :        //      functionName == &quot;operator!&quot;  || functionName == &quot;operator*&quot;  || functionName == &quot;operator+&quot; ||</a>
<a name="18698"><span class="lineNum">   18698 </span>            :        //      functionName == &quot;operator-&quot;  || functionName == &quot;operator+&quot; )</a>
<a name="18699"><span class="lineNum">   18699 </span><span class="lineCov">       6505 :           if ( functionName == &quot;operator++&quot; || functionName == &quot;operator--&quot; || functionName == &quot;operator&amp;&quot; ||</span></a>
<a name="18700"><span class="lineNum">   18700 </span><span class="lineCov">       6388 :                functionName == &quot;operator!&quot;  || functionName == &quot;operator*&quot;  || functionName == &quot;operator+&quot; ||</span></a>
<a name="18701"><span class="lineNum">   18701 </span><span class="lineCov">       4841 :                functionName == &quot;operator-&quot;  || functionName == &quot;operator+&quot;  || functionName == &quot;operator~&quot;)</span></a>
<a name="18702"><span class="lineNum">   18702 </span>            :              {</a>
<a name="18703"><span class="lineNum">   18703 </span><span class="lineCov">         91 :                returnValue = true;</span></a>
<a name="18704"><span class="lineNum">   18704 </span>            :              }</a>
<a name="18705"><span class="lineNum">   18705 </span>            :         }</a>
<a name="18706"><span class="lineNum">   18706 </span>            : </a>
<a name="18707"><span class="lineNum">   18707 </span><span class="lineCov">      50793 :      return returnValue;</span></a>
<a name="18708"><span class="lineNum">   18708 </span>            :    }</a>
<a name="18709"><span class="lineNum">   18709 </span>            : </a>
<a name="18710"><span class="lineNum">   18710 </span>            : </a>
<a name="18711"><span class="lineNum">   18711 </span>            : // DQ (4/13/2013): We need these to support the unparing of operators defined by operator syntax or member function names.</a>
<a name="18712"><span class="lineNum">   18712 </span>            : //! Is an overloaded operator a prefix operator (e.g. address operator X * operator&amp;(), dereference operator X &amp; operator*(), unary plus operator X &amp; operator+(), etc.</a>
<a name="18713"><span class="lineNum">   18713 </span>            : bool</a>
<a name="18714"><span class="lineNum">   18714 </span><span class="lineCov">      50793 : SageInterface::isPrefixOperator( SgExpression* exp )</span></a>
<a name="18715"><span class="lineNum">   18715 </span>            :    {</a>
<a name="18716"><span class="lineNum">   18716 </span>            :   // DQ (4/21/2013): Reimplemented this function to support more of the prefix operators.</a>
<a name="18717"><span class="lineNum">   18717 </span>            :   // Also we now support when they are defined as member functions and non-member functions.</a>
<a name="18718"><span class="lineNum">   18718 </span>            : </a>
<a name="18719"><span class="lineNum">   18719 </span><span class="lineCov">      50793 :      bool returnValue = false;</span></a>
<a name="18720"><span class="lineNum">   18720 </span>            : </a>
<a name="18721"><span class="lineNum">   18721 </span><span class="lineCov">      50793 :      SgFunctionRefExp* functionRefExp             = isSgFunctionRefExp(exp);</span></a>
<a name="18722"><span class="lineNum">   18722 </span><span class="lineCov">      50793 :      SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(exp);</span></a>
<a name="18723"><span class="lineNum">   18723 </span>            :   // ROSE_ASSERT(memberFunctionRefExp != NULL);</a>
<a name="18724"><span class="lineNum">   18724 </span>            : </a>
<a name="18725"><span class="lineNum">   18725 </span><span class="lineCov">      50793 :      SgName functionName;</span></a>
<a name="18726"><span class="lineNum">   18726 </span><span class="lineCov">      50793 :      size_t numberOfOperands = 0;</span></a>
<a name="18727"><span class="lineNum">   18727 </span>            : </a>
<a name="18728"><span class="lineNum">   18728 </span><span class="lineCov">      50793 :      if (memberFunctionRefExp != NULL)</span></a>
<a name="18729"><span class="lineNum">   18729 </span>            :         {</a>
<a name="18730"><span class="lineNum">   18730 </span><span class="lineCov">        788 :           ROSE_ASSERT(functionRefExp == NULL);</span></a>
<a name="18731"><span class="lineNum">   18731 </span><span class="lineCov">        788 :           SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration();</span></a>
<a name="18732"><span class="lineNum">   18732 </span><span class="lineCov">        788 :           if (memberFunctionDeclaration != NULL)</span></a>
<a name="18733"><span class="lineNum">   18733 </span>            :              {</a>
<a name="18734"><span class="lineNum">   18734 </span><span class="lineCov">        788 :                functionName = memberFunctionDeclaration-&gt;get_name();</span></a>
<a name="18735"><span class="lineNum">   18735 </span><span class="lineCov">        788 :                numberOfOperands = memberFunctionDeclaration-&gt;get_args().size();</span></a>
<a name="18736"><span class="lineNum">   18736 </span>            :              }</a>
<a name="18737"><span class="lineNum">   18737 </span>            :         }</a>
<a name="18738"><span class="lineNum">   18738 </span>            :        else</a>
<a name="18739"><span class="lineNum">   18739 </span>            :         {</a>
<a name="18740"><span class="lineNum">   18740 </span>            :        // This could be &quot;friend bool operator!(const X &amp; x);&quot;</a>
<a name="18741"><span class="lineNum">   18741 </span><span class="lineCov">      50005 :           if (functionRefExp != NULL)</span></a>
<a name="18742"><span class="lineNum">   18742 </span>            :              {</a>
<a name="18743"><span class="lineNum">   18743 </span><span class="lineCov">        851 :                SgFunctionDeclaration* functionDeclaration = functionRefExp-&gt;getAssociatedFunctionDeclaration();</span></a>
<a name="18744"><span class="lineNum">   18744 </span><span class="lineCov">        851 :                if (functionDeclaration != NULL)</span></a>
<a name="18745"><span class="lineNum">   18745 </span>            :                   {</a>
<a name="18746"><span class="lineNum">   18746 </span><span class="lineCov">        851 :                     functionName     = functionDeclaration-&gt;get_name();</span></a>
<a name="18747"><span class="lineNum">   18747 </span><span class="lineCov">        851 :                     numberOfOperands = functionDeclaration-&gt;get_args().size();</span></a>
<a name="18748"><span class="lineNum">   18748 </span>            :                   }</a>
<a name="18749"><span class="lineNum">   18749 </span>            :              }</a>
<a name="18750"><span class="lineNum">   18750 </span>            :             else</a>
<a name="18751"><span class="lineNum">   18751 </span>            :              {</a>
<a name="18752"><span class="lineNum">   18752 </span>            :             // Note clear if this should be an error.</a>
<a name="18753"><span class="lineNum">   18753 </span><span class="lineCov">      59650 :                printf (&quot;In SageInterface::isPrefixOperator(): unknown case of exp = %p = %s \n&quot;,exp,exp-&gt;class_name().c_str());</span></a>
<a name="18754"><span class="lineNum">   18754 </span>            :              }</a>
<a name="18755"><span class="lineNum">   18755 </span>            :         }</a>
<a name="18756"><span class="lineNum">   18756 </span>            : </a>
<a name="18757"><span class="lineNum">   18757 </span>            : #if 0</a>
<a name="18758"><span class="lineNum">   18758 </span>            :      printf (&quot;In SageInterface::isPrefixOperator(): functionName = %s numberOfOperands = %&quot; PRIuPTR &quot; (might have to check the return type to distinguish the deref operator from the multiply operator) \n&quot;,functionName.str(),numberOfOperands);</a>
<a name="18759"><span class="lineNum">   18759 </span>            : #endif</a>
<a name="18760"><span class="lineNum">   18760 </span>            : </a>
<a name="18761"><span class="lineNum">   18761 </span><span class="lineCov">      50793 :      if (isPrefixOperatorName(functionName) == true)</span></a>
<a name="18762"><span class="lineNum">   18762 </span>            :         {</a>
<a name="18763"><span class="lineNum">   18763 </span><span class="lineCov">         91 :           if (memberFunctionRefExp != NULL)</span></a>
<a name="18764"><span class="lineNum">   18764 </span>            :              {</a>
<a name="18765"><span class="lineNum">   18765 </span>            :             // This case is for member functions.</a>
<a name="18766"><span class="lineNum">   18766 </span><span class="lineCov">         35 :                ROSE_ASSERT(functionRefExp == NULL);</span></a>
<a name="18767"><span class="lineNum">   18767 </span><span class="lineCov">         35 :                if (numberOfOperands == 0)</span></a>
<a name="18768"><span class="lineNum">   18768 </span>            :                   {</a>
<a name="18769"><span class="lineNum">   18769 </span>            :                  // This is the C++ signature for the operator++() prefix operator.</a>
<a name="18770"><span class="lineNum">   18770 </span>            :                     returnValue = true;</a>
<a name="18771"><span class="lineNum">   18771 </span>            :                   }</a>
<a name="18772"><span class="lineNum">   18772 </span>            :                  else</a>
<a name="18773"><span class="lineNum">   18773 </span>            :                   {</a>
<a name="18774"><span class="lineNum">   18774 </span>            :                  // This is the C++ signature for the operator++() postfix operator.</a>
<a name="18775"><span class="lineNum">   18775 </span><span class="lineCov">         19 :                     returnValue = false;</span></a>
<a name="18776"><span class="lineNum">   18776 </span>            :                   }</a>
<a name="18777"><span class="lineNum">   18777 </span>            :              }</a>
<a name="18778"><span class="lineNum">   18778 </span>            :             else</a>
<a name="18779"><span class="lineNum">   18779 </span>            :              {</a>
<a name="18780"><span class="lineNum">   18780 </span>            :             // This case is for non-member functions.</a>
<a name="18781"><span class="lineNum">   18781 </span><span class="lineCov">         56 :                ROSE_ASSERT(functionRefExp != NULL);</span></a>
<a name="18782"><span class="lineNum">   18782 </span><span class="lineCov">         56 :                ROSE_ASSERT(memberFunctionRefExp == NULL);</span></a>
<a name="18783"><span class="lineNum">   18783 </span><span class="lineCov">         56 :                if (numberOfOperands == 1)</span></a>
<a name="18784"><span class="lineNum">   18784 </span>            :                   {</a>
<a name="18785"><span class="lineNum">   18785 </span>            :                  // This is the C++ signature for the operator++() prefix operator.</a>
<a name="18786"><span class="lineNum">   18786 </span>            :                     returnValue = true;</a>
<a name="18787"><span class="lineNum">   18787 </span>            :                   }</a>
<a name="18788"><span class="lineNum">   18788 </span>            :                  else</a>
<a name="18789"><span class="lineNum">   18789 </span>            :                   {</a>
<a name="18790"><span class="lineNum">   18790 </span>            :                  // This is the C++ signature for the operator++() postfix operator.</a>
<a name="18791"><span class="lineNum">   18791 </span><span class="lineCov">         48 :                     ROSE_ASSERT(numberOfOperands == 2);</span></a>
<a name="18792"><span class="lineNum">   18792 </span><span class="lineCov">         48 :                     returnValue = false;</span></a>
<a name="18793"><span class="lineNum">   18793 </span>            :                   }</a>
<a name="18794"><span class="lineNum">   18794 </span>            :              }</a>
<a name="18795"><span class="lineNum">   18795 </span>            :         }</a>
<a name="18796"><span class="lineNum">   18796 </span>            : </a>
<a name="18797"><span class="lineNum">   18797 </span>            : #if 0</a>
<a name="18798"><span class="lineNum">   18798 </span>            :      printf (&quot;Leaving SageInterface::isPrefixOperator(): returnValue = %s \n&quot;,returnValue ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="18799"><span class="lineNum">   18799 </span>            : #endif</a>
<a name="18800"><span class="lineNum">   18800 </span>            : </a>
<a name="18801"><span class="lineNum">   18801 </span><span class="lineCov">      50793 :      return returnValue;</span></a>
<a name="18802"><span class="lineNum">   18802 </span>            :    }</a>
<a name="18803"><span class="lineNum">   18803 </span>            : </a>
<a name="18804"><span class="lineNum">   18804 </span>            : </a>
<a name="18805"><span class="lineNum">   18805 </span>            : //! Is an overloaded operator a postfix operator. (e.g. ).</a>
<a name="18806"><span class="lineNum">   18806 </span>            : bool</a>
<a name="18807"><span class="lineNum">   18807 </span><span class="lineCov">      50745 : SageInterface::isPostfixOperator( SgExpression* exp )</span></a>
<a name="18808"><span class="lineNum">   18808 </span>            :    {</a>
<a name="18809"><span class="lineNum">   18809 </span><span class="lineCov">      50745 :      return ( (isPrefixOperator(exp) == false) &amp;&amp; (isIndexOperator(exp) == false) );</span></a>
<a name="18810"><span class="lineNum">   18810 </span>            :    }</a>
<a name="18811"><span class="lineNum">   18811 </span>            : </a>
<a name="18812"><span class="lineNum">   18812 </span>            : </a>
<a name="18813"><span class="lineNum">   18813 </span>            : //! Is an overloaded operator an index operator (also refereded to as call or subscript operators). (e.g. X &amp; operator()() or X &amp; operator[]()).</a>
<a name="18814"><span class="lineNum">   18814 </span>            : bool</a>
<a name="18815"><span class="lineNum">   18815 </span><span class="lineCov">     101468 : SageInterface::isIndexOperator( SgExpression* exp )</span></a>
<a name="18816"><span class="lineNum">   18816 </span>            :    {</a>
<a name="18817"><span class="lineNum">   18817 </span><span class="lineCov">     101468 :      bool returnValue = false;</span></a>
<a name="18818"><span class="lineNum">   18818 </span><span class="lineCov">     101468 :      SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(exp);</span></a>
<a name="18819"><span class="lineNum">   18819 </span><span class="lineCov">     101468 :      if (memberFunctionRefExp == NULL)</span></a>
<a name="18820"><span class="lineNum">   18820 </span>            :        return false;</a>
<a name="18821"><span class="lineNum">   18821 </span>            : </a>
<a name="18822"><span class="lineNum">   18822 </span><span class="lineCov">       1466 :      SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp-&gt;getAssociatedMemberFunctionDeclaration();</span></a>
<a name="18823"><span class="lineNum">   18823 </span><span class="lineCov">       1466 :      if (memberFunctionDeclaration != NULL)</span></a>
<a name="18824"><span class="lineNum">   18824 </span>            :         {</a>
<a name="18825"><span class="lineNum">   18825 </span><span class="lineCov">       2932 :           SgName functionName = memberFunctionDeclaration-&gt;get_name();</span></a>
<a name="18826"><span class="lineNum">   18826 </span><span class="lineCov">       1466 :           if ( (functionName == &quot;operator[]&quot;) &amp;&amp; (isSgType(memberFunctionDeclaration-&gt;get_type()) != NULL) )</span></a>
<a name="18827"><span class="lineNum">   18827 </span>            :              {</a>
<a name="18828"><span class="lineNum">   18828 </span>            :                returnValue = true;</a>
<a name="18829"><span class="lineNum">   18829 </span>            :              }</a>
<a name="18830"><span class="lineNum">   18830 </span>            :             else</a>
<a name="18831"><span class="lineNum">   18831 </span>            :              {</a>
<a name="18832"><span class="lineNum">   18832 </span><span class="lineCov">       1466 :                if ( (functionName == &quot;operator()&quot;) &amp;&amp; (isSgType(memberFunctionDeclaration-&gt;get_type()) != NULL) )</span></a>
<a name="18833"><span class="lineNum">   18833 </span>            :                   {</a>
<a name="18834"><span class="lineNum">   18834 </span>            :                     returnValue = true;</a>
<a name="18835"><span class="lineNum">   18835 </span>            :                   }</a>
<a name="18836"><span class="lineNum">   18836 </span>            :                  else</a>
<a name="18837"><span class="lineNum">   18837 </span>            :                   {</a>
<a name="18838"><span class="lineNum">   18838 </span><span class="lineCov">       1456 :                     returnValue = false;</span></a>
<a name="18839"><span class="lineNum">   18839 </span>            :                   }</a>
<a name="18840"><span class="lineNum">   18840 </span>            :              }</a>
<a name="18841"><span class="lineNum">   18841 </span>            :         }</a>
<a name="18842"><span class="lineNum">   18842 </span>            : </a>
<a name="18843"><span class="lineNum">   18843 </span>            :      return returnValue;</a>
<a name="18844"><span class="lineNum">   18844 </span>            :    }</a>
<a name="18845"><span class="lineNum">   18845 </span>            : </a>
<a name="18846"><span class="lineNum">   18846 </span>            : </a>
<a name="18847"><span class="lineNum">   18847 </span>            : // DQ (1/10/2014): Adding more general support for token based unparsing.</a>
<a name="18848"><span class="lineNum">   18848 </span>            : SgStatement*</a>
<a name="18849"><span class="lineNum">   18849 </span><span class="lineNoCov">          0 : SageInterface::lastStatementOfScopeWithTokenInfo (SgScopeStatement* scope, std::map&lt;SgNode*,TokenStreamSequenceToNodeMapping*&gt; &amp; tokenStreamSequenceMap)</span></a>
<a name="18850"><span class="lineNum">   18850 </span>            :    {</a>
<a name="18851"><span class="lineNum">   18851 </span>            :   // Return the last statement in the associated scope that has token information.</a>
<a name="18852"><span class="lineNum">   18852 </span><span class="lineNoCov">          0 :      SgStatement* lastStatement = NULL;</span></a>
<a name="18853"><span class="lineNum">   18853 </span>            : </a>
<a name="18854"><span class="lineNum">   18854 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="18855"><span class="lineNum">   18855 </span>            : </a>
<a name="18856"><span class="lineNum">   18856 </span>            : #if 0</a>
<a name="18857"><span class="lineNum">   18857 </span>            :      printf (&quot;In SageInterface::lastStatementOfScopeWithTokenInfo(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="18858"><span class="lineNum">   18858 </span>            : #endif</a>
<a name="18859"><span class="lineNum">   18859 </span>            : </a>
<a name="18860"><span class="lineNum">   18860 </span><span class="lineNoCov">          0 :      SgIfStmt* ifStatement = isSgIfStmt(scope);</span></a>
<a name="18861"><span class="lineNum">   18861 </span><span class="lineNoCov">          0 :      if (ifStatement != NULL)</span></a>
<a name="18862"><span class="lineNum">   18862 </span>            :         {</a>
<a name="18863"><span class="lineNum">   18863 </span><span class="lineNoCov">          0 :           lastStatement = ifStatement-&gt;get_false_body();</span></a>
<a name="18864"><span class="lineNum">   18864 </span><span class="lineNoCov">          0 :           if (lastStatement == NULL || (tokenStreamSequenceMap.find(lastStatement) == tokenStreamSequenceMap.end() || tokenStreamSequenceMap[lastStatement] == NULL))</span></a>
<a name="18865"><span class="lineNum">   18865 </span>            :              {</a>
<a name="18866"><span class="lineNum">   18866 </span><span class="lineNoCov">          0 :                lastStatement = ifStatement-&gt;get_true_body();</span></a>
<a name="18867"><span class="lineNum">   18867 </span><span class="lineNoCov">          0 :                if (lastStatement == NULL || (tokenStreamSequenceMap.find(lastStatement) == tokenStreamSequenceMap.end() || tokenStreamSequenceMap[lastStatement] == NULL))</span></a>
<a name="18868"><span class="lineNum">   18868 </span>            :                   {</a>
<a name="18869"><span class="lineNum">   18869 </span>            :                     lastStatement = NULL;</a>
<a name="18870"><span class="lineNum">   18870 </span>            :                   }</a>
<a name="18871"><span class="lineNum">   18871 </span>            :              }</a>
<a name="18872"><span class="lineNum">   18872 </span>            : </a>
<a name="18873"><span class="lineNum">   18873 </span><span class="lineNoCov">          0 :           printf (&quot;Note: SgIfStmt scope in SageInterface::lastStatementOfScopeWithTokenInfo(): returning lastStatement = %p \n&quot;,lastStatement);</span></a>
<a name="18874"><span class="lineNum">   18874 </span><span class="lineNoCov">          0 :           if (lastStatement != NULL)</span></a>
<a name="18875"><span class="lineNum">   18875 </span>            :              {</a>
<a name="18876"><span class="lineNum">   18876 </span><span class="lineNoCov">          0 :                printf (&quot;   --- lastStatement = %p = %s \n&quot;,lastStatement,lastStatement-&gt;class_name().c_str());</span></a>
<a name="18877"><span class="lineNum">   18877 </span>            :              }</a>
<a name="18878"><span class="lineNum">   18878 </span>            : </a>
<a name="18879"><span class="lineNum">   18879 </span><span class="lineNoCov">          0 :           return lastStatement;</span></a>
<a name="18880"><span class="lineNum">   18880 </span>            :         }</a>
<a name="18881"><span class="lineNum">   18881 </span>            : </a>
<a name="18882"><span class="lineNum">   18882 </span><span class="lineNoCov">          0 :      SgStatementPtrList statementList = scope-&gt;generateStatementList();</span></a>
<a name="18883"><span class="lineNum">   18883 </span><span class="lineNoCov">          0 :      if (statementList.rbegin() != statementList.rend())</span></a>
<a name="18884"><span class="lineNum">   18884 </span>            :         {</a>
<a name="18885"><span class="lineNum">   18885 </span>            :        // Find the last statement with token stream information.</a>
<a name="18886"><span class="lineNum">   18886 </span>            :           int counter = 0;</a>
<a name="18887"><span class="lineNum">   18887 </span>            : </a>
<a name="18888"><span class="lineNum">   18888 </span><span class="lineNoCov">          0 :           SgStatementPtrList::reverse_iterator i = statementList.rbegin();</span></a>
<a name="18889"><span class="lineNum">   18889 </span>            : </a>
<a name="18890"><span class="lineNum">   18890 </span><span class="lineNoCov">          0 :           while (i != statementList.rend() &amp;&amp; (tokenStreamSequenceMap.find(*i) == tokenStreamSequenceMap.end() || tokenStreamSequenceMap[*i] == NULL) )</span></a>
<a name="18891"><span class="lineNum">   18891 </span>            :              {</a>
<a name="18892"><span class="lineNum">   18892 </span>            : #if 0</a>
<a name="18893"><span class="lineNum">   18893 </span>            :                printf (&quot;IN LOOP: SgDeclarationStatementPtrList::reverse_iterator i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="18894"><span class="lineNum">   18894 </span>            : #endif</a>
<a name="18895"><span class="lineNum">   18895 </span><span class="lineNoCov">          0 :                i++;</span></a>
<a name="18896"><span class="lineNum">   18896 </span>            : </a>
<a name="18897"><span class="lineNum">   18897 </span><span class="lineNoCov">          0 :                counter++;</span></a>
<a name="18898"><span class="lineNum">   18898 </span>            :              }</a>
<a name="18899"><span class="lineNum">   18899 </span>            : #if 0</a>
<a name="18900"><span class="lineNum">   18900 </span>            :           printf (&quot;AFTER LOOP: SgDeclarationStatementPtrList::reverse_iterator i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="18901"><span class="lineNum">   18901 </span>            :           printf (&quot;Number of declarations without token information at the bottom of the global scope: counter = %d \n&quot;,counter);</a>
<a name="18902"><span class="lineNum">   18902 </span>            : #endif</a>
<a name="18903"><span class="lineNum">   18903 </span>            : </a>
<a name="18904"><span class="lineNum">   18904 </span>            :        // DQ (1/12/2015): If we are not using the token based unparsing (which is allowed) then this assertion will fail.</a>
<a name="18905"><span class="lineNum">   18905 </span>            :        // ROSE_ASSERT(i != statementList.rend());</a>
<a name="18906"><span class="lineNum">   18906 </span>            :        // ROSE_ASSERT(tokenStreamSequenceMap.find(*i) != tokenStreamSequenceMap.end());</a>
<a name="18907"><span class="lineNum">   18907 </span>            :        // lastStatement = *i;</a>
<a name="18908"><span class="lineNum">   18908 </span><span class="lineNoCov">          0 :           if (i == statementList.rend())</span></a>
<a name="18909"><span class="lineNum">   18909 </span>            :              {</a>
<a name="18910"><span class="lineNum">   18910 </span>            :                lastStatement = NULL;</a>
<a name="18911"><span class="lineNum">   18911 </span>            :              }</a>
<a name="18912"><span class="lineNum">   18912 </span>            :             else</a>
<a name="18913"><span class="lineNum">   18913 </span>            :              {</a>
<a name="18914"><span class="lineNum">   18914 </span><span class="lineNoCov">          0 :                lastStatement = *i;</span></a>
<a name="18915"><span class="lineNum">   18915 </span>            :              }</a>
<a name="18916"><span class="lineNum">   18916 </span>            : #if 0</a>
<a name="18917"><span class="lineNum">   18917 </span>            :           printf (&quot;computed lastStatement of scope = %p = %s \n&quot;,lastStatement,lastStatement-&gt;class_name().c_str());</a>
<a name="18918"><span class="lineNum">   18918 </span>            : #endif</a>
<a name="18919"><span class="lineNum">   18919 </span>            :         }</a>
<a name="18920"><span class="lineNum">   18920 </span>            :        else</a>
<a name="18921"><span class="lineNum">   18921 </span>            :         {</a>
<a name="18922"><span class="lineNum">   18922 </span>            : #if 0</a>
<a name="18923"><span class="lineNum">   18923 </span>            :           printf (&quot;In SageInterface::lastStatementOfScopeWithTokenInfo(): scope is empty! \n&quot;);</a>
<a name="18924"><span class="lineNum">   18924 </span>            : #endif</a>
<a name="18925"><span class="lineNum">   18925 </span>            :         }</a>
<a name="18926"><span class="lineNum">   18926 </span>            : </a>
<a name="18927"><span class="lineNum">   18927 </span><span class="lineNoCov">          0 :      return lastStatement;</span></a>
<a name="18928"><span class="lineNum">   18928 </span>            :    }</a>
<a name="18929"><span class="lineNum">   18929 </span>            : </a>
<a name="18930"><span class="lineNum">   18930 </span>            : </a>
<a name="18931"><span class="lineNum">   18931 </span>            : void</a>
<a name="18932"><span class="lineNum">   18932 </span><span class="lineNoCov">          0 : SageInterface::checkAccessPermissions ( SgNode* astNode )</span></a>
<a name="18933"><span class="lineNum">   18933 </span>            :    {</a>
<a name="18934"><span class="lineNum">   18934 </span>            :   // DQ (8/12/2020): Check the access permissions of all defining and nodefining declarations (debugging support for Cxx_tests/test2020_28.C).</a>
<a name="18935"><span class="lineNum">   18935 </span>            : </a>
<a name="18936"><span class="lineNum">   18936 </span><span class="lineNoCov">          0 :      class DeclarationTraversal : public AstSimpleProcessing</span></a>
<a name="18937"><span class="lineNum">   18937 </span>            :         {</a>
<a name="18938"><span class="lineNum">   18938 </span>            :           public:</a>
<a name="18939"><span class="lineNum">   18939 </span>            :             // DeclarationTraversal() {}</a>
<a name="18940"><span class="lineNum">   18940 </span>            : </a>
<a name="18941"><span class="lineNum">   18941 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="18942"><span class="lineNum">   18942 </span>            :                   {</a>
<a name="18943"><span class="lineNum">   18943 </span><span class="lineNoCov">          0 :                     SgDeclarationStatement* decl = isSgDeclarationStatement(node);</span></a>
<a name="18944"><span class="lineNum">   18944 </span><span class="lineNoCov">          0 :                     if (decl != NULL)</span></a>
<a name="18945"><span class="lineNum">   18945 </span>            :                        {</a>
<a name="18946"><span class="lineNum">   18946 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* definingDeclaration         = isSgDeclarationStatement(decl-&gt;get_definingDeclaration());</span></a>
<a name="18947"><span class="lineNum">   18947 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* firstNondefiningDeclaration = isSgDeclarationStatement(decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="18948"><span class="lineNum">   18948 </span><span class="lineNoCov">          0 :                          SgDeclarationStatement* otherDeclaration            = NULL;</span></a>
<a name="18949"><span class="lineNum">   18949 </span>            : </a>
<a name="18950"><span class="lineNum">   18950 </span>            :                       // Output access modifier information for each declaration.</a>
<a name="18951"><span class="lineNum">   18951 </span><span class="lineNoCov">          0 :                          printf (&quot;Found declaration = %p = %s name = %s \n&quot;,decl,decl-&gt;class_name().c_str(),get_name(decl).c_str());</span></a>
<a name="18952"><span class="lineNum">   18952 </span><span class="lineNoCov">          0 :                          if (decl != definingDeclaration &amp;&amp; decl != firstNondefiningDeclaration)</span></a>
<a name="18953"><span class="lineNum">   18953 </span>            :                             {</a>
<a name="18954"><span class="lineNum">   18954 </span><span class="lineNoCov">          0 :                               otherDeclaration = decl;</span></a>
<a name="18955"><span class="lineNum">   18955 </span>            :                             }</a>
<a name="18956"><span class="lineNum">   18956 </span>            : </a>
<a name="18957"><span class="lineNum">   18957 </span><span class="lineNoCov">          0 :                          if (definingDeclaration != NULL)</span></a>
<a name="18958"><span class="lineNum">   18958 </span>            :                             {</a>
<a name="18959"><span class="lineNum">   18959 </span><span class="lineNoCov">          0 :                               definingDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;definingDeclaration: accessModifier&quot;);</span></a>
<a name="18960"><span class="lineNum">   18960 </span>            :                             }</a>
<a name="18961"><span class="lineNum">   18961 </span>            : </a>
<a name="18962"><span class="lineNum">   18962 </span><span class="lineNoCov">          0 :                          if (firstNondefiningDeclaration != NULL)</span></a>
<a name="18963"><span class="lineNum">   18963 </span>            :                             {</a>
<a name="18964"><span class="lineNum">   18964 </span><span class="lineNoCov">          0 :                               firstNondefiningDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;firstNondefiningDeclaration: accessModifier&quot;);</span></a>
<a name="18965"><span class="lineNum">   18965 </span>            :                             }</a>
<a name="18966"><span class="lineNum">   18966 </span>            : </a>
<a name="18967"><span class="lineNum">   18967 </span><span class="lineNoCov">          0 :                          if (otherDeclaration != NULL)</span></a>
<a name="18968"><span class="lineNum">   18968 </span>            :                             {</a>
<a name="18969"><span class="lineNum">   18969 </span><span class="lineNoCov">          0 :                               otherDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;otherDeclaration: accessModifier&quot;);</span></a>
<a name="18970"><span class="lineNum">   18970 </span>            :                             }</a>
<a name="18971"><span class="lineNum">   18971 </span>            : </a>
<a name="18972"><span class="lineNum">   18972 </span>            :                       // Adding space for formatting.</a>
<a name="18973"><span class="lineNum">   18973 </span><span class="lineNoCov">          0 :                          printf (&quot;\n&quot;);</span></a>
<a name="18974"><span class="lineNum">   18974 </span>            :                        }</a>
<a name="18975"><span class="lineNum">   18975 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="18976"><span class="lineNum">   18976 </span>            :         };</a>
<a name="18977"><span class="lineNum">   18977 </span>            : </a>
<a name="18978"><span class="lineNum">   18978 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="18979"><span class="lineNum">   18979 </span><span class="lineNoCov">          0 :      DeclarationTraversal traversal;</span></a>
<a name="18980"><span class="lineNum">   18980 </span><span class="lineNoCov">          0 :      traversal.traverse(astNode, preorder);</span></a>
<a name="18981"><span class="lineNum">   18981 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="18982"><span class="lineNum">   18982 </span>            : </a>
<a name="18983"><span class="lineNum">   18983 </span>            : </a>
<a name="18984"><span class="lineNum">   18984 </span>            : void</a>
<a name="18985"><span class="lineNum">   18985 </span><span class="lineNoCov">          0 : SageInterface::checkSymbolTables ( SgNode* astNode )</span></a>
<a name="18986"><span class="lineNum">   18986 </span>            :    {</a>
<a name="18987"><span class="lineNum">   18987 </span>            :   // DQ (8/14/2020): Check the symbol tables for specific scopes (debugging support).</a>
<a name="18988"><span class="lineNum">   18988 </span>            : </a>
<a name="18989"><span class="lineNum">   18989 </span><span class="lineNoCov">          0 :      class ScopeTraversal : public AstSimpleProcessing</span></a>
<a name="18990"><span class="lineNum">   18990 </span>            :         {</a>
<a name="18991"><span class="lineNum">   18991 </span>            :           public:</a>
<a name="18992"><span class="lineNum">   18992 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="18993"><span class="lineNum">   18993 </span>            :                   {</a>
<a name="18994"><span class="lineNum">   18994 </span><span class="lineNoCov">          0 :                     SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="18995"><span class="lineNum">   18995 </span><span class="lineNoCov">          0 :                     if (scope != NULL)</span></a>
<a name="18996"><span class="lineNum">   18996 </span>            :                        {</a>
<a name="18997"><span class="lineNum">   18997 </span><span class="lineNoCov">          0 :                          SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(scope);</span></a>
<a name="18998"><span class="lineNum">   18998 </span><span class="lineNoCov">          0 :                          if (functionDefinition != NULL)</span></a>
<a name="18999"><span class="lineNum">   18999 </span>            :                             {</a>
<a name="19000"><span class="lineNum">   19000 </span><span class="lineNoCov">          0 :                               SgFunctionDeclaration* functionDeclaration = functionDefinition-&gt;get_declaration();</span></a>
<a name="19001"><span class="lineNum">   19001 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="19002"><span class="lineNum">   19002 </span>            : </a>
<a name="19003"><span class="lineNum">   19003 </span><span class="lineNoCov">          0 :                               string functionName = functionDeclaration-&gt;get_name();</span></a>
<a name="19004"><span class="lineNum">   19004 </span>            : </a>
<a name="19005"><span class="lineNum">   19005 </span><span class="lineNoCov">          0 :                               printf (&quot;functionName = %s \n&quot;,functionName.c_str());</span></a>
<a name="19006"><span class="lineNum">   19006 </span>            : </a>
<a name="19007"><span class="lineNum">   19007 </span><span class="lineNoCov">          0 :                               if (functionName == &quot;main&quot;)</span></a>
<a name="19008"><span class="lineNum">   19008 </span>            :                                  {</a>
<a name="19009"><span class="lineNum">   19009 </span>            : </a>
<a name="19010"><span class="lineNum">   19010 </span><span class="lineNoCov">          0 :                                    SgBasicBlock* functionBody = functionDefinition-&gt;get_body();</span></a>
<a name="19011"><span class="lineNum">   19011 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(functionBody != NULL);</span></a>
<a name="19012"><span class="lineNum">   19012 </span><span class="lineNoCov">          0 :                                    SgSymbolTable* symbolTable = functionBody-&gt;get_symbol_table();</span></a>
<a name="19013"><span class="lineNum">   19013 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="19014"><span class="lineNum">   19014 </span>            : </a>
<a name="19015"><span class="lineNum">   19015 </span>            :                                 // Print out the symbol table.</a>
<a name="19016"><span class="lineNum">   19016 </span><span class="lineNoCov">          0 :                                    symbolTable-&gt;print();</span></a>
<a name="19017"><span class="lineNum">   19017 </span>            :                                  }</a>
<a name="19018"><span class="lineNum">   19018 </span>            :                             }</a>
<a name="19019"><span class="lineNum">   19019 </span>            : </a>
<a name="19020"><span class="lineNum">   19020 </span><span class="lineNoCov">          0 :                          SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);</span></a>
<a name="19021"><span class="lineNum">   19021 </span><span class="lineNoCov">          0 :                          if (namespaceDefinition != NULL)</span></a>
<a name="19022"><span class="lineNum">   19022 </span>            :                             {</a>
<a name="19023"><span class="lineNum">   19023 </span><span class="lineNoCov">          0 :                               SgNamespaceDeclarationStatement* namespaceDeclaration = namespaceDefinition-&gt;get_namespaceDeclaration();</span></a>
<a name="19024"><span class="lineNum">   19024 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(namespaceDeclaration != NULL);</span></a>
<a name="19025"><span class="lineNum">   19025 </span>            : </a>
<a name="19026"><span class="lineNum">   19026 </span><span class="lineNoCov">          0 :                               string namespaceName = namespaceDeclaration-&gt;get_name();</span></a>
<a name="19027"><span class="lineNum">   19027 </span>            : </a>
<a name="19028"><span class="lineNum">   19028 </span><span class="lineNoCov">          0 :                               printf (&quot;namespaceName = %s \n&quot;,namespaceName.c_str());</span></a>
<a name="19029"><span class="lineNum">   19029 </span>            : </a>
<a name="19030"><span class="lineNum">   19030 </span><span class="lineNoCov">          0 :                               if (namespaceName == &quot;B&quot;)</span></a>
<a name="19031"><span class="lineNum">   19031 </span>            :                                  {</a>
<a name="19032"><span class="lineNum">   19032 </span><span class="lineNoCov">          0 :                                    SgSymbolTable* symbolTable = namespaceDefinition-&gt;get_symbol_table();</span></a>
<a name="19033"><span class="lineNum">   19033 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="19034"><span class="lineNum">   19034 </span>            : </a>
<a name="19035"><span class="lineNum">   19035 </span>            :                                 // Print out the symbol table.</a>
<a name="19036"><span class="lineNum">   19036 </span><span class="lineNoCov">          0 :                                    symbolTable-&gt;print();</span></a>
<a name="19037"><span class="lineNum">   19037 </span>            :                                  }</a>
<a name="19038"><span class="lineNum">   19038 </span>            :                             }</a>
<a name="19039"><span class="lineNum">   19039 </span>            :                        }</a>
<a name="19040"><span class="lineNum">   19040 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="19041"><span class="lineNum">   19041 </span>            :         };</a>
<a name="19042"><span class="lineNum">   19042 </span>            : </a>
<a name="19043"><span class="lineNum">   19043 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="19044"><span class="lineNum">   19044 </span><span class="lineNoCov">          0 :      ScopeTraversal traversal;</span></a>
<a name="19045"><span class="lineNum">   19045 </span><span class="lineNoCov">          0 :      traversal.traverse(astNode, preorder);</span></a>
<a name="19046"><span class="lineNum">   19046 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="19047"><span class="lineNum">   19047 </span>            : </a>
<a name="19048"><span class="lineNum">   19048 </span>            : </a>
<a name="19049"><span class="lineNum">   19049 </span>            : </a>
<a name="19050"><span class="lineNum">   19050 </span>            : </a>
<a name="19051"><span class="lineNum">   19051 </span><span class="lineNoCov">          0 : void SageInterface::markNodeToBeUnparsed(SgNode* node, int physical_file_id)</span></a>
<a name="19052"><span class="lineNum">   19052 </span>            :    {</a>
<a name="19053"><span class="lineNum">   19053 </span><span class="lineNoCov">          0 :      Sg_File_Info* fileInfo=node-&gt;get_file_info();</span></a>
<a name="19054"><span class="lineNum">   19054 </span><span class="lineNoCov">          0 :      if (fileInfo != NULL)</span></a>
<a name="19055"><span class="lineNum">   19055 </span>            :         {</a>
<a name="19056"><span class="lineNum">   19056 </span><span class="lineNoCov">          0 :           fileInfo-&gt;setTransformation();</span></a>
<a name="19057"><span class="lineNum">   19057 </span><span class="lineNoCov">          0 :           fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="19058"><span class="lineNum">   19058 </span>            : </a>
<a name="19059"><span class="lineNum">   19059 </span><span class="lineNoCov">          0 :           SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="19060"><span class="lineNum">   19060 </span><span class="lineNoCov">          0 :           if (locatedNode != NULL)</span></a>
<a name="19061"><span class="lineNum">   19061 </span>            :              {</a>
<a name="19062"><span class="lineNum">   19062 </span>            :             // DQ (7/7/2015): Make the subtree as transformed.</a>
<a name="19063"><span class="lineNum">   19063 </span><span class="lineNoCov">          0 :                locatedNode-&gt;setTransformation();</span></a>
<a name="19064"><span class="lineNum">   19064 </span><span class="lineNoCov">          0 :                locatedNode-&gt;setOutputInCodeGeneration();</span></a>
<a name="19065"><span class="lineNum">   19065 </span>            : </a>
<a name="19066"><span class="lineNum">   19066 </span>            :             // DQ (10/26/2020): Set the physical_file_id, required for ueader file unparsing (is it?).</a>
<a name="19067"><span class="lineNum">   19067 </span><span class="lineNoCov">          0 :                locatedNode-&gt;get_file_info()-&gt;set_physical_file_id(physical_file_id);</span></a>
<a name="19068"><span class="lineNum">   19068 </span>            : #if 0</a>
<a name="19069"><span class="lineNum">   19069 </span>            :                printf (&quot;Note: calling node markTransformationsForOutput(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="19070"><span class="lineNum">   19070 </span>            : #endif</a>
<a name="19071"><span class="lineNum">   19071 </span><span class="lineNoCov">          0 :                markTransformationsForOutput(node);</span></a>
<a name="19072"><span class="lineNum">   19072 </span>            :              }</a>
<a name="19073"><span class="lineNum">   19073 </span>            :             else</a>
<a name="19074"><span class="lineNum">   19074 </span>            :              {</a>
<a name="19075"><span class="lineNum">   19075 </span>            : #if 0</a>
<a name="19076"><span class="lineNum">   19076 </span>            :                printf (&quot;Note: node is not a SgLocatedNode: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="19077"><span class="lineNum">   19077 </span>            : #endif</a>
<a name="19078"><span class="lineNum">   19078 </span>            :              }</a>
<a name="19079"><span class="lineNum">   19079 </span>            :         }</a>
<a name="19080"><span class="lineNum">   19080 </span>            :        else</a>
<a name="19081"><span class="lineNum">   19081 </span>            :         {</a>
<a name="19082"><span class="lineNum">   19082 </span>            : #if 0</a>
<a name="19083"><span class="lineNum">   19083 </span>            :           printf (&quot;Note: no Sg_File_Info was found: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="19084"><span class="lineNum">   19084 </span>            : #endif</a>
<a name="19085"><span class="lineNum">   19085 </span>            :         }</a>
<a name="19086"><span class="lineNum">   19086 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="19087"><span class="lineNum">   19087 </span>            : </a>
<a name="19088"><span class="lineNum">   19088 </span>            : </a>
<a name="19089"><span class="lineNum">   19089 </span><span class="lineNoCov">          0 : void SageInterface::markSubtreeToBeUnparsed(SgNode* root, int physical_file_id)</span></a>
<a name="19090"><span class="lineNum">   19090 </span>            :    {</a>
<a name="19091"><span class="lineNum">   19091 </span><span class="lineNoCov">          0 :      RoseAst ast(root);</span></a>
<a name="19092"><span class="lineNum">   19092 </span><span class="lineNoCov">          0 :      for (RoseAst::iterator i=ast.begin();i!=ast.end();++i)</span></a>
<a name="19093"><span class="lineNum">   19093 </span>            :         {</a>
<a name="19094"><span class="lineNum">   19094 </span>            : #if 0</a>
<a name="19095"><span class="lineNum">   19095 </span>            :        // DQ (5/9/2017): Debugging code.</a>
<a name="19096"><span class="lineNum">   19096 </span>            :           if (isSgGlobal((*i)-&gt;get_parent()) != NULL)</a>
<a name="19097"><span class="lineNum">   19097 </span>            :              {</a>
<a name="19098"><span class="lineNum">   19098 </span>            :                printf (&quot;In global scope: *i = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="19099"><span class="lineNum">   19099 </span>            :              }</a>
<a name="19100"><span class="lineNum">   19100 </span>            : #endif</a>
<a name="19101"><span class="lineNum">   19101 </span>            : #if 0</a>
<a name="19102"><span class="lineNum">   19102 </span>            :           printf (&quot;Calling markNodeToBeUnparsed(): *i = %p = %s physical_file_id = %d \n&quot;,*i,(*i)-&gt;class_name().c_str(),physical_file_id);</a>
<a name="19103"><span class="lineNum">   19103 </span>            : #endif</a>
<a name="19104"><span class="lineNum">   19104 </span><span class="lineNoCov">          0 :           markNodeToBeUnparsed(*i,physical_file_id);</span></a>
<a name="19105"><span class="lineNum">   19105 </span>            :        }</a>
<a name="19106"><span class="lineNum">   19106 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="19107"><span class="lineNum">   19107 </span>            : </a>
<a name="19108"><span class="lineNum">   19108 </span>            : </a>
<a name="19109"><span class="lineNum">   19109 </span>            : </a>
<a name="19110"><span class="lineNum">   19110 </span>            : </a>
<a name="19111"><span class="lineNum">   19111 </span>            : //! Generate copies for a list of declarations and insert them into a different targetScope.</a>
<a name="19112"><span class="lineNum">   19112 </span>            : vector&lt;SgDeclarationStatement*&gt;</a>
<a name="19113"><span class="lineNum">   19113 </span><span class="lineNoCov">          0 : generateCopiesOfDependentDeclarations (const  vector&lt;SgDeclarationStatement*&gt;&amp; dependentDeclarations, SgScopeStatement* targetScope)</span></a>
<a name="19114"><span class="lineNum">   19114 </span>            : //generateCopiesOfDependentDeclarations ( SgStatement* stmt, SgScopeStatement* targetScope )</a>
<a name="19115"><span class="lineNum">   19115 </span>            :    {</a>
<a name="19116"><span class="lineNum">   19116 </span>            :   // Liao suggests adding the target scope to the parameter list so that the constructed function</a>
<a name="19117"><span class="lineNum">   19117 </span>            :   // built using SageBuilder::buildNondefiningFunctionDeclaration() can be built to be in the</a>
<a name="19118"><span class="lineNum">   19118 </span>            :   // correct scope as soon as possible.</a>
<a name="19119"><span class="lineNum">   19119 </span>            : </a>
<a name="19120"><span class="lineNum">   19120 </span>            :   // This function uses the getDependentDeclarations() function to get the dependent declarations</a>
<a name="19121"><span class="lineNum">   19121 </span>            :   // and then returns a list of copies of each of them.</a>
<a name="19122"><span class="lineNum">   19122 </span>            : </a>
<a name="19123"><span class="lineNum">   19123 </span>            : #if 0</a>
<a name="19124"><span class="lineNum">   19124 </span>            :      printf (&quot;\n\n********************************************************** \n&quot;);</a>
<a name="19125"><span class="lineNum">   19125 </span>            :      printf (&quot; Inside of generateCopiesOfDependentDeclarations(stmt = %p = %s) \n&quot;,stmt,stmt-&gt;class_name().c_str());</a>
<a name="19126"><span class="lineNum">   19126 </span>            :      printf (&quot;********************************************************** \n&quot;);</a>
<a name="19127"><span class="lineNum">   19127 </span>            : #endif</a>
<a name="19128"><span class="lineNum">   19128 </span>            : </a>
<a name="19129"><span class="lineNum">   19129 </span><span class="lineNoCov">          0 :      vector&lt;SgDeclarationStatement*&gt; copiesOfDependentDeclarations;</span></a>
<a name="19130"><span class="lineNum">   19130 </span>            :      // avoiding call getDependentDeclarations() twice</a>
<a name="19131"><span class="lineNum">   19131 </span>            : //     vector&lt;SgDeclarationStatement*&gt; dependentDeclarations = getDependentDeclarations(stmt);</a>
<a name="19132"><span class="lineNum">   19132 </span>            : </a>
<a name="19133"><span class="lineNum">   19133 </span>            : #if 0</a>
<a name="19134"><span class="lineNum">   19134 </span>            :      printf (&quot;Output the dependentDeclarations: dependentDeclarations.size() = %&quot; PRIuPTR &quot; \n&quot;,dependentDeclarations.size());</a>
<a name="19135"><span class="lineNum">   19135 </span>            :      outputDeclarationList(dependentDeclarations);</a>
<a name="19136"><span class="lineNum">   19136 </span>            : #endif</a>
<a name="19137"><span class="lineNum">   19137 </span>            : #if 0</a>
<a name="19138"><span class="lineNum">   19138 </span>            :      printf (&quot;************************************************ \n&quot;);</a>
<a name="19139"><span class="lineNum">   19139 </span>            :      printf (&quot;*** Make all copies of dependentDeclarations *** \n&quot;);</a>
<a name="19140"><span class="lineNum">   19140 </span>            :      printf (&quot;************************************************ \n&quot;);</a>
<a name="19141"><span class="lineNum">   19141 </span>            : #endif</a>
<a name="19142"><span class="lineNum">   19142 </span>            : </a>
<a name="19143"><span class="lineNum">   19143 </span>            :   // Should have a valid scope, so that symbol tables can be expected to be setup.</a>
<a name="19144"><span class="lineNum">   19144 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(targetScope != NULL);</span></a>
<a name="19145"><span class="lineNum">   19145 </span>            : </a>
<a name="19146"><span class="lineNum">   19146 </span>            :   // DQ (2/25/2009): Initially this is always global scope so test this for now, at least.</a>
<a name="19147"><span class="lineNum">   19147 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isSgGlobal(targetScope) != NULL);</span></a>
<a name="19148"><span class="lineNum">   19148 </span>            : </a>
<a name="19149"><span class="lineNum">   19149 </span><span class="lineNoCov">          0 :      for (vector&lt;SgDeclarationStatement*&gt;::const_iterator i = dependentDeclarations.begin(); i != dependentDeclarations.end(); i++)</span></a>
<a name="19150"><span class="lineNum">   19150 </span>            :         {</a>
<a name="19151"><span class="lineNum">   19151 </span>            : #if 0</a>
<a name="19152"><span class="lineNum">   19152 </span>            :           printf (&quot;Copying declaration = %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),SageInterface::get_name(*i).c_str());</a>
<a name="19153"><span class="lineNum">   19153 </span>            : #endif</a>
<a name="19154"><span class="lineNum">   19154 </span>            :        // SgNode* copy_node = (*i)-&gt;copy(collectDependentDeclarationsCopyType);</a>
<a name="19155"><span class="lineNum">   19155 </span>            : </a>
<a name="19156"><span class="lineNum">   19156 </span><span class="lineNoCov">          0 :           SgNode* copy_node = NULL;</span></a>
<a name="19157"><span class="lineNum">   19157 </span><span class="lineNoCov">          0 :           const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(*i);</span></a>
<a name="19158"><span class="lineNum">   19158 </span>            : </a>
<a name="19159"><span class="lineNum">   19159 </span>            :        // For function declarations we don't want to do deep copies on defining declarations</a>
<a name="19160"><span class="lineNum">   19160 </span>            :        // since that would violate the One-time Definition Rule (ODR).</a>
<a name="19161"><span class="lineNum">   19161 </span><span class="lineNoCov">          0 :           if (functionDeclaration != NULL)</span></a>
<a name="19162"><span class="lineNum">   19162 </span>            :              {</a>
<a name="19163"><span class="lineNum">   19163 </span>            :                // the target scope may already have a declaration for this function.</a>
<a name="19164"><span class="lineNum">   19164 </span>            :                // This happens since SageInterface::appendStatementWithDependentDeclaration() is called in the end of outlining</a>
<a name="19165"><span class="lineNum">   19165 </span>            :                // and the original enclosing class of the outlined target has been changed already (replaced target with a call to OUT_xxx())</a>
<a name="19166"><span class="lineNum">   19166 </span>            :                // Also, getDependentDeclarations() recursively searches for declarations within the dependent class and hits OUT_xxx()</a>
<a name="19167"><span class="lineNum">   19167 </span>            :                // Liao, 5/8/2009</a>
<a name="19168"><span class="lineNum">   19168 </span>            : </a>
<a name="19169"><span class="lineNum">   19169 </span><span class="lineNoCov">          0 :              if ( SgProject::get_verbose() &gt;= 1 )</span></a>
<a name="19170"><span class="lineNum">   19170 </span><span class="lineNoCov">          0 :                 printf (&quot;WARNING: In SageInterface -- generateCopiesOfDependentDeclarations(): I think this is the wrong lookup symbol function that is being used here! \n&quot;);</span></a>
<a name="19171"><span class="lineNum">   19171 </span>            : </a>
<a name="19172"><span class="lineNum">   19172 </span>            :             // DQ (8/16/2013): I think this is the wrong symbol lookup function to be using here, but the API is fixed.</a>
<a name="19173"><span class="lineNum">   19173 </span>            :             // if (targetScope-&gt;lookup_symbol(functionDeclaration-&gt;get_name()) !=NULL)</a>
<a name="19174"><span class="lineNum">   19174 </span>            :             // TV (2/4/2014): can be found in the project wide global scope...</a>
<a name="19175"><span class="lineNum">   19175 </span>            :             //                So I removed it as we only build a nondef decl and it will only happen for function declared in global scope.`</a>
<a name="19176"><span class="lineNum">   19176 </span>            :             // if (targetScope-&gt;lookup_symbol(functionDeclaration-&gt;get_name(),NULL,NULL) !=NULL)</a>
<a name="19177"><span class="lineNum">   19177 </span>            :             //      continue;</a>
<a name="19178"><span class="lineNum">   19178 </span>            : #endif</a>
<a name="19179"><span class="lineNum">   19179 </span>            : #if 0</a>
<a name="19180"><span class="lineNum">   19180 </span>            :                printf (&quot;In generateCopiesOfDependentDeclarations(): Copy mechanism appied to SgFunctionDeclaration functionDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="19181"><span class="lineNum">   19181 </span>            : </a>
<a name="19182"><span class="lineNum">   19182 </span>            :                printf (&quot;functionDeclaration                                    = %p \n&quot;,functionDeclaration);</a>
<a name="19183"><span class="lineNum">   19183 </span>            :                printf (&quot;functionDeclaration-&gt;get_definingDeclaration()         = %p \n&quot;,functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="19184"><span class="lineNum">   19184 </span>            :                printf (&quot;functionDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="19185"><span class="lineNum">   19185 </span>            :                printf (&quot;functionDeclaration-&gt;get_scope()                       = %p \n&quot;,functionDeclaration-&gt;get_scope());</a>
<a name="19186"><span class="lineNum">   19186 </span>            :                printf (&quot;targetScope                                            = %p \n&quot;,targetScope);</a>
<a name="19187"><span class="lineNum">   19187 </span>            : #endif</a>
<a name="19188"><span class="lineNum">   19188 </span><span class="lineNoCov">          0 :                SgFunctionDeclaration* copy_functionDeclaration = SageBuilder::buildNondefiningFunctionDeclaration(functionDeclaration,targetScope);</span></a>
<a name="19189"><span class="lineNum">   19189 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration != NULL);</span></a>
<a name="19190"><span class="lineNum">   19190 </span>            : </a>
<a name="19191"><span class="lineNum">   19191 </span><span class="lineNoCov">          0 :                copy_functionDeclaration-&gt;set_parent(targetScope);</span></a>
<a name="19192"><span class="lineNum">   19192 </span>            : </a>
<a name="19193"><span class="lineNum">   19193 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19194"><span class="lineNum">   19194 </span>            : </a>
<a name="19195"><span class="lineNum">   19195 </span>            :             // DQ (11/8/2020): This can not be asserted now that the buildSourceFile() has the</a>
<a name="19196"><span class="lineNum">   19196 </span>            :             // feature of clearing the symbol table used across multiple files.</a>
<a name="19197"><span class="lineNum">   19197 </span>            :             // assert(copy_functionDeclaration-&gt;get_firstNondefiningDeclaration() != copy_functionDeclaration);</a>
<a name="19198"><span class="lineNum">   19198 </span>            : </a>
<a name="19199"><span class="lineNum">   19199 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table() != NULL);</span></a>
<a name="19200"><span class="lineNum">   19200 </span>            : </a>
<a name="19201"><span class="lineNum">   19201 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_scope() != NULL);</span></a>
<a name="19202"><span class="lineNum">   19202 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_scope() == targetScope);</span></a>
<a name="19203"><span class="lineNum">   19203 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_scope()-&gt;lookup_function_symbol(copy_functionDeclaration-&gt;get_name(),</span></a>
<a name="19204"><span class="lineNum">   19204 </span>            :                     copy_functionDeclaration-&gt;get_type()) != NULL);</a>
<a name="19205"><span class="lineNum">   19205 </span><span class="lineNoCov">          0 :                assert(copy_functionDeclaration-&gt;get_scope()-&gt;lookup_function_symbol(copy_functionDeclaration-&gt;get_name(),</span></a>
<a name="19206"><span class="lineNum">   19206 </span>            :                     copy_functionDeclaration-&gt;get_type())-&gt;get_symbol_basis() == copy_functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="19207"><span class="lineNum">   19207 </span>            : </a>
<a name="19208"><span class="lineNum">   19208 </span><span class="lineNoCov">          0 :                copy_node = copy_functionDeclaration;</span></a>
<a name="19209"><span class="lineNum">   19209 </span>            : #if 0</a>
<a name="19210"><span class="lineNum">   19210 </span>            :                printf (&quot;In generateCopiesOfDependentDeclarations(): DONE: Copy mechanism appied to SgFunctionDeclaration \n&quot;);</a>
<a name="19211"><span class="lineNum">   19211 </span>            :                ROSE_ABORT();</a>
<a name="19212"><span class="lineNum">   19212 </span>            : #endif</a>
<a name="19213"><span class="lineNum">   19213 </span>            :              }</a>
<a name="19214"><span class="lineNum">   19214 </span>            :             else</a>
<a name="19215"><span class="lineNum">   19215 </span>            :              {</a>
<a name="19216"><span class="lineNum">   19216 </span>            :           // We only copy the non-defining declaration of a defining typedef declaration</a>
<a name="19217"><span class="lineNum">   19217 </span>            :           // since its defining body will be treated as a separate declaration and inserted to the new file.</a>
<a name="19218"><span class="lineNum">   19218 </span>            :           // This is also a workaround for an AST copy bug: losing defining body of a defining typedef declaration after copying.</a>
<a name="19219"><span class="lineNum">   19219 </span><span class="lineNoCov">          0 :                  SgTypedefDeclaration* tdecl = isSgTypedefDeclaration(*i);</span></a>
<a name="19220"><span class="lineNum">   19220 </span><span class="lineNoCov">          0 :                  if (tdecl)</span></a>
<a name="19221"><span class="lineNum">   19221 </span>            :                  {</a>
<a name="19222"><span class="lineNum">   19222 </span>            : #if 0</a>
<a name="19223"><span class="lineNum">   19223 </span>            :                    if (tdecl-&gt;get_definingDeclaration() == tdecl)</a>
<a name="19224"><span class="lineNum">   19224 </span>            :                      cout&lt;&lt;&quot;Copying a defining typedef declaration:&quot;&lt;&lt;tdecl-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="19225"><span class="lineNum">   19225 </span>            :                    else</a>
<a name="19226"><span class="lineNum">   19226 </span>            :                      cout&lt;&lt;&quot;Copying a non-defining typedef declaration:&quot;&lt;&lt;tdecl-&gt;unparseToString()&lt;&lt;endl;</a>
<a name="19227"><span class="lineNum">   19227 </span>            : #endif</a>
<a name="19228"><span class="lineNum">   19228 </span><span class="lineNoCov">          0 :                    copy_node = SageInterface::deepCopy(tdecl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19229"><span class="lineNum">   19229 </span><span class="lineNoCov">          0 :                    SgTypedefDeclaration* tdecl_copy = isSgTypedefDeclaration(copy_node);</span></a>
<a name="19230"><span class="lineNum">   19230 </span><span class="lineNoCov">          0 :                    tdecl_copy-&gt;set_typedefBaseTypeContainsDefiningDeclaration (false); // explicit indicate this does not contain defining base type, Liao 12/14/2012</span></a>
<a name="19231"><span class="lineNum">   19231 </span>            :                  }</a>
<a name="19232"><span class="lineNum">   19232 </span>            :                   else</a>
<a name="19233"><span class="lineNum">   19233 </span><span class="lineNoCov">          0 :                    copy_node = (*i)-&gt;copy(collectDependentDeclarationsCopyType);</span></a>
<a name="19234"><span class="lineNum">   19234 </span>            : </a>
<a name="19235"><span class="lineNum">   19235 </span>            :             // Set the scope now that we know it (might be the same as the parent which will be set when the copy is inserted into the AST).</a>
<a name="19236"><span class="lineNum">   19236 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* copy_declaration = isSgDeclarationStatement(copy_node);</span></a>
<a name="19237"><span class="lineNum">   19237 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(copy_declaration != NULL);</span></a>
<a name="19238"><span class="lineNum">   19238 </span>            : </a>
<a name="19239"><span class="lineNum">   19239 </span>            :             // DQ (3/2/2009): This will be done later, but it is set above, so set it in this branch to be consistant.</a>
<a name="19240"><span class="lineNum">   19240 </span><span class="lineNoCov">          0 :                if (copy_declaration-&gt;hasExplicitScope() == true)</span></a>
<a name="19241"><span class="lineNum">   19241 </span><span class="lineNoCov">          0 :                     copy_declaration-&gt;set_scope(targetScope);</span></a>
<a name="19242"><span class="lineNum">   19242 </span>            :              }</a>
<a name="19243"><span class="lineNum">   19243 </span>            : </a>
<a name="19244"><span class="lineNum">   19244 </span>            :        // SgNode* copy_node = (*i)-&gt;copy(collectDependentDeclarationsCopyType);</a>
<a name="19245"><span class="lineNum">   19245 </span>            :        // Build a function prototype, but what scope should be used?</a>
<a name="19246"><span class="lineNum">   19246 </span>            :        // ROSE_ASSERT(functionDeclaration-&gt;get_scope() != NULL);</a>
<a name="19247"><span class="lineNum">   19247 </span>            :        // copy = SageBuilder::buildNondefiningFunctionDeclaration(functionDeclaration,functionDeclaration-&gt;get_scope());</a>
<a name="19248"><span class="lineNum">   19248 </span>            : </a>
<a name="19249"><span class="lineNum">   19249 </span>            : #if 0</a>
<a name="19250"><span class="lineNum">   19250 </span>            :           printf (&quot;DONE: Copying declaration: original = %p = %s = %s to copy = %p = %s = %s \n&quot;,*i,(*i)-&gt;class_name().c_str(),SageInterface::get_name(*i).c_str(),copy_node,copy_node-&gt;class_name().c_str(),SageInterface::get_name(copy_node).c_str());</a>
<a name="19251"><span class="lineNum">   19251 </span>            : #endif</a>
<a name="19252"><span class="lineNum">   19252 </span>            : </a>
<a name="19253"><span class="lineNum">   19253 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_node != NULL);</span></a>
<a name="19254"><span class="lineNum">   19254 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_node-&gt;get_file_info() != NULL);</span></a>
<a name="19255"><span class="lineNum">   19255 </span>            : </a>
<a name="19256"><span class="lineNum">   19256 </span>            :        // Note that the root of the does not have its file info set like its children.</a>
<a name="19257"><span class="lineNum">   19257 </span><span class="lineNoCov">          0 :           copy_node-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="19258"><span class="lineNum">   19258 </span><span class="lineNoCov">          0 :           copy_node-&gt;get_file_info()-&gt;setOutputInCodeGeneration();</span></a>
<a name="19259"><span class="lineNum">   19259 </span>            :        // copy_node-&gt;get_file_info()-&gt;display(&quot;CollectDependentDeclarationsTraversal::visit()&quot;);</a>
<a name="19260"><span class="lineNum">   19260 </span>            : </a>
<a name="19261"><span class="lineNum">   19261 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* copy_definingDeclaration = isSgDeclarationStatement(copy_node);</span></a>
<a name="19262"><span class="lineNum">   19262 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_definingDeclaration != NULL);</span></a>
<a name="19263"><span class="lineNum">   19263 </span>            : </a>
<a name="19264"><span class="lineNum">   19264 </span><span class="lineNoCov">          0 :           ROSE_ASSERT( *i != NULL );</span></a>
<a name="19265"><span class="lineNum">   19265 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_definingDeclaration != NULL);</span></a>
<a name="19266"><span class="lineNum">   19266 </span>            : </a>
<a name="19267"><span class="lineNum">   19267 </span>            :        // DQ (2/26/2009): get_scope() will require a valid parent for some cases (see moreTest4.cpp).</a>
<a name="19268"><span class="lineNum">   19268 </span><span class="lineNoCov">          0 :           if (copy_definingDeclaration-&gt;get_parent() == NULL)</span></a>
<a name="19269"><span class="lineNum">   19269 </span>            :              {</a>
<a name="19270"><span class="lineNum">   19270 </span><span class="lineNoCov">          0 :                copy_definingDeclaration-&gt;set_parent(targetScope);</span></a>
<a name="19271"><span class="lineNum">   19271 </span>            :              }</a>
<a name="19272"><span class="lineNum">   19272 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_definingDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="19273"><span class="lineNum">   19273 </span>            : </a>
<a name="19274"><span class="lineNum">   19274 </span>            : #if 0</a>
<a name="19275"><span class="lineNum">   19275 </span>            :           printf (&quot;DONE: Copying declaration: original scope = %p copied to scope = %p \n&quot;,(*i)-&gt;get_scope(),copy_definingDeclaration-&gt;get_scope());</a>
<a name="19276"><span class="lineNum">   19276 </span>            : #endif</a>
<a name="19277"><span class="lineNum">   19277 </span>            : </a>
<a name="19278"><span class="lineNum">   19278 </span>            :        // DQ (2/22/2009): I think we need to set these explicitly (it will be reset later).</a>
<a name="19279"><span class="lineNum">   19279 </span><span class="lineNoCov">          0 :           copy_definingDeclaration-&gt;set_parent(NULL);</span></a>
<a name="19280"><span class="lineNum">   19280 </span>            : </a>
<a name="19281"><span class="lineNum">   19281 </span>            :        // Now that we pass in the scope explicitly we can set the scope (above), so don't reset to NULL!</a>
<a name="19282"><span class="lineNum">   19282 </span>            :        // copy_definingDeclaration-&gt;set_scope(NULL);</a>
<a name="19283"><span class="lineNum">   19283 </span>            : </a>
<a name="19284"><span class="lineNum">   19284 </span>            :        // DQ (2/20/2009): Added assertion.</a>
<a name="19285"><span class="lineNum">   19285 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(copy_definingDeclaration-&gt;get_parent() == NULL);</span></a>
<a name="19286"><span class="lineNum">   19286 </span>            : </a>
<a name="19287"><span class="lineNum">   19287 </span>            : #if 0</a>
<a name="19288"><span class="lineNum">   19288 </span>            :        // DQ (2/20/2009): Added assertion.</a>
<a name="19289"><span class="lineNum">   19289 </span>            :        // ROSE_ASSERT(copy_definingDeclaration-&gt;get_definingDeclaration() != NULL);</a>
<a name="19290"><span class="lineNum">   19290 </span>            :           if (copy_definingDeclaration-&gt;get_firstNondefiningDeclaration() == NULL)</a>
<a name="19291"><span class="lineNum">   19291 </span>            :              {</a>
<a name="19292"><span class="lineNum">   19292 </span>            :                printf (&quot;copy_definingDeclaration = %p \n&quot;,copy_definingDeclaration);</a>
<a name="19293"><span class="lineNum">   19293 </span>            :                printf (&quot;copy_definingDeclaration-&gt;get_firstNondefiningDeclaration() == NULL \n&quot;);</a>
<a name="19294"><span class="lineNum">   19294 </span>            :                printf (&quot;copy_definingDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,copy_definingDeclaration-&gt;get_definingDeclaration());</a>
<a name="19295"><span class="lineNum">   19295 </span>            :              }</a>
<a name="19296"><span class="lineNum">   19296 </span>            : #endif</a>
<a name="19297"><span class="lineNum">   19297 </span>            : </a>
<a name="19298"><span class="lineNum">   19298 </span>            :        // DQ (2/21/2009): Commented out as a test.</a>
<a name="19299"><span class="lineNum">   19299 </span><span class="lineNoCov">          0 :           if ((*i)-&gt;get_firstNondefiningDeclaration() != NULL)</span></a>
<a name="19300"><span class="lineNum">   19300 </span>            :              {</a>
<a name="19301"><span class="lineNum">   19301 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(copy_definingDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19302"><span class="lineNum">   19302 </span>            :              }</a>
<a name="19303"><span class="lineNum">   19303 </span>            : </a>
<a name="19304"><span class="lineNum">   19304 </span>            :        // DQ (2/20/2009): Added asertion.</a>
<a name="19305"><span class="lineNum">   19305 </span>            :        // ROSE_ASSERT(copy_definingDeclaration-&gt;get_parent() != NULL);</a>
<a name="19306"><span class="lineNum">   19306 </span>            : </a>
<a name="19307"><span class="lineNum">   19307 </span><span class="lineNoCov">          0 :           copiesOfDependentDeclarations.push_back(copy_definingDeclaration);</span></a>
<a name="19308"><span class="lineNum">   19308 </span>            :         }</a>
<a name="19309"><span class="lineNum">   19309 </span>            : </a>
<a name="19310"><span class="lineNum">   19310 </span>            : #if 0</a>
<a name="19311"><span class="lineNum">   19311 </span>            :      printf (&quot;****************************************************** \n&quot;);</a>
<a name="19312"><span class="lineNum">   19312 </span>            :      printf (&quot;*** DONE: Make all copies of dependentDeclarations *** \n&quot;);</a>
<a name="19313"><span class="lineNum">   19313 </span>            :      printf (&quot;****************************************************** \n&quot;);</a>
<a name="19314"><span class="lineNum">   19314 </span>            :      printf (&quot;copiesOfDependentDeclarations.size() = %&quot; PRIuPTR &quot; \n&quot;,copiesOfDependentDeclarations.size());</a>
<a name="19315"><span class="lineNum">   19315 </span>            : #endif</a>
<a name="19316"><span class="lineNum">   19316 </span>            : </a>
<a name="19317"><span class="lineNum">   19317 </span>            :   // The mapping of copies to original declarations should be 1-to-1.</a>
<a name="19318"><span class="lineNum">   19318 </span>            :   // Liao, not true anymore for getDependentDeclarations() using recursion: a depending class's body is searched for dependents also.</a>
<a name="19319"><span class="lineNum">   19319 </span>            :   // The class body  might have a call to an outlined function, which already has a prototype in the target scope and needs no redundant copy</a>
<a name="19320"><span class="lineNum">   19320 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(copiesOfDependentDeclarations.size() &lt;= dependentDeclarations.size());</span></a>
<a name="19321"><span class="lineNum">   19321 </span>            : </a>
<a name="19322"><span class="lineNum">   19322 </span><span class="lineNoCov">          0 :      return copiesOfDependentDeclarations;</span></a>
<a name="19323"><span class="lineNum">   19323 </span>            :    }</a>
<a name="19324"><span class="lineNum">   19324 </span>            : </a>
<a name="19325"><span class="lineNum">   19325 </span>            : </a>
<a name="19326"><span class="lineNum">   19326 </span>            : bool</a>
<a name="19327"><span class="lineNum">   19327 </span><span class="lineNoCov">          0 : declarationContainsDependentDeclarations( SgDeclarationStatement* decl, vector&lt;SgDeclarationStatement*&gt; &amp; dependentDeclarationList )</span></a>
<a name="19328"><span class="lineNum">   19328 </span>            :    {</a>
<a name="19329"><span class="lineNum">   19329 </span>            :   // DQ (2/16/2009): This function finds the declarations in &quot;decl&quot; and checks if they match against those in dependentDeclarationList</a>
<a name="19330"><span class="lineNum">   19330 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="19331"><span class="lineNum">   19331 </span>            : </a>
<a name="19332"><span class="lineNum">   19332 </span>            : #if 0</a>
<a name="19333"><span class="lineNum">   19333 </span>            :      printf (&quot;\n\n********************************************************** \n&quot;);</a>
<a name="19334"><span class="lineNum">   19334 </span>            :      printf (&quot; Inside of declarationContainsDependentDeclarations(decl = %p = %s) \n&quot;,decl,decl-&gt;class_name().c_str());</a>
<a name="19335"><span class="lineNum">   19335 </span>            :      printf (&quot;********************************************************** \n&quot;);</a>
<a name="19336"><span class="lineNum">   19336 </span>            : #endif</a>
<a name="19337"><span class="lineNum">   19337 </span>            : </a>
<a name="19338"><span class="lineNum">   19338 </span><span class="lineNoCov">          0 :      vector&lt;SgDeclarationStatement*&gt; locallyDependentDeclarationList = SageInterface::getDependentDeclarations(decl);</span></a>
<a name="19339"><span class="lineNum">   19339 </span>            : </a>
<a name="19340"><span class="lineNum">   19340 </span>            :   // printf (&quot;In declarationContainsDependentDeclarations(): locallyDependentDeclarationList: \n&quot;);</a>
<a name="19341"><span class="lineNum">   19341 </span>            :   // outputPreprocessingInfoList(locallyDependentDeclarationList);</a>
<a name="19342"><span class="lineNum">   19342 </span>            : </a>
<a name="19343"><span class="lineNum">   19343 </span><span class="lineNoCov">          0 :      for (size_t i = 0; i &lt; locallyDependentDeclarationList.size(); i++)</span></a>
<a name="19344"><span class="lineNum">   19344 </span>            :         {</a>
<a name="19345"><span class="lineNum">   19345 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* d = locallyDependentDeclarationList[i];</span></a>
<a name="19346"><span class="lineNum">   19346 </span>            : #if 0</a>
<a name="19347"><span class="lineNum">   19347 </span>            :           printf (&quot;locallyDependentDeclarationList[%&quot; PRIuPTR &quot;] = %p = %s = %s \n&quot;,i,d,d-&gt;class_name().c_str(),SageInterface::get_name(d).c_str());</a>
<a name="19348"><span class="lineNum">   19348 </span>            : #endif</a>
<a name="19349"><span class="lineNum">   19349 </span><span class="lineNoCov">          0 :           vector&lt;SgDeclarationStatement*&gt;::iterator j = find(dependentDeclarationList.begin(),dependentDeclarationList.end(),d);</span></a>
<a name="19350"><span class="lineNum">   19350 </span><span class="lineNoCov">          0 :           if (j != dependentDeclarationList.end())</span></a>
<a name="19351"><span class="lineNum">   19351 </span>            :              {</a>
<a name="19352"><span class="lineNum">   19352 </span>            :             // These identified declaration must be output as members of the class when it is output in the separate header file.</a>
<a name="19353"><span class="lineNum">   19353 </span>            :             // infact ODR may require that the whole class be output! Actually I think we don't have any chioce here!</a>
<a name="19354"><span class="lineNum">   19354 </span>            : #if 0</a>
<a name="19355"><span class="lineNum">   19355 </span>            :                printf (&quot;Found a dependent declaration buried in the class definition: locallyDependentDeclarationList[%&quot; PRIuPTR &quot;] = %p = %s = %s \n&quot;,i,d,d-&gt;class_name().c_str(),SageInterface::get_name(d).c_str());</a>
<a name="19356"><span class="lineNum">   19356 </span>            : #endif</a>
<a name="19357"><span class="lineNum">   19357 </span><span class="lineNoCov">          0 :                returnValue = true;</span></a>
<a name="19358"><span class="lineNum">   19358 </span>            :              }</a>
<a name="19359"><span class="lineNum">   19359 </span>            :         }</a>
<a name="19360"><span class="lineNum">   19360 </span>            : </a>
<a name="19361"><span class="lineNum">   19361 </span>            : #if 0</a>
<a name="19362"><span class="lineNum">   19362 </span>            :      printf (&quot;**************************************************************************** \n&quot;);</a>
<a name="19363"><span class="lineNum">   19363 </span>            :      printf (&quot; LEAVING: Inside of declarationContainsDependentDeclarations(decl = %p = %s) returnValue = %s \n&quot;,decl,decl-&gt;class_name().c_str(),returnValue ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="19364"><span class="lineNum">   19364 </span>            :      printf (&quot;**************************************************************************** \n&quot;);</a>
<a name="19365"><span class="lineNum">   19365 </span>            : #endif</a>
<a name="19366"><span class="lineNum">   19366 </span>            : </a>
<a name="19367"><span class="lineNum">   19367 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="19368"><span class="lineNum">   19368 </span>            :    }</a>
<a name="19369"><span class="lineNum">   19369 </span>            : //! Insert an expression (new_exp )before another expression (anchor_exp) has possible side effects, with minimum changes to the original semantics. This is achieved by using a comma operator: (new_exp, anchor_exp). The comma operator is returned.</a>
<a name="19370"><span class="lineNum">   19370 </span><span class="lineCov">          1 : SgCommaOpExp * SageInterface::insertBeforeUsingCommaOp (SgExpression* new_exp, SgExpression* anchor_exp)</span></a>
<a name="19371"><span class="lineNum">   19371 </span>            : {</a>
<a name="19372"><span class="lineNum">   19372 </span><span class="lineCov">          1 :   ROSE_ASSERT (new_exp != NULL);</span></a>
<a name="19373"><span class="lineNum">   19373 </span><span class="lineCov">          1 :   ROSE_ASSERT (anchor_exp != NULL);</span></a>
<a name="19374"><span class="lineNum">   19374 </span><span class="lineCov">          1 :   ROSE_ASSERT (new_exp != anchor_exp);</span></a>
<a name="19375"><span class="lineNum">   19375 </span>            : </a>
<a name="19376"><span class="lineNum">   19376 </span><span class="lineCov">          1 :   SgNode* parent = anchor_exp-&gt;get_parent();</span></a>
<a name="19377"><span class="lineNum">   19377 </span><span class="lineCov">          1 :   ROSE_ASSERT (parent != NULL);</span></a>
<a name="19378"><span class="lineNum">   19378 </span>            : </a>
<a name="19379"><span class="lineNum">   19379 </span>            :   //TODO use deep copy may be a better way, avoid reusing the original anchor_exp</a>
<a name="19380"><span class="lineNum">   19380 </span><span class="lineCov">          1 :   SgCommaOpExp * result = buildCommaOpExp(new_exp, NULL);</span></a>
<a name="19381"><span class="lineNum">   19381 </span><span class="lineCov">          1 :   ROSE_ASSERT (result != NULL);</span></a>
<a name="19382"><span class="lineNum">   19382 </span><span class="lineCov">          1 :   replaceExpression (anchor_exp, result, true);</span></a>
<a name="19383"><span class="lineNum">   19383 </span>            : </a>
<a name="19384"><span class="lineNum">   19384 </span><span class="lineCov">          1 :   result-&gt;set_rhs_operand(anchor_exp);</span></a>
<a name="19385"><span class="lineNum">   19385 </span><span class="lineCov">          1 :   anchor_exp-&gt;set_parent(result);</span></a>
<a name="19386"><span class="lineNum">   19386 </span><span class="lineCov">          1 :   return result ;</span></a>
<a name="19387"><span class="lineNum">   19387 </span>            : }</a>
<a name="19388"><span class="lineNum">   19388 </span>            : </a>
<a name="19389"><span class="lineNum">   19389 </span>            : </a>
<a name="19390"><span class="lineNum">   19390 </span>            : //! Insert an expression (new_exp ) after another expression (anchor_exp) has possible side effects, with minimum changes to the original semantics. This is done by using two comma operators:  type T1; ... ((T1 = anchor_exp, new_exp),T1) )... , where T1 is a temp variable saving the possible side effect of anchor_exp. The top level comma op exp is returned. The reference to T1 in T1 = anchor_exp is saved in temp_ref.</a>
<a name="19391"><span class="lineNum">   19391 </span><span class="lineCov">          1 : SgCommaOpExp * SageInterface::insertAfterUsingCommaOp (SgExpression* new_exp, SgExpression* anchor_exp, SgStatement** temp_decl /* = NULL */, SgVarRefExp** temp_ref /* = NULL */)</span></a>
<a name="19392"><span class="lineNum">   19392 </span>            : {</a>
<a name="19393"><span class="lineNum">   19393 </span><span class="lineCov">          1 :   ROSE_ASSERT (new_exp != NULL);</span></a>
<a name="19394"><span class="lineNum">   19394 </span><span class="lineCov">          1 :   ROSE_ASSERT (anchor_exp != NULL);</span></a>
<a name="19395"><span class="lineNum">   19395 </span><span class="lineCov">          1 :   ROSE_ASSERT (new_exp != anchor_exp);</span></a>
<a name="19396"><span class="lineNum">   19396 </span>            : </a>
<a name="19397"><span class="lineNum">   19397 </span><span class="lineCov">          1 :   SgNode* parent = anchor_exp-&gt;get_parent();</span></a>
<a name="19398"><span class="lineNum">   19398 </span><span class="lineCov">          1 :   ROSE_ASSERT (parent != NULL);</span></a>
<a name="19399"><span class="lineNum">   19399 </span>            : </a>
<a name="19400"><span class="lineNum">   19400 </span>            :   // insert TYPE T1; right before the enclosing statement of anchor_exp</a>
<a name="19401"><span class="lineNum">   19401 </span><span class="lineCov">          1 :   SgType * t = anchor_exp -&gt;get_type();</span></a>
<a name="19402"><span class="lineNum">   19402 </span><span class="lineCov">          1 :   ROSE_ASSERT (t != NULL);</span></a>
<a name="19403"><span class="lineNum">   19403 </span><span class="lineCov">          1 :   SgStatement * enclosing_stmt = getEnclosingStatement(anchor_exp);</span></a>
<a name="19404"><span class="lineNum">   19404 </span><span class="lineCov">          1 :   ROSE_ASSERT (enclosing_stmt != NULL);</span></a>
<a name="19405"><span class="lineNum">   19405 </span>            : </a>
<a name="19406"><span class="lineNum">   19406 </span><span class="lineCov">          1 :   gensym_counter ++;</span></a>
<a name="19407"><span class="lineNum">   19407 </span><span class="lineCov">          1 :   string temp_name = &quot;_t_&quot;+ StringUtility::numberToString(gensym_counter);</span></a>
<a name="19408"><span class="lineNum">   19408 </span><span class="lineCov">          1 :   SgVariableDeclaration* t_decl = buildVariableDeclaration(temp_name, t, NULL, enclosing_stmt-&gt;get_scope());</span></a>
<a name="19409"><span class="lineNum">   19409 </span><span class="lineCov">          1 :   insertStatementBefore (enclosing_stmt, t_decl);</span></a>
<a name="19410"><span class="lineNum">   19410 </span><span class="lineCov">          1 :   SgVariableSymbol * temp_sym = getFirstVarSym (t_decl);</span></a>
<a name="19411"><span class="lineNum">   19411 </span><span class="lineCov">          1 :   ROSE_ASSERT (temp_sym != NULL);</span></a>
<a name="19412"><span class="lineNum">   19412 </span><span class="lineCov">          1 :   if (temp_decl)</span></a>
<a name="19413"><span class="lineNum">   19413 </span><span class="lineNoCov">          0 :     *temp_decl = t_decl;</span></a>
<a name="19414"><span class="lineNum">   19414 </span>            : </a>
<a name="19415"><span class="lineNum">   19415 </span>            :   // build ((T1 = anchor_exp, new_exp),T1) )</a>
<a name="19416"><span class="lineNum">   19416 </span><span class="lineCov">          1 :   SgVarRefExp * first_ref = buildVarRefExp(temp_sym);</span></a>
<a name="19417"><span class="lineNum">   19417 </span><span class="lineCov">          1 :   if (temp_ref)</span></a>
<a name="19418"><span class="lineNum">   19418 </span><span class="lineNoCov">          0 :     * temp_ref = first_ref;</span></a>
<a name="19419"><span class="lineNum">   19419 </span><span class="lineCov">          1 :   SgCommaOpExp * result = buildCommaOpExp ( buildCommaOpExp (buildAssignOp ( first_ref, deepCopy(anchor_exp)), new_exp) , buildVarRefExp(temp_sym));</span></a>
<a name="19420"><span class="lineNum">   19420 </span><span class="lineCov">          1 :   replaceExpression (anchor_exp, result, false);</span></a>
<a name="19421"><span class="lineNum">   19421 </span>            : </a>
<a name="19422"><span class="lineNum">   19422 </span><span class="lineCov">          1 :   return result;</span></a>
<a name="19423"><span class="lineNum">   19423 </span>            : }</a>
<a name="19424"><span class="lineNum">   19424 </span>            : </a>
<a name="19425"><span class="lineNum">   19425 </span>            : void</a>
<a name="19426"><span class="lineNum">   19426 </span><span class="lineNoCov">          0 : SageInterface::addMessageStatement( SgStatement* stmt, string message )</span></a>
<a name="19427"><span class="lineNum">   19427 </span>            :    {</a>
<a name="19428"><span class="lineNum">   19428 </span>            :   // Put out a message in the separate file to lable the dependent CPP directives.</a>
<a name="19429"><span class="lineNum">   19429 </span>            :   // --- PreprocessingInfo(DirectiveType, const std::string &amp; inputString, const std::string &amp; filenameString, int line_no, int col_no, int nol, RelativePositionType relPos );</a>
<a name="19430"><span class="lineNum">   19430 </span>            :   // SgSourceFile* separateSourceFile = TransformationSupport::getSourceFile(scope);</a>
<a name="19431"><span class="lineNum">   19431 </span><span class="lineNoCov">          0 :      string fileName = &quot;separate-outlined-file&quot;;</span></a>
<a name="19432"><span class="lineNum">   19432 </span><span class="lineNoCov">          0 :      PreprocessingInfo* messageToUser = new PreprocessingInfo(PreprocessingInfo::C_StyleComment,message,fileName,0,0,1,PreprocessingInfo::before);</span></a>
<a name="19433"><span class="lineNum">   19433 </span>            :   // requiredDirectivesList.push_back(messageToUser);</a>
<a name="19434"><span class="lineNum">   19434 </span><span class="lineNoCov">          0 :      stmt-&gt;addToAttachedPreprocessingInfo(messageToUser,PreprocessingInfo::before);</span></a>
<a name="19435"><span class="lineNum">   19435 </span>            : </a>
<a name="19436"><span class="lineNum">   19436 </span>            :   // DQ (3/12/2019): We need to mark the added comments and CPP directives as a transformation so that then can be output.</a>
<a name="19437"><span class="lineNum">   19437 </span>            :   // This is a result of a fix to support the correct handling of comments and CPP directives for shared IR nodes as happen</a>
<a name="19438"><span class="lineNum">   19438 </span>            :   // when multiple files are used on the command line.</a>
<a name="19439"><span class="lineNum">   19439 </span><span class="lineNoCov">          0 :      messageToUser-&gt;get_file_info()-&gt;setTransformation();</span></a>
<a name="19440"><span class="lineNum">   19440 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="19441"><span class="lineNum">   19441 </span>            : </a>
<a name="19442"><span class="lineNum">   19442 </span>            : </a>
<a name="19443"><span class="lineNum">   19443 </span>            : // DQ (2/6/2009): Added function to support outlining into separate file.</a>
<a name="19444"><span class="lineNum">   19444 </span>            : // Append a function 'decl' into a 'scope', including any referenced declarations required if the scope is within a compiler generated file. All referenced declarations, including those from headers, are inserted if excludeHeaderFiles is set to true (the new file will not have any headers)</a>
<a name="19445"><span class="lineNum">   19445 </span>            : void</a>
<a name="19446"><span class="lineNum">   19446 </span><span class="lineNoCov">          0 : SageInterface::appendStatementWithDependentDeclaration( SgDeclarationStatement* decl, SgGlobal* scope, SgStatement* original_statement, bool excludeHeaderFiles)</span></a>
<a name="19447"><span class="lineNum">   19447 </span>            :    {</a>
<a name="19448"><span class="lineNum">   19448 </span>            :   // New function to support outlining of functions into separate files (with their required declarations).</a>
<a name="19449"><span class="lineNum">   19449 </span>            : </a>
<a name="19450"><span class="lineNum">   19450 </span>            : #if 0</a>
<a name="19451"><span class="lineNum">   19451 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): decl                                    = %p \n&quot;,decl);</a>
<a name="19452"><span class="lineNum">   19452 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): decl-&gt;get_parent()                      = %p \n&quot;,decl-&gt;get_parent());</a>
<a name="19453"><span class="lineNum">   19453 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): decl-&gt;get_scope()                       = %p \n&quot;,decl-&gt;get_scope());</a>
<a name="19454"><span class="lineNum">   19454 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): original_statement                      = %p \n&quot;,original_statement);</a>
<a name="19455"><span class="lineNum">   19455 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): file (decl)                             = %s \n&quot;,TransformationSupport::getSourceFile(decl)-&gt;getFileName().c_str());</a>
<a name="19456"><span class="lineNum">   19456 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): decl-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,decl-&gt;get_firstNondefiningDeclaration());</a>
<a name="19457"><span class="lineNum">   19457 </span>            :      if (decl-&gt;get_firstNondefiningDeclaration() != NULL)</a>
<a name="19458"><span class="lineNum">   19458 </span>            :           printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): file (first non-defining)               = %s \n&quot;,TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration())-&gt;getFileName().c_str());</a>
<a name="19459"><span class="lineNum">   19459 </span>            :      printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): decl-&gt;get_definingDeclaration()         = %p \n&quot;,decl-&gt;get_definingDeclaration());</a>
<a name="19460"><span class="lineNum">   19460 </span>            :      if (decl-&gt;get_definingDeclaration() != NULL)</a>
<a name="19461"><span class="lineNum">   19461 </span>            :           printf (&quot;***** In SageInterface::appendStatementWithDependentDeclaration(): file (first non-defining)               = %s \n&quot;,TransformationSupport::getSourceFile(decl-&gt;get_definingDeclaration())-&gt;getFileName().c_str());</a>
<a name="19462"><span class="lineNum">   19462 </span>            : #endif</a>
<a name="19463"><span class="lineNum">   19463 </span>            : </a>
<a name="19464"><span class="lineNum">   19464 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="19465"><span class="lineNum">   19465 </span>            :   // Make sure that the input declaration (decl&quot; is consistent in it's representation across more</a>
<a name="19466"><span class="lineNum">   19466 </span>            :   // than one file (only a significant test when outlining to a separate file; which is what this</a>
<a name="19467"><span class="lineNum">   19467 </span>            :   // function supports).</a>
<a name="19468"><span class="lineNum">   19468 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19469"><span class="lineNum">   19469 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(TransformationSupport::getSourceFile(decl) == TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration()));</span></a>
<a name="19470"><span class="lineNum">   19470 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(TransformationSupport::getSourceFile(decl-&gt;get_scope()) == TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration()));</span></a>
<a name="19471"><span class="lineNum">   19471 </span>            : </a>
<a name="19472"><span class="lineNum">   19472 </span>            :   // DQ (2/6/2009): I need to write this function to support the</a>
<a name="19473"><span class="lineNum">   19473 </span>            :   // insertion of the function into the specified scope.  If the</a>
<a name="19474"><span class="lineNum">   19474 </span>            :   // file associated with the scope is marked as compiler generated</a>
<a name="19475"><span class="lineNum">   19475 </span>            :   // (or as a transformation) then the declarations referenced in the</a>
<a name="19476"><span class="lineNum">   19476 </span>            :   // function must be copied as well (those not in include files)</a>
<a name="19477"><span class="lineNum">   19477 </span>            :   // and the include files must be copies also. If the SgFile</a>
<a name="19478"><span class="lineNum">   19478 </span>            :   // is not compiler generated (or a transformation) then we just</a>
<a name="19479"><span class="lineNum">   19479 </span>            :   // append the function to the scope (trivial case).</a>
<a name="19480"><span class="lineNum">   19480 </span>            : </a>
<a name="19481"><span class="lineNum">   19481 </span>            :   // This code will be based on the work in:</a>
<a name="19482"><span class="lineNum">   19482 </span>            :   //   developersScratchSpace/Dan/translator_tests/reverseTraversal.C</a>
<a name="19483"><span class="lineNum">   19483 </span>            : </a>
<a name="19484"><span class="lineNum">   19484 </span>            :   // To test this run: &quot;rm moreTest2.o ; make moreTest2.o&quot;</a>
<a name="19485"><span class="lineNum">   19485 </span>            :   // in directory: tests/nonsmoke/functional/roseTests/astOutliningTests</a>
<a name="19486"><span class="lineNum">   19486 </span>            : </a>
<a name="19487"><span class="lineNum">   19487 </span>            :   // ***** Also move different loop IR nodes into a common base class *****</a>
<a name="19488"><span class="lineNum">   19488 </span>            : </a>
<a name="19489"><span class="lineNum">   19489 </span>            :   // SgSourceFile* separateSourceFile = TransformationSupport::getSourceFile(scope);</a>
<a name="19490"><span class="lineNum">   19490 </span>            : </a>
<a name="19491"><span class="lineNum">   19491 </span>            :   // DQ (3/2/2009): This now calls a newer function which returns a list of declarations and a list of symbols.</a>
<a name="19492"><span class="lineNum">   19492 </span>            :   // The declarations are sometimes outer declarations of nested references to dependent declaration in inner</a>
<a name="19493"><span class="lineNum">   19493 </span>            :   // scopes (see moreTest3.cpp).  The Symbol list are the symbols in the old AST that will be mapped to newer</a>
<a name="19494"><span class="lineNum">   19494 </span>            :   // symbols generated in the copied AST.</a>
<a name="19495"><span class="lineNum">   19495 </span>            :   // Collect the declaration that the input declaration depends upon.</a>
<a name="19496"><span class="lineNum">   19496 </span><span class="lineNoCov">          0 :     vector&lt;SgDeclarationStatement*&gt; dependentDeclarationList_inOriginalFile;</span></a>
<a name="19497"><span class="lineNum">   19497 </span>            : </a>
<a name="19498"><span class="lineNum">   19498 </span><span class="lineNoCov">          0 :     dependentDeclarationList_inOriginalFile = getDependentDeclarations(decl);</span></a>
<a name="19499"><span class="lineNum">   19499 </span>            : </a>
<a name="19500"><span class="lineNum">   19500 </span>            :   // Generate the copies of all the dependent statements</a>
<a name="19501"><span class="lineNum">   19501 </span>            : //     printf (&quot;Fixme: this currently causes the getDependentDeclarations(decl) function to be called twice \n&quot;);</a>
<a name="19502"><span class="lineNum">   19502 </span>            : //     vector&lt;SgDeclarationStatement*&gt; dependentDeclarationList = generateCopiesOfDependentDeclarations(decl,scope);</a>
<a name="19503"><span class="lineNum">   19503 </span><span class="lineNoCov">          0 :      vector&lt;SgDeclarationStatement*&gt; dependentDeclarationList = generateCopiesOfDependentDeclarations(dependentDeclarationList_inOriginalFile,scope);</span></a>
<a name="19504"><span class="lineNum">   19504 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(dependentDeclarationList.size() &lt;= dependentDeclarationList_inOriginalFile.size());</span></a>
<a name="19505"><span class="lineNum">   19505 </span>            : </a>
<a name="19506"><span class="lineNum">   19506 </span>            :   // Make sure that the input declaration (decl&quot; is consistent in it's representation across more</a>
<a name="19507"><span class="lineNum">   19507 </span>            :   // than one file (only a significant test when outlining to a separate file; which is what this</a>
<a name="19508"><span class="lineNum">   19508 </span>            :   // function supports).</a>
<a name="19509"><span class="lineNum">   19509 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19510"><span class="lineNum">   19510 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(TransformationSupport::getSourceFile(decl) == TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration()));</span></a>
<a name="19511"><span class="lineNum">   19511 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(TransformationSupport::getSourceFile(decl-&gt;get_scope()) == TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration()));</span></a>
<a name="19512"><span class="lineNum">   19512 </span>            : </a>
<a name="19513"><span class="lineNum">   19513 </span>            :   // This is used to fixup the AST by resetting references to IR nodes (leveraged from AST merge).</a>
<a name="19514"><span class="lineNum">   19514 </span><span class="lineNoCov">          0 :      std::map&lt;SgNode*, SgNode*&gt; replacementMap;</span></a>
<a name="19515"><span class="lineNum">   19515 </span>            : </a>
<a name="19516"><span class="lineNum">   19516 </span>            :   // DQ (3/2/2009): Now use the collectDependentDeclarationsCopyType object to generate the mapping</a>
<a name="19517"><span class="lineNum">   19517 </span>            :   // from the symbols in the old AST to the new symbols in the new AST (generated as part of the AST</a>
<a name="19518"><span class="lineNum">   19518 </span>            :   // copy mechanism).</a>
<a name="19519"><span class="lineNum">   19519 </span><span class="lineNoCov">          0 :      SgCopyHelp::copiedNodeMapType copyNodeMap = collectDependentDeclarationsCopyType.get_copiedNodeMap();</span></a>
<a name="19520"><span class="lineNum">   19520 </span><span class="lineNoCov">          0 :      SgCopyHelp::copiedNodeMapType::iterator copyNodeMapItrator = copyNodeMap.begin();</span></a>
<a name="19521"><span class="lineNum">   19521 </span><span class="lineNoCov">          0 :      while (copyNodeMapItrator != copyNodeMap.end())</span></a>
<a name="19522"><span class="lineNum">   19522 </span>            :         {</a>
<a name="19523"><span class="lineNum">   19523 </span>            :        // Loop over all the nodes generated in the AST copy mechanism (accumulated result over multiple copies).</a>
<a name="19524"><span class="lineNum">   19524 </span>            :        // const SgNode* first  = const_cast&lt;SgNode*&gt;(copyNodeMapItrator-&gt;first);</a>
<a name="19525"><span class="lineNum">   19525 </span>            :        // SgNode* first  = copyNodeMapItrator-&gt;first;</a>
<a name="19526"><span class="lineNum">   19526 </span><span class="lineNoCov">          0 :           SgNode* first  = const_cast&lt;SgNode*&gt;(copyNodeMapItrator-&gt;first);</span></a>
<a name="19527"><span class="lineNum">   19527 </span><span class="lineNoCov">          0 :           SgNode* second = copyNodeMapItrator-&gt;second;</span></a>
<a name="19528"><span class="lineNum">   19528 </span>            : #if 0</a>
<a name="19529"><span class="lineNum">   19529 </span>            :           printf (&quot;copyNodeMapItrator.first = %p = %s second = %p = %s \n&quot;,first,first-&gt;class_name().c_str(),second,second-&gt;class_name().c_str());</a>
<a name="19530"><span class="lineNum">   19530 </span>            : #endif</a>
<a name="19531"><span class="lineNum">   19531 </span>            :        // Add the SgGlobal referenece to the replacementMap</a>
<a name="19532"><span class="lineNum">   19532 </span><span class="lineNoCov">          0 :           if (isSgSymbol(first) != NULL)</span></a>
<a name="19533"><span class="lineNum">   19533 </span>            :              {</a>
<a name="19534"><span class="lineNum">   19534 </span>            : #if 0</a>
<a name="19535"><span class="lineNum">   19535 </span>            :                printf (&quot;Adding to replacementMap (first = %p = %s = %s , second = %p \n&quot;,first,first-&gt;class_name().c_str(),SageInterface::get_name(first).c_str(),second);</a>
<a name="19536"><span class="lineNum">   19536 </span>            : #endif</a>
<a name="19537"><span class="lineNum">   19537 </span><span class="lineNoCov">          0 :                replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(first,second));</span></a>
<a name="19538"><span class="lineNum">   19538 </span>            :              }</a>
<a name="19539"><span class="lineNum">   19539 </span>            : </a>
<a name="19540"><span class="lineNum">   19540 </span><span class="lineNoCov">          0 :           copyNodeMapItrator++;</span></a>
<a name="19541"><span class="lineNum">   19541 </span>            :         }</a>
<a name="19542"><span class="lineNum">   19542 </span>            : </a>
<a name="19543"><span class="lineNum">   19543 </span>            : #if 0</a>
<a name="19544"><span class="lineNum">   19544 </span>            :      printf (&quot;Exiting after test of new functionality \n&quot;);</a>
<a name="19545"><span class="lineNum">   19545 </span>            :      ROSE_ABORT();</a>
<a name="19546"><span class="lineNum">   19546 </span>            : #endif</a>
<a name="19547"><span class="lineNum">   19547 </span>            : </a>
<a name="19548"><span class="lineNum">   19548 </span>            :   // DQ (2/22/2009): We need all the declarations! (moreTest3.cpp demonstrates this, since it drops</a>
<a name="19549"><span class="lineNum">   19549 </span>            :   // the &quot;#define SIMPLE 1&quot; which causes it to be treated a &quot;0&quot; (causing errors in the generated code).</a>
<a name="19550"><span class="lineNum">   19550 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = TransformationSupport::getSourceFile(original_statement);</span></a>
<a name="19551"><span class="lineNum">   19551 </span><span class="lineNoCov">          0 :      vector&lt;PreprocessingInfo*&gt; requiredDirectivesList = collectCppDirectives(sourceFile);</span></a>
<a name="19552"><span class="lineNum">   19552 </span>            : </a>
<a name="19553"><span class="lineNum">   19553 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* outlinedFunctionDeclaration = isSgFunctionDeclaration(decl);</span></a>
<a name="19554"><span class="lineNum">   19554 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedFunctionDeclaration != NULL);</span></a>
<a name="19555"><span class="lineNum">   19555 </span><span class="lineNoCov">          0 :      SgGlobal* originalFileGlobalScope = TransformationSupport::getGlobalScope(original_statement);</span></a>
<a name="19556"><span class="lineNum">   19556 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(originalFileGlobalScope != NULL);</span></a>
<a name="19557"><span class="lineNum">   19557 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt;= 1 )</span></a>
<a name="19558"><span class="lineNum">   19558 </span><span class="lineNoCov">          0 :        printf (&quot;WARNING: In SageInterface::appendStatementWithDependentDeclaration(): I think this is the wrong lookup symbol function that is being used here! \n&quot;);</span></a>
<a name="19559"><span class="lineNum">   19559 </span>            : </a>
<a name="19560"><span class="lineNum">   19560 </span>            :   // DQ (8/16/2013): I think this is the wrong symbol lookup function to be using here, but the API is fixed.</a>
<a name="19561"><span class="lineNum">   19561 </span>            :   // SgFunctionSymbol* outlinedFunctionSymbolFromOriginalFile = isSgFunctionSymbol(originalFileGlobalScope-&gt;lookup_symbol(outlinedFunctionDeclaration-&gt;get_name()));</a>
<a name="19562"><span class="lineNum">   19562 </span><span class="lineNoCov">          0 :      SgFunctionSymbol* outlinedFunctionSymbolFromOriginalFile = isSgFunctionSymbol(originalFileGlobalScope-&gt;lookup_symbol(outlinedFunctionDeclaration-&gt;get_name(),NULL,NULL));</span></a>
<a name="19563"><span class="lineNum">   19563 </span>            : </a>
<a name="19564"><span class="lineNum">   19564 </span>            :   // SgSymbol* outlinedFunctionSymbolFromOutlinedFile = scope-&gt;lookup_symbol(outlinedFunctionDeclaration-&gt;get_name());</a>
<a name="19565"><span class="lineNum">   19565 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(decl-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="19566"><span class="lineNum">   19566 </span><span class="lineNoCov">          0 :      SgFunctionSymbol* outlinedFunctionSymbolFromOutlinedFile = isSgFunctionSymbol(decl-&gt;get_firstNondefiningDeclaration()-&gt;get_symbol_from_symbol_table());</span></a>
<a name="19567"><span class="lineNum">   19567 </span>            : #if 0</a>
<a name="19568"><span class="lineNum">   19568 </span>            :      printf (&quot;outlinedFunctionSymbolFromOriginalFile = %p outlinedFunctionSymbolFromOutlinedFile = %p \n&quot;,outlinedFunctionSymbolFromOriginalFile,outlinedFunctionSymbolFromOutlinedFile);</a>
<a name="19569"><span class="lineNum">   19569 </span>            : </a>
<a name="19570"><span class="lineNum">   19570 </span>            :      printf (&quot;TransformationSupport::getSourceFile(decl)-&gt;getFileName()                                    = %s \n&quot;,TransformationSupport::getSourceFile(decl)-&gt;getFileName().c_str());</a>
<a name="19571"><span class="lineNum">   19571 </span>            :      printf (&quot;TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration())-&gt;getFileName() = %s \n&quot;,TransformationSupport::getSourceFile(decl-&gt;get_firstNondefiningDeclaration())-&gt;getFileName().c_str());</a>
<a name="19572"><span class="lineNum">   19572 </span>            :      printf (&quot;TransformationSupport::getSourceFile(original_statement)-&gt;getFileName()                      = %s \n&quot;,TransformationSupport::getSourceFile(original_statement)-&gt;getFileName().c_str());</a>
<a name="19573"><span class="lineNum">   19573 </span>            : #endif</a>
<a name="19574"><span class="lineNum">   19574 </span>            : </a>
<a name="19575"><span class="lineNum">   19575 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedFunctionSymbolFromOriginalFile != NULL);</span></a>
<a name="19576"><span class="lineNum">   19576 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedFunctionSymbolFromOutlinedFile != NULL);</span></a>
<a name="19577"><span class="lineNum">   19577 </span>            : </a>
<a name="19578"><span class="lineNum">   19578 </span>            :   // TV (07/24/2013): Symbol are unified across files through the project wide global scope</a>
<a name="19579"><span class="lineNum">   19579 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedFunctionSymbolFromOriginalFile == outlinedFunctionSymbolFromOutlinedFile);</span></a>
<a name="19580"><span class="lineNum">   19580 </span>            : </a>
<a name="19581"><span class="lineNum">   19581 </span>            :   // Add the SgGlobal referenece to the replacementMap</a>
<a name="19582"><span class="lineNum">   19582 </span><span class="lineNoCov">          0 :      replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(originalFileGlobalScope,scope));</span></a>
<a name="19583"><span class="lineNum">   19583 </span>            : </a>
<a name="19584"><span class="lineNum">   19584 </span>            :   // Add the non-defining declarations of the outlined function to the replacementMap</a>
<a name="19585"><span class="lineNum">   19585 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* outlinedNondefiningFunctionDeclarationFromOriginalFile = isSgFunctionDeclaration(outlinedFunctionSymbolFromOriginalFile-&gt;get_declaration());</span></a>
<a name="19586"><span class="lineNum">   19586 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* outlinedNondefiningFunctionDeclarationFromOutlinedFile = isSgFunctionDeclaration(decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="19587"><span class="lineNum">   19587 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedNondefiningFunctionDeclarationFromOriginalFile != NULL);</span></a>
<a name="19588"><span class="lineNum">   19588 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedNondefiningFunctionDeclarationFromOutlinedFile != NULL);</span></a>
<a name="19589"><span class="lineNum">   19589 </span><span class="lineNoCov">          0 :      replacementMap.insert(pair&lt;SgNode*,SgNode*&gt;(outlinedNondefiningFunctionDeclarationFromOriginalFile,outlinedNondefiningFunctionDeclarationFromOutlinedFile));</span></a>
<a name="19590"><span class="lineNum">   19590 </span>            : </a>
<a name="19591"><span class="lineNum">   19591 </span>            : </a>
<a name="19592"><span class="lineNum">   19592 </span>            :   // list&lt;SgDeclarationStatement&gt;::iterator i = declarationList.begin();</a>
<a name="19593"><span class="lineNum">   19593 </span>            :   // while (i != declarationList.end())</a>
<a name="19594"><span class="lineNum">   19594 </span>            :   // for (list&lt;SgDeclarationStatement&gt;::iterator i = declarationList.begin(); i != declarationList.end(); i++)</a>
<a name="19595"><span class="lineNum">   19595 </span>            : </a>
<a name="19596"><span class="lineNum">   19596 </span>            : //      cout&lt;&lt;&quot;\n*******************************************\n&quot;&lt;&lt;endl;</a>
<a name="19597"><span class="lineNum">   19597 </span>            : //      cout&lt;&lt;&quot;Inserting dependent decls: count=&quot;&lt;&lt;dependentDeclarationList.size()&lt;&lt;endl;</a>
<a name="19598"><span class="lineNum">   19598 </span><span class="lineNoCov">          0 :      for (size_t i = 0; i &lt; dependentDeclarationList.size(); i++)</span></a>
<a name="19599"><span class="lineNum">   19599 </span>            :         {</a>
<a name="19600"><span class="lineNum">   19600 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* d                   = dependentDeclarationList[i]; // copies of dependent declarations</span></a>
<a name="19601"><span class="lineNum">   19601 </span>            : #if 0</a>
<a name="19602"><span class="lineNum">   19602 </span>            :           SgDeclarationStatement* originalDeclaration = dependentDeclarationList_inOriginalFile[i];</a>
<a name="19603"><span class="lineNum">   19603 </span>            :           printf (&quot;declarationList[%&quot; PRIuPTR &quot;] = %p = %s = %s \n&quot;,i,d,d-&gt;class_name().c_str(),SageInterface::get_name(d).c_str());</a>
<a name="19604"><span class="lineNum">   19604 </span>            :           printf (&quot;originalDeclaration = %p \n&quot;,originalDeclaration);</a>
<a name="19605"><span class="lineNum">   19605 </span>            : </a>
<a name="19606"><span class="lineNum">   19606 </span>            :           d-&gt;get_file_info()-&gt;display(&quot;SageInterface::appendStatementWithDependentDeclaration()&quot;);</a>
<a name="19607"><span class="lineNum">   19607 </span>            : #endif</a>
<a name="19608"><span class="lineNum">   19608 </span>            : </a>
<a name="19609"><span class="lineNum">   19609 </span>            :        // DQ (2/20/2009): Added assertion.</a>
<a name="19610"><span class="lineNum">   19610 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(d-&gt;get_parent() == NULL);</span></a>
<a name="19611"><span class="lineNum">   19611 </span>            : </a>
<a name="19612"><span class="lineNum">   19612 </span>            :        // scope-&gt;append_declaration(d);</a>
<a name="19613"><span class="lineNum">   19613 </span>            :        // scope-&gt;insert_statement (decl, d, /* bool inFront= */ true);</a>
<a name="19614"><span class="lineNum">   19614 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(decl-&gt;get_scope() == scope);</span></a>
<a name="19615"><span class="lineNum">   19615 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(find(scope-&gt;getDeclarationList().begin(),scope-&gt;getDeclarationList().end(),decl) != scope-&gt;getDeclarationList().end());</span></a>
<a name="19616"><span class="lineNum">   19616 </span><span class="lineNoCov">          0 :           scope-&gt;insert_statement (decl, d, /* bool inFront= */ true);</span></a>
<a name="19617"><span class="lineNum">   19617 </span><span class="lineNoCov">          0 :           d-&gt;set_parent (scope);</span></a>
<a name="19618"><span class="lineNum">   19618 </span>            : </a>
<a name="19619"><span class="lineNum">   19619 </span>            : #if 0</a>
<a name="19620"><span class="lineNum">   19620 </span>            :           printf (&quot;Add the required symbol information to the symbol table: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="19621"><span class="lineNum">   19621 </span>            : #endif</a>
<a name="19622"><span class="lineNum">   19622 </span>            : </a>
<a name="19623"><span class="lineNum">   19623 </span>            :        // For whatever type of declaration we add to the global scope in the new separate</a>
<a name="19624"><span class="lineNum">   19624 </span>            :        // file we have to add the required symbol information to the symbol table.</a>
<a name="19625"><span class="lineNum">   19625 </span><span class="lineNoCov">          0 :           switch(d-&gt;variantT())</span></a>
<a name="19626"><span class="lineNum">   19626 </span>            :              {</a>
<a name="19627"><span class="lineNum">   19627 </span><span class="lineNoCov">          0 :                case V_SgClassDeclaration:</span></a>
<a name="19628"><span class="lineNum">   19628 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="19629"><span class="lineNum">   19629 </span><span class="lineNoCov">          0 :                     if ( declarationContainsDependentDeclarations(d,dependentDeclarationList) == true )</span></a>
<a name="19630"><span class="lineNum">   19630 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: This class contains dependent declarations (not implemented) \n&quot;);</span></a>
<a name="19631"><span class="lineNum">   19631 </span>            :                     break;</a>
<a name="19632"><span class="lineNum">   19632 </span>            :                   }</a>
<a name="19633"><span class="lineNum">   19633 </span>            : </a>
<a name="19634"><span class="lineNum">   19634 </span><span class="lineNoCov">          0 :                case V_SgMemberFunctionDeclaration:</span></a>
<a name="19635"><span class="lineNum">   19635 </span><span class="lineNoCov">          0 :                   printf (&quot;Sorry, support for dependent member function declarations not implemented! \n&quot;);</span></a>
<a name="19636"><span class="lineNum">   19636 </span><span class="lineNoCov">          0 :                   ROSE_ABORT();</span></a>
<a name="19637"><span class="lineNum">   19637 </span>            : </a>
<a name="19638"><span class="lineNum">   19638 </span><span class="lineNoCov">          0 :                 case V_SgTemplateInstantiationDecl:</span></a>
<a name="19639"><span class="lineNum">   19639 </span><span class="lineNoCov">          0 :                   printf (&quot;Sorry, not implemented: case SgTemplateInstantiationDecl not handled as dependent declaration \n&quot;);</span></a>
<a name="19640"><span class="lineNum">   19640 </span><span class="lineNoCov">          0 :                   d-&gt;get_file_info()-&gt;display(&quot;Sorry, not implemented: case SgTemplateInstantiationDecl not handled as dependent declaration&quot;);</span></a>
<a name="19641"><span class="lineNum">   19641 </span>            : </a>
<a name="19642"><span class="lineNum">   19642 </span><span class="lineNoCov">          0 :                   printf (&quot;Case of SgTemplateInstantiationDecl not implemented. \n&quot;);</span></a>
<a name="19643"><span class="lineNum">   19643 </span><span class="lineNoCov">          0 :                   ROSE_ABORT();</span></a>
<a name="19644"><span class="lineNum">   19644 </span>            : </a>
<a name="19645"><span class="lineNum">   19645 </span><span class="lineNoCov">          0 :                 case V_SgNamespaceDeclarationStatement:</span></a>
<a name="19646"><span class="lineNum">   19646 </span><span class="lineNoCov">          0 :                   if (declarationContainsDependentDeclarations(d,dependentDeclarationList) == true )</span></a>
<a name="19647"><span class="lineNum">   19647 </span><span class="lineNoCov">          0 :                     printf (&quot;Warning: This namespace contains dependent declarations (not supported) \n&quot;);</span></a>
<a name="19648"><span class="lineNum">   19648 </span>            :                   break;</a>
<a name="19649"><span class="lineNum">   19649 </span>            : </a>
<a name="19650"><span class="lineNum">   19650 </span>            :                case V_SgFunctionDeclaration:</a>
<a name="19651"><span class="lineNum">   19651 </span>            :                case V_SgTypedefDeclaration:</a>
<a name="19652"><span class="lineNum">   19652 </span>            :                case V_SgEnumDeclaration:</a>
<a name="19653"><span class="lineNum">   19653 </span>            :                   break;</a>
<a name="19654"><span class="lineNum">   19654 </span>            : </a>
<a name="19655"><span class="lineNum">   19655 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="19656"><span class="lineNum">   19656 </span><span class="lineNoCov">          0 :                  printf (&quot;default case in SageInterface::appendStatementWithDependentDeclaration() (handling dependentDeclarationList) d = %p = %s \n&quot;,d,d-&gt;class_name().c_str());</span></a>
<a name="19657"><span class="lineNum">   19657 </span><span class="lineNoCov">          0 :                  ROSE_ABORT();</span></a>
<a name="19658"><span class="lineNum">   19658 </span>            :              }</a>
<a name="19659"><span class="lineNum">   19659 </span>            : </a>
<a name="19660"><span class="lineNum">   19660 </span>            : </a>
<a name="19661"><span class="lineNum">   19661 </span>            :        // Collect include directives that are already attached to this dependent declaration.</a>
<a name="19662"><span class="lineNum">   19662 </span><span class="lineNoCov">          0 :           vector&lt;PreprocessingInfo*&gt; cppDirectivesAlreadyAttachedToDependentDeclarations = collectCppDirectives(d);</span></a>
<a name="19663"><span class="lineNum">   19663 </span>            : </a>
<a name="19664"><span class="lineNum">   19664 </span>            : #if 0</a>
<a name="19665"><span class="lineNum">   19665 </span>            :           printf (&quot;directives BEFORE excluding those already present in dependent declarations \n&quot;);</a>
<a name="19666"><span class="lineNum">   19666 </span>            :           outputPreprocessingInfoList(requiredDirectivesList);</a>
<a name="19667"><span class="lineNum">   19667 </span>            : </a>
<a name="19668"><span class="lineNum">   19668 </span>            :           printf (&quot;directives already attached to dependent declarations \n&quot;);</a>
<a name="19669"><span class="lineNum">   19669 </span>            :           outputPreprocessingInfoList(cppDirectivesAlreadyAttachedToDependentDeclarations);</a>
<a name="19670"><span class="lineNum">   19670 </span>            : #endif</a>
<a name="19671"><span class="lineNum">   19671 </span>            : </a>
<a name="19672"><span class="lineNum">   19672 </span>            :        // Remove these include directives from the requiredDirectivesList (to prevent redundant output in the generated file)</a>
<a name="19673"><span class="lineNum">   19673 </span><span class="lineNoCov">          0 :           vector&lt;PreprocessingInfo*&gt;::iterator j = cppDirectivesAlreadyAttachedToDependentDeclarations.begin();</span></a>
<a name="19674"><span class="lineNum">   19674 </span><span class="lineNoCov">          0 :           while ( j != cppDirectivesAlreadyAttachedToDependentDeclarations.end() )</span></a>
<a name="19675"><span class="lineNum">   19675 </span>            :              {</a>
<a name="19676"><span class="lineNum">   19676 </span>            :             // Remove this directive from the requiredDirectivesList (to avoid having them output redundently).</a>
<a name="19677"><span class="lineNum">   19677 </span><span class="lineNoCov">          0 :                vector&lt;PreprocessingInfo*&gt;::iterator entry = find(requiredDirectivesList.begin(),requiredDirectivesList.end(),*j);</span></a>
<a name="19678"><span class="lineNum">   19678 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(entry != requiredDirectivesList.end());</span></a>
<a name="19679"><span class="lineNum">   19679 </span>            : </a>
<a name="19680"><span class="lineNum">   19680 </span><span class="lineNoCov">          0 :                requiredDirectivesList.erase(entry);</span></a>
<a name="19681"><span class="lineNum">   19681 </span>            : </a>
<a name="19682"><span class="lineNum">   19682 </span><span class="lineNoCov">          0 :                j++;</span></a>
<a name="19683"><span class="lineNum">   19683 </span>            :              }</a>
<a name="19684"><span class="lineNum">   19684 </span>            : </a>
<a name="19685"><span class="lineNum">   19685 </span>            : #if 0</a>
<a name="19686"><span class="lineNum">   19686 </span>            :           printf (&quot;directives AFTER excluding those already present in dependent declarations \n&quot;);</a>
<a name="19687"><span class="lineNum">   19687 </span>            :           outputPreprocessingInfoList(requiredDirectivesList);</a>
<a name="19688"><span class="lineNum">   19688 </span>            : #endif</a>
<a name="19689"><span class="lineNum">   19689 </span>            :         }</a>
<a name="19690"><span class="lineNum">   19690 </span>            : </a>
<a name="19691"><span class="lineNum">   19691 </span>            :   // Add a message to the top of the outlined function that has been added</a>
<a name="19692"><span class="lineNum">   19692 </span><span class="lineNoCov">          0 :      addMessageStatement(decl,&quot;/* OUTLINED FUNCTION */&quot;);</span></a>
<a name="19693"><span class="lineNum">   19693 </span>            : </a>
<a name="19694"><span class="lineNum">   19694 </span>            :   // Insert the dependent declarations ahead of the input &quot;decl&quot;.</a>
<a name="19695"><span class="lineNum">   19695 </span><span class="lineNoCov">          0 :      SgStatement* firstStatmentInFile = NULL;</span></a>
<a name="19696"><span class="lineNum">   19696 </span><span class="lineNoCov">          0 :      if (dependentDeclarationList.empty() == true)</span></a>
<a name="19697"><span class="lineNum">   19697 </span>            :         {</a>
<a name="19698"><span class="lineNum">   19698 </span><span class="lineNoCov">          0 :           firstStatmentInFile = decl;</span></a>
<a name="19699"><span class="lineNum">   19699 </span>            :         }</a>
<a name="19700"><span class="lineNum">   19700 </span>            :        else</a>
<a name="19701"><span class="lineNum">   19701 </span>            :         {</a>
<a name="19702"><span class="lineNum">   19702 </span><span class="lineNoCov">          0 :           firstStatmentInFile = dependentDeclarationList[0];</span></a>
<a name="19703"><span class="lineNum">   19703 </span>            :         }</a>
<a name="19704"><span class="lineNum">   19704 </span>            : </a>
<a name="19705"><span class="lineNum">   19705 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstStatmentInFile != NULL);</span></a>
<a name="19706"><span class="lineNum">   19706 </span>            : </a>
<a name="19707"><span class="lineNum">   19707 </span>            :   // Add a message to the top of the dependent declarations that have been added</a>
<a name="19708"><span class="lineNum">   19708 </span><span class="lineNoCov">          0 :      addMessageStatement(firstStatmentInFile,&quot;/* REQUIRED DEPENDENT DECLARATIONS */&quot;);</span></a>
<a name="19709"><span class="lineNum">   19709 </span>            : </a>
<a name="19710"><span class="lineNum">   19710 </span>            :   // DQ (3/6/2009): Added support to permit exclusion of &quot;#include&lt;header.h&gt;&quot; files since they can make it</a>
<a name="19711"><span class="lineNum">   19711 </span>            :   // much more difficult for external tools. Later we will check if there are remaining unsatisfied dependent</a>
<a name="19712"><span class="lineNum">   19712 </span>            :   // declarations (which must be in the header file) so we can automate this step.</a>
<a name="19713"><span class="lineNum">   19713 </span><span class="lineNoCov">          0 :      if (excludeHeaderFiles == false)</span></a>
<a name="19714"><span class="lineNum">   19714 </span>            :         {</a>
<a name="19715"><span class="lineNum">   19715 </span>            :        // Include all the &quot;#include&lt;header.h&gt;&quot; cpp directives obtained from the original file.</a>
<a name="19716"><span class="lineNum">   19716 </span><span class="lineNoCov">          0 :           vector&lt;PreprocessingInfo*&gt;::reverse_iterator j = requiredDirectivesList.rbegin();</span></a>
<a name="19717"><span class="lineNum">   19717 </span><span class="lineNoCov">          0 :           while ( j != requiredDirectivesList.rend() )</span></a>
<a name="19718"><span class="lineNum">   19718 </span>            :              {</a>
<a name="19719"><span class="lineNum">   19719 </span><span class="lineNoCov">          0 :                firstStatmentInFile-&gt;addToAttachedPreprocessingInfo(*j,PreprocessingInfo::before);</span></a>
<a name="19720"><span class="lineNum">   19720 </span><span class="lineNoCov">          0 :                j++;</span></a>
<a name="19721"><span class="lineNum">   19721 </span>            :              }</a>
<a name="19722"><span class="lineNum">   19722 </span>            :         }</a>
<a name="19723"><span class="lineNum">   19723 </span>            : </a>
<a name="19724"><span class="lineNum">   19724 </span>            :   // Add a message to the top of the CPP directives that have been added</a>
<a name="19725"><span class="lineNum">   19725 </span><span class="lineNoCov">          0 :      addMessageStatement(firstStatmentInFile,&quot;/* REQUIRED CPP DIRECTIVES */&quot;);</span></a>
<a name="19726"><span class="lineNum">   19726 </span>            : </a>
<a name="19727"><span class="lineNum">   19727 </span>            :   // ****************************************************************************</a>
<a name="19728"><span class="lineNum">   19728 </span>            :   // ****************  Fixup AST to Reset References To IR nodes  ***************</a>
<a name="19729"><span class="lineNum">   19729 </span>            :   // ****************************************************************************</a>
<a name="19730"><span class="lineNum">   19730 </span>            :   // This traversal of the replacement map modified the AST to reset pointers to subtrees that will be shared.</a>
<a name="19731"><span class="lineNum">   19731 </span>            :   // The whole AST is traversed (using the memory pool traversal) and the data member pointers to IR nodes that</a>
<a name="19732"><span class="lineNum">   19732 </span>            :   // are found in the replacement map are used to lookup the replacement values that are used to reset the</a>
<a name="19733"><span class="lineNum">   19733 </span>            :   // pointers in the AST. As the replacement is computed the pointer values that are marked in the replacement</a>
<a name="19734"><span class="lineNum">   19734 </span>            :   // list for update are added to the intermediateDeleteSet.</a>
<a name="19735"><span class="lineNum">   19735 </span>            : </a>
<a name="19736"><span class="lineNum">   19736 </span><span class="lineNoCov">          0 :      SgSourceFile* outlinedFile = TransformationSupport::getSourceFile(scope);</span></a>
<a name="19737"><span class="lineNum">   19737 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(outlinedFile != NULL);</span></a>
<a name="19738"><span class="lineNum">   19738 </span>            : </a>
<a name="19739"><span class="lineNum">   19739 </span>            :   // This replacement will be done over the entire file (parts of it are redundant with what has already</a>
<a name="19740"><span class="lineNum">   19740 </span>            :   // been done by the AST copy (so this step need not do as much and may be reduced to just operating</a>
<a name="19741"><span class="lineNum">   19741 </span>            :   // on the outlined function, I think).</a>
<a name="19742"><span class="lineNum">   19742 </span>            : #if 0</a>
<a name="19743"><span class="lineNum">   19743 </span>            :      printf (&quot;\n\n************************************************************\n&quot;);</a>
<a name="19744"><span class="lineNum">   19744 </span>            :      printf (&quot;Calling Utils::edgePointerReplacement() \n&quot;);</a>
<a name="19745"><span class="lineNum">   19745 </span>            : #endif</a>
<a name="19746"><span class="lineNum">   19746 </span>            : </a>
<a name="19747"><span class="lineNum">   19747 </span><span class="lineNoCov">          0 :      Rose::AST::Utils::edgePointerReplacement(outlinedFile,replacementMap);</span></a>
<a name="19748"><span class="lineNum">   19748 </span>            : </a>
<a name="19749"><span class="lineNum">   19749 </span>            : #if 0</a>
<a name="19750"><span class="lineNum">   19750 </span>            :      printf (&quot;Calling Utils::edgePointerReplacement(): DONE \n&quot;);</a>
<a name="19751"><span class="lineNum">   19751 </span>            :      printf (&quot;************************************************************\n\n&quot;);</a>
<a name="19752"><span class="lineNum">   19752 </span>            : </a>
<a name="19753"><span class="lineNum">   19753 </span>            :      printf (&quot;\n\n After replacementMapTraversal(): intermediateDeleteSet: \n&quot;);</a>
<a name="19754"><span class="lineNum">   19754 </span>            :      displaySet(intermediateDeleteSet,&quot;After Utils::edgePointerReplacement&quot;);</a>
<a name="19755"><span class="lineNum">   19755 </span>            : #endif</a>
<a name="19756"><span class="lineNum">   19756 </span>            : </a>
<a name="19757"><span class="lineNum">   19757 </span>            :   // Repeated test from above</a>
<a name="19758"><span class="lineNum">   19758 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(dependentDeclarationList.size() &lt;= dependentDeclarationList_inOriginalFile.size());</span></a>
<a name="19759"><span class="lineNum">   19759 </span>            : </a>
<a name="19760"><span class="lineNum">   19760 </span>            : // endif for ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="19761"><span class="lineNum">   19761 </span>            : #endif</a>
<a name="19762"><span class="lineNum">   19762 </span>            : </a>
<a name="19763"><span class="lineNum">   19763 </span>            : #if 0</a>
<a name="19764"><span class="lineNum">   19764 </span>            :   // The replacementMap should include the symbols associated with the dependentDeclarationList</a>
<a name="19765"><span class="lineNum">   19765 </span>            :   // and the outlined function (so dependentDeclarationList.size() + 1).</a>
<a name="19766"><span class="lineNum">   19766 </span>            :      printf (&quot;replacementMap.size() = %&quot; PRIuPTR &quot; dependentDeclarationList.size() = %&quot; PRIuPTR &quot; \n&quot;,replacementMap.size(),dependentDeclarationList.size());</a>
<a name="19767"><span class="lineNum">   19767 </span>            :   // ROSE_ASSERT(replacementMap.size() == dependentDeclarationList.size() + 1);</a>
<a name="19768"><span class="lineNum">   19768 </span>            : #endif</a>
<a name="19769"><span class="lineNum">   19769 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="19770"><span class="lineNum">   19770 </span>            : </a>
<a name="19771"><span class="lineNum">   19771 </span>            : void</a>
<a name="19772"><span class="lineNum">   19772 </span><span class="lineCov">        518 : SageInterface::deleteAST ( SgNode* n )</span></a>
<a name="19773"><span class="lineNum">   19773 </span>            :    {</a>
<a name="19774"><span class="lineNum">   19774 </span>            : //Tan, August/25/2010:       //Re-implement DeleteAST function</a>
<a name="19775"><span class="lineNum">   19775 </span>            : </a>
<a name="19776"><span class="lineNum">   19776 </span>            :         //Use MemoryPoolTraversal to count the number of references to a certain symbol</a>
<a name="19777"><span class="lineNum">   19777 </span>            :         //This class defines the visitors for the MemoryPoolTraversal</a>
<a name="19778"><span class="lineNum">   19778 </span>            : </a>
<a name="19779"><span class="lineNum">   19779 </span><span class="lineCov">        194 :         class ClassicVisitor : public ROSE_VisitorPattern</span></a>
<a name="19780"><span class="lineNum">   19780 </span>            :         {</a>
<a name="19781"><span class="lineNum">   19781 </span>            :                 private:</a>
<a name="19782"><span class="lineNum">   19782 </span>            :                 int SgVariableSymbol_count;</a>
<a name="19783"><span class="lineNum">   19783 </span>            :                 int SgFunctionSymbol_count;</a>
<a name="19784"><span class="lineNum">   19784 </span>            :                 int SgClassDeclaration_count;</a>
<a name="19785"><span class="lineNum">   19785 </span>            :                 int SgTypedefSymbol_count;</a>
<a name="19786"><span class="lineNum">   19786 </span>            :                 int SgMemFuncSymbol_count;</a>
<a name="19787"><span class="lineNum">   19787 </span>            :                 int SgTemplateSymbol_count;</a>
<a name="19788"><span class="lineNum">   19788 </span>            :                 int SgEnumFieldSymbol_count;</a>
<a name="19789"><span class="lineNum">   19789 </span>            : </a>
<a name="19790"><span class="lineNum">   19790 </span>            :                 SgVariableSymbol* SgVariableSymbolPtr;</a>
<a name="19791"><span class="lineNum">   19791 </span>            :                 SgFunctionSymbol* SgFunctionSymbolPtr;</a>
<a name="19792"><span class="lineNum">   19792 </span>            :                 SgClassSymbol * SgClassSymbolPtr;</a>
<a name="19793"><span class="lineNum">   19793 </span>            :                 SgTypedefSymbol * SgTypedefPtr;</a>
<a name="19794"><span class="lineNum">   19794 </span>            :                 SgEnumFieldSymbol * SgEnumFieldSymbolPtr;</a>
<a name="19795"><span class="lineNum">   19795 </span>            :                 SgMemberFunctionSymbol * SgMemFuncSymbolPtr;</a>
<a name="19796"><span class="lineNum">   19796 </span>            :                 SgTemplateSymbol * SgTemplateSymbolPtr;</a>
<a name="19797"><span class="lineNum">   19797 </span>            :                 SgClassDeclaration * class_defining;</a>
<a name="19798"><span class="lineNum">   19798 </span>            :                 SgTemplateDeclaration * template_defining;</a>
<a name="19799"><span class="lineNum">   19799 </span>            :                 SgMemberFunctionDeclaration * memFunc;</a>
<a name="19800"><span class="lineNum">   19800 </span>            :                 SgTypedefDeclaration * typedef_defining;</a>
<a name="19801"><span class="lineNum">   19801 </span>            :                 SgFunctionDeclaration * function_decl;</a>
<a name="19802"><span class="lineNum">   19802 </span>            :                 SgTemplateInstantiationDecl * templateInstantiate_defining;</a>
<a name="19803"><span class="lineNum">   19803 </span>            : </a>
<a name="19804"><span class="lineNum">   19804 </span>            :                 public:</a>
<a name="19805"><span class="lineNum">   19805 </span><span class="lineCov">        161 :                 ClassicVisitor(SgVariableSymbol* symbol){</span></a>
<a name="19806"><span class="lineNum">   19806 </span><span class="lineCov">        161 :                         SgVariableSymbol_count = 0;</span></a>
<a name="19807"><span class="lineNum">   19807 </span><span class="lineCov">        161 :                         SgVariableSymbolPtr = symbol;</span></a>
<a name="19808"><span class="lineNum">   19808 </span><span class="lineCov">        161 :                         SgFunctionSymbolPtr =NULL;</span></a>
<a name="19809"><span class="lineNum">   19809 </span><span class="lineCov">        161 :                         SgClassSymbolPtr =NULL;</span></a>
<a name="19810"><span class="lineNum">   19810 </span><span class="lineCov">        161 :                         SgTypedefPtr = NULL;</span></a>
<a name="19811"><span class="lineNum">   19811 </span><span class="lineCov">        161 :                         SgMemFuncSymbolPtr =NULL;</span></a>
<a name="19812"><span class="lineNum">   19812 </span><span class="lineCov">        161 :                         class_defining = NULL;</span></a>
<a name="19813"><span class="lineNum">   19813 </span><span class="lineCov">        161 :                         memFunc =NULL;</span></a>
<a name="19814"><span class="lineNum">   19814 </span><span class="lineCov">        161 :                         typedef_defining =NULL;</span></a>
<a name="19815"><span class="lineNum">   19815 </span><span class="lineCov">        161 :                         function_decl = NULL;</span></a>
<a name="19816"><span class="lineNum">   19816 </span><span class="lineCov">        161 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19817"><span class="lineNum">   19817 </span><span class="lineCov">        161 :                         template_defining = NULL;</span></a>
<a name="19818"><span class="lineNum">   19818 </span><span class="lineCov">        161 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19819"><span class="lineNum">   19819 </span><span class="lineCov">        161 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19820"><span class="lineNum">   19820 </span>            :                 }</a>
<a name="19821"><span class="lineNum">   19821 </span>            : </a>
<a name="19822"><span class="lineNum">   19822 </span><span class="lineCov">         33 :                 ClassicVisitor(SgFunctionSymbol* symbol){</span></a>
<a name="19823"><span class="lineNum">   19823 </span><span class="lineCov">         33 :                         SgFunctionSymbol_count = 0;</span></a>
<a name="19824"><span class="lineNum">   19824 </span><span class="lineCov">         33 :                         SgFunctionSymbolPtr = symbol;</span></a>
<a name="19825"><span class="lineNum">   19825 </span>            : </a>
<a name="19826"><span class="lineNum">   19826 </span>            :                      // DQ (5/2/2013): Added to fix test2013_141.C.</a>
<a name="19827"><span class="lineNum">   19827 </span><span class="lineCov">         33 :                         SgMemFuncSymbol_count =0;</span></a>
<a name="19828"><span class="lineNum">   19828 </span>            : </a>
<a name="19829"><span class="lineNum">   19829 </span><span class="lineCov">         33 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19830"><span class="lineNum">   19830 </span><span class="lineCov">         33 :                         SgClassSymbolPtr =NULL;</span></a>
<a name="19831"><span class="lineNum">   19831 </span><span class="lineCov">         33 :                         SgTypedefPtr = NULL;</span></a>
<a name="19832"><span class="lineNum">   19832 </span><span class="lineCov">         33 :                         SgMemFuncSymbolPtr =NULL;</span></a>
<a name="19833"><span class="lineNum">   19833 </span><span class="lineCov">         33 :                         class_defining = NULL;</span></a>
<a name="19834"><span class="lineNum">   19834 </span><span class="lineCov">         33 :                         memFunc =NULL;</span></a>
<a name="19835"><span class="lineNum">   19835 </span><span class="lineCov">         33 :                         typedef_defining =NULL;</span></a>
<a name="19836"><span class="lineNum">   19836 </span><span class="lineCov">         33 :                         function_decl = NULL;</span></a>
<a name="19837"><span class="lineNum">   19837 </span><span class="lineCov">         33 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19838"><span class="lineNum">   19838 </span><span class="lineCov">         33 :                         template_defining = NULL;</span></a>
<a name="19839"><span class="lineNum">   19839 </span><span class="lineCov">         33 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19840"><span class="lineNum">   19840 </span><span class="lineCov">         33 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19841"><span class="lineNum">   19841 </span>            :                 }</a>
<a name="19842"><span class="lineNum">   19842 </span>            : </a>
<a name="19843"><span class="lineNum">   19843 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgClassSymbol* symbol){</span></a>
<a name="19844"><span class="lineNum">   19844 </span><span class="lineNoCov">          0 :                         SgClassDeclaration_count = 0;</span></a>
<a name="19845"><span class="lineNum">   19845 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = symbol;</span></a>
<a name="19846"><span class="lineNum">   19846 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19847"><span class="lineNum">   19847 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19848"><span class="lineNum">   19848 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19849"><span class="lineNum">   19849 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr =NULL;</span></a>
<a name="19850"><span class="lineNum">   19850 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19851"><span class="lineNum">   19851 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19852"><span class="lineNum">   19852 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19853"><span class="lineNum">   19853 </span><span class="lineNoCov">          0 :                         function_decl = NULL;</span></a>
<a name="19854"><span class="lineNum">   19854 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19855"><span class="lineNum">   19855 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19856"><span class="lineNum">   19856 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19857"><span class="lineNum">   19857 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19858"><span class="lineNum">   19858 </span>            :                 }</a>
<a name="19859"><span class="lineNum">   19859 </span>            : </a>
<a name="19860"><span class="lineNum">   19860 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgTypedefSymbol* symbol){</span></a>
<a name="19861"><span class="lineNum">   19861 </span><span class="lineNoCov">          0 :                         SgTypedefSymbol_count =0;</span></a>
<a name="19862"><span class="lineNum">   19862 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = symbol;</span></a>
<a name="19863"><span class="lineNum">   19863 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19864"><span class="lineNum">   19864 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19865"><span class="lineNum">   19865 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19866"><span class="lineNum">   19866 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr =NULL;</span></a>
<a name="19867"><span class="lineNum">   19867 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19868"><span class="lineNum">   19868 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19869"><span class="lineNum">   19869 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19870"><span class="lineNum">   19870 </span><span class="lineNoCov">          0 :                         function_decl = NULL;</span></a>
<a name="19871"><span class="lineNum">   19871 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19872"><span class="lineNum">   19872 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19873"><span class="lineNum">   19873 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19874"><span class="lineNum">   19874 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19875"><span class="lineNum">   19875 </span>            :                 }</a>
<a name="19876"><span class="lineNum">   19876 </span>            : </a>
<a name="19877"><span class="lineNum">   19877 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgMemberFunctionSymbol* symbol){</span></a>
<a name="19878"><span class="lineNum">   19878 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = symbol;</span></a>
<a name="19879"><span class="lineNum">   19879 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbol_count =0;</span></a>
<a name="19880"><span class="lineNum">   19880 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19881"><span class="lineNum">   19881 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19882"><span class="lineNum">   19882 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19883"><span class="lineNum">   19883 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19884"><span class="lineNum">   19884 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19885"><span class="lineNum">   19885 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19886"><span class="lineNum">   19886 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19887"><span class="lineNum">   19887 </span><span class="lineNoCov">          0 :                         function_decl = NULL;</span></a>
<a name="19888"><span class="lineNum">   19888 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19889"><span class="lineNum">   19889 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19890"><span class="lineNum">   19890 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19891"><span class="lineNum">   19891 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19892"><span class="lineNum">   19892 </span>            :                 }</a>
<a name="19893"><span class="lineNum">   19893 </span>            : </a>
<a name="19894"><span class="lineNum">   19894 </span>            :                 ClassicVisitor(SgTemplateSymbol* symbol){</a>
<a name="19895"><span class="lineNum">   19895 </span>            :                         SgTemplateSymbolPtr = symbol;</a>
<a name="19896"><span class="lineNum">   19896 </span>            :                         SgTemplateSymbol_count =0;</a>
<a name="19897"><span class="lineNum">   19897 </span>            :                         SgMemFuncSymbolPtr = NULL;</a>
<a name="19898"><span class="lineNum">   19898 </span>            :                         SgTypedefPtr = NULL;</a>
<a name="19899"><span class="lineNum">   19899 </span>            :                         SgClassSymbolPtr = NULL;</a>
<a name="19900"><span class="lineNum">   19900 </span>            :                         SgFunctionSymbolPtr = NULL;</a>
<a name="19901"><span class="lineNum">   19901 </span>            :                         SgVariableSymbolPtr = NULL;</a>
<a name="19902"><span class="lineNum">   19902 </span>            :                         class_defining = NULL;</a>
<a name="19903"><span class="lineNum">   19903 </span>            :                         memFunc =NULL;</a>
<a name="19904"><span class="lineNum">   19904 </span>            :                         typedef_defining =NULL;</a>
<a name="19905"><span class="lineNum">   19905 </span>            :                         function_decl = NULL;</a>
<a name="19906"><span class="lineNum">   19906 </span>            :                         template_defining = NULL;</a>
<a name="19907"><span class="lineNum">   19907 </span>            :                         SgEnumFieldSymbolPtr = NULL;</a>
<a name="19908"><span class="lineNum">   19908 </span>            :                         templateInstantiate_defining =NULL;</a>
<a name="19909"><span class="lineNum">   19909 </span>            :                 }</a>
<a name="19910"><span class="lineNum">   19910 </span>            : </a>
<a name="19911"><span class="lineNum">   19911 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgEnumFieldSymbol* symbol){</span></a>
<a name="19912"><span class="lineNum">   19912 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = symbol;</span></a>
<a name="19913"><span class="lineNum">   19913 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbol_count =0;</span></a>
<a name="19914"><span class="lineNum">   19914 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19915"><span class="lineNum">   19915 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = NULL;</span></a>
<a name="19916"><span class="lineNum">   19916 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19917"><span class="lineNum">   19917 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19918"><span class="lineNum">   19918 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19919"><span class="lineNum">   19919 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19920"><span class="lineNum">   19920 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19921"><span class="lineNum">   19921 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19922"><span class="lineNum">   19922 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19923"><span class="lineNum">   19923 </span><span class="lineNoCov">          0 :                         function_decl = NULL;</span></a>
<a name="19924"><span class="lineNum">   19924 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19925"><span class="lineNum">   19925 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19926"><span class="lineNum">   19926 </span>            :                 }</a>
<a name="19927"><span class="lineNum">   19927 </span>            : </a>
<a name="19928"><span class="lineNum">   19928 </span>            : </a>
<a name="19929"><span class="lineNum">   19929 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgClassDeclaration* node){</span></a>
<a name="19930"><span class="lineNum">   19930 </span><span class="lineNoCov">          0 :                         class_defining = node;</span></a>
<a name="19931"><span class="lineNum">   19931 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = NULL;</span></a>
<a name="19932"><span class="lineNum">   19932 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19933"><span class="lineNum">   19933 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19934"><span class="lineNum">   19934 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19935"><span class="lineNum">   19935 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19936"><span class="lineNum">   19936 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19937"><span class="lineNum">   19937 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19938"><span class="lineNum">   19938 </span><span class="lineNoCov">          0 :                         function_decl = NULL;</span></a>
<a name="19939"><span class="lineNum">   19939 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19940"><span class="lineNum">   19940 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19941"><span class="lineNum">   19941 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19942"><span class="lineNum">   19942 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19943"><span class="lineNum">   19943 </span>            :                 }</a>
<a name="19944"><span class="lineNum">   19944 </span>            : </a>
<a name="19945"><span class="lineNum">   19945 </span>            :                 ClassicVisitor(SgTemplateDeclaration* node){</a>
<a name="19946"><span class="lineNum">   19946 </span>            :                         template_defining = node;</a>
<a name="19947"><span class="lineNum">   19947 </span>            :                         class_defining = NULL;</a>
<a name="19948"><span class="lineNum">   19948 </span>            :                         SgMemFuncSymbolPtr = NULL;</a>
<a name="19949"><span class="lineNum">   19949 </span>            :                         SgTypedefPtr = NULL;</a>
<a name="19950"><span class="lineNum">   19950 </span>            :                         SgClassSymbolPtr = NULL;</a>
<a name="19951"><span class="lineNum">   19951 </span>            :                         SgFunctionSymbolPtr = NULL;</a>
<a name="19952"><span class="lineNum">   19952 </span>            :                         SgVariableSymbolPtr = NULL;</a>
<a name="19953"><span class="lineNum">   19953 </span>            :                         memFunc =NULL;</a>
<a name="19954"><span class="lineNum">   19954 </span>            :                         typedef_defining =NULL;</a>
<a name="19955"><span class="lineNum">   19955 </span>            :                         function_decl = NULL;</a>
<a name="19956"><span class="lineNum">   19956 </span>            :                         SgTemplateSymbolPtr = NULL;</a>
<a name="19957"><span class="lineNum">   19957 </span>            :                         SgEnumFieldSymbolPtr = NULL;</a>
<a name="19958"><span class="lineNum">   19958 </span>            :                         templateInstantiate_defining =NULL;</a>
<a name="19959"><span class="lineNum">   19959 </span>            :                 }</a>
<a name="19960"><span class="lineNum">   19960 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgFunctionDeclaration* node){</span></a>
<a name="19961"><span class="lineNum">   19961 </span><span class="lineNoCov">          0 :                         function_decl =node;</span></a>
<a name="19962"><span class="lineNum">   19962 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19963"><span class="lineNum">   19963 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = NULL;</span></a>
<a name="19964"><span class="lineNum">   19964 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19965"><span class="lineNum">   19965 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19966"><span class="lineNum">   19966 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19967"><span class="lineNum">   19967 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19968"><span class="lineNum">   19968 </span><span class="lineNoCov">          0 :                         memFunc =NULL;</span></a>
<a name="19969"><span class="lineNum">   19969 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19970"><span class="lineNum">   19970 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19971"><span class="lineNum">   19971 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19972"><span class="lineNum">   19972 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19973"><span class="lineNum">   19973 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19974"><span class="lineNum">   19974 </span>            :                 }</a>
<a name="19975"><span class="lineNum">   19975 </span>            : </a>
<a name="19976"><span class="lineNum">   19976 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgMemberFunctionDeclaration* node){</span></a>
<a name="19977"><span class="lineNum">   19977 </span><span class="lineNoCov">          0 :                         memFunc = node;</span></a>
<a name="19978"><span class="lineNum">   19978 </span><span class="lineNoCov">          0 :                         function_decl =NULL;</span></a>
<a name="19979"><span class="lineNum">   19979 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19980"><span class="lineNum">   19980 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = NULL;</span></a>
<a name="19981"><span class="lineNum">   19981 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19982"><span class="lineNum">   19982 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="19983"><span class="lineNum">   19983 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="19984"><span class="lineNum">   19984 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="19985"><span class="lineNum">   19985 </span><span class="lineNoCov">          0 :                         typedef_defining =NULL;</span></a>
<a name="19986"><span class="lineNum">   19986 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="19987"><span class="lineNum">   19987 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="19988"><span class="lineNum">   19988 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="19989"><span class="lineNum">   19989 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="19990"><span class="lineNum">   19990 </span>            :                 }</a>
<a name="19991"><span class="lineNum">   19991 </span>            : </a>
<a name="19992"><span class="lineNum">   19992 </span><span class="lineNoCov">          0 :                 ClassicVisitor(SgTypedefDeclaration* node){</span></a>
<a name="19993"><span class="lineNum">   19993 </span><span class="lineNoCov">          0 :                         typedef_defining = node;</span></a>
<a name="19994"><span class="lineNum">   19994 </span><span class="lineNoCov">          0 :                         memFunc = NULL;</span></a>
<a name="19995"><span class="lineNum">   19995 </span><span class="lineNoCov">          0 :                         function_decl =NULL;</span></a>
<a name="19996"><span class="lineNum">   19996 </span><span class="lineNoCov">          0 :                         class_defining = NULL;</span></a>
<a name="19997"><span class="lineNum">   19997 </span><span class="lineNoCov">          0 :                         SgMemFuncSymbolPtr = NULL;</span></a>
<a name="19998"><span class="lineNum">   19998 </span><span class="lineNoCov">          0 :                         SgTypedefPtr = NULL;</span></a>
<a name="19999"><span class="lineNum">   19999 </span><span class="lineNoCov">          0 :                         SgClassSymbolPtr = NULL;</span></a>
<a name="20000"><span class="lineNum">   20000 </span><span class="lineNoCov">          0 :                         SgFunctionSymbolPtr = NULL;</span></a>
<a name="20001"><span class="lineNum">   20001 </span><span class="lineNoCov">          0 :                         SgVariableSymbolPtr = NULL;</span></a>
<a name="20002"><span class="lineNum">   20002 </span><span class="lineNoCov">          0 :                         SgTemplateSymbolPtr = NULL;</span></a>
<a name="20003"><span class="lineNum">   20003 </span><span class="lineNoCov">          0 :                         template_defining = NULL;</span></a>
<a name="20004"><span class="lineNum">   20004 </span><span class="lineNoCov">          0 :                         SgEnumFieldSymbolPtr = NULL;</span></a>
<a name="20005"><span class="lineNum">   20005 </span><span class="lineNoCov">          0 :                         templateInstantiate_defining =NULL;</span></a>
<a name="20006"><span class="lineNum">   20006 </span>            :                 }</a>
<a name="20007"><span class="lineNum">   20007 </span>            : </a>
<a name="20008"><span class="lineNum">   20008 </span>            :                 ClassicVisitor(SgTemplateInstantiationDecl* node){</a>
<a name="20009"><span class="lineNum">   20009 </span>            :                         templateInstantiate_defining =node;</a>
<a name="20010"><span class="lineNum">   20010 </span>            :                         typedef_defining = NULL;</a>
<a name="20011"><span class="lineNum">   20011 </span>            :                         memFunc = NULL;</a>
<a name="20012"><span class="lineNum">   20012 </span>            :                         function_decl =NULL;</a>
<a name="20013"><span class="lineNum">   20013 </span>            :                         class_defining = NULL;</a>
<a name="20014"><span class="lineNum">   20014 </span>            :                         SgMemFuncSymbolPtr = NULL;</a>
<a name="20015"><span class="lineNum">   20015 </span>            :                         SgTypedefPtr = NULL;</a>
<a name="20016"><span class="lineNum">   20016 </span>            :                         SgClassSymbolPtr = NULL;</a>
<a name="20017"><span class="lineNum">   20017 </span>            :                         SgFunctionSymbolPtr = NULL;</a>
<a name="20018"><span class="lineNum">   20018 </span>            :                         SgVariableSymbolPtr = NULL;</a>
<a name="20019"><span class="lineNum">   20019 </span>            :                         SgTemplateSymbolPtr = NULL;</a>
<a name="20020"><span class="lineNum">   20020 </span>            :                         template_defining = NULL;</a>
<a name="20021"><span class="lineNum">   20021 </span>            :                         SgEnumFieldSymbolPtr = NULL;</a>
<a name="20022"><span class="lineNum">   20022 </span>            :                 }</a>
<a name="20023"><span class="lineNum">   20023 </span>            : </a>
<a name="20024"><span class="lineNum">   20024 </span>            : </a>
<a name="20025"><span class="lineNum">   20025 </span>            :         // SgVariableSymbol and SgEnumFieldSymbol</a>
<a name="20026"><span class="lineNum">   20026 </span><span class="lineCov">    6131590 :                 void visit(SgInitializedName* node)</span></a>
<a name="20027"><span class="lineNum">   20027 </span>            :                    {</a>
<a name="20028"><span class="lineNum">   20028 </span><span class="lineCov">    6131590 :                      if(SgVariableSymbolPtr !=NULL)</span></a>
<a name="20029"><span class="lineNum">   20029 </span>            :                         {</a>
<a name="20030"><span class="lineNum">   20030 </span><span class="lineCov">    4943860 :                           if(node-&gt;get_scope()!=NULL)</span></a>
<a name="20031"><span class="lineNum">   20031 </span>            :                              {</a>
<a name="20032"><span class="lineNum">   20032 </span>            :                             // DQ (5/21/2013): We want to restrict access to the symbol table.</a>
<a name="20033"><span class="lineNum">   20033 </span><span class="lineCov">    4943860 :                                if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20034"><span class="lineNum">   20034 </span>            :                                   {</a>
<a name="20035"><span class="lineNum">   20035 </span><span class="lineCov">    4943860 :                                     SgSymbol* s = node-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20036"><span class="lineNum">   20036 </span><span class="lineCov">    4943860 :                                     if (isSgVariableSymbol(s) == SgVariableSymbolPtr) SgVariableSymbol_count++;</span></a>
<a name="20037"><span class="lineNum">   20037 </span>            :                                   }</a>
<a name="20038"><span class="lineNum">   20038 </span>            :                              }</a>
<a name="20039"><span class="lineNum">   20039 </span>            :                         }</a>
<a name="20040"><span class="lineNum">   20040 </span>            : </a>
<a name="20041"><span class="lineNum">   20041 </span><span class="lineCov">    6131590 :                      if(SgEnumFieldSymbolPtr !=NULL)</span></a>
<a name="20042"><span class="lineNum">   20042 </span>            :                         {</a>
<a name="20043"><span class="lineNum">   20043 </span><span class="lineNoCov">          0 :                           if(node-&gt;get_scope()!=NULL)</span></a>
<a name="20044"><span class="lineNum">   20044 </span>            :                              {</a>
<a name="20045"><span class="lineNum">   20045 </span>            :                             // DQ (5/21/2013): We want to restrict access to the symbol table.</a>
<a name="20046"><span class="lineNum">   20046 </span><span class="lineNoCov">          0 :                                if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20047"><span class="lineNum">   20047 </span>            :                                   {</a>
<a name="20048"><span class="lineNum">   20048 </span><span class="lineNoCov">          0 :                                     SgSymbol* s = node-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20049"><span class="lineNum">   20049 </span><span class="lineNoCov">          0 :                                     if (isSgEnumFieldSymbol(s) == SgEnumFieldSymbolPtr) SgEnumFieldSymbol_count++;</span></a>
<a name="20050"><span class="lineNum">   20050 </span>            :                                   }</a>
<a name="20051"><span class="lineNum">   20051 </span>            :                              }</a>
<a name="20052"><span class="lineNum">   20052 </span>            :                         }</a>
<a name="20053"><span class="lineNum">   20053 </span><span class="lineCov">    6131590 :                    }</span></a>
<a name="20054"><span class="lineNum">   20054 </span>            : </a>
<a name="20055"><span class="lineNum">   20055 </span><span class="lineCov">     924234 :                 void visit(SgVarRefExp* node)</span></a>
<a name="20056"><span class="lineNum">   20056 </span>            :                 {</a>
<a name="20057"><span class="lineNum">   20057 </span><span class="lineCov">     924234 :                         if(SgVariableSymbolPtr !=NULL){</span></a>
<a name="20058"><span class="lineNum">   20058 </span><span class="lineCov">     710073 :                                 SgVariableSymbol* s = node-&gt;get_symbol();</span></a>
<a name="20059"><span class="lineNum">   20059 </span><span class="lineCov">     710073 :                                 if (s == SgVariableSymbolPtr) SgVariableSymbol_count++;</span></a>
<a name="20060"><span class="lineNum">   20060 </span>            :                         }</a>
<a name="20061"><span class="lineNum">   20061 </span><span class="lineCov">     924234 :                 }</span></a>
<a name="20062"><span class="lineNum">   20062 </span>            : </a>
<a name="20063"><span class="lineNum">   20063 </span><span class="lineCov">        161 :                 int get_num_variable_pointers(){return SgVariableSymbol_count;}</span></a>
<a name="20064"><span class="lineNum">   20064 </span>            : </a>
<a name="20065"><span class="lineNum">   20065 </span><span class="lineNoCov">          0 :                 int get_num_EnumField_pointers(){return SgEnumFieldSymbol_count;}</span></a>
<a name="20066"><span class="lineNum">   20066 </span>            : </a>
<a name="20067"><span class="lineNum">   20067 </span>            : </a>
<a name="20068"><span class="lineNum">   20068 </span>            :         // SgFunctionSymbol</a>
<a name="20069"><span class="lineNum">   20069 </span><span class="lineCov">     824638 :                 void visit(SgFunctionDeclaration* node)         {</span></a>
<a name="20070"><span class="lineNum">   20070 </span><span class="lineCov">     824638 :                         if(SgFunctionSymbolPtr !=NULL){</span></a>
<a name="20071"><span class="lineNum">   20071 </span><span class="lineCov">     149330 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20072"><span class="lineNum">   20072 </span>            :                                    // DQ (5/21/2013): We want to restrict access to the symbol table.</a>
<a name="20073"><span class="lineNum">   20073 </span><span class="lineCov">     149330 :                                       if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20074"><span class="lineNum">   20074 </span>            :                                         {</a>
<a name="20075"><span class="lineNum">   20075 </span><span class="lineCov">     149330 :                                                 SgSymbol* s = ((SgFunctionDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20076"><span class="lineNum">   20076 </span><span class="lineCov">     149330 :                                                 if ((SgFunctionSymbol *)s == SgFunctionSymbolPtr) SgFunctionSymbol_count++;</span></a>
<a name="20077"><span class="lineNum">   20077 </span>            :                                         }</a>
<a name="20078"><span class="lineNum">   20078 </span>            :                                 }</a>
<a name="20079"><span class="lineNum">   20079 </span>            :                         }</a>
<a name="20080"><span class="lineNum">   20080 </span>            : #if 0</a>
<a name="20081"><span class="lineNum">   20081 </span>            :                         if(function_decl!=NULL){</a>
<a name="20082"><span class="lineNum">   20082 </span>            :                                 if(node-&gt;get_symbol_from_symbol_table() == NULL){</a>
<a name="20083"><span class="lineNum">   20083 </span>            :                                         SgDeclarationStatement * define = ((SgDeclarationStatement*)node)-&gt;get_definingDeclaration();</a>
<a name="20084"><span class="lineNum">   20084 </span>            :                                         SgDeclarationStatement * first_nondefine = ((SgDeclarationStatement*)node)-&gt;get_firstNondefiningDeclaration();</a>
<a name="20085"><span class="lineNum">   20085 </span>            :                                         if(node!=function_decl &amp;&amp; (define==function_decl || first_nondefine==function_decl)) delete node;</a>
<a name="20086"><span class="lineNum">   20086 </span>            :                                 }</a>
<a name="20087"><span class="lineNum">   20087 </span>            :                         }</a>
<a name="20088"><span class="lineNum">   20088 </span>            : #endif</a>
<a name="20089"><span class="lineNum">   20089 </span><span class="lineCov">     824638 :                 }</span></a>
<a name="20090"><span class="lineNum">   20090 </span>            : </a>
<a name="20091"><span class="lineNum">   20091 </span><span class="lineCov">      84885 :                 void visit(SgFunctionRefExp* node)</span></a>
<a name="20092"><span class="lineNum">   20092 </span>            :                 {</a>
<a name="20093"><span class="lineNum">   20093 </span>            : #if 0</a>
<a name="20094"><span class="lineNum">   20094 </span>            :                         printf (&quot;In visit(SgFunctionRefExp* node): SgFunctionSymbolPtr = %p \n&quot;,SgFunctionSymbolPtr);</a>
<a name="20095"><span class="lineNum">   20095 </span>            : #endif</a>
<a name="20096"><span class="lineNum">   20096 </span><span class="lineCov">      84885 :                         if (SgFunctionSymbolPtr !=NULL)</span></a>
<a name="20097"><span class="lineNum">   20097 </span>            :                         {</a>
<a name="20098"><span class="lineNum">   20098 </span><span class="lineCov">      19740 :                                 SgFunctionSymbol* s = node-&gt;get_symbol_i();</span></a>
<a name="20099"><span class="lineNum">   20099 </span><span class="lineCov">      19740 :                                 if (isSgFunctionSymbol(s) == SgFunctionSymbolPtr)</span></a>
<a name="20100"><span class="lineNum">   20100 </span>            :                                 {</a>
<a name="20101"><span class="lineNum">   20101 </span><span class="lineCov">        242 :                                   SgFunctionSymbol_count++;</span></a>
<a name="20102"><span class="lineNum">   20102 </span>            : #if 0</a>
<a name="20103"><span class="lineNum">   20103 </span>            :                                   printf (&quot;Increment SgFunctionSymbol_count = %d \n&quot;,SgFunctionSymbol_count);</a>
<a name="20104"><span class="lineNum">   20104 </span>            : #endif</a>
<a name="20105"><span class="lineNum">   20105 </span>            :                                 }</a>
<a name="20106"><span class="lineNum">   20106 </span>            :                         }</a>
<a name="20107"><span class="lineNum">   20107 </span><span class="lineCov">      84885 :                 }</span></a>
<a name="20108"><span class="lineNum">   20108 </span>            : </a>
<a name="20109"><span class="lineNum">   20109 </span>            :              // DQ (5/2/2013): Added support for SgMemberFunctionRefExp which is not derived from SgFunctionRefExp.</a>
<a name="20110"><span class="lineNum">   20110 </span><span class="lineCov">      76152 :                 void visit(SgMemberFunctionRefExp* node)</span></a>
<a name="20111"><span class="lineNum">   20111 </span>            :                 {</a>
<a name="20112"><span class="lineNum">   20112 </span>            : #if 0</a>
<a name="20113"><span class="lineNum">   20113 </span>            :                         printf (&quot;In visit(SgMemberFunctionRefExp* node): SgFunctionSymbolPtr = %p \n&quot;,SgFunctionSymbolPtr);</a>
<a name="20114"><span class="lineNum">   20114 </span>            : #endif</a>
<a name="20115"><span class="lineNum">   20115 </span><span class="lineCov">      76152 :                         if (SgFunctionSymbolPtr !=NULL)</span></a>
<a name="20116"><span class="lineNum">   20116 </span>            :                         {</a>
<a name="20117"><span class="lineNum">   20117 </span><span class="lineCov">      17744 :                                 SgFunctionSymbol* s = node-&gt;get_symbol_i();</span></a>
<a name="20118"><span class="lineNum">   20118 </span><span class="lineCov">      17744 :                                 if (isSgFunctionSymbol(s) == SgFunctionSymbolPtr)</span></a>
<a name="20119"><span class="lineNum">   20119 </span>            :                                 {</a>
<a name="20120"><span class="lineNum">   20120 </span><span class="lineNoCov">          0 :                                   SgFunctionSymbol_count++;</span></a>
<a name="20121"><span class="lineNum">   20121 </span>            : #if 0</a>
<a name="20122"><span class="lineNum">   20122 </span>            :                                   printf (&quot;Increment SgFunctionSymbol_count = %d \n&quot;,SgFunctionSymbol_count);</a>
<a name="20123"><span class="lineNum">   20123 </span>            : #endif</a>
<a name="20124"><span class="lineNum">   20124 </span>            :                                 }</a>
<a name="20125"><span class="lineNum">   20125 </span>            :                         }</a>
<a name="20126"><span class="lineNum">   20126 </span><span class="lineCov">      76152 :                 }</span></a>
<a name="20127"><span class="lineNum">   20127 </span>            : </a>
<a name="20128"><span class="lineNum">   20128 </span><span class="lineNoCov">          0 :                 void visit(SgUserDefinedBinaryOp* node)</span></a>
<a name="20129"><span class="lineNum">   20129 </span>            :                 {</a>
<a name="20130"><span class="lineNum">   20130 </span><span class="lineNoCov">          0 :                         if (SgFunctionSymbolPtr !=NULL){</span></a>
<a name="20131"><span class="lineNum">   20131 </span><span class="lineNoCov">          0 :                                 SgFunctionSymbol* s = node-&gt;get_symbol();</span></a>
<a name="20132"><span class="lineNum">   20132 </span><span class="lineNoCov">          0 :                                 if (isSgFunctionSymbol(s) == SgFunctionSymbolPtr) SgFunctionSymbol_count++;</span></a>
<a name="20133"><span class="lineNum">   20133 </span>            :                         }</a>
<a name="20134"><span class="lineNum">   20134 </span><span class="lineNoCov">          0 :                 }</span></a>
<a name="20135"><span class="lineNum">   20135 </span>            : </a>
<a name="20136"><span class="lineNum">   20136 </span><span class="lineCov">         33 :                 int get_num_Function_pointers(){return SgFunctionSymbol_count;}</span></a>
<a name="20137"><span class="lineNum">   20137 </span>            : </a>
<a name="20138"><span class="lineNum">   20138 </span>            :         // SgClassSymbol</a>
<a name="20139"><span class="lineNum">   20139 </span><span class="lineCov">      48819 :                 void visit(SgClassDeclaration* node)</span></a>
<a name="20140"><span class="lineNum">   20140 </span>            :                 {</a>
<a name="20141"><span class="lineNum">   20141 </span><span class="lineCov">      48819 :                         if(SgClassSymbolPtr !=NULL){</span></a>
<a name="20142"><span class="lineNum">   20142 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20143"><span class="lineNum">   20143 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20144"><span class="lineNum">   20144 </span>            :                                         {</a>
<a name="20145"><span class="lineNum">   20145 </span><span class="lineNoCov">          0 :                                                 SgSymbol* s = node-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20146"><span class="lineNum">   20146 </span><span class="lineNoCov">          0 :                                                 if (isSgClassSymbol(s) == SgClassSymbolPtr) SgClassDeclaration_count++;</span></a>
<a name="20147"><span class="lineNum">   20147 </span>            :                                         }</a>
<a name="20148"><span class="lineNum">   20148 </span>            :                                 }</a>
<a name="20149"><span class="lineNum">   20149 </span>            :                         }</a>
<a name="20150"><span class="lineNum">   20150 </span>            : </a>
<a name="20151"><span class="lineNum">   20151 </span><span class="lineCov">      48819 :                         if(class_defining!=NULL) {</span></a>
<a name="20152"><span class="lineNum">   20152 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_symbol_from_symbol_table() == NULL){</span></a>
<a name="20153"><span class="lineNum">   20153 </span><span class="lineNoCov">          0 :                                         SgDeclarationStatement * class_decl = ((SgDeclarationStatement*)node)-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="20154"><span class="lineNum">   20154 </span><span class="lineNoCov">          0 :                                         SgDeclarationStatement * class_decl1 = ((SgDeclarationStatement*)node)-&gt;get_definingDeclaration();</span></a>
<a name="20155"><span class="lineNum">   20155 </span><span class="lineNoCov">          0 :                                         if((class_decl==class_defining||class_decl1==class_defining) &amp;&amp; node!=class_defining )</span></a>
<a name="20156"><span class="lineNum">   20156 </span><span class="lineNoCov">          0 :                                                 delete node;</span></a>
<a name="20157"><span class="lineNum">   20157 </span>            :                                 }</a>
<a name="20158"><span class="lineNum">   20158 </span>            :                         }</a>
<a name="20159"><span class="lineNum">   20159 </span><span class="lineCov">      48819 :                 }</span></a>
<a name="20160"><span class="lineNum">   20160 </span>            : </a>
<a name="20161"><span class="lineNum">   20161 </span><span class="lineCov">     183029 :                 void visit(SgTemplateInstantiationDecl* node)</span></a>
<a name="20162"><span class="lineNum">   20162 </span>            :                 {</a>
<a name="20163"><span class="lineNum">   20163 </span><span class="lineCov">     183029 :                         if(SgClassSymbolPtr !=NULL){</span></a>
<a name="20164"><span class="lineNum">   20164 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20165"><span class="lineNum">   20165 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20166"><span class="lineNum">   20166 </span>            :                                         {</a>
<a name="20167"><span class="lineNum">   20167 </span><span class="lineNoCov">          0 :                                                 SgSymbol* s = node-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20168"><span class="lineNum">   20168 </span><span class="lineNoCov">          0 :                                                 if (isSgClassSymbol(s) == SgClassSymbolPtr) SgClassDeclaration_count++;</span></a>
<a name="20169"><span class="lineNum">   20169 </span>            :                                         }</a>
<a name="20170"><span class="lineNum">   20170 </span>            :                                 }</a>
<a name="20171"><span class="lineNum">   20171 </span>            :                         }</a>
<a name="20172"><span class="lineNum">   20172 </span>            : </a>
<a name="20173"><span class="lineNum">   20173 </span><span class="lineCov">     183029 :                         if(templateInstantiate_defining!=NULL) {</span></a>
<a name="20174"><span class="lineNum">   20174 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20175"><span class="lineNum">   20175 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20176"><span class="lineNum">   20176 </span>            :                                         {</a>
<a name="20177"><span class="lineNum">   20177 </span><span class="lineNoCov">          0 :                                                 if(node-&gt;get_symbol_from_symbol_table() == NULL){</span></a>
<a name="20178"><span class="lineNum">   20178 </span><span class="lineNoCov">          0 :                                                         SgDeclarationStatement * template_decl = ((SgDeclarationStatement*)node)-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="20179"><span class="lineNum">   20179 </span><span class="lineNoCov">          0 :                                                         SgDeclarationStatement * template_decl1 = ((SgDeclarationStatement*)node)-&gt;get_definingDeclaration();</span></a>
<a name="20180"><span class="lineNum">   20180 </span><span class="lineNoCov">          0 :                                                         if((template_decl==templateInstantiate_defining||template_decl1==templateInstantiate_defining) &amp;&amp; node!=templateInstantiate_defining){</span></a>
<a name="20181"><span class="lineNum">   20181 </span>            :                                                                 /*vector&lt;SgTemplateArgument*&gt; tempargs=  ((SgTemplateInstantiationDecl*)node)-&gt;get_templateArguments();</a>
<a name="20182"><span class="lineNum">   20182 </span>            :                                                                 foreach (SgTemplateArgument* element, tempargs){</a>
<a name="20183"><span class="lineNum">   20183 </span>            :                                                                         SgTemplateArgument* temparg = isSgTemplateArgument(element);</a>
<a name="20184"><span class="lineNum">   20184 </span>            :                                                                         if(temparg){</a>
<a name="20185"><span class="lineNum">   20185 </span>            :                                                                                 delete temparg;</a>
<a name="20186"><span class="lineNum">   20186 </span>            :                                                                         }</a>
<a name="20187"><span class="lineNum">   20187 </span>            :                                                                         printf(&quot;SgTemplateArg in Memory Pool traversal\n&quot;);</a>
<a name="20188"><span class="lineNum">   20188 </span>            :                                                                 }*/</a>
<a name="20189"><span class="lineNum">   20189 </span><span class="lineNoCov">          0 :                                                                 delete node;</span></a>
<a name="20190"><span class="lineNum">   20190 </span>            :                                                                 //printf(&quot;SgTemplateInstantiationDecl in Memory Pool traversal\n&quot;);</a>
<a name="20191"><span class="lineNum">   20191 </span>            :                                                         }</a>
<a name="20192"><span class="lineNum">   20192 </span>            :                                                 }</a>
<a name="20193"><span class="lineNum">   20193 </span>            :                                         }</a>
<a name="20194"><span class="lineNum">   20194 </span>            :                                 }</a>
<a name="20195"><span class="lineNum">   20195 </span>            :                         }</a>
<a name="20196"><span class="lineNum">   20196 </span><span class="lineCov">     183029 :                 }</span></a>
<a name="20197"><span class="lineNum">   20197 </span>            : </a>
<a name="20198"><span class="lineNum">   20198 </span><span class="lineCov">     179329 :                 void visit(SgThisExp* node)</span></a>
<a name="20199"><span class="lineNum">   20199 </span>            :                 {</a>
<a name="20200"><span class="lineNum">   20200 </span><span class="lineCov">     179329 :                         if (SgClassSymbolPtr !=NULL){</span></a>
<a name="20201"><span class="lineNum">   20201 </span><span class="lineNoCov">          0 :                                 SgSymbol* s = node-&gt;get_class_symbol();</span></a>
<a name="20202"><span class="lineNum">   20202 </span><span class="lineNoCov">          0 :                                 if (s == SgClassSymbolPtr) SgClassDeclaration_count++;</span></a>
<a name="20203"><span class="lineNum">   20203 </span>            :                         }</a>
<a name="20204"><span class="lineNum">   20204 </span><span class="lineCov">     179329 :                 }</span></a>
<a name="20205"><span class="lineNum">   20205 </span>            : </a>
<a name="20206"><span class="lineNum">   20206 </span><span class="lineNoCov">          0 :                 void visit(SgClassNameRefExp* node)</span></a>
<a name="20207"><span class="lineNum">   20207 </span>            :                 {</a>
<a name="20208"><span class="lineNum">   20208 </span><span class="lineNoCov">          0 :                         if (SgClassSymbolPtr !=NULL){</span></a>
<a name="20209"><span class="lineNum">   20209 </span><span class="lineNoCov">          0 :                                 SgSymbol* s = node-&gt;get_symbol();</span></a>
<a name="20210"><span class="lineNum">   20210 </span><span class="lineNoCov">          0 :                                 if (isSgClassSymbol(s) == SgClassSymbolPtr) SgClassDeclaration_count++;</span></a>
<a name="20211"><span class="lineNum">   20211 </span>            :                         }</a>
<a name="20212"><span class="lineNum">   20212 </span><span class="lineNoCov">          0 :                 }</span></a>
<a name="20213"><span class="lineNum">   20213 </span>            : </a>
<a name="20214"><span class="lineNum">   20214 </span>            : </a>
<a name="20215"><span class="lineNum">   20215 </span><span class="lineNoCov">          0 :                 int get_num_Class_pointers(){return SgClassDeclaration_count;}</span></a>
<a name="20216"><span class="lineNum">   20216 </span>            : </a>
<a name="20217"><span class="lineNum">   20217 </span>            : </a>
<a name="20218"><span class="lineNum">   20218 </span>            :         // SgMemberFunctionSymbol</a>
<a name="20219"><span class="lineNum">   20219 </span><span class="lineCov">     619556 :                 void visit(SgCtorInitializerList* node)</span></a>
<a name="20220"><span class="lineNum">   20220 </span>            :                 {</a>
<a name="20221"><span class="lineNum">   20221 </span><span class="lineCov">     619556 :                         if(memFunc !=NULL){</span></a>
<a name="20222"><span class="lineNum">   20222 </span><span class="lineNoCov">          0 :                                 SgMemberFunctionDeclaration * func= (SgMemberFunctionDeclaration*) (node-&gt;get_parent());</span></a>
<a name="20223"><span class="lineNum">   20223 </span><span class="lineNoCov">          0 :                                 if(func == memFunc){</span></a>
<a name="20224"><span class="lineNum">   20224 </span><span class="lineNoCov">          0 :                                         delete node;</span></a>
<a name="20225"><span class="lineNum">   20225 </span>            :                                 }</a>
<a name="20226"><span class="lineNum">   20226 </span>            :                         }</a>
<a name="20227"><span class="lineNum">   20227 </span><span class="lineCov">     619556 :                 }</span></a>
<a name="20228"><span class="lineNum">   20228 </span>            : </a>
<a name="20229"><span class="lineNum">   20229 </span>            : </a>
<a name="20230"><span class="lineNum">   20230 </span><span class="lineCov">     109848 :                 void visit(SgMemberFunctionDeclaration* node)</span></a>
<a name="20231"><span class="lineNum">   20231 </span>            :                 {</a>
<a name="20232"><span class="lineNum">   20232 </span><span class="lineCov">     109848 :                         if (SgMemFuncSymbolPtr !=NULL){</span></a>
<a name="20233"><span class="lineNum">   20233 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20234"><span class="lineNum">   20234 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20235"><span class="lineNum">   20235 </span>            :                                         {</a>
<a name="20236"><span class="lineNum">   20236 </span><span class="lineNoCov">          0 :                                                 SgSymbol* symbol = ((SgMemberFunctionDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20237"><span class="lineNum">   20237 </span><span class="lineNoCov">          0 :                                                 if(symbol == SgMemFuncSymbolPtr){</span></a>
<a name="20238"><span class="lineNum">   20238 </span><span class="lineNoCov">          0 :                                                         SgMemFuncSymbol_count++;</span></a>
<a name="20239"><span class="lineNum">   20239 </span>            :                                                 }</a>
<a name="20240"><span class="lineNum">   20240 </span>            :                                         }</a>
<a name="20241"><span class="lineNum">   20241 </span>            :                                 }</a>
<a name="20242"><span class="lineNum">   20242 </span>            :                         }</a>
<a name="20243"><span class="lineNum">   20243 </span><span class="lineCov">     109848 :                 }</span></a>
<a name="20244"><span class="lineNum">   20244 </span>            : </a>
<a name="20245"><span class="lineNum">   20245 </span><span class="lineCov">     238967 :                 void visit(SgTemplateInstantiationMemberFunctionDecl* node)</span></a>
<a name="20246"><span class="lineNum">   20246 </span>            :                 {</a>
<a name="20247"><span class="lineNum">   20247 </span><span class="lineCov">     238967 :                         if (SgMemFuncSymbolPtr !=NULL){</span></a>
<a name="20248"><span class="lineNum">   20248 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20249"><span class="lineNum">   20249 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20250"><span class="lineNum">   20250 </span>            :                                         {</a>
<a name="20251"><span class="lineNum">   20251 </span><span class="lineNoCov">          0 :                                                 SgSymbol* symbol = ((SgTemplateInstantiationMemberFunctionDecl*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20252"><span class="lineNum">   20252 </span><span class="lineNoCov">          0 :                                                 if(symbol == SgMemFuncSymbolPtr){</span></a>
<a name="20253"><span class="lineNum">   20253 </span><span class="lineNoCov">          0 :                                                         SgMemFuncSymbol_count++;</span></a>
<a name="20254"><span class="lineNum">   20254 </span>            :                                                 }</a>
<a name="20255"><span class="lineNum">   20255 </span>            :                                         }</a>
<a name="20256"><span class="lineNum">   20256 </span>            :                                 }</a>
<a name="20257"><span class="lineNum">   20257 </span>            :                         }</a>
<a name="20258"><span class="lineNum">   20258 </span><span class="lineCov">     238967 :                 }</span></a>
<a name="20259"><span class="lineNum">   20259 </span>            : </a>
<a name="20260"><span class="lineNum">   20260 </span>            : </a>
<a name="20261"><span class="lineNum">   20261 </span>            : </a>
<a name="20262"><span class="lineNum">   20262 </span><span class="lineNoCov">          0 :                 int get_num_memFunc_pointers(){return SgMemFuncSymbol_count;}</span></a>
<a name="20263"><span class="lineNum">   20263 </span>            : </a>
<a name="20264"><span class="lineNum">   20264 </span>            : </a>
<a name="20265"><span class="lineNum">   20265 </span>            :         // SgTypedefSymbol</a>
<a name="20266"><span class="lineNum">   20266 </span><span class="lineCov">     223774 :                 void visit(SgTypedefDeclaration* node)</span></a>
<a name="20267"><span class="lineNum">   20267 </span>            :                 {</a>
<a name="20268"><span class="lineNum">   20268 </span><span class="lineCov">     223774 :                         if(SgTypedefPtr!=NULL){</span></a>
<a name="20269"><span class="lineNum">   20269 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20270"><span class="lineNum">   20270 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20271"><span class="lineNum">   20271 </span>            :                                         {</a>
<a name="20272"><span class="lineNum">   20272 </span><span class="lineNoCov">          0 :                                                 SgSymbol* s = ((SgTypedefDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20273"><span class="lineNum">   20273 </span><span class="lineNoCov">          0 :                                                 if ((SgTypedefSymbol *)s == SgTypedefPtr) SgTypedefSymbol_count++;</span></a>
<a name="20274"><span class="lineNum">   20274 </span>            :                                         }</a>
<a name="20275"><span class="lineNum">   20275 </span>            :                                 }</a>
<a name="20276"><span class="lineNum">   20276 </span>            :                         }</a>
<a name="20277"><span class="lineNum">   20277 </span><span class="lineCov">     223774 :                         if(typedef_defining!=NULL){</span></a>
<a name="20278"><span class="lineNum">   20278 </span><span class="lineNoCov">          0 :                                 SgDeclarationStatement * typedef_define = ((SgDeclarationStatement*)node)-&gt;get_definingDeclaration();</span></a>
<a name="20279"><span class="lineNum">   20279 </span><span class="lineNoCov">          0 :                                 if(typedef_define == typedef_defining &amp;&amp; node != typedef_defining ) {</span></a>
<a name="20280"><span class="lineNum">   20280 </span><span class="lineNoCov">          0 :                                         delete node;</span></a>
<a name="20281"><span class="lineNum">   20281 </span>            :                                 }</a>
<a name="20282"><span class="lineNum">   20282 </span>            :                         }</a>
<a name="20283"><span class="lineNum">   20283 </span><span class="lineCov">     223774 :                 }</span></a>
<a name="20284"><span class="lineNum">   20284 </span>            : </a>
<a name="20285"><span class="lineNum">   20285 </span><span class="lineNoCov">          0 :                 int get_num_Typedef_pointers(){return SgTypedefSymbol_count;}</span></a>
<a name="20286"><span class="lineNum">   20286 </span>            : </a>
<a name="20287"><span class="lineNum">   20287 </span>            : </a>
<a name="20288"><span class="lineNum">   20288 </span>            : </a>
<a name="20289"><span class="lineNum">   20289 </span><span class="lineNoCov">          0 :                 void visit(SgTemplateDeclaration* node)</span></a>
<a name="20290"><span class="lineNum">   20290 </span>            :                 {</a>
<a name="20291"><span class="lineNum">   20291 </span><span class="lineNoCov">          0 :                         if (SgTemplateSymbolPtr !=NULL){</span></a>
<a name="20292"><span class="lineNum">   20292 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20293"><span class="lineNum">   20293 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20294"><span class="lineNum">   20294 </span>            :                                         {</a>
<a name="20295"><span class="lineNum">   20295 </span><span class="lineNoCov">          0 :                                                 SgSymbol* symbol = ((SgTemplateDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20296"><span class="lineNum">   20296 </span><span class="lineNoCov">          0 :                                                 if(symbol == SgTemplateSymbolPtr){</span></a>
<a name="20297"><span class="lineNum">   20297 </span><span class="lineNoCov">          0 :                                                         SgTemplateSymbol_count++;</span></a>
<a name="20298"><span class="lineNum">   20298 </span>            :                                                 }</a>
<a name="20299"><span class="lineNum">   20299 </span>            :                                         }</a>
<a name="20300"><span class="lineNum">   20300 </span>            :                                 }</a>
<a name="20301"><span class="lineNum">   20301 </span>            :                         }</a>
<a name="20302"><span class="lineNum">   20302 </span>            : </a>
<a name="20303"><span class="lineNum">   20303 </span><span class="lineNoCov">          0 :                         if(template_defining !=NULL) {</span></a>
<a name="20304"><span class="lineNum">   20304 </span><span class="lineNoCov">          0 :                                 if(node-&gt;get_scope()!=NULL){</span></a>
<a name="20305"><span class="lineNum">   20305 </span><span class="lineNoCov">          0 :                                      if(node-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20306"><span class="lineNum">   20306 </span>            :                                         {</a>
<a name="20307"><span class="lineNum">   20307 </span><span class="lineNoCov">          0 :                                                 if(node-&gt;get_symbol_from_symbol_table() == NULL){</span></a>
<a name="20308"><span class="lineNum">   20308 </span><span class="lineNoCov">          0 :                                                         SgDeclarationStatement * template_decl = ((SgDeclarationStatement*)node)-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="20309"><span class="lineNum">   20309 </span><span class="lineNoCov">          0 :                                                         SgDeclarationStatement * template_decl1 = ((SgDeclarationStatement*)node)-&gt;get_definingDeclaration();</span></a>
<a name="20310"><span class="lineNum">   20310 </span><span class="lineNoCov">          0 :                                                         if((template_decl==template_defining||template_decl1==template_defining) &amp;&amp; node!=template_defining) {</span></a>
<a name="20311"><span class="lineNum">   20311 </span><span class="lineNoCov">          0 :                                                                 delete node;</span></a>
<a name="20312"><span class="lineNum">   20312 </span>            : </a>
<a name="20313"><span class="lineNum">   20313 </span>            :                                                         }</a>
<a name="20314"><span class="lineNum">   20314 </span>            :                                                 }</a>
<a name="20315"><span class="lineNum">   20315 </span>            :                                         }</a>
<a name="20316"><span class="lineNum">   20316 </span>            :                                 }</a>
<a name="20317"><span class="lineNum">   20317 </span>            :                         }</a>
<a name="20318"><span class="lineNum">   20318 </span><span class="lineNoCov">          0 :                 }</span></a>
<a name="20319"><span class="lineNum">   20319 </span>            : </a>
<a name="20320"><span class="lineNum">   20320 </span>            :                 int get_num_Template_pointers(){return SgTemplateSymbol_count;}</a>
<a name="20321"><span class="lineNum">   20321 </span>            : </a>
<a name="20322"><span class="lineNum">   20322 </span>            :         };</a>
<a name="20323"><span class="lineNum">   20323 </span>            : </a>
<a name="20324"><span class="lineNum">   20324 </span>            : </a>
<a name="20325"><span class="lineNum">   20325 </span>            :         //Tan August,25,2010 //Traverse AST in post order, delete nodes and their symbols if it's safe to do so</a>
<a name="20326"><span class="lineNum">   20326 </span><span class="lineCov">        518 :         class DeleteAST : public SgSimpleProcessing,  ROSE_VisitTraversal</span></a>
<a name="20327"><span class="lineNum">   20327 </span>            :                 {</a>
<a name="20328"><span class="lineNum">   20328 </span>            :                         public:</a>
<a name="20329"><span class="lineNum">   20329 </span>            : </a>
<a name="20330"><span class="lineNum">   20330 </span><span class="lineCov">       1342 :                         void visit (SgNode* node)</span></a>
<a name="20331"><span class="lineNum">   20331 </span>            :                         {</a>
<a name="20332"><span class="lineNum">   20332 </span>            :                         //These nodes are manually deleted because they cannot be visited by the traversal</a>
<a name="20333"><span class="lineNum">   20333 </span>            :                                 ////////////////////////////////////////////////</a>
<a name="20334"><span class="lineNum">   20334 </span>            :                                 //remove SgVariableDefinition, SgVariableSymbol and SgEnumFieldSymbol</a>
<a name="20335"><span class="lineNum">   20335 </span>            :                                 ////////////////////////////////////////////////</a>
<a name="20336"><span class="lineNum">   20336 </span>            : #if 0</a>
<a name="20337"><span class="lineNum">   20337 </span>            :                                 printf (&quot;In DeleteAST::visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="20338"><span class="lineNum">   20338 </span>            : #endif</a>
<a name="20339"><span class="lineNum">   20339 </span>            : #if 0</a>
<a name="20340"><span class="lineNum">   20340 </span>            :                              // DQ (3/2/2014): I think this might be a problem...</a>
<a name="20341"><span class="lineNum">   20341 </span>            :                              // DQ (3/1/2014): check for a SgScopeStatement and delete the associated local type table.</a>
<a name="20342"><span class="lineNum">   20342 </span>            :                                 if (isSgScopeStatement(node) !=NULL)</a>
<a name="20343"><span class="lineNum">   20343 </span>            :                                    {</a>
<a name="20344"><span class="lineNum">   20344 </span>            :                                      SgScopeStatement* scope = isSgScopeStatement(node);</a>
<a name="20345"><span class="lineNum">   20345 </span>            : #if 1</a>
<a name="20346"><span class="lineNum">   20346 </span>            :                                      printf (&quot;Deleting the scopes type table: scope-&gt;get_type_table() = %p \n&quot;,scope-&gt;get_type_table());</a>
<a name="20347"><span class="lineNum">   20347 </span>            : #endif</a>
<a name="20348"><span class="lineNum">   20348 </span>            :                                      delete scope-&gt;get_type_table();</a>
<a name="20349"><span class="lineNum">   20349 </span>            :                                    }</a>
<a name="20350"><span class="lineNum">   20350 </span>            : #endif</a>
<a name="20351"><span class="lineNum">   20351 </span>            : #if 0</a>
<a name="20352"><span class="lineNum">   20352 </span>            :                              // DQ (3/2/2014): I think this might be a problem...</a>
<a name="20353"><span class="lineNum">   20353 </span>            :                              // DQ (3/1/2014): check for a SgScopeStatement and delete the associated local type table.</a>
<a name="20354"><span class="lineNum">   20354 </span>            :                                 if (isSgTypeTable(node) !=NULL)</a>
<a name="20355"><span class="lineNum">   20355 </span>            :                                    {</a>
<a name="20356"><span class="lineNum">   20356 </span>            :                                      SgTypeTable* typeTable = isSgTypeTable(node);</a>
<a name="20357"><span class="lineNum">   20357 </span>            : #if 1</a>
<a name="20358"><span class="lineNum">   20358 </span>            :                                      printf (&quot;Deleting the type table (SgSymbolTable): typeTable-&gt;get_type_table() = %p \n&quot;,typeTable-&gt;get_type_table());</a>
<a name="20359"><span class="lineNum">   20359 </span>            : #endif</a>
<a name="20360"><span class="lineNum">   20360 </span>            :                                      delete typeTable-&gt;get_type_table();</a>
<a name="20361"><span class="lineNum">   20361 </span>            :                                    }</a>
<a name="20362"><span class="lineNum">   20362 </span>            : #endif</a>
<a name="20363"><span class="lineNum">   20363 </span><span class="lineCov">       1342 :                                 if(isSgInitializedName(node) !=NULL){</span></a>
<a name="20364"><span class="lineNum">   20364 </span>            :                                         //remove SgVariableDefinition</a>
<a name="20365"><span class="lineNum">   20365 </span><span class="lineNoCov">          0 :                                         SgDeclarationStatement* var_def;</span></a>
<a name="20366"><span class="lineNum">   20366 </span><span class="lineNoCov">          0 :                                         var_def =  ((SgInitializedName *)node)-&gt;get_definition();</span></a>
<a name="20367"><span class="lineNum">   20367 </span><span class="lineNoCov">          0 :                                         if(isSgVariableDefinition(var_def) !=NULL){</span></a>
<a name="20368"><span class="lineNum">   20368 </span><span class="lineNoCov">          0 :                                                 delete var_def;</span></a>
<a name="20369"><span class="lineNum">   20369 </span>            :                                                 //printf(&quot;A SgVariableDefinition was deleted\n&quot;);</a>
<a name="20370"><span class="lineNum">   20370 </span>            :                                         }</a>
<a name="20371"><span class="lineNum">   20371 </span>            : </a>
<a name="20372"><span class="lineNum">   20372 </span>            : </a>
<a name="20373"><span class="lineNum">   20373 </span>            :                                         //remove SgVariableSymbol</a>
<a name="20374"><span class="lineNum">   20374 </span><span class="lineNoCov">          0 :                                         if(isSgInitializedName(node)-&gt;get_scope()!=NULL){</span></a>
<a name="20375"><span class="lineNum">   20375 </span><span class="lineNoCov">          0 :                                              if(isSgInitializedName(node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20376"><span class="lineNum">   20376 </span>            :                                                 {</a>
<a name="20377"><span class="lineNum">   20377 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgInitializedName *)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20378"><span class="lineNum">   20378 </span><span class="lineNoCov">          0 :                                                         if(isSgVariableSymbol(symbol) !=NULL){</span></a>
<a name="20379"><span class="lineNum">   20379 </span><span class="lineNoCov">          0 :                                                                 ClassicVisitor visitor((SgVariableSymbol*)symbol);</span></a>
<a name="20380"><span class="lineNum">   20380 </span><span class="lineNoCov">          0 :                                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20381"><span class="lineNum">   20381 </span><span class="lineNoCov">          0 :                                                                 if(visitor.get_num_variable_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</span></a>
<a name="20382"><span class="lineNum">   20382 </span><span class="lineNoCov">          0 :                                                                 ((SgInitializedName*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20383"><span class="lineNum">   20383 </span><span class="lineNoCov">          0 :                                                                         delete symbol;</span></a>
<a name="20384"><span class="lineNum">   20384 </span>            :                                                                         //printf(&quot;A SgVariableSymbol was deleted\n&quot;);</a>
<a name="20385"><span class="lineNum">   20385 </span>            :                                                                 }</a>
<a name="20386"><span class="lineNum">   20386 </span>            :                                                         }</a>
<a name="20387"><span class="lineNum">   20387 </span>            : </a>
<a name="20388"><span class="lineNum">   20388 </span><span class="lineNoCov">          0 :                                                         if(isSgEnumFieldSymbol(symbol) !=NULL){</span></a>
<a name="20389"><span class="lineNum">   20389 </span><span class="lineNoCov">          0 :                                                                 ClassicVisitor visitor((SgEnumFieldSymbol*)symbol);</span></a>
<a name="20390"><span class="lineNum">   20390 </span><span class="lineNoCov">          0 :                                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20391"><span class="lineNum">   20391 </span><span class="lineNoCov">          0 :                                                                 if(visitor.get_num_EnumField_pointers()==1){</span></a>
<a name="20392"><span class="lineNum">   20392 </span><span class="lineNoCov">          0 :                                                                         ((SgInitializedName*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20393"><span class="lineNum">   20393 </span><span class="lineNoCov">          0 :                                                                         delete symbol;</span></a>
<a name="20394"><span class="lineNum">   20394 </span>            :                                                                         //printf(&quot;A SgEnumFieldSymbol was deleted\n&quot;);</a>
<a name="20395"><span class="lineNum">   20395 </span>            :                                                                 }</a>
<a name="20396"><span class="lineNum">   20396 </span>            :                                                         }</a>
<a name="20397"><span class="lineNum">   20397 </span>            : </a>
<a name="20398"><span class="lineNum">   20398 </span>            :                                                 }</a>
<a name="20399"><span class="lineNum">   20399 </span>            :                                         }</a>
<a name="20400"><span class="lineNum">   20400 </span>            :                                 }</a>
<a name="20401"><span class="lineNum">   20401 </span>            : </a>
<a name="20402"><span class="lineNum">   20402 </span><span class="lineCov">       1342 :                                 if(isSgVarRefExp(node) !=NULL){</span></a>
<a name="20403"><span class="lineNum">   20403 </span><span class="lineCov">        161 :                                                 SgVariableSymbol *symbol = ((SgVarRefExp*)node)-&gt;get_symbol();</span></a>
<a name="20404"><span class="lineNum">   20404 </span><span class="lineCov">        322 :                                                 ClassicVisitor visitor(symbol);</span></a>
<a name="20405"><span class="lineNum">   20405 </span><span class="lineCov">        161 :                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20406"><span class="lineNum">   20406 </span><span class="lineCov">        161 :                                                 if(visitor.get_num_variable_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</span></a>
<a name="20407"><span class="lineNum">   20407 </span>            :                                                         //((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20408"><span class="lineNum">   20408 </span><span class="lineNoCov">          0 :                                                         delete symbol;</span></a>
<a name="20409"><span class="lineNum">   20409 </span>            :                                                         //printf(&quot;A SgVariableSymbol was deleted\n&quot;);</a>
<a name="20410"><span class="lineNum">   20410 </span>            :                                                 }</a>
<a name="20411"><span class="lineNum">   20411 </span>            :                                 }</a>
<a name="20412"><span class="lineNum">   20412 </span>            : </a>
<a name="20413"><span class="lineNum">   20413 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20414"><span class="lineNum">   20414 </span>            :                                 /remove SgFunctionSymbol</a>
<a name="20415"><span class="lineNum">   20415 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20416"><span class="lineNum">   20416 </span>            : </a>
<a name="20417"><span class="lineNum">   20417 </span><span class="lineCov">       1342 :                                 {</span></a>
<a name="20418"><span class="lineNum">   20418 </span><span class="lineCov">       1342 :                                    SgFunctionDeclaration* funcDecl = isSgFunctionDeclaration(node);</span></a>
<a name="20419"><span class="lineNum">   20419 </span><span class="lineCov">       1342 :                                    if (funcDecl != NULL){</span></a>
<a name="20420"><span class="lineNum">   20420 </span><span class="lineNoCov">          0 :                                       if (isSgMemberFunctionDeclaration(node) == NULL) {</span></a>
<a name="20421"><span class="lineNum">   20421 </span><span class="lineNoCov">          0 :                                          if (funcDecl-&gt;get_scope() != NULL) {</span></a>
<a name="20422"><span class="lineNum">   20422 </span><span class="lineNoCov">          0 :                                             if (funcDecl-&gt;get_scope()-&gt;get_symbol_table() != NULL) {</span></a>
<a name="20423"><span class="lineNum">   20423 </span><span class="lineNoCov">          0 :                                                SgSymbol* symbol = ((SgFunctionDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20424"><span class="lineNum">   20424 </span><span class="lineNoCov">          0 :                                                ClassicVisitor visitor((SgFunctionSymbol *)symbol);</span></a>
<a name="20425"><span class="lineNum">   20425 </span><span class="lineNoCov">          0 :                                                traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20426"><span class="lineNum">   20426 </span><span class="lineNoCov">          0 :                                                if (visitor.get_num_Function_pointers()==1) { //only one reference to this FunctionSymbol =&gt; safe to delete</span></a>
<a name="20427"><span class="lineNum">   20427 </span><span class="lineNoCov">          0 :                                                   ((SgFunctionDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20428"><span class="lineNum">   20428 </span><span class="lineNoCov">          0 :                                                   delete symbol;</span></a>
<a name="20429"><span class="lineNum">   20429 </span>            :                                                 //printf(&quot;A SgFunctionSymbol was deleted\n&quot;);</a>
<a name="20430"><span class="lineNum">   20430 </span>            :                                                }</a>
<a name="20431"><span class="lineNum">   20431 </span><span class="lineNoCov">          0 :                                                ClassicVisitor visitor1((SgFunctionDeclaration *)node);</span></a>
<a name="20432"><span class="lineNum">   20432 </span><span class="lineNoCov">          0 :                                                traverseMemoryPoolVisitorPattern(visitor1);</span></a>
<a name="20433"><span class="lineNum">   20433 </span>            :                                             }</a>
<a name="20434"><span class="lineNum">   20434 </span>            :                                          }</a>
<a name="20435"><span class="lineNum">   20435 </span>            :                                       }</a>
<a name="20436"><span class="lineNum">   20436 </span>            :                                    }</a>
<a name="20437"><span class="lineNum">   20437 </span>            :                                 }</a>
<a name="20438"><span class="lineNum">   20438 </span>            : </a>
<a name="20439"><span class="lineNum">   20439 </span><span class="lineCov">       1342 :                                 if(isSgFunctionRefExp(node) !=NULL)</span></a>
<a name="20440"><span class="lineNum">   20440 </span>            :                                 {</a>
<a name="20441"><span class="lineNum">   20441 </span>            : #if 0</a>
<a name="20442"><span class="lineNum">   20442 </span>            :                                    SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(node);</a>
<a name="20443"><span class="lineNum">   20443 </span>            :                                    ROSE_ASSERT(functionRefExp-&gt;get_symbol_i() != NULL);</a>
<a name="20444"><span class="lineNum">   20444 </span>            :                                    printf (&quot;In DeleteAST::visit(): functionRefExp-&gt;get_symbol_i() = %p = %s \n&quot;,functionRefExp-&gt;get_symbol_i(),functionRefExp-&gt;get_symbol_i()-&gt;class_name().c_str());</a>
<a name="20445"><span class="lineNum">   20445 </span>            : #endif</a>
<a name="20446"><span class="lineNum">   20446 </span><span class="lineCov">         33 :                                                 SgFunctionSymbol *symbol = ((SgFunctionRefExp*)node)-&gt;get_symbol_i();</span></a>
<a name="20447"><span class="lineNum">   20447 </span><span class="lineCov">         66 :                                                 ClassicVisitor visitor(symbol);</span></a>
<a name="20448"><span class="lineNum">   20448 </span><span class="lineCov">         33 :                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20449"><span class="lineNum">   20449 </span><span class="lineCov">         33 :                                                 if(visitor.get_num_Function_pointers()==1)</span></a>
<a name="20450"><span class="lineNum">   20450 </span>            :                                                 {</a>
<a name="20451"><span class="lineNum">   20451 </span>            :                                                // only one reference to this FunctionSymbol =&gt; safe to delete</a>
<a name="20452"><span class="lineNum">   20452 </span>            :                                                         //((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20453"><span class="lineNum">   20453 </span><span class="lineNoCov">          0 :                                                         delete symbol;</span></a>
<a name="20454"><span class="lineNum">   20454 </span>            :                                                         //printf(&quot;A SgFunctionSymbol was deleted\n&quot;);</a>
<a name="20455"><span class="lineNum">   20455 </span>            :                                                 }</a>
<a name="20456"><span class="lineNum">   20456 </span>            : </a>
<a name="20457"><span class="lineNum">   20457 </span>            :                                 }</a>
<a name="20458"><span class="lineNum">   20458 </span>            : </a>
<a name="20459"><span class="lineNum">   20459 </span><span class="lineCov">       1342 :                                 if(isSgUserDefinedBinaryOp(node) !=NULL){</span></a>
<a name="20460"><span class="lineNum">   20460 </span><span class="lineNoCov">          0 :                                         SgFunctionSymbol *symbol = ((SgUserDefinedBinaryOp*)node)-&gt;get_symbol();</span></a>
<a name="20461"><span class="lineNum">   20461 </span><span class="lineNoCov">          0 :                                         ClassicVisitor visitor(symbol);</span></a>
<a name="20462"><span class="lineNum">   20462 </span><span class="lineNoCov">          0 :                                         traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20463"><span class="lineNum">   20463 </span><span class="lineNoCov">          0 :                                         if(visitor.get_num_Function_pointers()==1){ //only one reference to this FunctionSymbol =&gt; safe to delete</span></a>
<a name="20464"><span class="lineNum">   20464 </span><span class="lineNoCov">          0 :                                                 ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20465"><span class="lineNum">   20465 </span><span class="lineNoCov">          0 :                                                 delete symbol;</span></a>
<a name="20466"><span class="lineNum">   20466 </span>            :                                                 //printf(&quot;A SgFunctionSymbol was deleted\n&quot;);</a>
<a name="20467"><span class="lineNum">   20467 </span>            :                                         }</a>
<a name="20468"><span class="lineNum">   20468 </span>            :                                 }</a>
<a name="20469"><span class="lineNum">   20469 </span>            : </a>
<a name="20470"><span class="lineNum">   20470 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20471"><span class="lineNum">   20471 </span>            :                                 /remove SgTypedefSymbol</a>
<a name="20472"><span class="lineNum">   20472 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20473"><span class="lineNum">   20473 </span>            : </a>
<a name="20474"><span class="lineNum">   20474 </span><span class="lineCov">       1342 :                                 if(isSgTypedefDeclaration(node) !=NULL){</span></a>
<a name="20475"><span class="lineNum">   20475 </span><span class="lineNoCov">          0 :                                         if(((SgTypedefDeclaration*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20476"><span class="lineNum">   20476 </span><span class="lineNoCov">          0 :                                              if(((SgTypedefDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20477"><span class="lineNum">   20477 </span>            :                                                 {</a>
<a name="20478"><span class="lineNum">   20478 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgTypedefDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20479"><span class="lineNum">   20479 </span><span class="lineNoCov">          0 :                                                         if(isSgTypedefSymbol(symbol)){</span></a>
<a name="20480"><span class="lineNum">   20480 </span><span class="lineNoCov">          0 :                                                                 ClassicVisitor visitor((SgTypedefSymbol*) symbol);</span></a>
<a name="20481"><span class="lineNum">   20481 </span><span class="lineNoCov">          0 :                                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20482"><span class="lineNum">   20482 </span><span class="lineNoCov">          0 :                                                                 if(visitor.get_num_Typedef_pointers()==1){ //only one reference to this SgTypedefSymbol  =&gt; safe to delete</span></a>
<a name="20483"><span class="lineNum">   20483 </span><span class="lineNoCov">          0 :                                                                         ((SgTypedefDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20484"><span class="lineNum">   20484 </span><span class="lineNoCov">          0 :                                                                         delete symbol;</span></a>
<a name="20485"><span class="lineNum">   20485 </span>            :                                                                         //printf(&quot;A SgTypedefSymbol was deleted\n&quot;);</a>
<a name="20486"><span class="lineNum">   20486 </span>            :                                                                 }</a>
<a name="20487"><span class="lineNum">   20487 </span>            :                                                         }</a>
<a name="20488"><span class="lineNum">   20488 </span>            :                                                 }</a>
<a name="20489"><span class="lineNum">   20489 </span>            :                                         }</a>
<a name="20490"><span class="lineNum">   20490 </span>            : </a>
<a name="20491"><span class="lineNum">   20491 </span><span class="lineNoCov">          0 :                                         if(node == isSgTypedefDeclaration(node)-&gt;get_definingDeclaration()){</span></a>
<a name="20492"><span class="lineNum">   20492 </span><span class="lineNoCov">          0 :                                                 ClassicVisitor visitor1((SgTypedefDeclaration*) node);</span></a>
<a name="20493"><span class="lineNum">   20493 </span><span class="lineNoCov">          0 :                                                 traverseMemoryPoolVisitorPattern(visitor1);</span></a>
<a name="20494"><span class="lineNum">   20494 </span>            :                                         }</a>
<a name="20495"><span class="lineNum">   20495 </span>            :                                 }</a>
<a name="20496"><span class="lineNum">   20496 </span>            : </a>
<a name="20497"><span class="lineNum">   20497 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20498"><span class="lineNum">   20498 </span>            :                                 /remove SgNamespaceDeclarationSymbol</a>
<a name="20499"><span class="lineNum">   20499 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20500"><span class="lineNum">   20500 </span>            : </a>
<a name="20501"><span class="lineNum">   20501 </span><span class="lineCov">       1342 :                                 if(isSgNamespaceDeclarationStatement(node) !=NULL){</span></a>
<a name="20502"><span class="lineNum">   20502 </span><span class="lineNoCov">          0 :                                         if(((SgNamespaceDeclarationStatement*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20503"><span class="lineNum">   20503 </span><span class="lineNoCov">          0 :                                              if(((SgNamespaceDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20504"><span class="lineNum">   20504 </span>            :                                                 {</a>
<a name="20505"><span class="lineNum">   20505 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgNamespaceDeclarationStatement*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20506"><span class="lineNum">   20506 </span><span class="lineNoCov">          0 :                                                         if(isSgNamespaceSymbol(symbol)){</span></a>
<a name="20507"><span class="lineNum">   20507 </span><span class="lineNoCov">          0 :                                                                 ((SgNamespaceDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20508"><span class="lineNum">   20508 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20509"><span class="lineNum">   20509 </span>            :                                                                 //printf(&quot;A SgNamespaceSymbol was deleted\n&quot;);</a>
<a name="20510"><span class="lineNum">   20510 </span>            :                                                         }</a>
<a name="20511"><span class="lineNum">   20511 </span>            :                                                 }</a>
<a name="20512"><span class="lineNum">   20512 </span>            :                                         }</a>
<a name="20513"><span class="lineNum">   20513 </span>            :                                 }</a>
<a name="20514"><span class="lineNum">   20514 </span>            : </a>
<a name="20515"><span class="lineNum">   20515 </span>            : </a>
<a name="20516"><span class="lineNum">   20516 </span><span class="lineCov">       1342 :                                 if(isSgNamespaceAliasDeclarationStatement(node) !=NULL){</span></a>
<a name="20517"><span class="lineNum">   20517 </span><span class="lineNoCov">          0 :                                         if(((SgNamespaceAliasDeclarationStatement*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20518"><span class="lineNum">   20518 </span><span class="lineNoCov">          0 :                                              if(((SgNamespaceAliasDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20519"><span class="lineNum">   20519 </span>            :                                                 {</a>
<a name="20520"><span class="lineNum">   20520 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgNamespaceAliasDeclarationStatement*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20521"><span class="lineNum">   20521 </span><span class="lineNoCov">          0 :                                                         if(isSgNamespaceSymbol(symbol)){</span></a>
<a name="20522"><span class="lineNum">   20522 </span><span class="lineNoCov">          0 :                                                                 ((SgNamespaceAliasDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20523"><span class="lineNum">   20523 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20524"><span class="lineNum">   20524 </span>            :                                                                 //printf(&quot;A SgNamespaceSymbol was deleted\n&quot;);</a>
<a name="20525"><span class="lineNum">   20525 </span>            :                                                         }</a>
<a name="20526"><span class="lineNum">   20526 </span>            :                                                 }</a>
<a name="20527"><span class="lineNum">   20527 </span>            :                                         }</a>
<a name="20528"><span class="lineNum">   20528 </span>            :                                 }</a>
<a name="20529"><span class="lineNum">   20529 </span>            : </a>
<a name="20530"><span class="lineNum">   20530 </span>            : </a>
<a name="20531"><span class="lineNum">   20531 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20532"><span class="lineNum">   20532 </span>            :                                 /remove SgLabelSymbol</a>
<a name="20533"><span class="lineNum">   20533 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20534"><span class="lineNum">   20534 </span>            : </a>
<a name="20535"><span class="lineNum">   20535 </span><span class="lineCov">       1342 :                                 if(isSgLabelStatement(node) !=NULL){</span></a>
<a name="20536"><span class="lineNum">   20536 </span><span class="lineNoCov">          0 :                                         if(((SgLabelStatement*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20537"><span class="lineNum">   20537 </span><span class="lineNoCov">          0 :                                              if(((SgLabelStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20538"><span class="lineNum">   20538 </span>            :                                                 {</a>
<a name="20539"><span class="lineNum">   20539 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgLabelStatement*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20540"><span class="lineNum">   20540 </span><span class="lineNoCov">          0 :                                                         if(isSgLabelSymbol(symbol)){</span></a>
<a name="20541"><span class="lineNum">   20541 </span><span class="lineNoCov">          0 :                                                                 ((SgLabelStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20542"><span class="lineNum">   20542 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20543"><span class="lineNum">   20543 </span>            :                                                                 //printf(&quot;A SgLabelSymbol was deleted\n&quot;);</a>
<a name="20544"><span class="lineNum">   20544 </span>            :                                                         }</a>
<a name="20545"><span class="lineNum">   20545 </span>            :                                                 }</a>
<a name="20546"><span class="lineNum">   20546 </span>            :                                         }</a>
<a name="20547"><span class="lineNum">   20547 </span>            :                                 }</a>
<a name="20548"><span class="lineNum">   20548 </span>            : </a>
<a name="20549"><span class="lineNum">   20549 </span><span class="lineCov">       1342 :                                 if(isSgLabelRefExp(node) !=NULL){</span></a>
<a name="20550"><span class="lineNum">   20550 </span><span class="lineNoCov">          0 :                                         SgLabelSymbol* symbol = ((SgLabelRefExp*)node)-&gt;get_symbol();</span></a>
<a name="20551"><span class="lineNum">   20551 </span><span class="lineNoCov">          0 :                                         ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20552"><span class="lineNum">   20552 </span><span class="lineNoCov">          0 :                                         delete symbol;</span></a>
<a name="20553"><span class="lineNum">   20553 </span>            :                                         //printf(&quot;A SgLabelSymbol was deleted\n&quot;);</a>
<a name="20554"><span class="lineNum">   20554 </span>            :                                 }</a>
<a name="20555"><span class="lineNum">   20555 </span>            : </a>
<a name="20556"><span class="lineNum">   20556 </span>            : </a>
<a name="20557"><span class="lineNum">   20557 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20558"><span class="lineNum">   20558 </span>            :                                 /remove SgEnumSymbol</a>
<a name="20559"><span class="lineNum">   20559 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20560"><span class="lineNum">   20560 </span>            : </a>
<a name="20561"><span class="lineNum">   20561 </span><span class="lineCov">       1342 :                                 if(isSgEnumDeclaration(node) !=NULL){</span></a>
<a name="20562"><span class="lineNum">   20562 </span><span class="lineNoCov">          0 :                                         if(((SgEnumDeclaration*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20563"><span class="lineNum">   20563 </span><span class="lineNoCov">          0 :                                              if(((SgEnumDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20564"><span class="lineNum">   20564 </span>            :                                                 {</a>
<a name="20565"><span class="lineNum">   20565 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgEnumDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20566"><span class="lineNum">   20566 </span><span class="lineNoCov">          0 :                                                         if(isSgEnumSymbol(symbol) !=NULL){</span></a>
<a name="20567"><span class="lineNum">   20567 </span><span class="lineNoCov">          0 :                                                                 ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20568"><span class="lineNum">   20568 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20569"><span class="lineNum">   20569 </span>            :                                                                 //printf(&quot;A SgEnumSymbol was deleted\n&quot;);</a>
<a name="20570"><span class="lineNum">   20570 </span>            :                                                         }</a>
<a name="20571"><span class="lineNum">   20571 </span>            :                                                 }</a>
<a name="20572"><span class="lineNum">   20572 </span>            :                                         }</a>
<a name="20573"><span class="lineNum">   20573 </span><span class="lineNoCov">          0 :                                         SgEnumType* type= ((SgEnumDeclaration*)node)-&gt;get_type();</span></a>
<a name="20574"><span class="lineNum">   20574 </span><span class="lineNoCov">          0 :                                         if(type !=NULL){</span></a>
<a name="20575"><span class="lineNum">   20575 </span><span class="lineNoCov">          0 :                                                         delete type;</span></a>
<a name="20576"><span class="lineNum">   20576 </span>            :                                                         //printf(&quot;A SgEnumType was deleted\n&quot;);</a>
<a name="20577"><span class="lineNum">   20577 </span>            :                                         }</a>
<a name="20578"><span class="lineNum">   20578 </span>            :                                 }</a>
<a name="20579"><span class="lineNum">   20579 </span>            : </a>
<a name="20580"><span class="lineNum">   20580 </span>            : </a>
<a name="20581"><span class="lineNum">   20581 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20582"><span class="lineNum">   20582 </span>            :                                 /remove SgClassSymbol</a>
<a name="20583"><span class="lineNum">   20583 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20584"><span class="lineNum">   20584 </span>            : </a>
<a name="20585"><span class="lineNum">   20585 </span><span class="lineCov">       1342 :                                 if(isSgClassDeclaration(node) !=NULL &amp;&amp; isSgTemplateInstantiationDecl(node) ==NULL){</span></a>
<a name="20586"><span class="lineNum">   20586 </span><span class="lineNoCov">          0 :                                         if(((SgClassDeclaration*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20587"><span class="lineNum">   20587 </span><span class="lineNoCov">          0 :                                              if(((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20588"><span class="lineNum">   20588 </span>            :                                                 {</a>
<a name="20589"><span class="lineNum">   20589 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgClassDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20590"><span class="lineNum">   20590 </span><span class="lineNoCov">          0 :                                                         if(isSgClassSymbol(symbol) !=NULL){</span></a>
<a name="20591"><span class="lineNum">   20591 </span><span class="lineNoCov">          0 :                                                                 ClassicVisitor visitor((SgClassSymbol*)symbol);</span></a>
<a name="20592"><span class="lineNum">   20592 </span><span class="lineNoCov">          0 :                                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20593"><span class="lineNum">   20593 </span><span class="lineNoCov">          0 :                                                                 if(visitor.get_num_Class_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</span></a>
<a name="20594"><span class="lineNum">   20594 </span><span class="lineNoCov">          0 :                                                                         ((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20595"><span class="lineNum">   20595 </span><span class="lineNoCov">          0 :                                                                         delete symbol;</span></a>
<a name="20596"><span class="lineNum">   20596 </span>            :                                                                         //printf(&quot;A SgClassSymbol was deleted\n&quot;);</a>
<a name="20597"><span class="lineNum">   20597 </span>            :                                                                 }</a>
<a name="20598"><span class="lineNum">   20598 </span>            :                                                         }</a>
<a name="20599"><span class="lineNum">   20599 </span>            :                                                 }</a>
<a name="20600"><span class="lineNum">   20600 </span>            :                                         }</a>
<a name="20601"><span class="lineNum">   20601 </span>            : </a>
<a name="20602"><span class="lineNum">   20602 </span><span class="lineNoCov">          0 :                                         ClassicVisitor visitor((SgClassDeclaration*) node );</span></a>
<a name="20603"><span class="lineNum">   20603 </span><span class="lineNoCov">          0 :                                         traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20604"><span class="lineNum">   20604 </span>            : </a>
<a name="20605"><span class="lineNum">   20605 </span><span class="lineNoCov">          0 :                                         SgClassType* type= ((SgClassDeclaration*)node)-&gt;get_type();</span></a>
<a name="20606"><span class="lineNum">   20606 </span><span class="lineNoCov">          0 :                                         if(type !=NULL){</span></a>
<a name="20607"><span class="lineNum">   20607 </span><span class="lineNoCov">          0 :                                                 delete type;</span></a>
<a name="20608"><span class="lineNum">   20608 </span>            :                                                 //printf(&quot;A SgClassType was deleted\n&quot;);</a>
<a name="20609"><span class="lineNum">   20609 </span>            :                                         }</a>
<a name="20610"><span class="lineNum">   20610 </span>            :                                 }</a>
<a name="20611"><span class="lineNum">   20611 </span>            : </a>
<a name="20612"><span class="lineNum">   20612 </span><span class="lineCov">       1342 :                                 if(isSgThisExp(node) !=NULL){</span></a>
<a name="20613"><span class="lineNum">   20613 </span><span class="lineNoCov">          0 :                                         SgSymbol* symbol = ((SgThisExp*)node)-&gt;get_class_symbol();</span></a>
<a name="20614"><span class="lineNum">   20614 </span><span class="lineNoCov">          0 :                                         ClassicVisitor visitor((SgClassSymbol*)symbol);</span></a>
<a name="20615"><span class="lineNum">   20615 </span><span class="lineNoCov">          0 :                                         traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20616"><span class="lineNum">   20616 </span><span class="lineNoCov">          0 :                                         if(visitor.get_num_Class_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</span></a>
<a name="20617"><span class="lineNum">   20617 </span><span class="lineNoCov">          0 :                                                 ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20618"><span class="lineNum">   20618 </span><span class="lineNoCov">          0 :                                                 delete symbol;</span></a>
<a name="20619"><span class="lineNum">   20619 </span>            :                                                 //printf(&quot;A SgClassSymbol was deleted\n&quot;);</a>
<a name="20620"><span class="lineNum">   20620 </span>            :                                         }</a>
<a name="20621"><span class="lineNum">   20621 </span>            : </a>
<a name="20622"><span class="lineNum">   20622 </span>            :                                 }</a>
<a name="20623"><span class="lineNum">   20623 </span>            : </a>
<a name="20624"><span class="lineNum">   20624 </span><span class="lineCov">       1342 :                                 if(isSgClassNameRefExp(node) !=NULL){</span></a>
<a name="20625"><span class="lineNum">   20625 </span><span class="lineNoCov">          0 :                                         SgSymbol* symbol = ((SgClassNameRefExp*)node)-&gt;get_symbol();</span></a>
<a name="20626"><span class="lineNum">   20626 </span><span class="lineNoCov">          0 :                                         if(isSgClassSymbol(symbol) !=NULL)</span></a>
<a name="20627"><span class="lineNum">   20627 </span>            :                                         {</a>
<a name="20628"><span class="lineNum">   20628 </span><span class="lineNoCov">          0 :                                                 ClassicVisitor visitor((SgClassSymbol*)symbol);</span></a>
<a name="20629"><span class="lineNum">   20629 </span><span class="lineNoCov">          0 :                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20630"><span class="lineNum">   20630 </span><span class="lineNoCov">          0 :                                                 if(visitor.get_num_Class_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</span></a>
<a name="20631"><span class="lineNum">   20631 </span><span class="lineNoCov">          0 :                                                         ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20632"><span class="lineNum">   20632 </span><span class="lineNoCov">          0 :                                                         delete symbol;</span></a>
<a name="20633"><span class="lineNum">   20633 </span>            :                                                         //printf(&quot;A SgClassSymbol was deleted\n&quot;);</a>
<a name="20634"><span class="lineNum">   20634 </span>            :                                                 }</a>
<a name="20635"><span class="lineNum">   20635 </span>            :                                         }</a>
<a name="20636"><span class="lineNum">   20636 </span>            :                                 }</a>
<a name="20637"><span class="lineNum">   20637 </span>            : </a>
<a name="20638"><span class="lineNum">   20638 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20639"><span class="lineNum">   20639 </span>            :                                 /remove SgMemberFunctionSymbol</a>
<a name="20640"><span class="lineNum">   20640 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20641"><span class="lineNum">   20641 </span>            : </a>
<a name="20642"><span class="lineNum">   20642 </span>            : </a>
<a name="20643"><span class="lineNum">   20643 </span><span class="lineCov">       1342 :                                 if(isSgMemberFunctionDeclaration(node) !=NULL){</span></a>
<a name="20644"><span class="lineNum">   20644 </span><span class="lineNoCov">          0 :                                         if(((SgMemberFunctionDeclaration*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20645"><span class="lineNum">   20645 </span><span class="lineNoCov">          0 :                                              if(((SgMemberFunctionDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20646"><span class="lineNum">   20646 </span>            :                                                 {</a>
<a name="20647"><span class="lineNum">   20647 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgMemberFunctionDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20648"><span class="lineNum">   20648 </span><span class="lineNoCov">          0 :                                                         if(isSgMemberFunctionSymbol(symbol)){</span></a>
<a name="20649"><span class="lineNum">   20649 </span><span class="lineNoCov">          0 :                                                                 ClassicVisitor visitor((SgMemberFunctionSymbol*)symbol);</span></a>
<a name="20650"><span class="lineNum">   20650 </span><span class="lineNoCov">          0 :                                                                 traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20651"><span class="lineNum">   20651 </span><span class="lineNoCov">          0 :                                                                 if(visitor.get_num_memFunc_pointers()==1){</span></a>
<a name="20652"><span class="lineNum">   20652 </span><span class="lineNoCov">          0 :                                                                         ((SgMemberFunctionDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20653"><span class="lineNum">   20653 </span><span class="lineNoCov">          0 :                                                                         delete symbol;</span></a>
<a name="20654"><span class="lineNum">   20654 </span>            :                                                                         //printf(&quot;A SgMemberFunctionSymbol was deleted\n&quot;);</a>
<a name="20655"><span class="lineNum">   20655 </span>            :                                                                 }</a>
<a name="20656"><span class="lineNum">   20656 </span>            :                                                         }</a>
<a name="20657"><span class="lineNum">   20657 </span>            :                                                 }</a>
<a name="20658"><span class="lineNum">   20658 </span>            :                                         }</a>
<a name="20659"><span class="lineNum">   20659 </span><span class="lineNoCov">          0 :                                         ClassicVisitor visitor((SgMemberFunctionDeclaration*) node);</span></a>
<a name="20660"><span class="lineNum">   20660 </span><span class="lineNoCov">          0 :                                         traverseMemoryPoolVisitorPattern(visitor);</span></a>
<a name="20661"><span class="lineNum">   20661 </span>            : </a>
<a name="20662"><span class="lineNum">   20662 </span>            :                                 }</a>
<a name="20663"><span class="lineNum">   20663 </span>            : //Tan: I have no idea why the codes below cannot work. Perhaps it conflicts with some prior works</a>
<a name="20664"><span class="lineNum">   20664 </span>            : #if 0</a>
<a name="20665"><span class="lineNum">   20665 </span>            :                                 if(isSgMemberFunctionRefExp(node) !=NULL){</a>
<a name="20666"><span class="lineNum">   20666 </span>            :                                         SgMemberFunctionSymbol* symbol = ((SgMemberFunctionRefExp*)node)-&gt;get_symbol_i();</a>
<a name="20667"><span class="lineNum">   20667 </span>            :                                         ClassicVisitor visitor(symbol);</a>
<a name="20668"><span class="lineNum">   20668 </span>            :                                         traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20669"><span class="lineNum">   20669 </span>            :                                         if(visitor.get_num_memFunc_pointers()==1){ //only one reference to this symbol =&gt; safe to delete</a>
<a name="20670"><span class="lineNum">   20670 </span>            :                                                 ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20671"><span class="lineNum">   20671 </span>            :                                                 delete symbol;</a>
<a name="20672"><span class="lineNum">   20672 </span>            :                                                 //printf(&quot;A SgClassSymbol was deleted\n&quot;);</a>
<a name="20673"><span class="lineNum">   20673 </span>            :                                         }</a>
<a name="20674"><span class="lineNum">   20674 </span>            : </a>
<a name="20675"><span class="lineNum">   20675 </span>            :                                 }</a>
<a name="20676"><span class="lineNum">   20676 </span>            : </a>
<a name="20677"><span class="lineNum">   20677 </span>            :                                 if(isSgFunctionType(node) !=NULL){</a>
<a name="20678"><span class="lineNum">   20678 </span>            :                                         SgSymbol* symbol = ((SgFunctionType*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20679"><span class="lineNum">   20679 </span>            :                                         if(isSgFunctionTypeSymbol(symbol)){</a>
<a name="20680"><span class="lineNum">   20680 </span>            :                                                 ((SgSymbol*)symbol)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20681"><span class="lineNum">   20681 </span>            :                                                 delete symbol;</a>
<a name="20682"><span class="lineNum">   20682 </span>            :                                                 //printf(&quot;A SgFunctionTypeSymbol was deleted\n&quot;);</a>
<a name="20683"><span class="lineNum">   20683 </span>            :                                         }</a>
<a name="20684"><span class="lineNum">   20684 </span>            :                                 }</a>
<a name="20685"><span class="lineNum">   20685 </span>            : #endif</a>
<a name="20686"><span class="lineNum">   20686 </span>            : </a>
<a name="20687"><span class="lineNum">   20687 </span>            :                                 /*////////////////////////////////////////////////</a>
<a name="20688"><span class="lineNum">   20688 </span>            :                                 /remove SgInterfaceSymbol and SgModuleSymbol</a>
<a name="20689"><span class="lineNum">   20689 </span>            :                                 /////////////////////////////////////////////////*/</a>
<a name="20690"><span class="lineNum">   20690 </span>            : </a>
<a name="20691"><span class="lineNum">   20691 </span><span class="lineCov">       1342 :                                 if(isSgInterfaceStatement(node) !=NULL){</span></a>
<a name="20692"><span class="lineNum">   20692 </span><span class="lineNoCov">          0 :                                         if(((SgDeclarationStatement*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20693"><span class="lineNum">   20693 </span><span class="lineNoCov">          0 :                                              if(((SgDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20694"><span class="lineNum">   20694 </span>            :                                                 {</a>
<a name="20695"><span class="lineNum">   20695 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgDeclarationStatement*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20696"><span class="lineNum">   20696 </span><span class="lineNoCov">          0 :                                                         if(isSgInterfaceSymbol(symbol)){</span></a>
<a name="20697"><span class="lineNum">   20697 </span><span class="lineNoCov">          0 :                                                                 ((SgDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20698"><span class="lineNum">   20698 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20699"><span class="lineNum">   20699 </span>            :                                                                 //printf(&quot;A SgInterfaceSymbol was deleted\n&quot;);</a>
<a name="20700"><span class="lineNum">   20700 </span>            :                                                         }</a>
<a name="20701"><span class="lineNum">   20701 </span>            :                                                 }</a>
<a name="20702"><span class="lineNum">   20702 </span>            :                                         }</a>
<a name="20703"><span class="lineNum">   20703 </span>            : </a>
<a name="20704"><span class="lineNum">   20704 </span>            :                                 }</a>
<a name="20705"><span class="lineNum">   20705 </span>            : </a>
<a name="20706"><span class="lineNum">   20706 </span>            : </a>
<a name="20707"><span class="lineNum">   20707 </span><span class="lineCov">       1342 :                                 if(isSgModuleStatement(node) !=NULL){</span></a>
<a name="20708"><span class="lineNum">   20708 </span><span class="lineNoCov">          0 :                                         if(((SgClassDeclaration*)node)-&gt;get_scope()!=NULL){</span></a>
<a name="20709"><span class="lineNum">   20709 </span><span class="lineNoCov">          0 :                                              if(((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</span></a>
<a name="20710"><span class="lineNum">   20710 </span>            :                                                 {</a>
<a name="20711"><span class="lineNum">   20711 </span><span class="lineNoCov">          0 :                                                         SgSymbol* symbol = ((SgClassDeclaration*)node)-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20712"><span class="lineNum">   20712 </span><span class="lineNoCov">          0 :                                                         if(isSgModuleSymbol(symbol)){</span></a>
<a name="20713"><span class="lineNum">   20713 </span><span class="lineNoCov">          0 :                                                                 ((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</span></a>
<a name="20714"><span class="lineNum">   20714 </span><span class="lineNoCov">          0 :                                                                 delete symbol;</span></a>
<a name="20715"><span class="lineNum">   20715 </span>            :                                                                 //printf(&quot;A SgModuleSymbol was deleted\n&quot;);</a>
<a name="20716"><span class="lineNum">   20716 </span>            :                                                         }</a>
<a name="20717"><span class="lineNum">   20717 </span>            :                                                 }</a>
<a name="20718"><span class="lineNum">   20718 </span>            :                                         }</a>
<a name="20719"><span class="lineNum">   20719 </span>            : </a>
<a name="20720"><span class="lineNum">   20720 </span>            :                                 }</a>
<a name="20721"><span class="lineNum">   20721 </span>            : </a>
<a name="20722"><span class="lineNum">   20722 </span>            : </a>
<a name="20723"><span class="lineNum">   20723 </span>            : //Tan: I got stuck in deleting the SgTemplateArgument</a>
<a name="20724"><span class="lineNum">   20724 </span>            : #if 0</a>
<a name="20725"><span class="lineNum">   20725 </span>            :                                 if(isSgTemplateInstantiationMemberFunctionDecl(node) !=NULL){</a>
<a name="20726"><span class="lineNum">   20726 </span>            :                                         if(((SgTemplateInstantiationMemberFunctionDecl*)node)-&gt;get_scope()!=NULL){</a>
<a name="20727"><span class="lineNum">   20727 </span>            :                                              if(((SgTemplateInstantiationMemberFunctionDecl*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</a>
<a name="20728"><span class="lineNum">   20728 </span>            :                                                 {</a>
<a name="20729"><span class="lineNum">   20729 </span>            :                                                         SgSymbol* symbol = ((SgTemplateInstantiationMemberFunctionDecl*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20730"><span class="lineNum">   20730 </span>            :                                                         if(isSgMemberFunctionSymbol(symbol)){</a>
<a name="20731"><span class="lineNum">   20731 </span>            :                                                                 ClassicVisitor visitor((SgMemberFunctionSymbol*)symbol);</a>
<a name="20732"><span class="lineNum">   20732 </span>            :                                                                 traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20733"><span class="lineNum">   20733 </span>            :                                                                 if(visitor.get_num_memFunc_pointers()==1){</a>
<a name="20734"><span class="lineNum">   20734 </span>            :                                                                         ((SgMemberFunctionDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20735"><span class="lineNum">   20735 </span>            :                                                                         delete symbol;</a>
<a name="20736"><span class="lineNum">   20736 </span>            :                                                                         //printf(&quot;A SgMemberFunctionSymbol was deleted\n&quot;);</a>
<a name="20737"><span class="lineNum">   20737 </span>            :                                                                 }</a>
<a name="20738"><span class="lineNum">   20738 </span>            :                                                         }</a>
<a name="20739"><span class="lineNum">   20739 </span>            :                                                 }</a>
<a name="20740"><span class="lineNum">   20740 </span>            :                                         }</a>
<a name="20741"><span class="lineNum">   20741 </span>            :                                         ClassicVisitor visitor((SgMemberFunctionDeclaration*) node);</a>
<a name="20742"><span class="lineNum">   20742 </span>            :                                         traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20743"><span class="lineNum">   20743 </span>            :                                 }</a>
<a name="20744"><span class="lineNum">   20744 </span>            : </a>
<a name="20745"><span class="lineNum">   20745 </span>            :                                 if(isSgTemplateDeclaration(node) !=NULL){</a>
<a name="20746"><span class="lineNum">   20746 </span>            :                                         if(((SgTemplateDeclaration*)node)-&gt;get_scope()!=NULL){</a>
<a name="20747"><span class="lineNum">   20747 </span>            :                                              if(((SgTemplateDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</a>
<a name="20748"><span class="lineNum">   20748 </span>            :                                                 {</a>
<a name="20749"><span class="lineNum">   20749 </span>            :                                                         SgSymbol* symbol = ((SgTemplateDeclaration*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20750"><span class="lineNum">   20750 </span>            :                                                         ClassicVisitor visitor((SgTemplateSymbol*)symbol);</a>
<a name="20751"><span class="lineNum">   20751 </span>            :                                                         traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20752"><span class="lineNum">   20752 </span>            :                                                         if(visitor.get_num_Template_pointers()==1){</a>
<a name="20753"><span class="lineNum">   20753 </span>            :                                                                         ((SgTemplateDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20754"><span class="lineNum">   20754 </span>            :                                                                         delete symbol;</a>
<a name="20755"><span class="lineNum">   20755 </span>            :                                                                         printf(&quot;A SgTemplateSymbol was deleted\n&quot;);</a>
<a name="20756"><span class="lineNum">   20756 </span>            :                                                         }</a>
<a name="20757"><span class="lineNum">   20757 </span>            :                                                 }</a>
<a name="20758"><span class="lineNum">   20758 </span>            :                                         }</a>
<a name="20759"><span class="lineNum">   20759 </span>            :                                         //if(isSgTemplateDeclaration(node) == ((SgTemplateDeclaration*)node)-&gt;get_firstNondefiningDeclaration()){</a>
<a name="20760"><span class="lineNum">   20760 </span>            :                                                 ClassicVisitor visitor1((SgTemplateDeclaration*) node );</a>
<a name="20761"><span class="lineNum">   20761 </span>            :                                                 traverseMemoryPoolVisitorPattern(visitor1);</a>
<a name="20762"><span class="lineNum">   20762 </span>            :                                         //}</a>
<a name="20763"><span class="lineNum">   20763 </span>            : </a>
<a name="20764"><span class="lineNum">   20764 </span>            :                                 }</a>
<a name="20765"><span class="lineNum">   20765 </span>            : </a>
<a name="20766"><span class="lineNum">   20766 </span>            :                                 if(isSgInterfaceStatement(node) !=NULL){</a>
<a name="20767"><span class="lineNum">   20767 </span>            :                                         if(((SgDeclarationStatement*)node)-&gt;get_scope()!=NULL){</a>
<a name="20768"><span class="lineNum">   20768 </span>            :                                              if(((SgDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</a>
<a name="20769"><span class="lineNum">   20769 </span>            :                                                 {</a>
<a name="20770"><span class="lineNum">   20770 </span>            :                                                         SgSymbol* symbol = ((SgDeclarationStatement*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20771"><span class="lineNum">   20771 </span>            :                                                         if(isSgInterfaceSymbol(symbol)){</a>
<a name="20772"><span class="lineNum">   20772 </span>            :                                                                 ((SgDeclarationStatement*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20773"><span class="lineNum">   20773 </span>            :                                                                 delete symbol;</a>
<a name="20774"><span class="lineNum">   20774 </span>            :                                                                 //printf(&quot;A SgInterfaceSymbol was deleted\n&quot;);</a>
<a name="20775"><span class="lineNum">   20775 </span>            :                                                         }</a>
<a name="20776"><span class="lineNum">   20776 </span>            :                                                 }</a>
<a name="20777"><span class="lineNum">   20777 </span>            :                                         }</a>
<a name="20778"><span class="lineNum">   20778 </span>            : </a>
<a name="20779"><span class="lineNum">   20779 </span>            :                                 }</a>
<a name="20780"><span class="lineNum">   20780 </span>            : </a>
<a name="20781"><span class="lineNum">   20781 </span>            : </a>
<a name="20782"><span class="lineNum">   20782 </span>            :                                 if(isSgModuleStatement(node) !=NULL){</a>
<a name="20783"><span class="lineNum">   20783 </span>            :                                         if(((SgClassDeclaration*)node)-&gt;get_scope()!=NULL){</a>
<a name="20784"><span class="lineNum">   20784 </span>            :                                              if(((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</a>
<a name="20785"><span class="lineNum">   20785 </span>            :                                                 {</a>
<a name="20786"><span class="lineNum">   20786 </span>            :                                                         SgSymbol* symbol = ((SgClassDeclaration*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20787"><span class="lineNum">   20787 </span>            :                                                         if(isSgModuleSymbol(symbol)){</a>
<a name="20788"><span class="lineNum">   20788 </span>            :                                                                 ((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20789"><span class="lineNum">   20789 </span>            :                                                                 delete symbol;</a>
<a name="20790"><span class="lineNum">   20790 </span>            :                                                                 //printf(&quot;A SgModuleSymbol was deleted\n&quot;);</a>
<a name="20791"><span class="lineNum">   20791 </span>            :                                                         }</a>
<a name="20792"><span class="lineNum">   20792 </span>            :                                                 }</a>
<a name="20793"><span class="lineNum">   20793 </span>            :                                         }</a>
<a name="20794"><span class="lineNum">   20794 </span>            : </a>
<a name="20795"><span class="lineNum">   20795 </span>            :                                 }</a>
<a name="20796"><span class="lineNum">   20796 </span>            : </a>
<a name="20797"><span class="lineNum">   20797 </span>            :                                 if(isSgTemplateInstantiationDecl(node) !=NULL){</a>
<a name="20798"><span class="lineNum">   20798 </span>            :                                         if(((SgTemplateInstantiationDecl*)node)-&gt;get_scope()!=NULL){</a>
<a name="20799"><span class="lineNum">   20799 </span>            :                                              if(((SgTemplateInstantiationDecl*)node)-&gt;get_scope()-&gt;get_symbol_table()!=NULL)</a>
<a name="20800"><span class="lineNum">   20800 </span>            :                                                 {</a>
<a name="20801"><span class="lineNum">   20801 </span>            :                                                         SgSymbol* symbol = ((SgTemplateInstantiationDecl*)node)-&gt;get_symbol_from_symbol_table();</a>
<a name="20802"><span class="lineNum">   20802 </span>            :                                                         if(isSgClassSymbol(symbol)){</a>
<a name="20803"><span class="lineNum">   20803 </span>            :                                                                 ClassicVisitor visitor((SgClassSymbol*)symbol);</a>
<a name="20804"><span class="lineNum">   20804 </span>            :                                                                 traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20805"><span class="lineNum">   20805 </span>            :                                                                 if(visitor.get_num_Class_pointers()==1){</a>
<a name="20806"><span class="lineNum">   20806 </span>            :                                                                         ((SgClassDeclaration*)node)-&gt;get_scope()-&gt;get_symbol_table()-&gt;remove(symbol);</a>
<a name="20807"><span class="lineNum">   20807 </span>            :                                                                         delete symbol;</a>
<a name="20808"><span class="lineNum">   20808 </span>            :                                                                 }</a>
<a name="20809"><span class="lineNum">   20809 </span>            :                                                         }</a>
<a name="20810"><span class="lineNum">   20810 </span>            :                                                 }</a>
<a name="20811"><span class="lineNum">   20811 </span>            :                                         }</a>
<a name="20812"><span class="lineNum">   20812 </span>            :                                         SgClassType* type= ((SgClassDeclaration*)node)-&gt;get_type();</a>
<a name="20813"><span class="lineNum">   20813 </span>            :                                         if(type !=NULL){</a>
<a name="20814"><span class="lineNum">   20814 </span>            :                                                 delete type;</a>
<a name="20815"><span class="lineNum">   20815 </span>            :                                                 //printf(&quot;A SgClassType was deleted\n&quot;);</a>
<a name="20816"><span class="lineNum">   20816 </span>            :                                         }</a>
<a name="20817"><span class="lineNum">   20817 </span>            : </a>
<a name="20818"><span class="lineNum">   20818 </span>            :                                         vector&lt;SgTemplateArgument*&gt; tempargs=  ((SgTemplateInstantiationDecl*)node)-&gt;get_templateArguments();</a>
<a name="20819"><span class="lineNum">   20819 </span>            :                                         foreach (SgTemplateArgument* element, tempargs){</a>
<a name="20820"><span class="lineNum">   20820 </span>            :                                                 SgTemplateArgument* temparg = isSgTemplateArgument(element);</a>
<a name="20821"><span class="lineNum">   20821 </span>            :                                                 if(temparg){</a>
<a name="20822"><span class="lineNum">   20822 </span>            :                                                         delete temparg;</a>
<a name="20823"><span class="lineNum">   20823 </span>            :                                                 }</a>
<a name="20824"><span class="lineNum">   20824 </span>            :                                                 printf(&quot;SgTemplateArg in normal traversal\n&quot;);</a>
<a name="20825"><span class="lineNum">   20825 </span>            :                                         }</a>
<a name="20826"><span class="lineNum">   20826 </span>            :                                         printf(&quot;SgTemplateInstantiationDecl in normal traversal\n&quot;);</a>
<a name="20827"><span class="lineNum">   20827 </span>            : </a>
<a name="20828"><span class="lineNum">   20828 </span>            :                                         ClassicVisitor visitor((SgTemplateInstantiationDecl*) node);</a>
<a name="20829"><span class="lineNum">   20829 </span>            :                                         traverseMemoryPoolVisitorPattern(visitor);</a>
<a name="20830"><span class="lineNum">   20830 </span>            :                                 }</a>
<a name="20831"><span class="lineNum">   20831 </span>            : </a>
<a name="20832"><span class="lineNum">   20832 </span>            : #endif</a>
<a name="20833"><span class="lineNum">   20833 </span>            : #if 0</a>
<a name="20834"><span class="lineNum">   20834 </span>            :                         printf (&quot;Deleting node = %p = %s = %s \n&quot;,node,node-&gt;class_name().c_str(),SageInterface::get_name(node).c_str());</a>
<a name="20835"><span class="lineNum">   20835 </span>            : #endif</a>
<a name="20836"><span class="lineNum">   20836 </span>            :                      // Normal nodes  will be removed in a post-order way</a>
<a name="20837"><span class="lineNum">   20837 </span><span class="lineCov">       1342 :                         delete node;</span></a>
<a name="20838"><span class="lineNum">   20838 </span>            : #if 0</a>
<a name="20839"><span class="lineNum">   20839 </span>            :                         printf (&quot;After delete node: node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="20840"><span class="lineNum">   20840 </span>            : #endif</a>
<a name="20841"><span class="lineNum">   20841 </span><span class="lineCov">       1342 :                         }</span></a>
<a name="20842"><span class="lineNum">   20842 </span>            :                 };</a>
<a name="20843"><span class="lineNum">   20843 </span>            : </a>
<a name="20844"><span class="lineNum">   20844 </span>            : </a>
<a name="20845"><span class="lineNum">   20845 </span><span class="lineCov">        518 :           DeleteAST deleteTree;</span></a>
<a name="20846"><span class="lineNum">   20846 </span>            : </a>
<a name="20847"><span class="lineNum">   20847 </span>            :           // Deletion must happen in post-order to avoid traversal of (visiting) deleted IR nodes</a>
<a name="20848"><span class="lineNum">   20848 </span><span class="lineCov">        518 :           deleteTree.traverse(n,postorder);</span></a>
<a name="20849"><span class="lineNum">   20849 </span>            : </a>
<a name="20850"><span class="lineNum">   20850 </span>            : #if 0</a>
<a name="20851"><span class="lineNum">   20851 </span>            :      printf (&quot;Leaving SageInterface::deleteAST(): n = %p = %s \n&quot;,n,n-&gt;class_name().c_str());</a>
<a name="20852"><span class="lineNum">   20852 </span>            : #endif</a>
<a name="20853"><span class="lineNum">   20853 </span><span class="lineCov">        518 :    }</span></a>
<a name="20854"><span class="lineNum">   20854 </span>            : </a>
<a name="20855"><span class="lineNum">   20855 </span>            : </a>
<a name="20856"><span class="lineNum">   20856 </span>            : </a>
<a name="20857"><span class="lineNum">   20857 </span>            : </a>
<a name="20858"><span class="lineNum">   20858 </span>            : #ifndef USE_ROSE</a>
<a name="20859"><span class="lineNum">   20859 </span>            : // DQ (9/25/2011):  The deleteAST() function will not remove original expression trees behind constant folded expressions.</a>
<a name="20860"><span class="lineNum">   20860 </span>            : // These exist in the AST within the internal construction of the AST until they are simplified in the AST post-processing.</a>
<a name="20861"><span class="lineNum">   20861 </span>            : // In the post-processing either:</a>
<a name="20862"><span class="lineNum">   20862 </span>            : //    1) the constant folded values are kept and the original expression trees deleted (optional, controled by default parameter to function &quot;frontend()&quot;, OR</a>
<a name="20863"><span class="lineNum">   20863 </span>            : //    2) the constant folded values are replaced by the original expression trees, and the constant folded values are deleted (default).</a>
<a name="20864"><span class="lineNum">   20864 </span>            : // Either way, after the AST post-processing the AST is simplified.  Until then the expression trees can contain constant</a>
<a name="20865"><span class="lineNum">   20865 </span>            : // folded values and the values will have a pointer to the original expression tree.  Before (9/16/2011) the original</a>
<a name="20866"><span class="lineNum">   20866 </span>            : // tree would also sometimes (not uniformally) be traversed as part of the AST.  This was confusing (to people and</a>
<a name="20867"><span class="lineNum">   20867 </span>            : // to numerous forms of analysis), so this is being fixed to be uniform (using either of the methods defined above).</a>
<a name="20868"><span class="lineNum">   20868 </span>            : // However, the fact that until post-processing the AST has this complexity, and that the AST traversal does not</a>
<a name="20869"><span class="lineNum">   20869 </span>            : // traverse the original expression trees (now uniform); means that we need a special delete function for subtrees</a>
<a name="20870"><span class="lineNum">   20870 </span>            : // that are not use post-processed.  This is the special purpose function that we need.</a>
<a name="20871"><span class="lineNum">   20871 </span>            : //</a>
<a name="20872"><span class="lineNum">   20872 </span>            : // NOTE: This function is called from the SgArrayType::createType() member function and in the constant folding AST post-processing.</a>
<a name="20873"><span class="lineNum">   20873 </span>            : //</a>
<a name="20874"><span class="lineNum">   20874 </span><span class="lineNoCov">          0 : void SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees(SgNode* root)</span></a>
<a name="20875"><span class="lineNum">   20875 </span>            :    {</a>
<a name="20876"><span class="lineNum">   20876 </span><span class="lineNoCov">          0 :      struct Visitor: public AstSimpleProcessing</span></a>
<a name="20877"><span class="lineNum">   20877 </span>            :         {</a>
<a name="20878"><span class="lineNum">   20878 </span><span class="lineNoCov">          0 :           virtual void visit(SgNode* n)</span></a>
<a name="20879"><span class="lineNum">   20879 </span>            :              {</a>
<a name="20880"><span class="lineNum">   20880 </span><span class="lineNoCov">          0 :                SgExpression* expression = isSgExpression(n);</span></a>
<a name="20881"><span class="lineNum">   20881 </span><span class="lineNoCov">          0 :                if (expression != NULL)</span></a>
<a name="20882"><span class="lineNum">   20882 </span>            :                   {</a>
<a name="20883"><span class="lineNum">   20883 </span><span class="lineNoCov">          0 :                     Visitor().traverse(expression-&gt;get_originalExpressionTree(), postorder);</span></a>
<a name="20884"><span class="lineNum">   20884 </span>            :                   }</a>
<a name="20885"><span class="lineNum">   20885 </span>            : </a>
<a name="20886"><span class="lineNum">   20886 </span><span class="lineNoCov">          0 :                delete (n);</span></a>
<a name="20887"><span class="lineNum">   20887 </span><span class="lineNoCov">          0 :              }</span></a>
<a name="20888"><span class="lineNum">   20888 </span>            :         };</a>
<a name="20889"><span class="lineNum">   20889 </span>            : </a>
<a name="20890"><span class="lineNum">   20890 </span><span class="lineNoCov">          0 :      Visitor().traverse(root, postorder);</span></a>
<a name="20891"><span class="lineNum">   20891 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="20892"><span class="lineNum">   20892 </span>            : #endif</a>
<a name="20893"><span class="lineNum">   20893 </span>            :   // move symbol table from one scope to another</a>
<a name="20894"><span class="lineNum">   20894 </span><span class="lineNoCov">          0 : static void moveSymbolTableBetweenBlocks(SgScopeStatement* sourceBlock, SgScopeStatement* targetBlock, std::vector &lt;SgInitializedName*&gt;&amp; initname_vec)</span></a>
<a name="20895"><span class="lineNum">   20895 </span>            : {</a>
<a name="20896"><span class="lineNum">   20896 </span>            :   // Move the symbol table</a>
<a name="20897"><span class="lineNum">   20897 </span><span class="lineNoCov">          0 :   SgSymbolTable* s_table = sourceBlock-&gt;get_symbol_table();</span></a>
<a name="20898"><span class="lineNum">   20898 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(sourceBlock-&gt;get_symbol_table() != NULL);</span></a>
<a name="20899"><span class="lineNum">   20899 </span>            :   // Liao, 11/26/2019 make sure the symbol table has symbols for init names before and after the move</a>
<a name="20900"><span class="lineNum">   20900 </span><span class="lineNoCov">          0 :   for (std::vector&lt;SgInitializedName* &gt;::iterator iter = initname_vec.begin(); iter != initname_vec.end(); iter++)</span></a>
<a name="20901"><span class="lineNum">   20901 </span>            :   {</a>
<a name="20902"><span class="lineNum">   20902 </span><span class="lineNoCov">          0 :     SgInitializedName* iname = *iter;</span></a>
<a name="20903"><span class="lineNum">   20903 </span><span class="lineNoCov">          0 :     SgSymbol* symbol = s_table-&gt;find(iname);</span></a>
<a name="20904"><span class="lineNum">   20904 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (symbol != NULL);</span></a>
<a name="20905"><span class="lineNum">   20905 </span>            :   }</a>
<a name="20906"><span class="lineNum">   20906 </span>            :   // entirely move source block's symbol table to target block</a>
<a name="20907"><span class="lineNum">   20907 </span><span class="lineNoCov">          0 :   targetBlock-&gt;set_symbol_table(sourceBlock-&gt;get_symbol_table());</span></a>
<a name="20908"><span class="lineNum">   20908 </span>            : </a>
<a name="20909"><span class="lineNum">   20909 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(sourceBlock != NULL);</span></a>
<a name="20910"><span class="lineNum">   20910 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(targetBlock != NULL);</span></a>
<a name="20911"><span class="lineNum">   20911 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(targetBlock-&gt;get_symbol_table() != NULL);</span></a>
<a name="20912"><span class="lineNum">   20912 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(sourceBlock-&gt;get_symbol_table() != NULL);</span></a>
<a name="20913"><span class="lineNum">   20913 </span><span class="lineNoCov">          0 :   targetBlock-&gt;get_symbol_table()-&gt;set_parent(targetBlock);</span></a>
<a name="20914"><span class="lineNum">   20914 </span>            : </a>
<a name="20915"><span class="lineNum">   20915 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(sourceBlock-&gt;get_symbol_table() != NULL);</span></a>
<a name="20916"><span class="lineNum">   20916 </span><span class="lineNoCov">          0 :   sourceBlock-&gt;set_symbol_table(NULL);</span></a>
<a name="20917"><span class="lineNum">   20917 </span>            : </a>
<a name="20918"><span class="lineNum">   20918 </span>            :   // DQ (9/23/2011): Reset with a valid symbol table.</a>
<a name="20919"><span class="lineNum">   20919 </span><span class="lineNoCov">          0 :   sourceBlock-&gt;set_symbol_table(new SgSymbolTable());</span></a>
<a name="20920"><span class="lineNum">   20920 </span><span class="lineNoCov">          0 :   sourceBlock-&gt;get_symbol_table()-&gt;set_parent(sourceBlock);</span></a>
<a name="20921"><span class="lineNum">   20921 </span>            : </a>
<a name="20922"><span class="lineNum">   20922 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (targetBlock-&gt;get_symbol_table() == s_table);</span></a>
<a name="20923"><span class="lineNum">   20923 </span><span class="lineNoCov">          0 :   for (std::vector&lt;SgInitializedName* &gt;::iterator iter = initname_vec.begin(); iter != initname_vec.end(); iter++)</span></a>
<a name="20924"><span class="lineNum">   20924 </span>            :   {</a>
<a name="20925"><span class="lineNum">   20925 </span><span class="lineNoCov">          0 :     SgInitializedName* iname = *iter;</span></a>
<a name="20926"><span class="lineNum">   20926 </span><span class="lineNoCov">          0 :     SgSymbol* symbol = s_table-&gt;find(iname);</span></a>
<a name="20927"><span class="lineNum">   20927 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (symbol != NULL);</span></a>
<a name="20928"><span class="lineNum">   20928 </span>            :   }</a>
<a name="20929"><span class="lineNum">   20929 </span>            : </a>
<a name="20930"><span class="lineNum">   20930 </span>            :   // Liao, 11/26/2019 make sure init names have symbols after the move.</a>
<a name="20931"><span class="lineNum">   20931 </span><span class="lineNoCov">          0 :   for (std::vector&lt;SgInitializedName* &gt;::iterator iter = initname_vec.begin(); iter != initname_vec.end(); iter++)</span></a>
<a name="20932"><span class="lineNum">   20932 </span>            :   {</a>
<a name="20933"><span class="lineNum">   20933 </span><span class="lineNoCov">          0 :     SgInitializedName* iname = *iter;</span></a>
<a name="20934"><span class="lineNum">   20934 </span><span class="lineNoCov">          0 :     SgSymbol* symbol = iname-&gt;get_symbol_from_symbol_table();</span></a>
<a name="20935"><span class="lineNum">   20935 </span><span class="lineNoCov">          0 :     ROSE_ASSERT (symbol != NULL);</span></a>
<a name="20936"><span class="lineNum">   20936 </span>            :   }</a>
<a name="20937"><span class="lineNum">   20937 </span><span class="lineNoCov">          0 : }</span></a>
<a name="20938"><span class="lineNum">   20938 </span>            : </a>
<a name="20939"><span class="lineNum">   20939 </span>            : // helper function to move a single statement or declaration from a block to another</a>
<a name="20940"><span class="lineNum">   20940 </span><span class="lineNoCov">          0 : static void moveOneStatement(SgScopeStatement* sourceBlock, SgScopeStatement* targetBlock, SgStatement* stmt, std::vector &lt;SgInitializedName*&gt;&amp; initname_vec)</span></a>
<a name="20941"><span class="lineNum">   20941 </span>            : {</a>
<a name="20942"><span class="lineNum">   20942 </span>            :   // append statement to the target block</a>
<a name="20943"><span class="lineNum">   20943 </span><span class="lineNoCov">          0 :   targetBlock-&gt;append_statement(stmt);</span></a>
<a name="20944"><span class="lineNum">   20944 </span>            : </a>
<a name="20945"><span class="lineNum">   20945 </span>            :   // Make sure that the parents are set.</a>
<a name="20946"><span class="lineNum">   20946 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(stmt-&gt;get_parent() == targetBlock);</span></a>
<a name="20947"><span class="lineNum">   20947 </span><span class="lineNoCov">          0 :   if (stmt-&gt;hasExplicitScope())</span></a>
<a name="20948"><span class="lineNum">   20948 </span>            :   {</a>
<a name="20949"><span class="lineNum">   20949 </span>            :     // DQ (3/4/2009): This fails the test in ROSE/tutorial/outliner/inputCode_OutlineNonLocalJumps.cc</a>
<a name="20950"><span class="lineNum">   20950 </span>            :     // I am unclear if this is a reasonable constraint, it passes all tests but this one!</a>
<a name="20951"><span class="lineNum">   20951 </span><span class="lineNoCov">          0 :     if (stmt-&gt;get_scope() != targetBlock)</span></a>
<a name="20952"><span class="lineNum">   20952 </span>            :     {</a>
<a name="20953"><span class="lineNum">   20953 </span><span class="lineNoCov">          0 :       if (SgFunctionDeclaration* func = isSgFunctionDeclaration(stmt))</span></a>
<a name="20954"><span class="lineNum">   20954 </span>            :       {</a>
<a name="20955"><span class="lineNum">   20955 </span>            : </a>
<a name="20956"><span class="lineNum">   20956 </span>            :         // why only move if it is a first nondefining declaration?</a>
<a name="20957"><span class="lineNum">   20957 </span>            :         // We have a case to move both defining and nondefining function declarations of Ada package body to namespace definition.</a>
<a name="20958"><span class="lineNum">   20958 </span>            :          // comment out the if condition for now. 1/20/2021</a>
<a name="20959"><span class="lineNum">   20959 </span>            :         //</a>
<a name="20960"><span class="lineNum">   20960 </span>            :         // A call to a undeclared function will introduce a hidden func prototype declaration in the enclosing scope .</a>
<a name="20961"><span class="lineNum">   20961 </span>            :         // The func declaration should be moved along with the call site.</a>
<a name="20962"><span class="lineNum">   20962 </span>            :         // The scope should be set to the new block also</a>
<a name="20963"><span class="lineNum">   20963 </span>            :         // Liao 1/14/2011</a>
<a name="20964"><span class="lineNum">   20964 </span>            :         // if (func-&gt;get_firstNondefiningDeclaration() == func)</a>
<a name="20965"><span class="lineNum">   20965 </span><span class="lineNoCov">          0 :           func-&gt;set_scope(targetBlock);</span></a>
<a name="20966"><span class="lineNum">   20966 </span>            :           // This is needed to move functions in Ada package body into C++ namespace</a>
<a name="20967"><span class="lineNum">   20967 </span>            :           // We may have compiler generated first nondefining declaration. We need to move its scope also</a>
<a name="20968"><span class="lineNum">   20968 </span><span class="lineNoCov">          0 :           SgFunctionDeclaration* nondef_decl= isSgFunctionDeclaration(func-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="20969"><span class="lineNum">   20969 </span><span class="lineNoCov">          0 :           if (func != nondef_decl)</span></a>
<a name="20970"><span class="lineNum">   20970 </span>            :           {</a>
<a name="20971"><span class="lineNum">   20971 </span><span class="lineNoCov">          0 :             assert(nondef_decl != NULL);</span></a>
<a name="20972"><span class="lineNum">   20972 </span><span class="lineNoCov">          0 :             assert(nondef_decl-&gt;get_file_info() != NULL);</span></a>
<a name="20973"><span class="lineNum">   20973 </span><span class="lineNoCov">          0 :             if (nondef_decl-&gt;get_file_info()-&gt;isCompilerGenerated())</span></a>
<a name="20974"><span class="lineNum">   20974 </span><span class="lineNoCov">          0 :               nondef_decl-&gt;set_scope(targetBlock);</span></a>
<a name="20975"><span class="lineNum">   20975 </span>            :           }</a>
<a name="20976"><span class="lineNum">   20976 </span>            :       }</a>
<a name="20977"><span class="lineNum">   20977 </span><span class="lineNoCov">          0 :       else if (isSgTypedefDeclaration(stmt) || isSgEnumDeclaration(stmt))</span></a>
<a name="20978"><span class="lineNum">   20978 </span>            :       {</a>
<a name="20979"><span class="lineNum">   20979 </span>            :         // Rasmussen 9/21/2020,10/27/2020,11/4/2020: Uncovered by issues RC-135 and RC-227.</a>
<a name="20980"><span class="lineNum">   20980 </span>            :         // The issues are fixed in the switch statement below but this test is needed</a>
<a name="20981"><span class="lineNum">   20981 </span>            :         // so that the warning message immediately below is not triggered.</a>
<a name="20982"><span class="lineNum">   20982 </span>            :       }</a>
<a name="20983"><span class="lineNum">   20983 </span>            :       else</a>
<a name="20984"><span class="lineNum">   20984 </span>            :       {</a>
<a name="20985"><span class="lineNum">   20985 </span><span class="lineNoCov">          0 :         printf (&quot;Warning: test failing (*i)-&gt;get_scope() == targetBlock in SageInterface::moveStatementsBetweenBlocks() \n&quot;);</span></a>
<a name="20986"><span class="lineNum">   20986 </span><span class="lineNoCov">          0 :         cerr&lt;&lt;&quot;  &quot;&lt;&lt;stmt-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="20987"><span class="lineNum">   20987 </span>            :       }</a>
<a name="20988"><span class="lineNum">   20988 </span>            :     }</a>
<a name="20989"><span class="lineNum">   20989 </span>            :   }</a>
<a name="20990"><span class="lineNum">   20990 </span>            : </a>
<a name="20991"><span class="lineNum">   20991 </span><span class="lineNoCov">          0 :   SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);</span></a>
<a name="20992"><span class="lineNum">   20992 </span><span class="lineNoCov">          0 :   if (declaration != NULL)</span></a>
<a name="20993"><span class="lineNum">   20993 </span>            :   {</a>
<a name="20994"><span class="lineNum">   20994 </span>            :     // Need to reset the scope from sourceBlock to targetBlock.</a>
<a name="20995"><span class="lineNum">   20995 </span><span class="lineNoCov">          0 :     switch(declaration-&gt;variantT())</span></a>
<a name="20996"><span class="lineNum">   20996 </span>            :     {</a>
<a name="20997"><span class="lineNum">   20997 </span>            :       // There will be other cases to handle, but likely not all declaration will be possible to support.</a>
<a name="20998"><span class="lineNum">   20998 </span>            : </a>
<a name="20999"><span class="lineNum">   20999 </span><span class="lineNoCov">          0 :       case V_SgVariableDeclaration:</span></a>
<a name="21000"><span class="lineNum">   21000 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="21001"><span class="lineNum">   21001 </span>            :           // Reset the scopes on any SgInitializedName objects.</a>
<a name="21002"><span class="lineNum">   21002 </span><span class="lineNoCov">          0 :           SgVariableDeclaration* varDecl = isSgVariableDeclaration(declaration);</span></a>
<a name="21003"><span class="lineNum">   21003 </span><span class="lineNoCov">          0 :           SgInitializedNamePtrList &amp; l = varDecl-&gt;get_variables();</span></a>
<a name="21004"><span class="lineNum">   21004 </span><span class="lineNoCov">          0 :           for (SgInitializedNamePtrList::iterator ii = l.begin(); ii != l.end(); ii++)</span></a>
<a name="21005"><span class="lineNum">   21005 </span>            :           {</a>
<a name="21006"><span class="lineNum">   21006 </span>            :             // reset the scope, but make sure it was set to sourceBlock to make sure.</a>
<a name="21007"><span class="lineNum">   21007 </span>            :             // This might be an issue for extern variable declaration that have a scope</a>
<a name="21008"><span class="lineNum">   21008 </span>            :             // in a separate namespace of a static class member defined external to</a>
<a name="21009"><span class="lineNum">   21009 </span>            :             // its class, etc. I don't want to worry about those cases right now.</a>
<a name="21010"><span class="lineNum">   21010 </span>            : </a>
<a name="21011"><span class="lineNum">   21011 </span><span class="lineNoCov">          0 :             SgInitializedName * init_name = (*ii);</span></a>
<a name="21012"><span class="lineNum">   21012 </span>            : </a>
<a name="21013"><span class="lineNum">   21013 </span>            :             // Rasmussen (3/16/2021): Use the base type in case type is modified (i.e., const)</a>
<a name="21014"><span class="lineNum">   21014 </span><span class="lineNoCov">          0 :             SgType* var_type = init_name-&gt;get_type();</span></a>
<a name="21015"><span class="lineNum">   21015 </span><span class="lineNoCov">          0 :             if (SgModifierType* mod_type = isSgModifierType(var_type))</span></a>
<a name="21016"><span class="lineNum">   21016 </span>            :             {</a>
<a name="21017"><span class="lineNum">   21017 </span><span class="lineNoCov">          0 :               var_type = mod_type-&gt;get_base_type();</span></a>
<a name="21018"><span class="lineNum">   21018 </span>            :             }</a>
<a name="21019"><span class="lineNum">   21019 </span>            : </a>
<a name="21020"><span class="lineNum">   21020 </span>            :             // Rasmussen (6/29/2020) and (10/19/2020): Variable declarations related to anonymous types are not</a>
<a name="21021"><span class="lineNum">   21021 </span>            :             // moved. This is fixed below. Note that SgJovialTableType derives from SgClassType, it may</a>
<a name="21022"><span class="lineNum">   21022 </span>            :             // be that class types are not moved correctly either.</a>
<a name="21023"><span class="lineNum">   21023 </span>            :             //</a>
<a name="21024"><span class="lineNum">   21024 </span><span class="lineNoCov">          0 :             if (isSgEnumType(var_type))</span></a>
<a name="21025"><span class="lineNum">   21025 </span>            :             {</a>
<a name="21026"><span class="lineNum">   21026 </span><span class="lineNoCov">          0 :               SgEnumType* enum_type = isSgEnumType(var_type);</span></a>
<a name="21027"><span class="lineNum">   21027 </span><span class="lineNoCov">          0 :               SgEnumDeclaration* decl = isSgEnumDeclaration(enum_type-&gt;get_declaration());</span></a>
<a name="21028"><span class="lineNum">   21028 </span><span class="lineNoCov">          0 :               SgEnumDeclaration* def_decl = isSgEnumDeclaration(decl-&gt;get_definingDeclaration());</span></a>
<a name="21029"><span class="lineNum">   21029 </span><span class="lineNoCov">          0 :               SgEnumDeclaration* nondef_decl = isSgEnumDeclaration(decl-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="21030"><span class="lineNum">   21030 </span>            : </a>
<a name="21031"><span class="lineNum">   21031 </span><span class="lineNoCov">          0 :               if (decl-&gt;get_scope() == sourceBlock)</span></a>
<a name="21032"><span class="lineNum">   21032 </span>            :               {</a>
<a name="21033"><span class="lineNum">   21033 </span>            :                 // Needs to be moved</a>
<a name="21034"><span class="lineNum">   21034 </span><span class="lineNoCov">          0 :                 def_decl-&gt;set_scope(targetBlock);</span></a>
<a name="21035"><span class="lineNum">   21035 </span><span class="lineNoCov">          0 :                 nondef_decl-&gt;set_scope(targetBlock);</span></a>
<a name="21036"><span class="lineNum">   21036 </span><span class="lineNoCov">          0 :                 nondef_decl-&gt;set_parent(targetBlock);</span></a>
<a name="21037"><span class="lineNum">   21037 </span>            : </a>
<a name="21038"><span class="lineNum">   21038 </span>            :                 // Move the scope of the enumerators to the new block as well</a>
<a name="21039"><span class="lineNum">   21039 </span><span class="lineNoCov">          0 :                 SgInitializedNamePtrList &amp; enums = def_decl-&gt;get_enumerators();</span></a>
<a name="21040"><span class="lineNum">   21040 </span><span class="lineNoCov">          0 :                 for (SgInitializedNamePtrList::iterator e = enums.begin(); e != enums.end(); e++)</span></a>
<a name="21041"><span class="lineNum">   21041 </span>            :                 {</a>
<a name="21042"><span class="lineNum">   21042 </span><span class="lineNoCov">          0 :                   (*e)-&gt;set_scope(targetBlock);</span></a>
<a name="21043"><span class="lineNum">   21043 </span>            :                 }</a>
<a name="21044"><span class="lineNum">   21044 </span>            :               }</a>
<a name="21045"><span class="lineNum">   21045 </span>            :             }</a>
<a name="21046"><span class="lineNum">   21046 </span>            : </a>
<a name="21047"><span class="lineNum">   21047 </span>            :             // Must also move the symbol into the source block, Liao 2019/8/14</a>
<a name="21048"><span class="lineNum">   21048 </span><span class="lineNoCov">          0 :             SgVariableSymbol* var_sym = isSgVariableSymbol(init_name -&gt; search_for_symbol_from_symbol_table ()) ;</span></a>
<a name="21049"><span class="lineNum">   21049 </span><span class="lineNoCov">          0 :             ROSE_ASSERT (var_sym);</span></a>
<a name="21050"><span class="lineNum">   21050 </span><span class="lineNoCov">          0 :             SgScopeStatement * old_scope = var_sym -&gt; get_scope();</span></a>
<a name="21051"><span class="lineNum">   21051 </span>            : #if 1 // we will later move entire source symbol table to target scope,  so we move symbol to the sourceBlock first here.</a>
<a name="21052"><span class="lineNum">   21052 </span><span class="lineNoCov">          0 :             if (old_scope != sourceBlock)</span></a>
<a name="21053"><span class="lineNum">   21053 </span>            :             {</a>
<a name="21054"><span class="lineNum">   21054 </span><span class="lineNoCov">          0 :               old_scope-&gt;remove_symbol (var_sym);</span></a>
<a name="21055"><span class="lineNum">   21055 </span><span class="lineNoCov">          0 :               sourceBlock -&gt;insert_symbol(init_name-&gt;get_name(), var_sym);</span></a>
<a name="21056"><span class="lineNum">   21056 </span>            :             }</a>
<a name="21057"><span class="lineNum">   21057 </span>            : #endif</a>
<a name="21058"><span class="lineNum">   21058 </span><span class="lineNoCov">          0 :             init_name-&gt;set_scope(targetBlock);</span></a>
<a name="21059"><span class="lineNum">   21059 </span><span class="lineNoCov">          0 :             initname_vec.push_back(init_name);</span></a>
<a name="21060"><span class="lineNum">   21060 </span>            :           }</a>
<a name="21061"><span class="lineNum">   21061 </span>            :           break;</a>
<a name="21062"><span class="lineNum">   21062 </span>            :         }</a>
<a name="21063"><span class="lineNum">   21063 </span><span class="lineNoCov">          0 :       case V_SgFunctionDeclaration: // Liao 1/15/2009, I don't think there is any extra things to do here</span></a>
<a name="21064"><span class="lineNum">   21064 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="21065"><span class="lineNum">   21065 </span><span class="lineNoCov">          0 :           SgFunctionDeclaration * funcDecl = isSgFunctionDeclaration(declaration);</span></a>
<a name="21066"><span class="lineNum">   21066 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (funcDecl);</span></a>
<a name="21067"><span class="lineNum">   21067 </span>            : #if 0 // we will later move entire source symbol table to target scope,  so we move symbol to the sourceBlock first here.</a>
<a name="21068"><span class="lineNum">   21068 </span>            :           // move function symbols also: search_for_symbol_from_symbol_table()</a>
<a name="21069"><span class="lineNum">   21069 </span>            :           SgSymbol* func_sym= funcDecl-&gt;get_firstNondefiningDeclaration()-&gt;search_for_symbol_from_symbol_table();</a>
<a name="21070"><span class="lineNum">   21070 </span>            :           if (func_sym)</a>
<a name="21071"><span class="lineNum">   21071 </span>            :           {</a>
<a name="21072"><span class="lineNum">   21072 </span>            :             SgScopeStatement * old_scope = func_sym -&gt; get_scope();</a>
<a name="21073"><span class="lineNum">   21073 </span>            :             if (old_scope != sourceBlock)</a>
<a name="21074"><span class="lineNum">   21074 </span>            :             {</a>
<a name="21075"><span class="lineNum">   21075 </span>            :               old_scope-&gt;remove_symbol (func_sym);</a>
<a name="21076"><span class="lineNum">   21076 </span>            :               sourceBlock -&gt;insert_symbol(func_sym-&gt;get_name(), func_sym);</a>
<a name="21077"><span class="lineNum">   21077 </span>            :             }</a>
<a name="21078"><span class="lineNum">   21078 </span>            :           }</a>
<a name="21079"><span class="lineNum">   21079 </span>            : #endif</a>
<a name="21080"><span class="lineNum">   21080 </span>            : </a>
<a name="21081"><span class="lineNum">   21081 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="21082"><span class="lineNum">   21082 </span>            :         }</a>
<a name="21083"><span class="lineNum">   21083 </span>            :       // needed to move Ada record into definition of C++ namespace</a>
<a name="21084"><span class="lineNum">   21084 </span><span class="lineNoCov">          0 :       case V_SgClassDeclaration:</span></a>
<a name="21085"><span class="lineNum">   21085 </span><span class="lineNoCov">          0 :       case V_SgEnumDeclaration:</span></a>
<a name="21086"><span class="lineNum">   21086 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="21087"><span class="lineNum">   21087 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* def_decl = declaration-&gt;get_definingDeclaration();</span></a>
<a name="21088"><span class="lineNum">   21088 </span><span class="lineNoCov">          0 :           SgDeclarationStatement* nondef_decl = declaration-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="21089"><span class="lineNum">   21089 </span>            : </a>
<a name="21090"><span class="lineNum">   21090 </span><span class="lineNoCov">          0 :           nondef_decl-&gt;set_parent(targetBlock);</span></a>
<a name="21091"><span class="lineNum">   21091 </span><span class="lineNoCov">          0 :           nondef_decl-&gt;set_scope(targetBlock);</span></a>
<a name="21092"><span class="lineNum">   21092 </span>            : </a>
<a name="21093"><span class="lineNum">   21093 </span><span class="lineNoCov">          0 :           def_decl-&gt;set_parent(targetBlock);</span></a>
<a name="21094"><span class="lineNum">   21094 </span><span class="lineNoCov">          0 :           def_decl-&gt;set_scope(targetBlock);</span></a>
<a name="21095"><span class="lineNum">   21095 </span>            : </a>
<a name="21096"><span class="lineNum">   21096 </span><span class="lineNoCov">          0 :           SgEnumDeclaration* enum_decl = isSgEnumDeclaration(stmt);</span></a>
<a name="21097"><span class="lineNum">   21097 </span><span class="lineNoCov">          0 :           if (enum_decl) // Rasmussen (12/23/2020)</span></a>
<a name="21098"><span class="lineNum">   21098 </span>            :             {</a>
<a name="21099"><span class="lineNum">   21099 </span>            :               // Set the scope of the enumerators</a>
<a name="21100"><span class="lineNum">   21100 </span><span class="lineNoCov">          0 :               BOOST_FOREACH (SgInitializedName* name, enum_decl-&gt;get_enumerators())</span></a>
<a name="21101"><span class="lineNum">   21101 </span>            :                 {</a>
<a name="21102"><span class="lineNum">   21102 </span><span class="lineNoCov">          0 :                   name-&gt;set_scope(targetBlock);</span></a>
<a name="21103"><span class="lineNum">   21103 </span>            :                 }</a>
<a name="21104"><span class="lineNum">   21104 </span>            :             }</a>
<a name="21105"><span class="lineNum">   21105 </span>            :           break;</a>
<a name="21106"><span class="lineNum">   21106 </span>            :         }</a>
<a name="21107"><span class="lineNum">   21107 </span><span class="lineNoCov">          0 :       case V_SgTypedefDeclaration: // Rasmussen (10/19/2020)</span></a>
<a name="21108"><span class="lineNum">   21108 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="21109"><span class="lineNum">   21109 </span>            :           // Rasmussen 10/19/2020: Needed for issue RC-227</a>
<a name="21110"><span class="lineNum">   21110 </span><span class="lineNoCov">          0 :           SgTypedefDeclaration* typedef_decl = isSgTypedefDeclaration(declaration);</span></a>
<a name="21111"><span class="lineNum">   21111 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (typedef_decl);</span></a>
<a name="21112"><span class="lineNum">   21112 </span><span class="lineNoCov">          0 :           typedef_decl-&gt;set_parent(targetBlock);</span></a>
<a name="21113"><span class="lineNum">   21113 </span><span class="lineNoCov">          0 :           typedef_decl-&gt;set_scope(targetBlock);</span></a>
<a name="21114"><span class="lineNum">   21114 </span><span class="lineNoCov">          0 :           break;</span></a>
<a name="21115"><span class="lineNum">   21115 </span>            :        }</a>
<a name="21116"><span class="lineNum">   21116 </span>            :       case V_SgAttributeSpecificationStatement:</a>
<a name="21117"><span class="lineNum">   21117 </span>            :       case V_SgEmptyDeclaration:</a>
<a name="21118"><span class="lineNum">   21118 </span>            :       case V_SgFortranIncludeLine:</a>
<a name="21119"><span class="lineNum">   21119 </span>            :       case V_SgPragmaDeclaration:</a>
<a name="21120"><span class="lineNum">   21120 </span>            :         break;</a>
<a name="21121"><span class="lineNum">   21121 </span><span class="lineNoCov">          0 :       default:</span></a>
<a name="21122"><span class="lineNum">   21122 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="21123"><span class="lineNum">   21123 </span><span class="lineNoCov">          0 :           printf (&quot;Moving this declaration = %p = %s = %s between blocks is not yet supported \n&quot;,declaration,declaration-&gt;class_name().c_str(), SageInterface::get_name(declaration).c_str());</span></a>
<a name="21124"><span class="lineNum">   21124 </span><span class="lineNoCov">          0 :           declaration-&gt;get_file_info()-&gt;display(&quot;file info&quot;);</span></a>
<a name="21125"><span class="lineNum">   21125 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="21126"><span class="lineNum">   21126 </span>            :         }</a>
<a name="21127"><span class="lineNum">   21127 </span>            :     }</a>
<a name="21128"><span class="lineNum">   21128 </span>            :   } // end if</a>
<a name="21129"><span class="lineNum">   21129 </span><span class="lineNoCov">          0 : }</span></a>
<a name="21130"><span class="lineNum">   21130 </span>            : </a>
<a name="21131"><span class="lineNum">   21131 </span>            : // different handling for scopes with declarations only</a>
<a name="21132"><span class="lineNum">   21132 </span>            : template &lt;class T1, class T2&gt;</a>
<a name="21133"><span class="lineNum">   21133 </span>            : void moveDeclarationsBetweenScopes( T1* sourceBlock, T2* targetBlock)</a>
<a name="21134"><span class="lineNum">   21134 </span>            : {</a>
<a name="21135"><span class="lineNum">   21135 </span>            :   // This function moves statements from one block to another (used by the outliner).</a>
<a name="21136"><span class="lineNum">   21136 </span>            :   // printf (&quot;***** Moving statements from sourceBlock %p to targetBlock %p ***** \n&quot;,sourceBlock,targetBlock);</a>
<a name="21137"><span class="lineNum">   21137 </span>            :   ROSE_ASSERT (sourceBlock &amp;&amp; targetBlock);</a>
<a name="21138"><span class="lineNum">   21138 </span>            :   ROSE_ASSERT (sourceBlock-&gt;containsOnlyDeclarations() &amp;&amp; targetBlock-&gt;containsOnlyDeclarations());</a>
<a name="21139"><span class="lineNum">   21139 </span>            :   if ((void*)sourceBlock == (void*)targetBlock)</a>
<a name="21140"><span class="lineNum">   21140 </span>            :   {</a>
<a name="21141"><span class="lineNum">   21141 </span>            :     cerr&lt;&lt;&quot;warning: SageInterface::moveStatementsBetweenScopes() is skipped, &quot;&lt;&lt;endl;</a>
<a name="21142"><span class="lineNum">   21142 </span>            :     cerr&lt;&lt;&quot;         since program is trying to move statements from and to the identical scoped block. &quot;&lt;&lt;endl;</a>
<a name="21143"><span class="lineNum">   21143 </span>            :     return;</a>
<a name="21144"><span class="lineNum">   21144 </span>            :   }</a>
<a name="21145"><span class="lineNum">   21145 </span>            : </a>
<a name="21146"><span class="lineNum">   21146 </span>            :   SgDeclarationStatementPtrList&amp; srcStmts = sourceBlock-&gt;get_declarations ();</a>
<a name="21147"><span class="lineNum">   21147 </span>            :   std::vector &lt;SgInitializedName*&gt; initname_vec;</a>
<a name="21148"><span class="lineNum">   21148 </span>            : </a>
<a name="21149"><span class="lineNum">   21149 </span>            :   for (SgDeclarationStatementPtrList::iterator i = srcStmts.begin(); i != srcStmts.end(); i++)</a>
<a name="21150"><span class="lineNum">   21150 </span>            :   {</a>
<a name="21151"><span class="lineNum">   21151 </span>            :     moveOneStatement(sourceBlock, targetBlock, *i, initname_vec);</a>
<a name="21152"><span class="lineNum">   21152 </span>            :   } // end for</a>
<a name="21153"><span class="lineNum">   21153 </span>            : </a>
<a name="21154"><span class="lineNum">   21154 </span>            :   // Remove the statements in the sourceBlock</a>
<a name="21155"><span class="lineNum">   21155 </span>            :   srcStmts.clear();</a>
<a name="21156"><span class="lineNum">   21156 </span>            :   ROSE_ASSERT(srcStmts.empty() == true);</a>
<a name="21157"><span class="lineNum">   21157 </span>            :   ROSE_ASSERT(sourceBlock-&gt;get_declarations().empty() == true);</a>
<a name="21158"><span class="lineNum">   21158 </span>            : </a>
<a name="21159"><span class="lineNum">   21159 </span>            :  // move symbol table from one scope to another</a>
<a name="21160"><span class="lineNum">   21160 </span>            :   moveSymbolTableBetweenBlocks(sourceBlock, targetBlock, initname_vec);</a>
<a name="21161"><span class="lineNum">   21161 </span>            : </a>
<a name="21162"><span class="lineNum">   21162 </span>            :   // Liao 2/4/2009</a>
<a name="21163"><span class="lineNum">   21163 </span>            :   // Finally , move preprocessing information attached inside the source block to the target block</a>
<a name="21164"><span class="lineNum">   21164 </span>            :   // Outliner uses this function to move a code block to the outlined function.</a>
<a name="21165"><span class="lineNum">   21165 </span>            :   // This will ensure that a trailing #endif (which is attached inside the source block) will be moved</a>
<a name="21166"><span class="lineNum">   21166 </span>            :   // to the target block to match #if (which is attached</a>
<a name="21167"><span class="lineNum">   21167 </span>            :   // before some statement moved to the target block)</a>
<a name="21168"><span class="lineNum">   21168 </span>            :   SageInterface::moveUpPreprocessingInfo (targetBlock, sourceBlock, PreprocessingInfo::inside);</a>
<a name="21169"><span class="lineNum">   21169 </span>            : }</a>
<a name="21170"><span class="lineNum">   21170 </span>            : </a>
<a name="21171"><span class="lineNum">   21171 </span>            : </a>
<a name="21172"><span class="lineNum">   21172 </span>            : // source and destination class, both are derived classes of scope statement but with support of get_statements()</a>
<a name="21173"><span class="lineNum">   21173 </span>            : template &lt;class T1, class T2&gt;</a>
<a name="21174"><span class="lineNum">   21174 </span><span class="lineNoCov">          0 : void moveStatementsBetweenScopes( T1* sourceBlock, T2* targetBlock)</span></a>
<a name="21175"><span class="lineNum">   21175 </span>            : {</a>
<a name="21176"><span class="lineNum">   21176 </span>            :   // This function moves statements from one block to another (used by the outliner).</a>
<a name="21177"><span class="lineNum">   21177 </span>            :   // printf (&quot;***** Moving statements from sourceBlock %p to targetBlock %p ***** \n&quot;,sourceBlock,targetBlock);</a>
<a name="21178"><span class="lineNum">   21178 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (sourceBlock &amp;&amp; targetBlock);</span></a>
<a name="21179"><span class="lineNum">   21179 </span><span class="lineNoCov">          0 :   if ((void*)sourceBlock == (void*)targetBlock)</span></a>
<a name="21180"><span class="lineNum">   21180 </span>            :   {</a>
<a name="21181"><span class="lineNum">   21181 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;warning: SageInterface::moveStatementsBetweenScopes() is skipped, &quot;&lt;&lt;endl;</span></a>
<a name="21182"><span class="lineNum">   21182 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;         since program is trying to move statements from and to the identical scoped block. &quot;&lt;&lt;endl;</span></a>
<a name="21183"><span class="lineNum">   21183 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="21184"><span class="lineNum">   21184 </span>            :   }</a>
<a name="21185"><span class="lineNum">   21185 </span>            : </a>
<a name="21186"><span class="lineNum">   21186 </span><span class="lineNoCov">          0 :   SgStatementPtrList &amp; srcStmts = sourceBlock-&gt;get_statements();</span></a>
<a name="21187"><span class="lineNum">   21187 </span><span class="lineNoCov">          0 :   std::vector &lt;SgInitializedName*&gt; initname_vec;</span></a>
<a name="21188"><span class="lineNum">   21188 </span>            : </a>
<a name="21189"><span class="lineNum">   21189 </span>            : </a>
<a name="21190"><span class="lineNum">   21190 </span><span class="lineNoCov">          0 :   for (SgStatementPtrList::iterator i = srcStmts.begin(); i != srcStmts.end(); i++)</span></a>
<a name="21191"><span class="lineNum">   21191 </span>            :   {</a>
<a name="21192"><span class="lineNum">   21192 </span><span class="lineNoCov">          0 :     moveOneStatement(sourceBlock, targetBlock, *i, initname_vec);</span></a>
<a name="21193"><span class="lineNum">   21193 </span>            :   } // end for</a>
<a name="21194"><span class="lineNum">   21194 </span>            : </a>
<a name="21195"><span class="lineNum">   21195 </span>            :   // Remove the statements in the sourceBlock</a>
<a name="21196"><span class="lineNum">   21196 </span><span class="lineNoCov">          0 :   srcStmts.clear();</span></a>
<a name="21197"><span class="lineNum">   21197 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(srcStmts.empty() == true);</span></a>
<a name="21198"><span class="lineNum">   21198 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(sourceBlock-&gt;get_statements().empty() == true);</span></a>
<a name="21199"><span class="lineNum">   21199 </span>            : </a>
<a name="21200"><span class="lineNum">   21200 </span>            :  // move symbol table from one scope to another</a>
<a name="21201"><span class="lineNum">   21201 </span><span class="lineNoCov">          0 :   moveSymbolTableBetweenBlocks(sourceBlock, targetBlock, initname_vec);</span></a>
<a name="21202"><span class="lineNum">   21202 </span>            : </a>
<a name="21203"><span class="lineNum">   21203 </span>            :   // Liao 2/4/2009</a>
<a name="21204"><span class="lineNum">   21204 </span>            :   // Finally , move preprocessing information attached inside the source block to the target block</a>
<a name="21205"><span class="lineNum">   21205 </span>            :   // Outliner uses this function to move a code block to the outlined function.</a>
<a name="21206"><span class="lineNum">   21206 </span>            :   // This will ensure that a trailing #endif (which is attached inside the source block) will be moved</a>
<a name="21207"><span class="lineNum">   21207 </span>            :   // to the target block to match #if (which is attached</a>
<a name="21208"><span class="lineNum">   21208 </span>            :   // before some statement moved to the target block)</a>
<a name="21209"><span class="lineNum">   21209 </span><span class="lineNoCov">          0 :   SageInterface::moveUpPreprocessingInfo (targetBlock, sourceBlock, PreprocessingInfo::inside);</span></a>
<a name="21210"><span class="lineNum">   21210 </span>            : </a>
<a name="21211"><span class="lineNum">   21211 </span>            : }</a>
<a name="21212"><span class="lineNum">   21212 </span>            : </a>
<a name="21213"><span class="lineNum">   21213 </span>            : static void createAliasSymbols (SgNamespaceDeclarationStatement* decl)</a>
<a name="21214"><span class="lineNum">   21214 </span>            : {</a>
<a name="21215"><span class="lineNum">   21215 </span>            :   ROSE_ASSERT(decl);</a>
<a name="21216"><span class="lineNum">   21216 </span>            :   SgNamespaceDefinitionStatement* local_def = decl-&gt;get_definition();</a>
<a name="21217"><span class="lineNum">   21217 </span>            :   SgNamespaceDefinitionStatement* global_def = local_def-&gt;get_global_definition();</a>
<a name="21218"><span class="lineNum">   21218 </span>            : </a>
<a name="21219"><span class="lineNum">   21219 </span>            :   ROSE_ASSERT(local_def &amp;&amp; global_def &amp;&amp; (local_def!=global_def));</a>
<a name="21220"><span class="lineNum">   21220 </span>            : </a>
<a name="21221"><span class="lineNum">   21221 </span>            :   std::set&lt;SgNode*&gt; syms = local_def-&gt;get_symbol_table()-&gt;get_symbols();</a>
<a name="21222"><span class="lineNum">   21222 </span>            : //  cout&lt;&lt;&quot;Found syms.size()==&quot;&lt;&lt;syms.size()&lt;&lt;endl;</a>
<a name="21223"><span class="lineNum">   21223 </span>            :   for (std::set&lt;SgNode*&gt;::iterator iter= syms.begin(); iter != syms.end(); iter++)</a>
<a name="21224"><span class="lineNum">   21224 </span>            :   {</a>
<a name="21225"><span class="lineNum">   21225 </span>            :     SgSymbol *orig_sym = isSgSymbol(*iter);</a>
<a name="21226"><span class="lineNum">   21226 </span>            :     ROSE_ASSERT (orig_sym);</a>
<a name="21227"><span class="lineNum">   21227 </span>            :     SgAliasSymbol* asym = new SgAliasSymbol (orig_sym);</a>
<a name="21228"><span class="lineNum">   21228 </span>            :     global_def-&gt;get_symbol_table()-&gt;insert (asym-&gt;get_name(), asym);</a>
<a name="21229"><span class="lineNum">   21229 </span>            :   }</a>
<a name="21230"><span class="lineNum">   21230 </span>            : }</a>
<a name="21231"><span class="lineNum">   21231 </span>            : </a>
<a name="21232"><span class="lineNum">   21232 </span>            : void</a>
<a name="21233"><span class="lineNum">   21233 </span><span class="lineNoCov">          0 : SageInterface::moveStatementsBetweenBlocks ( SgBasicBlock* sourceBlock, SgBasicBlock* targetBlock )</span></a>
<a name="21234"><span class="lineNum">   21234 </span>            : {</a>
<a name="21235"><span class="lineNum">   21235 </span><span class="lineNoCov">          0 :   moveStatementsBetweenScopes (sourceBlock, targetBlock);</span></a>
<a name="21236"><span class="lineNum">   21236 </span><span class="lineNoCov">          0 : }</span></a>
<a name="21237"><span class="lineNum">   21237 </span>            : </a>
<a name="21238"><span class="lineNum">   21238 </span>            : //! Check if a function declaration is a C++11 lambda function</a>
<a name="21239"><span class="lineNum">   21239 </span>            : // TODO, expose to SageInterface namespace</a>
<a name="21240"><span class="lineNum">   21240 </span><span class="lineNoCov">          0 : bool SageInterface::isLambdaFunction (SgFunctionDeclaration* func)</span></a>
<a name="21241"><span class="lineNum">   21241 </span>            : {</a>
<a name="21242"><span class="lineNum">   21242 </span><span class="lineNoCov">          0 :   bool rt = false;</span></a>
<a name="21243"><span class="lineNum">   21243 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (func != NULL);</span></a>
<a name="21244"><span class="lineNum">   21244 </span><span class="lineNoCov">          0 :   SgNode* p = func-&gt;get_parent();</span></a>
<a name="21245"><span class="lineNum">   21245 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (p != NULL);</span></a>
<a name="21246"><span class="lineNum">   21246 </span><span class="lineNoCov">          0 :   SgLambdaExp* le = isSgLambdaExp (p);</span></a>
<a name="21247"><span class="lineNum">   21247 </span><span class="lineNoCov">          0 :   if (le &amp;&amp; le-&gt;get_lambda_function() == func)</span></a>
<a name="21248"><span class="lineNum">   21248 </span>            :     rt = true;</a>
<a name="21249"><span class="lineNum">   21249 </span><span class="lineNoCov">          0 :   return rt;</span></a>
<a name="21250"><span class="lineNum">   21250 </span>            : }</a>
<a name="21251"><span class="lineNum">   21251 </span>            : </a>
<a name="21252"><span class="lineNum">   21252 </span>            : // check if a variable reference is this-&gt;a[i] inside of a lambda function</a>
<a name="21253"><span class="lineNum">   21253 </span>            : // SgArrowExp &lt;SgThisExp,  SgVarRefExp&gt;, both are compiler generated nodes</a>
<a name="21254"><span class="lineNum">   21254 </span>            : // class symbol of ThisExp 's declaration is AutonomousDeclaration SgClassDeclaration</a>
<a name="21255"><span class="lineNum">   21255 </span>            : // its parent is SgLambdaExp, and lambda_closure_class points back to this class declaration</a>
<a name="21256"><span class="lineNum">   21256 </span><span class="lineNoCov">          0 : bool SageInterface::isLambdaCapturedVariable (SgVarRefExp* varRef)</span></a>
<a name="21257"><span class="lineNum">   21257 </span>            : {</a>
<a name="21258"><span class="lineNum">   21258 </span><span class="lineNoCov">          0 :   bool rt = false;</span></a>
<a name="21259"><span class="lineNum">   21259 </span>            : #ifdef  _MSC_VER</a>
<a name="21260"><span class="lineNum">   21260 </span>            :   #pragma message (&quot;WARNING: MSVC does not handle isLambdaCapturedVariable() properly.&quot;)</a>
<a name="21261"><span class="lineNum">   21261 </span>            : #else</a>
<a name="21262"><span class="lineNum">   21262 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (varRef!= NULL);</span></a>
<a name="21263"><span class="lineNum">   21263 </span><span class="lineNoCov">          0 :   SgNode* parent = varRef-&gt;get_parent();</span></a>
<a name="21264"><span class="lineNum">   21264 </span><span class="lineNoCov">          0 :   if (SgArrowExp *p = isSgArrowExp(parent))</span></a>
<a name="21265"><span class="lineNum">   21265 </span>            :   {</a>
<a name="21266"><span class="lineNum">   21266 </span><span class="lineNoCov">          0 :     SgThisExp* te = isSgThisExp(p-&gt;get_lhs_operand_i());</span></a>
<a name="21267"><span class="lineNum">   21267 </span><span class="lineNoCov">          0 :     if (te != NULL)</span></a>
<a name="21268"><span class="lineNum">   21268 </span>            :     {</a>
<a name="21269"><span class="lineNum">   21269 </span><span class="lineNoCov">          0 :       SgClassSymbol* csym = te-&gt;get_class_symbol();</span></a>
<a name="21270"><span class="lineNum">   21270 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (csym!= NULL);</span></a>
<a name="21271"><span class="lineNum">   21271 </span><span class="lineNoCov">          0 :       SgClassDeclaration* xdecl = isSgClassDeclaration(csym-&gt;get_declaration());</span></a>
<a name="21272"><span class="lineNum">   21272 </span>            :       // each this exp should have a class decl</a>
<a name="21273"><span class="lineNum">   21273 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (xdecl != NULL);</span></a>
<a name="21274"><span class="lineNum">   21274 </span><span class="lineNoCov">          0 :       SgLambdaExp* le = isSgLambdaExp(xdecl-&gt;get_parent());</span></a>
<a name="21275"><span class="lineNum">   21275 </span><span class="lineNoCov">          0 :       if (le != NULL)</span></a>
<a name="21276"><span class="lineNum">   21276 </span>            :       {</a>
<a name="21277"><span class="lineNum">   21277 </span><span class="lineNoCov">          0 :         if (le-&gt;get_lambda_closure_class() == xdecl ) // the class is a lambda closure class</span></a>
<a name="21278"><span class="lineNum">   21278 </span><span class="lineNoCov">          0 :           rt = true;</span></a>
<a name="21279"><span class="lineNum">   21279 </span>            :       }</a>
<a name="21280"><span class="lineNum">   21280 </span>            :     }</a>
<a name="21281"><span class="lineNum">   21281 </span>            :   }</a>
<a name="21282"><span class="lineNum">   21282 </span>            : #endif</a>
<a name="21283"><span class="lineNum">   21283 </span><span class="lineNoCov">          0 :   return rt;</span></a>
<a name="21284"><span class="lineNum">   21284 </span>            : }</a>
<a name="21285"><span class="lineNum">   21285 </span>            : </a>
<a name="21286"><span class="lineNum">   21286 </span>            : //! Variable references can be introduced by SgVarRef, SgPntrArrRefExp, SgInitializedName, SgMemberFunctionRef etc. This function will convert them all to  a top level SgInitializedName.</a>
<a name="21287"><span class="lineNum">   21287 </span>            : //! For dot and arrow expressions, a top level SgInitializedName.</a>
<a name="21288"><span class="lineNum">   21288 </span>            : //TODO consult  AstInterface::IsVarRef() for more cases</a>
<a name="21289"><span class="lineNum">   21289 </span><span class="lineCov">         50 : SgInitializedName* SageInterface::convertRefToInitializedName(SgNode* current, bool coarseGrain/*=true*/)</span></a>
<a name="21290"><span class="lineNum">   21290 </span>            : {</a>
<a name="21291"><span class="lineNum">   21291 </span><span class="lineCov">         50 :   SgInitializedName* name = NULL;</span></a>
<a name="21292"><span class="lineNum">   21292 </span><span class="lineCov">         50 :   SgExpression* nameExp = NULL;</span></a>
<a name="21293"><span class="lineNum">   21293 </span><span class="lineCov">         50 :   ROSE_ASSERT(current != NULL);</span></a>
<a name="21294"><span class="lineNum">   21294 </span>            : </a>
<a name="21295"><span class="lineNum">   21295 </span><span class="lineCov">         50 :   if (isSgInitializedName(current))</span></a>
<a name="21296"><span class="lineNum">   21296 </span>            :   {</a>
<a name="21297"><span class="lineNum">   21297 </span><span class="lineCov">          4 :     name = isSgInitializedName(current);</span></a>
<a name="21298"><span class="lineNum">   21298 </span>            :   }</a>
<a name="21299"><span class="lineNum">   21299 </span><span class="lineCov">         46 :   else if (isSgPntrArrRefExp(current) != NULL)</span></a>
<a name="21300"><span class="lineNum">   21300 </span>            :   {</a>
<a name="21301"><span class="lineNum">   21301 </span><span class="lineCov">          6 :     bool suc=false;</span></a>
<a name="21302"><span class="lineNum">   21302 </span><span class="lineCov">          6 :     SgExpression* exp = isSgExpression(current);</span></a>
<a name="21303"><span class="lineNum">   21303 </span><span class="lineCov">          6 :     ROSE_ASSERT(exp != NULL);</span></a>
<a name="21304"><span class="lineNum">   21304 </span><span class="lineCov">          6 :     suc = SageInterface::isArrayReference(exp,&amp;nameExp);</span></a>
<a name="21305"><span class="lineNum">   21305 </span><span class="lineCov">          6 :     ROSE_ASSERT(suc == true);</span></a>
<a name="21306"><span class="lineNum">   21306 </span>            :      // has to resolve this recursively</a>
<a name="21307"><span class="lineNum">   21307 </span><span class="lineCov">          6 :     return convertRefToInitializedName(nameExp, coarseGrain);</span></a>
<a name="21308"><span class="lineNum">   21308 </span>            :   }</a>
<a name="21309"><span class="lineNum">   21309 </span><span class="lineCov">         40 :   else if (isSgVarRefExp(current) != NULL)</span></a>
<a name="21310"><span class="lineNum">   21310 </span>            :   {</a>
<a name="21311"><span class="lineNum">   21311 </span><span class="lineCov">         40 :     if (coarseGrain)</span></a>
<a name="21312"><span class="lineNum">   21312 </span>            :     {</a>
<a name="21313"><span class="lineNum">   21313 </span>            :      // Outliner needs coarse grain mem objects to work. Always returning fine grain objects will cause problems.</a>
<a name="21314"><span class="lineNum">   21314 </span><span class="lineCov">         40 :       SgNode* parent = current-&gt;get_parent();</span></a>
<a name="21315"><span class="lineNum">   21315 </span><span class="lineCov">         40 :       if (isSgDotExp(parent))</span></a>
<a name="21316"><span class="lineNum">   21316 </span>            :       {</a>
<a name="21317"><span class="lineNum">   21317 </span><span class="lineNoCov">          0 :         if (isSgDotExp(parent)-&gt;get_rhs_operand() == current)</span></a>
<a name="21318"><span class="lineNum">   21318 </span><span class="lineNoCov">          0 :           return convertRefToInitializedName(parent, coarseGrain);</span></a>
<a name="21319"><span class="lineNum">   21319 </span>            :       }</a>
<a name="21320"><span class="lineNum">   21320 </span>            :       // avoid backtracking to parent if this is part of lambda function</a>
<a name="21321"><span class="lineNum">   21321 </span><span class="lineCov">         40 :       else if(isSgArrowExp(parent) &amp;&amp; ! isLambdaCapturedVariable ( isSgVarRefExp(current) ) )</span></a>
<a name="21322"><span class="lineNum">   21322 </span>            :       {</a>
<a name="21323"><span class="lineNum">   21323 </span><span class="lineNoCov">          0 :         if (isSgArrowExp(parent)-&gt;get_rhs_operand() == current)</span></a>
<a name="21324"><span class="lineNum">   21324 </span><span class="lineNoCov">          0 :           return convertRefToInitializedName(parent, coarseGrain);</span></a>
<a name="21325"><span class="lineNum">   21325 </span>            :       }</a>
<a name="21326"><span class="lineNum">   21326 </span>            :     }</a>
<a name="21327"><span class="lineNum">   21327 </span><span class="lineCov">         40 :     name = isSgVarRefExp(current)-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="21328"><span class="lineNum">   21328 </span>            :   }</a>
<a name="21329"><span class="lineNum">   21329 </span><span class="lineNoCov">          0 :   else if (isSgFunctionRefExp(current) != NULL ||</span></a>
<a name="21330"><span class="lineNum">   21330 </span><span class="lineNoCov">          0 :            isSgTemplateFunctionRefExp(current) != NULL ||</span></a>
<a name="21331"><span class="lineNum">   21331 </span><span class="lineNoCov">          0 :            isSgMemberFunctionRefExp(current) != NULL ||</span></a>
<a name="21332"><span class="lineNum">   21332 </span><span class="lineNoCov">          0 :            isSgTemplateMemberFunctionRefExp(current) != NULL)</span></a>
<a name="21333"><span class="lineNum">   21333 </span>            :   {</a>
<a name="21334"><span class="lineNum">   21334 </span>            :     //If a function is here it's probably related to a function pointer, it can't be converted to an SgInitailizedName</a>
<a name="21335"><span class="lineNum">   21335 </span><span class="lineNoCov">          0 :     return NULL;</span></a>
<a name="21336"><span class="lineNum">   21336 </span>            :   }</a>
<a name="21337"><span class="lineNum">   21337 </span><span class="lineNoCov">          0 :   else if (isSgNonrealRefExp(current) != NULL)</span></a>
<a name="21338"><span class="lineNum">   21338 </span>            :   {</a>
<a name="21339"><span class="lineNum">   21339 </span>            :     //SgNonrealRefExp is not a reasonable thing to convert to an SgInitializedName (I think) -Jim Leek</a>
<a name="21340"><span class="lineNum">   21340 </span>            :     return NULL;</a>
<a name="21341"><span class="lineNum">   21341 </span>            :   }</a>
<a name="21342"><span class="lineNum">   21342 </span><span class="lineNoCov">          0 :   else if (isSgDotExp(current))</span></a>
<a name="21343"><span class="lineNum">   21343 </span>            :   {</a>
<a name="21344"><span class="lineNum">   21344 </span><span class="lineNoCov">          0 :     SgExpression* child = NULL;</span></a>
<a name="21345"><span class="lineNum">   21345 </span><span class="lineNoCov">          0 :     if (coarseGrain)</span></a>
<a name="21346"><span class="lineNum">   21346 </span><span class="lineNoCov">          0 :      child= isSgDotExp(current)-&gt;get_lhs_operand();</span></a>
<a name="21347"><span class="lineNum">   21347 </span>            :     else</a>
<a name="21348"><span class="lineNum">   21348 </span><span class="lineNoCov">          0 :      child= isSgDotExp(current)-&gt;get_rhs_operand();</span></a>
<a name="21349"><span class="lineNum">   21349 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(child);</span></a>
<a name="21350"><span class="lineNum">   21350 </span>            :      // has to resolve this recursively</a>
<a name="21351"><span class="lineNum">   21351 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(child, coarseGrain);</span></a>
<a name="21352"><span class="lineNum">   21352 </span>            :   }</a>
<a name="21353"><span class="lineNum">   21353 </span><span class="lineNoCov">          0 :    else if (isSgArrowExp(current))</span></a>
<a name="21354"><span class="lineNum">   21354 </span>            :   {</a>
<a name="21355"><span class="lineNum">   21355 </span><span class="lineNoCov">          0 :     SgExpression* child = NULL;</span></a>
<a name="21356"><span class="lineNum">   21356 </span><span class="lineNoCov">          0 :     if (coarseGrain)</span></a>
<a name="21357"><span class="lineNum">   21357 </span>            :     {</a>
<a name="21358"><span class="lineNum">   21358 </span><span class="lineNoCov">          0 :       child = isSgArrowExp(current)-&gt;get_lhs_operand();</span></a>
<a name="21359"><span class="lineNum">   21359 </span><span class="lineNoCov">          0 :       SgExpression* lhs = isSgArrowExp(current)-&gt;get_lhs_operand();</span></a>
<a name="21360"><span class="lineNum">   21360 </span><span class="lineNoCov">          0 :       ROSE_ASSERT(lhs);</span></a>
<a name="21361"><span class="lineNum">   21361 </span>            :       // Liao 9/12/2016, special handling for variables inside of C++11 lambda functions</a>
<a name="21362"><span class="lineNum">   21362 </span>            :       // They capture variables outside of the lambda function.</a>
<a name="21363"><span class="lineNum">   21363 </span>            :       // They are represented as a class variable of an anonymous class, this-&gt;a[i]</a>
<a name="21364"><span class="lineNum">   21364 </span>            :       // So, we have to recognize this pattern, and pass the rhs variable to obtain initialized name.</a>
<a name="21365"><span class="lineNum">   21365 </span>            :       // has to resolve this recursively</a>
<a name="21366"><span class="lineNum">   21366 </span><span class="lineNoCov">          0 :       SgFunctionDeclaration* efunc =  getEnclosingFunctionDeclaration (current);</span></a>
<a name="21367"><span class="lineNum">   21367 </span>            : </a>
<a name="21368"><span class="lineNum">   21368 </span><span class="lineNoCov">          0 :       if (isLambdaFunction (efunc) )</span></a>
<a name="21369"><span class="lineNum">   21369 </span><span class="lineNoCov">          0 :         child= isSgArrowExp(current)-&gt;get_rhs_operand();</span></a>
<a name="21370"><span class="lineNum">   21370 </span>            :       else</a>
<a name="21371"><span class="lineNum">   21371 </span>            :         child = lhs;</a>
<a name="21372"><span class="lineNum">   21372 </span>            :     }</a>
<a name="21373"><span class="lineNum">   21373 </span>            :     else</a>
<a name="21374"><span class="lineNum">   21374 </span><span class="lineNoCov">          0 :       child = isSgArrowExp(current)-&gt;get_rhs_operand();</span></a>
<a name="21375"><span class="lineNum">   21375 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(child);</span></a>
<a name="21376"><span class="lineNum">   21376 </span>            :      // has to resolve this recursively</a>
<a name="21377"><span class="lineNum">   21377 </span>            : </a>
<a name="21378"><span class="lineNum">   21378 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(child, coarseGrain);</span></a>
<a name="21379"><span class="lineNum">   21379 </span>            :   } // The following expression types are usually introduced by left hand operands of DotExp, ArrowExp</a>
<a name="21380"><span class="lineNum">   21380 </span><span class="lineNoCov">          0 :   else if (isSgThisExp(current))</span></a>
<a name="21381"><span class="lineNum">   21381 </span>            :   {</a>
<a name="21382"><span class="lineNum">   21382 </span>            :     //SgThisExp* texp = isSgThisExp(current);</a>
<a name="21383"><span class="lineNum">   21383 </span>            :     name = NULL; // inside a class, there is no initialized name at all!! what to do??</a>
<a name="21384"><span class="lineNum">   21384 </span>            :   }</a>
<a name="21385"><span class="lineNum">   21385 </span><span class="lineNoCov">          0 :   else if (isSgPointerDerefExp(current))</span></a>
<a name="21386"><span class="lineNum">   21386 </span>            :   {</a>
<a name="21387"><span class="lineNum">   21387 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(isSgPointerDerefExp(current)-&gt;get_operand(), coarseGrain);</span></a>
<a name="21388"><span class="lineNum">   21388 </span>            :   }</a>
<a name="21389"><span class="lineNum">   21389 </span><span class="lineNoCov">          0 :   else if(isSgUnaryOp(current)) { //Written for SgAddressOfOp, but seems generally aplicable to all Unary Ops (replace above?) -JL</span></a>
<a name="21390"><span class="lineNum">   21390 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(isSgUnaryOp(current)-&gt;get_operand(), coarseGrain);</span></a>
<a name="21391"><span class="lineNum">   21391 </span>            :   }</a>
<a name="21392"><span class="lineNum">   21392 </span><span class="lineNoCov">          0 :   else if (isSgCastExp(current))</span></a>
<a name="21393"><span class="lineNum">   21393 </span>            :   {</a>
<a name="21394"><span class="lineNum">   21394 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(isSgCastExp(current)-&gt;get_operand(), coarseGrain);</span></a>
<a name="21395"><span class="lineNum">   21395 </span>            :   }</a>
<a name="21396"><span class="lineNum">   21396 </span>            :   // Scientific applications often use *(address + offset) to access array elements</a>
<a name="21397"><span class="lineNum">   21397 </span>            :   // If a pointer dereferencing  is applied to AddOp, we assume the left operand is the variable of our interests</a>
<a name="21398"><span class="lineNum">   21398 </span><span class="lineNoCov">          0 :   else if (isSgAddOp(current))</span></a>
<a name="21399"><span class="lineNum">   21399 </span>            :   {</a>
<a name="21400"><span class="lineNum">   21400 </span><span class="lineNoCov">          0 :     SgExpression* lhs = isSgAddOp(current)-&gt;get_lhs_operand();</span></a>
<a name="21401"><span class="lineNum">   21401 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(lhs, coarseGrain);</span></a>
<a name="21402"><span class="lineNum">   21402 </span>            :   }</a>
<a name="21403"><span class="lineNum">   21403 </span><span class="lineNoCov">          0 :   else if (isSgSubtractOp(current))</span></a>
<a name="21404"><span class="lineNum">   21404 </span>            :   {</a>
<a name="21405"><span class="lineNum">   21405 </span><span class="lineNoCov">          0 :     SgExpression* lhs = isSgSubtractOp(current)-&gt;get_lhs_operand();</span></a>
<a name="21406"><span class="lineNum">   21406 </span><span class="lineNoCov">          0 :     return convertRefToInitializedName(lhs, coarseGrain);</span></a>
<a name="21407"><span class="lineNum">   21407 </span>            :   }</a>
<a name="21408"><span class="lineNum">   21408 </span>            :   // operator-&gt;() may be called upon a class object.</a>
<a name="21409"><span class="lineNum">   21409 </span>            :   // e.g.  we need to get the function: it a SgDotExp node, (lhs is the class object, rhs is its member function)</a>
<a name="21410"><span class="lineNum">   21410 </span><span class="lineNoCov">          0 :   else if (SgFunctionCallExp * func_call = isSgFunctionCallExp(current))</span></a>
<a name="21411"><span class="lineNum">   21411 </span>            :   {</a>
<a name="21412"><span class="lineNum">   21412 </span><span class="lineNoCov">          0 :       return convertRefToInitializedName(func_call-&gt;get_function(), coarseGrain);</span></a>
<a name="21413"><span class="lineNum">   21413 </span>            :   }</a>
<a name="21414"><span class="lineNum">   21414 </span><span class="lineNoCov">          0 :   else if (isSgIntVal(current))</span></a>
<a name="21415"><span class="lineNum">   21415 </span>            :   {</a>
<a name="21416"><span class="lineNum">   21416 </span>            :       //It is very rare, but sometimes a constant is treated as a</a>
<a name="21417"><span class="lineNum">   21417 </span>            :       //variable.  In which case we don't need an SgInitializdName</a>
<a name="21418"><span class="lineNum">   21418 </span>            :       return NULL;</a>
<a name="21419"><span class="lineNum">   21419 </span>            :   }</a>
<a name="21420"><span class="lineNum">   21420 </span>            : </a>
<a name="21421"><span class="lineNum">   21421 </span>            :   else</a>
<a name="21422"><span class="lineNum">   21422 </span>            :   {</a>
<a name="21423"><span class="lineNum">   21423 </span>            :       // side effect analysis will return rhs of  Class A a = A(); as a read ref exp. SgConstructorInitializer</a>
<a name="21424"><span class="lineNum">   21424 </span><span class="lineNoCov">          0 :       if (!isSgConstructorInitializer(current))</span></a>
<a name="21425"><span class="lineNum">   21425 </span>            :       {</a>
<a name="21426"><span class="lineNum">   21426 </span><span class="lineNoCov">          0 :           mlog[Sawyer::Message::Common::WARN] &lt;&lt;</span></a>
<a name="21427"><span class="lineNum">   21427 </span>            :               &quot;convertRefToInitializedName: &quot; &lt;&lt;</a>
<a name="21428"><span class="lineNum">   21428 </span><span class="lineNoCov">          0 :               current-&gt;get_file_info()-&gt;get_filename() &lt;&lt; &quot;:&quot; &lt;&lt;</span></a>
<a name="21429"><span class="lineNum">   21429 </span><span class="lineNoCov">          0 :               current-&gt;get_file_info()-&gt;get_line() &lt;&lt; &quot;-&quot; &lt;&lt; current-&gt;get_file_info()-&gt;get_col()&lt;&lt;endl;</span></a>
<a name="21430"><span class="lineNum">   21430 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;In SageInterface::convertRefToInitializedName(): unhandled reference type:&quot;&lt;&lt;current-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="21431"><span class="lineNum">   21431 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="21432"><span class="lineNum">   21432 </span>            :       }</a>
<a name="21433"><span class="lineNum">   21433 </span>            :   }</a>
<a name="21434"><span class="lineNum">   21434 </span>            :   //ROSE_ASSERT(name != NULL);</a>
<a name="21435"><span class="lineNum">   21435 </span>            :   return name;</a>
<a name="21436"><span class="lineNum">   21436 </span>            : }</a>
<a name="21437"><span class="lineNum">   21437 </span>            : </a>
<a name="21438"><span class="lineNum">   21438 </span>            : //! Obtain a matching SgNode from an abstract handle string</a>
<a name="21439"><span class="lineNum">   21439 </span><span class="lineCov">         30 : SgNode* SageInterface::getSgNodeFromAbstractHandleString(const std::string&amp; input_string)</span></a>
<a name="21440"><span class="lineNum">   21440 </span>            : {</a>
<a name="21441"><span class="lineNum">   21441 </span>            : #ifdef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="21442"><span class="lineNum">   21442 </span>            :   printf (&quot;AbstractHandle support is disabled for ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT \n&quot;);</a>
<a name="21443"><span class="lineNum">   21443 </span>            :   ROSE_ABORT();</a>
<a name="21444"><span class="lineNum">   21444 </span>            : #else</a>
<a name="21445"><span class="lineNum">   21445 </span><span class="lineCov">         30 :   AbstractHandle::abstract_handle * project_handle = buildAbstractHandle(getProject());</span></a>
<a name="21446"><span class="lineNum">   21446 </span>            : </a>
<a name="21447"><span class="lineNum">   21447 </span>            :   // trim off the possible leading handle for project: &quot;Project&lt;numbering,1&gt;::&quot;</a>
<a name="21448"><span class="lineNum">   21448 </span><span class="lineCov">         30 :   size_t pos = input_string.find(&quot;SourceFile&lt;&quot;);</span></a>
<a name="21449"><span class="lineNum">   21449 </span><span class="lineCov">         30 :   ROSE_ASSERT (pos != string::npos);</span></a>
<a name="21450"><span class="lineNum">   21450 </span><span class="lineCov">         60 :   string trimed_string = input_string.substr(pos);</span></a>
<a name="21451"><span class="lineNum">   21451 </span><span class="lineCov">         30 :   AbstractHandle::abstract_handle * handle = new AbstractHandle::abstract_handle(project_handle, trimed_string);</span></a>
<a name="21452"><span class="lineNum">   21452 </span><span class="lineCov">         30 :   if (handle)</span></a>
<a name="21453"><span class="lineNum">   21453 </span>            :   {</a>
<a name="21454"><span class="lineNum">   21454 </span><span class="lineCov">         30 :     if (handle-&gt;getNode()!=NULL)</span></a>
<a name="21455"><span class="lineNum">   21455 </span>            :     {</a>
<a name="21456"><span class="lineNum">   21456 </span>            : #ifdef _MSC_VER</a>
<a name="21457"><span class="lineNum">   21457 </span>            :      // DQ (11/28/2009): This is related to the use of covariant return types (I think).</a>
<a name="21458"><span class="lineNum">   21458 </span>            : SgNode* result = NULL; // (SgNode*)(handle-&gt;getNode()-&gt;getNode());</a>
<a name="21459"><span class="lineNum">   21459 </span>            : #pragma message (&quot;WARNING: covariant return type for get_node() not supported in MSVC.&quot;)</a>
<a name="21460"><span class="lineNum">   21460 </span>            :                 printf (&quot;ERROR: covariant return type for get_node() not supported in MSVC. \n&quot;);</a>
<a name="21461"><span class="lineNum">   21461 </span>            :                 ROSE_ABORT();</a>
<a name="21462"><span class="lineNum">   21462 </span>            : #else</a>
<a name="21463"><span class="lineNum">   21463 </span><span class="lineCov">         30 :                 SgNode* result = (SgNode*)(handle-&gt;getNode()-&gt;getNode());</span></a>
<a name="21464"><span class="lineNum">   21464 </span>            : #endif</a>
<a name="21465"><span class="lineNum">   21465 </span>            :       // deallocate memory, should not do this!!</a>
<a name="21466"><span class="lineNum">   21466 </span>            :       // May corrupt the internal std maps used in abstract handle namespace</a>
<a name="21467"><span class="lineNum">   21467 </span>            :       //delete handle-&gt;getNode();</a>
<a name="21468"><span class="lineNum">   21468 </span>            :       //delete handle;</a>
<a name="21469"><span class="lineNum">   21469 </span>            :       return result;</a>
<a name="21470"><span class="lineNum">   21470 </span>            :     }</a>
<a name="21471"><span class="lineNum">   21471 </span>            :   }</a>
<a name="21472"><span class="lineNum">   21472 </span>            : #endif</a>
<a name="21473"><span class="lineNum">   21473 </span>            : </a>
<a name="21474"><span class="lineNum">   21474 </span>            :   return NULL;</a>
<a name="21475"><span class="lineNum">   21475 </span>            : }</a>
<a name="21476"><span class="lineNum">   21476 </span>            : </a>
<a name="21477"><span class="lineNum">   21477 </span>            : </a>
<a name="21478"><span class="lineNum">   21478 </span>            : //! Dump information about a SgNode for debugging</a>
<a name="21479"><span class="lineNum">   21479 </span>            : // unparseToString() is too strict for debugging purpose</a>
<a name="21480"><span class="lineNum">   21480 </span>            : //  we provide this instead.</a>
<a name="21481"><span class="lineNum">   21481 </span><span class="lineCov">      10761 : void SageInterface::dumpInfo(SgNode* node, std::string desc/*=&quot;&quot;*/)</span></a>
<a name="21482"><span class="lineNum">   21482 </span>            : {</a>
<a name="21483"><span class="lineNum">   21483 </span><span class="lineCov">      10761 :   ROSE_ASSERT(node != NULL);</span></a>
<a name="21484"><span class="lineNum">   21484 </span><span class="lineCov">      10761 :   cout&lt;&lt;desc&lt;&lt;endl;</span></a>
<a name="21485"><span class="lineNum">   21485 </span>            :   // base information for all SgNode:</a>
<a name="21486"><span class="lineNum">   21486 </span><span class="lineCov">      10761 :   cout&lt;&lt;&quot;///////////// begin of SageInterface::dumpInfo() ///////////////&quot;&lt;&lt;endl;</span></a>
<a name="21487"><span class="lineNum">   21487 </span><span class="lineCov">      10761 :   cout&lt;&lt;&quot;--------------base info. for SgNode---------------&quot;&lt;&lt;endl;</span></a>
<a name="21488"><span class="lineNum">   21488 </span><span class="lineCov">      10761 :   cout&lt;&lt;node&lt;&lt;&quot; &quot;&lt;&lt;node-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="21489"><span class="lineNum">   21489 </span><span class="lineCov">      10761 :   SgLocatedNode* snode = isSgLocatedNode(node);</span></a>
<a name="21490"><span class="lineNum">   21490 </span><span class="lineCov">      10761 :   if (snode)</span></a>
<a name="21491"><span class="lineNum">   21491 </span>            :   {</a>
<a name="21492"><span class="lineNum">   21492 </span>            :     // source file info. dump</a>
<a name="21493"><span class="lineNum">   21493 </span><span class="lineCov">      10761 :     cout&lt;&lt;&quot;--------------source location info. for SgNode---------------&quot;&lt;&lt;endl;</span></a>
<a name="21494"><span class="lineNum">   21494 </span><span class="lineCov">      10761 :     cout&lt;&lt;snode-&gt;get_file_info()-&gt;get_filename()</span></a>
<a name="21495"><span class="lineNum">   21495 </span><span class="lineCov">      10761 :       &lt;&lt; &quot;:&quot;&lt;&lt;snode-&gt;get_file_info()-&gt;get_line()&lt;&lt;&quot;-&quot;</span></a>
<a name="21496"><span class="lineNum">   21496 </span><span class="lineCov">      10761 :       &lt;&lt; snode-&gt;get_file_info()-&gt;get_col()&lt;&lt;endl;</span></a>
<a name="21497"><span class="lineNum">   21497 </span>            :     // preprocessing info dump</a>
<a name="21498"><span class="lineNum">   21498 </span><span class="lineCov">      10761 :     AttachedPreprocessingInfoType *comments = snode-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="21499"><span class="lineNum">   21499 </span><span class="lineCov">      10761 :     if (comments)</span></a>
<a name="21500"><span class="lineNum">   21500 </span>            :     {</a>
<a name="21501"><span class="lineNum">   21501 </span><span class="lineCov">          9 :       cout&lt;&lt;&quot;--------------preprocessing info. for SgNode---------------&quot;&lt;&lt;endl;</span></a>
<a name="21502"><span class="lineNum">   21502 </span><span class="lineCov">          9 :       AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="21503"><span class="lineNum">   21503 </span><span class="lineCov">          9 :       cout&lt;&lt;&quot;Total attached preprocessingInfo count=&quot;&lt;&lt;comments-&gt;size()&lt;&lt;endl;</span></a>
<a name="21504"><span class="lineNum">   21504 </span><span class="lineCov">         24 :       for (i = comments-&gt;begin (); i != comments-&gt;end (); i++)</span></a>
<a name="21505"><span class="lineNum">   21505 </span>            :       {</a>
<a name="21506"><span class="lineNum">   21506 </span><span class="lineCov">         15 :         PreprocessingInfo * pinfo = *i;</span></a>
<a name="21507"><span class="lineNum">   21507 </span><span class="lineCov">         30 :         pinfo-&gt;display(&quot;&quot;);</span></a>
<a name="21508"><span class="lineNum">   21508 </span>            :       }</a>
<a name="21509"><span class="lineNum">   21509 </span>            :     }</a>
<a name="21510"><span class="lineNum">   21510 </span><span class="lineCov">      10761 :     cout&lt;&lt;&quot;--------------name info. for SgNode---------------&quot;&lt;&lt;endl;</span></a>
<a name="21511"><span class="lineNum">   21511 </span>            :     // print out namea for named nodes</a>
<a name="21512"><span class="lineNum">   21512 </span><span class="lineCov">      10761 :     SgFunctionDeclaration * decl = isSgFunctionDeclaration(snode);</span></a>
<a name="21513"><span class="lineNum">   21513 </span><span class="lineCov">      10761 :     if (decl)</span></a>
<a name="21514"><span class="lineNum">   21514 </span><span class="lineCov">      10761 :       cout&lt;&lt;&quot;\tqualified name=&quot;&lt;&lt;decl-&gt;get_qualified_name().getString()&lt;&lt;endl;</span></a>
<a name="21515"><span class="lineNum">   21515 </span><span class="lineCov">      10761 :     SgVarRefExp * varRef =  isSgVarRefExp(snode);</span></a>
<a name="21516"><span class="lineNum">   21516 </span><span class="lineCov">      10761 :     if (varRef)</span></a>
<a name="21517"><span class="lineNum">   21517 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;\treferenced variable name= &quot;&lt;&lt;varRef-&gt;get_symbol()-&gt;get_name().getString()&lt;&lt;endl;</span></a>
<a name="21518"><span class="lineNum">   21518 </span>            :   }</a>
<a name="21519"><span class="lineNum">   21519 </span><span class="lineCov">      10761 :   SgInitializedName * iname = isSgInitializedName(snode);</span></a>
<a name="21520"><span class="lineNum">   21520 </span><span class="lineCov">      10761 :   if (iname)</span></a>
<a name="21521"><span class="lineNum">   21521 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;\tvariable name= &quot;&lt;&lt;iname-&gt;get_qualified_name().getString()&lt;&lt;endl;</span></a>
<a name="21522"><span class="lineNum">   21522 </span>            : </a>
<a name="21523"><span class="lineNum">   21523 </span><span class="lineCov">      10761 :   cout&lt;&lt;endl;</span></a>
<a name="21524"><span class="lineNum">   21524 </span><span class="lineCov">      10761 :   cout&lt;&lt;&quot;///////////// end of SageInterface::dumpInfo() ///////////////&quot;&lt;&lt;endl;</span></a>
<a name="21525"><span class="lineNum">   21525 </span><span class="lineCov">      10761 : }</span></a>
<a name="21526"><span class="lineNum">   21526 </span>            : </a>
<a name="21527"><span class="lineNum">   21527 </span>            : //! Collect all read and write references within stmt, which can be a function, a scope statement, or a single statement. Note that a reference can be both read and written, like i++</a>
<a name="21528"><span class="lineNum">   21528 </span>            : //! This is a wrapper function to Qing's side effect analysis from loop optimization</a>
<a name="21529"><span class="lineNum">   21529 </span>            : //! Liao, 2/26/2009</a>
<a name="21530"><span class="lineNum">   21530 </span>            : //! Returns true if the side effect analysis was complete, false otherwise.  Note that a false result is expected</a>
<a name="21531"><span class="lineNum">   21531 </span>            : //! if any functions are called in the body</a>
<a name="21532"><span class="lineNum">   21532 </span>            : bool</a>
<a name="21533"><span class="lineNum">   21533 </span><span class="lineCov">          2 : SageInterface::collectReadWriteRefs(SgStatement* stmt, std::vector&lt;SgNode*&gt;&amp; readRefs, std::vector&lt;SgNode*&gt;&amp; writeRefs, bool useCachedDefUse)</span></a>
<a name="21534"><span class="lineNum">   21534 </span>            : {   // The type cannot be SgExpression since variable declarations have SgInitializedName as the reference, not SgVarRefExp.</a>
<a name="21535"><span class="lineNum">   21535 </span><span class="lineCov">          2 :   bool retVal = true;</span></a>
<a name="21536"><span class="lineNum">   21536 </span>            : </a>
<a name="21537"><span class="lineNum">   21537 </span><span class="lineCov">          2 :   ROSE_ASSERT(stmt !=NULL);</span></a>
<a name="21538"><span class="lineNum">   21538 </span>            : </a>
<a name="21539"><span class="lineNum">   21539 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="21540"><span class="lineNum">   21540 </span>            :   // We should allow accumulate the effects for multiple statements</a>
<a name="21541"><span class="lineNum">   21541 </span>            :   // ROSE_ASSERT(readRefs.size() == 0);</a>
<a name="21542"><span class="lineNum">   21542 </span>            :   // ROSE_ASSERT(writeRefs.size() == 0);</a>
<a name="21543"><span class="lineNum">   21543 </span>            : </a>
<a name="21544"><span class="lineNum">   21544 </span>            :   // convert a request for a defining function declaration to its function body</a>
<a name="21545"><span class="lineNum">   21545 </span><span class="lineCov">          2 :   SgFunctionDeclaration* funcDecl = isSgFunctionDeclaration(stmt);</span></a>
<a name="21546"><span class="lineNum">   21546 </span><span class="lineCov">          2 :   if (funcDecl != NULL)</span></a>
<a name="21547"><span class="lineNum">   21547 </span>            :   {</a>
<a name="21548"><span class="lineNum">   21548 </span><span class="lineCov">          2 :     funcDecl= isSgFunctionDeclaration(funcDecl-&gt;get_definingDeclaration ());</span></a>
<a name="21549"><span class="lineNum">   21549 </span><span class="lineCov">          2 :     if (funcDecl == NULL)</span></a>
<a name="21550"><span class="lineNum">   21550 </span>            :     {</a>
<a name="21551"><span class="lineNum">   21551 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;&quot;In collectReadWriteRefs(): cannot proceed without a function body!&quot;&lt;&lt;endl;</span></a>
<a name="21552"><span class="lineNum">   21552 </span>            :     }</a>
<a name="21553"><span class="lineNum">   21553 </span><span class="lineCov">          2 :     stmt = funcDecl-&gt;get_definition()-&gt;get_body();</span></a>
<a name="21554"><span class="lineNum">   21554 </span>            :   }</a>
<a name="21555"><span class="lineNum">   21555 </span>            : </a>
<a name="21556"><span class="lineNum">   21556 </span>            :   // get function level information</a>
<a name="21557"><span class="lineNum">   21557 </span><span class="lineCov">          2 :   SgFunctionDefinition* funcDef = isSgFunctionDefinition(stmt);</span></a>
<a name="21558"><span class="lineNum">   21558 </span><span class="lineCov">          2 :   if (!funcDef)</span></a>
<a name="21559"><span class="lineNum">   21559 </span><span class="lineCov">          2 :      funcDef= SageInterface::getEnclosingFunctionDefinition(stmt);</span></a>
<a name="21560"><span class="lineNum">   21560 </span>            : </a>
<a name="21561"><span class="lineNum">   21561 </span><span class="lineCov">          2 :   ROSE_ASSERT(funcDef != NULL);</span></a>
<a name="21562"><span class="lineNum">   21562 </span><span class="lineCov">          2 :   SgBasicBlock* funcBody = funcDef-&gt;get_body();</span></a>
<a name="21563"><span class="lineNum">   21563 </span><span class="lineCov">          2 :   ROSE_ASSERT(funcBody!= NULL);</span></a>
<a name="21564"><span class="lineNum">   21564 </span>            : </a>
<a name="21565"><span class="lineNum">   21565 </span>            :   // prepare Loop transformation environment</a>
<a name="21566"><span class="lineNum">   21566 </span><span class="lineCov">          2 :   AstInterfaceImpl faImpl(funcBody);</span></a>
<a name="21567"><span class="lineNum">   21567 </span><span class="lineCov">          4 :   AstInterface fa(&amp;faImpl);</span></a>
<a name="21568"><span class="lineNum">   21568 </span><span class="lineCov">          2 :   ArrayAnnotation* annot = ArrayAnnotation::get_inst();</span></a>
<a name="21569"><span class="lineNum">   21569 </span><span class="lineCov">          2 :   if( useCachedDefUse ){</span></a>
<a name="21570"><span class="lineNum">   21570 </span><span class="lineNoCov">          0 :     ArrayInterface* array_interface = ArrayInterface::get_inst(*annot, fa, funcDef, AstNodePtrImpl(funcDef));</span></a>
<a name="21571"><span class="lineNum">   21571 </span><span class="lineNoCov">          0 :     LoopTransformInterface::set_arrayInfo(array_interface);</span></a>
<a name="21572"><span class="lineNum">   21572 </span>            :   } else {</a>
<a name="21573"><span class="lineNum">   21573 </span><span class="lineCov">          4 :     ArrayInterface array_interface(*annot);</span></a>
<a name="21574"><span class="lineNum">   21574 </span>            :  // Alias analysis and value propagation are called in initialize(). Turn both off for now.</a>
<a name="21575"><span class="lineNum">   21575 </span>            : //    array_interface.initialize(fa, AstNodePtrImpl(funcDef));</a>
<a name="21576"><span class="lineNum">   21576 </span><span class="lineCov">          2 :     array_interface.observe(fa);</span></a>
<a name="21577"><span class="lineNum">   21577 </span><span class="lineCov">          2 :     LoopTransformInterface::set_arrayInfo(&amp;array_interface);</span></a>
<a name="21578"><span class="lineNum">   21578 </span>            :   }</a>
<a name="21579"><span class="lineNum">   21579 </span><span class="lineCov">          2 :   LoopTransformInterface::set_astInterface(fa);</span></a>
<a name="21580"><span class="lineNum">   21580 </span>            :   // Liao, 3/27/2015. connect to annotations for function side effect</a>
<a name="21581"><span class="lineNum">   21581 </span><span class="lineCov">          2 :   LoopTransformInterface::set_sideEffectInfo(annot);</span></a>
<a name="21582"><span class="lineNum">   21582 </span>            : </a>
<a name="21583"><span class="lineNum">   21583 </span>            :   // variables to store results</a>
<a name="21584"><span class="lineNum">   21584 </span><span class="lineCov">          4 :   DoublyLinkedListWrap&lt;AstNodePtr&gt; rRef1, wRef1;</span></a>
<a name="21585"><span class="lineNum">   21585 </span><span class="lineCov">          4 :   CollectDoublyLinkedList&lt;AstNodePtr&gt; crRef1(rRef1),cwRef1(wRef1);</span></a>
<a name="21586"><span class="lineNum">   21586 </span><span class="lineCov">          4 :   AstNodePtr s1 = AstNodePtrImpl(stmt);</span></a>
<a name="21587"><span class="lineNum">   21587 </span>            : </a>
<a name="21588"><span class="lineNum">   21588 </span>            :   // Actual side effect analysis</a>
<a name="21589"><span class="lineNum">   21589 </span><span class="lineCov">          2 :   if (!AnalyzeStmtRefs(fa, s1, cwRef1, crRef1))</span></a>
<a name="21590"><span class="lineNum">   21590 </span>            :   {</a>
<a name="21591"><span class="lineNum">   21591 </span><span class="lineNoCov">          0 :     mlog[Sawyer::Message::Common::WARN] &lt;&lt; &quot;Side Effect Analysis incomplete on &quot; &lt;&lt; funcDef-&gt;get_declaration()-&gt;get_qualified_name() &lt;&lt; endl;</span></a>
<a name="21592"><span class="lineNum">   21592 </span>            :     //It's incomplete, but it's not useless, we still want the reflist returned. -Jim</a>
<a name="21593"><span class="lineNum">   21593 </span><span class="lineNoCov">          0 :     retVal = false;</span></a>
<a name="21594"><span class="lineNum">   21594 </span>            :   }</a>
<a name="21595"><span class="lineNum">   21595 </span>            : </a>
<a name="21596"><span class="lineNum">   21596 </span>            :   // transfer results into STL containers.</a>
<a name="21597"><span class="lineNum">   21597 </span><span class="lineCov">         30 :   for (DoublyLinkedEntryWrap&lt;AstNodePtr&gt;* p = rRef1.First(); p != 0; )</span></a>
<a name="21598"><span class="lineNum">   21598 </span>            :   {</a>
<a name="21599"><span class="lineNum">   21599 </span><span class="lineCov">         28 :     DoublyLinkedEntryWrap&lt;AstNodePtr&gt;* p1 = p;</span></a>
<a name="21600"><span class="lineNum">   21600 </span><span class="lineCov">         28 :     p = rRef1.Next(p);</span></a>
<a name="21601"><span class="lineNum">   21601 </span><span class="lineCov">         56 :     AstNodePtr cur = p1-&gt;GetEntry();</span></a>
<a name="21602"><span class="lineNum">   21602 </span><span class="lineCov">         28 :     SgNode* sgRef = AstNodePtrImpl(cur).get_ptr();</span></a>
<a name="21603"><span class="lineNum">   21603 </span><span class="lineCov">         28 :    ROSE_ASSERT(sgRef != NULL);</span></a>
<a name="21604"><span class="lineNum">   21604 </span><span class="lineCov">         28 :     readRefs.push_back(sgRef);</span></a>
<a name="21605"><span class="lineNum">   21605 </span>            :     //cout&lt;&lt;&quot;read reference:&quot;&lt;&lt;sgRef-&gt;unparseToString()&lt;&lt;&quot; address &quot;&lt;&lt;sgRef&lt;&lt;</a>
<a name="21606"><span class="lineNum">   21606 </span>            :     //    &quot; sage type:&quot;&lt;&lt; sgRef-&gt;class_name()&lt;&lt; endl;</a>
<a name="21607"><span class="lineNum">   21607 </span>            :   }</a>
<a name="21608"><span class="lineNum">   21608 </span>            : </a>
<a name="21609"><span class="lineNum">   21609 </span><span class="lineCov">         18 :   for (DoublyLinkedEntryWrap&lt;AstNodePtr&gt;* p = wRef1.First(); p != 0; )</span></a>
<a name="21610"><span class="lineNum">   21610 </span>            :   {</a>
<a name="21611"><span class="lineNum">   21611 </span><span class="lineCov">         16 :     DoublyLinkedEntryWrap&lt;AstNodePtr&gt;* p1 = p;</span></a>
<a name="21612"><span class="lineNum">   21612 </span><span class="lineCov">         16 :     p = wRef1.Next(p);</span></a>
<a name="21613"><span class="lineNum">   21613 </span><span class="lineCov">         32 :     AstNodePtr cur = p1-&gt;GetEntry();</span></a>
<a name="21614"><span class="lineNum">   21614 </span><span class="lineCov">         16 :     SgNode* sgRef = AstNodePtrImpl(cur).get_ptr();</span></a>
<a name="21615"><span class="lineNum">   21615 </span><span class="lineCov">         16 :     ROSE_ASSERT(sgRef != NULL);</span></a>
<a name="21616"><span class="lineNum">   21616 </span><span class="lineCov">         16 :     writeRefs.push_back(sgRef);</span></a>
<a name="21617"><span class="lineNum">   21617 </span>            :   //  cout&lt;&lt;&quot;write reference:&quot;&lt;&lt;sgRef-&gt;unparseToString()&lt;&lt;&quot; address &quot;&lt;&lt;sgRef&lt;&lt;</a>
<a name="21618"><span class="lineNum">   21618 </span>            :   //      &quot; sage type:&quot;&lt;&lt; sgRef-&gt;class_name()&lt;&lt; endl;</a>
<a name="21619"><span class="lineNum">   21619 </span>            :   }</a>
<a name="21620"><span class="lineNum">   21620 </span>            : </a>
<a name="21621"><span class="lineNum">   21621 </span>            : #endif</a>
<a name="21622"><span class="lineNum">   21622 </span>            : </a>
<a name="21623"><span class="lineNum">   21623 </span><span class="lineCov">          4 :   return retVal;</span></a>
<a name="21624"><span class="lineNum">   21624 </span>            : }</a>
<a name="21625"><span class="lineNum">   21625 </span>            : #if 0</a>
<a name="21626"><span class="lineNum">   21626 </span>            : // The side effect analysis will report three references for a statement like this-&gt;x = ...</a>
<a name="21627"><span class="lineNum">   21627 </span>            : // 1.SgThisExp 2. SgArrowExp  3. SgVarRefExp</a>
<a name="21628"><span class="lineNum">   21628 </span>            : // We only need to keep SgVarRefExp and skip the other two.</a>
<a name="21629"><span class="lineNum">   21629 </span>            : static bool skipSomeRefs(SgNode* n)</a>
<a name="21630"><span class="lineNum">   21630 </span>            : {</a>
<a name="21631"><span class="lineNum">   21631 </span>            :   ROSE_ASSERT (n);</a>
<a name="21632"><span class="lineNum">   21632 </span>            :   return (isSgThisExp(n)||isSgArrowExp(n)||isSgDotExp(n));</a>
<a name="21633"><span class="lineNum">   21633 </span>            : }</a>
<a name="21634"><span class="lineNum">   21634 </span>            : #endif</a>
<a name="21635"><span class="lineNum">   21635 </span>            : //!Collect unique variables which are read or written within a statement. Note that a variable can be both read and written. The statement can be either of a function, a scope, or a single line statement.</a>
<a name="21636"><span class="lineNum">   21636 </span><span class="lineCov">          2 : bool SageInterface::collectReadWriteVariables(SgStatement* stmt, set&lt;SgInitializedName*&gt;&amp; readVars, set&lt;SgInitializedName*&gt;&amp; writeVars, bool coarseGrain/*=true*/)</span></a>
<a name="21637"><span class="lineNum">   21637 </span>            : {</a>
<a name="21638"><span class="lineNum">   21638 </span><span class="lineCov">          2 :   ROSE_ASSERT(stmt != NULL);</span></a>
<a name="21639"><span class="lineNum">   21639 </span><span class="lineCov">          4 :   vector &lt;SgNode* &gt; readRefs, writeRefs;</span></a>
<a name="21640"><span class="lineNum">   21640 </span>            : </a>
<a name="21641"><span class="lineNum">   21641 </span><span class="lineCov">          2 :   bool retVal = collectReadWriteRefs(stmt, readRefs, writeRefs);</span></a>
<a name="21642"><span class="lineNum">   21642 </span>            :   // process read references</a>
<a name="21643"><span class="lineNum">   21643 </span><span class="lineCov">          2 :   vector&lt;SgNode*&gt;::iterator iter = readRefs.begin();</span></a>
<a name="21644"><span class="lineNum">   21644 </span><span class="lineCov">         30 :   for (; iter!=readRefs.end();iter++)</span></a>
<a name="21645"><span class="lineNum">   21645 </span>            :   {</a>
<a name="21646"><span class="lineNum">   21646 </span><span class="lineCov">         28 :     SgNode* current = *iter;</span></a>
<a name="21647"><span class="lineNum">   21647 </span>            :     //if (skipSomeRefs(current)) continue;</a>
<a name="21648"><span class="lineNum">   21648 </span>            : </a>
<a name="21649"><span class="lineNum">   21649 </span><span class="lineCov">         28 :     ROSE_ASSERT (current != NULL);</span></a>
<a name="21650"><span class="lineNum">   21650 </span><span class="lineCov">         28 :     SgInitializedName* name= convertRefToInitializedName(current, coarseGrain);</span></a>
<a name="21651"><span class="lineNum">   21651 </span>            :     //ROSE_ASSERT (name); // this pointer will return NULL</a>
<a name="21652"><span class="lineNum">   21652 </span><span class="lineCov">         28 :     if (!name) continue;</span></a>
<a name="21653"><span class="lineNum">   21653 </span>            :    // Only insert unique ones</a>
<a name="21654"><span class="lineNum">   21654 </span>            :    // We use std::set to ensure uniqueness now</a>
<a name="21655"><span class="lineNum">   21655 </span><span class="lineCov">         28 :     readVars.insert(name);</span></a>
<a name="21656"><span class="lineNum">   21656 </span>            :   }</a>
<a name="21657"><span class="lineNum">   21657 </span>            :   // process write references</a>
<a name="21658"><span class="lineNum">   21658 </span><span class="lineCov">          2 :   vector&lt;SgNode*&gt;::iterator iterw = writeRefs.begin();</span></a>
<a name="21659"><span class="lineNum">   21659 </span><span class="lineCov">         18 :   for (; iterw!=writeRefs.end();iterw++)</span></a>
<a name="21660"><span class="lineNum">   21660 </span>            :   {</a>
<a name="21661"><span class="lineNum">   21661 </span><span class="lineCov">         16 :     SgNode* current = *iterw;</span></a>
<a name="21662"><span class="lineNum">   21662 </span><span class="lineCov">         16 :     ROSE_ASSERT (current != NULL);</span></a>
<a name="21663"><span class="lineNum">   21663 </span>            :    // if (skipSomeRefs(current)) continue;</a>
<a name="21664"><span class="lineNum">   21664 </span><span class="lineCov">         16 :     SgInitializedName* name = convertRefToInitializedName(current, coarseGrain);</span></a>
<a name="21665"><span class="lineNum">   21665 </span><span class="lineCov">         16 :     if (!name) continue;</span></a>
<a name="21666"><span class="lineNum">   21666 </span>            :     //ROSE_ASSERT (name); // this pointer will return NULL</a>
<a name="21667"><span class="lineNum">   21667 </span>            :    // Only insert unique ones</a>
<a name="21668"><span class="lineNum">   21668 </span>            :    // We use std::set to ensure uniqueness now</a>
<a name="21669"><span class="lineNum">   21669 </span><span class="lineCov">         16 :     writeVars.insert(name);</span></a>
<a name="21670"><span class="lineNum">   21670 </span>            :   }</a>
<a name="21671"><span class="lineNum">   21671 </span><span class="lineCov">          4 :   return retVal;</span></a>
<a name="21672"><span class="lineNum">   21672 </span>            : }</a>
<a name="21673"><span class="lineNum">   21673 </span>            : </a>
<a name="21674"><span class="lineNum">   21674 </span>            : //!Collect read only variables within a statement. The statement can be either of a function, a scope, or a single line statement.</a>
<a name="21675"><span class="lineNum">   21675 </span><span class="lineCov">          1 : void SageInterface::collectReadOnlyVariables(SgStatement* stmt, std::set&lt;SgInitializedName*&gt;&amp; readOnlyVars, bool coarseGrain/*=true*/)</span></a>
<a name="21676"><span class="lineNum">   21676 </span>            : {</a>
<a name="21677"><span class="lineNum">   21677 </span><span class="lineCov">          1 :   ROSE_ASSERT(stmt != NULL);</span></a>
<a name="21678"><span class="lineNum">   21678 </span><span class="lineCov">          2 :   set&lt;SgInitializedName*&gt; readVars, writeVars;</span></a>
<a name="21679"><span class="lineNum">   21679 </span>            :    // Only collect read only variables if collectReadWriteVariables() succeeded.</a>
<a name="21680"><span class="lineNum">   21680 </span><span class="lineCov">          1 :   if (collectReadWriteVariables(stmt, readVars, writeVars, coarseGrain))</span></a>
<a name="21681"><span class="lineNum">   21681 </span>            :   {</a>
<a name="21682"><span class="lineNum">   21682 </span>            :     // read only = read - write</a>
<a name="21683"><span class="lineNum">   21683 </span><span class="lineCov">          1 :     set_difference(readVars.begin(), readVars.end(),</span></a>
<a name="21684"><span class="lineNum">   21684 </span>            :         writeVars.begin(), writeVars.end(),</a>
<a name="21685"><span class="lineNum">   21685 </span><span class="lineCov">          1 :         std::inserter(readOnlyVars, readOnlyVars.begin()));</span></a>
<a name="21686"><span class="lineNum">   21686 </span>            :   }</a>
<a name="21687"><span class="lineNum">   21687 </span>            :   else // Qing's side effect analysis often fails, we do a simple type based read only variable collection, find all referenced variables of const type</a>
<a name="21688"><span class="lineNum">   21688 </span>            :   {</a>
<a name="21689"><span class="lineNum">   21689 </span><span class="lineNoCov">          0 :     RoseAst ast(stmt);</span></a>
<a name="21690"><span class="lineNum">   21690 </span>            : </a>
<a name="21691"><span class="lineNum">   21691 </span><span class="lineNoCov">          0 :     for(RoseAst::iterator i=ast.begin();i!=ast.end();++i) {</span></a>
<a name="21692"><span class="lineNum">   21692 </span><span class="lineNoCov">          0 :       if (SgVarRefExp* v_ref = isSgVarRefExp(*i))</span></a>
<a name="21693"><span class="lineNum">   21693 </span>            :       {</a>
<a name="21694"><span class="lineNum">   21694 </span><span class="lineNoCov">          0 :         if (isConstType(v_ref-&gt;get_type()))</span></a>
<a name="21695"><span class="lineNum">   21695 </span><span class="lineNoCov">          0 :           readOnlyVars.insert (v_ref-&gt;get_symbol()-&gt;get_declaration());</span></a>
<a name="21696"><span class="lineNum">   21696 </span>            :       }</a>
<a name="21697"><span class="lineNum">   21697 </span>            :     } // end for</a>
<a name="21698"><span class="lineNum">   21698 </span>            :   } // end else</a>
<a name="21699"><span class="lineNum">   21699 </span><span class="lineCov">          1 : }</span></a>
<a name="21700"><span class="lineNum">   21700 </span>            : </a>
<a name="21701"><span class="lineNum">   21701 </span>            : </a>
<a name="21702"><span class="lineNum">   21702 </span>            : //!Collect read only variable symbols within a statement. The statement can be either of a function, a scope, or a single line statement.</a>
<a name="21703"><span class="lineNum">   21703 </span><span class="lineNoCov">          0 : void SageInterface::collectReadOnlySymbols(SgStatement* stmt, std::set&lt;SgVariableSymbol*&gt;&amp; readOnlySymbols, bool coarseGrain/*=true*/)</span></a>
<a name="21704"><span class="lineNum">   21704 </span>            : {</a>
<a name="21705"><span class="lineNum">   21705 </span><span class="lineNoCov">          0 :   set&lt;SgInitializedName*&gt; temp;</span></a>
<a name="21706"><span class="lineNum">   21706 </span><span class="lineNoCov">          0 :   collectReadOnlyVariables(stmt, temp, coarseGrain);</span></a>
<a name="21707"><span class="lineNum">   21707 </span>            : </a>
<a name="21708"><span class="lineNum">   21708 </span><span class="lineNoCov">          0 :   for (set&lt;SgInitializedName*&gt;::const_iterator iter = temp.begin();</span></a>
<a name="21709"><span class="lineNum">   21709 </span><span class="lineNoCov">          0 :       iter!=temp.end(); iter++)</span></a>
<a name="21710"><span class="lineNum">   21710 </span>            :   {</a>
<a name="21711"><span class="lineNum">   21711 </span><span class="lineNoCov">          0 :     SgSymbol* symbol = (*iter)-&gt;get_symbol_from_symbol_table () ;</span></a>
<a name="21712"><span class="lineNum">   21712 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(symbol != NULL );</span></a>
<a name="21713"><span class="lineNum">   21713 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(isSgVariableSymbol(symbol));</span></a>
<a name="21714"><span class="lineNum">   21714 </span><span class="lineNoCov">          0 :     readOnlySymbols.insert(isSgVariableSymbol(symbol));</span></a>
<a name="21715"><span class="lineNum">   21715 </span>            :   }</a>
<a name="21716"><span class="lineNum">   21716 </span>            : </a>
<a name="21717"><span class="lineNum">   21717 </span><span class="lineNoCov">          0 : }</span></a>
<a name="21718"><span class="lineNum">   21718 </span>            : </a>
<a name="21719"><span class="lineNum">   21719 </span>            : //! Check if a variable reference is used by its address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++</a>
<a name="21720"><span class="lineNum">   21720 </span><span class="lineNoCov">          0 : bool SageInterface::isUseByAddressVariableRef(SgVarRefExp* ref)</span></a>
<a name="21721"><span class="lineNum">   21721 </span>            : {</a>
<a name="21722"><span class="lineNum">   21722 </span><span class="lineNoCov">          0 :   bool result = false;</span></a>
<a name="21723"><span class="lineNum">   21723 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(ref != NULL);</span></a>
<a name="21724"><span class="lineNum">   21724 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(ref-&gt;get_parent() != NULL);</span></a>
<a name="21725"><span class="lineNum">   21725 </span>            :   // case 1: ref is used as an operator for &amp; (SgAddressofOp)</a>
<a name="21726"><span class="lineNum">   21726 </span>            :   // TODO tolerate possible type casting operations in between ?</a>
<a name="21727"><span class="lineNum">   21727 </span><span class="lineNoCov">          0 :   if (isSgAddressOfOp(ref-&gt;get_parent()))</span></a>
<a name="21728"><span class="lineNum">   21728 </span>            :   {</a>
<a name="21729"><span class="lineNum">   21729 </span>            :     result = true;</a>
<a name="21730"><span class="lineNum">   21730 </span>            :   }</a>
<a name="21731"><span class="lineNum">   21731 </span>            :   // case 2. ref is used as a function call's parameter, and the parameter has reference type in C++</a>
<a name="21732"><span class="lineNum">   21732 </span><span class="lineNoCov">          0 :   else if ((SageInterface::is_Cxx_language())&amp;&amp;(isSgExprListExp(ref-&gt;get_parent())))</span></a>
<a name="21733"><span class="lineNum">   21733 </span>            :   {</a>
<a name="21734"><span class="lineNum">   21734 </span><span class="lineNoCov">          0 :     SgNode* grandparent = ref-&gt;get_parent()-&gt;get_parent();</span></a>
<a name="21735"><span class="lineNum">   21735 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(grandparent);</span></a>
<a name="21736"><span class="lineNum">   21736 </span><span class="lineNoCov">          0 :     if (isSgFunctionCallExp(grandparent)) // Is used as a function call's parameter</span></a>
<a name="21737"><span class="lineNum">   21737 </span>            :     {</a>
<a name="21738"><span class="lineNum">   21738 </span>            :       // find which parameter ref is in SgExpressionPtrList</a>
<a name="21739"><span class="lineNum">   21739 </span>            : </a>
<a name="21740"><span class="lineNum">   21740 </span>            :    // DQ (8/12/2020): This is a compiler warning where it is used below in comparision between signed and unsigned types.</a>
<a name="21741"><span class="lineNum">   21741 </span>            :    // int param_index = 0;</a>
<a name="21742"><span class="lineNum">   21742 </span><span class="lineNoCov">          0 :       size_t param_index = 0;</span></a>
<a name="21743"><span class="lineNum">   21743 </span>            : </a>
<a name="21744"><span class="lineNum">   21744 </span><span class="lineNoCov">          0 :       SgExpressionPtrList expList = isSgExprListExp(ref-&gt;get_parent())-&gt;get_expressions();</span></a>
<a name="21745"><span class="lineNum">   21745 </span><span class="lineNoCov">          0 :       Rose_STL_Container&lt;SgExpression*&gt;::const_iterator iter= expList.begin();</span></a>
<a name="21746"><span class="lineNum">   21746 </span><span class="lineNoCov">          0 :       for (; iter!=expList.end(); iter++)</span></a>
<a name="21747"><span class="lineNum">   21747 </span>            :       {</a>
<a name="21748"><span class="lineNum">   21748 </span><span class="lineNoCov">          0 :         if (*iter == ref)</span></a>
<a name="21749"><span class="lineNum">   21749 </span>            :           break;</a>
<a name="21750"><span class="lineNum">   21750 </span>            :         else</a>
<a name="21751"><span class="lineNum">   21751 </span><span class="lineNoCov">          0 :           param_index++;</span></a>
<a name="21752"><span class="lineNum">   21752 </span>            :       }</a>
<a name="21753"><span class="lineNum">   21753 </span>            :       // find the parameter type of the corresponding function declaration</a>
<a name="21754"><span class="lineNum">   21754 </span><span class="lineNoCov">          0 :       SgExpression* func_exp = isSgFunctionCallExp(grandparent)-&gt;get_function();</span></a>
<a name="21755"><span class="lineNum">   21755 </span><span class="lineNoCov">          0 :       ROSE_ASSERT (func_exp);</span></a>
<a name="21756"><span class="lineNum">   21756 </span><span class="lineNoCov">          0 :       SgFunctionRefExp * funcRef = isSgFunctionRefExp(func_exp);</span></a>
<a name="21757"><span class="lineNum">   21757 </span><span class="lineNoCov">          0 :       if (funcRef) // regular functions</span></a>
<a name="21758"><span class="lineNum">   21758 </span>            :       {</a>
<a name="21759"><span class="lineNum">   21759 </span><span class="lineNoCov">          0 :         SgFunctionDeclaration* funcDecl = isSgFunctionSymbol(funcRef-&gt;get_symbol())-&gt;get_declaration();</span></a>
<a name="21760"><span class="lineNum">   21760 </span><span class="lineNoCov">          0 :         SgInitializedNamePtrList nameList = funcDecl-&gt;get_args();</span></a>
<a name="21761"><span class="lineNum">   21761 </span>            :         //TODO tolerate typedef chains</a>
<a name="21762"><span class="lineNum">   21762 </span>            :         // printf() has only two arguments to express variable arguments.</a>
<a name="21763"><span class="lineNum">   21763 </span>            :         // The third argument index ==2 will be out of bounds for nameList[index]</a>
<a name="21764"><span class="lineNum">   21764 </span>            :         // So we must check the bound first.</a>
<a name="21765"><span class="lineNum">   21765 </span><span class="lineNoCov">          0 :         if (param_index &gt;= nameList.size() ||isSgTypeEllipse(nameList[param_index]-&gt;get_type()) )</span></a>
<a name="21766"><span class="lineNum">   21766 </span>            :         {</a>
<a name="21767"><span class="lineNum">   21767 </span><span class="lineNoCov">          0 :           if (isSgReferenceType(ref))</span></a>
<a name="21768"><span class="lineNum">   21768 </span><span class="lineNoCov">          0 :             result = true;</span></a>
<a name="21769"><span class="lineNum">   21769 </span>            :         }</a>
<a name="21770"><span class="lineNum">   21770 </span>            :         else // now within the bound: two situations,</a>
<a name="21771"><span class="lineNum">   21771 </span><span class="lineNoCov">          0 :         if (isSgReferenceType(nameList[param_index]-&gt;get_type()))</span></a>
<a name="21772"><span class="lineNum">   21772 </span>            :         {</a>
<a name="21773"><span class="lineNum">   21773 </span><span class="lineNoCov">          0 :           result = true;</span></a>
<a name="21774"><span class="lineNum">   21774 </span>            :         }</a>
<a name="21775"><span class="lineNum">   21775 </span>            :       } //It also could be a dot or arrow expression where its right hand operand is a SgMemberFunctionRefExp</a>
<a name="21776"><span class="lineNum">   21776 </span><span class="lineNoCov">          0 :       else if (isSgDotExp (func_exp) || isSgArrowExp(func_exp)) // ArrowExp TODO</span></a>
<a name="21777"><span class="lineNum">   21777 </span>            :       {</a>
<a name="21778"><span class="lineNum">   21778 </span><span class="lineNoCov">          0 :         SgBinaryOp* binOp = isSgBinaryOp(func_exp);</span></a>
<a name="21779"><span class="lineNum">   21779 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (binOp);</span></a>
<a name="21780"><span class="lineNum">   21780 </span><span class="lineNoCov">          0 :         SgMemberFunctionRefExp* mfuncRef = isSgMemberFunctionRefExp(binOp-&gt;get_rhs_operand_i());</span></a>
<a name="21781"><span class="lineNum">   21781 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (mfuncRef);</span></a>
<a name="21782"><span class="lineNum">   21782 </span><span class="lineNoCov">          0 :         SgMemberFunctionDeclaration * mfuncDecl = isSgMemberFunctionSymbol (mfuncRef-&gt;get_symbol())-&gt;get_declaration();</span></a>
<a name="21783"><span class="lineNum">   21783 </span><span class="lineNoCov">          0 :         ROSE_ASSERT (mfuncDecl);</span></a>
<a name="21784"><span class="lineNum">   21784 </span><span class="lineNoCov">          0 :         SgInitializedNamePtrList nameList = mfuncDecl-&gt;get_args();</span></a>
<a name="21785"><span class="lineNum">   21785 </span>            :         //TODO tolerate typedef chains</a>
<a name="21786"><span class="lineNum">   21786 </span><span class="lineNoCov">          0 :         if (isSgReferenceType(nameList[param_index]-&gt;get_type()))</span></a>
<a name="21787"><span class="lineNum">   21787 </span>            :         {</a>
<a name="21788"><span class="lineNum">   21788 </span><span class="lineNoCov">          0 :           result = true;</span></a>
<a name="21789"><span class="lineNum">   21789 </span>            :         }</a>
<a name="21790"><span class="lineNum">   21790 </span>            :       }</a>
<a name="21791"><span class="lineNum">   21791 </span>            : </a>
<a name="21792"><span class="lineNum">   21792 </span>            :     }</a>
<a name="21793"><span class="lineNum">   21793 </span>            :   }</a>
<a name="21794"><span class="lineNum">   21794 </span><span class="lineNoCov">          0 :   return result;</span></a>
<a name="21795"><span class="lineNum">   21795 </span>            : }</a>
<a name="21796"><span class="lineNum">   21796 </span>            : </a>
<a name="21797"><span class="lineNum">   21797 </span>            : </a>
<a name="21798"><span class="lineNum">   21798 </span>            : //! Collect variable references involving use by address: including &amp;a expression and foo(a) when foo(Type&amp; parameter) in C++</a>
<a name="21799"><span class="lineNum">   21799 </span><span class="lineNoCov">          0 : void SageInterface::collectUseByAddressVariableRefs (const SgStatement* s, std::set&lt;SgVarRefExp* &gt;&amp; varSetB)</span></a>
<a name="21800"><span class="lineNum">   21800 </span>            : {</a>
<a name="21801"><span class="lineNum">   21801 </span><span class="lineNoCov">          0 :   Rose_STL_Container &lt;SgNode*&gt; var_refs = NodeQuery::querySubTree (const_cast&lt;SgStatement *&gt; (s), V_SgVarRefExp);</span></a>
<a name="21802"><span class="lineNum">   21802 </span>            : </a>
<a name="21803"><span class="lineNum">   21803 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt;::iterator iter = var_refs.begin();</span></a>
<a name="21804"><span class="lineNum">   21804 </span><span class="lineNoCov">          0 :   for (; iter!=var_refs.end(); iter++)</span></a>
<a name="21805"><span class="lineNum">   21805 </span>            :   {</a>
<a name="21806"><span class="lineNum">   21806 </span><span class="lineNoCov">          0 :     SgVarRefExp* ref = isSgVarRefExp(*iter);</span></a>
<a name="21807"><span class="lineNum">   21807 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(ref != NULL);</span></a>
<a name="21808"><span class="lineNum">   21808 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(ref-&gt;get_parent() != NULL);</span></a>
<a name="21809"><span class="lineNum">   21809 </span>            : #if 0</a>
<a name="21810"><span class="lineNum">   21810 </span>            :     // case 1: ref is used as an operator for &amp; (SgAddressofOp)</a>
<a name="21811"><span class="lineNum">   21811 </span>            :     // TODO tolerate possible type casting operations in between ?</a>
<a name="21812"><span class="lineNum">   21812 </span>            :     if (isSgAddressOfOp(ref-&gt;get_parent()))</a>
<a name="21813"><span class="lineNum">   21813 </span>            :     {</a>
<a name="21814"><span class="lineNum">   21814 </span>            :       varSetB.insert(ref);</a>
<a name="21815"><span class="lineNum">   21815 </span>            :     }</a>
<a name="21816"><span class="lineNum">   21816 </span>            :     // case 2. ref is used as a function call's parameter, and the parameter has reference type in C++</a>
<a name="21817"><span class="lineNum">   21817 </span>            :     else if ((SageInterface::is_Cxx_language())&amp;&amp;(isSgExprListExp(ref-&gt;get_parent())))</a>
<a name="21818"><span class="lineNum">   21818 </span>            :     {</a>
<a name="21819"><span class="lineNum">   21819 </span>            :       SgNode* grandparent = ref-&gt;get_parent()-&gt;get_parent();</a>
<a name="21820"><span class="lineNum">   21820 </span>            :       ROSE_ASSERT(grandparent);</a>
<a name="21821"><span class="lineNum">   21821 </span>            :       if (isSgFunctionCallExp(grandparent)) // Is used as a function call's parameter</a>
<a name="21822"><span class="lineNum">   21822 </span>            :       {</a>
<a name="21823"><span class="lineNum">   21823 </span>            :         // find which parameter ref is in SgExpressionPtrList</a>
<a name="21824"><span class="lineNum">   21824 </span>            :         int param_index =0;</a>
<a name="21825"><span class="lineNum">   21825 </span>            :         SgExpressionPtrList expList = isSgExprListExp(ref-&gt;get_parent())-&gt;get_expressions();</a>
<a name="21826"><span class="lineNum">   21826 </span>            :         Rose_STL_Container&lt;SgExpression*&gt;::const_iterator iter= expList.begin();</a>
<a name="21827"><span class="lineNum">   21827 </span>            :         for (; iter!=expList.end(); iter++)</a>
<a name="21828"><span class="lineNum">   21828 </span>            :         {</a>
<a name="21829"><span class="lineNum">   21829 </span>            :           if (*iter == ref)</a>
<a name="21830"><span class="lineNum">   21830 </span>            :             break;</a>
<a name="21831"><span class="lineNum">   21831 </span>            :           else</a>
<a name="21832"><span class="lineNum">   21832 </span>            :             param_index++;</a>
<a name="21833"><span class="lineNum">   21833 </span>            :         }</a>
<a name="21834"><span class="lineNum">   21834 </span>            :         // find the parameter type of the corresponding function declaration</a>
<a name="21835"><span class="lineNum">   21835 </span>            :         SgFunctionRefExp * funcRef = isSgFunctionRefExp(isSgFunctionCallExp(grandparent)-&gt;get_function());</a>
<a name="21836"><span class="lineNum">   21836 </span>            :         SgFunctionDeclaration* funcDecl = isSgFunctionSymbol(funcRef-&gt;get_symbol())-&gt;get_declaration();</a>
<a name="21837"><span class="lineNum">   21837 </span>            :         SgInitializedNamePtrList nameList = funcDecl-&gt;get_args();</a>
<a name="21838"><span class="lineNum">   21838 </span>            :         //TODO tolerate typedef chains</a>
<a name="21839"><span class="lineNum">   21839 </span>            :         if (isSgReferenceType(nameList[param_index]-&gt;get_type()))</a>
<a name="21840"><span class="lineNum">   21840 </span>            :         {</a>
<a name="21841"><span class="lineNum">   21841 </span>            :           varSetB.insert(ref);</a>
<a name="21842"><span class="lineNum">   21842 </span>            :         }</a>
<a name="21843"><span class="lineNum">   21843 </span>            :       }</a>
<a name="21844"><span class="lineNum">   21844 </span>            :     }</a>
<a name="21845"><span class="lineNum">   21845 </span>            : #endif</a>
<a name="21846"><span class="lineNum">   21846 </span><span class="lineNoCov">          0 :     if (isUseByAddressVariableRef(ref))</span></a>
<a name="21847"><span class="lineNum">   21847 </span><span class="lineNoCov">          0 :       varSetB.insert(ref);</span></a>
<a name="21848"><span class="lineNum">   21848 </span>            :   }</a>
<a name="21849"><span class="lineNum">   21849 </span><span class="lineNoCov">          0 : }</span></a>
<a name="21850"><span class="lineNum">   21850 </span>            : </a>
<a name="21851"><span class="lineNum">   21851 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="21852"><span class="lineNum">   21852 </span>            : //!Call liveness analysis on an entire project</a>
<a name="21853"><span class="lineNum">   21853 </span><span class="lineCov">          1 : LivenessAnalysis * SageInterface::call_liveness_analysis(SgProject* project, bool debug/*=false*/)</span></a>
<a name="21854"><span class="lineNum">   21854 </span>            : {</a>
<a name="21855"><span class="lineNum">   21855 </span>            :   // We expect this function to be called multiple times but always return the result generated from the first execution.</a>
<a name="21856"><span class="lineNum">   21856 </span><span class="lineCov">          1 :   static LivenessAnalysis* liv = NULL; // one instance</span></a>
<a name="21857"><span class="lineNum">   21857 </span><span class="lineCov">          1 :   if (liv!=NULL)</span></a>
<a name="21858"><span class="lineNum">   21858 </span>            :     return liv;</a>
<a name="21859"><span class="lineNum">   21859 </span>            : </a>
<a name="21860"><span class="lineNum">   21860 </span><span class="lineCov">          1 :   static DFAnalysis * defuse = NULL; // only one instance</span></a>
<a name="21861"><span class="lineNum">   21861 </span>            :   // Prepare def-use analysis</a>
<a name="21862"><span class="lineNum">   21862 </span><span class="lineCov">          1 :   if (defuse==NULL)</span></a>
<a name="21863"><span class="lineNum">   21863 </span>            :   {</a>
<a name="21864"><span class="lineNum">   21864 </span><span class="lineCov">          1 :     ROSE_ASSERT(project != NULL);</span></a>
<a name="21865"><span class="lineNum">   21865 </span><span class="lineCov">          1 :     defuse = new DefUseAnalysis(project);</span></a>
<a name="21866"><span class="lineNum">   21866 </span>            :   }</a>
<a name="21867"><span class="lineNum">   21867 </span>            : </a>
<a name="21868"><span class="lineNum">   21868 </span><span class="lineCov">          1 :   ROSE_ASSERT(defuse != NULL);</span></a>
<a name="21869"><span class="lineNum">   21869 </span><span class="lineCov">          1 :   defuse-&gt;run(debug);</span></a>
<a name="21870"><span class="lineNum">   21870 </span>            : </a>
<a name="21871"><span class="lineNum">   21871 </span><span class="lineCov">          1 :   if (debug)</span></a>
<a name="21872"><span class="lineNum">   21872 </span><span class="lineNoCov">          0 :     defuse-&gt;dfaToDOT();</span></a>
<a name="21873"><span class="lineNum">   21873 </span>            : </a>
<a name="21874"><span class="lineNum">   21874 </span>            :   //Prepare variable liveness analysis</a>
<a name="21875"><span class="lineNum">   21875 </span><span class="lineCov">          1 :   liv = new LivenessAnalysis(debug,(DefUseAnalysis*)defuse);</span></a>
<a name="21876"><span class="lineNum">   21876 </span><span class="lineCov">          1 :   ROSE_ASSERT(liv != NULL);</span></a>
<a name="21877"><span class="lineNum">   21877 </span>            : </a>
<a name="21878"><span class="lineNum">   21878 </span><span class="lineCov">          2 :   std::vector &lt;FilteredCFGNode &lt; IsDFAFilter &gt; &gt; dfaFunctions;</span></a>
<a name="21879"><span class="lineNum">   21879 </span><span class="lineCov">          1 :   NodeQuerySynthesizedAttributeType vars =</span></a>
<a name="21880"><span class="lineNum">   21880 </span><span class="lineCov">          2 :           NodeQuery::querySubTree(project, V_SgFunctionDefinition);</span></a>
<a name="21881"><span class="lineNum">   21881 </span><span class="lineCov">          1 :   NodeQuerySynthesizedAttributeType::const_iterator i;</span></a>
<a name="21882"><span class="lineNum">   21882 </span><span class="lineCov">          1 :   bool abortme=false;</span></a>
<a name="21883"><span class="lineNum">   21883 </span>            :      // run liveness analysis on each function body</a>
<a name="21884"><span class="lineNum">   21884 </span><span class="lineCov">          2 :   for (i= vars.begin(); i!=vars.end();++i)</span></a>
<a name="21885"><span class="lineNum">   21885 </span>            :   {</a>
<a name="21886"><span class="lineNum">   21886 </span><span class="lineCov">          1 :     SgFunctionDefinition* func = isSgFunctionDefinition(*i);</span></a>
<a name="21887"><span class="lineNum">   21887 </span><span class="lineCov">          1 :     ROSE_ASSERT(func != NULL);</span></a>
<a name="21888"><span class="lineNum">   21888 </span><span class="lineCov">          1 :     if (debug)</span></a>
<a name="21889"><span class="lineNum">   21889 </span>            :     {</a>
<a name="21890"><span class="lineNum">   21890 </span><span class="lineNoCov">          0 :       std::string name = func-&gt;class_name();</span></a>
<a name="21891"><span class="lineNum">   21891 </span><span class="lineNoCov">          0 :       string funcName = func-&gt;get_declaration()-&gt;get_qualified_name().str();</span></a>
<a name="21892"><span class="lineNum">   21892 </span><span class="lineNoCov">          0 :       cout&lt;&lt; &quot; .. running liveness analysis for function: &quot; &lt;&lt; funcName &lt;&lt; endl;</span></a>
<a name="21893"><span class="lineNum">   21893 </span>            :     }</a>
<a name="21894"><span class="lineNum">   21894 </span><span class="lineCov">          1 :     FilteredCFGNode &lt;IsDFAFilter&gt; rem_source = liv-&gt;run(func,abortme);</span></a>
<a name="21895"><span class="lineNum">   21895 </span>            :     // propagate results to statement level</a>
<a name="21896"><span class="lineNum">   21896 </span><span class="lineCov">          1 :     liv-&gt;fixupStatementsINOUT(func);</span></a>
<a name="21897"><span class="lineNum">   21897 </span><span class="lineCov">          1 :     if (rem_source.getNode()!=NULL)</span></a>
<a name="21898"><span class="lineNum">   21898 </span><span class="lineCov">          1 :       dfaFunctions.push_back(rem_source);</span></a>
<a name="21899"><span class="lineNum">   21899 </span><span class="lineCov">          1 :     if (abortme)</span></a>
<a name="21900"><span class="lineNum">   21900 </span>            :       break;</a>
<a name="21901"><span class="lineNum">   21901 </span>            :   } // end for ()</a>
<a name="21902"><span class="lineNum">   21902 </span><span class="lineCov">          1 :   if(debug)</span></a>
<a name="21903"><span class="lineNum">   21903 </span>            :   {</a>
<a name="21904"><span class="lineNum">   21904 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;Writing out liveness analysis results into var.dot... &quot; &lt;&lt; endl;</span></a>
<a name="21905"><span class="lineNum">   21905 </span><span class="lineNoCov">          0 :     std::ofstream f2(&quot;var.dot&quot;);</span></a>
<a name="21906"><span class="lineNum">   21906 </span><span class="lineNoCov">          0 :     dfaToDot(f2, string(&quot;var&quot;), dfaFunctions, (DefUseAnalysis*)defuse, liv);</span></a>
<a name="21907"><span class="lineNum">   21907 </span><span class="lineNoCov">          0 :     f2.close();</span></a>
<a name="21908"><span class="lineNum">   21908 </span>            :   }</a>
<a name="21909"><span class="lineNum">   21909 </span><span class="lineCov">          1 :   if (abortme) {</span></a>
<a name="21910"><span class="lineNum">   21910 </span><span class="lineNoCov">          0 :     cerr&lt;&lt;&quot;Error: Liveness analysis is ABORTING .&quot; &lt;&lt; endl;</span></a>
<a name="21911"><span class="lineNum">   21911 </span><span class="lineNoCov">          0 :     ROSE_ABORT();</span></a>
<a name="21912"><span class="lineNum">   21912 </span>            :   }</a>
<a name="21913"><span class="lineNum">   21913 </span><span class="lineCov">          1 :   return liv;</span></a>
<a name="21914"><span class="lineNum">   21914 </span>            :   //return !abortme;</a>
<a name="21915"><span class="lineNum">   21915 </span>            : }</a>
<a name="21916"><span class="lineNum">   21916 </span>            : #endif</a>
<a name="21917"><span class="lineNum">   21917 </span>            : </a>
<a name="21918"><span class="lineNum">   21918 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="21919"><span class="lineNum">   21919 </span>            : //!Get liveIn and liveOut variables for a for loop</a>
<a name="21920"><span class="lineNum">   21920 </span><span class="lineCov">          1 : void SageInterface::getLiveVariables(LivenessAnalysis * liv, SgForStatement* loop, std::set&lt;SgInitializedName*&gt;&amp; liveIns, std::set&lt;SgInitializedName*&gt; &amp; liveOuts)</span></a>
<a name="21921"><span class="lineNum">   21921 </span>            : {</a>
<a name="21922"><span class="lineNum">   21922 </span><span class="lineCov">          1 :   ROSE_ASSERT(liv != NULL);</span></a>
<a name="21923"><span class="lineNum">   21923 </span><span class="lineCov">          1 :   ROSE_ASSERT(loop != NULL);</span></a>
<a name="21924"><span class="lineNum">   21924 </span><span class="lineCov">          1 :   SgForStatement *forstmt = loop;</span></a>
<a name="21925"><span class="lineNum">   21925 </span><span class="lineCov">          2 :   std::vector&lt;SgInitializedName*&gt; liveIns0, liveOuts0; // store the original one</span></a>
<a name="21926"><span class="lineNum">   21926 </span>            : </a>
<a name="21927"><span class="lineNum">   21927 </span>            :   // Jeremiah's hidden constructor parameter value '2' to grab the node for forStmt's</a>
<a name="21928"><span class="lineNum">   21928 </span>            :   // Several CFG nodes are used for the same SgForStatement, only one of the is needed.</a>
<a name="21929"><span class="lineNum">   21929 </span>            :   // We have to check the full control flow graph to find all SgForStatement's nodes,</a>
<a name="21930"><span class="lineNum">   21930 </span>            :   // check the index numbers from 0 , find the one with two out edges (true, false)</a>
<a name="21931"><span class="lineNum">   21931 </span>            :   // The CFG node should have a caption like&quot; &lt;SgForStatement&gt; @ 8: 1&quot;,</a>
<a name="21932"><span class="lineNum">   21932 </span>            :   // which means this is a CFG node for a for statement at source line 8, with an index 1.</a>
<a name="21933"><span class="lineNum">   21933 </span>            :   // For SgForStatement, there are 5 cfg nodes, 0 and 4 are for begin and end CFG nodes</a>
<a name="21934"><span class="lineNum">   21934 </span>            :   // 1: after init statement, 2: after test expression (the remaining one after filtering), 3: before increment</a>
<a name="21935"><span class="lineNum">   21935 </span><span class="lineCov">          1 :   CFGNode cfgnode(forstmt,2);</span></a>
<a name="21936"><span class="lineNum">   21936 </span><span class="lineCov">          1 :   FilteredCFGNode&lt;IsDFAFilter&gt; filternode= FilteredCFGNode&lt;IsDFAFilter&gt; (cfgnode);</span></a>
<a name="21937"><span class="lineNum">   21937 </span>            :   // This one does not return the one we want even its getNode returns the</a>
<a name="21938"><span class="lineNum">   21938 </span>            :   // right for statement</a>
<a name="21939"><span class="lineNum">   21939 </span>            :   //FilteredCFGNode&lt;IsDFAFilter&gt; filternode= FilteredCFGNode&lt;IsDFAFilter&gt; (forstmt-&gt;cfgForBeginning());</a>
<a name="21940"><span class="lineNum">   21940 </span><span class="lineCov">          1 :   ROSE_ASSERT(filternode.getNode()==forstmt);</span></a>
<a name="21941"><span class="lineNum">   21941 </span>            : </a>
<a name="21942"><span class="lineNum">   21942 </span>            :   // Check out edges</a>
<a name="21943"><span class="lineNum">   21943 </span><span class="lineCov">          2 :   vector&lt;FilteredCFGEdge &lt; IsDFAFilter &gt; &gt; out_edges = filternode.outEdges();</span></a>
<a name="21944"><span class="lineNum">   21944 </span><span class="lineCov">          1 :   ROSE_ASSERT(out_edges.size()==2);</span></a>
<a name="21945"><span class="lineNum">   21945 </span><span class="lineCov">          1 :   vector&lt;FilteredCFGEdge &lt; IsDFAFilter &gt; &gt;::iterator iter= out_edges.begin();</span></a>
<a name="21946"><span class="lineNum">   21946 </span>            : </a>
<a name="21947"><span class="lineNum">   21947 </span><span class="lineCov">          3 :   for (; iter!=out_edges.end();iter++)</span></a>
<a name="21948"><span class="lineNum">   21948 </span>            :   {</a>
<a name="21949"><span class="lineNum">   21949 </span><span class="lineCov">          4 :     FilteredCFGEdge &lt; IsDFAFilter &gt; edge= *iter;</span></a>
<a name="21950"><span class="lineNum">   21950 </span>            :     //SgForStatement should have two outgoing edges based on the loop condition</a>
<a name="21951"><span class="lineNum">   21951 </span>            :     // one true(going into the loop body) and one false (going out the loop)</a>
<a name="21952"><span class="lineNum">   21952 </span>            :     //x. Live-in (loop) = live-in (first-stmt-in-loop)</a>
<a name="21953"><span class="lineNum">   21953 </span><span class="lineCov">          2 :     if (edge.condition()==eckTrue)</span></a>
<a name="21954"><span class="lineNum">   21954 </span>            :     {</a>
<a name="21955"><span class="lineNum">   21955 </span><span class="lineCov">          1 :       SgNode* firstnode= edge.target().getNode();</span></a>
<a name="21956"><span class="lineNum">   21956 </span><span class="lineCov">          2 :       liveIns0 = liv-&gt;getIn(firstnode);</span></a>
<a name="21957"><span class="lineNum">   21957 </span>            :       // cout&lt;&lt;&quot;Live-in variables for loop:&quot;&lt;&lt;endl;</a>
<a name="21958"><span class="lineNum">   21958 </span><span class="lineCov">          1 :       for (std::vector&lt;SgInitializedName*&gt;::iterator iter = liveIns0.begin();</span></a>
<a name="21959"><span class="lineNum">   21959 </span><span class="lineCov">          5 :           iter!=liveIns0.end(); iter++)</span></a>
<a name="21960"><span class="lineNum">   21960 </span>            :       {</a>
<a name="21961"><span class="lineNum">   21961 </span>            :         // SgInitializedName* name = *iter;</a>
<a name="21962"><span class="lineNum">   21962 </span><span class="lineCov">          4 :         liveIns.insert(*iter);</span></a>
<a name="21963"><span class="lineNum">   21963 </span>            :         //           cout&lt;&lt; name-&gt;get_qualified_name().getString()&lt;&lt;endl;</a>
<a name="21964"><span class="lineNum">   21964 </span>            :       }</a>
<a name="21965"><span class="lineNum">   21965 </span>            :     }</a>
<a name="21966"><span class="lineNum">   21966 </span>            :     //x. live-out(loop) = live-in (first-stmt-after-loop)</a>
<a name="21967"><span class="lineNum">   21967 </span><span class="lineCov">          1 :     else if (edge.condition()==eckFalse)</span></a>
<a name="21968"><span class="lineNum">   21968 </span>            :     {</a>
<a name="21969"><span class="lineNum">   21969 </span><span class="lineCov">          1 :       SgNode* firstnode= edge.target().getNode();</span></a>
<a name="21970"><span class="lineNum">   21970 </span><span class="lineCov">          2 :       liveOuts0 = liv-&gt;getIn(firstnode);</span></a>
<a name="21971"><span class="lineNum">   21971 </span>            :       //  cout&lt;&lt;&quot;Live-out variables for loop:&quot;&lt;&lt;endl;</a>
<a name="21972"><span class="lineNum">   21972 </span><span class="lineCov">          1 :       for (std::vector&lt;SgInitializedName*&gt;::iterator iter = liveOuts0.begin();</span></a>
<a name="21973"><span class="lineNum">   21973 </span><span class="lineCov">          4 :           iter!=liveOuts0.end(); iter++)</span></a>
<a name="21974"><span class="lineNum">   21974 </span>            :       {</a>
<a name="21975"><span class="lineNum">   21975 </span>            :         // SgInitializedName* name = *iter;</a>
<a name="21976"><span class="lineNum">   21976 </span>            :         //  cout&lt;&lt; name-&gt;get_qualified_name().getString()&lt;&lt;endl;</a>
<a name="21977"><span class="lineNum">   21977 </span><span class="lineCov">          3 :         liveOuts.insert(*iter);</span></a>
<a name="21978"><span class="lineNum">   21978 </span>            :       }</a>
<a name="21979"><span class="lineNum">   21979 </span>            :     }</a>
<a name="21980"><span class="lineNum">   21980 </span>            :     else</a>
<a name="21981"><span class="lineNum">   21981 </span>            :     {</a>
<a name="21982"><span class="lineNum">   21982 </span><span class="lineNoCov">          0 :       cerr&lt;&lt;&quot;Unexpected CFG out edge type for SgForStmt!&quot;&lt;&lt;endl;</span></a>
<a name="21983"><span class="lineNum">   21983 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="21984"><span class="lineNum">   21984 </span>            :     }</a>
<a name="21985"><span class="lineNum">   21985 </span>            :   } // end for (edges)</a>
<a name="21986"><span class="lineNum">   21986 </span>            : </a>
<a name="21987"><span class="lineNum">   21987 </span><span class="lineCov">          1 : }</span></a>
<a name="21988"><span class="lineNum">   21988 </span>            : #endif</a>
<a name="21989"><span class="lineNum">   21989 </span>            : </a>
<a name="21990"><span class="lineNum">   21990 </span>            : //Check if two references form an idiom like:  x= x op expr,  x = expr op x (except for subtraction)</a>
<a name="21991"><span class="lineNum">   21991 </span><span class="lineNoCov">          0 : static bool isAssignReduction (SgVarRefExp* ref_exp1, SgVarRefExp* ref_exp2, OmpSupport::omp_construct_enum&amp; optype)</span></a>
<a name="21992"><span class="lineNum">   21992 </span>            : {</a>
<a name="21993"><span class="lineNum">   21993 </span><span class="lineNoCov">          0 :   bool isReduction = false;</span></a>
<a name="21994"><span class="lineNum">   21994 </span>            :   // Sanity check</a>
<a name="21995"><span class="lineNum">   21995 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref_exp1!= NULL);</span></a>
<a name="21996"><span class="lineNum">   21996 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref_exp2!= NULL);</span></a>
<a name="21997"><span class="lineNum">   21997 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref_exp1-&gt; get_symbol() == ref_exp2-&gt; get_symbol());</span></a>
<a name="21998"><span class="lineNum">   21998 </span>            :   // must be scalar type</a>
<a name="21999"><span class="lineNum">   21999 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (SageInterface::isScalarType(ref_exp1-&gt; get_symbol()-&gt;get_type() ) );</span></a>
<a name="22000"><span class="lineNum">   22000 </span>            : </a>
<a name="22001"><span class="lineNum">   22001 </span><span class="lineNoCov">          0 :   SgStatement* stmt = SageInterface::getEnclosingStatement(ref_exp1);</span></a>
<a name="22002"><span class="lineNum">   22002 </span><span class="lineNoCov">          0 :   SgStatement* stmt2 = SageInterface::getEnclosingStatement(ref_exp2);</span></a>
<a name="22003"><span class="lineNum">   22003 </span><span class="lineNoCov">          0 :   if (stmt != stmt2) return false; // early return false;</span></a>
<a name="22004"><span class="lineNum">   22004 </span>            : </a>
<a name="22005"><span class="lineNum">   22005 </span>            :   // must be assignment statement using</a>
<a name="22006"><span class="lineNum">   22006 </span>            :   //  x= x op expr,  x = expr op x (except for subtraction)</a>
<a name="22007"><span class="lineNum">   22007 </span>            :   // one reference on left hand, the other on the right hand of assignment expression</a>
<a name="22008"><span class="lineNum">   22008 </span>            :   // the right hand uses associative operators +, *, -, &amp;, ^ ,|, &amp;&amp;, ||</a>
<a name="22009"><span class="lineNum">   22009 </span><span class="lineNoCov">          0 :   SgExprStatement* exp_stmt =  isSgExprStatement(stmt);</span></a>
<a name="22010"><span class="lineNum">   22010 </span><span class="lineNoCov">          0 :   if (exp_stmt &amp;&amp; isSgAssignOp(exp_stmt-&gt;get_expression()))</span></a>
<a name="22011"><span class="lineNum">   22011 </span>            :   {</a>
<a name="22012"><span class="lineNum">   22012 </span><span class="lineNoCov">          0 :     SgExpression* assign_lhs=NULL, * assign_rhs =NULL;</span></a>
<a name="22013"><span class="lineNum">   22013 </span><span class="lineNoCov">          0 :     assign_lhs = isSgAssignOp(exp_stmt-&gt;get_expression())-&gt;get_lhs_operand();</span></a>
<a name="22014"><span class="lineNum">   22014 </span><span class="lineNoCov">          0 :     assign_rhs = isSgAssignOp(exp_stmt-&gt;get_expression())-&gt;get_rhs_operand();</span></a>
<a name="22015"><span class="lineNum">   22015 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(assign_lhs &amp;&amp; assign_rhs);</span></a>
<a name="22016"><span class="lineNum">   22016 </span>            :     // x must show up in both lhs and rhs in any order:</a>
<a name="22017"><span class="lineNum">   22017 </span>            :     //  e.g.: ref1 = ref2 op exp or ref2 = ref1 op exp</a>
<a name="22018"><span class="lineNum">   22018 </span><span class="lineNoCov">          0 :     if (((assign_lhs==ref_exp1)&amp;&amp;SageInterface::isAncestor(assign_rhs,ref_exp2))</span></a>
<a name="22019"><span class="lineNum">   22019 </span><span class="lineNoCov">          0 :         ||((assign_lhs==ref_exp2)&amp;&amp;SageInterface::isAncestor(assign_rhs,ref_exp1)))</span></a>
<a name="22020"><span class="lineNum">   22020 </span>            :     {</a>
<a name="22021"><span class="lineNum">   22021 </span>            :       // assignment's rhs must match the associative binary operations</a>
<a name="22022"><span class="lineNum">   22022 </span>            :       // +, *, -, &amp;, ^ ,|, &amp;&amp;, ||</a>
<a name="22023"><span class="lineNum">   22023 </span><span class="lineNoCov">          0 :       SgBinaryOp * binop = isSgBinaryOp(assign_rhs);</span></a>
<a name="22024"><span class="lineNum">   22024 </span><span class="lineNoCov">          0 :       if (binop!=NULL){</span></a>
<a name="22025"><span class="lineNum">   22025 </span><span class="lineNoCov">          0 :         SgExpression* op_lhs = binop-&gt;get_lhs_operand();</span></a>
<a name="22026"><span class="lineNum">   22026 </span><span class="lineNoCov">          0 :         SgExpression* op_rhs = binop-&gt;get_rhs_operand();</span></a>
<a name="22027"><span class="lineNum">   22027 </span>            : </a>
<a name="22028"><span class="lineNum">   22028 </span>            :         // double check that the binary expression has either ref1 or ref2 as one operand</a>
<a name="22029"><span class="lineNum">   22029 </span><span class="lineNoCov">          0 :         if( !((op_lhs==ref_exp1)||(op_lhs==ref_exp2))</span></a>
<a name="22030"><span class="lineNum">   22030 </span><span class="lineNoCov">          0 :             &amp;&amp; !((op_rhs==ref_exp1)||(op_rhs==ref_exp2)))</span></a>
<a name="22031"><span class="lineNum">   22031 </span>            :           return false;  // early return false;</a>
<a name="22032"><span class="lineNum">   22032 </span>            : </a>
<a name="22033"><span class="lineNum">   22033 </span><span class="lineNoCov">          0 :         bool isOnLeft = false; // true if it has form (refx op exp), instead (exp or refx)</span></a>
<a name="22034"><span class="lineNum">   22034 </span><span class="lineNoCov">          0 :         if ((op_lhs==ref_exp1)||   // TODO might have in between !!</span></a>
<a name="22035"><span class="lineNum">   22035 </span><span class="lineNoCov">          0 :             (op_lhs==ref_exp2))</span></a>
<a name="22036"><span class="lineNum">   22036 </span><span class="lineNoCov">          0 :           isOnLeft = true;</span></a>
<a name="22037"><span class="lineNum">   22037 </span><span class="lineNoCov">          0 :         switch (binop-&gt;variantT())</span></a>
<a name="22038"><span class="lineNum">   22038 </span>            :         {</a>
<a name="22039"><span class="lineNum">   22039 </span><span class="lineNoCov">          0 :           case V_SgAddOp:</span></a>
<a name="22040"><span class="lineNum">   22040 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22041"><span class="lineNum">   22041 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_plus;</span></a>
<a name="22042"><span class="lineNum">   22042 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22043"><span class="lineNum">   22043 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22044"><span class="lineNum">   22044 </span>            :             }</a>
<a name="22045"><span class="lineNum">   22045 </span><span class="lineNoCov">          0 :           case V_SgMultiplyOp:</span></a>
<a name="22046"><span class="lineNum">   22046 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22047"><span class="lineNum">   22047 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_mul;</span></a>
<a name="22048"><span class="lineNum">   22048 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22049"><span class="lineNum">   22049 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22050"><span class="lineNum">   22050 </span>            :             }</a>
<a name="22051"><span class="lineNum">   22051 </span><span class="lineNoCov">          0 :           case V_SgSubtractOp: // special handle here!!</span></a>
<a name="22052"><span class="lineNum">   22052 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22053"><span class="lineNum">   22053 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_minus;</span></a>
<a name="22054"><span class="lineNum">   22054 </span><span class="lineNoCov">          0 :               if (isOnLeft) // cannot allow (exp - x)a</span></a>
<a name="22055"><span class="lineNum">   22055 </span>            :               {</a>
<a name="22056"><span class="lineNum">   22056 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22057"><span class="lineNum">   22057 </span>            :               }</a>
<a name="22058"><span class="lineNum">   22058 </span>            :               break;</a>
<a name="22059"><span class="lineNum">   22059 </span>            :             }</a>
<a name="22060"><span class="lineNum">   22060 </span><span class="lineNoCov">          0 :           case V_SgBitAndOp:</span></a>
<a name="22061"><span class="lineNum">   22061 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22062"><span class="lineNum">   22062 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_bitand ;</span></a>
<a name="22063"><span class="lineNum">   22063 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22064"><span class="lineNum">   22064 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22065"><span class="lineNum">   22065 </span>            :             }</a>
<a name="22066"><span class="lineNum">   22066 </span><span class="lineNoCov">          0 :           case V_SgBitXorOp:</span></a>
<a name="22067"><span class="lineNum">   22067 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22068"><span class="lineNum">   22068 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_bitxor;</span></a>
<a name="22069"><span class="lineNum">   22069 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22070"><span class="lineNum">   22070 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22071"><span class="lineNum">   22071 </span>            :             }</a>
<a name="22072"><span class="lineNum">   22072 </span><span class="lineNoCov">          0 :           case V_SgBitOrOp:</span></a>
<a name="22073"><span class="lineNum">   22073 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22074"><span class="lineNum">   22074 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_bitor;</span></a>
<a name="22075"><span class="lineNum">   22075 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22076"><span class="lineNum">   22076 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22077"><span class="lineNum">   22077 </span>            :             }</a>
<a name="22078"><span class="lineNum">   22078 </span><span class="lineNoCov">          0 :           case V_SgAndOp:</span></a>
<a name="22079"><span class="lineNum">   22079 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22080"><span class="lineNum">   22080 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_logand;</span></a>
<a name="22081"><span class="lineNum">   22081 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22082"><span class="lineNum">   22082 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22083"><span class="lineNum">   22083 </span>            :             }</a>
<a name="22084"><span class="lineNum">   22084 </span><span class="lineNoCov">          0 :           case V_SgOrOp:</span></a>
<a name="22085"><span class="lineNum">   22085 </span><span class="lineNoCov">          0 :             {</span></a>
<a name="22086"><span class="lineNum">   22086 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_logor;</span></a>
<a name="22087"><span class="lineNum">   22087 </span><span class="lineNoCov">          0 :               isReduction = true;</span></a>
<a name="22088"><span class="lineNum">   22088 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="22089"><span class="lineNum">   22089 </span>            :             }</a>
<a name="22090"><span class="lineNum">   22090 </span>            :           default:</a>
<a name="22091"><span class="lineNum">   22091 </span>            :             break;</a>
<a name="22092"><span class="lineNum">   22092 </span>            :         }</a>
<a name="22093"><span class="lineNum">   22093 </span>            :       } // end matching associative operations</a>
<a name="22094"><span class="lineNum">   22094 </span>            :     }</a>
<a name="22095"><span class="lineNum">   22095 </span>            :   } // end if assignop</a>
<a name="22096"><span class="lineNum">   22096 </span>            :   return isReduction;</a>
<a name="22097"><span class="lineNum">   22097 </span>            : }</a>
<a name="22098"><span class="lineNum">   22098 </span>            : // A helper function for reduction recognition</a>
<a name="22099"><span class="lineNum">   22099 </span>            : // check if two references to the same variable form a reduction idiom using if-statement</a>
<a name="22100"><span class="lineNum">   22100 </span>            : // example 1: if (array[i]&gt; maxV) maxV = array[i]</a>
<a name="22101"><span class="lineNum">   22101 </span>            : // example 2: if (array[i]&lt; minV) minV = array[i]</a>
<a name="22102"><span class="lineNum">   22102 </span>            : // If it matches, return true and the reduction operator type</a>
<a name="22103"><span class="lineNum">   22103 </span><span class="lineNoCov">          0 : static  bool isIfReduction(SgVarRefExp* ref1, SgVarRefExp* ref2, OmpSupport::omp_construct_enum&amp; optype)</span></a>
<a name="22104"><span class="lineNum">   22104 </span>            : {</a>
<a name="22105"><span class="lineNum">   22105 </span><span class="lineNoCov">          0 :   bool matchStmt1 = false;</span></a>
<a name="22106"><span class="lineNum">   22106 </span><span class="lineNoCov">          0 :   bool matchStmt2 = false;</span></a>
<a name="22107"><span class="lineNum">   22107 </span>            : </a>
<a name="22108"><span class="lineNum">   22108 </span>            :   //TODO: ensure ref1, ref2 are ordered as pre-order manner in AST</a>
<a name="22109"><span class="lineNum">   22109 </span>            :   //   SgExpression* reduction_var_ref = NULL;</a>
<a name="22110"><span class="lineNum">   22110 </span>            :   //   SgExpression* source_var_ref = NULL;  //array[i] is the source var ref</a>
<a name="22111"><span class="lineNum">   22111 </span>            : </a>
<a name="22112"><span class="lineNum">   22112 </span>            :   // Sanity check</a>
<a name="22113"><span class="lineNum">   22113 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref1 != NULL);</span></a>
<a name="22114"><span class="lineNum">   22114 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref2 != NULL);</span></a>
<a name="22115"><span class="lineNum">   22115 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref1-&gt; get_symbol() == ref2-&gt; get_symbol());</span></a>
<a name="22116"><span class="lineNum">   22116 </span>            :   // must be scalar type</a>
<a name="22117"><span class="lineNum">   22117 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (SageInterface::isScalarType(ref1-&gt; get_symbol()-&gt;get_type() ) );</span></a>
<a name="22118"><span class="lineNum">   22118 </span>            : </a>
<a name="22119"><span class="lineNum">   22119 </span><span class="lineNoCov">          0 :   SgStatement* stmt1 = SageInterface::getEnclosingStatement(ref1);</span></a>
<a name="22120"><span class="lineNum">   22120 </span><span class="lineNoCov">          0 :   SgStatement* stmt2 = SageInterface::getEnclosingStatement(ref2);</span></a>
<a name="22121"><span class="lineNum">   22121 </span>            : </a>
<a name="22122"><span class="lineNum">   22122 </span>            :   //early return if the same stmt</a>
<a name="22123"><span class="lineNum">   22123 </span><span class="lineNoCov">          0 :   if (stmt1 == stmt2) return false;</span></a>
<a name="22124"><span class="lineNum">   22124 </span>            : </a>
<a name="22125"><span class="lineNum">   22125 </span>            :   // check stmt2 first. It is easier.</a>
<a name="22126"><span class="lineNum">   22126 </span>            :   // stmt2 should be an assignment stmt like:</a>
<a name="22127"><span class="lineNum">   22127 </span>            :   //    reduction_variable = else;</a>
<a name="22128"><span class="lineNum">   22128 </span>            :   //    minV = array[i];</a>
<a name="22129"><span class="lineNum">   22129 </span><span class="lineNoCov">          0 :   SgExpression* lhs2 = NULL;</span></a>
<a name="22130"><span class="lineNum">   22130 </span><span class="lineNoCov">          0 :   SgExpression* rhs2 = NULL;</span></a>
<a name="22131"><span class="lineNum">   22131 </span><span class="lineNoCov">          0 :   if (SageInterface::isAssignmentStatement (stmt2, &amp;lhs2, &amp;rhs2 ))</span></a>
<a name="22132"><span class="lineNum">   22132 </span>            :   {</a>
<a name="22133"><span class="lineNum">   22133 </span>            :     // lhs2 must be ref2</a>
<a name="22134"><span class="lineNum">   22134 </span><span class="lineNoCov">          0 :     if (lhs2 == ref2 )</span></a>
<a name="22135"><span class="lineNum">   22135 </span>            :     {</a>
<a name="22136"><span class="lineNum">   22136 </span><span class="lineNoCov">          0 :       matchStmt2 = true;</span></a>
<a name="22137"><span class="lineNum">   22137 </span>            :       //     reduction_var_ref = lhs2;</a>
<a name="22138"><span class="lineNum">   22138 </span>            :       //     source_var_ref= rhs2;</a>
<a name="22139"><span class="lineNum">   22139 </span>            :     }</a>
<a name="22140"><span class="lineNum">   22140 </span>            :   } // end assignment stmt</a>
<a name="22141"><span class="lineNum">   22141 </span>            : </a>
<a name="22142"><span class="lineNum">   22142 </span>            :   // stmt1 should be a if-stmt's conditional expression stmt</a>
<a name="22143"><span class="lineNum">   22143 </span>            :   // and its body should be stmt2</a>
<a name="22144"><span class="lineNum">   22144 </span><span class="lineNoCov">          0 :   if (SgExprStatement* if_cond_stmt = isSgExprStatement(stmt1))</span></a>
<a name="22145"><span class="lineNum">   22145 </span>            :   {</a>
<a name="22146"><span class="lineNum">   22146 </span><span class="lineNoCov">          0 :     bool matchBody = false;</span></a>
<a name="22147"><span class="lineNum">   22147 </span><span class="lineNoCov">          0 :     bool matchCondition= false;</span></a>
<a name="22148"><span class="lineNum">   22148 </span><span class="lineNoCov">          0 :     if (SgIfStmt * if_stmt = isSgIfStmt (if_cond_stmt-&gt;get_parent()) )</span></a>
<a name="22149"><span class="lineNum">   22149 </span>            :     {</a>
<a name="22150"><span class="lineNum">   22150 </span><span class="lineNoCov">          0 :       if (SgStatement* body = if_stmt-&gt;get_true_body())</span></a>
<a name="22151"><span class="lineNum">   22151 </span>            :       {</a>
<a name="22152"><span class="lineNum">   22152 </span><span class="lineNoCov">          0 :         if (SgBasicBlock* block = isSgBasicBlock (body))</span></a>
<a name="22153"><span class="lineNum">   22153 </span>            :         {</a>
<a name="22154"><span class="lineNum">   22154 </span>            :           // stmt2 must be the only child of the if true body</a>
<a name="22155"><span class="lineNum">   22155 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(stmt2 != NULL);</span></a>
<a name="22156"><span class="lineNum">   22156 </span><span class="lineNoCov">          0 :           if ( ((block-&gt;get_statements()).size() == 1) &amp;&amp; stmt2-&gt;get_scope() == block )</span></a>
<a name="22157"><span class="lineNum">   22157 </span>            :             matchBody = true;</a>
<a name="22158"><span class="lineNum">   22158 </span>            :         }</a>
<a name="22159"><span class="lineNum">   22159 </span>            :         else</a>
<a name="22160"><span class="lineNum">   22160 </span>            :         {</a>
<a name="22161"><span class="lineNum">   22161 </span><span class="lineNoCov">          0 :           if (body == stmt2)</span></a>
<a name="22162"><span class="lineNum">   22162 </span><span class="lineNoCov">          0 :             matchBody = true;</span></a>
<a name="22163"><span class="lineNum">   22163 </span>            :         }</a>
<a name="22164"><span class="lineNum">   22164 </span>            :       } // body match test</a>
<a name="22165"><span class="lineNum">   22165 </span>            : </a>
<a name="22166"><span class="lineNum">   22166 </span>            :       // match condition   SgExprStatement  ref1 SgLessThanOp source_var</a>
<a name="22167"><span class="lineNum">   22167 </span><span class="lineNoCov">          0 :       if (SgExprStatement* cond_exp_stmt = isSgExprStatement (if_stmt-&gt;get_conditional()) )</span></a>
<a name="22168"><span class="lineNum">   22168 </span>            :       {</a>
<a name="22169"><span class="lineNum">   22169 </span><span class="lineNoCov">          0 :         SgExpression* cond_exp = cond_exp_stmt-&gt;get_expression();</span></a>
<a name="22170"><span class="lineNum">   22170 </span><span class="lineNoCov">          0 :         if (SgBinaryOp * binop = isSgBinaryOp (cond_exp))</span></a>
<a name="22171"><span class="lineNum">   22171 </span>            :         {</a>
<a name="22172"><span class="lineNum">   22172 </span><span class="lineNoCov">          0 :           if (ref1 == binop-&gt;get_lhs_operand_i())</span></a>
<a name="22173"><span class="lineNum">   22173 </span>            :           {</a>
<a name="22174"><span class="lineNum">   22174 </span>            :             // minV &gt; array[i] ;</a>
<a name="22175"><span class="lineNum">   22175 </span><span class="lineNoCov">          0 :             if (isSgLessThanOp (binop))</span></a>
<a name="22176"><span class="lineNum">   22176 </span>            :             {</a>
<a name="22177"><span class="lineNum">   22177 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_max;</span></a>
<a name="22178"><span class="lineNum">   22178 </span><span class="lineNoCov">          0 :               matchCondition= true;</span></a>
<a name="22179"><span class="lineNum">   22179 </span>            :             }</a>
<a name="22180"><span class="lineNum">   22180 </span><span class="lineNoCov">          0 :             else if (isSgGreaterThanOp(binop))</span></a>
<a name="22181"><span class="lineNum">   22181 </span>            :             {</a>
<a name="22182"><span class="lineNum">   22182 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_min;</span></a>
<a name="22183"><span class="lineNum">   22183 </span><span class="lineNoCov">          0 :               matchCondition= true;</span></a>
<a name="22184"><span class="lineNum">   22184 </span>            :             }</a>
<a name="22185"><span class="lineNum">   22185 </span>            :           }</a>
<a name="22186"><span class="lineNum">   22186 </span><span class="lineNoCov">          0 :           else if ( ref1 == binop-&gt;get_rhs_operand_i() )</span></a>
<a name="22187"><span class="lineNum">   22187 </span>            :           {</a>
<a name="22188"><span class="lineNum">   22188 </span>            :             // array[i] &lt; minV</a>
<a name="22189"><span class="lineNum">   22189 </span><span class="lineNoCov">          0 :             if (isSgLessThanOp (binop))</span></a>
<a name="22190"><span class="lineNum">   22190 </span>            :             {</a>
<a name="22191"><span class="lineNum">   22191 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_min;</span></a>
<a name="22192"><span class="lineNum">   22192 </span><span class="lineNoCov">          0 :               matchCondition= true;</span></a>
<a name="22193"><span class="lineNum">   22193 </span>            :             }</a>
<a name="22194"><span class="lineNum">   22194 </span><span class="lineNoCov">          0 :             else if (isSgGreaterThanOp(binop))</span></a>
<a name="22195"><span class="lineNum">   22195 </span>            :             {</a>
<a name="22196"><span class="lineNum">   22196 </span><span class="lineNoCov">          0 :               optype = OmpSupport::e_reduction_max;</span></a>
<a name="22197"><span class="lineNum">   22197 </span><span class="lineNoCov">          0 :               matchCondition= true;</span></a>
<a name="22198"><span class="lineNum">   22198 </span>            :             }</a>
<a name="22199"><span class="lineNum">   22199 </span>            :           }</a>
<a name="22200"><span class="lineNum">   22200 </span>            :         } // end if binary op</a>
<a name="22201"><span class="lineNum">   22201 </span>            :         // TODO the source_var should match the source_var from stmt2</a>
<a name="22202"><span class="lineNum">   22202 </span>            :       }</a>
<a name="22203"><span class="lineNum">   22203 </span>            :     }</a>
<a name="22204"><span class="lineNum">   22204 </span><span class="lineNoCov">          0 :     matchStmt1 = matchBody &amp;&amp; matchCondition;</span></a>
<a name="22205"><span class="lineNum">   22205 </span>            :   } // end if-stmt</a>
<a name="22206"><span class="lineNum">   22206 </span>            : </a>
<a name="22207"><span class="lineNum">   22207 </span>            : </a>
<a name="22208"><span class="lineNum">   22208 </span><span class="lineNoCov">          0 :   return (matchStmt2 &amp;&amp; matchStmt1);</span></a>
<a name="22209"><span class="lineNum">   22209 </span>            : }</a>
<a name="22210"><span class="lineNum">   22210 </span>            : </a>
<a name="22211"><span class="lineNum">   22211 </span>            : // check if a var ref is a form of</a>
<a name="22212"><span class="lineNum">   22212 </span>            : //  --x, x--, ++x, x++</a>
<a name="22213"><span class="lineNum">   22213 </span>            : //  x+= .., x-= ..., etc.</a>
<a name="22214"><span class="lineNum">   22214 </span>            : // The reduction variable appears only once in the reduction idiom.</a>
<a name="22215"><span class="lineNum">   22215 </span><span class="lineNoCov">          0 : static bool isSingleAppearanceReduction(SgVarRefExp* ref1, OmpSupport::omp_construct_enum&amp; optype )</span></a>
<a name="22216"><span class="lineNum">   22216 </span>            : {</a>
<a name="22217"><span class="lineNum">   22217 </span><span class="lineNoCov">          0 :   bool isReduction = false;</span></a>
<a name="22218"><span class="lineNum">   22218 </span>            : </a>
<a name="22219"><span class="lineNum">   22219 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (ref1 != NULL);</span></a>
<a name="22220"><span class="lineNum">   22220 </span>            :   // must be scalar type</a>
<a name="22221"><span class="lineNum">   22221 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (SageInterface::isScalarType(ref1-&gt; get_symbol()-&gt;get_type() ) );</span></a>
<a name="22222"><span class="lineNum">   22222 </span>            : </a>
<a name="22223"><span class="lineNum">   22223 </span><span class="lineNoCov">          0 :   SgStatement* stmt = SageInterface::getEnclosingStatement(ref1);</span></a>
<a name="22224"><span class="lineNum">   22224 </span>            : </a>
<a name="22225"><span class="lineNum">   22225 </span><span class="lineNoCov">          0 :   if (isSgExprStatement(stmt))</span></a>
<a name="22226"><span class="lineNum">   22226 </span>            :   {</a>
<a name="22227"><span class="lineNum">   22227 </span><span class="lineNoCov">          0 :     SgExpression* exp = isSgExprStatement(stmt)-&gt;get_expression();</span></a>
<a name="22228"><span class="lineNum">   22228 </span><span class="lineNoCov">          0 :     SgExpression* binop = isSgBinaryOp(exp);</span></a>
<a name="22229"><span class="lineNum">   22229 </span><span class="lineNoCov">          0 :     if (isSgPlusPlusOp(exp)) // x++ or ++x</span></a>
<a name="22230"><span class="lineNum">   22230 </span>            :     { // Could have multiple reduction clause with different operators!!</a>
<a name="22231"><span class="lineNum">   22231 </span>            :       // So the variable list is associated with each kind of operator</a>
<a name="22232"><span class="lineNum">   22232 </span><span class="lineNoCov">          0 :       optype = OmpSupport::e_reduction_plus;</span></a>
<a name="22233"><span class="lineNum">   22233 </span><span class="lineNoCov">          0 :       isReduction = true;</span></a>
<a name="22234"><span class="lineNum">   22234 </span>            :     }</a>
<a name="22235"><span class="lineNum">   22235 </span><span class="lineNoCov">          0 :     else if (isSgMinusMinusOp(exp)) // x-- or --x</span></a>
<a name="22236"><span class="lineNum">   22236 </span>            :     {</a>
<a name="22237"><span class="lineNum">   22237 </span><span class="lineNoCov">          0 :       optype = OmpSupport::e_reduction_minus;</span></a>
<a name="22238"><span class="lineNum">   22238 </span><span class="lineNoCov">          0 :       isReduction = true;</span></a>
<a name="22239"><span class="lineNum">   22239 </span>            :     }</a>
<a name="22240"><span class="lineNum">   22240 </span>            :     else</a>
<a name="22241"><span class="lineNum">   22241 </span>            :       // x binop= expr where binop is one of + * - &amp; ^ |</a>
<a name="22242"><span class="lineNum">   22242 </span>            :       // x must be on the left hand side</a>
<a name="22243"><span class="lineNum">   22243 </span><span class="lineNoCov">          0 :       if (binop!=NULL) {</span></a>
<a name="22244"><span class="lineNum">   22244 </span><span class="lineNoCov">          0 :         SgExpression* lhs= isSgBinaryOp(exp)-&gt;get_lhs_operand ();</span></a>
<a name="22245"><span class="lineNum">   22245 </span><span class="lineNoCov">          0 :         if (lhs==ref1)</span></a>
<a name="22246"><span class="lineNum">   22246 </span>            :         {</a>
<a name="22247"><span class="lineNum">   22247 </span><span class="lineNoCov">          0 :           switch (exp-&gt;variantT())</span></a>
<a name="22248"><span class="lineNum">   22248 </span>            :           {</a>
<a name="22249"><span class="lineNum">   22249 </span><span class="lineNoCov">          0 :             case V_SgPlusAssignOp:</span></a>
<a name="22250"><span class="lineNum">   22250 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22251"><span class="lineNum">   22251 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_plus;</span></a>
<a name="22252"><span class="lineNum">   22252 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22253"><span class="lineNum">   22253 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22254"><span class="lineNum">   22254 </span>            :               }</a>
<a name="22255"><span class="lineNum">   22255 </span><span class="lineNoCov">          0 :             case V_SgMultAssignOp:</span></a>
<a name="22256"><span class="lineNum">   22256 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22257"><span class="lineNum">   22257 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_mul;</span></a>
<a name="22258"><span class="lineNum">   22258 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22259"><span class="lineNum">   22259 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22260"><span class="lineNum">   22260 </span>            :               }</a>
<a name="22261"><span class="lineNum">   22261 </span><span class="lineNoCov">          0 :             case V_SgMinusAssignOp:</span></a>
<a name="22262"><span class="lineNum">   22262 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22263"><span class="lineNum">   22263 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_minus;</span></a>
<a name="22264"><span class="lineNum">   22264 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22265"><span class="lineNum">   22265 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22266"><span class="lineNum">   22266 </span>            :               }</a>
<a name="22267"><span class="lineNum">   22267 </span><span class="lineNoCov">          0 :             case V_SgAndAssignOp:</span></a>
<a name="22268"><span class="lineNum">   22268 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22269"><span class="lineNum">   22269 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_bitand;</span></a>
<a name="22270"><span class="lineNum">   22270 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22271"><span class="lineNum">   22271 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22272"><span class="lineNum">   22272 </span>            :               }</a>
<a name="22273"><span class="lineNum">   22273 </span><span class="lineNoCov">          0 :             case V_SgXorAssignOp:</span></a>
<a name="22274"><span class="lineNum">   22274 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22275"><span class="lineNum">   22275 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_bitxor;</span></a>
<a name="22276"><span class="lineNum">   22276 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22277"><span class="lineNum">   22277 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22278"><span class="lineNum">   22278 </span>            :               }</a>
<a name="22279"><span class="lineNum">   22279 </span><span class="lineNoCov">          0 :             case V_SgIorAssignOp:</span></a>
<a name="22280"><span class="lineNum">   22280 </span><span class="lineNoCov">          0 :               {</span></a>
<a name="22281"><span class="lineNum">   22281 </span><span class="lineNoCov">          0 :                 optype = OmpSupport::e_reduction_bitor;</span></a>
<a name="22282"><span class="lineNum">   22282 </span><span class="lineNoCov">          0 :                 isReduction = true;</span></a>
<a name="22283"><span class="lineNum">   22283 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="22284"><span class="lineNum">   22284 </span>            :               }</a>
<a name="22285"><span class="lineNum">   22285 </span>            :             default:</a>
<a name="22286"><span class="lineNum">   22286 </span>            :               break;</a>
<a name="22287"><span class="lineNum">   22287 </span>            :           } // end</a>
<a name="22288"><span class="lineNum">   22288 </span>            :         }// end if on left side</a>
<a name="22289"><span class="lineNum">   22289 </span>            :       }</a>
<a name="22290"><span class="lineNum">   22290 </span>            :   }</a>
<a name="22291"><span class="lineNum">   22291 </span><span class="lineNoCov">          0 :   return isReduction;</span></a>
<a name="22292"><span class="lineNum">   22292 </span>            : }</a>
<a name="22293"><span class="lineNum">   22293 </span>            : </a>
<a name="22294"><span class="lineNum">   22294 </span>            : //!Recognize and collect reduction variables and operations within a C/C++ loop, following OpenMP 3.0 specification for allowed reduction variable types and operation types.</a>
<a name="22295"><span class="lineNum">   22295 </span>            : /* This code is refactored from project/autoParallelization/autoParSupport.C</a>
<a name="22296"><span class="lineNum">   22296 </span>            :   std::vector&lt;SgInitializedName*&gt;</a>
<a name="22297"><span class="lineNum">   22297 </span>            :   RecognizeReduction(SgNode *loop, OmpSupport::OmpAttribute* attribute, std::vector&lt;SgInitializedName*&gt;&amp; candidateVars/)</a>
<a name="22298"><span class="lineNum">   22298 </span>            :   * Algorithms:</a>
<a name="22299"><span class="lineNum">   22299 </span>            :    *   for each scalar candidate which are both live-in and live-out for the loop body</a>
<a name="22300"><span class="lineNum">   22300 </span>            :    *   (We don't use liveness analysis here for simplicity)</a>
<a name="22301"><span class="lineNum">   22301 </span>            :    *    and which is not the loop invariant variable (loop index).</a>
<a name="22302"><span class="lineNum">   22302 </span>            :    *   Consider those with only 1 or 2 references</a>
<a name="22303"><span class="lineNum">   22303 </span>            :    *   1 reference</a>
<a name="22304"><span class="lineNum">   22304 </span>            :    *     the operation is one of x++, ++x, x--, --x, x binop= expr</a>
<a name="22305"><span class="lineNum">   22305 </span>            :    *   2 references belonging to the same operation</a>
<a name="22306"><span class="lineNum">   22306 </span>            :    *     operations: one of  x= x op expr,  x = expr op x (except for subtraction)</a>
<a name="22307"><span class="lineNum">   22307 </span>            :    * The reduction description from the OpenMP 3.0 specification.</a>
<a name="22308"><span class="lineNum">   22308 </span>            :    *  x is not referenced in exp</a>
<a name="22309"><span class="lineNum">   22309 </span>            :    *  expr has scalar type (no array, objects etc)</a>
<a name="22310"><span class="lineNum">   22310 </span>            :    *  x: scalar only, aggregate types (including arrays), pointer types and reference types may not appear in a reduction clause.</a>
<a name="22311"><span class="lineNum">   22311 </span>            :    *  op is not an overloaded operator, but +, *, -, &amp;, ^ ,|, &amp;&amp;, ||</a>
<a name="22312"><span class="lineNum">   22312 </span>            :    *  binop is not an overloaded operator, but: +, *, -, &amp;, ^ ,|</a>
<a name="22313"><span class="lineNum">   22313 </span>            :   */</a>
<a name="22314"><span class="lineNum">   22314 </span><span class="lineNoCov">          0 : void SageInterface::ReductionRecognition(SgForStatement* loop, std::set&lt; std::pair &lt;SgInitializedName*, OmpSupport::omp_construct_enum &gt; &gt; &amp; results)</span></a>
<a name="22315"><span class="lineNum">   22315 </span>            : {</a>
<a name="22316"><span class="lineNum">   22316 </span>            :   //x. Collect variable references of scalar types as candidates, excluding loop index</a>
<a name="22317"><span class="lineNum">   22317 </span><span class="lineNoCov">          0 :   SgInitializedName* loopindex;</span></a>
<a name="22318"><span class="lineNum">   22318 </span><span class="lineNoCov">          0 :   if (!(isCanonicalForLoop(loop, &amp;loopindex)))</span></a>
<a name="22319"><span class="lineNum">   22319 </span>            :   {</a>
<a name="22320"><span class="lineNum">   22320 </span>            : //    cerr&lt;&lt;&quot;Skip reduction recognition for non-canonical for loop&quot;&lt;&lt;endl;</a>
<a name="22321"><span class="lineNum">   22321 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="22322"><span class="lineNum">   22322 </span>            :   }</a>
<a name="22323"><span class="lineNum">   22323 </span><span class="lineNoCov">          0 :   std::set&lt;SgInitializedName*&gt; candidateVars; // scalar variables used within the loop</span></a>
<a name="22324"><span class="lineNum">   22324 </span>            :   //Store the references for each scalar variable</a>
<a name="22325"><span class="lineNum">   22325 </span><span class="lineNoCov">          0 :   std::map &lt;SgInitializedName*, vector&lt;SgVarRefExp* &gt; &gt; var_references;</span></a>
<a name="22326"><span class="lineNum">   22326 </span>            : </a>
<a name="22327"><span class="lineNum">   22327 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt; reflist = NodeQuery::querySubTree(loop, V_SgVarRefExp);</span></a>
<a name="22328"><span class="lineNum">   22328 </span><span class="lineNoCov">          0 :   SgStatement* lbody= loop-&gt;get_loop_body();</span></a>
<a name="22329"><span class="lineNum">   22329 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(lbody != NULL);</span></a>
<a name="22330"><span class="lineNum">   22330 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt;::iterator iter = reflist.begin();</span></a>
<a name="22331"><span class="lineNum">   22331 </span><span class="lineNoCov">          0 :   for (; iter!=reflist.end(); iter++)</span></a>
<a name="22332"><span class="lineNum">   22332 </span>            :   {</a>
<a name="22333"><span class="lineNum">   22333 </span><span class="lineNoCov">          0 :     SgVarRefExp* ref_exp = isSgVarRefExp(*iter);</span></a>
<a name="22334"><span class="lineNum">   22334 </span><span class="lineNoCov">          0 :     SgInitializedName* initname= ref_exp-&gt;get_symbol()-&gt;get_declaration();</span></a>
<a name="22335"><span class="lineNum">   22335 </span>            :     // candidates are of scalar types and are not the loop index variable</a>
<a name="22336"><span class="lineNum">   22336 </span>            :     // And also should be live-in:</a>
<a name="22337"><span class="lineNum">   22337 </span>            :     //        not declared locally (var_scope equal or lower than loop body )</a>
<a name="22338"><span class="lineNum">   22338 </span>            :     //        or redefined (captured by ref count)</a>
<a name="22339"><span class="lineNum">   22339 </span><span class="lineNoCov">          0 :     SgScopeStatement* var_scope = initname-&gt;get_scope();</span></a>
<a name="22340"><span class="lineNum">   22340 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(var_scope != NULL);</span></a>
<a name="22341"><span class="lineNum">   22341 </span><span class="lineNoCov">          0 :     if ((isScalarType(initname-&gt;get_type())) &amp;&amp;(initname !=loopindex)</span></a>
<a name="22342"><span class="lineNum">   22342 </span><span class="lineNoCov">          0 :         &amp;&amp; !(SageInterface::isAncestor(lbody, var_scope)||(lbody==var_scope)))</span></a>
<a name="22343"><span class="lineNum">   22343 </span>            :     {</a>
<a name="22344"><span class="lineNum">   22344 </span><span class="lineNoCov">          0 :       candidateVars.insert(initname);</span></a>
<a name="22345"><span class="lineNum">   22345 </span><span class="lineNoCov">          0 :       var_references[initname].push_back(ref_exp);</span></a>
<a name="22346"><span class="lineNum">   22346 </span>            :     }</a>
<a name="22347"><span class="lineNum">   22347 </span>            :   }</a>
<a name="22348"><span class="lineNum">   22348 </span>            : </a>
<a name="22349"><span class="lineNum">   22349 </span>            :   //Consider variables referenced at most twice</a>
<a name="22350"><span class="lineNum">   22350 </span><span class="lineNoCov">          0 :   std::set&lt;SgInitializedName*&gt;::iterator niter=candidateVars.begin();</span></a>
<a name="22351"><span class="lineNum">   22351 </span><span class="lineNoCov">          0 :   for (; niter!=candidateVars.end(); niter++)</span></a>
<a name="22352"><span class="lineNum">   22352 </span>            :   {</a>
<a name="22353"><span class="lineNum">   22353 </span><span class="lineNoCov">          0 :     SgInitializedName* initname = *niter;</span></a>
<a name="22354"><span class="lineNum">   22354 </span><span class="lineNoCov">          0 :     bool isReduction = false;</span></a>
<a name="22355"><span class="lineNum">   22355 </span><span class="lineNoCov">          0 :     OmpSupport::omp_construct_enum optype;</span></a>
<a name="22356"><span class="lineNum">   22356 </span>            :     // referenced once only</a>
<a name="22357"><span class="lineNum">   22357 </span><span class="lineNoCov">          0 :     if (var_references[initname].size()==1)</span></a>
<a name="22358"><span class="lineNum">   22358 </span>            :     {</a>
<a name="22359"><span class="lineNum">   22359 </span><span class="lineNoCov">          0 :       mlog[Sawyer::Message::Common::DEBUG] &lt;&lt; &quot;Debug: SageInterface::ReductionRecognition() A candidate used once:&quot;&lt;&lt;initname-&gt;get_name().getString()&lt;&lt;endl;</span></a>
<a name="22360"><span class="lineNum">   22360 </span><span class="lineNoCov">          0 :       SgVarRefExp* ref_exp = *(var_references[initname].begin());</span></a>
<a name="22361"><span class="lineNum">   22361 </span><span class="lineNoCov">          0 :       if (isSingleAppearanceReduction (ref_exp, optype))</span></a>
<a name="22362"><span class="lineNum">   22362 </span>            :         isReduction = true;</a>
<a name="22363"><span class="lineNum">   22363 </span>            :     }</a>
<a name="22364"><span class="lineNum">   22364 </span>            :     // referenced twice within a same statement</a>
<a name="22365"><span class="lineNum">   22365 </span><span class="lineNoCov">          0 :     else if (var_references[initname].size()==2)</span></a>
<a name="22366"><span class="lineNum">   22366 </span>            :     {</a>
<a name="22367"><span class="lineNum">   22367 </span><span class="lineNoCov">          0 :       mlog[Sawyer::Message::Common::DEBUG] &lt;&lt; &quot;Debug: A candidate used twice:&quot;&lt;&lt;initname-&gt;get_name().getString()&lt;&lt;endl;</span></a>
<a name="22368"><span class="lineNum">   22368 </span><span class="lineNoCov">          0 :       SgVarRefExp* ref_exp1 = *(var_references[initname].begin());</span></a>
<a name="22369"><span class="lineNum">   22369 </span><span class="lineNoCov">          0 :       SgVarRefExp* ref_exp2 = *(++var_references[initname].begin());</span></a>
<a name="22370"><span class="lineNum">   22370 </span>            :       // TODO: recognize  maxV = array[i]&gt;maxV? array[i]:maxV // this can be normalized to if () stmt</a>
<a name="22371"><span class="lineNum">   22371 </span>            :       // TODO: recognize  maxV = max (maxV, array[i])</a>
<a name="22372"><span class="lineNum">   22372 </span><span class="lineNoCov">          0 :       if (isAssignReduction (ref_exp1, ref_exp2, optype) || isIfReduction (ref_exp1, ref_exp2, optype) )</span></a>
<a name="22373"><span class="lineNum">   22373 </span>            :       {</a>
<a name="22374"><span class="lineNum">   22374 </span>            :         isReduction = true;</a>
<a name="22375"><span class="lineNum">   22375 </span>            :       }</a>
<a name="22376"><span class="lineNum">   22376 </span>            : </a>
<a name="22377"><span class="lineNum">   22377 </span>            :     }// end referenced twice</a>
<a name="22378"><span class="lineNum">   22378 </span>            : </a>
<a name="22379"><span class="lineNum">   22379 </span>            :     if (isReduction)</a>
<a name="22380"><span class="lineNum">   22380 </span><span class="lineNoCov">          0 :       results.insert(make_pair(initname,optype));</span></a>
<a name="22381"><span class="lineNum">   22381 </span>            :   }// end for ()</a>
<a name="22382"><span class="lineNum">   22382 </span>            : }</a>
<a name="22383"><span class="lineNum">   22383 </span>            : </a>
<a name="22384"><span class="lineNum">   22384 </span>            : //! a wrapper for ConstantFolding::constantFoldingOptimization ()</a>
<a name="22385"><span class="lineNum">   22385 </span><span class="lineCov">         56 : void SageInterface::constantFolding(SgNode* r)</span></a>
<a name="22386"><span class="lineNum">   22386 </span>            : {</a>
<a name="22387"><span class="lineNum">   22387 </span><span class="lineCov">         56 :   ROSE_ASSERT(r!=NULL);</span></a>
<a name="22388"><span class="lineNum">   22388 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="22389"><span class="lineNum">   22389 </span><span class="lineCov">         56 :   ConstantFolding::constantFoldingOptimization(r,false);</span></a>
<a name="22390"><span class="lineNum">   22390 </span>            : #endif</a>
<a name="22391"><span class="lineNum">   22391 </span><span class="lineCov">         56 : }</span></a>
<a name="22392"><span class="lineNum">   22392 </span>            : </a>
<a name="22393"><span class="lineNum">   22393 </span>            : //! Generate unique names for expressions and attach the names as persistent attributes</a>
<a name="22394"><span class="lineNum">   22394 </span><span class="lineCov">          1 : void SageInterface::annotateExpressionsWithUniqueNames (SgProject* project)</span></a>
<a name="22395"><span class="lineNum">   22395 </span>            : {</a>
<a name="22396"><span class="lineNum">   22396 </span><span class="lineCov">          1 :   class visitorTraversal:public AstSimpleProcessing</span></a>
<a name="22397"><span class="lineNum">   22397 </span>            :   {</a>
<a name="22398"><span class="lineNum">   22398 </span>            :     public:</a>
<a name="22399"><span class="lineNum">   22399 </span><span class="lineCov">      17016 :       virtual void visit (SgNode * n)</span></a>
<a name="22400"><span class="lineNum">   22400 </span>            :       {</a>
<a name="22401"><span class="lineNum">   22401 </span><span class="lineCov">      17016 :         SgExpression* exp = isSgExpression(n);</span></a>
<a name="22402"><span class="lineNum">   22402 </span><span class="lineCov">      17016 :         if (exp)</span></a>
<a name="22403"><span class="lineNum">   22403 </span>            :         {</a>
<a name="22404"><span class="lineNum">   22404 </span><span class="lineCov">         24 :           string u_name = generateUniqueName(exp,false)+&quot;-&quot;+exp-&gt;class_name();</span></a>
<a name="22405"><span class="lineNum">   22405 </span><span class="lineCov">         16 :           AstAttribute * name_attribute = new UniqueNameAttribute(u_name);</span></a>
<a name="22406"><span class="lineNum">   22406 </span><span class="lineCov">          8 :           ROSE_ASSERT (name_attribute != NULL);</span></a>
<a name="22407"><span class="lineNum">   22407 </span><span class="lineCov">         16 :           exp-&gt;addNewAttribute(&quot;UniqueNameAttribute&quot;,name_attribute);</span></a>
<a name="22408"><span class="lineNum">   22408 </span>            :         }</a>
<a name="22409"><span class="lineNum">   22409 </span><span class="lineCov">      17016 :       }</span></a>
<a name="22410"><span class="lineNum">   22410 </span>            :   };</a>
<a name="22411"><span class="lineNum">   22411 </span><span class="lineCov">          1 :   visitorTraversal exampleTraversal;</span></a>
<a name="22412"><span class="lineNum">   22412 </span>            :   //Sriram FIX: should traverse using the traverse function</a>
<a name="22413"><span class="lineNum">   22413 </span>            :   // exampleTraversal.traverseInputFiles(project,preorder);</a>
<a name="22414"><span class="lineNum">   22414 </span><span class="lineCov">          1 :   exampleTraversal.traverse(project, preorder);</span></a>
<a name="22415"><span class="lineNum">   22415 </span><span class="lineCov">          1 : }</span></a>
<a name="22416"><span class="lineNum">   22416 </span>            : </a>
<a name="22417"><span class="lineNum">   22417 </span>            : </a>
<a name="22418"><span class="lineNum">   22418 </span>            :   //</a>
<a name="22419"><span class="lineNum">   22419 </span>            :   // wrap free-standing function body in another function</a>
<a name="22420"><span class="lineNum">   22420 </span>            : </a>
<a name="22421"><span class="lineNum">   22421 </span><span class="lineCov">       2264 :   SgInitializedName&amp; SageInterface::getFirstVariable(SgVariableDeclaration&amp; vardecl)</span></a>
<a name="22422"><span class="lineNum">   22422 </span>            :   {</a>
<a name="22423"><span class="lineNum">   22423 </span><span class="lineCov">       2264 :     ROSE_ASSERT(vardecl.get_variables().size());</span></a>
<a name="22424"><span class="lineNum">   22424 </span>            : </a>
<a name="22425"><span class="lineNum">   22425 </span><span class="lineCov">       2264 :     return *vardecl.get_variables().front();</span></a>
<a name="22426"><span class="lineNum">   22426 </span>            :   }</a>
<a name="22427"><span class="lineNum">   22427 </span>            : </a>
<a name="22428"><span class="lineNum">   22428 </span>            : #if 0</a>
<a name="22429"><span class="lineNum">   22429 </span>            :   // DQ (11/1/2016): This function violated the ROSE -enable-advanced-warnings</a>
<a name="22430"><span class="lineNum">   22430 </span>            :   // option (-D_GLIBCXX_CONCEPT_CHECKS -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC).</a>
<a name="22431"><span class="lineNum">   22431 </span>            : </a>
<a name="22432"><span class="lineNum">   22432 </span>            :   /// \brief  clones a function parameter list @params and uses the function</a>
<a name="22433"><span class="lineNum">   22433 </span>            :   ///         definition @fundef as new scope</a>
<a name="22434"><span class="lineNum">   22434 </span>            :   /// \return a copy of a function parameter list</a>
<a name="22435"><span class="lineNum">   22435 </span>            :   /// \param  params the original list</a>
<a name="22436"><span class="lineNum">   22436 </span>            :   /// \param  fundef the function definition with which the new parameter list</a>
<a name="22437"><span class="lineNum">   22437 </span>            :   ///         will be associated (indirectly through the function declaration).</a>
<a name="22438"><span class="lineNum">   22438 </span>            :   ///         fundef can be NULL.</a>
<a name="22439"><span class="lineNum">   22439 </span>            :   static</a>
<a name="22440"><span class="lineNum">   22440 </span>            :   SgFunctionParameterList&amp;</a>
<a name="22441"><span class="lineNum">   22441 </span>            :   cloneParameterList(const SgFunctionParameterList&amp; params, SgFunctionDefinition* fundef = NULL)</a>
<a name="22442"><span class="lineNum">   22442 </span>            :   {</a>
<a name="22443"><span class="lineNum">   22443 </span>            :     namespace SB = SageBuilder;</a>
<a name="22444"><span class="lineNum">   22444 </span>            : </a>
<a name="22445"><span class="lineNum">   22445 </span>            :     SgFunctionParameterList&amp;          copy = *SB::buildFunctionParameterList();</a>
<a name="22446"><span class="lineNum">   22446 </span>            :     const SgInitializedNamePtrList&amp;   orig_decls = params.get_args();</a>
<a name="22447"><span class="lineNum">   22447 </span>            : </a>
<a name="22448"><span class="lineNum">   22448 </span>            :     std::transform( orig_decls.begin(), orig_decls.end(), sg::sage_inserter(copy), sg::InitNameCloner(copy, fundef) );</a>
<a name="22449"><span class="lineNum">   22449 </span>            : </a>
<a name="22450"><span class="lineNum">   22450 </span>            :     return copy;</a>
<a name="22451"><span class="lineNum">   22451 </span>            :   }</a>
<a name="22452"><span class="lineNum">   22452 </span>            : #endif</a>
<a name="22453"><span class="lineNum">   22453 </span>            : </a>
<a name="22454"><span class="lineNum">   22454 </span>            : #if 0</a>
<a name="22455"><span class="lineNum">   22455 </span>            :   // DQ (2/16/2017): This is a static function that is defined but not used in this file (compiler waring).</a>
<a name="22456"><span class="lineNum">   22456 </span>            : </a>
<a name="22457"><span class="lineNum">   22457 </span>            :   /// \brief swaps the &quot;defining elements&quot; of two function declarations</a>
<a name="22458"><span class="lineNum">   22458 </span>            :   static</a>
<a name="22459"><span class="lineNum">   22459 </span>            :   void swapDefiningElements(SgFunctionDeclaration&amp; ll, SgFunctionDeclaration&amp; rr)</a>
<a name="22460"><span class="lineNum">   22460 </span>            :   {</a>
<a name="22461"><span class="lineNum">   22461 </span>            :     // swap definitions</a>
<a name="22462"><span class="lineNum">   22462 </span>            :     sg::swap_child(ll, rr, &amp;SgFunctionDeclaration::get_definition,    &amp;SgFunctionDeclaration::set_definition);</a>
<a name="22463"><span class="lineNum">   22463 </span>            :     sg::swap_child(ll, rr, &amp;SgFunctionDeclaration::get_parameterList, &amp;SgFunctionDeclaration::set_parameterList);</a>
<a name="22464"><span class="lineNum">   22464 </span>            : </a>
<a name="22465"><span class="lineNum">   22465 </span>            :     // \todo do we need to swap also exception spec, decorator_list, etc. ?</a>
<a name="22466"><span class="lineNum">   22466 </span>            :   }</a>
<a name="22467"><span class="lineNum">   22467 </span>            : #endif</a>
<a name="22468"><span class="lineNum">   22468 </span>            : </a>
<a name="22469"><span class="lineNum">   22469 </span>            : #if 0</a>
<a name="22470"><span class="lineNum">   22470 </span>            :   // DQ (11/1/2016): This function violated the ROSE -enable-advanced-warnings</a>
<a name="22471"><span class="lineNum">   22471 </span>            :   // option (-D_GLIBCXX_CONCEPT_CHECKS -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC).</a>
<a name="22472"><span class="lineNum">   22472 </span>            : </a>
<a name="22473"><span class="lineNum">   22473 </span>            :   std::pair&lt;SgStatement*, SgInitializedName*&gt;</a>
<a name="22474"><span class="lineNum">   22474 </span>            :   SageInterface::wrapFunction(SgFunctionDeclaration&amp; definingDeclaration, SgName newName)</a>
<a name="22475"><span class="lineNum">   22475 </span>            :   {</a>
<a name="22476"><span class="lineNum">   22476 </span>            :     namespace SB = SageBuilder;</a>
<a name="22477"><span class="lineNum">   22477 </span>            : </a>
<a name="22478"><span class="lineNum">   22478 </span>            :     // handles freestanding functions only</a>
<a name="22479"><span class="lineNum">   22479 </span>            :     ROSE_ASSERT(typeid(SgFunctionDeclaration) == typeid(definingDeclaration));</a>
<a name="22480"><span class="lineNum">   22480 </span>            :     ROSE_ASSERT(definingDeclaration.get_definingDeclaration() == &amp;definingDeclaration);</a>
<a name="22481"><span class="lineNum">   22481 </span>            : </a>
<a name="22482"><span class="lineNum">   22482 </span>            :     // clone function parameter list</a>
<a name="22483"><span class="lineNum">   22483 </span>            :     SgFunctionParameterList&amp;  param_list = cloneParameterList(*definingDeclaration.get_parameterList());</a>
<a name="22484"><span class="lineNum">   22484 </span>            : </a>
<a name="22485"><span class="lineNum">   22485 </span>            :     // create new function definition/declaration in the same scope</a>
<a name="22486"><span class="lineNum">   22486 </span>            :     SgScopeStatement*         containing_scope = definingDeclaration.get_scope();</a>
<a name="22487"><span class="lineNum">   22487 </span>            :     SgType*                   result_type = definingDeclaration.get_type()-&gt;get_return_type();</a>
<a name="22488"><span class="lineNum">   22488 </span>            :     SgExprListExp*            decorators = deepCopy( definingDeclaration.get_decoratorList() );</a>
<a name="22489"><span class="lineNum">   22489 </span>            : </a>
<a name="22490"><span class="lineNum">   22490 </span>            :  // DQ (4/9/2015): Suggested fix for this function.</a>
<a name="22491"><span class="lineNum">   22491 </span>            :  // SgFunctionDeclaration*    wrapperfn = SB::buildDefiningFunctionDeclaration(newName, result_type, &amp;param_list, containing_scope, decorators);</a>
<a name="22492"><span class="lineNum">   22492 </span>            :     SgFunctionDeclaration*    wrapperfn = SB::buildDefiningFunctionDeclaration(newName, result_type, &amp;param_list, containing_scope);</a>
<a name="22493"><span class="lineNum">   22493 </span>            : </a>
<a name="22494"><span class="lineNum">   22494 </span>            :     SgFunctionDefinition*     wrapperdef = wrapperfn-&gt;get_definition();</a>
<a name="22495"><span class="lineNum">   22495 </span>            :     ROSE_ASSERT(wrapperdef);</a>
<a name="22496"><span class="lineNum">   22496 </span>            : </a>
<a name="22497"><span class="lineNum">   22497 </span>            :     // copy the exception specification</a>
<a name="22498"><span class="lineNum">   22498 </span>            :     wrapperfn-&gt;set_exceptionSpecification(definingDeclaration.get_exceptionSpecification());</a>
<a name="22499"><span class="lineNum">   22499 </span>            : </a>
<a name="22500"><span class="lineNum">   22500 </span>            :     // swap the original's function definition w/ the clone's function def</a>
<a name="22501"><span class="lineNum">   22501 </span>            :     //  and the original's func parameter list w/ the clone's parameters</a>
<a name="22502"><span class="lineNum">   22502 </span>            :     swapDefiningElements(definingDeclaration, *wrapperfn);</a>
<a name="22503"><span class="lineNum">   22503 </span>            : </a>
<a name="22504"><span class="lineNum">   22504 </span>            :     // call original function from within the defining decl's body</a>
<a name="22505"><span class="lineNum">   22505 </span>            :     SgBasicBlock*             body = wrapperdef-&gt;get_body();</a>
<a name="22506"><span class="lineNum">   22506 </span>            :     SgExprListExp*            args = SB::buildExprListExp();</a>
<a name="22507"><span class="lineNum">   22507 </span>            :     SgInitializedNamePtrList&amp; param_decls = param_list.get_args();</a>
<a name="22508"><span class="lineNum">   22508 </span>            : </a>
<a name="22509"><span class="lineNum">   22509 </span>            :     std::transform( param_decls.begin(), param_decls.end(), sg::sage_inserter(*args), sg::VarRefBuilder(*wrapperdef) );</a>
<a name="22510"><span class="lineNum">   22510 </span>            : </a>
<a name="22511"><span class="lineNum">   22511 </span>            :     SgFunctionCallExp*        callWrapped = SB::buildFunctionCallExp( newName, result_type, args, body );</a>
<a name="22512"><span class="lineNum">   22512 </span>            :     SgInitializedName*        resultName = NULL;</a>
<a name="22513"><span class="lineNum">   22513 </span>            :     SgStatement*              callStatement = NULL;</a>
<a name="22514"><span class="lineNum">   22514 </span>            : </a>
<a name="22515"><span class="lineNum">   22515 </span>            :     // \todo skip legal qualifiers that could be on top of void</a>
<a name="22516"><span class="lineNum">   22516 </span>            :     if (!isSgTypeVoid(result_type))</a>
<a name="22517"><span class="lineNum">   22517 </span>            :     {</a>
<a name="22518"><span class="lineNum">   22518 </span>            :       // add call to original function and assign result to variable</a>
<a name="22519"><span class="lineNum">   22519 </span>            :       SgVariableDeclaration*  res = SB::buildVariableDeclaration( &quot;res&quot;, result_type, SB::buildAssignInitializer(callWrapped), body );</a>
<a name="22520"><span class="lineNum">   22520 </span>            :       SgVarRefExp*            resref = SB::buildVarRefExp( res );</a>
<a name="22521"><span class="lineNum">   22521 </span>            : </a>
<a name="22522"><span class="lineNum">   22522 </span>            :       appendStatement(res, body);</a>
<a name="22523"><span class="lineNum">   22523 </span>            : </a>
<a name="22524"><span class="lineNum">   22524 </span>            :       // add return statement, returning result</a>
<a name="22525"><span class="lineNum">   22525 </span>            :       resultName    = &amp;getFirstVariable(*res);</a>
<a name="22526"><span class="lineNum">   22526 </span>            :       callStatement = res;</a>
<a name="22527"><span class="lineNum">   22527 </span>            : </a>
<a name="22528"><span class="lineNum">   22528 </span>            :       appendStatement(SB::buildReturnStmt(resref), body);</a>
<a name="22529"><span class="lineNum">   22529 </span>            :     }</a>
<a name="22530"><span class="lineNum">   22530 </span>            :     else</a>
<a name="22531"><span class="lineNum">   22531 </span>            :     {</a>
<a name="22532"><span class="lineNum">   22532 </span>            :       // add function call statement to original function</a>
<a name="22533"><span class="lineNum">   22533 </span>            :       callStatement = SB::buildExprStatement(callWrapped);</a>
<a name="22534"><span class="lineNum">   22534 </span>            :       appendStatement(callStatement, body);</a>
<a name="22535"><span class="lineNum">   22535 </span>            :     }</a>
<a name="22536"><span class="lineNum">   22536 </span>            : </a>
<a name="22537"><span class="lineNum">   22537 </span>            :     ROSE_ASSERT(callStatement);</a>
<a name="22538"><span class="lineNum">   22538 </span>            : </a>
<a name="22539"><span class="lineNum">   22539 </span>            :     // create non defining declaration</a>
<a name="22540"><span class="lineNum">   22540 </span>            :     SgExprListExp*            decorator_proto = deepCopy( decorators );</a>
<a name="22541"><span class="lineNum">   22541 </span>            :     SgFunctionDeclaration*    wrapperfn_proto = SB::buildNondefiningFunctionDeclaration(wrapperfn, containing_scope, decorator_proto);</a>
<a name="22542"><span class="lineNum">   22542 </span>            : </a>
<a name="22543"><span class="lineNum">   22543 </span>            :     // add the new functions at the proper location of the surrounding scope</a>
<a name="22544"><span class="lineNum">   22544 </span>            :     insertStatementBefore(&amp;definingDeclaration, wrapperfn_proto);</a>
<a name="22545"><span class="lineNum">   22545 </span>            :     insertStatementAfter (&amp;definingDeclaration, wrapperfn);</a>
<a name="22546"><span class="lineNum">   22546 </span>            : </a>
<a name="22547"><span class="lineNum">   22547 </span>            :     return std::make_pair(callStatement, resultName);</a>
<a name="22548"><span class="lineNum">   22548 </span>            :   }</a>
<a name="22549"><span class="lineNum">   22549 </span>            : #endif</a>
<a name="22550"><span class="lineNum">   22550 </span>            : </a>
<a name="22551"><span class="lineNum">   22551 </span>            :   //</a>
<a name="22552"><span class="lineNum">   22552 </span>            :   // flatten C/C++ array dimensions</a>
<a name="22553"><span class="lineNum">   22553 </span>            :   namespace</a>
<a name="22554"><span class="lineNum">   22554 </span>            :   {</a>
<a name="22555"><span class="lineNum">   22555 </span><span class="lineCov">         71 :     struct VarrefBuilder</span></a>
<a name="22556"><span class="lineNum">   22556 </span>            :     {</a>
<a name="22557"><span class="lineNum">   22557 </span>            :       virtual SgVarRefExp* get() const = 0;</a>
<a name="22558"><span class="lineNum">   22558 </span>            : </a>
<a name="22559"><span class="lineNum">   22559 </span>            :       static</a>
<a name="22560"><span class="lineNum">   22560 </span><span class="lineNoCov">          0 :       SgVarRefExp* build(const SgVarRefExp&amp; n)</span></a>
<a name="22561"><span class="lineNum">   22561 </span>            :       {</a>
<a name="22562"><span class="lineNum">   22562 </span><span class="lineNoCov">          0 :         return SageInterface::deepCopy(&amp;n);</span></a>
<a name="22563"><span class="lineNum">   22563 </span>            :       }</a>
<a name="22564"><span class="lineNum">   22564 </span>            : </a>
<a name="22565"><span class="lineNum">   22565 </span>            :       static</a>
<a name="22566"><span class="lineNum">   22566 </span><span class="lineNoCov">          0 :       SgVarRefExp* build(SgInitializedName&amp; n)</span></a>
<a name="22567"><span class="lineNum">   22567 </span>            :       {</a>
<a name="22568"><span class="lineNum">   22568 </span><span class="lineNoCov">          0 :         SgScopeStatement* scope = sg::ancestor&lt;SgStatement&gt;(n).get_scope();</span></a>
<a name="22569"><span class="lineNum">   22569 </span>            : </a>
<a name="22570"><span class="lineNum">   22570 </span><span class="lineNoCov">          0 :         return SageBuilder::buildVarRefExp(&amp;n, scope);</span></a>
<a name="22571"><span class="lineNum">   22571 </span>            :       }</a>
<a name="22572"><span class="lineNum">   22572 </span>            :     };</a>
<a name="22573"><span class="lineNum">   22573 </span>            : </a>
<a name="22574"><span class="lineNum">   22574 </span>            :     template &lt;class AstNode&gt;</a>
<a name="22575"><span class="lineNum">   22575 </span>            :     struct VarrefCreator : VarrefBuilder</a>
<a name="22576"><span class="lineNum">   22576 </span>            :     {</a>
<a name="22577"><span class="lineNum">   22577 </span>            :       AstNode&amp; origin;</a>
<a name="22578"><span class="lineNum">   22578 </span>            : </a>
<a name="22579"><span class="lineNum">   22579 </span>            :       explicit</a>
<a name="22580"><span class="lineNum">   22580 </span><span class="lineCov">         71 :       VarrefCreator(AstNode&amp; orig)</span></a>
<a name="22581"><span class="lineNum">   22581 </span><span class="lineCov">         71 :       : origin(orig)</span></a>
<a name="22582"><span class="lineNum">   22582 </span>            :       {}</a>
<a name="22583"><span class="lineNum">   22583 </span>            : </a>
<a name="22584"><span class="lineNum">   22584 </span><span class="lineNoCov">          0 :       SgVarRefExp* get() const { return VarrefBuilder::build(origin); }</span></a>
<a name="22585"><span class="lineNum">   22585 </span>            :     };</a>
<a name="22586"><span class="lineNum">   22586 </span>            : </a>
<a name="22587"><span class="lineNum">   22587 </span>            :     template &lt;class AstNode&gt;</a>
<a name="22588"><span class="lineNum">   22588 </span>            :     VarrefCreator&lt;AstNode&gt;</a>
<a name="22589"><span class="lineNum">   22589 </span><span class="lineCov">         71 :     varrefCreator(AstNode&amp; n)</span></a>
<a name="22590"><span class="lineNum">   22590 </span>            :     {</a>
<a name="22591"><span class="lineNum">   22591 </span><span class="lineCov">         71 :       return VarrefCreator&lt;AstNode&gt;(n);</span></a>
<a name="22592"><span class="lineNum">   22592 </span>            :     }</a>
<a name="22593"><span class="lineNum">   22593 </span>            : </a>
<a name="22594"><span class="lineNum">   22594 </span><span class="lineNoCov">          0 :     SgExpression* create_mulop(SgExpression* lhs, const SgExpression* rhs)</span></a>
<a name="22595"><span class="lineNum">   22595 </span>            :     {</a>
<a name="22596"><span class="lineNum">   22596 </span><span class="lineNoCov">          0 :       namespace SB = SageBuilder;</span></a>
<a name="22597"><span class="lineNum">   22597 </span><span class="lineNoCov">          0 :       namespace SI = SageInterface;</span></a>
<a name="22598"><span class="lineNum">   22598 </span>            : </a>
<a name="22599"><span class="lineNum">   22599 </span>            :       // we own the lhs (intermediate result),</a>
<a name="22600"><span class="lineNum">   22600 </span>            :       // but we do not own the rhs (another top-level expression)</a>
<a name="22601"><span class="lineNum">   22601 </span><span class="lineNoCov">          0 :       return SB::buildMultiplyOp(lhs, SI::deepCopy(rhs));</span></a>
<a name="22602"><span class="lineNum">   22602 </span>            :     }</a>
<a name="22603"><span class="lineNum">   22603 </span>            : </a>
<a name="22604"><span class="lineNum">   22604 </span>            :     std::pair&lt;std::vector&lt;SgExpression*&gt;, SgType*&gt;</a>
<a name="22605"><span class="lineNum">   22605 </span><span class="lineCov">         71 :     get_C_array_dimensions_aux(const SgArrayType&amp; arr_type)</span></a>
<a name="22606"><span class="lineNum">   22606 </span>            :     {</a>
<a name="22607"><span class="lineNum">   22607 </span><span class="lineCov">         71 :       namespace SB = SageBuilder;</span></a>
<a name="22608"><span class="lineNum">   22608 </span><span class="lineCov">         71 :       namespace SI = SageInterface;</span></a>
<a name="22609"><span class="lineNum">   22609 </span>            : </a>
<a name="22610"><span class="lineNum">   22610 </span><span class="lineCov">         71 :       const SgArrayType*         arrtype = &amp;arr_type;</span></a>
<a name="22611"><span class="lineNum">   22611 </span><span class="lineCov">         71 :       std::vector&lt;SgExpression*&gt; indices;</span></a>
<a name="22612"><span class="lineNum">   22612 </span><span class="lineCov">         71 :       SgType*                    undertype = NULL;</span></a>
<a name="22613"><span class="lineNum">   22613 </span>            : </a>
<a name="22614"><span class="lineNum">   22614 </span>            :       // \todo when get_index() does not return a nullptr anymore</a>
<a name="22615"><span class="lineNum">   22615 </span>            :       //       the condition can be removed</a>
<a name="22616"><span class="lineNum">   22616 </span><span class="lineCov">         71 :       if (arrtype-&gt;get_index() == NULL)</span></a>
<a name="22617"><span class="lineNum">   22617 </span>            :       {</a>
<a name="22618"><span class="lineNum">   22618 </span><span class="lineNoCov">          0 :         indices.push_back(SB::buildNullExpression());</span></a>
<a name="22619"><span class="lineNum">   22619 </span><span class="lineNoCov">          0 :         undertype = arrtype-&gt;get_base_type();</span></a>
<a name="22620"><span class="lineNum">   22620 </span><span class="lineNoCov">          0 :         arrtype = isSgArrayType(undertype);</span></a>
<a name="22621"><span class="lineNum">   22621 </span>            :       }</a>
<a name="22622"><span class="lineNum">   22622 </span>            : </a>
<a name="22623"><span class="lineNum">   22623 </span><span class="lineCov">        142 :       while (arrtype)</span></a>
<a name="22624"><span class="lineNum">   22624 </span>            :       {</a>
<a name="22625"><span class="lineNum">   22625 </span><span class="lineCov">         71 :         SgExpression* indexexpr = arrtype-&gt;get_index();</span></a>
<a name="22626"><span class="lineNum">   22626 </span><span class="lineCov">         71 :         ROSE_ASSERT(indexexpr);</span></a>
<a name="22627"><span class="lineNum">   22627 </span>            : </a>
<a name="22628"><span class="lineNum">   22628 </span><span class="lineCov">         71 :         indices.push_back(SI::deepCopy(indexexpr));</span></a>
<a name="22629"><span class="lineNum">   22629 </span><span class="lineCov">         71 :         undertype = arrtype-&gt;get_base_type();</span></a>
<a name="22630"><span class="lineNum">   22630 </span><span class="lineCov">         71 :         arrtype = isSgArrayType(undertype);</span></a>
<a name="22631"><span class="lineNum">   22631 </span>            :       }</a>
<a name="22632"><span class="lineNum">   22632 </span>            : </a>
<a name="22633"><span class="lineNum">   22633 </span><span class="lineCov">         71 :       ROSE_ASSERT((!indices.empty()) &amp;&amp; undertype);</span></a>
<a name="22634"><span class="lineNum">   22634 </span><span class="lineCov">        142 :       return std::make_pair(indices, undertype);</span></a>
<a name="22635"><span class="lineNum">   22635 </span>            :     }</a>
<a name="22636"><span class="lineNum">   22636 </span>            : </a>
<a name="22637"><span class="lineNum">   22637 </span>            :     /// \param varrefBuilder generates an unowned varref expression on demand</a>
<a name="22638"><span class="lineNum">   22638 </span>            :     std::vector&lt;SgExpression*&gt;</a>
<a name="22639"><span class="lineNum">   22639 </span><span class="lineCov">         71 :     get_C_array_dimensions_aux(const SgArrayType&amp; arrtype, const VarrefBuilder&amp; varrefBuilder)</span></a>
<a name="22640"><span class="lineNum">   22640 </span>            :     {</a>
<a name="22641"><span class="lineNum">   22641 </span><span class="lineCov">         71 :       namespace SB = SageBuilder;</span></a>
<a name="22642"><span class="lineNum">   22642 </span>            : </a>
<a name="22643"><span class="lineNum">   22643 </span><span class="lineCov">         71 :       std::pair&lt;std::vector&lt;SgExpression*&gt;, SgType*&gt; res = get_C_array_dimensions_aux(arrtype);</span></a>
<a name="22644"><span class="lineNum">   22644 </span><span class="lineCov">         71 :       const std::vector&lt;SgExpression*&gt;::iterator     first = res.first.begin();</span></a>
<a name="22645"><span class="lineNum">   22645 </span>            : </a>
<a name="22646"><span class="lineNum">   22646 </span>            :       // if the first dimension was open, create the expression for it</a>
<a name="22647"><span class="lineNum">   22647 </span><span class="lineCov">         71 :       if (isSgNullExpression(*first))</span></a>
<a name="22648"><span class="lineNum">   22648 </span>            :       {</a>
<a name="22649"><span class="lineNum">   22649 </span>            :         // handle implicit first dimension for array initializers</a>
<a name="22650"><span class="lineNum">   22650 </span>            :         // for something like</a>
<a name="22651"><span class="lineNum">   22651 </span>            :         //      int p[][2][3] = {{{ 1, 2, 3 }, { 4, 5, 6 }}}</a>
<a name="22652"><span class="lineNum">   22652 </span>            :         //  we can calculate the first dimension as</a>
<a name="22653"><span class="lineNum">   22653 </span>            :         //      sizeof( p ) / ( sizeof( int ) * 2 * 3 )</a>
<a name="22654"><span class="lineNum">   22654 </span>            : </a>
<a name="22655"><span class="lineNum">   22655 </span><span class="lineNoCov">          0 :         const std::vector&lt;SgExpression*&gt;::iterator aa = first+1;</span></a>
<a name="22656"><span class="lineNum">   22656 </span><span class="lineNoCov">          0 :         const std::vector&lt;SgExpression*&gt;::iterator zz = res.first.end();</span></a>
<a name="22657"><span class="lineNum">   22657 </span>            : </a>
<a name="22658"><span class="lineNum">   22658 </span><span class="lineNoCov">          0 :         SgExpression* sz_undertype = SB::buildSizeOfOp(res.second);</span></a>
<a name="22659"><span class="lineNum">   22659 </span><span class="lineNoCov">          0 :         SgExpression* denominator  = std::accumulate(aa, zz, sz_undertype, create_mulop);</span></a>
<a name="22660"><span class="lineNum">   22660 </span><span class="lineNoCov">          0 :         SgSizeOfOp*   sz_var       = SB::buildSizeOfOp(varrefBuilder.get());</span></a>
<a name="22661"><span class="lineNum">   22661 </span><span class="lineNoCov">          0 :         SgExpression* sz           = SB::buildDivideOp(sz_var, denominator);</span></a>
<a name="22662"><span class="lineNum">   22662 </span>            : </a>
<a name="22663"><span class="lineNum">   22663 </span><span class="lineNoCov">          0 :         std::swap(*first, sz);</span></a>
<a name="22664"><span class="lineNum">   22664 </span><span class="lineNoCov">          0 :         delete sz;</span></a>
<a name="22665"><span class="lineNum">   22665 </span>            :       }</a>
<a name="22666"><span class="lineNum">   22666 </span>            : </a>
<a name="22667"><span class="lineNum">   22667 </span><span class="lineCov">        142 :       return res.first;</span></a>
<a name="22668"><span class="lineNum">   22668 </span>            :     }</a>
<a name="22669"><span class="lineNum">   22669 </span>            :   }</a>
<a name="22670"><span class="lineNum">   22670 </span>            : </a>
<a name="22671"><span class="lineNum">   22671 </span>            :   std::vector&lt;SgExpression*&gt;</a>
<a name="22672"><span class="lineNum">   22672 </span><span class="lineNoCov">          0 :   SageInterface::get_C_array_dimensions(const SgArrayType&amp; arrtype)</span></a>
<a name="22673"><span class="lineNum">   22673 </span>            :   {</a>
<a name="22674"><span class="lineNum">   22674 </span><span class="lineNoCov">          0 :     return get_C_array_dimensions_aux(arrtype).first;</span></a>
<a name="22675"><span class="lineNum">   22675 </span>            :   }</a>
<a name="22676"><span class="lineNum">   22676 </span>            : </a>
<a name="22677"><span class="lineNum">   22677 </span>            :   std::vector&lt;SgExpression*&gt;</a>
<a name="22678"><span class="lineNum">   22678 </span><span class="lineCov">         71 :   SageInterface::get_C_array_dimensions(const SgArrayType&amp; arrtype, const SgVarRefExp&amp; varref)</span></a>
<a name="22679"><span class="lineNum">   22679 </span>            :   {</a>
<a name="22680"><span class="lineNum">   22680 </span><span class="lineCov">         71 :     return get_C_array_dimensions_aux(arrtype, varrefCreator(varref));</span></a>
<a name="22681"><span class="lineNum">   22681 </span>            :   }</a>
<a name="22682"><span class="lineNum">   22682 </span>            : </a>
<a name="22683"><span class="lineNum">   22683 </span>            :   std::vector&lt;SgExpression*&gt;</a>
<a name="22684"><span class="lineNum">   22684 </span><span class="lineNoCov">          0 :   SageInterface::get_C_array_dimensions(const SgArrayType&amp; arrtype, SgInitializedName&amp; initname)</span></a>
<a name="22685"><span class="lineNum">   22685 </span>            :   {</a>
<a name="22686"><span class="lineNum">   22686 </span><span class="lineNoCov">          0 :     return get_C_array_dimensions_aux(arrtype, varrefCreator(initname));</span></a>
<a name="22687"><span class="lineNum">   22687 </span>            :   }</a>
<a name="22688"><span class="lineNum">   22688 </span>            : </a>
<a name="22689"><span class="lineNum">   22689 </span>            : // DQ (1/23/2013): Added support for generated a set of source sequence entries.</a>
<a name="22690"><span class="lineNum">   22690 </span><span class="lineCov">        147 : class CollectSourceSequenceNumbers : public AstSimpleProcessing</span></a>
<a name="22691"><span class="lineNum">   22691 </span>            :    {</a>
<a name="22692"><span class="lineNum">   22692 </span>            :      public:</a>
<a name="22693"><span class="lineNum">   22693 </span>            :           set&lt;unsigned int&gt; sourceSequenceSet;</a>
<a name="22694"><span class="lineNum">   22694 </span>            : </a>
<a name="22695"><span class="lineNum">   22695 </span>            :           void visit ( SgNode* astNode );</a>
<a name="22696"><span class="lineNum">   22696 </span>            :    };</a>
<a name="22697"><span class="lineNum">   22697 </span>            : </a>
<a name="22698"><span class="lineNum">   22698 </span>            : // DQ (1/23/2013): Added support for generated a set of source sequence entries.</a>
<a name="22699"><span class="lineNum">   22699 </span>            : void</a>
<a name="22700"><span class="lineNum">   22700 </span><span class="lineCov">        457 : CollectSourceSequenceNumbers::visit ( SgNode* astNode )</span></a>
<a name="22701"><span class="lineNum">   22701 </span>            :    {</a>
<a name="22702"><span class="lineNum">   22702 </span><span class="lineCov">        457 :      Sg_File_Info* fileInfo = astNode-&gt;get_file_info();</span></a>
<a name="22703"><span class="lineNum">   22703 </span><span class="lineCov">        457 :      if (fileInfo != NULL)</span></a>
<a name="22704"><span class="lineNum">   22704 </span>            :         {</a>
<a name="22705"><span class="lineNum">   22705 </span><span class="lineCov">        457 :           unsigned int source_sequence_number = fileInfo-&gt;get_source_sequence_number();</span></a>
<a name="22706"><span class="lineNum">   22706 </span>            : #if 0</a>
<a name="22707"><span class="lineNum">   22707 </span>            :           printf (&quot;In CollectSourceSequenceNumbers::visit(): source_sequence_number = %&quot; PRIuPTR &quot; \n&quot;,source_sequence_number);</a>
<a name="22708"><span class="lineNum">   22708 </span>            : #endif</a>
<a name="22709"><span class="lineNum">   22709 </span><span class="lineCov">        457 :           sourceSequenceSet.insert(source_sequence_number);</span></a>
<a name="22710"><span class="lineNum">   22710 </span>            :         }</a>
<a name="22711"><span class="lineNum">   22711 </span><span class="lineCov">        457 :    }</span></a>
<a name="22712"><span class="lineNum">   22712 </span>            : </a>
<a name="22713"><span class="lineNum">   22713 </span>            : // DQ (1/23/2013): Added support for generated a set of source sequence entries.</a>
<a name="22714"><span class="lineNum">   22714 </span>            : set&lt;unsigned int&gt;</a>
<a name="22715"><span class="lineNum">   22715 </span><span class="lineCov">        147 : SageInterface::collectSourceSequenceNumbers( SgNode* astNode )</span></a>
<a name="22716"><span class="lineNum">   22716 </span>            :   {</a>
<a name="22717"><span class="lineNum">   22717 </span><span class="lineCov">        147 :     CollectSourceSequenceNumbers traversal;</span></a>
<a name="22718"><span class="lineNum">   22718 </span>            : </a>
<a name="22719"><span class="lineNum">   22719 </span><span class="lineCov">        147 :     traversal.traverse(astNode,preorder);</span></a>
<a name="22720"><span class="lineNum">   22720 </span>            : </a>
<a name="22721"><span class="lineNum">   22721 </span><span class="lineCov">        147 :     return traversal.sourceSequenceSet;</span></a>
<a name="22722"><span class="lineNum">   22722 </span>            : </a>
<a name="22723"><span class="lineNum">   22723 </span>            :   }</a>
<a name="22724"><span class="lineNum">   22724 </span>            : </a>
<a name="22725"><span class="lineNum">   22725 </span>            : /*Winnie, loop collapse, collapse nested for loops into one large for loop</a>
<a name="22726"><span class="lineNum">   22726 </span>            :  *  return a SgExprListExp *, which will contain a list of SgVarRefExp * to variables newly created, inserted outside of the</a>
<a name="22727"><span class="lineNum">   22727 </span>            :  *                            loop scope, and used inside the loop scope.</a>
<a name="22728"><span class="lineNum">   22728 </span>            :  *                            If the target_loop comes with omp target directive, these variables should be added in map in clause in</a>
<a name="22729"><span class="lineNum">   22729 </span>            :  *                            transOmpCollpase(..) function in omp_lowering.cpp.</a>
<a name="22730"><span class="lineNum">   22730 </span>            :  *</a>
<a name="22731"><span class="lineNum">   22731 </span>            :  *  The input loop pointer is changed to the generated collapsed loop after the transformation.</a>
<a name="22732"><span class="lineNum">   22732 </span>            :  *</a>
<a name="22733"><span class="lineNum">   22733 </span>            :  *</a>
<a name="22734"><span class="lineNum">   22734 </span>            :  *  Loop is normalized to [lb,ub,step], ub is inclusive (&lt;=, &gt;=)</a>
<a name="22735"><span class="lineNum">   22735 </span>            :  *</a>
<a name="22736"><span class="lineNum">   22736 </span>            :  *  to collapse two level of loops:</a>
<a name="22737"><span class="lineNum">   22737 </span>            :  *  iteration_count_one= (ub1-lb1+1)%step1 ==0?(ub1-lb1+1)/step1: (ub1-lb1+1)/step1+1</a>
<a name="22738"><span class="lineNum">   22738 </span>            :  *  iteration_count_two= (ub2-lb2+1)%step2 ==0?(ub2-lb2+1)/step2: (ub2-lb2+1)/step2+1</a>
<a name="22739"><span class="lineNum">   22739 </span>            :  *  total_iteration_count = iteration_count_one * iteration_count_two</a>
<a name="22740"><span class="lineNum">   22740 </span>            :  *</a>
<a name="22741"><span class="lineNum">   22741 </span>            :  *  Decide incremental/decremental loop by checking operator of test statement(ub), &lt;=/&gt;=, this is done in isCanonicalForLoop()</a>
<a name="22742"><span class="lineNum">   22742 </span>            :  *</a>
<a name="22743"><span class="lineNum">   22743 </span>            :  * Example 1:</a>
<a name="22744"><span class="lineNum">   22744 </span>            :  * for (int i=lb2;i&lt;ub2;i+=inc2)                 //incremental</a>
<a name="22745"><span class="lineNum">   22745 </span>            :  *  {</a>
<a name="22746"><span class="lineNum">   22746 </span>            :  *      for (int j=lb1;j&gt;ub1;i+=inc1)            //decremental</a>
<a name="22747"><span class="lineNum">   22747 </span>            :  *      {</a>
<a name="22748"><span class="lineNum">   22748 </span>            :  *                  for (int l=lb2;l&lt;ub2;l+=inc2)        //incremental</a>
<a name="22749"><span class="lineNum">   22749 </span>            :  *              {</a>
<a name="22750"><span class="lineNum">   22750 </span>            :  *               a[i][j][l]=i+j+l;</a>
<a name="22751"><span class="lineNum">   22751 </span>            :  *              }</a>
<a name="22752"><span class="lineNum">   22752 </span>            :  *      }</a>
<a name="22753"><span class="lineNum">   22753 </span>            :  *  }</a>
<a name="22754"><span class="lineNum">   22754 </span>            :  *</a>
<a name="22755"><span class="lineNum">   22755 </span>            :  *==&gt; translated output code ==&gt;</a>
<a name="22756"><span class="lineNum">   22756 </span>            :  *  int i_nom_1_total_iters = (ub2 - 1 - lb2 + 1) % inc2 == 0?(ub2 - 1 - lb2 + 1) / inc2 : (ub2 - 1 - lb2 + 1) / inc2 + 1;</a>
<a name="22757"><span class="lineNum">   22757 </span>            :  *  int j_nom_2_total_iters = (lb1 - (ub1 + 1) + 1) % (inc1 * -1) == 0?(lb1 - (ub1 + 1) + 1) / (inc1 * -1) : (lb1 - (ub1 + 1) + 1) / (inc1 * -1) + 1;</a>
<a name="22758"><span class="lineNum">   22758 </span>            :  *  int l_nom_3_total_iters = (ub2 - 1 - lb2 + 1) % inc2 == 0?(ub2 - 1 - lb2 + 1) / inc2 : (ub2 - 1 - lb2 + 1) / inc2 + 1;</a>
<a name="22759"><span class="lineNum">   22759 </span>            :  *  int final_total_iters = 1 * i_nom_1_total_iters* j_nom_2_total_iters* l_nom_3_total_iters;</a>
<a name="22760"><span class="lineNum">   22760 </span>            :  *  int i_nom_1_interval = j_nom_2_total_iters * (l_nom_3_total_iters* 1);</a>
<a name="22761"><span class="lineNum">   22761 </span>            :  *  int j_nom_2_interval = l_nom_3_total_iters * 1;</a>
<a name="22762"><span class="lineNum">   22762 </span>            :  *  int l_nom_3_interval = 1;</a>
<a name="22763"><span class="lineNum">   22763 </span>            :  *</a>
<a name="22764"><span class="lineNum">   22764 </span>            :  *  for (int new_index = 0; new_index &lt;= final_total_iters- 1; new_index += 1) {</a>
<a name="22765"><span class="lineNum">   22765 </span>            :  *    i_nom_1 = new_index / i_nom_1_interval* inc2 + lb2;</a>
<a name="22766"><span class="lineNum">   22766 </span>            :  *    int i_nom_1_remainder = new_index % i_nom_1_interval;</a>
<a name="22767"><span class="lineNum">   22767 </span>            :  *    j_nom_2 = -(i_nom_1_remainder / j_nom_2_interval* (inc1 * -1)) + lb1;</a>
<a name="22768"><span class="lineNum">   22768 </span>            :  *    l_nom_3 = i_nom_1_remainder % j_nom_2_interval* inc2 + lb2;</a>
<a name="22769"><span class="lineNum">   22769 </span>            :  *    a[i_nom_1][j_nom_2][l_nom_3] = i_nom_1 + j_nom_2 + l_nom_3;</a>
<a name="22770"><span class="lineNum">   22770 </span>            :  *  }</a>
<a name="22771"><span class="lineNum">   22771 </span>            :  *</a>
<a name="22772"><span class="lineNum">   22772 </span>            :  *  Example 2 with concrete numbers:</a>
<a name="22773"><span class="lineNum">   22773 </span>            :  *</a>
<a name="22774"><span class="lineNum">   22774 </span>            :  * // collapse the following two level of for loops:</a>
<a name="22775"><span class="lineNum">   22775 </span>            :  *       for (i=1; i&lt;=9; i+=1)      //incremental for loop</a>
<a name="22776"><span class="lineNum">   22776 </span>            :  *       {</a>
<a name="22777"><span class="lineNum">   22777 </span>            :  *          for(j=10; j&gt;=1; j+=-2)    //decremental for loop</a>
<a name="22778"><span class="lineNum">   22778 </span>            :  *         {</a>
<a name="22779"><span class="lineNum">   22779 </span>            :  *              a[i][j]=i+j;</a>
<a name="22780"><span class="lineNum">   22780 </span>            :  *         }</a>
<a name="22781"><span class="lineNum">   22781 </span>            :  *       }</a>
<a name="22782"><span class="lineNum">   22782 </span>            :  * // it becomes</a>
<a name="22783"><span class="lineNum">   22783 </span>            :  *     // total iteration count = ((9 - 1 + 1)/1) * ((10 - 1 + 1)/2) = 45</a>
<a name="22784"><span class="lineNum">   22784 </span>            :  *     // ub = 45</a>
<a name="22785"><span class="lineNum">   22785 </span>            :  *     // lb = 0</a>
<a name="22786"><span class="lineNum">   22786 </span>            :  *</a>
<a name="22787"><span class="lineNum">   22787 </span>            :  *     int i_nom_1_total_iters = 9;</a>
<a name="22788"><span class="lineNum">   22788 </span>            :  *     int j_nom_1_total_iters = 5;      // 10 % (-2 * -1) == 0 ? 10 / (-2 * -1) : 10 /(-2 * -1) + 1;</a>
<a name="22789"><span class="lineNum">   22789 </span>            :  *     int final_total_iters = 45;       // i_nom_1_total_iters * j_nom_2_total_iters;</a>
<a name="22790"><span class="lineNum">   22790 </span>            :  *</a>
<a name="22791"><span class="lineNum">   22791 </span>            :  *     int i_nom_1_interval = 5;</a>
<a name="22792"><span class="lineNum">   22792 </span>            :  *</a>
<a name="22793"><span class="lineNum">   22793 </span>            :  *     for (z=0; z&lt;=44; z+=1)</a>
<a name="22794"><span class="lineNum">   22794 </span>            :  *     {</a>
<a name="22795"><span class="lineNum">   22795 </span>            :  *       i_nom_1 = z / 5 + 1;</a>
<a name="22796"><span class="lineNum">   22796 </span>            :  *       j_nom_2 = -(z % 5 * 2) + 10;</a>
<a name="22797"><span class="lineNum">   22797 </span>            :  *       a[i_nom_1][j_nom_2]=i_nom_1 + j_nom_2;</a>
<a name="22798"><span class="lineNum">   22798 </span>            :  *     }</a>
<a name="22799"><span class="lineNum">   22799 </span>            :  *  // for the generated loop, a few compiler generated variables are introduced</a>
<a name="22800"><span class="lineNum">   22800 </span>            :  *     final_total_iters for the collapsed loop</a>
<a name="22801"><span class="lineNum">   22801 </span>            :  *     i_interval for each of the n-1 loops</a>
<a name="22802"><span class="lineNum">   22802 </span>            :  **</a>
<a name="22803"><span class="lineNum">   22803 </span>            : */</a>
<a name="22804"><span class="lineNum">   22804 </span>            : </a>
<a name="22805"><span class="lineNum">   22805 </span>            : #ifndef USE_ROSE</a>
<a name="22806"><span class="lineNum">   22806 </span><span class="lineCov">          5 : SgExprListExp * SageInterface::loopCollapsing(SgForStatement* loop, size_t collapsing_factor)</span></a>
<a name="22807"><span class="lineNum">   22807 </span>            : {</a>
<a name="22808"><span class="lineNum">   22808 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="22809"><span class="lineNum">   22809 </span>            :   //Handle 0 and 1, which means no collapsing at all</a>
<a name="22810"><span class="lineNum">   22810 </span><span class="lineCov">          5 :     if (collapsing_factor &lt;= 1)</span></a>
<a name="22811"><span class="lineNum">   22811 </span>            :         return NULL;</a>
<a name="22812"><span class="lineNum">   22812 </span>            : </a>
<a name="22813"><span class="lineNum">   22813 </span><span class="lineCov">          5 :     SgExprListExp * new_var_list = buildExprListExp();  //expression list contains all the SgVarRefExp * to variables that need to be added in the mapin clause</span></a>
<a name="22814"><span class="lineNum">   22814 </span>            : </a>
<a name="22815"><span class="lineNum">   22815 </span>            :     /*</a>
<a name="22816"><span class="lineNum">   22816 </span>            :      *step 1: grab the target loops' header information</a>
<a name="22817"><span class="lineNum">   22817 </span>            :      */</a>
<a name="22818"><span class="lineNum">   22818 </span><span class="lineCov">          5 :     SgForStatement *&amp; target_loop = loop;</span></a>
<a name="22819"><span class="lineNum">   22819 </span>            : </a>
<a name="22820"><span class="lineNum">   22820 </span>            :     // we use global scope to help generate unique variable name later</a>
<a name="22821"><span class="lineNum">   22821 </span>            :     // local scope-based unique names may cause conflicts if the declarations are moved around (in OpenMP target data promotion)</a>
<a name="22822"><span class="lineNum">   22822 </span><span class="lineCov">          5 :     SgGlobal* global_scope = getGlobalScope (loop);</span></a>
<a name="22823"><span class="lineNum">   22823 </span><span class="lineCov">          5 :     ROSE_ASSERT (global_scope != NULL);</span></a>
<a name="22824"><span class="lineNum">   22824 </span><span class="lineCov">          5 :     SgInitializedName** ivar = new SgInitializedName*[collapsing_factor];</span></a>
<a name="22825"><span class="lineNum">   22825 </span><span class="lineCov">          5 :     SgExpression** lb = new SgExpression*[collapsing_factor];</span></a>
<a name="22826"><span class="lineNum">   22826 </span><span class="lineCov">          5 :     SgExpression** ub = new SgExpression*[collapsing_factor];</span></a>
<a name="22827"><span class="lineNum">   22827 </span><span class="lineCov">          5 :     SgExpression** step = new SgExpression*[collapsing_factor];</span></a>
<a name="22828"><span class="lineNum">   22828 </span><span class="lineCov">          5 :     SgStatement** orig_body = new SgStatement*[collapsing_factor];</span></a>
<a name="22829"><span class="lineNum">   22829 </span>            : </a>
<a name="22830"><span class="lineNum">   22830 </span><span class="lineCov">          5 :     SgExpression** total_iters = new SgExpression*[collapsing_factor]; //Winnie, the real iteration counter in each loop level</span></a>
<a name="22831"><span class="lineNum">   22831 </span><span class="lineCov">          5 :     SgExpression** interval = new SgExpression*[collapsing_factor]; //Winnie, this will be used to calculate i_nom_1_remainder</span></a>
<a name="22832"><span class="lineNum">   22832 </span><span class="lineCov">          5 :     bool *isPlus = new bool[collapsing_factor]; //Winnie, a flag indicates incremental or decremental for loop</span></a>
<a name="22833"><span class="lineNum">   22833 </span>            : </a>
<a name="22834"><span class="lineNum">   22834 </span>            : </a>
<a name="22835"><span class="lineNum">   22835 </span>            :     //Winnie, get loops info first</a>
<a name="22836"><span class="lineNum">   22836 </span><span class="lineCov">         10 :     std::vector&lt;SgForStatement* &gt; loops= SageInterface::querySubTree&lt;SgForStatement&gt;(target_loop,V_SgForStatement);</span></a>
<a name="22837"><span class="lineNum">   22837 </span><span class="lineCov">          5 :     ROSE_ASSERT(loops.size()&gt;=collapsing_factor);</span></a>
<a name="22838"><span class="lineNum">   22838 </span>            : </a>
<a name="22839"><span class="lineNum">   22839 </span><span class="lineCov">          5 :     SgForStatement* temp_target_loop = NULL;</span></a>
<a name="22840"><span class="lineNum">   22840 </span><span class="lineCov">          5 :     SgExpression* temp_range_exp = NULL; //Raw iteration range</span></a>
<a name="22841"><span class="lineNum">   22841 </span><span class="lineCov">          5 :     SgExpression* temp_range_d_step_exp = NULL; //temp_range_exp / step[i]</span></a>
<a name="22842"><span class="lineNum">   22842 </span><span class="lineCov">          5 :     SgExpression* temp_condition_1 = NULL; //Check whether temp_range_exp % step[i] == 0</span></a>
<a name="22843"><span class="lineNum">   22843 </span><span class="lineCov">          5 :     SgExpression* temp_total_iter = NULL;</span></a>
<a name="22844"><span class="lineNum">   22844 </span><span class="lineCov">          5 :     SgExpression* ub_exp = buildIntVal(1); //Winnie, upbound</span></a>
<a name="22845"><span class="lineNum">   22845 </span>            : </a>
<a name="22846"><span class="lineNum">   22846 </span>            :     /*</a>
<a name="22847"><span class="lineNum">   22847 </span>            :     *    get lb, ub, step information for each level of the loops</a>
<a name="22848"><span class="lineNum">   22848 </span>            :     *    ub_exp is the final iterantion range(starting from 0) after loop collapsing</a>
<a name="22849"><span class="lineNum">   22849 </span>            :     *    total_iters[i], = (ub[i] - lb[i] + 1)/step[i]  is the total iter num in each level of loop before loop collapsing</a>
<a name="22850"><span class="lineNum">   22850 </span>            :     */</a>
<a name="22851"><span class="lineNum">   22851 </span>            : </a>
<a name="22852"><span class="lineNum">   22852 </span><span class="lineCov">          5 :     SgStatement* parent =  isSgStatement(getScope(target_loop)-&gt;get_parent());        //Winnie, the scope that include target_loop</span></a>
<a name="22853"><span class="lineNum">   22853 </span><span class="lineCov">          5 :     ROSE_ASSERT(getScope(target_loop)-&gt;get_parent()!= NULL);</span></a>
<a name="22854"><span class="lineNum">   22854 </span>            : </a>
<a name="22855"><span class="lineNum">   22855 </span><span class="lineCov">          5 :     SgScopeStatement* scope = isSgScopeStatement(parent);    //Winnie, the scope that include target_loop</span></a>
<a name="22856"><span class="lineNum">   22856 </span>            : </a>
<a name="22857"><span class="lineNum">   22857 </span><span class="lineCov">          5 :     while(scope == NULL)</span></a>
<a name="22858"><span class="lineNum">   22858 </span>            :     {</a>
<a name="22859"><span class="lineNum">   22859 </span><span class="lineNoCov">          0 :        parent = isSgStatement(parent-&gt;get_parent());</span></a>
<a name="22860"><span class="lineNum">   22860 </span><span class="lineNoCov">          0 :        scope = isSgScopeStatement(parent);</span></a>
<a name="22861"><span class="lineNum">   22861 </span>            :     }</a>
<a name="22862"><span class="lineNum">   22862 </span>            : </a>
<a name="22863"><span class="lineNum">   22863 </span><span class="lineCov">          5 :     SgStatement* insert_target = findLastDeclarationStatement(scope);</span></a>
<a name="22864"><span class="lineNum">   22864 </span><span class="lineCov">          5 :     if (insert_target != NULL)</span></a>
<a name="22865"><span class="lineNum">   22865 </span><span class="lineCov">          4 :         insert_target = getNextStatement(insert_target);</span></a>
<a name="22866"><span class="lineNum">   22866 </span>            :     else</a>
<a name="22867"><span class="lineNum">   22867 </span><span class="lineCov">          1 :         insert_target = getFirstStatement(scope);</span></a>
<a name="22868"><span class="lineNum">   22868 </span>            : </a>
<a name="22869"><span class="lineNum">   22869 </span><span class="lineCov">          5 :     ROSE_ASSERT(scope != NULL);</span></a>
<a name="22870"><span class="lineNum">   22870 </span>            : </a>
<a name="22871"><span class="lineNum">   22871 </span>            : </a>
<a name="22872"><span class="lineNum">   22872 </span><span class="lineCov">         21 :     for(size_t i = 0; i &lt; collapsing_factor; i ++)</span></a>
<a name="22873"><span class="lineNum">   22873 </span>            :     {</a>
<a name="22874"><span class="lineNum">   22874 </span><span class="lineCov">         16 :         temp_target_loop = loops[i];</span></a>
<a name="22875"><span class="lineNum">   22875 </span>            : </a>
<a name="22876"><span class="lineNum">   22876 </span>            :         // normalize the target loop first  // adjust to numbering starting from 0</a>
<a name="22877"><span class="lineNum">   22877 </span><span class="lineCov">         16 :         forLoopNormalization(temp_target_loop);</span></a>
<a name="22878"><span class="lineNum">   22878 </span>            : </a>
<a name="22879"><span class="lineNum">   22879 </span><span class="lineCov">         16 :         if (!isCanonicalForLoop(temp_target_loop, &amp;ivar[i], &amp;lb[i], &amp;ub[i], &amp;step[i], &amp;orig_body[i], &amp;isPlus[i]))</span></a>
<a name="22880"><span class="lineNum">   22880 </span>            :         {</a>
<a name="22881"><span class="lineNum">   22881 </span><span class="lineNoCov">          0 :             cerr&lt;&lt;&quot;Error in SageInterface::loopCollapsing(): target loop is not canonical.&quot;&lt;&lt;endl;</span></a>
<a name="22882"><span class="lineNum">   22882 </span><span class="lineNoCov">          0 :             dumpInfo(target_loop);</span></a>
<a name="22883"><span class="lineNum">   22883 </span><span class="lineNoCov">          0 :             return NULL;</span></a>
<a name="22884"><span class="lineNum">   22884 </span>            :         }</a>
<a name="22885"><span class="lineNum">   22885 </span>            : </a>
<a name="22886"><span class="lineNum">   22886 </span><span class="lineCov">         16 :         ROSE_ASSERT(ivar[i]&amp;&amp; lb[i] &amp;&amp; ub[i] &amp;&amp; step[i]);</span></a>
<a name="22887"><span class="lineNum">   22887 </span>            : </a>
<a name="22888"><span class="lineNum">   22888 </span>            : </a>
<a name="22889"><span class="lineNum">   22889 </span>            : //Winnie, (ub[i]-lb[i]+1)%step[i] ==0?(ub[i]-lb[i]+1)/step[i]: (ub[i]-lb[i]+1)/step[i]+1; (need ceiling) total number of iterations in this level (ub[i] - lb[i] + 1)/step[i]</a>
<a name="22890"><span class="lineNum">   22890 </span><span class="lineCov">         16 :         if(isPlus[i] == true)</span></a>
<a name="22891"><span class="lineNum">   22891 </span><span class="lineCov">         13 :             temp_range_exp = buildAddOp(buildSubtractOp(copyExpression(ub[i]), copyExpression(lb[i])), buildIntVal(1));</span></a>
<a name="22892"><span class="lineNum">   22892 </span>            :         else{</a>
<a name="22893"><span class="lineNum">   22893 </span><span class="lineCov">          3 :             temp_range_exp = buildAddOp(buildSubtractOp(copyExpression(lb[i]), copyExpression(ub[i])), buildIntVal(1));</span></a>
<a name="22894"><span class="lineNum">   22894 </span><span class="lineCov">          3 :             step[i] = buildMultiplyOp(step[i], buildIntVal(-1));</span></a>
<a name="22895"><span class="lineNum">   22895 </span>            :         }</a>
<a name="22896"><span class="lineNum">   22896 </span><span class="lineCov">         16 :         temp_range_d_step_exp = buildDivideOp(temp_range_exp,copyExpression(step[i]));//(ub[i]-lb[i]+1)/step[i]</span></a>
<a name="22897"><span class="lineNum">   22897 </span>            : </a>
<a name="22898"><span class="lineNum">   22898 </span><span class="lineCov">         16 :         temp_condition_1 = buildEqualityOp(buildModOp(copyExpression(temp_range_exp),copyExpression(step[i])),buildIntVal(0)); //(ub[i]-lb[i]+1)%step[i] ==0</span></a>
<a name="22899"><span class="lineNum">   22899 </span>            : </a>
<a name="22900"><span class="lineNum">   22900 </span><span class="lineCov">         16 :         temp_total_iter = buildConditionalExp(temp_condition_1,temp_range_d_step_exp, buildAddOp(copyExpression(temp_range_d_step_exp),buildIntVal(1)));</span></a>
<a name="22901"><span class="lineNum">   22901 </span>            : </a>
<a name="22902"><span class="lineNum">   22902 </span>            :         //build variables to store iteration numbers in each loop, simplify the calculation of &quot;final_total_iters&quot;</a>
<a name="22903"><span class="lineNum">   22903 </span>            :         //insert the new variable (store real iteration number of each level of the loop) before the target loop</a>
<a name="22904"><span class="lineNum">   22904 </span><span class="lineCov">         32 :         string iter_var_name= &quot;_total_iters&quot;;</span></a>
<a name="22905"><span class="lineNum">   22905 </span>            :         //iter_var_name = ivar[i]-&gt;get_name().getString() + iter_var_name + generateUniqueName(temp_total_iter, false);</a>
<a name="22906"><span class="lineNum">   22906 </span><span class="lineCov">         16 :         iter_var_name = &quot;__&quot;+ivar[i]-&gt;get_name().getString() + iter_var_name+ generateUniqueVariableName (global_scope,&quot;&quot;);</span></a>
<a name="22907"><span class="lineNum">   22907 </span><span class="lineCov">         16 :         SgVariableDeclaration* total_iter = buildVariableDeclaration(iter_var_name, buildIntType(), buildAssignInitializer(temp_total_iter, buildIntType()), scope);</span></a>
<a name="22908"><span class="lineNum">   22908 </span><span class="lineCov">         16 :         insertStatementBefore(insert_target, total_iter);</span></a>
<a name="22909"><span class="lineNum">   22909 </span><span class="lineCov">         16 :         constantFolding (total_iter);</span></a>
<a name="22910"><span class="lineNum">   22910 </span><span class="lineCov">         16 :         total_iters[i] = buildVarRefExp(iter_var_name, scope);</span></a>
<a name="22911"><span class="lineNum">   22911 </span><span class="lineCov">         16 :         ub_exp = buildMultiplyOp(ub_exp, total_iters[i]);    //Winnie, build up the final iteration range</span></a>
<a name="22912"><span class="lineNum">   22912 </span>            :     }</a>
<a name="22913"><span class="lineNum">   22913 </span>            : </a>
<a name="22914"><span class="lineNum">   22914 </span>            : </a>
<a name="22915"><span class="lineNum">   22915 </span>            :     /*</a>
<a name="22916"><span class="lineNum">   22916 </span>            :     * step 2: build new variables (new_index, final_total_iters, remainders...) for the new loop</a>
<a name="22917"><span class="lineNum">   22917 </span>            :     */</a>
<a name="22918"><span class="lineNum">   22918 </span>            : </a>
<a name="22919"><span class="lineNum">   22919 </span>            :     /*Winnie, build another variable to store final total iteration counter of the loop after collapsing*/</a>
<a name="22920"><span class="lineNum">   22920 </span>            :     //string final_iter_counter_name = &quot;final_total_iters&quot; + generateUniqueName(ub_exp, false);</a>
<a name="22921"><span class="lineNum">   22921 </span><span class="lineCov">         15 :     string final_iter_counter_name = &quot;__final_total_iters&quot; + generateUniqueVariableName(global_scope,&quot;&quot;);</span></a>
<a name="22922"><span class="lineNum">   22922 </span><span class="lineCov">          5 :     SgVariableDeclaration * final_total_iter = buildVariableDeclaration(final_iter_counter_name, buildIntType(), buildAssignInitializer(copyExpression(ub_exp), buildIntType()), scope);</span></a>
<a name="22923"><span class="lineNum">   22923 </span><span class="lineCov">          5 :     insertStatementBefore(insert_target, final_total_iter);</span></a>
<a name="22924"><span class="lineNum">   22924 </span><span class="lineCov">          5 :     ub_exp = buildVarRefExp(final_iter_counter_name, scope);</span></a>
<a name="22925"><span class="lineNum">   22925 </span><span class="lineCov">          5 :     new_var_list-&gt;append_expression(isSgVarRefExp(ub_exp));</span></a>
<a name="22926"><span class="lineNum">   22926 </span>            : </a>
<a name="22927"><span class="lineNum">   22927 </span>            :     /*Winnie, interval[i] will make the calculation of remainders simpler*/</a>
<a name="22928"><span class="lineNum">   22928 </span><span class="lineCov">         21 :     for(unsigned int i = 0; i &lt; collapsing_factor; i++)</span></a>
<a name="22929"><span class="lineNum">   22929 </span>            :     {</a>
<a name="22930"><span class="lineNum">   22930 </span><span class="lineCov">         16 :         interval[i] = buildIntVal(1);</span></a>
<a name="22931"><span class="lineNum">   22931 </span><span class="lineCov">         37 :         for(unsigned int j = collapsing_factor - 1; j &gt; i; j--)</span></a>
<a name="22932"><span class="lineNum">   22932 </span>            :         {</a>
<a name="22933"><span class="lineNum">   22933 </span><span class="lineCov">         21 :             interval[i] = buildMultiplyOp(total_iters[j], interval[i]);</span></a>
<a name="22934"><span class="lineNum">   22934 </span>            :         }</a>
<a name="22935"><span class="lineNum">   22935 </span>            :         //string interval_name = ivar[i]-&gt;get_name().getString() + &quot;_interval&quot; + generateUniqueName(interval[i], false);</a>
<a name="22936"><span class="lineNum">   22936 </span><span class="lineCov">         48 :         string interval_name = &quot;__&quot;+ ivar[i]-&gt;get_name().getString() + &quot;_interval&quot; + generateUniqueVariableName (global_scope,&quot;&quot;);</span></a>
<a name="22937"><span class="lineNum">   22937 </span><span class="lineCov">         16 :         SgVariableDeclaration* temp_interval = buildVariableDeclaration(interval_name, buildIntType(), buildAssignInitializer(copyExpression(interval[i]), buildIntType()), scope);</span></a>
<a name="22938"><span class="lineNum">   22938 </span><span class="lineCov">         16 :         insertStatementBefore(insert_target, temp_interval);</span></a>
<a name="22939"><span class="lineNum">   22939 </span><span class="lineCov">         16 :         interval[i] = buildVarRefExp(interval_name, scope);</span></a>
<a name="22940"><span class="lineNum">   22940 </span><span class="lineCov">         16 :         new_var_list-&gt;append_expression(isSgVarRefExp(interval[i]));</span></a>
<a name="22941"><span class="lineNum">   22941 </span>            :     }</a>
<a name="22942"><span class="lineNum">   22942 </span>            : </a>
<a name="22943"><span class="lineNum">   22943 </span>            : </a>
<a name="22944"><span class="lineNum">   22944 </span>            :    //Winnie, starting from here, we are dealing with variables inside loop, update scope</a>
<a name="22945"><span class="lineNum">   22945 </span><span class="lineCov">          5 :       scope = getScope(target_loop);</span></a>
<a name="22946"><span class="lineNum">   22946 </span>            : </a>
<a name="22947"><span class="lineNum">   22947 </span>            :    //Winnie, init statement of the loop header, copy the lower bound, we are dealing with a range, the lower bound should always be &quot;0&quot;</a>
<a name="22948"><span class="lineNum">   22948 </span>            :     //Winnie, declare a brand new var as the new index</a>
<a name="22949"><span class="lineNum">   22949 </span><span class="lineCov">         15 :       string ivar_name = &quot;__collapsed_index&quot;+ generateUniqueVariableName (global_scope,&quot;&quot;);</span></a>
<a name="22950"><span class="lineNum">   22950 </span><span class="lineCov">          5 :       ROSE_ASSERT(insert_target != NULL);</span></a>
<a name="22951"><span class="lineNum">   22951 </span><span class="lineCov">          5 :       SgVariableDeclaration* new_index_decl = buildVariableDeclaration(ivar_name, buildIntType(), NULL, insert_target-&gt;get_scope());</span></a>
<a name="22952"><span class="lineNum">   22952 </span><span class="lineCov">          5 :       SgVariableSymbol * collapsed_index_symbol = getFirstVarSym (new_index_decl);</span></a>
<a name="22953"><span class="lineNum">   22953 </span><span class="lineCov">          5 :       insertStatementBefore(insert_target, new_index_decl);</span></a>
<a name="22954"><span class="lineNum">   22954 </span><span class="lineCov">          5 :       SgVarRefExp * clps_index_ref = buildVarRefExp(collapsed_index_symbol);</span></a>
<a name="22955"><span class="lineNum">   22955 </span><span class="lineCov">          5 :       new_var_list-&gt;append_expression(clps_index_ref);</span></a>
<a name="22956"><span class="lineNum">   22956 </span>            : </a>
<a name="22957"><span class="lineNum">   22957 </span>            : //      SgVariableDeclaration* init_stmt = buildVariableDeclaration(ivar_name, buildIntType(), buildAssignInitializer(buildIntVal(0), buildIntType()), scope);</a>
<a name="22958"><span class="lineNum">   22958 </span>            : </a>
<a name="22959"><span class="lineNum">   22959 </span>            : </a>
<a name="22960"><span class="lineNum">   22960 </span><span class="lineCov">          5 :      SgBasicBlock* body = isSgBasicBlock(deepCopy(temp_target_loop-&gt;get_loop_body())); // normalized loop has a BB body</span></a>
<a name="22961"><span class="lineNum">   22961 </span><span class="lineCov">          5 :      ROSE_ASSERT(body != NULL);</span></a>
<a name="22962"><span class="lineNum">   22962 </span><span class="lineCov">          5 :      SgExpression* new_exp = NULL;</span></a>
<a name="22963"><span class="lineNum">   22963 </span><span class="lineCov">          5 :      SgExpression* remain_exp_temp = buildVarRefExp(ivar_name, scope);</span></a>
<a name="22964"><span class="lineNum">   22964 </span><span class="lineCov">         10 :      std::vector&lt;SgStatement*&gt; new_stmt_list;</span></a>
<a name="22965"><span class="lineNum">   22965 </span>            : </a>
<a name="22966"><span class="lineNum">   22966 </span><span class="lineCov">          5 :      SgExprStatement* assign_stmt = NULL;</span></a>
<a name="22967"><span class="lineNum">   22967 </span>            : </a>
<a name="22968"><span class="lineNum">   22968 </span>            :      /*  Winnie</a>
<a name="22969"><span class="lineNum">   22969 </span>            :      *   express old iterator variables (i_norm, j_norm ...)  with new_index,</a>
<a name="22970"><span class="lineNum">   22970 </span>            :      *   new_exp, create new expression for each of the iterators</a>
<a name="22971"><span class="lineNum">   22971 </span>            :      *   i_nom_1 = (_new_index / interval[0])*step[0] + lb[0]</a>
<a name="22972"><span class="lineNum">   22972 </span>            :      *   i_nom_1_remain_value = (_new_index % interval[0])*step[0] + lb[0], create a new var to store remain value</a>
<a name="22973"><span class="lineNum">   22973 </span>            :      *   create a new var to store total_iters[i]</a>
<a name="22974"><span class="lineNum">   22974 </span>            :      */</a>
<a name="22975"><span class="lineNum">   22975 </span><span class="lineCov">         16 :      for(unsigned int i = 0; i &lt; collapsing_factor - 1; i ++)</span></a>
<a name="22976"><span class="lineNum">   22976 </span>            :      {</a>
<a name="22977"><span class="lineNum">   22977 </span><span class="lineCov">         11 :          if(isPlus[i] == true)</span></a>
<a name="22978"><span class="lineNum">   22978 </span><span class="lineCov">          9 :              new_exp = buildAddOp(buildMultiplyOp(buildDivideOp(copyExpression(remain_exp_temp), copyExpression(interval[i])), step[i]), copyExpression(lb[i]));  //Winnie, (i_remain/interval[i])*step[i] + lb[i]</span></a>
<a name="22979"><span class="lineNum">   22979 </span>            :          else</a>
<a name="22980"><span class="lineNum">   22980 </span><span class="lineCov">          2 :              new_exp = buildAddOp(buildMinusOp(buildMultiplyOp(buildDivideOp(copyExpression(remain_exp_temp), copyExpression(interval[i])), step[i])), copyExpression(lb[i]));  //Winnie, -(i_remain/interval[i])*step[i] + lb[i], for decremental loop</span></a>
<a name="22981"><span class="lineNum">   22981 </span>            : </a>
<a name="22982"><span class="lineNum">   22982 </span><span class="lineCov">         11 :          assign_stmt = buildAssignStatement(buildVarRefExp(ivar[i], scope), copyExpression(new_exp));</span></a>
<a name="22983"><span class="lineNum">   22983 </span><span class="lineCov">         11 :          new_stmt_list.push_back(assign_stmt);</span></a>
<a name="22984"><span class="lineNum">   22984 </span><span class="lineCov">         11 :          remain_exp_temp = buildModOp((remain_exp_temp), copyExpression(interval[i]));</span></a>
<a name="22985"><span class="lineNum">   22985 </span>            : </a>
<a name="22986"><span class="lineNum">   22986 </span><span class="lineCov">         11 :          if(i != collapsing_factor - 2){ //Winnie, if this is the second last level of loop, no need to create new variable to hold the remain_value, or remove the original index variable declaration</span></a>
<a name="22987"><span class="lineNum">   22987 </span><span class="lineCov">         12 :              string remain_var_name= &quot;_remainder&quot;;</span></a>
<a name="22988"><span class="lineNum">   22988 </span><span class="lineCov">          6 :              remain_var_name = &quot;__&quot;+ ivar[i]-&gt;get_name().getString() + remain_var_name;</span></a>
<a name="22989"><span class="lineNum">   22989 </span><span class="lineCov">          6 :              SgVariableDeclaration* loop_index_decl = buildVariableDeclaration(remain_var_name, buildIntType(), buildAssignInitializer(remain_exp_temp, buildIntType()), scope);</span></a>
<a name="22990"><span class="lineNum">   22990 </span><span class="lineCov">          6 :              remain_exp_temp = buildVarRefExp(remain_var_name, scope);</span></a>
<a name="22991"><span class="lineNum">   22991 </span><span class="lineCov">          6 :              new_stmt_list.push_back(loop_index_decl);</span></a>
<a name="22992"><span class="lineNum">   22992 </span>            :          }</a>
<a name="22993"><span class="lineNum">   22993 </span><span class="lineCov">         11 :          new_exp = NULL;</span></a>
<a name="22994"><span class="lineNum">   22994 </span>            :      }</a>
<a name="22995"><span class="lineNum">   22995 </span>            : </a>
<a name="22996"><span class="lineNum">   22996 </span>            : //Winnie, the inner most loop, iter</a>
<a name="22997"><span class="lineNum">   22997 </span><span class="lineCov">          5 :     if(isPlus[collapsing_factor - 1] == true)</span></a>
<a name="22998"><span class="lineNum">   22998 </span><span class="lineCov">          4 :         assign_stmt = buildAssignStatement(buildVarRefExp(ivar[collapsing_factor - 1], scope), buildAddOp(buildMultiplyOp(remain_exp_temp, step[collapsing_factor - 1]), lb[collapsing_factor - 1]));</span></a>
<a name="22999"><span class="lineNum">   22999 </span>            :     else</a>
<a name="23000"><span class="lineNum">   23000 </span><span class="lineCov">          1 :         assign_stmt = buildAssignStatement(buildVarRefExp(ivar[collapsing_factor - 1], scope), buildAddOp(buildMinusOp(buildMultiplyOp(remain_exp_temp, step[collapsing_factor - 1])), lb[collapsing_factor - 1]));</span></a>
<a name="23001"><span class="lineNum">   23001 </span><span class="lineCov">          5 :      new_stmt_list.push_back(assign_stmt);</span></a>
<a name="23002"><span class="lineNum">   23002 </span><span class="lineCov">          5 :      prependStatementList(new_stmt_list, body);</span></a>
<a name="23003"><span class="lineNum">   23003 </span>            : </a>
<a name="23004"><span class="lineNum">   23004 </span>            :     /*</a>
<a name="23005"><span class="lineNum">   23005 </span>            :     * step 3: build the new loop, new step is always 1, disregard value of step[i]</a>
<a name="23006"><span class="lineNum">   23006 </span>            :     */</a>
<a name="23007"><span class="lineNum">   23007 </span><span class="lineCov">          5 :     SgExpression* incr_exp = buildPlusAssignOp(buildVarRefExp(ivar_name, scope), buildIntVal(1));</span></a>
<a name="23008"><span class="lineNum">   23008 </span>            : </a>
<a name="23009"><span class="lineNum">   23009 </span>            :     //Winnie, build the new conditional expression/ub</a>
<a name="23010"><span class="lineNum">   23010 </span><span class="lineCov">          5 :     SgExprStatement* cond_stmt = NULL;</span></a>
<a name="23011"><span class="lineNum">   23011 </span><span class="lineCov">          5 :     ub_exp = buildSubtractOp(ub_exp, buildIntVal(1));</span></a>
<a name="23012"><span class="lineNum">   23012 </span><span class="lineCov">          5 :     cond_stmt = buildExprStatement(buildLessOrEqualOp(buildVarRefExp(ivar_name,scope),copyExpression(ub_exp)));</span></a>
<a name="23013"><span class="lineNum">   23013 </span><span class="lineCov">          5 :     ROSE_ASSERT(cond_stmt != NULL);</span></a>
<a name="23014"><span class="lineNum">   23014 </span>            : </a>
<a name="23015"><span class="lineNum">   23015 </span><span class="lineCov">          5 :     SgForStatement* new_loop = buildForStatement(buildAssignStatement(clps_index_ref, buildIntVal(0)), cond_stmt,incr_exp, body);  //Winnie, add in the new block!</span></a>
<a name="23016"><span class="lineNum">   23016 </span><span class="lineCov">          5 :     new_loop-&gt;set_parent(scope);  //TODO: what's the correct parent?</span></a>
<a name="23017"><span class="lineNum">   23017 </span>            : </a>
<a name="23018"><span class="lineNum">   23018 </span><span class="lineCov">          5 :     replaceStatement(target_loop, new_loop);</span></a>
<a name="23019"><span class="lineNum">   23019 </span>            : </a>
<a name="23020"><span class="lineNum">   23020 </span><span class="lineCov">          5 :     target_loop = new_loop; //Winnie, so that transOmpLoop() can work on the collapsed loop</span></a>
<a name="23021"><span class="lineNum">   23021 </span>            :    // constant folding for the transformed AST</a>
<a name="23022"><span class="lineNum">   23022 </span><span class="lineCov">          5 :    ConstantFolding::constantFoldingOptimization(scope-&gt;get_parent(),false);   //Winnie, &quot;scope&quot; is the scope that contains new_loop, this is the scope where we insert some new variables to store interation count and intervals</span></a>
<a name="23023"><span class="lineNum">   23023 </span>            : </a>
<a name="23024"><span class="lineNum">   23024 </span><span class="lineCov">          5 :     delete [] ivar;</span></a>
<a name="23025"><span class="lineNum">   23025 </span><span class="lineCov">          5 :     delete [] lb;</span></a>
<a name="23026"><span class="lineNum">   23026 </span><span class="lineCov">          5 :     delete [] ub;</span></a>
<a name="23027"><span class="lineNum">   23027 </span><span class="lineCov">          5 :     delete [] step;</span></a>
<a name="23028"><span class="lineNum">   23028 </span><span class="lineCov">          5 :     delete [] orig_body;</span></a>
<a name="23029"><span class="lineNum">   23029 </span><span class="lineCov">          5 :     delete [] total_iters;</span></a>
<a name="23030"><span class="lineNum">   23030 </span><span class="lineCov">          5 :     delete [] interval;</span></a>
<a name="23031"><span class="lineNum">   23031 </span><span class="lineCov">          5 :     delete [] isPlus;</span></a>
<a name="23032"><span class="lineNum">   23032 </span>            : </a>
<a name="23033"><span class="lineNum">   23033 </span>            :     #endif</a>
<a name="23034"><span class="lineNum">   23034 </span>            : </a>
<a name="23035"><span class="lineNum">   23035 </span><span class="lineCov">          5 :     return new_var_list;</span></a>
<a name="23036"><span class="lineNum">   23036 </span>            : }</a>
<a name="23037"><span class="lineNum">   23037 </span>            : </a>
<a name="23038"><span class="lineNum">   23038 </span>            : </a>
<a name="23039"><span class="lineNum">   23039 </span>            : </a>
<a name="23040"><span class="lineNum">   23040 </span>            : bool</a>
<a name="23041"><span class="lineNum">   23041 </span><span class="lineNoCov">          0 : SageInterface::isStructurallyEquivalentAST( SgNode* tree1, SgNode* tree2 )</span></a>
<a name="23042"><span class="lineNum">   23042 </span>            :    {</a>
<a name="23043"><span class="lineNum">   23043 </span>            :   // DQ (3/4/2014): Added support for testing two trees for equivalents using the AST iterators.</a>
<a name="23044"><span class="lineNum">   23044 </span>            : </a>
<a name="23045"><span class="lineNum">   23045 </span>            : #ifndef USE_CMAKEx</a>
<a name="23046"><span class="lineNum">   23046 </span>            :   // DQ (3/8/2014): Make this conditionally compiled based on when CMake is not used because the libraries are not configured yet.</a>
<a name="23047"><span class="lineNum">   23047 </span>            : </a>
<a name="23048"><span class="lineNum">   23048 </span>            :   // This is AST container for the ROSE AST that will provide an iterator.</a>
<a name="23049"><span class="lineNum">   23049 </span>            :   // We want two iterators (one for the copy of the snippet and one for the</a>
<a name="23050"><span class="lineNum">   23050 </span>            :   // original snippet so that we can query the original snippet's AST</a>
<a name="23051"><span class="lineNum">   23051 </span>            :   // as we process each IR node of the AST for the copy of the snippet.</a>
<a name="23052"><span class="lineNum">   23052 </span>            :   // Only the copy of the snippet is inserted into the target AST.</a>
<a name="23053"><span class="lineNum">   23053 </span><span class="lineNoCov">          0 :      RoseAst ast_of_copy(tree1);</span></a>
<a name="23054"><span class="lineNum">   23054 </span><span class="lineNoCov">          0 :      RoseAst ast_of_original(tree2);</span></a>
<a name="23055"><span class="lineNum">   23055 </span>            : </a>
<a name="23056"><span class="lineNum">   23056 </span>            :   // printf (&quot;ast_of_copy.size() = %&quot; PRIuPTR &quot; \n&quot;,ast_of_copy.size());</a>
<a name="23057"><span class="lineNum">   23057 </span>            : </a>
<a name="23058"><span class="lineNum">   23058 </span>            :   // Build the iterators so that we can increment thorugh both ASTs one IR node at a time.</a>
<a name="23059"><span class="lineNum">   23059 </span><span class="lineNoCov">          0 :      RoseAst::iterator i_copy     = ast_of_copy.begin();</span></a>
<a name="23060"><span class="lineNum">   23060 </span><span class="lineNoCov">          0 :      RoseAst::iterator i_original = ast_of_original.begin();</span></a>
<a name="23061"><span class="lineNum">   23061 </span>            : </a>
<a name="23062"><span class="lineNum">   23062 </span>            :   // Iterate of the copy of the snippet's AST.</a>
<a name="23063"><span class="lineNum">   23063 </span><span class="lineNoCov">          0 :      while (i_copy != ast_of_copy.end())</span></a>
<a name="23064"><span class="lineNum">   23064 </span>            :         {</a>
<a name="23065"><span class="lineNum">   23065 </span>            : #if 0</a>
<a name="23066"><span class="lineNum">   23066 </span>            :           printf (&quot;*i_copy = %p = %s \n&quot;,*i_copy,(*i_copy)-&gt;class_name().c_str());</a>
<a name="23067"><span class="lineNum">   23067 </span>            :           printf (&quot;*i_original = %p = %s \n&quot;,*i_original,(*i_original)-&gt;class_name().c_str());</a>
<a name="23068"><span class="lineNum">   23068 </span>            : #endif</a>
<a name="23069"><span class="lineNum">   23069 </span>            :        // DQ (2/28/2014): This is a problem for some of the test codes (TEST   store/load heap string [test7a] and [test7a])</a>
<a name="23070"><span class="lineNum">   23070 </span>            :        // ROSE_ASSERT((*i_copy)-&gt;variantT() == (*i_original)-&gt;variantT());</a>
<a name="23071"><span class="lineNum">   23071 </span><span class="lineNoCov">          0 :           if ((*i_copy)-&gt;variantT() != (*i_original)-&gt;variantT())</span></a>
<a name="23072"><span class="lineNum">   23072 </span>            :              {</a>
<a name="23073"><span class="lineNum">   23073 </span>            : #if 0</a>
<a name="23074"><span class="lineNum">   23074 </span>            :                printf (&quot;ERROR: return from SageInterface::isStructurallyEquivalentAST(): (*i_copy)-&gt;variantT() != (*i_original)-&gt;variantT() \n&quot;);</a>
<a name="23075"><span class="lineNum">   23075 </span>            : #endif</a>
<a name="23076"><span class="lineNum">   23076 </span>            : #if 0</a>
<a name="23077"><span class="lineNum">   23077 </span>            :                printf (&quot;Making this an error! \n&quot;);</a>
<a name="23078"><span class="lineNum">   23078 </span>            :                ROSE_ABORT();</a>
<a name="23079"><span class="lineNum">   23079 </span>            : #endif</a>
<a name="23080"><span class="lineNum">   23080 </span>            :                return false;</a>
<a name="23081"><span class="lineNum">   23081 </span>            :              }</a>
<a name="23082"><span class="lineNum">   23082 </span>            : </a>
<a name="23083"><span class="lineNum">   23083 </span><span class="lineNoCov">          0 :           i_copy++;</span></a>
<a name="23084"><span class="lineNum">   23084 </span>            : </a>
<a name="23085"><span class="lineNum">   23085 </span>            :        // Verify that we have not reached the end of the ast for the original (both the</a>
<a name="23086"><span class="lineNum">   23086 </span>            :        // copy and the original are the same structurally, and thus the same size).</a>
<a name="23087"><span class="lineNum">   23087 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(i_original != ast_of_original.end());</span></a>
<a name="23088"><span class="lineNum">   23088 </span><span class="lineNoCov">          0 :           i_original++;</span></a>
<a name="23089"><span class="lineNum">   23089 </span>            :         }</a>
<a name="23090"><span class="lineNum">   23090 </span>            : </a>
<a name="23091"><span class="lineNum">   23091 </span>            :   // We have reached the end of both ASTs.</a>
<a name="23092"><span class="lineNum">   23092 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(i_copy == ast_of_copy.end() &amp;&amp; i_original == ast_of_original.end());</span></a>
<a name="23093"><span class="lineNum">   23093 </span>            : #endif</a>
<a name="23094"><span class="lineNum">   23094 </span>            : </a>
<a name="23095"><span class="lineNum">   23095 </span><span class="lineNoCov">          0 :      return true;</span></a>
<a name="23096"><span class="lineNum">   23096 </span>            :    }</a>
<a name="23097"><span class="lineNum">   23097 </span>            : </a>
<a name="23098"><span class="lineNum">   23098 </span>            : </a>
<a name="23099"><span class="lineNum">   23099 </span>            : #endif</a>
<a name="23100"><span class="lineNum">   23100 </span>            : </a>
<a name="23101"><span class="lineNum">   23101 </span><span class="lineNoCov">          0 : bool SageInterface::getForLoopInformations(</span></a>
<a name="23102"><span class="lineNum">   23102 </span>            :   SgForStatement * for_loop,</a>
<a name="23103"><span class="lineNum">   23103 </span>            :   SgVariableSymbol * &amp; iterator,</a>
<a name="23104"><span class="lineNum">   23104 </span>            :   SgExpression * &amp; lower_bound,</a>
<a name="23105"><span class="lineNum">   23105 </span>            :   SgExpression * &amp; upper_bound,</a>
<a name="23106"><span class="lineNum">   23106 </span>            :   SgExpression * &amp; stride</a>
<a name="23107"><span class="lineNum">   23107 </span>            : ) {</a>
<a name="23108"><span class="lineNum">   23108 </span>            :   /// \todo handle more case. For example: declaration in initialization</a>
<a name="23109"><span class="lineNum">   23109 </span>            :   /// \todo replace most assertions by error messages and 'return false;'</a>
<a name="23110"><span class="lineNum">   23110 </span>            : </a>
<a name="23111"><span class="lineNum">   23111 </span><span class="lineNoCov">          0 :   iterator = NULL;</span></a>
<a name="23112"><span class="lineNum">   23112 </span><span class="lineNoCov">          0 :   lower_bound = NULL;</span></a>
<a name="23113"><span class="lineNum">   23113 </span><span class="lineNoCov">          0 :   upper_bound = NULL;</span></a>
<a name="23114"><span class="lineNum">   23114 </span><span class="lineNoCov">          0 :   stride = NULL;</span></a>
<a name="23115"><span class="lineNum">   23115 </span>            : </a>
<a name="23116"><span class="lineNum">   23116 </span><span class="lineNoCov">          0 :   SgForInitStatement * for_init_stmt = for_loop-&gt;get_for_init_stmt();</span></a>
<a name="23117"><span class="lineNum">   23117 </span><span class="lineNoCov">          0 :   const std::vector&lt;SgStatement *&gt; &amp; init_stmts = for_init_stmt-&gt;get_init_stmt();</span></a>
<a name="23118"><span class="lineNum">   23118 </span><span class="lineNoCov">          0 :   assert(init_stmts.size() == 1);</span></a>
<a name="23119"><span class="lineNum">   23119 </span><span class="lineNoCov">          0 :   SgExprStatement * init_stmt = isSgExprStatement(init_stmts[0]);</span></a>
<a name="23120"><span class="lineNum">   23120 </span><span class="lineNoCov">          0 :   assert(init_stmt != NULL);</span></a>
<a name="23121"><span class="lineNum">   23121 </span><span class="lineNoCov">          0 :   SgExpression * init = init_stmt-&gt;get_expression();</span></a>
<a name="23122"><span class="lineNum">   23122 </span>            : </a>
<a name="23123"><span class="lineNum">   23123 </span><span class="lineNoCov">          0 :   SgAssignOp * assign_init = isSgAssignOp(init);</span></a>
<a name="23124"><span class="lineNum">   23124 </span><span class="lineNoCov">          0 :   assert(assign_init != NULL);</span></a>
<a name="23125"><span class="lineNum">   23125 </span><span class="lineNoCov">          0 :   SgVarRefExp * iterator_init_ref = isSgVarRefExp(assign_init-&gt;get_lhs_operand_i());</span></a>
<a name="23126"><span class="lineNum">   23126 </span><span class="lineNoCov">          0 :   assert(iterator_init_ref != NULL);</span></a>
<a name="23127"><span class="lineNum">   23127 </span><span class="lineNoCov">          0 :   iterator = iterator_init_ref-&gt;get_symbol();</span></a>
<a name="23128"><span class="lineNum">   23128 </span><span class="lineNoCov">          0 :   assert(iterator != NULL);</span></a>
<a name="23129"><span class="lineNum">   23129 </span><span class="lineNoCov">          0 :   lower_bound = assign_init-&gt;get_rhs_operand_i();</span></a>
<a name="23130"><span class="lineNum">   23130 </span>            : </a>
<a name="23131"><span class="lineNum">   23131 </span><span class="lineNoCov">          0 :   SgExprStatement * test_stmt = isSgExprStatement(for_loop-&gt;get_test());</span></a>
<a name="23132"><span class="lineNum">   23132 </span><span class="lineNoCov">          0 :   assert(test_stmt != NULL);</span></a>
<a name="23133"><span class="lineNum">   23133 </span><span class="lineNoCov">          0 :   SgExpression * test = test_stmt-&gt;get_expression();</span></a>
<a name="23134"><span class="lineNum">   23134 </span><span class="lineNoCov">          0 :   SgBinaryOp * bin_test = isSgBinaryOp(test);</span></a>
<a name="23135"><span class="lineNum">   23135 </span><span class="lineNoCov">          0 :   assert(bin_test);</span></a>
<a name="23136"><span class="lineNum">   23136 </span>            : </a>
<a name="23137"><span class="lineNum">   23137 </span><span class="lineNoCov">          0 :   SgExpression * lhs_exp = bin_test-&gt;get_lhs_operand_i();</span></a>
<a name="23138"><span class="lineNum">   23138 </span><span class="lineNoCov">          0 :   while (isSgCastExp(lhs_exp)) lhs_exp = ((SgCastExp *)lhs_exp)-&gt;get_operand_i();</span></a>
<a name="23139"><span class="lineNum">   23139 </span><span class="lineNoCov">          0 :   SgVarRefExp * lhs_var_ref = isSgVarRefExp(lhs_exp);</span></a>
<a name="23140"><span class="lineNum">   23140 </span><span class="lineNoCov">          0 :   bool lhs_it = (lhs_var_ref != NULL) &amp;&amp; (lhs_var_ref-&gt;get_symbol() == iterator);</span></a>
<a name="23141"><span class="lineNum">   23141 </span>            : </a>
<a name="23142"><span class="lineNum">   23142 </span><span class="lineNoCov">          0 :   SgExpression * rhs_exp = bin_test-&gt;get_rhs_operand_i();</span></a>
<a name="23143"><span class="lineNum">   23143 </span><span class="lineNoCov">          0 :   while (isSgCastExp(rhs_exp)) rhs_exp = ((SgCastExp *)rhs_exp)-&gt;get_operand_i();</span></a>
<a name="23144"><span class="lineNum">   23144 </span><span class="lineNoCov">          0 :   SgVarRefExp * rhs_var_ref = isSgVarRefExp(rhs_exp);</span></a>
<a name="23145"><span class="lineNum">   23145 </span>            : #ifndef NDEBUG</a>
<a name="23146"><span class="lineNum">   23146 </span><span class="lineNoCov">          0 :   bool rhs_it = (rhs_var_ref != NULL) &amp;&amp; (rhs_var_ref-&gt;get_symbol() == iterator);</span></a>
<a name="23147"><span class="lineNum">   23147 </span>            : </a>
<a name="23148"><span class="lineNum">   23148 </span>            : // DQ (4/21/2016): Replacing use of bitwise xor with something more approriate for logical types.</a>
<a name="23149"><span class="lineNum">   23149 </span>            : // Note that the xor logica operator does not exist in C/C++ and that this is a case of using the</a>
<a name="23150"><span class="lineNum">   23150 </span>            : // bitwise xor operator on boolean values (not a great idea).  Note that logical &quot;a xor b&quot; is</a>
<a name="23151"><span class="lineNum">   23151 </span>            : // equivalent to &quot;!a != !b&quot;  the use of &quot;!&quot; only make sure that the &quot;!=&quot; is applied to a boolean</a>
<a name="23152"><span class="lineNum">   23152 </span>            : // value.  Since these are boolean typed values we can use &quot;a != b&quot;, directly.</a>
<a name="23153"><span class="lineNum">   23153 </span>            : // assert(lhs_it xor rhs_it);</a>
<a name="23154"><span class="lineNum">   23154 </span><span class="lineNoCov">          0 :   assert(lhs_it != rhs_it);</span></a>
<a name="23155"><span class="lineNum">   23155 </span>            : #endif</a>
<a name="23156"><span class="lineNum">   23156 </span>            : </a>
<a name="23157"><span class="lineNum">   23157 </span><span class="lineNoCov">          0 :   upper_bound = lhs_it ? bin_test-&gt;get_rhs_operand_i() : bin_test-&gt;get_lhs_operand_i();</span></a>
<a name="23158"><span class="lineNum">   23158 </span>            : </a>
<a name="23159"><span class="lineNum">   23159 </span><span class="lineNoCov">          0 :   bool inclusive;</span></a>
<a name="23160"><span class="lineNum">   23160 </span><span class="lineNoCov">          0 :   bool reversed;</span></a>
<a name="23161"><span class="lineNum">   23161 </span>            : </a>
<a name="23162"><span class="lineNum">   23162 </span><span class="lineNoCov">          0 :   switch (test-&gt;variantT()) {</span></a>
<a name="23163"><span class="lineNum">   23163 </span>            :     case V_SgGreaterOrEqualOp:</a>
<a name="23164"><span class="lineNum">   23164 </span>            :       inclusive = lhs_it;</a>
<a name="23165"><span class="lineNum">   23165 </span>            :       reversed = lhs_it;</a>
<a name="23166"><span class="lineNum">   23166 </span>            :       break;</a>
<a name="23167"><span class="lineNum">   23167 </span><span class="lineNoCov">          0 :     case V_SgGreaterThanOp:</span></a>
<a name="23168"><span class="lineNum">   23168 </span><span class="lineNoCov">          0 :       inclusive = !lhs_it;</span></a>
<a name="23169"><span class="lineNum">   23169 </span><span class="lineNoCov">          0 :       reversed = lhs_it;</span></a>
<a name="23170"><span class="lineNum">   23170 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23171"><span class="lineNum">   23171 </span><span class="lineNoCov">          0 :     case V_SgLessOrEqualOp:</span></a>
<a name="23172"><span class="lineNum">   23172 </span><span class="lineNoCov">          0 :       inclusive = lhs_it;</span></a>
<a name="23173"><span class="lineNum">   23173 </span><span class="lineNoCov">          0 :       reversed = !lhs_it;</span></a>
<a name="23174"><span class="lineNum">   23174 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23175"><span class="lineNum">   23175 </span><span class="lineNoCov">          0 :     case V_SgLessThanOp:</span></a>
<a name="23176"><span class="lineNum">   23176 </span><span class="lineNoCov">          0 :       inclusive = !lhs_it;</span></a>
<a name="23177"><span class="lineNum">   23177 </span><span class="lineNoCov">          0 :       reversed = !lhs_it;</span></a>
<a name="23178"><span class="lineNum">   23178 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23179"><span class="lineNum">   23179 </span><span class="lineNoCov">          0 :     case V_SgEqualityOp:</span></a>
<a name="23180"><span class="lineNum">   23180 </span><span class="lineNoCov">          0 :     case V_SgNotEqualOp:</span></a>
<a name="23181"><span class="lineNum">   23181 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="23182"><span class="lineNum">   23182 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="23183"><span class="lineNum">   23183 </span>            :   }</a>
<a name="23184"><span class="lineNum">   23184 </span>            : </a>
<a name="23185"><span class="lineNum">   23185 </span><span class="lineNoCov">          0 :   SgExpression * increment = for_loop-&gt;get_increment();</span></a>
<a name="23186"><span class="lineNum">   23186 </span><span class="lineNoCov">          0 :   switch (increment-&gt;variantT()) {</span></a>
<a name="23187"><span class="lineNum">   23187 </span><span class="lineNoCov">          0 :     case V_SgPlusPlusOp:</span></a>
<a name="23188"><span class="lineNum">   23188 </span><span class="lineNoCov">          0 :       assert(!reversed);</span></a>
<a name="23189"><span class="lineNum">   23189 </span><span class="lineNoCov">          0 :       stride = SageBuilder::buildIntVal(1);</span></a>
<a name="23190"><span class="lineNum">   23190 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23191"><span class="lineNum">   23191 </span><span class="lineNoCov">          0 :     case V_SgMinusMinusOp:</span></a>
<a name="23192"><span class="lineNum">   23192 </span><span class="lineNoCov">          0 :       assert(reversed);</span></a>
<a name="23193"><span class="lineNum">   23193 </span><span class="lineNoCov">          0 :       stride = SageBuilder::buildIntVal(-1);</span></a>
<a name="23194"><span class="lineNum">   23194 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23195"><span class="lineNum">   23195 </span><span class="lineNoCov">          0 :     case V_SgPlusAssignOp:</span></a>
<a name="23196"><span class="lineNum">   23196 </span><span class="lineNoCov">          0 :     {</span></a>
<a name="23197"><span class="lineNum">   23197 </span><span class="lineNoCov">          0 :       SgBinaryOp * bin_op = (SgBinaryOp *)increment;</span></a>
<a name="23198"><span class="lineNum">   23198 </span>            : #ifndef NDEBUG</a>
<a name="23199"><span class="lineNum">   23199 </span><span class="lineNoCov">          0 :       SgVarRefExp * var_ref_lhs = isSgVarRefExp(bin_op-&gt;get_lhs_operand_i());</span></a>
<a name="23200"><span class="lineNum">   23200 </span><span class="lineNoCov">          0 :       assert(var_ref_lhs != NULL &amp;&amp; var_ref_lhs-&gt;get_symbol() == iterator);</span></a>
<a name="23201"><span class="lineNum">   23201 </span>            : #endif</a>
<a name="23202"><span class="lineNum">   23202 </span><span class="lineNoCov">          0 :       stride = bin_op-&gt;get_rhs_operand_i();</span></a>
<a name="23203"><span class="lineNum">   23203 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23204"><span class="lineNum">   23204 </span>            :     }</a>
<a name="23205"><span class="lineNum">   23205 </span><span class="lineNoCov">          0 :     case V_SgMinusAssignOp:</span></a>
<a name="23206"><span class="lineNum">   23206 </span><span class="lineNoCov">          0 :     {</span></a>
<a name="23207"><span class="lineNum">   23207 </span><span class="lineNoCov">          0 :       SgBinaryOp * bin_op = (SgBinaryOp *)increment;</span></a>
<a name="23208"><span class="lineNum">   23208 </span>            : #ifndef NDEBUG</a>
<a name="23209"><span class="lineNum">   23209 </span><span class="lineNoCov">          0 :       SgVarRefExp * var_ref_lhs = isSgVarRefExp(bin_op-&gt;get_lhs_operand_i());</span></a>
<a name="23210"><span class="lineNum">   23210 </span><span class="lineNoCov">          0 :       assert(var_ref_lhs != NULL &amp;&amp; var_ref_lhs-&gt;get_symbol() == iterator);</span></a>
<a name="23211"><span class="lineNum">   23211 </span>            : #endif</a>
<a name="23212"><span class="lineNum">   23212 </span><span class="lineNoCov">          0 :       stride = bin_op-&gt;get_rhs_operand_i();</span></a>
<a name="23213"><span class="lineNum">   23213 </span><span class="lineNoCov">          0 :       break;</span></a>
<a name="23214"><span class="lineNum">   23214 </span>            :     }</a>
<a name="23215"><span class="lineNum">   23215 </span><span class="lineNoCov">          0 :     case V_SgAssignOp:</span></a>
<a name="23216"><span class="lineNum">   23216 </span><span class="lineNoCov">          0 :     {</span></a>
<a name="23217"><span class="lineNum">   23217 </span><span class="lineNoCov">          0 :       SgAssignOp * assign_op = (SgAssignOp *)increment;</span></a>
<a name="23218"><span class="lineNum">   23218 </span>            : #ifndef NDEBUG</a>
<a name="23219"><span class="lineNum">   23219 </span><span class="lineNoCov">          0 :       SgVarRefExp * inc_assign_lhs = isSgVarRefExp(assign_op-&gt;get_lhs_operand_i());</span></a>
<a name="23220"><span class="lineNum">   23220 </span><span class="lineNoCov">          0 :       assert(inc_assign_lhs != NULL &amp;&amp; inc_assign_lhs-&gt;get_symbol() == iterator);</span></a>
<a name="23221"><span class="lineNum">   23221 </span>            : #endif</a>
<a name="23222"><span class="lineNum">   23222 </span><span class="lineNoCov">          0 :       SgBinaryOp * inc_assign_rhs = isSgBinaryOp(assign_op-&gt;get_rhs_operand_i());</span></a>
<a name="23223"><span class="lineNum">   23223 </span><span class="lineNoCov">          0 :       assert(inc_assign_rhs != NULL);</span></a>
<a name="23224"><span class="lineNum">   23224 </span><span class="lineNoCov">          0 :       SgVarRefExp * inc_assign_rhs_lhs = isSgVarRefExp(inc_assign_rhs-&gt;get_lhs_operand_i());</span></a>
<a name="23225"><span class="lineNum">   23225 </span><span class="lineNoCov">          0 :       if (inc_assign_rhs_lhs != NULL &amp;&amp; inc_assign_rhs_lhs-&gt;get_symbol() == iterator)</span></a>
<a name="23226"><span class="lineNum">   23226 </span><span class="lineNoCov">          0 :         stride = inc_assign_rhs-&gt;get_rhs_operand_i();</span></a>
<a name="23227"><span class="lineNum">   23227 </span><span class="lineNoCov">          0 :       SgVarRefExp * inc_assign_rhs_rhs = isSgVarRefExp(inc_assign_rhs-&gt;get_rhs_operand_i());</span></a>
<a name="23228"><span class="lineNum">   23228 </span><span class="lineNoCov">          0 :       if (inc_assign_rhs_rhs != NULL &amp;&amp; inc_assign_rhs_rhs-&gt;get_symbol() == iterator)</span></a>
<a name="23229"><span class="lineNum">   23229 </span><span class="lineNoCov">          0 :         stride = inc_assign_rhs-&gt;get_lhs_operand_i();</span></a>
<a name="23230"><span class="lineNum">   23230 </span>            :       break;</a>
<a name="23231"><span class="lineNum">   23231 </span>            :     }</a>
<a name="23232"><span class="lineNum">   23232 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="23233"><span class="lineNum">   23233 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="23234"><span class="lineNum">   23234 </span>            :   }</a>
<a name="23235"><span class="lineNum">   23235 </span>            : </a>
<a name="23236"><span class="lineNum">   23236 </span>            :   // DQ (7/19/2015): Added braces to avoid compiler warning about ambigious &quot;else&quot; case.</a>
<a name="23237"><span class="lineNum">   23237 </span><span class="lineNoCov">          0 :      if (!inclusive)</span></a>
<a name="23238"><span class="lineNum">   23238 </span>            :         {</a>
<a name="23239"><span class="lineNum">   23239 </span><span class="lineNoCov">          0 :           if (reversed)</span></a>
<a name="23240"><span class="lineNum">   23240 </span><span class="lineNoCov">          0 :                upper_bound = SageBuilder::buildAddOp(upper_bound, SageBuilder::buildIntVal(1));</span></a>
<a name="23241"><span class="lineNum">   23241 </span>            :             else</a>
<a name="23242"><span class="lineNum">   23242 </span><span class="lineNoCov">          0 :                upper_bound = SageBuilder::buildSubtractOp(upper_bound, SageBuilder::buildIntVal(1));</span></a>
<a name="23243"><span class="lineNum">   23243 </span>            :         }</a>
<a name="23244"><span class="lineNum">   23244 </span>            : </a>
<a name="23245"><span class="lineNum">   23245 </span><span class="lineNoCov">          0 :   return true;</span></a>
<a name="23246"><span class="lineNum">   23246 </span>            : }</a>
<a name="23247"><span class="lineNum">   23247 </span>            : </a>
<a name="23248"><span class="lineNum">   23248 </span>            : //! Replace all variable references to an old symbol in a scope to being references to a new symbol.</a>
<a name="23249"><span class="lineNum">   23249 </span>            : // Essentially replace variable a with b.</a>
<a name="23250"><span class="lineNum">   23250 </span><span class="lineNoCov">          0 : void SageInterface::replaceVariableReferences(SgVariableSymbol* old_sym, SgVariableSymbol* new_sym, SgScopeStatement * scope )</span></a>
<a name="23251"><span class="lineNum">   23251 </span>            : {</a>
<a name="23252"><span class="lineNum">   23252 </span><span class="lineNoCov">          0 :   ROSE_ASSERT  (old_sym != NULL);</span></a>
<a name="23253"><span class="lineNum">   23253 </span><span class="lineNoCov">          0 :   ROSE_ASSERT  (new_sym != NULL);</span></a>
<a name="23254"><span class="lineNum">   23254 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (old_sym != new_sym);</span></a>
<a name="23255"><span class="lineNum">   23255 </span><span class="lineNoCov">          0 :   ROSE_ASSERT  (scope != NULL);</span></a>
<a name="23256"><span class="lineNum">   23256 </span>            : </a>
<a name="23257"><span class="lineNum">   23257 </span><span class="lineNoCov">          0 :   Rose_STL_Container&lt;SgNode*&gt; nodeList = NodeQuery::querySubTree(scope, V_SgVarRefExp);</span></a>
<a name="23258"><span class="lineNum">   23258 </span><span class="lineNoCov">          0 :   for (Rose_STL_Container&lt;SgNode *&gt;::iterator i = nodeList.begin(); i != nodeList.end(); i++)</span></a>
<a name="23259"><span class="lineNum">   23259 </span>            :   {</a>
<a name="23260"><span class="lineNum">   23260 </span><span class="lineNoCov">          0 :     SgVarRefExp *vRef = isSgVarRefExp(*i);</span></a>
<a name="23261"><span class="lineNum">   23261 </span><span class="lineNoCov">          0 :     if (vRef-&gt;get_symbol() == old_sym)</span></a>
<a name="23262"><span class="lineNum">   23262 </span><span class="lineNoCov">          0 :       vRef-&gt;set_symbol(new_sym);</span></a>
<a name="23263"><span class="lineNum">   23263 </span>            :   }</a>
<a name="23264"><span class="lineNum">   23264 </span><span class="lineNoCov">          0 : }</span></a>
<a name="23265"><span class="lineNum">   23265 </span>            : </a>
<a name="23266"><span class="lineNum">   23266 </span>            : </a>
<a name="23267"><span class="lineNum">   23267 </span>            : // DQ (11/12/2018): Adding test to avoid issues that we can't test for in the unparsing of header files using the token based unparsing.</a>
<a name="23268"><span class="lineNum">   23268 </span>            : //! If header file unparsing and token-based unparsing are used, then some statements in header files</a>
<a name="23269"><span class="lineNum">   23269 </span>            : //! used with the same name and different include syntax can't be transformed. This is currently because</a>
<a name="23270"><span class="lineNum">   23270 </span>            : //! there is no way to generally test the resulting transformed code generated by ROSE.</a>
<a name="23271"><span class="lineNum">   23271 </span>            : //! NOTE: This is demonstrated by test8 in the unparse headers tests directory.</a>
<a name="23272"><span class="lineNum">   23272 </span>            : bool</a>
<a name="23273"><span class="lineNum">   23273 </span><span class="lineNoCov">          0 : SageInterface::statementCanBeTransformed(SgStatement* stmt)</span></a>
<a name="23274"><span class="lineNum">   23274 </span>            :    {</a>
<a name="23275"><span class="lineNum">   23275 </span><span class="lineNoCov">          0 :      bool result = true;</span></a>
<a name="23276"><span class="lineNum">   23276 </span>            : </a>
<a name="23277"><span class="lineNum">   23277 </span><span class="lineNoCov">          0 :      bool includingSelf = false;</span></a>
<a name="23278"><span class="lineNum">   23278 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = getEnclosingSourceFile(stmt,includingSelf);</span></a>
<a name="23279"><span class="lineNum">   23279 </span>            : </a>
<a name="23280"><span class="lineNum">   23280 </span><span class="lineNoCov">          0 :      if (sourceFile == NULL)</span></a>
<a name="23281"><span class="lineNum">   23281 </span>            :         {</a>
<a name="23282"><span class="lineNum">   23282 </span><span class="lineNoCov">          0 :           printf (&quot;In SageInterface::statementCanBeTransformed(): sourceFile not found \n&quot;);</span></a>
<a name="23283"><span class="lineNum">   23283 </span>            :         }</a>
<a name="23284"><span class="lineNum">   23284 </span>            : </a>
<a name="23285"><span class="lineNum">   23285 </span>            :   // I think we can assert this!</a>
<a name="23286"><span class="lineNum">   23286 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(sourceFile != NULL);</span></a>
<a name="23287"><span class="lineNum">   23287 </span>            : </a>
<a name="23288"><span class="lineNum">   23288 </span><span class="lineNoCov">          0 :      if (sourceFile != NULL &amp;&amp; sourceFile-&gt;get_unparse_tokens() == true &amp;&amp; sourceFile-&gt;get_unparseHeaderFiles() == true)</span></a>
<a name="23289"><span class="lineNum">   23289 </span>            :         {</a>
<a name="23290"><span class="lineNum">   23290 </span>            :        // Need to look up the source file name, find the SgIncludeFile, and check if statements from this file can be transformed.</a>
<a name="23291"><span class="lineNum">   23291 </span>            :        // There could be at least one other file is this is a header file that was included twice, but it should have a different path.</a>
<a name="23292"><span class="lineNum">   23292 </span><span class="lineNoCov">          0 :           string source_filename = stmt-&gt;getFilenameString();</span></a>
<a name="23293"><span class="lineNum">   23293 </span>            : #if 0</a>
<a name="23294"><span class="lineNum">   23294 </span>            :           printf (&quot;In SageInterface::statementCanBeTransformed(): source_filename = %s \n&quot;,source_filename.c_str());</a>
<a name="23295"><span class="lineNum">   23295 </span>            :           printf (&quot; --- Rose::includeFileMapForUnparsing.size()                   = %zu \n&quot;,Rose::includeFileMapForUnparsing.size());</a>
<a name="23296"><span class="lineNum">   23296 </span>            : #endif</a>
<a name="23297"><span class="lineNum">   23297 </span>            : </a>
<a name="23298"><span class="lineNum">   23298 </span>            :        // DQ (11/5/2019): Using the edg_include_file_map instead (constructed in EDG/ROSE translation).</a>
<a name="23299"><span class="lineNum">   23299 </span>            :        // if (Rose::includeFileMapForUnparsing.find(source_filename) != Rose::includeFileMapForUnparsing.end())</a>
<a name="23300"><span class="lineNum">   23300 </span><span class="lineNoCov">          0 :           if (EDG_ROSE_Translation::edg_include_file_map.find(source_filename) != EDG_ROSE_Translation::edg_include_file_map.end())</span></a>
<a name="23301"><span class="lineNum">   23301 </span>            :              {</a>
<a name="23302"><span class="lineNum">   23302 </span>            :             // SgIncludeFile* include_file = Rose::includeFileMapForUnparsing[source_filename];</a>
<a name="23303"><span class="lineNum">   23303 </span><span class="lineNoCov">          0 :                SgIncludeFile* include_file = EDG_ROSE_Translation::edg_include_file_map[source_filename];</span></a>
<a name="23304"><span class="lineNum">   23304 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(include_file != NULL);</span></a>
<a name="23305"><span class="lineNum">   23305 </span>            : #if 0</a>
<a name="23306"><span class="lineNum">   23306 </span>            :                printf (&quot;include_file-&gt;get_can_be_supported_using_token_based_unparsing() = %s \n&quot;,include_file-&gt;get_can_be_supported_using_token_based_unparsing() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="23307"><span class="lineNum">   23307 </span>            : #endif</a>
<a name="23308"><span class="lineNum">   23308 </span><span class="lineNoCov">          0 :                if (include_file-&gt;get_can_be_supported_using_token_based_unparsing() == false)</span></a>
<a name="23309"><span class="lineNum">   23309 </span>            :                   {</a>
<a name="23310"><span class="lineNum">   23310 </span>            : #if 0</a>
<a name="23311"><span class="lineNum">   23311 </span>            :                     printf (&quot;NOTE: Transformations of this statement cannot be supported using the header file unparsing with token unparsing options! \n&quot;);</a>
<a name="23312"><span class="lineNum">   23312 </span>            : #endif</a>
<a name="23313"><span class="lineNum">   23313 </span><span class="lineNoCov">          0 :                     result = false;</span></a>
<a name="23314"><span class="lineNum">   23314 </span>            :                   }</a>
<a name="23315"><span class="lineNum">   23315 </span>            :              }</a>
<a name="23316"><span class="lineNum">   23316 </span>            :             else</a>
<a name="23317"><span class="lineNum">   23317 </span>            :              {</a>
<a name="23318"><span class="lineNum">   23318 </span>            : #if 1</a>
<a name="23319"><span class="lineNum">   23319 </span><span class="lineNoCov">          0 :                printf (&quot;Not found in Rose::includeFileMapForUnparsing: source_filename = %s \n&quot;,source_filename.c_str());</span></a>
<a name="23320"><span class="lineNum">   23320 </span>            : #endif</a>
<a name="23321"><span class="lineNum">   23321 </span>            : #if 1</a>
<a name="23322"><span class="lineNum">   23322 </span><span class="lineNoCov">          0 :                printf (&quot;Exiting as a test! \n&quot;);</span></a>
<a name="23323"><span class="lineNum">   23323 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="23324"><span class="lineNum">   23324 </span>            : #endif</a>
<a name="23325"><span class="lineNum">   23325 </span>            :              }</a>
<a name="23326"><span class="lineNum">   23326 </span>            : </a>
<a name="23327"><span class="lineNum">   23327 </span>            : #if 0</a>
<a name="23328"><span class="lineNum">   23328 </span>            :           printf (&quot;Error: In statementCanBeTransformed(): this might be an issue! \n&quot;);</a>
<a name="23329"><span class="lineNum">   23329 </span>            :           ROSE_ABORT();</a>
<a name="23330"><span class="lineNum">   23330 </span>            : #endif</a>
<a name="23331"><span class="lineNum">   23331 </span>            :         }</a>
<a name="23332"><span class="lineNum">   23332 </span>            : </a>
<a name="23333"><span class="lineNum">   23333 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="23334"><span class="lineNum">   23334 </span>            :    }</a>
<a name="23335"><span class="lineNum">   23335 </span>            : </a>
<a name="23336"><span class="lineNum">   23336 </span>            : </a>
<a name="23337"><span class="lineNum">   23337 </span>            : //Note: this function is no longer used by decl move tool: we use copy and insert instead to support moving to multiple scopes</a>
<a name="23338"><span class="lineNum">   23338 </span>            : //! Move a variable declaration from its original scope to a new scope, assuming original scope != target_scope</a>
<a name="23339"><span class="lineNum">   23339 </span><span class="lineCov">          1 : void SageInterface::moveVariableDeclaration(SgVariableDeclaration* decl, SgScopeStatement* target_scope)</span></a>
<a name="23340"><span class="lineNum">   23340 </span>            : {</a>
<a name="23341"><span class="lineNum">   23341 </span><span class="lineCov">          1 :   ROSE_ASSERT (decl!= NULL);</span></a>
<a name="23342"><span class="lineNum">   23342 </span><span class="lineCov">          1 :   ROSE_ASSERT (target_scope != NULL);</span></a>
<a name="23343"><span class="lineNum">   23343 </span><span class="lineCov">          1 :   ROSE_ASSERT (target_scope != decl-&gt;get_scope());</span></a>
<a name="23344"><span class="lineNum">   23344 </span>            : </a>
<a name="23345"><span class="lineNum">   23345 </span>            : #if 0 // at this stage, we focus on legal move only, any scope adjustment should be done earlier!</a>
<a name="23346"><span class="lineNum">   23346 </span>            :   // Special handling for If-Stmt, may need to climb up one level of scope when:</a>
<a name="23347"><span class="lineNum">   23347 </span>            :   // two bodies of if uses the same variable, but cannot be pushed down into each body.</a>
<a name="23348"><span class="lineNum">   23348 </span>            :   // If-stmt will be the innermost common scope for the variable.</a>
<a name="23349"><span class="lineNum">   23349 </span>            :   // But we should not move the declaration to if-stmt. We can only move it to the parent scope of if-stmt.</a>
<a name="23350"><span class="lineNum">   23350 </span>            :   if (isSgIfStmt (target_scope))</a>
<a name="23351"><span class="lineNum">   23351 </span>            :   {</a>
<a name="23352"><span class="lineNum">   23352 </span>            :     target_scope = SageInterface::getEnclosingScope (target_scope, false);</a>
<a name="23353"><span class="lineNum">   23353 </span>            :     if (target_scope == )</a>
<a name="23354"><span class="lineNum">   23354 </span>            :   }</a>
<a name="23355"><span class="lineNum">   23355 </span>            : # endif</a>
<a name="23356"><span class="lineNum">   23356 </span>            : </a>
<a name="23357"><span class="lineNum">   23357 </span>            :   // Move the declaration</a>
<a name="23358"><span class="lineNum">   23358 </span>            :   //TODO: consider another way: copy the declaration, insert the copy, replace varRefExp, and remove (delete) the original declaration</a>
<a name="23359"><span class="lineNum">   23359 </span><span class="lineCov">          1 :   SageInterface::removeStatement(decl);</span></a>
<a name="23360"><span class="lineNum">   23360 </span>            : </a>
<a name="23361"><span class="lineNum">   23361 </span><span class="lineCov">          1 :   switch (target_scope-&gt;variantT())</span></a>
<a name="23362"><span class="lineNum">   23362 </span>            :   {</a>
<a name="23363"><span class="lineNum">   23363 </span><span class="lineNoCov">          0 :     case V_SgBasicBlock:</span></a>
<a name="23364"><span class="lineNum">   23364 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="23365"><span class="lineNum">   23365 </span><span class="lineNoCov">          0 :         SageInterface::prependStatement (decl, target_scope);</span></a>
<a name="23366"><span class="lineNum">   23366 </span><span class="lineNoCov">          0 :         break;</span></a>
<a name="23367"><span class="lineNum">   23367 </span>            :       }</a>
<a name="23368"><span class="lineNum">   23368 </span>            : #if 0 // this check should be done earlier before any side effects can happen</a>
<a name="23369"><span class="lineNum">   23369 </span>            :     case V_SgIfStmt:</a>
<a name="23370"><span class="lineNum">   23370 </span>            :     {</a>
<a name="23371"><span class="lineNum">   23371 </span>            :        // adjust to parent scope of if-stmt</a>
<a name="23372"><span class="lineNum">   23372 </span>            :        break;</a>
<a name="23373"><span class="lineNum">   23373 </span>            :     }</a>
<a name="23374"><span class="lineNum">   23374 </span>            : #endif</a>
<a name="23375"><span class="lineNum">   23375 </span><span class="lineCov">          1 :     case V_SgForStatement:</span></a>
<a name="23376"><span class="lineNum">   23376 </span><span class="lineCov">          1 :       {</span></a>
<a name="23377"><span class="lineNum">   23377 </span>            :         // we move int i; to be for (int i=0; ...);</a>
<a name="23378"><span class="lineNum">   23378 </span><span class="lineCov">          1 :         SgForStatement* stmt = isSgForStatement (target_scope);</span></a>
<a name="23379"><span class="lineNum">   23379 </span><span class="lineCov">          1 :         ROSE_ASSERT(stmt != NULL);</span></a>
<a name="23380"><span class="lineNum">   23380 </span><span class="lineCov">          1 :         SgStatementPtrList&amp; stmt_list = stmt-&gt;get_init_stmt();</span></a>
<a name="23381"><span class="lineNum">   23381 </span>            :         // Try to match a pattern like for (i=0; ...) here</a>
<a name="23382"><span class="lineNum">   23382 </span>            :         // assuming there is only one assignment like i=0</a>
<a name="23383"><span class="lineNum">   23383 </span>            :         // We don't yet handle more complex cases</a>
<a name="23384"><span class="lineNum">   23384 </span><span class="lineCov">          1 :         if (stmt_list.size() !=1)</span></a>
<a name="23385"><span class="lineNum">   23385 </span>            :         {</a>
<a name="23386"><span class="lineNum">   23386 </span><span class="lineNoCov">          0 :           cerr&lt;&lt;&quot;Error in moveVariableDeclaration(): only single init statement is handled for SgForStatement now.&quot;&lt;&lt;endl;</span></a>
<a name="23387"><span class="lineNum">   23387 </span><span class="lineNoCov">          0 :           ROSE_ASSERT (stmt_list.size() ==1);</span></a>
<a name="23388"><span class="lineNum">   23388 </span>            :         }</a>
<a name="23389"><span class="lineNum">   23389 </span><span class="lineCov">          1 :         SgExprStatement* exp_stmt = isSgExprStatement(stmt_list[0]);</span></a>
<a name="23390"><span class="lineNum">   23390 </span><span class="lineCov">          1 :         ROSE_ASSERT (exp_stmt != NULL);</span></a>
<a name="23391"><span class="lineNum">   23391 </span><span class="lineCov">          1 :         SgAssignOp* assign_op = isSgAssignOp(exp_stmt-&gt;get_expression());</span></a>
<a name="23392"><span class="lineNum">   23392 </span><span class="lineCov">          1 :         ROSE_ASSERT (assign_op != NULL);</span></a>
<a name="23393"><span class="lineNum">   23393 </span>            : </a>
<a name="23394"><span class="lineNum">   23394 </span>            :         // remove the existing i=0; preserve its right hand operand</a>
<a name="23395"><span class="lineNum">   23395 </span><span class="lineCov">          1 :         SgExpression * rhs = SageInterface::copyExpression(assign_op-&gt;get_rhs_operand());</span></a>
<a name="23396"><span class="lineNum">   23396 </span><span class="lineCov">          1 :         stmt_list.clear();</span></a>
<a name="23397"><span class="lineNum">   23397 </span><span class="lineCov">          1 :         SageInterface::deepDelete (exp_stmt);</span></a>
<a name="23398"><span class="lineNum">   23398 </span>            : </a>
<a name="23399"><span class="lineNum">   23399 </span>            :         // modify the decl's rhs to be the new one</a>
<a name="23400"><span class="lineNum">   23400 </span><span class="lineCov">          1 :         SgInitializedName * init_name = SageInterface::getFirstInitializedName (decl);</span></a>
<a name="23401"><span class="lineNum">   23401 </span><span class="lineCov">          1 :         SgAssignInitializer * initor = SageBuilder::buildAssignInitializer (rhs);</span></a>
<a name="23402"><span class="lineNum">   23402 </span><span class="lineCov">          1 :         if (init_name-&gt;get_initptr() != NULL)</span></a>
<a name="23403"><span class="lineNum">   23403 </span><span class="lineNoCov">          0 :           SageInterface::deepDelete (init_name-&gt;get_initptr());</span></a>
<a name="23404"><span class="lineNum">   23404 </span><span class="lineCov">          1 :         init_name-&gt;set_initptr(initor);</span></a>
<a name="23405"><span class="lineNum">   23405 </span><span class="lineCov">          1 :         initor-&gt;set_parent(init_name);</span></a>
<a name="23406"><span class="lineNum">   23406 </span>            : </a>
<a name="23407"><span class="lineNum">   23407 </span><span class="lineCov">          1 :         stmt_list.insert (stmt_list.begin(),  decl );</span></a>
<a name="23408"><span class="lineNum">   23408 </span><span class="lineCov">          1 :         break;</span></a>
<a name="23409"><span class="lineNum">   23409 </span>            :       }</a>
<a name="23410"><span class="lineNum">   23410 </span>            : </a>
<a name="23411"><span class="lineNum">   23411 </span><span class="lineNoCov">          0 :     default:</span></a>
<a name="23412"><span class="lineNum">   23412 </span><span class="lineNoCov">          0 :       {</span></a>
<a name="23413"><span class="lineNum">   23413 </span><span class="lineNoCov">          0 :         cerr&lt;&lt;&quot;Error. Unhandled target scope type:&quot;&lt;&lt;target_scope-&gt;class_name()&lt;&lt;endl;</span></a>
<a name="23414"><span class="lineNum">   23414 </span><span class="lineNoCov">          0 :         ROSE_ASSERT  (false);</span></a>
<a name="23415"><span class="lineNum">   23415 </span>            :       }</a>
<a name="23416"><span class="lineNum">   23416 </span>            :   }</a>
<a name="23417"><span class="lineNum">   23417 </span>            : </a>
<a name="23418"><span class="lineNum">   23418 </span>            :   //make sure the symbol is moved also since prependStatement() (in fact fixVariableDeclaration()) does not handle this detail.</a>
<a name="23419"><span class="lineNum">   23419 </span><span class="lineCov">          1 :   SgVariableSymbol* sym = SageInterface::getFirstVarSym(decl);</span></a>
<a name="23420"><span class="lineNum">   23420 </span><span class="lineCov">          1 :   ROSE_ASSERT(sym != NULL);</span></a>
<a name="23421"><span class="lineNum">   23421 </span><span class="lineCov">          1 :   SgScopeStatement* orig_scope = sym-&gt;get_scope();</span></a>
<a name="23422"><span class="lineNum">   23422 </span><span class="lineCov">          1 :   if (orig_scope != target_scope)</span></a>
<a name="23423"><span class="lineNum">   23423 </span>            :   {</a>
<a name="23424"><span class="lineNum">   23424 </span>            :     // SageInterface::fixVariableDeclaration() cannot switch the scope for init name.</a>
<a name="23425"><span class="lineNum">   23425 </span>            :     // it somehow always reuses previously associated scope.</a>
<a name="23426"><span class="lineNum">   23426 </span><span class="lineCov">          1 :     SgInitializedName* init_name = SageInterface::getFirstInitializedName (decl);</span></a>
<a name="23427"><span class="lineNum">   23427 </span><span class="lineCov">          1 :     init_name-&gt;set_scope(target_scope);</span></a>
<a name="23428"><span class="lineNum">   23428 </span><span class="lineCov">          2 :     SgName sname = sym-&gt;get_name();</span></a>
<a name="23429"><span class="lineNum">   23429 </span><span class="lineCov">          1 :     orig_scope-&gt;remove_symbol(sym);</span></a>
<a name="23430"><span class="lineNum">   23430 </span><span class="lineCov">          1 :     target_scope-&gt;insert_symbol(sname, sym);</span></a>
<a name="23431"><span class="lineNum">   23431 </span>            :   }</a>
<a name="23432"><span class="lineNum">   23432 </span>            :   // This is difficult since C++ variables have namespaces</a>
<a name="23433"><span class="lineNum">   23433 </span>            :   // Details are in SageInterface::fixVariableDeclaration()</a>
<a name="23434"><span class="lineNum">   23434 </span><span class="lineCov">          1 :   ROSE_ASSERT (target_scope-&gt;symbol_exists(sym));</span></a>
<a name="23435"><span class="lineNum">   23435 </span><span class="lineCov">          1 : }</span></a>
<a name="23436"><span class="lineNum">   23436 </span>            : </a>
<a name="23437"><span class="lineNum">   23437 </span><span class="lineNoCov">          0 : class SimpleExpressionEvaluator: public AstBottomUpProcessing &lt;struct SageInterface::const_int_expr_t&gt; {</span></a>
<a name="23438"><span class="lineNum">   23438 </span>            :  public:</a>
<a name="23439"><span class="lineNum">   23439 </span><span class="lineCov">        264 :    SimpleExpressionEvaluator() {</span></a>
<a name="23440"><span class="lineNum">   23440 </span>            :    }</a>
<a name="23441"><span class="lineNum">   23441 </span>            : </a>
<a name="23442"><span class="lineNum">   23442 </span><span class="lineCov">        132 :  struct SageInterface::const_int_expr_t getValueExpressionValue(SgValueExp *valExp) {</span></a>
<a name="23443"><span class="lineNum">   23443 </span><span class="lineCov">        132 :    struct SageInterface::const_int_expr_t subtreeVal;</span></a>
<a name="23444"><span class="lineNum">   23444 </span><span class="lineCov">        132 :    subtreeVal.hasValue_ = true;</span></a>
<a name="23445"><span class="lineNum">   23445 </span>            : </a>
<a name="23446"><span class="lineNum">   23446 </span><span class="lineCov">        132 :    if (isSgIntVal(valExp)) {</span></a>
<a name="23447"><span class="lineNum">   23447 </span><span class="lineNoCov">          0 :      subtreeVal.value_ = isSgIntVal(valExp)-&gt;get_value();</span></a>
<a name="23448"><span class="lineNum">   23448 </span><span class="lineCov">        132 :    } else if (isSgLongIntVal(valExp)) {</span></a>
<a name="23449"><span class="lineNum">   23449 </span><span class="lineCov">         13 :      subtreeVal.value_ = isSgLongIntVal(valExp)-&gt;get_value();</span></a>
<a name="23450"><span class="lineNum">   23450 </span><span class="lineCov">        119 :    } else if (isSgLongLongIntVal(valExp)) {</span></a>
<a name="23451"><span class="lineNum">   23451 </span><span class="lineNoCov">          0 :      subtreeVal.value_ = isSgLongLongIntVal(valExp)-&gt;get_value();</span></a>
<a name="23452"><span class="lineNum">   23452 </span><span class="lineCov">        119 :    } else if (isSgShortVal(valExp)) {</span></a>
<a name="23453"><span class="lineNum">   23453 </span><span class="lineNoCov">          0 :      subtreeVal.value_ = isSgShortVal(valExp)-&gt;get_value();</span></a>
<a name="23454"><span class="lineNum">   23454 </span><span class="lineCov">        119 :    } else if (isSgUnsignedIntVal(valExp)) {</span></a>
<a name="23455"><span class="lineNum">   23455 </span><span class="lineCov">          8 :      subtreeVal.value_ = isSgUnsignedIntVal(valExp)-&gt;get_value();</span></a>
<a name="23456"><span class="lineNum">   23456 </span><span class="lineCov">        111 :    } else if (isSgUnsignedLongVal(valExp)) {</span></a>
<a name="23457"><span class="lineNum">   23457 </span><span class="lineCov">         24 :      subtreeVal.value_ = isSgUnsignedLongVal(valExp)-&gt;get_value();</span></a>
<a name="23458"><span class="lineNum">   23458 </span><span class="lineCov">         87 :    } else if (isSgUnsignedLongLongIntVal(valExp)) {</span></a>
<a name="23459"><span class="lineNum">   23459 </span><span class="lineNoCov">          0 :      subtreeVal.value_ = isSgUnsignedLongLongIntVal(valExp)-&gt;get_value();</span></a>
<a name="23460"><span class="lineNum">   23460 </span><span class="lineCov">         87 :    } else if (isSgUnsignedShortVal(valExp)) {</span></a>
<a name="23461"><span class="lineNum">   23461 </span><span class="lineNoCov">          0 :      subtreeVal.value_ = isSgUnsignedShortVal(valExp)-&gt;get_value();</span></a>
<a name="23462"><span class="lineNum">   23462 </span>            :    }</a>
<a name="23463"><span class="lineNum">   23463 </span><span class="lineCov">        132 :    return subtreeVal;</span></a>
<a name="23464"><span class="lineNum">   23464 </span>            :  }</a>
<a name="23465"><span class="lineNum">   23465 </span>            : </a>
<a name="23466"><span class="lineNum">   23466 </span><span class="lineNoCov">          0 :  struct SageInterface::const_int_expr_t evaluateVariableReference(SgVarRefExp *vRef) {</span></a>
<a name="23467"><span class="lineNum">   23467 </span><span class="lineNoCov">          0 :    if (isSgModifierType(vRef-&gt;get_type()) == NULL) {</span></a>
<a name="23468"><span class="lineNum">   23468 </span><span class="lineNoCov">          0 :      struct SageInterface::const_int_expr_t val;</span></a>
<a name="23469"><span class="lineNum">   23469 </span><span class="lineNoCov">          0 :      val.value_ = -1;</span></a>
<a name="23470"><span class="lineNum">   23470 </span><span class="lineNoCov">          0 :      val.hasValue_ = false;</span></a>
<a name="23471"><span class="lineNum">   23471 </span><span class="lineNoCov">          0 :      return val;</span></a>
<a name="23472"><span class="lineNum">   23472 </span>            :    }</a>
<a name="23473"><span class="lineNum">   23473 </span><span class="lineNoCov">          0 :    if (isSgModifierType(vRef-&gt;get_type())-&gt;get_typeModifier().get_constVolatileModifier().isConst()) {</span></a>
<a name="23474"><span class="lineNum">   23474 </span>            :      // We know that the var value is const, so get the initialized name and evaluate it</a>
<a name="23475"><span class="lineNum">   23475 </span><span class="lineNoCov">          0 :      SgVariableSymbol *sym = vRef-&gt;get_symbol();</span></a>
<a name="23476"><span class="lineNum">   23476 </span><span class="lineNoCov">          0 :      SgInitializedName *iName = sym-&gt;get_declaration();</span></a>
<a name="23477"><span class="lineNum">   23477 </span><span class="lineNoCov">          0 :      SgInitializer *ini = iName-&gt;get_initializer();</span></a>
<a name="23478"><span class="lineNum">   23478 </span>            : </a>
<a name="23479"><span class="lineNum">   23479 </span><span class="lineNoCov">          0 :      if (isSgAssignInitializer(ini)) {</span></a>
<a name="23480"><span class="lineNum">   23480 </span><span class="lineNoCov">          0 :        SgAssignInitializer *initializer = isSgAssignInitializer(ini);</span></a>
<a name="23481"><span class="lineNum">   23481 </span><span class="lineNoCov">          0 :        SgExpression *rhs = initializer-&gt;get_operand();</span></a>
<a name="23482"><span class="lineNum">   23482 </span><span class="lineNoCov">          0 :        SimpleExpressionEvaluator variableEval;</span></a>
<a name="23483"><span class="lineNum">   23483 </span>            : </a>
<a name="23484"><span class="lineNum">   23484 </span><span class="lineNoCov">          0 :        return variableEval.traverse(rhs);</span></a>
<a name="23485"><span class="lineNum">   23485 </span>            :      }</a>
<a name="23486"><span class="lineNum">   23486 </span>            :    }</a>
<a name="23487"><span class="lineNum">   23487 </span><span class="lineNoCov">          0 :    struct SageInterface::const_int_expr_t val;</span></a>
<a name="23488"><span class="lineNum">   23488 </span><span class="lineNoCov">          0 :    val.hasValue_ = false;</span></a>
<a name="23489"><span class="lineNum">   23489 </span><span class="lineNoCov">          0 :    val.value_ = -1;</span></a>
<a name="23490"><span class="lineNum">   23490 </span><span class="lineNoCov">          0 :    return val;</span></a>
<a name="23491"><span class="lineNum">   23491 </span>            :  }</a>
<a name="23492"><span class="lineNum">   23492 </span>            : </a>
<a name="23493"><span class="lineNum">   23493 </span><span class="lineCov">        132 :  struct SageInterface::const_int_expr_t evaluateSynthesizedAttribute(SgNode *node, SynthesizedAttributesList synList) {</span></a>
<a name="23494"><span class="lineNum">   23494 </span><span class="lineCov">        132 :    if (isSgExpression(node) != NULL) {</span></a>
<a name="23495"><span class="lineNum">   23495 </span><span class="lineCov">        132 :      SgValueExp* valueExp = isSgValueExp(node);</span></a>
<a name="23496"><span class="lineNum">   23496 </span><span class="lineCov">        132 :      if (valueExp != NULL) {</span></a>
<a name="23497"><span class="lineNum">   23497 </span><span class="lineCov">        132 :        return this-&gt;getValueExpressionValue(valueExp);</span></a>
<a name="23498"><span class="lineNum">   23498 </span>            :      }</a>
<a name="23499"><span class="lineNum">   23499 </span>            : </a>
<a name="23500"><span class="lineNum">   23500 </span><span class="lineNoCov">          0 :      SgVarRefExp* varRefExp = isSgVarRefExp(node);</span></a>
<a name="23501"><span class="lineNum">   23501 </span><span class="lineNoCov">          0 :      if (varRefExp != NULL) {</span></a>
<a name="23502"><span class="lineNum">   23502 </span>            :       //      std::cout &lt;&lt; &quot;Hit variable reference expression!&quot; &lt;&lt; std::endl;</a>
<a name="23503"><span class="lineNum">   23503 </span><span class="lineNoCov">          0 :        return evaluateVariableReference(varRefExp);</span></a>
<a name="23504"><span class="lineNum">   23504 </span>            :      }</a>
<a name="23505"><span class="lineNum">   23505 </span>            :      // Early break out for assign initializer // other possibility?</a>
<a name="23506"><span class="lineNum">   23506 </span><span class="lineNoCov">          0 :      if (isSgAssignInitializer(node)) {</span></a>
<a name="23507"><span class="lineNum">   23507 </span><span class="lineNoCov">          0 :        if(synList.at(0).hasValue_){</span></a>
<a name="23508"><span class="lineNum">   23508 </span><span class="lineNoCov">          0 :          return synList.at(0);</span></a>
<a name="23509"><span class="lineNum">   23509 </span>            :        } else {</a>
<a name="23510"><span class="lineNum">   23510 </span><span class="lineNoCov">          0 :          struct SageInterface::const_int_expr_t val;</span></a>
<a name="23511"><span class="lineNum">   23511 </span><span class="lineNoCov">          0 :          val.value_ = -1;</span></a>
<a name="23512"><span class="lineNum">   23512 </span><span class="lineNoCov">          0 :          val.hasValue_ = false;</span></a>
<a name="23513"><span class="lineNum">   23513 </span><span class="lineNoCov">          0 :          return val;</span></a>
<a name="23514"><span class="lineNum">   23514 </span>            :        }</a>
<a name="23515"><span class="lineNum">   23515 </span>            :      }</a>
<a name="23516"><span class="lineNum">   23516 </span><span class="lineNoCov">          0 :      struct SageInterface::const_int_expr_t evaluatedValue;</span></a>
<a name="23517"><span class="lineNum">   23517 </span><span class="lineNoCov">          0 :      evaluatedValue.hasValue_ = false;</span></a>
<a name="23518"><span class="lineNum">   23518 </span><span class="lineNoCov">          0 :      evaluatedValue.value_ = -1;</span></a>
<a name="23519"><span class="lineNum">   23519 </span>            : #if 0</a>
<a name="23520"><span class="lineNum">   23520 </span>            :     if(synList.size() != 2){</a>
<a name="23521"><span class="lineNum">   23521 </span>            :       for(SynthesizedAttributesList::iterator it = synList.begin(); it != synList.end(); ++it){</a>
<a name="23522"><span class="lineNum">   23522 </span>            :         std::cout &lt;&lt; &quot;Node: &quot; &lt;&lt; node-&gt;unparseToString() &lt;&lt; &quot;\n&quot; &lt;&lt; (*it).value_ &lt;&lt; std::endl;</a>
<a name="23523"><span class="lineNum">   23523 </span>            :         std::cout &lt;&lt; &quot;Parent: &quot; &lt;&lt; node-&gt;get_parent()-&gt;unparseToString() &lt;&lt; std::endl;</a>
<a name="23524"><span class="lineNum">   23524 </span>            :         std::cout &lt;&lt; &quot;Parent, Parent: &quot; &lt;&lt; node-&gt;get_parent()-&gt;get_parent()-&gt;unparseToString() &lt;&lt; std::endl;</a>
<a name="23525"><span class="lineNum">   23525 </span>            :       }</a>
<a name="23526"><span class="lineNum">   23526 </span>            :     }</a>
<a name="23527"><span class="lineNum">   23527 </span>            : #endif</a>
<a name="23528"><span class="lineNum">   23528 </span><span class="lineNoCov">          0 :      for (SynthesizedAttributesList::iterator it = synList.begin(); it != synList.end(); ++it) {</span></a>
<a name="23529"><span class="lineNum">   23529 </span><span class="lineNoCov">          0 :        if((*it).hasValue_){</span></a>
<a name="23530"><span class="lineNum">   23530 </span><span class="lineNoCov">          0 :          if (isSgAddOp(node)) {</span></a>
<a name="23531"><span class="lineNum">   23531 </span><span class="lineNoCov">          0 :            assert(synList.size() == 2);</span></a>
<a name="23532"><span class="lineNum">   23532 </span><span class="lineNoCov">          0 :            evaluatedValue.value_ = synList[0].value_ + synList[1].value_ ;</span></a>
<a name="23533"><span class="lineNum">   23533 </span><span class="lineNoCov">          0 :            evaluatedValue.hasValue_ = true;</span></a>
<a name="23534"><span class="lineNum">   23534 </span><span class="lineNoCov">          0 :          } else if (isSgSubtractOp(node)) {</span></a>
<a name="23535"><span class="lineNum">   23535 </span><span class="lineNoCov">          0 :            assert(synList.size() == 2);</span></a>
<a name="23536"><span class="lineNum">   23536 </span><span class="lineNoCov">          0 :            evaluatedValue.value_ = synList[0].value_  - synList[1].value_ ;</span></a>
<a name="23537"><span class="lineNum">   23537 </span><span class="lineNoCov">          0 :            evaluatedValue.hasValue_ = true;</span></a>
<a name="23538"><span class="lineNum">   23538 </span><span class="lineNoCov">          0 :          } else if (isSgMultiplyOp(node)) {</span></a>
<a name="23539"><span class="lineNum">   23539 </span><span class="lineNoCov">          0 :            assert(synList.size() == 2);</span></a>
<a name="23540"><span class="lineNum">   23540 </span><span class="lineNoCov">          0 :            evaluatedValue.value_ = synList[0].value_  * synList[1].value_ ;</span></a>
<a name="23541"><span class="lineNum">   23541 </span><span class="lineNoCov">          0 :            evaluatedValue.hasValue_ = true;</span></a>
<a name="23542"><span class="lineNum">   23542 </span><span class="lineNoCov">          0 :          } else if (isSgDivideOp(node)) {</span></a>
<a name="23543"><span class="lineNum">   23543 </span><span class="lineNoCov">          0 :            assert(synList.size() == 2);</span></a>
<a name="23544"><span class="lineNum">   23544 </span><span class="lineNoCov">          0 :            evaluatedValue.value_ = synList[0].value_  / synList[1].value_ ;</span></a>
<a name="23545"><span class="lineNum">   23545 </span><span class="lineNoCov">          0 :            evaluatedValue.hasValue_ = true;</span></a>
<a name="23546"><span class="lineNum">   23546 </span><span class="lineNoCov">          0 :          } else if (isSgModOp(node)) {</span></a>
<a name="23547"><span class="lineNum">   23547 </span><span class="lineNoCov">          0 :            assert(synList.size() == 2);</span></a>
<a name="23548"><span class="lineNum">   23548 </span><span class="lineNoCov">          0 :            evaluatedValue.value_ = synList[0].value_  % synList[1].value_ ;</span></a>
<a name="23549"><span class="lineNum">   23549 </span><span class="lineNoCov">          0 :            evaluatedValue.hasValue_ = true;</span></a>
<a name="23550"><span class="lineNum">   23550 </span>            :          }</a>
<a name="23551"><span class="lineNum">   23551 </span>            :        } else {</a>
<a name="23552"><span class="lineNum">   23552 </span><span class="lineNoCov">          0 :          std::cerr &lt;&lt; &quot;Expression is not evaluatable&quot; &lt;&lt; std::endl;</span></a>
<a name="23553"><span class="lineNum">   23553 </span><span class="lineNoCov">          0 :          evaluatedValue.hasValue_ = false;</span></a>
<a name="23554"><span class="lineNum">   23554 </span><span class="lineNoCov">          0 :          evaluatedValue.value_ = -1;</span></a>
<a name="23555"><span class="lineNum">   23555 </span><span class="lineNoCov">          0 :          return evaluatedValue;</span></a>
<a name="23556"><span class="lineNum">   23556 </span>            :        }</a>
<a name="23557"><span class="lineNum">   23557 </span>            :      }</a>
<a name="23558"><span class="lineNum">   23558 </span><span class="lineNoCov">          0 :      evaluatedValue.hasValue_ = true;</span></a>
<a name="23559"><span class="lineNum">   23559 </span><span class="lineNoCov">          0 :      return evaluatedValue;</span></a>
<a name="23560"><span class="lineNum">   23560 </span>            :    }</a>
<a name="23561"><span class="lineNum">   23561 </span><span class="lineNoCov">          0 :    struct SageInterface::const_int_expr_t evaluatedValue;</span></a>
<a name="23562"><span class="lineNum">   23562 </span><span class="lineNoCov">          0 :    evaluatedValue.hasValue_ = false;</span></a>
<a name="23563"><span class="lineNum">   23563 </span><span class="lineNoCov">          0 :    evaluatedValue.value_ = -1;</span></a>
<a name="23564"><span class="lineNum">   23564 </span><span class="lineNoCov">          0 :    return evaluatedValue;</span></a>
<a name="23565"><span class="lineNum">   23565 </span>            :  }</a>
<a name="23566"><span class="lineNum">   23566 </span>            : };</a>
<a name="23567"><span class="lineNum">   23567 </span>            : </a>
<a name="23568"><span class="lineNum">   23568 </span>            : struct SageInterface::const_int_expr_t</a>
<a name="23569"><span class="lineNum">   23569 </span><span class="lineCov">        132 : SageInterface::evaluateConstIntegerExpression(SgExpression *expr){</span></a>
<a name="23570"><span class="lineNum">   23570 </span><span class="lineCov">        132 :   SimpleExpressionEvaluator eval;</span></a>
<a name="23571"><span class="lineNum">   23571 </span><span class="lineCov">        132 :   return eval.traverse(expr);</span></a>
<a name="23572"><span class="lineNum">   23572 </span>            : }</a>
<a name="23573"><span class="lineNum">   23573 </span>            : </a>
<a name="23574"><span class="lineNum">   23574 </span>            : bool</a>
<a name="23575"><span class="lineNum">   23575 </span><span class="lineCov">          1 : SageInterface::checkTypesAreEqual(SgType *typeA, SgType *typeB){</span></a>
<a name="23576"><span class="lineNum">   23576 </span>            : </a>
<a name="23577"><span class="lineNum">   23577 </span><span class="lineCov">          1 :   class TypeEquivalenceChecker {</span></a>
<a name="23578"><span class="lineNum">   23578 </span>            :     public:</a>
<a name="23579"><span class="lineNum">   23579 </span><span class="lineCov">          1 :      TypeEquivalenceChecker(bool profile, bool useSemanticEquivalence)</span></a>
<a name="23580"><span class="lineNum">   23580 </span><span class="lineCov">          1 :        : profile_(profile), useSemanticEquivalence_(useSemanticEquivalence),</span></a>
<a name="23581"><span class="lineNum">   23581 </span><span class="lineCov">          1 :          namedType_(0), pointerType_(0), arrayType_(0), functionType_(0)</span></a>
<a name="23582"><span class="lineNum">   23582 </span>            :      {</a>
<a name="23583"><span class="lineNum">   23583 </span>            :      }</a>
<a name="23584"><span class="lineNum">   23584 </span>            : </a>
<a name="23585"><span class="lineNum">   23585 </span>            :      SgNode * getBasetypeIfApplicable(SgNode *t){</a>
<a name="23586"><span class="lineNum">   23586 </span>            :        SgNode * node = t;</a>
<a name="23587"><span class="lineNum">   23587 </span>            :        if (isSgTypedefType(t)) {</a>
<a name="23588"><span class="lineNum">   23588 </span>            : //    std::cout &lt;&lt; &quot;This is a typedef nodeT1. We strip everything away and compare the hidden types.&quot; &lt;&lt; std::endl;</a>
<a name="23589"><span class="lineNum">   23589 </span>            :          node = isSgTypedefType(t)-&gt;stripType(SgType::STRIP_TYPEDEF_TYPE);</a>
<a name="23590"><span class="lineNum">   23590 </span>            :      }</a>
<a name="23591"><span class="lineNum">   23591 </span>            :      if(useSemanticEquivalence_){</a>
<a name="23592"><span class="lineNum">   23592 </span>            :        if(isSgModifierType(t)){</a>
<a name="23593"><span class="lineNum">   23593 </span>            :          SgModifierType *modType = isSgModifierType(t);</a>
<a name="23594"><span class="lineNum">   23594 </span>            :          ROSE_ASSERT(modType != NULL);</a>
<a name="23595"><span class="lineNum">   23595 </span>            :          // We need to check for Volatile/Restrict types. These are modelled as ModifierTypes, but are equal (in some cases)</a>
<a name="23596"><span class="lineNum">   23596 </span>            :          // volatile seems to make no difference for basic (built in) types like int, bool etc. But it has an impact on types</a>
<a name="23597"><span class="lineNum">   23597 </span>            :          // like classes</a>
<a name="23598"><span class="lineNum">   23598 </span>            :          // restrict seems to have no impact on the type itself.</a>
<a name="23599"><span class="lineNum">   23599 </span>            :          if(SageInterface::isVolatileType(modType)){</a>
<a name="23600"><span class="lineNum">   23600 </span>            :           // handle volatile case</a>
<a name="23601"><span class="lineNum">   23601 </span>            :           std::cout &lt;&lt; &quot;Hit volatile type, stripping of modifier type&quot; &lt;&lt; std::endl;</a>
<a name="23602"><span class="lineNum">   23602 </span>            :           node = modType-&gt;get_base_type();</a>
<a name="23603"><span class="lineNum">   23603 </span>            :          }</a>
<a name="23604"><span class="lineNum">   23604 </span>            :       if(SageInterface::isRestrictType(modType)){</a>
<a name="23605"><span class="lineNum">   23605 </span>            :         // handle restrict case</a>
<a name="23606"><span class="lineNum">   23606 </span>            :         std::cout &lt;&lt; &quot;Hit restrict type, stripping of modifier type&quot; &lt;&lt; std::endl;</a>
<a name="23607"><span class="lineNum">   23607 </span>            :         node = modType-&gt;get_base_type();</a>
<a name="23608"><span class="lineNum">   23608 </span>            :       }</a>
<a name="23609"><span class="lineNum">   23609 </span>            :     }</a>
<a name="23610"><span class="lineNum">   23610 </span>            :   }</a>
<a name="23611"><span class="lineNum">   23611 </span>            :   ROSE_ASSERT(node != NULL);</a>
<a name="23612"><span class="lineNum">   23612 </span>            :   return node;</a>
<a name="23613"><span class="lineNum">   23613 </span>            : }</a>
<a name="23614"><span class="lineNum">   23614 </span>            : </a>
<a name="23615"><span class="lineNum">   23615 </span><span class="lineCov">          2 : bool typesAreEqual(SgType *t1, SgType *t2) {</span></a>
<a name="23616"><span class="lineNum">   23616 </span><span class="lineCov">          2 :   bool equal = false;</span></a>
<a name="23617"><span class="lineNum">   23617 </span><span class="lineCov">          2 :   if(t1 == NULL || t2 == NULL){</span></a>
<a name="23618"><span class="lineNum">   23618 </span><span class="lineNoCov">          0 :     std::string wasNull;</span></a>
<a name="23619"><span class="lineNum">   23619 </span><span class="lineNoCov">          0 :     if(t1 == NULL){</span></a>
<a name="23620"><span class="lineNum">   23620 </span><span class="lineNoCov">          0 :       wasNull = &quot;t1&quot;;</span></a>
<a name="23621"><span class="lineNum">   23621 </span>            :     } else {</a>
<a name="23622"><span class="lineNum">   23622 </span><span class="lineNoCov">          0 :       wasNull = &quot;t2&quot;;</span></a>
<a name="23623"><span class="lineNum">   23623 </span>            :     }</a>
<a name="23624"><span class="lineNum">   23624 </span><span class="lineNoCov">          0 :     std::cerr &lt;&lt; &quot;ERROR: &quot; &lt;&lt; wasNull &lt;&lt; &quot; was NULL&quot; &lt;&lt; std::endl;</span></a>
<a name="23625"><span class="lineNum">   23625 </span><span class="lineNoCov">          0 :     return equal;</span></a>
<a name="23626"><span class="lineNum">   23626 </span>            :   }</a>
<a name="23627"><span class="lineNum">   23627 </span>            :   // if both pointers point to same location the types MUST be equal!</a>
<a name="23628"><span class="lineNum">   23628 </span><span class="lineCov">          2 :   if(t1 == t2){</span></a>
<a name="23629"><span class="lineNum">   23629 </span>            : //    std::cout &lt;&lt; &quot;Pointers are equal, returning true&quot; &lt;&lt; std::endl;</a>
<a name="23630"><span class="lineNum">   23630 </span>            :     return true;</a>
<a name="23631"><span class="lineNum">   23631 </span>            :   }</a>
<a name="23632"><span class="lineNum">   23632 </span>            : #ifndef USE_CMAKEx</a>
<a name="23633"><span class="lineNum">   23633 </span><span class="lineCov">          2 :   RoseAst subT1(t1);</span></a>
<a name="23634"><span class="lineNum">   23634 </span><span class="lineCov">          2 :   RoseAst subT2(t2);</span></a>
<a name="23635"><span class="lineNum">   23635 </span>            : </a>
<a name="23636"><span class="lineNum">   23636 </span><span class="lineCov">          2 :   for (RoseAst::iterator i = subT1.begin(), j = subT2.begin();</span></a>
<a name="23637"><span class="lineNum">   23637 </span><span class="lineCov">          4 :        i != subT1.end() &amp;&amp; j != subT2.end(); ++i, ++j) {</span></a>
<a name="23638"><span class="lineNum">   23638 </span><span class="lineCov">          2 :     SgNode *nodeT1 = *i;</span></a>
<a name="23639"><span class="lineNum">   23639 </span><span class="lineCov">          2 :     SgNode *nodeT2 = *j;</span></a>
<a name="23640"><span class="lineNum">   23640 </span>            : </a>
<a name="23641"><span class="lineNum">   23641 </span>            : //    std::cout &lt;&lt; &quot;nodeT1: &quot; &lt;&lt; nodeT1-&gt;class_name() &lt;&lt; &quot; nodeT2: &quot; &lt;&lt; nodeT2-&gt;class_name() &lt;&lt; std::endl;</a>
<a name="23642"><span class="lineNum">   23642 </span><span class="lineCov">          2 :    nodeT1 = getBasetypeIfApplicable(nodeT1);</span></a>
<a name="23643"><span class="lineNum">   23643 </span><span class="lineCov">          2 :    nodeT2 = getBasetypeIfApplicable(nodeT2);</span></a>
<a name="23644"><span class="lineNum">   23644 </span>            : </a>
<a name="23645"><span class="lineNum">   23645 </span><span class="lineCov">          2 :    if (nodeT1-&gt;variantT() == nodeT2-&gt;variantT()) {</span></a>
<a name="23646"><span class="lineNum">   23646 </span>            : //     std::cout &lt;&lt; &quot;variantT is the same&quot; &lt;&lt; std::endl;</a>
<a name="23647"><span class="lineNum">   23647 </span><span class="lineCov">          1 :       if(isSgModifierType(nodeT1)){</span></a>
<a name="23648"><span class="lineNum">   23648 </span>            :         // we need to check whether the modifier is the same or not</a>
<a name="23649"><span class="lineNum">   23649 </span><span class="lineNoCov">          0 :         SgTypeModifier modT1 = isSgModifierType(nodeT1)-&gt;get_typeModifier();</span></a>
<a name="23650"><span class="lineNum">   23650 </span><span class="lineNoCov">          0 :         SgTypeModifier modT2 = isSgModifierType(nodeT2)-&gt;get_typeModifier();</span></a>
<a name="23651"><span class="lineNum">   23651 </span><span class="lineNoCov">          0 :         if(modT1.get_constVolatileModifier().isConst() != modT2.get_constVolatileModifier().isConst()){</span></a>
<a name="23652"><span class="lineNum">   23652 </span><span class="lineNoCov">          0 :           return false;</span></a>
<a name="23653"><span class="lineNum">   23653 </span>            :         }</a>
<a name="23654"><span class="lineNum">   23654 </span><span class="lineNoCov">          0 :         if(modT1.get_constVolatileModifier().isVolatile() != modT2.get_constVolatileModifier().isVolatile()){</span></a>
<a name="23655"><span class="lineNum">   23655 </span>            :           return false;</a>
<a name="23656"><span class="lineNum">   23656 </span>            :         }</a>
<a name="23657"><span class="lineNum">   23657 </span><span class="lineCov">          1 :       } else if (isSgNamedType(nodeT1)) {      // Two different names -&gt; Must be two different things</span></a>
<a name="23658"><span class="lineNum">   23658 </span><span class="lineNoCov">          0 :         if (profile_) {</span></a>
<a name="23659"><span class="lineNum">   23659 </span><span class="lineNoCov">          0 :           namedType_++;</span></a>
<a name="23660"><span class="lineNum">   23660 </span>            :         }</a>
<a name="23661"><span class="lineNum">   23661 </span><span class="lineNoCov">          0 :         i.skipChildrenOnForward();</span></a>
<a name="23662"><span class="lineNum">   23662 </span><span class="lineNoCov">          0 :         j.skipChildrenOnForward();</span></a>
<a name="23663"><span class="lineNum">   23663 </span><span class="lineNoCov">          0 :         SgNamedType *c1 = isSgNamedType(nodeT1);</span></a>
<a name="23664"><span class="lineNum">   23664 </span><span class="lineNoCov">          0 :         SgNamedType *c2 = isSgNamedType(nodeT2);</span></a>
<a name="23665"><span class="lineNum">   23665 </span>            : </a>
<a name="23666"><span class="lineNum">   23666 </span>            : //        std::cout &lt;&lt; c1-&gt;get_qualified_name() &lt;&lt; std::endl;</a>
<a name="23667"><span class="lineNum">   23667 </span>            :         // XXX A function to check whether a named type is anonymous or not would speed</a>
<a name="23668"><span class="lineNum">   23668 </span>            :         // up this check, since we could get rid of this string compare.</a>
<a name="23669"><span class="lineNum">   23669 </span>            : //        if (c1-&gt;get_qualified_name().getString().find(&quot;__anonymous_&quot;) != std::string::npos) {</a>
<a name="23670"><span class="lineNum">   23670 </span><span class="lineNoCov">          0 :         if(!c1-&gt;get_autonomous_declaration()){</span></a>
<a name="23671"><span class="lineNum">   23671 </span>            :           return false;</a>
<a name="23672"><span class="lineNum">   23672 </span>            :         }</a>
<a name="23673"><span class="lineNum">   23673 </span><span class="lineNoCov">          0 :         if (!c2-&gt;get_autonomous_declaration()){</span></a>
<a name="23674"><span class="lineNum">   23674 </span>            :           return false;</a>
<a name="23675"><span class="lineNum">   23675 </span>            :         }</a>
<a name="23676"><span class="lineNum">   23676 </span><span class="lineNoCov">          0 :         if (c1-&gt;get_qualified_name() == c2-&gt;get_qualified_name()) {</span></a>
<a name="23677"><span class="lineNum">   23677 </span>            :           return true;</a>
<a name="23678"><span class="lineNum">   23678 </span>            :         } else {</a>
<a name="23679"><span class="lineNum">   23679 </span><span class="lineNoCov">          0 :           return false;</span></a>
<a name="23680"><span class="lineNum">   23680 </span>            :         }</a>
<a name="23681"><span class="lineNum">   23681 </span>            : </a>
<a name="23682"><span class="lineNum">   23682 </span><span class="lineCov">          1 :       } else if (isSgPointerType(nodeT1)) {</span></a>
<a name="23683"><span class="lineNum">   23683 </span><span class="lineNoCov">          0 :         if (profile_) {</span></a>
<a name="23684"><span class="lineNum">   23684 </span><span class="lineNoCov">          0 :           pointerType_++;</span></a>
<a name="23685"><span class="lineNum">   23685 </span>            :         }</a>
<a name="23686"><span class="lineNum">   23686 </span><span class="lineNoCov">          0 :         SgPointerType *t1 = isSgPointerType(nodeT1);</span></a>
<a name="23687"><span class="lineNum">   23687 </span><span class="lineNoCov">          0 :         SgPointerType *t2 = isSgPointerType(nodeT2);</span></a>
<a name="23688"><span class="lineNum">   23688 </span>            : </a>
<a name="23689"><span class="lineNum">   23689 </span><span class="lineNoCov">          0 :         return typesAreEqual(t1-&gt;get_base_type(), t2-&gt;get_base_type());</span></a>
<a name="23690"><span class="lineNum">   23690 </span>            : </a>
<a name="23691"><span class="lineNum">   23691 </span><span class="lineCov">          1 :       } else if(isSgReferenceType(nodeT1)){</span></a>
<a name="23692"><span class="lineNum">   23692 </span><span class="lineNoCov">          0 :         SgReferenceType *t1 = isSgReferenceType(nodeT1);</span></a>
<a name="23693"><span class="lineNum">   23693 </span><span class="lineNoCov">          0 :         SgReferenceType *t2 = isSgReferenceType(nodeT2);</span></a>
<a name="23694"><span class="lineNum">   23694 </span>            : </a>
<a name="23695"><span class="lineNum">   23695 </span><span class="lineNoCov">          0 :         return typesAreEqual(t1-&gt;get_base_type(), t2-&gt;get_base_type());</span></a>
<a name="23696"><span class="lineNum">   23696 </span><span class="lineCov">          1 :       } else if (isSgArrayType(nodeT1)) {</span></a>
<a name="23697"><span class="lineNum">   23697 </span><span class="lineNoCov">          0 :         if (profile_) {</span></a>
<a name="23698"><span class="lineNum">   23698 </span><span class="lineNoCov">          0 :           arrayType_++;</span></a>
<a name="23699"><span class="lineNum">   23699 </span>            :         }</a>
<a name="23700"><span class="lineNum">   23700 </span><span class="lineNoCov">          0 :         SgArrayType *a1 = isSgArrayType(nodeT1);</span></a>
<a name="23701"><span class="lineNum">   23701 </span><span class="lineNoCov">          0 :         SgArrayType *a2 = isSgArrayType(nodeT2);</span></a>
<a name="23702"><span class="lineNum">   23702 </span>            : </a>
<a name="23703"><span class="lineNum">   23703 </span><span class="lineNoCov">          0 :         bool arrayBaseIsEqual = typesAreEqual(a1-&gt;get_base_type(), a2-&gt;get_base_type());</span></a>
<a name="23704"><span class="lineNum">   23704 </span>            : </a>
<a name="23705"><span class="lineNum">   23705 </span><span class="lineNoCov">          0 :         SageInterface::const_int_expr_t t1Index = SageInterface::evaluateConstIntegerExpression(a1-&gt;get_index());</span></a>
<a name="23706"><span class="lineNum">   23706 </span><span class="lineNoCov">          0 :         SageInterface::const_int_expr_t t2Index = SageInterface::evaluateConstIntegerExpression(a2-&gt;get_index());</span></a>
<a name="23707"><span class="lineNum">   23707 </span><span class="lineNoCov">          0 :         bool arrayIndexExpressionIsEquivalent = false;</span></a>
<a name="23708"><span class="lineNum">   23708 </span><span class="lineNoCov">          0 :         if(t1Index.hasValue_ &amp;&amp; t2Index.hasValue_){</span></a>
<a name="23709"><span class="lineNum">   23709 </span><span class="lineNoCov">          0 :           if(t1Index.value_ == t2Index.value_){</span></a>
<a name="23710"><span class="lineNum">   23710 </span><span class="lineNoCov">          0 :             arrayIndexExpressionIsEquivalent = true;</span></a>
<a name="23711"><span class="lineNum">   23711 </span>            :           }</a>
<a name="23712"><span class="lineNum">   23712 </span>            :         }</a>
<a name="23713"><span class="lineNum">   23713 </span><span class="lineNoCov">          0 :         bool arraysAreEqual = (arrayBaseIsEqual &amp;&amp; arrayIndexExpressionIsEquivalent);</span></a>
<a name="23714"><span class="lineNum">   23714 </span><span class="lineNoCov">          0 :         return arraysAreEqual;</span></a>
<a name="23715"><span class="lineNum">   23715 </span><span class="lineCov">          1 :       } else if (isSgFunctionType(nodeT1)) {</span></a>
<a name="23716"><span class="lineNum">   23716 </span><span class="lineCov">          1 :         if(profile_) {</span></a>
<a name="23717"><span class="lineNum">   23717 </span><span class="lineNoCov">          0 :           functionType_++;</span></a>
<a name="23718"><span class="lineNum">   23718 </span>            :         }</a>
<a name="23719"><span class="lineNum">   23719 </span><span class="lineCov">          1 :         SgFunctionType *funcTypeA = isSgFunctionType(nodeT1);</span></a>
<a name="23720"><span class="lineNum">   23720 </span><span class="lineCov">          1 :         SgFunctionType *funcTypeB = isSgFunctionType(nodeT2);</span></a>
<a name="23721"><span class="lineNum">   23721 </span>            : //        std::cout &lt;&lt; &quot;Inside SgFunctionType&quot; &lt;&lt; std::endl;</a>
<a name="23722"><span class="lineNum">   23722 </span>            : //        assert(funcTypeA != funcTypeB);</a>
<a name="23723"><span class="lineNum">   23723 </span><span class="lineCov">          1 :         if(typesAreEqual(funcTypeA-&gt;get_return_type(), funcTypeB-&gt;get_return_type())) {</span></a>
<a name="23724"><span class="lineNum">   23724 </span>            :           // If functions don't have the same number of arguments, they are not type-equal</a>
<a name="23725"><span class="lineNum">   23725 </span><span class="lineNoCov">          0 :           if(funcTypeA-&gt;get_arguments().size() != funcTypeB-&gt;get_arguments().size()) {</span></a>
<a name="23726"><span class="lineNum">   23726 </span>            :             return false;</a>
<a name="23727"><span class="lineNum">   23727 </span>            :           }</a>
<a name="23728"><span class="lineNum">   23728 </span>            :           // This should always be the same as the if before...</a>
<a name="23729"><span class="lineNum">   23729 </span><span class="lineNoCov">          0 :           if(funcTypeA-&gt;get_argument_list()-&gt;get_arguments().size() != funcTypeB-&gt;get_argument_list()-&gt;get_arguments().size()){</span></a>
<a name="23730"><span class="lineNum">   23730 </span>            :             return false;</a>
<a name="23731"><span class="lineNum">   23731 </span>            :           }</a>
<a name="23732"><span class="lineNum">   23732 </span>            : </a>
<a name="23733"><span class="lineNum">   23733 </span><span class="lineNoCov">          0 :           for(SgTypePtrList::const_iterator ii = funcTypeA-&gt;get_arguments().begin(),</span></a>
<a name="23734"><span class="lineNum">   23734 </span><span class="lineNoCov">          0 :               jj = funcTypeB-&gt;get_arguments().begin();</span></a>
<a name="23735"><span class="lineNum">   23735 </span><span class="lineNoCov">          0 :               ii != funcTypeA-&gt;get_arguments().end() &amp;&amp;</span></a>
<a name="23736"><span class="lineNum">   23736 </span><span class="lineNoCov">          0 :               jj != funcTypeB-&gt;get_arguments().end();</span></a>
<a name="23737"><span class="lineNum">   23737 </span><span class="lineNoCov">          0 :               ++ii, ++jj) {</span></a>
<a name="23738"><span class="lineNum">   23738 </span>            : //            std::cout &lt;&lt; (*ii)-&gt;class_name() &lt;&lt; &quot; &quot; &lt;&lt; (*jj)-&gt;class_name() &lt;&lt; std::endl;</a>
<a name="23739"><span class="lineNum">   23739 </span>            :             // For all argument types check whether they are equal</a>
<a name="23740"><span class="lineNum">   23740 </span><span class="lineNoCov">          0 :             if(!typesAreEqual((*ii), (*jj))) {</span></a>
<a name="23741"><span class="lineNum">   23741 </span><span class="lineCov">          2 :               return false;</span></a>
<a name="23742"><span class="lineNum">   23742 </span>            :             }</a>
<a name="23743"><span class="lineNum">   23743 </span>            :           }</a>
<a name="23744"><span class="lineNum">   23744 </span><span class="lineNoCov">          0 :           return true;</span></a>
<a name="23745"><span class="lineNum">   23745 </span>            :         }</a>
<a name="23746"><span class="lineNum">   23746 </span>            :         return false;</a>
<a name="23747"><span class="lineNum">   23747 </span>            :       } else {</a>
<a name="23748"><span class="lineNum">   23748 </span>            :         // We don't have a named type, pointer type or array type, so they are equal</a>
<a name="23749"><span class="lineNum">   23749 </span>            :         // This is for the primitive type - case</a>
<a name="23750"><span class="lineNum">   23750 </span>            :         return true;</a>
<a name="23751"><span class="lineNum">   23751 </span>            :       }</a>
<a name="23752"><span class="lineNum">   23752 </span>            :     } else {</a>
<a name="23753"><span class="lineNum">   23753 </span>            :       // In this case the types are not equal, since its variantT is not equal.</a>
<a name="23754"><span class="lineNum">   23754 </span>            :       return false;</a>
<a name="23755"><span class="lineNum">   23755 </span>            :     }</a>
<a name="23756"><span class="lineNum">   23756 </span>            :   }</a>
<a name="23757"><span class="lineNum">   23757 </span>            :   // this should be unreachable code...</a>
<a name="23758"><span class="lineNum">   23758 </span><span class="lineNoCov">          0 :   return equal;</span></a>
<a name="23759"><span class="lineNum">   23759 </span>            : #else</a>
<a name="23760"><span class="lineNum">   23760 </span>            :   std::cerr &lt;&lt; &quot;This feature for now is available with autotools only!&quot; &lt;&lt; std::endl;</a>
<a name="23761"><span class="lineNum">   23761 </span>            :   ROSE_ABORT();</a>
<a name="23762"><span class="lineNum">   23762 </span>            : #endif</a>
<a name="23763"><span class="lineNum">   23763 </span>            : }</a>
<a name="23764"><span class="lineNum">   23764 </span>            : </a>
<a name="23765"><span class="lineNum">   23765 </span>            : int getNamedTypeCount() {</a>
<a name="23766"><span class="lineNum">   23766 </span>            :   return namedType_;</a>
<a name="23767"><span class="lineNum">   23767 </span>            : }</a>
<a name="23768"><span class="lineNum">   23768 </span>            : </a>
<a name="23769"><span class="lineNum">   23769 </span>            : int getPointerTypeCount() {</a>
<a name="23770"><span class="lineNum">   23770 </span>            :   return pointerType_;</a>
<a name="23771"><span class="lineNum">   23771 </span>            : }</a>
<a name="23772"><span class="lineNum">   23772 </span>            : </a>
<a name="23773"><span class="lineNum">   23773 </span>            : int getArrayTypeCount() {</a>
<a name="23774"><span class="lineNum">   23774 </span>            :   return arrayType_;</a>
<a name="23775"><span class="lineNum">   23775 </span>            : }</a>
<a name="23776"><span class="lineNum">   23776 </span>            : </a>
<a name="23777"><span class="lineNum">   23777 </span>            : int getFunctionTypeCount() {</a>
<a name="23778"><span class="lineNum">   23778 </span>            :   return functionType_;</a>
<a name="23779"><span class="lineNum">   23779 </span>            : }</a>
<a name="23780"><span class="lineNum">   23780 </span>            :     private:</a>
<a name="23781"><span class="lineNum">   23781 </span>            : //     SgNode * getBasetypeIfApplicable(SgNode *t);</a>
<a name="23782"><span class="lineNum">   23782 </span>            :      bool profile_, useSemanticEquivalence_;</a>
<a name="23783"><span class="lineNum">   23783 </span>            :      int namedType_, pointerType_, arrayType_, functionType_;</a>
<a name="23784"><span class="lineNum">   23784 </span>            : };</a>
<a name="23785"><span class="lineNum">   23785 </span>            : </a>
<a name="23786"><span class="lineNum">   23786 </span><span class="lineCov">          1 : TypeEquivalenceChecker tec(false, false);</span></a>
<a name="23787"><span class="lineNum">   23787 </span><span class="lineCov">          1 : return tec.typesAreEqual(typeA, typeB);</span></a>
<a name="23788"><span class="lineNum">   23788 </span>            : }</a>
<a name="23789"><span class="lineNum">   23789 </span>            : </a>
<a name="23790"><span class="lineNum">   23790 </span>            : </a>
<a name="23791"><span class="lineNum">   23791 </span>            : std::set&lt;SgStatement*&gt;</a>
<a name="23792"><span class="lineNum">   23792 </span><span class="lineCov">          1 : SageInterface::collectTransformedStatements( SgNode* node )</span></a>
<a name="23793"><span class="lineNum">   23793 </span>            :    {</a>
<a name="23794"><span class="lineNum">   23794 </span>            :   // DQ (6/11/2015): This reports the statements that are marked as transformed.</a>
<a name="23795"><span class="lineNum">   23795 </span>            :   // It is useful for debugging the token-based unparsing.</a>
<a name="23796"><span class="lineNum">   23796 </span>            : </a>
<a name="23797"><span class="lineNum">   23797 </span><span class="lineCov">          1 :      class StatementTraversal : public AstSimpleProcessing</span></a>
<a name="23798"><span class="lineNum">   23798 </span>            :         {</a>
<a name="23799"><span class="lineNum">   23799 </span>            :           public:</a>
<a name="23800"><span class="lineNum">   23800 </span><span class="lineCov">          1 :                StatementTraversal() : count (0) {}</span></a>
<a name="23801"><span class="lineNum">   23801 </span><span class="lineCov">     103115 :                void visit (SgNode* node)</span></a>
<a name="23802"><span class="lineNum">   23802 </span>            :                   {</a>
<a name="23803"><span class="lineNum">   23803 </span><span class="lineCov">     103115 :                     SgStatement* statement = isSgStatement(node);</span></a>
<a name="23804"><span class="lineNum">   23804 </span>            :                  // if (statement != NULL &amp;&amp; statement-&gt;get_file_info()-&gt;isTransformation() == true)</a>
<a name="23805"><span class="lineNum">   23805 </span><span class="lineCov">     103115 :                     if (statement != NULL &amp;&amp; statement-&gt;isTransformation() == true)</span></a>
<a name="23806"><span class="lineNum">   23806 </span>            :                        {</a>
<a name="23807"><span class="lineNum">   23807 </span><span class="lineCov">       1452 :                          returnset.insert(statement);</span></a>
<a name="23808"><span class="lineNum">   23808 </span><span class="lineCov">       1452 :                          count++;</span></a>
<a name="23809"><span class="lineNum">   23809 </span>            :                        }</a>
<a name="23810"><span class="lineNum">   23810 </span><span class="lineCov">     103115 :                   }</span></a>
<a name="23811"><span class="lineNum">   23811 </span>            : </a>
<a name="23812"><span class="lineNum">   23812 </span>            :                int count; // running total of statements found marked as transformations in the input AST</a>
<a name="23813"><span class="lineNum">   23813 </span>            :                std::set&lt;SgStatement*&gt; returnset;</a>
<a name="23814"><span class="lineNum">   23814 </span>            :         };</a>
<a name="23815"><span class="lineNum">   23815 </span>            : </a>
<a name="23816"><span class="lineNum">   23816 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="23817"><span class="lineNum">   23817 </span><span class="lineCov">          1 :      StatementTraversal traversal;</span></a>
<a name="23818"><span class="lineNum">   23818 </span><span class="lineCov">          1 :      traversal.traverse(node, preorder);</span></a>
<a name="23819"><span class="lineNum">   23819 </span>            : </a>
<a name="23820"><span class="lineNum">   23820 </span><span class="lineCov">          1 :      return traversal.returnset;</span></a>
<a name="23821"><span class="lineNum">   23821 </span>            :    }</a>
<a name="23822"><span class="lineNum">   23822 </span>            : </a>
<a name="23823"><span class="lineNum">   23823 </span>            : std::set&lt;SgStatement*&gt;</a>
<a name="23824"><span class="lineNum">   23824 </span><span class="lineCov">          1 : SageInterface::collectModifiedStatements( SgNode* node )</span></a>
<a name="23825"><span class="lineNum">   23825 </span>            :    {</a>
<a name="23826"><span class="lineNum">   23826 </span>            :   // DQ (6/11/2015): This reports the statements that are marked as modified (isModified flag).</a>
<a name="23827"><span class="lineNum">   23827 </span>            :   // It is useful for debugging the token-based unparsing.</a>
<a name="23828"><span class="lineNum">   23828 </span>            : </a>
<a name="23829"><span class="lineNum">   23829 </span><span class="lineCov">          1 :      class StatementTraversal : public AstSimpleProcessing</span></a>
<a name="23830"><span class="lineNum">   23830 </span>            :         {</a>
<a name="23831"><span class="lineNum">   23831 </span>            :           public:</a>
<a name="23832"><span class="lineNum">   23832 </span><span class="lineCov">          1 :                StatementTraversal() : count (0) {}</span></a>
<a name="23833"><span class="lineNum">   23833 </span><span class="lineCov">     103115 :                void visit (SgNode* node)</span></a>
<a name="23834"><span class="lineNum">   23834 </span>            :                   {</a>
<a name="23835"><span class="lineNum">   23835 </span><span class="lineCov">     103115 :                     SgStatement* statement = isSgStatement(node);</span></a>
<a name="23836"><span class="lineNum">   23836 </span><span class="lineCov">     103115 :                     if (statement != NULL &amp;&amp; statement-&gt;get_isModified() == true)</span></a>
<a name="23837"><span class="lineNum">   23837 </span>            :                        {</a>
<a name="23838"><span class="lineNum">   23838 </span><span class="lineCov">        852 :                          returnset.insert(statement);</span></a>
<a name="23839"><span class="lineNum">   23839 </span><span class="lineCov">        852 :                          count++;</span></a>
<a name="23840"><span class="lineNum">   23840 </span>            :                        }</a>
<a name="23841"><span class="lineNum">   23841 </span><span class="lineCov">     103115 :                   }</span></a>
<a name="23842"><span class="lineNum">   23842 </span>            : </a>
<a name="23843"><span class="lineNum">   23843 </span>            :                int count; // running total of statements found marked as transformations in the input AST</a>
<a name="23844"><span class="lineNum">   23844 </span>            :                std::set&lt;SgStatement*&gt; returnset;</a>
<a name="23845"><span class="lineNum">   23845 </span>            :         };</a>
<a name="23846"><span class="lineNum">   23846 </span>            : </a>
<a name="23847"><span class="lineNum">   23847 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="23848"><span class="lineNum">   23848 </span><span class="lineCov">          1 :      StatementTraversal traversal;</span></a>
<a name="23849"><span class="lineNum">   23849 </span><span class="lineCov">          1 :      traversal.traverse(node, preorder);</span></a>
<a name="23850"><span class="lineNum">   23850 </span>            : </a>
<a name="23851"><span class="lineNum">   23851 </span><span class="lineCov">          1 :      return traversal.returnset;</span></a>
<a name="23852"><span class="lineNum">   23852 </span>            :    }</a>
<a name="23853"><span class="lineNum">   23853 </span>            : </a>
<a name="23854"><span class="lineNum">   23854 </span>            : </a>
<a name="23855"><span class="lineNum">   23855 </span>            : void</a>
<a name="23856"><span class="lineNum">   23856 </span><span class="lineNoCov">          0 : SageInterface::outputFileIds( SgNode* node )</span></a>
<a name="23857"><span class="lineNum">   23857 </span>            :    {</a>
<a name="23858"><span class="lineNum">   23858 </span>            :   // DQ (12/2/2019): This reports the file id values of all located nodes in the AST subtree represented by the input node.</a>
<a name="23859"><span class="lineNum">   23859 </span>            : </a>
<a name="23860"><span class="lineNum">   23860 </span>            : #if 1</a>
<a name="23861"><span class="lineNum">   23861 </span><span class="lineNoCov">          0 :      printf (&quot;In outputFileIds(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="23862"><span class="lineNum">   23862 </span>            : #endif</a>
<a name="23863"><span class="lineNum">   23863 </span>            : </a>
<a name="23864"><span class="lineNum">   23864 </span><span class="lineNoCov">          0 :      class LocatedNodeTraversal : public AstSimpleProcessing</span></a>
<a name="23865"><span class="lineNum">   23865 </span>            :         {</a>
<a name="23866"><span class="lineNum">   23866 </span>            :           public:</a>
<a name="23867"><span class="lineNum">   23867 </span><span class="lineNoCov">          0 :                LocatedNodeTraversal() {}</span></a>
<a name="23868"><span class="lineNum">   23868 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="23869"><span class="lineNum">   23869 </span>            :                   {</a>
<a name="23870"><span class="lineNum">   23870 </span><span class="lineNoCov">          0 :                     SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="23871"><span class="lineNum">   23871 </span><span class="lineNoCov">          0 :                     if (locatedNode != NULL)</span></a>
<a name="23872"><span class="lineNum">   23872 </span>            :                        {</a>
<a name="23873"><span class="lineNum">   23873 </span>            : #if 1</a>
<a name="23874"><span class="lineNum">   23874 </span><span class="lineNoCov">          0 :                          printf (&quot;In outputFileIds(): isModified() == %s: locatedNode = %p = %s \n&quot;,locatedNode-&gt;get_isModified() ? &quot;true&quot; : &quot;false&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</span></a>
<a name="23875"><span class="lineNum">   23875 </span><span class="lineNoCov">          0 :                          printf (&quot; --- file id = %d physical_file_id = %d \n&quot;,node-&gt;get_file_info()-&gt;get_file_id(),node-&gt;get_file_info()-&gt;get_physical_file_id());</span></a>
<a name="23876"><span class="lineNum">   23876 </span>            : #endif</a>
<a name="23877"><span class="lineNum">   23877 </span>            :                        }</a>
<a name="23878"><span class="lineNum">   23878 </span>            :                       else</a>
<a name="23879"><span class="lineNum">   23879 </span>            :                        {</a>
<a name="23880"><span class="lineNum">   23880 </span><span class="lineNoCov">          0 :                          SgInitializedName* initializedName = isSgInitializedName(node);</span></a>
<a name="23881"><span class="lineNum">   23881 </span><span class="lineNoCov">          0 :                          if (initializedName != NULL)</span></a>
<a name="23882"><span class="lineNum">   23882 </span>            :                             {</a>
<a name="23883"><span class="lineNum">   23883 </span><span class="lineNoCov">          0 :                               printf (&quot;In outputFileIds(): isModified() == %s: initializedName = %p = %s \n&quot;,initializedName-&gt;get_isModified() ? &quot;true&quot; : &quot;false&quot;,initializedName,initializedName-&gt;class_name().c_str());</span></a>
<a name="23884"><span class="lineNum">   23884 </span><span class="lineNoCov">          0 :                               printf (&quot; --- file id = %d physical_file_id = %d \n&quot;,initializedName-&gt;get_file_info()-&gt;get_file_id(),initializedName-&gt;get_file_info()-&gt;get_physical_file_id());</span></a>
<a name="23885"><span class="lineNum">   23885 </span>            :                             }</a>
<a name="23886"><span class="lineNum">   23886 </span>            :                        }</a>
<a name="23887"><span class="lineNum">   23887 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="23888"><span class="lineNum">   23888 </span>            :         };</a>
<a name="23889"><span class="lineNum">   23889 </span>            : </a>
<a name="23890"><span class="lineNum">   23890 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="23891"><span class="lineNum">   23891 </span><span class="lineNoCov">          0 :      LocatedNodeTraversal traversal;</span></a>
<a name="23892"><span class="lineNum">   23892 </span><span class="lineNoCov">          0 :      traversal.traverse(node, preorder);</span></a>
<a name="23893"><span class="lineNum">   23893 </span>            : </a>
<a name="23894"><span class="lineNum">   23894 </span>            : #if 0</a>
<a name="23895"><span class="lineNum">   23895 </span>            :      printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="23896"><span class="lineNum">   23896 </span>            :      ROSE_ABORT();</a>
<a name="23897"><span class="lineNum">   23897 </span>            : #endif</a>
<a name="23898"><span class="lineNum">   23898 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="23899"><span class="lineNum">   23899 </span>            : </a>
<a name="23900"><span class="lineNum">   23900 </span>            : </a>
<a name="23901"><span class="lineNum">   23901 </span>            : </a>
<a name="23902"><span class="lineNum">   23902 </span>            : std::set&lt;SgLocatedNode*&gt;</a>
<a name="23903"><span class="lineNum">   23903 </span><span class="lineCov">        136 : SageInterface::collectModifiedLocatedNodes( SgNode* node )</span></a>
<a name="23904"><span class="lineNum">   23904 </span>            :    {</a>
<a name="23905"><span class="lineNum">   23905 </span>            :   // DQ (6/11/2015): This reports the statements that are marked as modified (isModified flag).</a>
<a name="23906"><span class="lineNum">   23906 </span>            :   // It is useful for debugging the token-based unparsing.</a>
<a name="23907"><span class="lineNum">   23907 </span>            : </a>
<a name="23908"><span class="lineNum">   23908 </span>            : #if 0</a>
<a name="23909"><span class="lineNum">   23909 </span>            :      printf (&quot;In collectModifiedLocatedNodes(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="23910"><span class="lineNum">   23910 </span>            : #endif</a>
<a name="23911"><span class="lineNum">   23911 </span>            : </a>
<a name="23912"><span class="lineNum">   23912 </span><span class="lineCov">        136 :      class LocatedNodeTraversal : public AstSimpleProcessing</span></a>
<a name="23913"><span class="lineNum">   23913 </span>            :         {</a>
<a name="23914"><span class="lineNum">   23914 </span>            :           public:</a>
<a name="23915"><span class="lineNum">   23915 </span><span class="lineCov">        136 :                LocatedNodeTraversal() : count (0) {}</span></a>
<a name="23916"><span class="lineNum">   23916 </span><span class="lineCov">    3719020 :                void visit (SgNode* node)</span></a>
<a name="23917"><span class="lineNum">   23917 </span>            :                   {</a>
<a name="23918"><span class="lineNum">   23918 </span><span class="lineCov">    3719020 :                     SgLocatedNode* locatedNode = isSgLocatedNode(node);</span></a>
<a name="23919"><span class="lineNum">   23919 </span><span class="lineCov">    3719020 :                     if (locatedNode != NULL &amp;&amp; locatedNode-&gt;get_isModified() == true)</span></a>
<a name="23920"><span class="lineNum">   23920 </span>            :                        {</a>
<a name="23921"><span class="lineNum">   23921 </span>            : #if 0</a>
<a name="23922"><span class="lineNum">   23922 </span>            :                          printf (&quot;In collectModifiedLocatedNodes(): isModified() == true: locatedNode = %p = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="23923"><span class="lineNum">   23923 </span>            : #endif</a>
<a name="23924"><span class="lineNum">   23924 </span><span class="lineCov">     349740 :                          returnset.insert(locatedNode);</span></a>
<a name="23925"><span class="lineNum">   23925 </span><span class="lineCov">     349740 :                          count++;</span></a>
<a name="23926"><span class="lineNum">   23926 </span>            :                        }</a>
<a name="23927"><span class="lineNum">   23927 </span><span class="lineCov">    3719020 :                   }</span></a>
<a name="23928"><span class="lineNum">   23928 </span>            : </a>
<a name="23929"><span class="lineNum">   23929 </span>            :                int count; // running total of statements found marked as transformations in the input AST</a>
<a name="23930"><span class="lineNum">   23930 </span>            :                std::set&lt;SgLocatedNode*&gt; returnset;</a>
<a name="23931"><span class="lineNum">   23931 </span>            :         };</a>
<a name="23932"><span class="lineNum">   23932 </span>            : </a>
<a name="23933"><span class="lineNum">   23933 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the function definition.</a>
<a name="23934"><span class="lineNum">   23934 </span><span class="lineCov">        136 :      LocatedNodeTraversal traversal;</span></a>
<a name="23935"><span class="lineNum">   23935 </span><span class="lineCov">        136 :      traversal.traverse(node, preorder);</span></a>
<a name="23936"><span class="lineNum">   23936 </span>            : </a>
<a name="23937"><span class="lineNum">   23937 </span><span class="lineCov">        136 :      return traversal.returnset;</span></a>
<a name="23938"><span class="lineNum">   23938 </span>            :    }</a>
<a name="23939"><span class="lineNum">   23939 </span>            : </a>
<a name="23940"><span class="lineNum">   23940 </span>            : //! Use the set of IR nodes and set the isModified flag in each IR node to true.</a>
<a name="23941"><span class="lineNum">   23941 </span>            : void</a>
<a name="23942"><span class="lineNum">   23942 </span><span class="lineCov">          4 : SageInterface::resetModifiedLocatedNodes(const std::set&lt;SgLocatedNode*&gt; &amp; modifiedNodeSet)</span></a>
<a name="23943"><span class="lineNum">   23943 </span>            :    {</a>
<a name="23944"><span class="lineNum">   23944 </span>            :   // DQ (6/5/2019): Use a previously constructed set to reset the IR nodes to be marked as isModified.</a>
<a name="23945"><span class="lineNum">   23945 </span>            : </a>
<a name="23946"><span class="lineNum">   23946 </span>            : #if 0</a>
<a name="23947"><span class="lineNum">   23947 </span>            :      printf (&quot;In resetModifiedLocatedNodes(): modifiedNodeSet.size() = %zu \n&quot;,modifiedNodeSet.size());</a>
<a name="23948"><span class="lineNum">   23948 </span>            : #endif</a>
<a name="23949"><span class="lineNum">   23949 </span>            : </a>
<a name="23950"><span class="lineNum">   23950 </span><span class="lineCov">          4 :      std::set&lt;SgLocatedNode*&gt;::const_iterator i = modifiedNodeSet.begin();</span></a>
<a name="23951"><span class="lineNum">   23951 </span><span class="lineCov">         12 :      while (i != modifiedNodeSet.end())</span></a>
<a name="23952"><span class="lineNum">   23952 </span>            :         {</a>
<a name="23953"><span class="lineNum">   23953 </span><span class="lineCov">          8 :           SgLocatedNode* node = *i;</span></a>
<a name="23954"><span class="lineNum">   23954 </span>            : #if 0</a>
<a name="23955"><span class="lineNum">   23955 </span>            :           printf (&quot;Marking node = %p = %s as modified \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="23956"><span class="lineNum">   23956 </span>            : #endif</a>
<a name="23957"><span class="lineNum">   23957 </span><span class="lineCov">          8 :           node-&gt;set_isModified(true);</span></a>
<a name="23958"><span class="lineNum">   23958 </span>            : </a>
<a name="23959"><span class="lineNum">   23959 </span><span class="lineCov">         12 :           i++;</span></a>
<a name="23960"><span class="lineNum">   23960 </span>            :         }</a>
<a name="23961"><span class="lineNum">   23961 </span><span class="lineCov">          4 :    }</span></a>
<a name="23962"><span class="lineNum">   23962 </span>            : </a>
<a name="23963"><span class="lineNum">   23963 </span>            : </a>
<a name="23964"><span class="lineNum">   23964 </span>            : void</a>
<a name="23965"><span class="lineNum">   23965 </span><span class="lineNoCov">          0 : SageInterface::reportModifiedStatements( const string &amp; label, SgNode* node )</span></a>
<a name="23966"><span class="lineNum">   23966 </span>            :    {</a>
<a name="23967"><span class="lineNum">   23967 </span>            :   // DQ (10/23/2018): This reports the nodes in the AST that are marked as modified (isModified flag).</a>
<a name="23968"><span class="lineNum">   23968 </span>            :   // It is useful for debugging the token-based unparsing.</a>
<a name="23969"><span class="lineNum">   23969 </span>            : </a>
<a name="23970"><span class="lineNum">   23970 </span><span class="lineNoCov">          0 :      printf (&quot;\n\n##################################################### \n&quot;);</span></a>
<a name="23971"><span class="lineNum">   23971 </span><span class="lineNoCov">          0 :      printf (&quot;Report on modified statements: label = %s \n&quot;,label.c_str());</span></a>
<a name="23972"><span class="lineNum">   23972 </span>            : </a>
<a name="23973"><span class="lineNum">   23973 </span><span class="lineNoCov">          0 :      SgSourceFile* sourceFile = isSgSourceFile(node);</span></a>
<a name="23974"><span class="lineNum">   23974 </span><span class="lineNoCov">          0 :      if (sourceFile != NULL)</span></a>
<a name="23975"><span class="lineNum">   23975 </span>            :         {</a>
<a name="23976"><span class="lineNum">   23976 </span><span class="lineNoCov">          0 :           printf (&quot;   --- (SgSourceFile) filename = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</span></a>
<a name="23977"><span class="lineNum">   23977 </span>            :         }</a>
<a name="23978"><span class="lineNum">   23978 </span>            :        else</a>
<a name="23979"><span class="lineNum">   23979 </span>            :         {</a>
<a name="23980"><span class="lineNum">   23980 </span><span class="lineNoCov">          0 :           SgGlobal* globalScope = isSgGlobal(node);</span></a>
<a name="23981"><span class="lineNum">   23981 </span><span class="lineNoCov">          0 :           if (globalScope != NULL)</span></a>
<a name="23982"><span class="lineNum">   23982 </span>            :              {</a>
<a name="23983"><span class="lineNum">   23983 </span><span class="lineNoCov">          0 :                sourceFile = isSgSourceFile(globalScope-&gt;get_parent());</span></a>
<a name="23984"><span class="lineNum">   23984 </span><span class="lineNoCov">          0 :                printf (&quot;   --- (SgGlobal) filename = %s \n&quot;,sourceFile-&gt;getFileName().c_str());</span></a>
<a name="23985"><span class="lineNum">   23985 </span>            :              }</a>
<a name="23986"><span class="lineNum">   23986 </span>            :         }</a>
<a name="23987"><span class="lineNum">   23987 </span>            : </a>
<a name="23988"><span class="lineNum">   23988 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="23989"><span class="lineNum">   23989 </span><span class="lineNoCov">          0 :      std::set&lt;SgStatement*&gt; collection = collectModifiedStatements(node);</span></a>
<a name="23990"><span class="lineNum">   23990 </span>            : </a>
<a name="23991"><span class="lineNum">   23991 </span>            : #if 1</a>
<a name="23992"><span class="lineNum">   23992 </span><span class="lineNoCov">          0 :      printf (&quot;In reportModifiedStatements(): collection.size() = %zu \n&quot;,collection.size());</span></a>
<a name="23993"><span class="lineNum">   23993 </span>            : #endif</a>
<a name="23994"><span class="lineNum">   23994 </span>            : </a>
<a name="23995"><span class="lineNum">   23995 </span><span class="lineNoCov">          0 :      std::set&lt;SgStatement*&gt;::iterator i = collection.begin();</span></a>
<a name="23996"><span class="lineNum">   23996 </span><span class="lineNoCov">          0 :      while (i != collection.end())</span></a>
<a name="23997"><span class="lineNum">   23997 </span>            :         {</a>
<a name="23998"><span class="lineNum">   23998 </span>            :        // DQ (10/9/2019): Adding filename to debug output.</a>
<a name="23999"><span class="lineNum">   23999 </span><span class="lineNoCov">          0 :           string filename = (*i)-&gt;get_file_info()-&gt;get_filename();</span></a>
<a name="24000"><span class="lineNum">   24000 </span>            : </a>
<a name="24001"><span class="lineNum">   24001 </span>            :        // DQ (10/14/2019): Get the best name possible.</a>
<a name="24002"><span class="lineNum">   24002 </span><span class="lineNoCov">          0 :           if (filename == &quot;transformation&quot;)</span></a>
<a name="24003"><span class="lineNum">   24003 </span>            :              {</a>
<a name="24004"><span class="lineNum">   24004 </span>            : #if 0</a>
<a name="24005"><span class="lineNum">   24005 </span>            :                printf (&quot;   --- filename == transformation: sourceFile = %p using physical filename \n&quot;,sourceFile);</a>
<a name="24006"><span class="lineNum">   24006 </span>            : #endif</a>
<a name="24007"><span class="lineNum">   24007 </span>            :             // filename = (*i)-&gt;get_file_info()-&gt;get_physical_filename();</a>
<a name="24008"><span class="lineNum">   24008 </span><span class="lineNoCov">          0 :                SgSourceFile* sourceFile = TransformationSupport::getSourceFile(*i);</span></a>
<a name="24009"><span class="lineNum">   24009 </span><span class="lineNoCov">          0 :                if (sourceFile != NULL)</span></a>
<a name="24010"><span class="lineNum">   24010 </span>            :                   {</a>
<a name="24011"><span class="lineNum">   24011 </span><span class="lineNoCov">          0 :                     filename = sourceFile-&gt;getFileName();</span></a>
<a name="24012"><span class="lineNum">   24012 </span>            :                   }</a>
<a name="24013"><span class="lineNum">   24013 </span>            :              }</a>
<a name="24014"><span class="lineNum">   24014 </span>            : </a>
<a name="24015"><span class="lineNum">   24015 </span><span class="lineNoCov">          0 :           printf (&quot;   --- filename = %s modified statement = %p = %s \n&quot;,filename.c_str(),(*i),(*i)-&gt;class_name().c_str());</span></a>
<a name="24016"><span class="lineNum">   24016 </span>            : </a>
<a name="24017"><span class="lineNum">   24017 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="24018"><span class="lineNum">   24018 </span>            :         }</a>
<a name="24019"><span class="lineNum">   24019 </span>            : </a>
<a name="24020"><span class="lineNum">   24020 </span>            : #if 1</a>
<a name="24021"><span class="lineNum">   24021 </span>            :   // DQ (6/8/2019): This helps track down where this is being called when are are cleaning up</a>
<a name="24022"><span class="lineNum">   24022 </span>            :   // output spew else the message output at the top of this function will scroll off the screen.</a>
<a name="24023"><span class="lineNum">   24023 </span><span class="lineNoCov">          0 :      printf (&quot;########################################################## \n&quot;);</span></a>
<a name="24024"><span class="lineNum">   24024 </span><span class="lineNoCov">          0 :      printf (&quot;reportModifiedStatements(): Called using label = %s \n&quot;,label.c_str());</span></a>
<a name="24025"><span class="lineNum">   24025 </span>            : #endif</a>
<a name="24026"><span class="lineNum">   24026 </span><span class="lineNoCov">          0 :      printf (&quot;########################################################## \n\n\n&quot;);</span></a>
<a name="24027"><span class="lineNum">   24027 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="24028"><span class="lineNum">   24028 </span>            : </a>
<a name="24029"><span class="lineNum">   24029 </span>            : </a>
<a name="24030"><span class="lineNum">   24030 </span>            : </a>
<a name="24031"><span class="lineNum">   24031 </span>            : </a>
<a name="24032"><span class="lineNum">   24032 </span>            : // DQ (3/22/2019): Translate CPP directives from attached preprocessor information to CPP Directive Declaration IR nodes.</a>
<a name="24033"><span class="lineNum">   24033 </span>            : </a>
<a name="24034"><span class="lineNum">   24034 </span>            : void</a>
<a name="24035"><span class="lineNum">   24035 </span><span class="lineNoCov">          0 : SageInterface::printOutComments ( SgLocatedNode* locatedNode )</span></a>
<a name="24036"><span class="lineNum">   24036 </span>            :    {</a>
<a name="24037"><span class="lineNum">   24037 </span>            :   // Debugging function to print out comments in the statements (added by DQ)</a>
<a name="24038"><span class="lineNum">   24038 </span>            : </a>
<a name="24039"><span class="lineNum">   24039 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="24040"><span class="lineNum">   24040 </span><span class="lineNoCov">          0 :      AttachedPreprocessingInfoType* comments = locatedNode-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="24041"><span class="lineNum">   24041 </span>            : </a>
<a name="24042"><span class="lineNum">   24042 </span>            : #if 0</a>
<a name="24043"><span class="lineNum">   24043 </span>            :      curprint (&quot;/* Inside of printOutComments() */&quot;);</a>
<a name="24044"><span class="lineNum">   24044 </span>            : #endif</a>
<a name="24045"><span class="lineNum">   24045 </span>            : </a>
<a name="24046"><span class="lineNum">   24046 </span><span class="lineNoCov">          0 :      if (comments != NULL)</span></a>
<a name="24047"><span class="lineNum">   24047 </span>            :         {</a>
<a name="24048"><span class="lineNum">   24048 </span>            : #if 0</a>
<a name="24049"><span class="lineNum">   24049 </span>            :           printf (&quot;Found attached comments (at %p of type: %s): \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="24050"><span class="lineNum">   24050 </span>            :           curprint (&quot;/* Inside of printOutComments(): comments != NULL */&quot;);</a>
<a name="24051"><span class="lineNum">   24051 </span>            : #endif</a>
<a name="24052"><span class="lineNum">   24052 </span>            : </a>
<a name="24053"><span class="lineNum">   24053 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType::iterator i;</span></a>
<a name="24054"><span class="lineNum">   24054 </span><span class="lineNoCov">          0 :           for (i = comments-&gt;begin(); i != comments-&gt;end(); i++)</span></a>
<a name="24055"><span class="lineNum">   24055 </span>            :              {</a>
<a name="24056"><span class="lineNum">   24056 </span><span class="lineNoCov">          0 :                ROSE_ASSERT ( (*i) != NULL );</span></a>
<a name="24057"><span class="lineNum">   24057 </span><span class="lineNoCov">          0 :                printf (&quot;          Attached Comment (relativePosition=%s): %s \n&quot;,</span></a>
<a name="24058"><span class="lineNum">   24058 </span>            :                  // DQ (2/11/2021): Fixed to report correct relative locations.</a>
<a name="24059"><span class="lineNum">   24059 </span>            :                  // ((*i)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</a>
<a name="24060"><span class="lineNum">   24060 </span><span class="lineNoCov">          0 :                     PreprocessingInfo::relativePositionName((*i)-&gt;getRelativePosition()).c_str(),</span></a>
<a name="24061"><span class="lineNum">   24061 </span><span class="lineNoCov">          0 :                     (*i)-&gt;getString().c_str());</span></a>
<a name="24062"><span class="lineNum">   24062 </span><span class="lineNoCov">          0 :                printf (&quot;Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*i)-&gt;getNumberOfLines(),(*i)-&gt;getColumnNumberOfEndOfString());</span></a>
<a name="24063"><span class="lineNum">   24063 </span>            :             // curprint (string(&quot;/* Inside of printOutComments(): comments = &quot;) +  (*i)-&gt;getString() + &quot; */&quot;);</a>
<a name="24064"><span class="lineNum">   24064 </span>            : </a>
<a name="24065"><span class="lineNum">   24065 </span>            : #if 0</a>
<a name="24066"><span class="lineNum">   24066 </span>            :                (*i)-&gt;get_file_info()-&gt;display(&quot;comment/directive location&quot;);</a>
<a name="24067"><span class="lineNum">   24067 </span>            : #endif</a>
<a name="24068"><span class="lineNum">   24068 </span>            :              }</a>
<a name="24069"><span class="lineNum">   24069 </span>            :         }</a>
<a name="24070"><span class="lineNum">   24070 </span>            :        else</a>
<a name="24071"><span class="lineNum">   24071 </span>            :         {</a>
<a name="24072"><span class="lineNum">   24072 </span>            : #if 0</a>
<a name="24073"><span class="lineNum">   24073 </span>            :           printf (&quot;In SageInterface::printOutComments(): No attached comments (at %p of type: %s): \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="24074"><span class="lineNum">   24074 </span>            : #endif</a>
<a name="24075"><span class="lineNum">   24075 </span>            :         }</a>
<a name="24076"><span class="lineNum">   24076 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="24077"><span class="lineNum">   24077 </span>            : </a>
<a name="24078"><span class="lineNum">   24078 </span>            : </a>
<a name="24079"><span class="lineNum">   24079 </span>            : </a>
<a name="24080"><span class="lineNum">   24080 </span>            : bool</a>
<a name="24081"><span class="lineNum">   24081 </span><span class="lineNoCov">          0 : SageInterface::skipTranslateToUseCppDeclaration( PreprocessingInfo* currentPreprocessingInfo )</span></a>
<a name="24082"><span class="lineNum">   24082 </span>            :    {</a>
<a name="24083"><span class="lineNum">   24083 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="24084"><span class="lineNum">   24084 </span>            : </a>
<a name="24085"><span class="lineNum">   24085 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(currentPreprocessingInfo != NULL);</span></a>
<a name="24086"><span class="lineNum">   24086 </span>            : </a>
<a name="24087"><span class="lineNum">   24087 </span><span class="lineNoCov">          0 :      PreprocessingInfo::DirectiveType directive = currentPreprocessingInfo-&gt;getTypeOfDirective();</span></a>
<a name="24088"><span class="lineNum">   24088 </span>            : </a>
<a name="24089"><span class="lineNum">   24089 </span><span class="lineNoCov">          0 :      if (directive == PreprocessingInfo::C_StyleComment ||</span></a>
<a name="24090"><span class="lineNum">   24090 </span><span class="lineNoCov">          0 :          directive == PreprocessingInfo::CplusplusStyleComment ||</span></a>
<a name="24091"><span class="lineNum">   24091 </span><span class="lineNoCov">          0 :          directive == PreprocessingInfo::FortranStyleComment ||</span></a>
<a name="24092"><span class="lineNum">   24092 </span><span class="lineNoCov">          0 :          directive == PreprocessingInfo::CpreprocessorBlankLine ||</span></a>
<a name="24093"><span class="lineNum">   24093 </span><span class="lineNoCov">          0 :          directive == PreprocessingInfo::ClinkageSpecificationStart ||</span></a>
<a name="24094"><span class="lineNum">   24094 </span>            :          directive == PreprocessingInfo::ClinkageSpecificationEnd)</a>
<a name="24095"><span class="lineNum">   24095 </span>            :        {</a>
<a name="24096"><span class="lineNum">   24096 </span><span class="lineNoCov">          0 :          returnValue = true;</span></a>
<a name="24097"><span class="lineNum">   24097 </span>            :        }</a>
<a name="24098"><span class="lineNum">   24098 </span>            : </a>
<a name="24099"><span class="lineNum">   24099 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="24100"><span class="lineNum">   24100 </span>            :    }</a>
<a name="24101"><span class="lineNum">   24101 </span>            : </a>
<a name="24102"><span class="lineNum">   24102 </span>            : std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt;</a>
<a name="24103"><span class="lineNum">   24103 </span><span class="lineNoCov">          0 : SageInterface::translateStatementToUseCppDeclarations( SgStatement* statement, SgScopeStatement* scope)</span></a>
<a name="24104"><span class="lineNum">   24104 </span>            :    {</a>
<a name="24105"><span class="lineNum">   24105 </span>            : </a>
<a name="24106"><span class="lineNum">   24106 </span>            : #if 0</a>
<a name="24107"><span class="lineNum">   24107 </span>            :      printOutComments(statement);</a>
<a name="24108"><span class="lineNum">   24108 </span>            : #endif</a>
<a name="24109"><span class="lineNum">   24109 </span>            : </a>
<a name="24110"><span class="lineNum">   24110 </span><span class="lineNoCov">          0 :      std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; directiveList;</span></a>
<a name="24111"><span class="lineNum">   24111 </span>            : </a>
<a name="24112"><span class="lineNum">   24112 </span>            :   // Find existing first and last header.</a>
<a name="24113"><span class="lineNum">   24113 </span><span class="lineNoCov">          0 :      AttachedPreprocessingInfoType *comments = statement-&gt;getAttachedPreprocessingInfo ();</span></a>
<a name="24114"><span class="lineNum">   24114 </span>            : </a>
<a name="24115"><span class="lineNum">   24115 </span><span class="lineNoCov">          0 :      if (comments != NULL)</span></a>
<a name="24116"><span class="lineNum">   24116 </span>            :         {</a>
<a name="24117"><span class="lineNum">   24117 </span>            :        // DQ (3/23/2019): I think we can use this function instead.</a>
<a name="24118"><span class="lineNum">   24118 </span>            :        // SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement::createDirective ( PreprocessingInfo* currentPreprocessingInfo )</a>
<a name="24119"><span class="lineNum">   24119 </span>            : </a>
<a name="24120"><span class="lineNum">   24120 </span>            :        // PreprocessingInfo * firstExistingHeader = NULL;</a>
<a name="24121"><span class="lineNum">   24121 </span>            :        // PreprocessingInfo * lastExistingHeader  = NULL;</a>
<a name="24122"><span class="lineNum">   24122 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType::iterator i; // , firsti, lasti;</span></a>
<a name="24123"><span class="lineNum">   24123 </span><span class="lineNoCov">          0 :           for (i = comments-&gt;begin (); i != comments-&gt;end(); i++)</span></a>
<a name="24124"><span class="lineNum">   24124 </span>            :              {</a>
<a name="24125"><span class="lineNum">   24125 </span><span class="lineNoCov">          0 :                if (skipTranslateToUseCppDeclaration(*i) == true)</span></a>
<a name="24126"><span class="lineNum">   24126 </span>            :                   {</a>
<a name="24127"><span class="lineNum">   24127 </span>            :                  // We are not processing these types of directives into IR nodes (new IR nodes would have to be added and this can be done later if required).</a>
<a name="24128"><span class="lineNum">   24128 </span>            :                   }</a>
<a name="24129"><span class="lineNum">   24129 </span>            :                  else</a>
<a name="24130"><span class="lineNum">   24130 </span>            :                   {</a>
<a name="24131"><span class="lineNum">   24131 </span><span class="lineNoCov">          0 :                     SgC_PreprocessorDirectiveStatement* directive = SgC_PreprocessorDirectiveStatement::createDirective(*i);</span></a>
<a name="24132"><span class="lineNum">   24132 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(directive != NULL);</span></a>
<a name="24133"><span class="lineNum">   24133 </span><span class="lineNoCov">          0 :                     directiveList.push_back(directive);</span></a>
<a name="24134"><span class="lineNum">   24134 </span>            :                   }</a>
<a name="24135"><span class="lineNum">   24135 </span>            : </a>
<a name="24136"><span class="lineNum">   24136 </span><span class="lineNoCov">          0 :                printf (&quot;directiveList.size() = %zu \n&quot;,directiveList.size());</span></a>
<a name="24137"><span class="lineNum">   24137 </span>            :              }</a>
<a name="24138"><span class="lineNum">   24138 </span>            :         }</a>
<a name="24139"><span class="lineNum">   24139 </span>            : </a>
<a name="24140"><span class="lineNum">   24140 </span><span class="lineNoCov">          0 :      return directiveList;</span></a>
<a name="24141"><span class="lineNum">   24141 </span>            :    }</a>
<a name="24142"><span class="lineNum">   24142 </span>            : </a>
<a name="24143"><span class="lineNum">   24143 </span>            : </a>
<a name="24144"><span class="lineNum">   24144 </span>            : void</a>
<a name="24145"><span class="lineNum">   24145 </span><span class="lineNoCov">          0 : SageInterface::translateScopeToUseCppDeclarations( SgScopeStatement* scope )</span></a>
<a name="24146"><span class="lineNum">   24146 </span>            :    {</a>
<a name="24147"><span class="lineNum">   24147 </span><span class="lineNoCov">          0 :      bool declarationsOnly = scope-&gt;containsOnlyDeclarations();</span></a>
<a name="24148"><span class="lineNum">   24148 </span>            : </a>
<a name="24149"><span class="lineNum">   24149 </span><span class="lineNoCov">          0 :      printf (&quot;In translateScopeToUseCppDeclarations(): declarationsOnly = %s scope = %p = %s \n&quot;,declarationsOnly ? &quot;true&quot; : &quot;false&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="24150"><span class="lineNum">   24150 </span>            : </a>
<a name="24151"><span class="lineNum">   24151 </span><span class="lineNoCov">          0 :      std::map&lt;SgStatement*,std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; &gt; directiveMap;</span></a>
<a name="24152"><span class="lineNum">   24152 </span>            : </a>
<a name="24153"><span class="lineNum">   24153 </span><span class="lineNoCov">          0 :      if (declarationsOnly == true)</span></a>
<a name="24154"><span class="lineNum">   24154 </span>            :         {</a>
<a name="24155"><span class="lineNum">   24155 </span>            :        // These are scopes such as global scope, namespace definitions, class definitions, etc.</a>
<a name="24156"><span class="lineNum">   24156 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList &amp; declarationList = scope-&gt;getDeclarationList();</span></a>
<a name="24157"><span class="lineNum">   24157 </span><span class="lineNoCov">          0 :           SgDeclarationStatementPtrList::iterator i = declarationList.begin();</span></a>
<a name="24158"><span class="lineNum">   24158 </span><span class="lineNoCov">          0 :           while (i != declarationList.end())</span></a>
<a name="24159"><span class="lineNum">   24159 </span>            :              {</a>
<a name="24160"><span class="lineNum">   24160 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* declaration = *i;</span></a>
<a name="24161"><span class="lineNum">   24161 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(declaration != NULL);</span></a>
<a name="24162"><span class="lineNum">   24162 </span>            : </a>
<a name="24163"><span class="lineNum">   24163 </span><span class="lineNoCov">          0 :                std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; attachDirectives = translateStatementToUseCppDeclarations(declaration,scope);</span></a>
<a name="24164"><span class="lineNum">   24164 </span>            : </a>
<a name="24165"><span class="lineNum">   24165 </span><span class="lineNoCov">          0 :                printf (&quot;attachDirectives.size() = %zu \n&quot;,attachDirectives.size());</span></a>
<a name="24166"><span class="lineNum">   24166 </span>            : </a>
<a name="24167"><span class="lineNum">   24167 </span><span class="lineNoCov">          0 :                if (attachDirectives.empty() == false)</span></a>
<a name="24168"><span class="lineNum">   24168 </span>            :                   {</a>
<a name="24169"><span class="lineNum">   24169 </span><span class="lineNoCov">          0 :                     directiveMap.insert(std::pair&lt;SgStatement*,std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; &gt;(declaration,attachDirectives));</span></a>
<a name="24170"><span class="lineNum">   24170 </span>            :                   }</a>
<a name="24171"><span class="lineNum">   24171 </span>            : </a>
<a name="24172"><span class="lineNum">   24172 </span><span class="lineNoCov">          0 :                i++;</span></a>
<a name="24173"><span class="lineNum">   24173 </span>            :              }</a>
<a name="24174"><span class="lineNum">   24174 </span>            : </a>
<a name="24175"><span class="lineNum">   24175 </span>            :             // Need to save the list of things that will be added so we can avoid iterator invalidation.</a>
<a name="24176"><span class="lineNum">   24176 </span>            :         }</a>
<a name="24177"><span class="lineNum">   24177 </span>            :        else</a>
<a name="24178"><span class="lineNum">   24178 </span>            :         {</a>
<a name="24179"><span class="lineNum">   24179 </span>            :        // These are scopes such as SgBasicBlock (which can contain non-declaration statements.</a>
<a name="24180"><span class="lineNum">   24180 </span><span class="lineNoCov">          0 :           SgStatementPtrList &amp; statementList = scope-&gt;getStatementList();</span></a>
<a name="24181"><span class="lineNum">   24181 </span><span class="lineNoCov">          0 :           SgStatementPtrList::iterator i = statementList.begin();</span></a>
<a name="24182"><span class="lineNum">   24182 </span><span class="lineNoCov">          0 :           while (i != statementList.end())</span></a>
<a name="24183"><span class="lineNum">   24183 </span>            :              {</a>
<a name="24184"><span class="lineNum">   24184 </span><span class="lineNoCov">          0 :                SgStatement* statement = *i;</span></a>
<a name="24185"><span class="lineNum">   24185 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(statement != NULL);</span></a>
<a name="24186"><span class="lineNum">   24186 </span>            : </a>
<a name="24187"><span class="lineNum">   24187 </span><span class="lineNoCov">          0 :                std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; attachDirectives = translateStatementToUseCppDeclarations(statement,scope);</span></a>
<a name="24188"><span class="lineNum">   24188 </span>            : </a>
<a name="24189"><span class="lineNum">   24189 </span><span class="lineNoCov">          0 :                printf (&quot;attachDirectives.size() = %zu \n&quot;,attachDirectives.size());</span></a>
<a name="24190"><span class="lineNum">   24190 </span>            : </a>
<a name="24191"><span class="lineNum">   24191 </span><span class="lineNoCov">          0 :                if (attachDirectives.empty() == false)</span></a>
<a name="24192"><span class="lineNum">   24192 </span>            :                   {</a>
<a name="24193"><span class="lineNum">   24193 </span><span class="lineNoCov">          0 :                     directiveMap.insert(std::pair&lt;SgStatement*,std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; &gt;(statement,attachDirectives));</span></a>
<a name="24194"><span class="lineNum">   24194 </span>            :                   }</a>
<a name="24195"><span class="lineNum">   24195 </span>            : </a>
<a name="24196"><span class="lineNum">   24196 </span><span class="lineNoCov">          0 :                i++;</span></a>
<a name="24197"><span class="lineNum">   24197 </span>            :              }</a>
<a name="24198"><span class="lineNum">   24198 </span>            :         }</a>
<a name="24199"><span class="lineNum">   24199 </span>            : </a>
<a name="24200"><span class="lineNum">   24200 </span><span class="lineNoCov">          0 :      printf (&quot;directiveMap.size() = %zu \n&quot;,directiveMap.size());</span></a>
<a name="24201"><span class="lineNum">   24201 </span>            : </a>
<a name="24202"><span class="lineNum">   24202 </span><span class="lineNoCov">          0 :      printf (&quot;Processing the directiveMap: \n&quot;);</span></a>
<a name="24203"><span class="lineNum">   24203 </span><span class="lineNoCov">          0 :      std::map&lt;SgStatement*,std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; &gt;::iterator i = directiveMap.begin();</span></a>
<a name="24204"><span class="lineNum">   24204 </span><span class="lineNoCov">          0 :      while (i != directiveMap.end())</span></a>
<a name="24205"><span class="lineNum">   24205 </span>            :         {</a>
<a name="24206"><span class="lineNum">   24206 </span><span class="lineNoCov">          0 :           SgStatement* statement                                      = i-&gt;first;</span></a>
<a name="24207"><span class="lineNum">   24207 </span><span class="lineNoCov">          0 :           std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt; directives = i-&gt;second;</span></a>
<a name="24208"><span class="lineNum">   24208 </span>            : </a>
<a name="24209"><span class="lineNum">   24209 </span><span class="lineNoCov">          0 :           printf (&quot;statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</span></a>
<a name="24210"><span class="lineNum">   24210 </span><span class="lineNoCov">          0 :           printf (&quot;directives.size() = %zu \n&quot;,directives.size());</span></a>
<a name="24211"><span class="lineNum">   24211 </span>            :        // std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt;::reverse_iterator j = directives.begin();</a>
<a name="24212"><span class="lineNum">   24212 </span><span class="lineNoCov">          0 :           std::vector&lt;SgC_PreprocessorDirectiveStatement*&gt;::iterator j = directives.begin();</span></a>
<a name="24213"><span class="lineNum">   24213 </span><span class="lineNoCov">          0 :           while (j != directives.end())</span></a>
<a name="24214"><span class="lineNum">   24214 </span>            :              {</a>
<a name="24215"><span class="lineNum">   24215 </span><span class="lineNoCov">          0 :                scope-&gt;insert_statement(statement,*j);</span></a>
<a name="24216"><span class="lineNum">   24216 </span>            : </a>
<a name="24217"><span class="lineNum">   24217 </span><span class="lineNoCov">          0 :                j++;</span></a>
<a name="24218"><span class="lineNum">   24218 </span>            :              }</a>
<a name="24219"><span class="lineNum">   24219 </span>            : </a>
<a name="24220"><span class="lineNum">   24220 </span>            :        // Remove the directives there were attached to the statement.</a>
<a name="24221"><span class="lineNum">   24221 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType *comments = statement-&gt;getAttachedPreprocessingInfo();</span></a>
<a name="24222"><span class="lineNum">   24222 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(comments != NULL);</span></a>
<a name="24223"><span class="lineNum">   24223 </span>            : </a>
<a name="24224"><span class="lineNum">   24224 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType deleteList;</span></a>
<a name="24225"><span class="lineNum">   24225 </span>            :        // std::vector&lt;PreprocessingInfo*&gt; deleteList;</a>
<a name="24226"><span class="lineNum">   24226 </span>            : </a>
<a name="24227"><span class="lineNum">   24227 </span>            :        // comments-&gt;erase();</a>
<a name="24228"><span class="lineNum">   24228 </span>            :        // statement-&gt;setAttachedPreprocessingInfo(NULL);</a>
<a name="24229"><span class="lineNum">   24229 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType::iterator k;</span></a>
<a name="24230"><span class="lineNum">   24230 </span><span class="lineNoCov">          0 :           for (k = comments-&gt;begin(); k != comments-&gt;end(); k++)</span></a>
<a name="24231"><span class="lineNum">   24231 </span>            :              {</a>
<a name="24232"><span class="lineNum">   24232 </span>            : #if 1</a>
<a name="24233"><span class="lineNum">   24233 </span><span class="lineNoCov">          0 :                ROSE_ASSERT ( (*k) != NULL );</span></a>
<a name="24234"><span class="lineNum">   24234 </span><span class="lineNoCov">          0 :                printf (&quot;          Attached Comment (relativePosition=%s): %s\n&quot;,</span></a>
<a name="24235"><span class="lineNum">   24235 </span><span class="lineNoCov">          0 :                     ((*k)-&gt;getRelativePosition() == PreprocessingInfo::before) ? &quot;before&quot; : &quot;after&quot;,</span></a>
<a name="24236"><span class="lineNum">   24236 </span><span class="lineNoCov">          0 :                     (*k)-&gt;getString().c_str());</span></a>
<a name="24237"><span class="lineNum">   24237 </span><span class="lineNoCov">          0 :                printf (&quot;translateScopeToUseCppDeclarations(): Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n&quot;,(*k)-&gt;getNumberOfLines(),(*k)-&gt;getColumnNumberOfEndOfString());</span></a>
<a name="24238"><span class="lineNum">   24238 </span>            : #endif</a>
<a name="24239"><span class="lineNum">   24239 </span>            : </a>
<a name="24240"><span class="lineNum">   24240 </span>            :             // We only want to process the CPP directives (skipping comments and a few othr kinds of obscure directives).</a>
<a name="24241"><span class="lineNum">   24241 </span><span class="lineNoCov">          0 :                if (skipTranslateToUseCppDeclaration(*k) == true)</span></a>
<a name="24242"><span class="lineNum">   24242 </span>            :                   {</a>
<a name="24243"><span class="lineNum">   24243 </span>            :                  // We are not processing these types of directives into IR nodes (new IR nodes would have to be added and this can be done later if required).</a>
<a name="24244"><span class="lineNum">   24244 </span><span class="lineNoCov">          0 :                     printf (&quot;Do NOT delete *k = %p = %s \n&quot;,*k,(*k)-&gt;getString().c_str());</span></a>
<a name="24245"><span class="lineNum">   24245 </span>            :                   }</a>
<a name="24246"><span class="lineNum">   24246 </span>            :                  else</a>
<a name="24247"><span class="lineNum">   24247 </span>            :                   {</a>
<a name="24248"><span class="lineNum">   24248 </span><span class="lineNoCov">          0 :                     printf (&quot;DO delete *k = %p = %s \n&quot;,*k,(*k)-&gt;getString().c_str());</span></a>
<a name="24249"><span class="lineNum">   24249 </span>            : </a>
<a name="24250"><span class="lineNum">   24250 </span><span class="lineNoCov">          0 :                     deleteList.push_back(*k);</span></a>
<a name="24251"><span class="lineNum">   24251 </span>            :                  // delete *k;</a>
<a name="24252"><span class="lineNum">   24252 </span>            :                  // *k = NULL;</a>
<a name="24253"><span class="lineNum">   24253 </span>            :                   }</a>
<a name="24254"><span class="lineNum">   24254 </span>            :              }</a>
<a name="24255"><span class="lineNum">   24255 </span>            : </a>
<a name="24256"><span class="lineNum">   24256 </span><span class="lineNoCov">          0 :           printf (&quot;Iterate over the deleteList: deleteList.size() = %zu comments-&gt;size() = %zu \n&quot;,deleteList.size(),comments-&gt;size());</span></a>
<a name="24257"><span class="lineNum">   24257 </span><span class="lineNoCov">          0 :           AttachedPreprocessingInfoType::iterator m = deleteList.begin();</span></a>
<a name="24258"><span class="lineNum">   24258 </span><span class="lineNoCov">          0 :           while (m != deleteList.end())</span></a>
<a name="24259"><span class="lineNum">   24259 </span>            :              {</a>
<a name="24260"><span class="lineNum">   24260 </span>            :             // comments-&gt;erase(m);</a>
<a name="24261"><span class="lineNum">   24261 </span>            :             // std::remove(comments-&gt;begin(), comments-&gt;end(), *m);</a>
<a name="24262"><span class="lineNum">   24262 </span><span class="lineNoCov">          0 :                comments-&gt;erase(std::remove(comments-&gt;begin(), comments-&gt;end(), *m), comments-&gt;end());</span></a>
<a name="24263"><span class="lineNum">   24263 </span>            : </a>
<a name="24264"><span class="lineNum">   24264 </span><span class="lineNoCov">          0 :                printf (&quot; --- comments-&gt;size() = %zu \n&quot;,comments-&gt;size());</span></a>
<a name="24265"><span class="lineNum">   24265 </span>            : </a>
<a name="24266"><span class="lineNum">   24266 </span><span class="lineNoCov">          0 :                m++;</span></a>
<a name="24267"><span class="lineNum">   24267 </span>            :              }</a>
<a name="24268"><span class="lineNum">   24268 </span>            : </a>
<a name="24269"><span class="lineNum">   24269 </span>            :        // comments-&gt;clear();</a>
<a name="24270"><span class="lineNum">   24270 </span>            :        // delete comments; // statement-&gt;getAttachedPreprocessingInfoPtr();</a>
<a name="24271"><span class="lineNum">   24271 </span>            :        // statement-&gt;set_attachedPreprocessingInfoPtr(NULL);</a>
<a name="24272"><span class="lineNum">   24272 </span>            : </a>
<a name="24273"><span class="lineNum">   24273 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="24274"><span class="lineNum">   24274 </span>            :         }</a>
<a name="24275"><span class="lineNum">   24275 </span>            : </a>
<a name="24276"><span class="lineNum">   24276 </span><span class="lineNoCov">          0 :      printf (&quot;Leaving translateScopeToUseCppDeclarations(): scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="24277"><span class="lineNum">   24277 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="24278"><span class="lineNum">   24278 </span>            : </a>
<a name="24279"><span class="lineNum">   24279 </span>            : </a>
<a name="24280"><span class="lineNum">   24280 </span>            : void</a>
<a name="24281"><span class="lineNum">   24281 </span><span class="lineNoCov">          0 : SageInterface::translateToUseCppDeclarations( SgNode* n )</span></a>
<a name="24282"><span class="lineNum">   24282 </span>            :    {</a>
<a name="24283"><span class="lineNum">   24283 </span><span class="lineNoCov">          0 :      class CppTranslationTraversal : public AstSimpleProcessing</span></a>
<a name="24284"><span class="lineNum">   24284 </span>            :         {</a>
<a name="24285"><span class="lineNum">   24285 </span>            :           public:</a>
<a name="24286"><span class="lineNum">   24286 </span><span class="lineNoCov">          0 :                CppTranslationTraversal() {}</span></a>
<a name="24287"><span class="lineNum">   24287 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="24288"><span class="lineNum">   24288 </span>            :                   {</a>
<a name="24289"><span class="lineNum">   24289 </span><span class="lineNoCov">          0 :                     printf (&quot;In CppTranslationTraversal::visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</span></a>
<a name="24290"><span class="lineNum">   24290 </span>            : </a>
<a name="24291"><span class="lineNum">   24291 </span><span class="lineNoCov">          0 :                     SgScopeStatement* scope = isSgScopeStatement(node);</span></a>
<a name="24292"><span class="lineNum">   24292 </span><span class="lineNoCov">          0 :                     SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="24293"><span class="lineNum">   24293 </span>            :                  // if (scope != NULL)</a>
<a name="24294"><span class="lineNum">   24294 </span><span class="lineNoCov">          0 :                     if (globalScope != NULL)</span></a>
<a name="24295"><span class="lineNum">   24295 </span>            :                        {</a>
<a name="24296"><span class="lineNum">   24296 </span><span class="lineNoCov">          0 :                          printf (&quot;In CppTranslationTraversal::visit(): processing scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="24297"><span class="lineNum">   24297 </span><span class="lineNoCov">          0 :                          translateScopeToUseCppDeclarations(scope);</span></a>
<a name="24298"><span class="lineNum">   24298 </span>            :                        }</a>
<a name="24299"><span class="lineNum">   24299 </span>            :                       else</a>
<a name="24300"><span class="lineNum">   24300 </span>            :                        {</a>
<a name="24301"><span class="lineNum">   24301 </span><span class="lineNoCov">          0 :                          if (scope != NULL)</span></a>
<a name="24302"><span class="lineNum">   24302 </span>            :                             {</a>
<a name="24303"><span class="lineNum">   24303 </span><span class="lineNoCov">          0 :                               printf (&quot;In SageInterface::translateToUseCppDeclarations(): Currently skipping all but global scope! \n&quot;);</span></a>
<a name="24304"><span class="lineNum">   24304 </span>            :                             }</a>
<a name="24305"><span class="lineNum">   24305 </span>            :                        }</a>
<a name="24306"><span class="lineNum">   24306 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="24307"><span class="lineNum">   24307 </span>            :         };</a>
<a name="24308"><span class="lineNum">   24308 </span>            : </a>
<a name="24309"><span class="lineNum">   24309 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="24310"><span class="lineNum">   24310 </span><span class="lineNoCov">          0 :      CppTranslationTraversal traversal;</span></a>
<a name="24311"><span class="lineNum">   24311 </span>            : </a>
<a name="24312"><span class="lineNum">   24312 </span><span class="lineNoCov">          0 :      printf (&quot;In translateToUseCppDeclarations(): Calling traversal.traverse() \n&quot;);</span></a>
<a name="24313"><span class="lineNum">   24313 </span>            : </a>
<a name="24314"><span class="lineNum">   24314 </span>            :   // We might want to do this traversla POSTORDER since we are transforming the AST at each scope.</a>
<a name="24315"><span class="lineNum">   24315 </span>            :   // traversal.traverse(n, preorder);</a>
<a name="24316"><span class="lineNum">   24316 </span><span class="lineNoCov">          0 :      traversal.traverse(n, postorder);</span></a>
<a name="24317"><span class="lineNum">   24317 </span>            : </a>
<a name="24318"><span class="lineNum">   24318 </span><span class="lineNoCov">          0 :      printf (&quot;Leaving translateToUseCppDeclarations(): DONE: Calling traversal.traverse() \n&quot;);</span></a>
<a name="24319"><span class="lineNum">   24319 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="24320"><span class="lineNum">   24320 </span>            : </a>
<a name="24321"><span class="lineNum">   24321 </span><span class="lineNoCov">          0 : void SageInterface::recursivePrintCurrentAndParent (SgNode* n)</span></a>
<a name="24322"><span class="lineNum">   24322 </span>            : {</a>
<a name="24323"><span class="lineNum">   24323 </span>            :   // print current level's info</a>
<a name="24324"><span class="lineNum">   24324 </span><span class="lineNoCov">          0 :   if (!n) return;</span></a>
<a name="24325"><span class="lineNum">   24325 </span><span class="lineNoCov">          0 :   cout&lt;&lt;&quot;--------------&quot;&lt;&lt;endl;</span></a>
<a name="24326"><span class="lineNum">   24326 </span><span class="lineNoCov">          0 :   cout&lt;&lt;n&lt;&lt;&quot;:&quot;&lt;&lt;n-&gt;class_name()&lt;&lt;  endl;</span></a>
<a name="24327"><span class="lineNum">   24327 </span><span class="lineNoCov">          0 :   if (SgLocatedNode * lnode = isSgLocatedNode(n))</span></a>
<a name="24328"><span class="lineNum">   24328 </span>            :   {</a>
<a name="24329"><span class="lineNum">   24329 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;file info:\t &quot;;</span></a>
<a name="24330"><span class="lineNum">   24330 </span><span class="lineNoCov">          0 :     lnode-&gt;get_file_info()-&gt;display();</span></a>
<a name="24331"><span class="lineNum">   24331 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;\n unparseToString:\t &quot;;</span></a>
<a name="24332"><span class="lineNum">   24332 </span><span class="lineNoCov">          0 :     lnode-&gt;unparseToString();</span></a>
<a name="24333"><span class="lineNum">   24333 </span>            :   }</a>
<a name="24334"><span class="lineNum">   24334 </span>            : </a>
<a name="24335"><span class="lineNum">   24335 </span>            :   // track back to its parent</a>
<a name="24336"><span class="lineNum">   24336 </span><span class="lineNoCov">          0 :   recursivePrintCurrentAndParent (n-&gt;get_parent());</span></a>
<a name="24337"><span class="lineNum">   24337 </span>            : }</a>
<a name="24338"><span class="lineNum">   24338 </span>            : // forward declaration is needed here</a>
<a name="24339"><span class="lineNum">   24339 </span>            : static void serialize(SgNode* node, string&amp; prefix, bool hasRemaining, ostringstream&amp; out, string&amp; edgeLabel);</a>
<a name="24340"><span class="lineNum">   24340 </span>            : </a>
<a name="24341"><span class="lineNum">   24341 </span>            : // A special node in the AST text dump</a>
<a name="24342"><span class="lineNum">   24342 </span><span class="lineNoCov">          0 : static void serialize(SgTemplateArgumentPtrList&amp; plist, string&amp; prefix, bool hasRemaining, ostringstream&amp; out, string&amp; edgeLabel)</span></a>
<a name="24343"><span class="lineNum">   24343 </span>            : {</a>
<a name="24344"><span class="lineNum">   24344 </span><span class="lineNoCov">          0 :   out&lt;&lt;prefix;</span></a>
<a name="24345"><span class="lineNum">   24345 </span><span class="lineNoCov">          0 :   out&lt;&lt; (hasRemaining?&quot;|---&quot;: &quot;|___&quot;);</span></a>
<a name="24346"><span class="lineNum">   24346 </span>            : </a>
<a name="24347"><span class="lineNum">   24347 </span>            : //  out&lt;&lt;&quot;+&quot;&lt;&lt;edgeLabel&lt;&lt;&quot;+&gt;&quot;;</a>
<a name="24348"><span class="lineNum">   24348 </span><span class="lineNoCov">          0 :   out&lt;&lt;&quot; &quot;&lt;&lt;edgeLabel&lt;&lt;&quot; -&gt;&quot;;</span></a>
<a name="24349"><span class="lineNum">   24349 </span>            :   // print address</a>
<a name="24350"><span class="lineNum">   24350 </span><span class="lineNoCov">          0 :   out&lt;&lt;&quot;@&quot;&lt;&lt;&amp;plist&lt;&lt;&quot; &quot;&lt;&lt; &quot;SgTemplateArgumentPtrList &quot;;</span></a>
<a name="24351"><span class="lineNum">   24351 </span>            : </a>
<a name="24352"><span class="lineNum">   24352 </span><span class="lineNoCov">          0 :   out&lt;&lt;endl;</span></a>
<a name="24353"><span class="lineNum">   24353 </span>            : </a>
<a name="24354"><span class="lineNum">   24354 </span><span class="lineNoCov">          0 :   int last_non_null_child_idx =-1;</span></a>
<a name="24355"><span class="lineNum">   24355 </span><span class="lineNoCov">          0 :   for (int i = (int) (plist.size())-1; i&gt;=0; i--)</span></a>
<a name="24356"><span class="lineNum">   24356 </span>            :   {</a>
<a name="24357"><span class="lineNum">   24357 </span><span class="lineNoCov">          0 :     if (plist[i])</span></a>
<a name="24358"><span class="lineNum">   24358 </span>            :     {</a>
<a name="24359"><span class="lineNum">   24359 </span>            :       last_non_null_child_idx = i;</a>
<a name="24360"><span class="lineNum">   24360 </span>            :       break;</a>
<a name="24361"><span class="lineNum">   24361 </span>            :     }</a>
<a name="24362"><span class="lineNum">   24362 </span>            :   }</a>
<a name="24363"><span class="lineNum">   24363 </span>            : </a>
<a name="24364"><span class="lineNum">   24364 </span><span class="lineNoCov">          0 :   for (size_t i=0; i&lt; plist.size(); i++ )</span></a>
<a name="24365"><span class="lineNum">   24365 </span>            :   {</a>
<a name="24366"><span class="lineNum">   24366 </span><span class="lineNoCov">          0 :     bool n_hasRemaining=false;</span></a>
<a name="24367"><span class="lineNum">   24367 </span>            : #if 0</a>
<a name="24368"><span class="lineNum">   24368 </span>            :     if (i+1 &lt; plist.size())</a>
<a name="24369"><span class="lineNum">   24369 </span>            :       n_hasRemaining=true;</a>
<a name="24370"><span class="lineNum">   24370 </span>            : #else</a>
<a name="24371"><span class="lineNum">   24371 </span><span class="lineNoCov">          0 :     if ((int)i&lt; last_non_null_child_idx) n_hasRemaining = true;</span></a>
<a name="24372"><span class="lineNum">   24372 </span>            : #endif</a>
<a name="24373"><span class="lineNum">   24373 </span><span class="lineNoCov">          0 :     string suffix= hasRemaining? &quot;|   &quot; : &quot;    &quot;;</span></a>
<a name="24374"><span class="lineNum">   24374 </span><span class="lineNoCov">          0 :     string n_prefix = prefix+suffix;</span></a>
<a name="24375"><span class="lineNum">   24375 </span><span class="lineNoCov">          0 :     string n_edge_label=&quot;&quot;;</span></a>
<a name="24376"><span class="lineNum">   24376 </span><span class="lineNoCov">          0 :     if (plist[i])</span></a>
<a name="24377"><span class="lineNum">   24377 </span><span class="lineNoCov">          0 :       serialize (plist[i], n_prefix, n_hasRemaining, out,n_edge_label);</span></a>
<a name="24378"><span class="lineNum">   24378 </span>            :   }</a>
<a name="24379"><span class="lineNum">   24379 </span><span class="lineNoCov">          0 : }</span></a>
<a name="24380"><span class="lineNum">   24380 </span>            : </a>
<a name="24381"><span class="lineNum">   24381 </span>            : // print essential information from any AST node</a>
<a name="24382"><span class="lineNum">   24382 </span>            : // hasRemaining if this node has a sibling node to be visited next.</a>
<a name="24383"><span class="lineNum">   24383 </span><span class="lineNoCov">          0 : static void serialize(SgNode* node, string&amp; prefix, bool hasRemaining, ostringstream&amp; out, string&amp; edgeLabel)</span></a>
<a name="24384"><span class="lineNum">   24384 </span>            : {</a>
<a name="24385"><span class="lineNum">   24385 </span>            :   // there may be NULL children!!</a>
<a name="24386"><span class="lineNum">   24386 </span>            :   //if (!node) return;</a>
<a name="24387"><span class="lineNum">   24387 </span>            : </a>
<a name="24388"><span class="lineNum">   24388 </span><span class="lineNoCov">          0 :   out&lt;&lt;prefix;</span></a>
<a name="24389"><span class="lineNum">   24389 </span><span class="lineNoCov">          0 :   out&lt;&lt; (hasRemaining?&quot;|---&quot;: &quot;|___&quot;);</span></a>
<a name="24390"><span class="lineNum">   24390 </span>            : </a>
<a name="24391"><span class="lineNum">   24391 </span><span class="lineNoCov">          0 :   out&lt;&lt;&quot; &quot;&lt;&lt;edgeLabel&lt;&lt;&quot; -&gt;&quot;;</span></a>
<a name="24392"><span class="lineNum">   24392 </span><span class="lineNoCov">          0 :   if (!node)</span></a>
<a name="24393"><span class="lineNum">   24393 </span>            :   {</a>
<a name="24394"><span class="lineNum">   24394 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; NULL &quot;&lt;&lt;endl;</span></a>
<a name="24395"><span class="lineNum">   24395 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="24396"><span class="lineNum">   24396 </span>            :   }</a>
<a name="24397"><span class="lineNum">   24397 </span>            : </a>
<a name="24398"><span class="lineNum">   24398 </span>            :   // print address</a>
<a name="24399"><span class="lineNum">   24399 </span><span class="lineNoCov">          0 :   out&lt;&lt;&quot;@&quot;&lt;&lt;node&lt;&lt;&quot; &quot;&lt;&lt; node-&gt;class_name()&lt;&lt;&quot; &quot;;</span></a>
<a name="24400"><span class="lineNum">   24400 </span>            : </a>
<a name="24401"><span class="lineNum">   24401 </span>            :   //optionally file info</a>
<a name="24402"><span class="lineNum">   24402 </span><span class="lineNoCov">          0 :   if (SgLocatedNode* lnode= isSgLocatedNode(node))</span></a>
<a name="24403"><span class="lineNum">   24403 </span>            :   {</a>
<a name="24404"><span class="lineNum">   24404 </span><span class="lineNoCov">          0 :     out&lt;&lt; Rose::StringUtility::stripPathFromFileName ( lnode-&gt;get_file_info()-&gt;get_filename() )&lt;&lt;&quot; &quot;&lt;&lt;lnode-&gt;get_file_info()-&gt;get_line()&lt;&lt;&quot;:&quot;&lt;&lt;lnode-&gt;get_file_info()-&gt;get_col();</span></a>
<a name="24405"><span class="lineNum">   24405 </span>            :   }</a>
<a name="24406"><span class="lineNum">   24406 </span>            : </a>
<a name="24407"><span class="lineNum">   24407 </span><span class="lineNoCov">          0 :   if (SgDeclarationStatement* v= isSgDeclarationStatement(node))</span></a>
<a name="24408"><span class="lineNum">   24408 </span>            :   {</a>
<a name="24409"><span class="lineNum">   24409 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; first nondefining decl@&quot;&lt;&lt; v-&gt;get_firstNondefiningDeclaration();</span></a>
<a name="24410"><span class="lineNum">   24410 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; defining decl@&quot;&lt;&lt; v-&gt;get_definingDeclaration();</span></a>
<a name="24411"><span class="lineNum">   24411 </span>            :   }</a>
<a name="24412"><span class="lineNum">   24412 </span>            : </a>
<a name="24413"><span class="lineNum">   24413 </span><span class="lineNoCov">          0 :   if (SgEnumVal* f = isSgEnumVal(node) )</span></a>
<a name="24414"><span class="lineNum">   24414 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; f-&gt;get_value() &lt;&lt;&quot; declaration=&quot;&lt;&lt;f-&gt;get_declaration() &lt;&lt; &quot; name=&quot;&lt;&lt; f-&gt;get_name().getString();</span></a>
<a name="24415"><span class="lineNum">   24415 </span>            :   // optionally  qualified name</a>
<a name="24416"><span class="lineNum">   24416 </span>            : </a>
<a name="24417"><span class="lineNum">   24417 </span><span class="lineNoCov">          0 :   if (SgFunctionDeclaration* f = isSgFunctionDeclaration(node) )</span></a>
<a name="24418"><span class="lineNum">   24418 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; &quot;&lt;&lt; f-&gt;get_qualified_name();</span></a>
<a name="24419"><span class="lineNum">   24419 </span>            : </a>
<a name="24420"><span class="lineNum">   24420 </span><span class="lineNoCov">          0 :   if (SgClassDeclaration* f = isSgClassDeclaration(node) )</span></a>
<a name="24421"><span class="lineNum">   24421 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; &quot;&lt;&lt; f-&gt;get_qualified_name();</span></a>
<a name="24422"><span class="lineNum">   24422 </span>            : </a>
<a name="24423"><span class="lineNum">   24423 </span><span class="lineNoCov">          0 :   if (SgTypedefDeclaration* f = isSgTypedefDeclaration(node) )</span></a>
<a name="24424"><span class="lineNum">   24424 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; &quot;&lt;&lt; f-&gt;get_qualified_name();</span></a>
<a name="24425"><span class="lineNum">   24425 </span>            : </a>
<a name="24426"><span class="lineNum">   24426 </span><span class="lineNoCov">          0 :   if (SgInitializedName * v = isSgInitializedName(node) )</span></a>
<a name="24427"><span class="lineNum">   24427 </span>            :   {</a>
<a name="24428"><span class="lineNum">   24428 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; &quot;&lt;&lt; v-&gt;get_qualified_name();</span></a>
<a name="24429"><span class="lineNum">   24429 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; type@&quot;&lt;&lt; v-&gt;get_type();</span></a>
<a name="24430"><span class="lineNum">   24430 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; initializer@&quot;&lt;&lt; v-&gt;get_initializer();</span></a>
<a name="24431"><span class="lineNum">   24431 </span>            : //    type_set.insert (v-&gt;get_type());</a>
<a name="24432"><span class="lineNum">   24432 </span>            :   }</a>
<a name="24433"><span class="lineNum">   24433 </span>            : </a>
<a name="24434"><span class="lineNum">   24434 </span>            :   // associated class, function and variable declarations</a>
<a name="24435"><span class="lineNum">   24435 </span><span class="lineNoCov">          0 :   if (SgTemplateInstantiationDecl* f = isSgTemplateInstantiationDecl(node) )</span></a>
<a name="24436"><span class="lineNum">   24436 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; template class decl@&quot;&lt;&lt; f-&gt;get_templateDeclaration();</span></a>
<a name="24437"><span class="lineNum">   24437 </span>            : </a>
<a name="24438"><span class="lineNum">   24438 </span><span class="lineNoCov">          0 :   if (SgMemberFunctionDeclaration* f = isSgMemberFunctionDeclaration(node) )</span></a>
<a name="24439"><span class="lineNum">   24439 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; assoc. class decl@&quot;&lt;&lt; f-&gt;get_associatedClassDeclaration();</span></a>
<a name="24440"><span class="lineNum">   24440 </span>            : </a>
<a name="24441"><span class="lineNum">   24441 </span><span class="lineNoCov">          0 :   if (SgConstructorInitializer* ctor= isSgConstructorInitializer(node) )</span></a>
<a name="24442"><span class="lineNum">   24442 </span>            :   {</a>
<a name="24443"><span class="lineNum">   24443 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; member function decl@&quot;&lt;&lt; ctor-&gt;get_declaration();</span></a>
<a name="24444"><span class="lineNum">   24444 </span>            :   }</a>
<a name="24445"><span class="lineNum">   24445 </span>            : </a>
<a name="24446"><span class="lineNum">   24446 </span><span class="lineNoCov">          0 :   if (SgIntVal* v= isSgIntVal(node))</span></a>
<a name="24447"><span class="lineNum">   24447 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24448"><span class="lineNum">   24448 </span>            : </a>
<a name="24449"><span class="lineNum">   24449 </span><span class="lineNoCov">          0 :   if (SgShortVal* v= isSgShortVal(node))</span></a>
<a name="24450"><span class="lineNum">   24450 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24451"><span class="lineNum">   24451 </span>            : </a>
<a name="24452"><span class="lineNum">   24452 </span><span class="lineNoCov">          0 :   if (SgLongIntVal* v= isSgLongIntVal(node))</span></a>
<a name="24453"><span class="lineNum">   24453 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24454"><span class="lineNum">   24454 </span>            : </a>
<a name="24455"><span class="lineNum">   24455 </span><span class="lineNoCov">          0 :   if (SgLongLongIntVal* v= isSgLongLongIntVal(node))</span></a>
<a name="24456"><span class="lineNum">   24456 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24457"><span class="lineNum">   24457 </span>            : </a>
<a name="24458"><span class="lineNum">   24458 </span><span class="lineNoCov">          0 :   if (SgUnsignedIntVal* v= isSgUnsignedIntVal(node))</span></a>
<a name="24459"><span class="lineNum">   24459 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24460"><span class="lineNum">   24460 </span>            : </a>
<a name="24461"><span class="lineNum">   24461 </span><span class="lineNoCov">          0 :   if (SgUnsignedShortVal* v= isSgUnsignedShortVal(node))</span></a>
<a name="24462"><span class="lineNum">   24462 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24463"><span class="lineNum">   24463 </span>            : </a>
<a name="24464"><span class="lineNum">   24464 </span><span class="lineNoCov">          0 :   if (SgUnsignedLongVal* v= isSgUnsignedLongVal(node))</span></a>
<a name="24465"><span class="lineNum">   24465 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24466"><span class="lineNum">   24466 </span>            : </a>
<a name="24467"><span class="lineNum">   24467 </span><span class="lineNoCov">          0 :   if (SgUnsignedLongLongIntVal* v= isSgUnsignedLongLongIntVal(node))</span></a>
<a name="24468"><span class="lineNum">   24468 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24469"><span class="lineNum">   24469 </span>            : </a>
<a name="24470"><span class="lineNum">   24470 </span><span class="lineNoCov">          0 :   if (SgFloatVal* v= isSgFloatVal(node))</span></a>
<a name="24471"><span class="lineNum">   24471 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24472"><span class="lineNum">   24472 </span>            : </a>
<a name="24473"><span class="lineNum">   24473 </span><span class="lineNoCov">          0 :   if (SgDoubleVal* v= isSgDoubleVal(node))</span></a>
<a name="24474"><span class="lineNum">   24474 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24475"><span class="lineNum">   24475 </span>            : </a>
<a name="24476"><span class="lineNum">   24476 </span><span class="lineNoCov">          0 :   if (SgLongDoubleVal* v= isSgLongDoubleVal(node))</span></a>
<a name="24477"><span class="lineNum">   24477 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; value=&quot;&lt;&lt; v-&gt;get_value() &lt;&lt;&quot; valueString=&quot;&lt;&lt; v-&gt;get_valueString();</span></a>
<a name="24478"><span class="lineNum">   24478 </span>            : </a>
<a name="24479"><span class="lineNum">   24479 </span><span class="lineNoCov">          0 :   if (SgVarRefExp* var_ref= isSgVarRefExp(node) )</span></a>
<a name="24480"><span class="lineNum">   24480 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; init name@&quot;&lt;&lt; var_ref-&gt;get_symbol()-&gt;get_declaration() &lt;&lt;&quot; symbol name=&quot;&lt;&lt;var_ref-&gt;get_symbol()-&gt;get_name();</span></a>
<a name="24481"><span class="lineNum">   24481 </span>            : </a>
<a name="24482"><span class="lineNum">   24482 </span><span class="lineNoCov">          0 :   if (SgMemberFunctionRefExp* func_ref= isSgMemberFunctionRefExp(node) )</span></a>
<a name="24483"><span class="lineNum">   24483 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; member func decl@&quot;&lt;&lt; func_ref-&gt;get_symbol_i()-&gt;get_declaration();</span></a>
<a name="24484"><span class="lineNum">   24484 </span>            : </a>
<a name="24485"><span class="lineNum">   24485 </span><span class="lineNoCov">          0 :   if (SgTemplateInstantiationMemberFunctionDecl* cnode= isSgTemplateInstantiationMemberFunctionDecl(node) )</span></a>
<a name="24486"><span class="lineNum">   24486 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; template member func decl@&quot;&lt;&lt; cnode-&gt;get_templateDeclaration();</span></a>
<a name="24487"><span class="lineNum">   24487 </span>            : </a>
<a name="24488"><span class="lineNum">   24488 </span><span class="lineNoCov">          0 :   if (SgFunctionRefExp* func_ref= isSgFunctionRefExp(node) )</span></a>
<a name="24489"><span class="lineNum">   24489 </span>            :   {</a>
<a name="24490"><span class="lineNum">   24490 </span><span class="lineNoCov">          0 :     SgFunctionSymbol* sym= func_ref-&gt;get_symbol_i();</span></a>
<a name="24491"><span class="lineNum">   24491 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; func decl@&quot;&lt;&lt; sym-&gt;get_declaration() &lt;&lt; &quot; func sym name=&quot;&lt;&lt;sym-&gt;get_name();</span></a>
<a name="24492"><span class="lineNum">   24492 </span>            :   }</a>
<a name="24493"><span class="lineNum">   24493 </span>            : </a>
<a name="24494"><span class="lineNum">   24494 </span>            :   // base type of several types of nodes:</a>
<a name="24495"><span class="lineNum">   24495 </span><span class="lineNoCov">          0 :   if (SgTypedefDeclaration * v= isSgTypedefDeclaration(node))</span></a>
<a name="24496"><span class="lineNum">   24496 </span>            :   {</a>
<a name="24497"><span class="lineNum">   24497 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; base_type@&quot;&lt;&lt; v-&gt;get_base_type();</span></a>
<a name="24498"><span class="lineNum">   24498 </span>            : //    type_set.insert (v-&gt;get_base_type());</a>
<a name="24499"><span class="lineNum">   24499 </span>            :   }</a>
<a name="24500"><span class="lineNum">   24500 </span>            : </a>
<a name="24501"><span class="lineNum">   24501 </span><span class="lineNoCov">          0 :   if (SgArrayType* v= isSgArrayType(node))</span></a>
<a name="24502"><span class="lineNum">   24502 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; base_type@&quot;&lt;&lt; v-&gt;get_base_type();</span></a>
<a name="24503"><span class="lineNum">   24503 </span>            : </a>
<a name="24504"><span class="lineNum">   24504 </span><span class="lineNoCov">          0 :   if (SgTypeExpression* v= isSgTypeExpression(node))</span></a>
<a name="24505"><span class="lineNum">   24505 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; type@&quot;&lt;&lt; v-&gt;get_type();</span></a>
<a name="24506"><span class="lineNum">   24506 </span>            : </a>
<a name="24507"><span class="lineNum">   24507 </span><span class="lineNoCov">          0 :   if (SgUsingDirectiveStatement* v= isSgUsingDirectiveStatement(node))</span></a>
<a name="24508"><span class="lineNum">   24508 </span><span class="lineNoCov">          0 :     out&lt;&lt;&quot; namespaceDeclaration=&quot;&lt;&lt; v-&gt;get_namespaceDeclaration();</span></a>
<a name="24509"><span class="lineNum">   24509 </span>            : </a>
<a name="24510"><span class="lineNum">   24510 </span><span class="lineNoCov">          0 :   out&lt;&lt;endl;</span></a>
<a name="24511"><span class="lineNum">   24511 </span>            : </a>
<a name="24512"><span class="lineNum">   24512 </span><span class="lineNoCov">          0 :   std::vector&lt;SgNode* &gt; children = node-&gt;get_traversalSuccessorContainer();</span></a>
<a name="24513"><span class="lineNum">   24513 </span>            : #if 0</a>
<a name="24514"><span class="lineNum">   24514 </span>            :   int total_count = children.size();</a>
<a name="24515"><span class="lineNum">   24515 </span>            :   int current_index=0;</a>
<a name="24516"><span class="lineNum">   24516 </span>            : #endif</a>
<a name="24517"><span class="lineNum">   24517 </span>            : </a>
<a name="24518"><span class="lineNum">   24518 </span><span class="lineNoCov">          0 :   int last_non_null_child_idx =-1;</span></a>
<a name="24519"><span class="lineNum">   24519 </span><span class="lineNoCov">          0 :   for (int i = (int) (children.size())-1; i&gt;=0; i--)</span></a>
<a name="24520"><span class="lineNum">   24520 </span>            :   {</a>
<a name="24521"><span class="lineNum">   24521 </span><span class="lineNoCov">          0 :     if (children[i])</span></a>
<a name="24522"><span class="lineNum">   24522 </span>            :     {</a>
<a name="24523"><span class="lineNum">   24523 </span>            :       last_non_null_child_idx = i;</a>
<a name="24524"><span class="lineNum">   24524 </span>            :       break;</a>
<a name="24525"><span class="lineNum">   24525 </span>            :     }</a>
<a name="24526"><span class="lineNum">   24526 </span>            :   }</a>
<a name="24527"><span class="lineNum">   24527 </span>            : </a>
<a name="24528"><span class="lineNum">   24528 </span>            : #if 0</a>
<a name="24529"><span class="lineNum">   24529 </span>            :   // some Sg??PtrList are not AST nodes, not part of children , we need to handle them separatedly</a>
<a name="24530"><span class="lineNum">   24530 </span>            :   // we sum all children into single total_count to tell if there is remaining children.</a>
<a name="24531"><span class="lineNum">   24531 </span>            :   if (isSgTemplateInstantiationDecl (node))</a>
<a name="24532"><span class="lineNum">   24532 </span>            :     total_count += 1; // sn-&gt;get_templateArguments().size();</a>
<a name="24533"><span class="lineNum">   24533 </span>            : #endif</a>
<a name="24534"><span class="lineNum">   24534 </span>            : </a>
<a name="24535"><span class="lineNum">   24535 </span>            :    // handling SgTemplateArgumentPtrList first</a>
<a name="24536"><span class="lineNum">   24536 </span><span class="lineNoCov">          0 :   if (SgTemplateInstantiationDecl* sn = isSgTemplateInstantiationDecl (node))</span></a>
<a name="24537"><span class="lineNum">   24537 </span>            :   {</a>
<a name="24538"><span class="lineNum">   24538 </span><span class="lineNoCov">          0 :     SgTemplateArgumentPtrList&amp; plist = sn-&gt;get_templateArguments();</span></a>
<a name="24539"><span class="lineNum">   24539 </span><span class="lineNoCov">          0 :      bool n_hasRemaining=false;</span></a>
<a name="24540"><span class="lineNum">   24540 </span>            : #if 0</a>
<a name="24541"><span class="lineNum">   24541 </span>            :     if (current_index+1&lt;total_count)</a>
<a name="24542"><span class="lineNum">   24542 </span>            :       n_hasRemaining=true;</a>
<a name="24543"><span class="lineNum">   24543 </span>            :     current_index++;</a>
<a name="24544"><span class="lineNum">   24544 </span>            : #else</a>
<a name="24545"><span class="lineNum">   24545 </span><span class="lineNoCov">          0 :     if (last_non_null_child_idx&gt;-1) n_hasRemaining = true;</span></a>
<a name="24546"><span class="lineNum">   24546 </span>            : #endif</a>
<a name="24547"><span class="lineNum">   24547 </span><span class="lineNoCov">          0 :     string suffix= hasRemaining? &quot;|   &quot; : &quot;    &quot;;</span></a>
<a name="24548"><span class="lineNum">   24548 </span><span class="lineNoCov">          0 :     string n_prefix = prefix+suffix;</span></a>
<a name="24549"><span class="lineNum">   24549 </span><span class="lineNoCov">          0 :     string n_edge_label= &quot;&quot;;</span></a>
<a name="24550"><span class="lineNum">   24550 </span><span class="lineNoCov">          0 :     serialize(plist, n_prefix, n_hasRemaining, out, n_edge_label);</span></a>
<a name="24551"><span class="lineNum">   24551 </span>            :   }</a>
<a name="24552"><span class="lineNum">   24552 </span>            : </a>
<a name="24553"><span class="lineNum">   24553 </span><span class="lineNoCov">          0 :   std::vector&lt; std::string &gt;  successorNames= node-&gt;get_traversalSuccessorNamesContainer();</span></a>
<a name="24554"><span class="lineNum">   24554 </span>            : </a>
<a name="24555"><span class="lineNum">   24555 </span>            :    // finish sucessors</a>
<a name="24556"><span class="lineNum">   24556 </span><span class="lineNoCov">          0 :   for (size_t i =0; i&lt; children.size(); i++)</span></a>
<a name="24557"><span class="lineNum">   24557 </span>            :   {</a>
<a name="24558"><span class="lineNum">   24558 </span><span class="lineNoCov">          0 :     bool n_hasRemaining=false;</span></a>
<a name="24559"><span class="lineNum">   24559 </span>            : #if 0</a>
<a name="24560"><span class="lineNum">   24560 </span>            :     if (current_index+1&lt;total_count)</a>
<a name="24561"><span class="lineNum">   24561 </span>            :       n_hasRemaining=true;</a>
<a name="24562"><span class="lineNum">   24562 </span>            :     current_index++;</a>
<a name="24563"><span class="lineNum">   24563 </span>            : #else</a>
<a name="24564"><span class="lineNum">   24564 </span><span class="lineNoCov">          0 :     if ((int)i&lt;last_non_null_child_idx) n_hasRemaining = true;</span></a>
<a name="24565"><span class="lineNum">   24565 </span>            : #endif</a>
<a name="24566"><span class="lineNum">   24566 </span><span class="lineNoCov">          0 :     string suffix= hasRemaining? &quot;|   &quot; : &quot;    &quot;;</span></a>
<a name="24567"><span class="lineNum">   24567 </span><span class="lineNoCov">          0 :     string n_prefix = prefix+suffix;</span></a>
<a name="24568"><span class="lineNum">   24568 </span><span class="lineNoCov">          0 :     if (children[i])</span></a>
<a name="24569"><span class="lineNum">   24569 </span><span class="lineNoCov">          0 :       serialize (children[i], n_prefix, n_hasRemaining, out, successorNames[i]);</span></a>
<a name="24570"><span class="lineNum">   24570 </span>            :   }</a>
<a name="24571"><span class="lineNum">   24571 </span>            : }</a>
<a name="24572"><span class="lineNum">   24572 </span>            : </a>
<a name="24573"><span class="lineNum">   24573 </span><span class="lineNoCov">          0 : void SageInterface::printAST(SgNode* node)</span></a>
<a name="24574"><span class="lineNum">   24574 </span>            : {</a>
<a name="24575"><span class="lineNum">   24575 </span><span class="lineNoCov">          0 :   ostringstream oss;</span></a>
<a name="24576"><span class="lineNum">   24576 </span><span class="lineNoCov">          0 :   string prefix;</span></a>
<a name="24577"><span class="lineNum">   24577 </span><span class="lineNoCov">          0 :   string label=&quot;&quot;;</span></a>
<a name="24578"><span class="lineNum">   24578 </span><span class="lineNoCov">          0 :   serialize(node, prefix, false, oss, label);</span></a>
<a name="24579"><span class="lineNum">   24579 </span><span class="lineNoCov">          0 :   cout&lt;&lt;oss.str();</span></a>
<a name="24580"><span class="lineNum">   24580 </span><span class="lineNoCov">          0 : }</span></a>
<a name="24581"><span class="lineNum">   24581 </span>            : </a>
<a name="24582"><span class="lineNum">   24582 </span><span class="lineNoCov">          0 : void SageInterface::printAST2TextFile (SgNode* node, std::string filename, bool printType/*=true*/)</span></a>
<a name="24583"><span class="lineNum">   24583 </span>            : {</a>
<a name="24584"><span class="lineNum">   24584 </span>            :   // Rasmussen 9/21/2020: This leads to infinite recursion (clang warning message) and should be removed from API)</a>
<a name="24585"><span class="lineNum">   24585 </span>            : //  ROSE_ABORT();</a>
<a name="24586"><span class="lineNum">   24586 </span><span class="lineNoCov">          0 :   printAST2TextFile (node, filename.c_str(), printType);</span></a>
<a name="24587"><span class="lineNum">   24587 </span><span class="lineNoCov">          0 : }</span></a>
<a name="24588"><span class="lineNum">   24588 </span>            : </a>
<a name="24589"><span class="lineNum">   24589 </span><span class="lineNoCov">          0 : void SageInterface::printAST2TextFile(SgNode* node, const char* filename, bool printType/*=true*/)</span></a>
<a name="24590"><span class="lineNum">   24590 </span>            : {</a>
<a name="24591"><span class="lineNum">   24591 </span><span class="lineNoCov">          0 :   ostringstream oss;</span></a>
<a name="24592"><span class="lineNum">   24592 </span><span class="lineNoCov">          0 :   string prefix;</span></a>
<a name="24593"><span class="lineNum">   24593 </span><span class="lineNoCov">          0 :   string label=&quot;&quot;;</span></a>
<a name="24594"><span class="lineNum">   24594 </span><span class="lineNoCov">          0 :   serialize(node, prefix, false, oss, label);</span></a>
<a name="24595"><span class="lineNum">   24595 </span><span class="lineNoCov">          0 :   ofstream textfile;</span></a>
<a name="24596"><span class="lineNum">   24596 </span><span class="lineNoCov">          0 :   textfile.open(filename, ios::out);</span></a>
<a name="24597"><span class="lineNum">   24597 </span><span class="lineNoCov">          0 :   textfile&lt;&lt;oss.str();</span></a>
<a name="24598"><span class="lineNum">   24598 </span>            : </a>
<a name="24599"><span class="lineNum">   24599 </span><span class="lineNoCov">          0 :   if (printType)</span></a>
<a name="24600"><span class="lineNum">   24600 </span>            :   {</a>
<a name="24601"><span class="lineNum">   24601 </span>            :     // append type information also</a>
<a name="24602"><span class="lineNum">   24602 </span><span class="lineNoCov">          0 :     textfile&lt;&lt;&quot;Types encountered ....&quot;&lt;&lt;endl;</span></a>
<a name="24603"><span class="lineNum">   24603 </span><span class="lineNoCov">          0 :     ostringstream oss2;</span></a>
<a name="24604"><span class="lineNum">   24604 </span><span class="lineNoCov">          0 :     VariantVector vv(V_SgType);</span></a>
<a name="24605"><span class="lineNum">   24605 </span><span class="lineNoCov">          0 :     Rose_STL_Container&lt;SgNode*&gt; tnodes= NodeQuery::queryMemoryPool(vv);</span></a>
<a name="24606"><span class="lineNum">   24606 </span><span class="lineNoCov">          0 :     for (Rose_STL_Container&lt;SgNode*&gt;::const_iterator i = tnodes.begin(); i != tnodes.end(); ++i)</span></a>
<a name="24607"><span class="lineNum">   24607 </span>            :     {</a>
<a name="24608"><span class="lineNum">   24608 </span><span class="lineNoCov">          0 :       serialize (*i, prefix, false, oss2, label);</span></a>
<a name="24609"><span class="lineNum">   24609 </span>            :     }</a>
<a name="24610"><span class="lineNum">   24610 </span><span class="lineNoCov">          0 :     textfile&lt;&lt;oss2.str();</span></a>
<a name="24611"><span class="lineNum">   24611 </span>            :   }</a>
<a name="24612"><span class="lineNum">   24612 </span>            : </a>
<a name="24613"><span class="lineNum">   24613 </span><span class="lineNoCov">          0 :   textfile.close();</span></a>
<a name="24614"><span class="lineNum">   24614 </span><span class="lineNoCov">          0 : }</span></a>
<a name="24615"><span class="lineNum">   24615 </span>            : </a>
<a name="24616"><span class="lineNum">   24616 </span><span class="lineCov">          1 : void SageInterface:: saveToPDF(SgNode* node)</span></a>
<a name="24617"><span class="lineNum">   24617 </span>            : {</a>
<a name="24618"><span class="lineNum">   24618 </span><span class="lineCov">          1 :   saveToPDF(node, string(&quot;temp.pdf&quot;) );</span></a>
<a name="24619"><span class="lineNum">   24619 </span><span class="lineCov">          1 : }</span></a>
<a name="24620"><span class="lineNum">   24620 </span>            : //! Save AST into a pdf file, start from a node to find its enclosing file node. The entire file's AST will be saved into a pdf.</a>
<a name="24621"><span class="lineNum">   24621 </span><span class="lineCov">          1 : void SageInterface:: saveToPDF(SgNode* node, std::string filename)</span></a>
<a name="24622"><span class="lineNum">   24622 </span>            : {</a>
<a name="24623"><span class="lineNum">   24623 </span><span class="lineCov">          1 :   ROSE_ASSERT(node != NULL);</span></a>
<a name="24624"><span class="lineNum">   24624 </span>            : #if ROSE_WITH_LIBHARU</a>
<a name="24625"><span class="lineNum">   24625 </span><span class="lineCov">          1 :   AstPDFGeneration pdf;</span></a>
<a name="24626"><span class="lineNum">   24626 </span><span class="lineCov">          1 :   pdf.generateWithinFile(filename, getEnclosingFileNode(node));</span></a>
<a name="24627"><span class="lineNum">   24627 </span>            : #else</a>
<a name="24628"><span class="lineNum">   24628 </span>            :      printf (&quot;Warning: libharu support is not enabled\n&quot;);</a>
<a name="24629"><span class="lineNum">   24629 </span>            : #endif</a>
<a name="24630"><span class="lineNum">   24630 </span><span class="lineCov">          1 : }</span></a>
<a name="24631"><span class="lineNum">   24631 </span>            : </a>
<a name="24632"><span class="lineNum">   24632 </span><span class="lineNoCov">          0 : bool SageInterface::insideSystemHeader (SgLocatedNode* node)</span></a>
<a name="24633"><span class="lineNum">   24633 </span>            : {</a>
<a name="24634"><span class="lineNum">   24634 </span><span class="lineNoCov">          0 :   bool rtval = false;</span></a>
<a name="24635"><span class="lineNum">   24635 </span><span class="lineNoCov">          0 :   ROSE_ASSERT (node != NULL);</span></a>
<a name="24636"><span class="lineNum">   24636 </span><span class="lineNoCov">          0 :   Sg_File_Info* finfo = node-&gt;get_file_info();</span></a>
<a name="24637"><span class="lineNum">   24637 </span><span class="lineNoCov">          0 :   if (finfo!=NULL)</span></a>
<a name="24638"><span class="lineNum">   24638 </span>            :   {</a>
<a name="24639"><span class="lineNum">   24639 </span><span class="lineNoCov">          0 :     string fname = finfo-&gt;get_filenameString();</span></a>
<a name="24640"><span class="lineNum">   24640 </span><span class="lineNoCov">          0 :     string buildtree_str1 = string(&quot;include-staging/gcc_HEADERS&quot;);</span></a>
<a name="24641"><span class="lineNum">   24641 </span><span class="lineNoCov">          0 :     string buildtree_str2 = string(&quot;include-staging/g++_HEADERS&quot;);</span></a>
<a name="24642"><span class="lineNum">   24642 </span><span class="lineNoCov">          0 :     string installtree_str1 = string(&quot;include/edg/gcc_HEADERS&quot;);</span></a>
<a name="24643"><span class="lineNum">   24643 </span><span class="lineNoCov">          0 :     string installtree_str2 = string(&quot;include/edg/g++_HEADERS&quot;);</span></a>
<a name="24644"><span class="lineNum">   24644 </span><span class="lineNoCov">          0 :     string system_headers = string(&quot;/usr/include&quot;);</span></a>
<a name="24645"><span class="lineNum">   24645 </span>            :     // if the file name has a sys header path of either source or build tree</a>
<a name="24646"><span class="lineNum">   24646 </span><span class="lineNoCov">          0 :     if ((fname.find (buildtree_str1, 0) != string::npos) ||</span></a>
<a name="24647"><span class="lineNum">   24647 </span><span class="lineNoCov">          0 :         (fname.find (buildtree_str2, 0) != string::npos) ||</span></a>
<a name="24648"><span class="lineNum">   24648 </span><span class="lineNoCov">          0 :         (fname.find (installtree_str1, 0) != string::npos) ||</span></a>
<a name="24649"><span class="lineNum">   24649 </span><span class="lineNoCov">          0 :         (fname.find (installtree_str2, 0) != string::npos) ||</span></a>
<a name="24650"><span class="lineNum">   24650 </span><span class="lineNoCov">          0 :         (fname.find (system_headers, 0) != string::npos)</span></a>
<a name="24651"><span class="lineNum">   24651 </span>            :        )</a>
<a name="24652"><span class="lineNum">   24652 </span>            :       rtval = true;</a>
<a name="24653"><span class="lineNum">   24653 </span>            :   }</a>
<a name="24654"><span class="lineNum">   24654 </span><span class="lineNoCov">          0 :   return rtval;</span></a>
<a name="24655"><span class="lineNum">   24655 </span>            : }</a>
<a name="24656"><span class="lineNum">   24656 </span>            : </a>
<a name="24657"><span class="lineNum">   24657 </span>            : </a>
<a name="24658"><span class="lineNum">   24658 </span>            : // DQ (2/27/2021): Adding support to detect if a SgLocatedNode is located in a header file.</a>
<a name="24659"><span class="lineNum">   24659 </span><span class="lineNoCov">          0 : bool SageInterface::insideHeader (SgLocatedNode* node)</span></a>
<a name="24660"><span class="lineNum">   24660 </span>            :    {</a>
<a name="24661"><span class="lineNum">   24661 </span>            :   // Check if a node is from a header file</a>
<a name="24662"><span class="lineNum">   24662 </span>            : </a>
<a name="24663"><span class="lineNum">   24663 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="24664"><span class="lineNum">   24664 </span>            : </a>
<a name="24665"><span class="lineNum">   24665 </span><span class="lineNoCov">          0 :      Sg_File_Info* fileInfo = node-&gt;get_file_info();</span></a>
<a name="24666"><span class="lineNum">   24666 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(fileInfo != NULL);</span></a>
<a name="24667"><span class="lineNum">   24667 </span><span class="lineNoCov">          0 :      string filename = fileInfo-&gt;get_filenameString();</span></a>
<a name="24668"><span class="lineNum">   24668 </span>            : </a>
<a name="24669"><span class="lineNum">   24669 </span>            : #if 0</a>
<a name="24670"><span class="lineNum">   24670 </span>            :      printf (&quot;In SageInterface::insideHeader(): node = %s line: %d column: %d file: %s \n&quot;,node-&gt;class_name().c_str(),fileInfo-&gt;get_line(),fileInfo-&gt;get_col(),filename.c_str());</a>
<a name="24671"><span class="lineNum">   24671 </span>            : #endif</a>
<a name="24672"><span class="lineNum">   24672 </span>            : </a>
<a name="24673"><span class="lineNum">   24673 </span>            :   // DQ (2/27/2021): We save a map of all of the header files processed in the generation of the ROSE AST,</a>
<a name="24674"><span class="lineNum">   24674 </span>            :   // so the test is only if the filename is in the list.</a>
<a name="24675"><span class="lineNum">   24675 </span><span class="lineNoCov">          0 :      if (EDG_ROSE_Translation::edg_include_file_map.find(filename) == EDG_ROSE_Translation::edg_include_file_map.end())</span></a>
<a name="24676"><span class="lineNum">   24676 </span>            :         {</a>
<a name="24677"><span class="lineNum">   24677 </span>            : #if 0</a>
<a name="24678"><span class="lineNum">   24678 </span>            :           printf (&quot;This is NOT in the EDG_ROSE_Translation::edg_include_file_map \n&quot;);</a>
<a name="24679"><span class="lineNum">   24679 </span>            : #endif</a>
<a name="24680"><span class="lineNum">   24680 </span>            :         }</a>
<a name="24681"><span class="lineNum">   24681 </span>            :        else</a>
<a name="24682"><span class="lineNum">   24682 </span>            :         {</a>
<a name="24683"><span class="lineNum">   24683 </span>            : #if 0</a>
<a name="24684"><span class="lineNum">   24684 </span>            :           printf (&quot;This IS in the EDG_ROSE_Translation::edg_include_file_map \n&quot;);</a>
<a name="24685"><span class="lineNum">   24685 </span>            : #endif</a>
<a name="24686"><span class="lineNum">   24686 </span><span class="lineNoCov">          0 :           returnValue = true;</span></a>
<a name="24687"><span class="lineNum">   24687 </span>            :         }</a>
<a name="24688"><span class="lineNum">   24688 </span>            : </a>
<a name="24689"><span class="lineNum">   24689 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="24690"><span class="lineNum">   24690 </span>            :    }</a>
<a name="24691"><span class="lineNum">   24691 </span>            : </a>
<a name="24692"><span class="lineNum">   24692 </span>            : </a>
<a name="24693"><span class="lineNum">   24693 </span>            : //! Find the function type matching a function signature plus a given return type</a>
<a name="24694"><span class="lineNum">   24694 </span><span class="lineNoCov">          0 : SgFunctionType* SageInterface::findFunctionType (SgType* return_type, SgFunctionParameterTypeList* typeList)</span></a>
<a name="24695"><span class="lineNum">   24695 </span>            : {</a>
<a name="24696"><span class="lineNum">   24696 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(return_type != NULL);</span></a>
<a name="24697"><span class="lineNum">   24697 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(typeList != NULL);</span></a>
<a name="24698"><span class="lineNum">   24698 </span><span class="lineNoCov">          0 :   SgFunctionTypeTable * fTable = SgNode::get_globalFunctionTypeTable();</span></a>
<a name="24699"><span class="lineNum">   24699 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(fTable);</span></a>
<a name="24700"><span class="lineNum">   24700 </span>            : </a>
<a name="24701"><span class="lineNum">   24701 </span>            :   // This function make clever use of a static member function which can't be built</a>
<a name="24702"><span class="lineNum">   24702 </span>            :   // for the case of a SgMemberFunctionType (or at least not without more work).</a>
<a name="24703"><span class="lineNum">   24703 </span><span class="lineNoCov">          0 :   SgName typeName = SgFunctionType::get_mangled(return_type, typeList);</span></a>
<a name="24704"><span class="lineNum">   24704 </span><span class="lineNoCov">          0 :   SgFunctionType* funcType = isSgFunctionType(fTable-&gt;lookup_function_type(typeName));</span></a>
<a name="24705"><span class="lineNum">   24705 </span>            : </a>
<a name="24706"><span class="lineNum">   24706 </span><span class="lineNoCov">          0 :   return funcType;</span></a>
<a name="24707"><span class="lineNum">   24707 </span>            : }</a>
<a name="24708"><span class="lineNum">   24708 </span>            : </a>
<a name="24709"><span class="lineNum">   24709 </span>            : //! Test if two types are equivalent SgFunctionType nodes. This is necessary for template function types</a>
<a name="24710"><span class="lineNum">   24710 </span>            : //! They may differ in one SgTemplateType pointer but identical otherwise.</a>
<a name="24711"><span class="lineNum">   24711 </span>            : //! The algorithm is to compare return type and all argument types</a>
<a name="24712"><span class="lineNum">   24712 </span><span class="lineCov">      34720 : bool SageInterface::isEquivalentFunctionType (const SgFunctionType* lhs, const SgFunctionType* rhs)</span></a>
<a name="24713"><span class="lineNum">   24713 </span>            : {</a>
<a name="24714"><span class="lineNum">   24714 </span><span class="lineCov">      34720 :   ROSE_ASSERT (lhs != NULL);</span></a>
<a name="24715"><span class="lineNum">   24715 </span><span class="lineCov">      34720 :   ROSE_ASSERT (rhs != NULL);</span></a>
<a name="24716"><span class="lineNum">   24716 </span><span class="lineCov">      34720 :   if (lhs == rhs)</span></a>
<a name="24717"><span class="lineNum">   24717 </span>            :     return true;</a>
<a name="24718"><span class="lineNum">   24718 </span>            : </a>
<a name="24719"><span class="lineNum">   24719 </span><span class="lineCov">      23452 :   bool rt = false;</span></a>
<a name="24720"><span class="lineNum">   24720 </span><span class="lineCov">      23452 :   SgType* rt1 = lhs-&gt;get_return_type();</span></a>
<a name="24721"><span class="lineNum">   24721 </span><span class="lineCov">      23452 :   SgType* rt2 = rhs-&gt;get_return_type();</span></a>
<a name="24722"><span class="lineNum">   24722 </span>            : </a>
<a name="24723"><span class="lineNum">   24723 </span><span class="lineCov">      23452 :   if (isEquivalentType (rt1, rt2))</span></a>
<a name="24724"><span class="lineNum">   24724 </span>            :   {</a>
<a name="24725"><span class="lineNum">   24725 </span><span class="lineCov">      22388 :     SgTypePtrList f1_arg_types = lhs-&gt;get_arguments();</span></a>
<a name="24726"><span class="lineNum">   24726 </span><span class="lineCov">      22388 :     SgTypePtrList f2_arg_types = rhs-&gt;get_arguments();</span></a>
<a name="24727"><span class="lineNum">   24727 </span>            :     // Must have same number of argument types</a>
<a name="24728"><span class="lineNum">   24728 </span><span class="lineCov">      11194 :     if (f1_arg_types.size() == f2_arg_types.size())</span></a>
<a name="24729"><span class="lineNum">   24729 </span>            :     {</a>
<a name="24730"><span class="lineNum">   24730 </span>            :    // DQ (2/16/2017): Fixed compiler warning about comparison between signed and unsigned integers</a>
<a name="24731"><span class="lineNum">   24731 </span>            :    // int counter = 0;</a>
<a name="24732"><span class="lineNum">   24732 </span>            :       size_t counter = 0;</a>
<a name="24733"><span class="lineNum">   24733 </span>            :    // iterate through all argument types</a>
<a name="24734"><span class="lineNum">   24734 </span>            :    // for (int i=0; i&lt; f1_arg_types.size(); i++)</a>
<a name="24735"><span class="lineNum">   24735 </span><span class="lineCov">      10109 :       for (size_t i=0; i&lt; f1_arg_types.size(); i++)</span></a>
<a name="24736"><span class="lineNum">   24736 </span>            :       {</a>
<a name="24737"><span class="lineNum">   24737 </span><span class="lineCov">      10043 :         if (isEquivalentType (f1_arg_types[i], f2_arg_types[i]) )</span></a>
<a name="24738"><span class="lineNum">   24738 </span><span class="lineCov">       3383 :            counter ++;  // count the number of equal arguments</span></a>
<a name="24739"><span class="lineNum">   24739 </span>            :         else</a>
<a name="24740"><span class="lineNum">   24740 </span>            :           break; // found different type? jump out the loop</a>
<a name="24741"><span class="lineNum">   24741 </span>            :       }</a>
<a name="24742"><span class="lineNum">   24742 </span>            :       // all arguments are equivalent, set to true</a>
<a name="24743"><span class="lineNum">   24743 </span><span class="lineCov">       6726 :       if (counter == f1_arg_types.size())</span></a>
<a name="24744"><span class="lineNum">   24744 </span><span class="lineCov">         66 :         rt = true;</span></a>
<a name="24745"><span class="lineNum">   24745 </span>            :     }</a>
<a name="24746"><span class="lineNum">   24746 </span>            :   } // end if equivalent return types</a>
<a name="24747"><span class="lineNum">   24747 </span>            : </a>
<a name="24748"><span class="lineNum">   24748 </span>            :   return rt;</a>
<a name="24749"><span class="lineNum">   24749 </span>            : }</a>
<a name="24750"><span class="lineNum">   24750 </span>            : </a>
<a name="24751"><span class="lineNum">   24751 </span>            : bool</a>
<a name="24752"><span class="lineNum">   24752 </span><span class="lineCov">     108954 : SageInterface::isEquivalentType (const SgType* lhs, const SgType* rhs)</span></a>
<a name="24753"><span class="lineNum">   24753 </span>            :    {</a>
<a name="24754"><span class="lineNum">   24754 </span>            :   // This function is called in the SgType::isEquivalentType (const SgType &amp; Y) const function.</a>
<a name="24755"><span class="lineNum">   24755 </span>            : </a>
<a name="24756"><span class="lineNum">   24756 </span>            :   // DQ (11/28/2015): A better goal for this function should be to define it as a recursive function.</a>
<a name="24757"><span class="lineNum">   24757 </span>            : </a>
<a name="24758"><span class="lineNum">   24758 </span>            :   // DQ (12/8/2015): We need to add support for SgMemberFunctionType as demonstrated by test2007_17.C.</a>
<a name="24759"><span class="lineNum">   24759 </span>            :   // and for SgTemplateType as demonstrated by tests/nonsmoke/functional/CompileTests/RoseExample_tests/testRoseHeaders_03.C</a>
<a name="24760"><span class="lineNum">   24760 </span>            :   // Note that this is only required within the change to use this isEquivalentType() function in the</a>
<a name="24761"><span class="lineNum">   24761 </span>            :   // support to replace:</a>
<a name="24762"><span class="lineNum">   24762 </span>            :   //    templateParameterOrArgumentLocal-&gt;get_initializedName()-&gt;get_type() == templateParameterOrArgumentFromSymbol-&gt;get_initializedName()-&gt;get_type()</a>
<a name="24763"><span class="lineNum">   24763 </span>            :   // in ROSETTA/Grammar/Support.code</a>
<a name="24764"><span class="lineNum">   24764 </span>            : </a>
<a name="24765"><span class="lineNum">   24765 </span><span class="lineCov">     108954 :      ROSE_ASSERT(lhs != NULL);</span></a>
<a name="24766"><span class="lineNum">   24766 </span><span class="lineCov">     108954 :      ROSE_ASSERT(rhs != NULL);</span></a>
<a name="24767"><span class="lineNum">   24767 </span>            : </a>
<a name="24768"><span class="lineNum">   24768 </span><span class="lineCov">     108954 :      bool isSame = false;</span></a>
<a name="24769"><span class="lineNum">   24769 </span>            : </a>
<a name="24770"><span class="lineNum">   24770 </span>            :   // While debugging avoid infinte loops (most type chains in STL and boost are only a 3-4 long in test2015_127.C, nesting is how it goes wild).</a>
<a name="24771"><span class="lineNum">   24771 </span><span class="lineCov">     108954 :      static int counter = 0;</span></a>
<a name="24772"><span class="lineNum">   24772 </span>            : </a>
<a name="24773"><span class="lineNum">   24773 </span><span class="lineCov">     108954 :      const SgType &amp; X = *lhs;</span></a>
<a name="24774"><span class="lineNum">   24774 </span><span class="lineCov">     108954 :      const SgType &amp; Y = *rhs;</span></a>
<a name="24775"><span class="lineNum">   24775 </span>            : </a>
<a name="24776"><span class="lineNum">   24776 </span>            :   // DQ (11/28/2015): We don't want to strip off everything.</a>
<a name="24777"><span class="lineNum">   24777 </span>            :   // SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE ) const;</a>
<a name="24778"><span class="lineNum">   24778 </span>            : </a>
<a name="24779"><span class="lineNum">   24779 </span>            :   // I think we need to compute the type chain to evaluate equalence.</a>
<a name="24780"><span class="lineNum">   24780 </span>            :   // Rose_STL_Container&lt; SgType*&gt; getInternalTypes () const</a>
<a name="24781"><span class="lineNum">   24781 </span>            : </a>
<a name="24782"><span class="lineNum">   24782 </span>            : #define DEBUG_TYPE_EQUIVALENCE 0</a>
<a name="24783"><span class="lineNum">   24783 </span>            : </a>
<a name="24784"><span class="lineNum">   24784 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="24785"><span class="lineNum">   24785 </span>            :      printf (&quot;In SageInterface::isEquivalentType(): evaluation of type equivalence for lhs and rhs: counter = %d \n&quot;,counter);</a>
<a name="24786"><span class="lineNum">   24786 </span>            :      printf (&quot;   --- lhs = %s \n&quot;,lhs-&gt;unparseToString().c_str());</a>
<a name="24787"><span class="lineNum">   24787 </span>            :      printf (&quot;   --- rhs = %s \n&quot;,rhs-&gt;unparseToString().c_str());</a>
<a name="24788"><span class="lineNum">   24788 </span>            : #endif</a>
<a name="24789"><span class="lineNum">   24789 </span>            : </a>
<a name="24790"><span class="lineNum">   24790 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="24791"><span class="lineNum">   24791 </span>            :      if (counter == 0)</a>
<a name="24792"><span class="lineNum">   24792 </span>            :         {</a>
<a name="24793"><span class="lineNum">   24793 </span>            :           printf (&quot;In SageInterface::isEquivalentType(): evaluation of type equivalence for lhs and rhs: counter = %d \n&quot;,counter);</a>
<a name="24794"><span class="lineNum">   24794 </span>            :           printf (&quot;   --- lhs = %p = %s = %s \n&quot;,lhs,lhs-&gt;class_name().c_str(),lhs-&gt;unparseToString().c_str());</a>
<a name="24795"><span class="lineNum">   24795 </span>            :           printf (&quot;   --- rhs = %p = %s = %s \n&quot;,rhs,rhs-&gt;class_name().c_str(),rhs-&gt;unparseToString().c_str());</a>
<a name="24796"><span class="lineNum">   24796 </span>            :         }</a>
<a name="24797"><span class="lineNum">   24797 </span>            : #endif</a>
<a name="24798"><span class="lineNum">   24798 </span>            : </a>
<a name="24799"><span class="lineNum">   24799 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="24800"><span class="lineNum">   24800 </span>            :   // Debugging output.</a>
<a name="24801"><span class="lineNum">   24801 </span>            :      Rose_STL_Container&lt;SgType*&gt; X_typeChain = X.getInternalTypes();</a>
<a name="24802"><span class="lineNum">   24802 </span>            :      Rose_STL_Container&lt;SgType*&gt; Y_typeChain = Y.getInternalTypes();</a>
<a name="24803"><span class="lineNum">   24803 </span>            : </a>
<a name="24804"><span class="lineNum">   24804 </span>            :   // Debugging output.</a>
<a name="24805"><span class="lineNum">   24805 </span>            :      printf (&quot;Output of type chain for lhs: \n&quot;);</a>
<a name="24806"><span class="lineNum">   24806 </span>            :      for (size_t i = 0; i &lt; X_typeChain.size(); i++)</a>
<a name="24807"><span class="lineNum">   24807 </span>            :         {</a>
<a name="24808"><span class="lineNum">   24808 </span>            :           SgType* element_type = X_typeChain[i];</a>
<a name="24809"><span class="lineNum">   24809 </span>            :           printf (&quot;X_element_type = %p = %s \n&quot;,element_type,element_type-&gt;class_name().c_str());</a>
<a name="24810"><span class="lineNum">   24810 </span>            :           printf (&quot;   --- X_element_type unparseToString: = %s \n&quot;,element_type-&gt;unparseToString().c_str());</a>
<a name="24811"><span class="lineNum">   24811 </span>            :           SgModifierType* modifierType = isSgModifierType(element_type);</a>
<a name="24812"><span class="lineNum">   24812 </span>            :           if (modifierType != NULL)</a>
<a name="24813"><span class="lineNum">   24813 </span>            :              {</a>
<a name="24814"><span class="lineNum">   24814 </span>            :             // modifierType-&gt;get_typeModifier().display(&quot;X type chain&quot;);</a>
<a name="24815"><span class="lineNum">   24815 </span>            :                string s = modifierType-&gt;get_typeModifier().displayString();</a>
<a name="24816"><span class="lineNum">   24816 </span>            :                printf (&quot;   --- type chain modifier: %s \n&quot;,s.c_str());</a>
<a name="24817"><span class="lineNum">   24817 </span>            :                printf (&quot;   --- type chain modifier: unparseToString: %s \n&quot;,modifierType-&gt;unparseToString().c_str());</a>
<a name="24818"><span class="lineNum">   24818 </span>            :              }</a>
<a name="24819"><span class="lineNum">   24819 </span>            :         }</a>
<a name="24820"><span class="lineNum">   24820 </span>            : </a>
<a name="24821"><span class="lineNum">   24821 </span>            :      printf (&quot;Output of type chain for rhs: \n&quot;);</a>
<a name="24822"><span class="lineNum">   24822 </span>            :      for (size_t i = 0; i &lt; Y_typeChain.size(); i++)</a>
<a name="24823"><span class="lineNum">   24823 </span>            :         {</a>
<a name="24824"><span class="lineNum">   24824 </span>            :           SgType* element_type = Y_typeChain[i];</a>
<a name="24825"><span class="lineNum">   24825 </span>            :           printf (&quot;Y_element_type = %p = %s \n&quot;,element_type,element_type-&gt;class_name().c_str());</a>
<a name="24826"><span class="lineNum">   24826 </span>            :           printf (&quot;   --- Y_element_type unparseToString: = %s \n&quot;,element_type-&gt;unparseToString().c_str());</a>
<a name="24827"><span class="lineNum">   24827 </span>            :           SgModifierType* modifierType = isSgModifierType(element_type);</a>
<a name="24828"><span class="lineNum">   24828 </span>            :           if (modifierType != NULL)</a>
<a name="24829"><span class="lineNum">   24829 </span>            :              {</a>
<a name="24830"><span class="lineNum">   24830 </span>            :             // modifierType-&gt;get_typeModifier().display(&quot;Y type chain&quot;);</a>
<a name="24831"><span class="lineNum">   24831 </span>            :                string s = modifierType-&gt;get_typeModifier().displayString();</a>
<a name="24832"><span class="lineNum">   24832 </span>            :                printf (&quot;   --- type chain modifier: %s \n&quot;,s.c_str());</a>
<a name="24833"><span class="lineNum">   24833 </span>            :                printf (&quot;   --- type chain modifier: unparseToString: %s \n&quot;,modifierType-&gt;unparseToString().c_str());</a>
<a name="24834"><span class="lineNum">   24834 </span>            :              }</a>
<a name="24835"><span class="lineNum">   24835 </span>            :         }</a>
<a name="24836"><span class="lineNum">   24836 </span>            : #endif</a>
<a name="24837"><span class="lineNum">   24837 </span>            : </a>
<a name="24838"><span class="lineNum">   24838 </span>            :   // Increment the static variable to control the recursive depth while we debug this.</a>
<a name="24839"><span class="lineNum">   24839 </span><span class="lineCov">     108954 :      counter++;</span></a>
<a name="24840"><span class="lineNum">   24840 </span>            : </a>
<a name="24841"><span class="lineNum">   24841 </span>            :   // DQ (11/28/2015): exit with debug output instead of infinte recursion.</a>
<a name="24842"><span class="lineNum">   24842 </span>            :   // if (counter &gt;= 280)</a>
<a name="24843"><span class="lineNum">   24843 </span>            :   // if (counter &gt;= 500)</a>
<a name="24844"><span class="lineNum">   24844 </span><span class="lineCov">     108954 :      if (counter &gt;= 280)</span></a>
<a name="24845"><span class="lineNum">   24845 </span>            :         {</a>
<a name="24846"><span class="lineNum">   24846 </span>            :        // printf (&quot;In SageInterface::isEquivalentType(): counter = %d: type chain X_element_type = %s Y_element_type = %s \n&quot;,counter,X.class_name().c_str(),Y.class_name().c_str());</a>
<a name="24847"><span class="lineNum">   24847 </span><span class="lineNoCov">          0 :           printf (&quot;In SageInterface::isEquivalentType(): counter = %d: type chain X_element_type = %s = %p Y_element_type = %s = %p \n&quot;,counter,X.class_name().c_str(),lhs,Y.class_name().c_str(),rhs);</span></a>
<a name="24848"><span class="lineNum">   24848 </span>            :         }</a>
<a name="24849"><span class="lineNum">   24849 </span>            : </a>
<a name="24850"><span class="lineNum">   24850 </span>            :   // DQ (12/23/2015): ASC application code requires this to be increased to over 122 (selected 300 for extra margin of safety).</a>
<a name="24851"><span class="lineNum">   24851 </span>            :   // DQ (11/28/2015): exit in stead of infinte recursion.</a>
<a name="24852"><span class="lineNum">   24852 </span>            :   // if (counter &gt; 300)</a>
<a name="24853"><span class="lineNum">   24853 </span>            :   // if (counter &gt; 600)</a>
<a name="24854"><span class="lineNum">   24854 </span>            :   // if (counter &gt; 5000)</a>
<a name="24855"><span class="lineNum">   24855 </span>            :   // if (counter &gt; 300)</a>
<a name="24856"><span class="lineNum">   24856 </span><span class="lineCov">     108954 :      if (counter &gt; 350)</span></a>
<a name="24857"><span class="lineNum">   24857 </span>            :         {</a>
<a name="24858"><span class="lineNum">   24858 </span>            :        // DQ (11/28/2015): I think this is a reasonable limit.</a>
<a name="24859"><span class="lineNum">   24859 </span><span class="lineNoCov">          0 :           printf (&quot;ERROR: In SageInterface::isEquivalentType(): recursive limit exceeded for : counter = %d \n&quot;,counter);</span></a>
<a name="24860"><span class="lineNum">   24860 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="24861"><span class="lineNum">   24861 </span>            :         }</a>
<a name="24862"><span class="lineNum">   24862 </span>            : </a>
<a name="24863"><span class="lineNum">   24863 </span>            :   // bool exit = false;</a>
<a name="24864"><span class="lineNum">   24864 </span>            : </a>
<a name="24865"><span class="lineNum">   24865 </span>            :   // Strip off any typedefs since they are equivalent by definition.</a>
<a name="24866"><span class="lineNum">   24866 </span><span class="lineCov">     108954 :      SgType* X_element_type = X.stripType( SgType::STRIP_TYPEDEF_TYPE );</span></a>
<a name="24867"><span class="lineNum">   24867 </span><span class="lineCov">     108954 :      SgType* Y_element_type = Y.stripType( SgType::STRIP_TYPEDEF_TYPE );</span></a>
<a name="24868"><span class="lineNum">   24868 </span>            : </a>
<a name="24869"><span class="lineNum">   24869 </span>            :   // DQ (11/29/2015): We need to handle references (when they are both references we can support then uniformally).</a>
<a name="24870"><span class="lineNum">   24870 </span><span class="lineCov">     108954 :      SgReferenceType* X_referenceType = isSgReferenceType(X_element_type);</span></a>
<a name="24871"><span class="lineNum">   24871 </span><span class="lineCov">     108954 :      SgReferenceType* Y_referenceType = isSgReferenceType(Y_element_type);</span></a>
<a name="24872"><span class="lineNum">   24872 </span>            : </a>
<a name="24873"><span class="lineNum">   24873 </span><span class="lineCov">     108954 :      if (X_referenceType != NULL &amp;&amp; Y_referenceType != NULL)</span></a>
<a name="24874"><span class="lineNum">   24874 </span>            :         {</a>
<a name="24875"><span class="lineNum">   24875 </span><span class="lineCov">       7007 :           X_element_type = X_referenceType-&gt;get_base_type();</span></a>
<a name="24876"><span class="lineNum">   24876 </span><span class="lineCov">       7007 :           Y_element_type = Y_referenceType-&gt;get_base_type();</span></a>
<a name="24877"><span class="lineNum">   24877 </span>            : </a>
<a name="24878"><span class="lineNum">   24878 </span><span class="lineCov">       7007 :           counter--;</span></a>
<a name="24879"><span class="lineNum">   24879 </span>            : </a>
<a name="24880"><span class="lineNum">   24880 </span>            :        // Recursive call.</a>
<a name="24881"><span class="lineNum">   24881 </span>            :        // return (*X_element_type) == (*Y_element_type);</a>
<a name="24882"><span class="lineNum">   24882 </span><span class="lineCov">       7007 :           return isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="24883"><span class="lineNum">   24883 </span>            :         }</a>
<a name="24884"><span class="lineNum">   24884 </span>            :        else</a>
<a name="24885"><span class="lineNum">   24885 </span>            :         {</a>
<a name="24886"><span class="lineNum">   24886 </span>            :        // DQ (12/8/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="24887"><span class="lineNum">   24887 </span><span class="lineCov">     101947 :           SgPointerType* X_pointerType = isSgPointerType(X_element_type);</span></a>
<a name="24888"><span class="lineNum">   24888 </span><span class="lineCov">     101947 :           SgPointerType* Y_pointerType = isSgPointerType(Y_element_type);</span></a>
<a name="24889"><span class="lineNum">   24889 </span>            : </a>
<a name="24890"><span class="lineNum">   24890 </span><span class="lineCov">     101947 :           if (X_pointerType != NULL &amp;&amp; Y_pointerType != NULL)</span></a>
<a name="24891"><span class="lineNum">   24891 </span>            :              {</a>
<a name="24892"><span class="lineNum">   24892 </span><span class="lineCov">       4236 :                X_element_type = X_pointerType-&gt;get_base_type();</span></a>
<a name="24893"><span class="lineNum">   24893 </span><span class="lineCov">       4236 :                Y_element_type = Y_pointerType-&gt;get_base_type();</span></a>
<a name="24894"><span class="lineNum">   24894 </span>            : </a>
<a name="24895"><span class="lineNum">   24895 </span><span class="lineCov">       4236 :                counter--;</span></a>
<a name="24896"><span class="lineNum">   24896 </span>            : </a>
<a name="24897"><span class="lineNum">   24897 </span>            :             // Recursive call.</a>
<a name="24898"><span class="lineNum">   24898 </span>            :             // return (*X_element_type) == (*Y_element_type);</a>
<a name="24899"><span class="lineNum">   24899 </span><span class="lineCov">       4236 :                return isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="24900"><span class="lineNum">   24900 </span>            :              }</a>
<a name="24901"><span class="lineNum">   24901 </span>            :             else</a>
<a name="24902"><span class="lineNum">   24902 </span>            :              {</a>
<a name="24903"><span class="lineNum">   24903 </span>            :             // DQ (12/8/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="24904"><span class="lineNum">   24904 </span><span class="lineCov">      97711 :                SgArrayType* X_arrayType = isSgArrayType(X_element_type);</span></a>
<a name="24905"><span class="lineNum">   24905 </span><span class="lineCov">      97711 :                SgArrayType* Y_arrayType = isSgArrayType(Y_element_type);</span></a>
<a name="24906"><span class="lineNum">   24906 </span>            : </a>
<a name="24907"><span class="lineNum">   24907 </span>            :             // DQ (12/8/2015): We need to check that the array size is the same.</a>
<a name="24908"><span class="lineNum">   24908 </span><span class="lineCov">      97711 :                if (X_arrayType != NULL &amp;&amp; Y_arrayType != NULL)</span></a>
<a name="24909"><span class="lineNum">   24909 </span>            :                   {</a>
<a name="24910"><span class="lineNum">   24910 </span><span class="lineNoCov">          0 :                     X_element_type = X_arrayType-&gt;get_base_type();</span></a>
<a name="24911"><span class="lineNum">   24911 </span><span class="lineNoCov">          0 :                     Y_element_type = Y_arrayType-&gt;get_base_type();</span></a>
<a name="24912"><span class="lineNum">   24912 </span>            : </a>
<a name="24913"><span class="lineNum">   24913 </span><span class="lineNoCov">          0 :                     SgExpression* X_array_index_expression = X_arrayType-&gt;get_index();</span></a>
<a name="24914"><span class="lineNum">   24914 </span><span class="lineNoCov">          0 :                     SgExpression* Y_array_index_expression = Y_arrayType-&gt;get_index();</span></a>
<a name="24915"><span class="lineNum">   24915 </span>            : </a>
<a name="24916"><span class="lineNum">   24916 </span><span class="lineNoCov">          0 :                     if (X_array_index_expression == Y_array_index_expression)</span></a>
<a name="24917"><span class="lineNum">   24917 </span>            :                        {</a>
<a name="24918"><span class="lineNum">   24918 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="24919"><span class="lineNum">   24919 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): counter = %d: Need to check the array size for static equivalence \n&quot;,counter);</a>
<a name="24920"><span class="lineNum">   24920 </span>            : #endif</a>
<a name="24921"><span class="lineNum">   24921 </span><span class="lineNoCov">          0 :                          counter--;</span></a>
<a name="24922"><span class="lineNum">   24922 </span>            : </a>
<a name="24923"><span class="lineNum">   24923 </span>            :                       // Recursive call.</a>
<a name="24924"><span class="lineNum">   24924 </span>            :                       // return (*X_element_type) == (*Y_element_type);</a>
<a name="24925"><span class="lineNum">   24925 </span><span class="lineNoCov">          0 :                          return isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="24926"><span class="lineNum">   24926 </span>            :                        }</a>
<a name="24927"><span class="lineNum">   24927 </span>            :                       else</a>
<a name="24928"><span class="lineNum">   24928 </span>            :                        {</a>
<a name="24929"><span class="lineNum">   24929 </span>            :                       // Need more complex test for expression equivalence.</a>
<a name="24930"><span class="lineNum">   24930 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="24931"><span class="lineNum">   24931 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): counter = %d Need more complex test for expression equivalence \n&quot;,counter);</a>
<a name="24932"><span class="lineNum">   24932 </span>            :                          string str1 = X_array_index_expression-&gt;unparseToString();</a>
<a name="24933"><span class="lineNum">   24933 </span>            :                          string str2 = Y_array_index_expression-&gt;unparseToString();</a>
<a name="24934"><span class="lineNum">   24934 </span>            :                          printf (&quot;   --- array index expressions: str1 = %s str2 = %s \n&quot;,str1.c_str(),str2.c_str());</a>
<a name="24935"><span class="lineNum">   24935 </span>            : #endif</a>
<a name="24936"><span class="lineNum">   24936 </span>            :                       // DQ (12/9/2016): Need to decriment the counter as part of recursive function call.</a>
<a name="24937"><span class="lineNum">   24937 </span><span class="lineNoCov">          0 :                          counter--;</span></a>
<a name="24938"><span class="lineNum">   24938 </span>            : </a>
<a name="24939"><span class="lineNum">   24939 </span>            :                       // Recursive call.</a>
<a name="24940"><span class="lineNum">   24940 </span><span class="lineNoCov">          0 :                          return isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="24941"><span class="lineNum">   24941 </span>            :                        }</a>
<a name="24942"><span class="lineNum">   24942 </span>            :                   }</a>
<a name="24943"><span class="lineNum">   24943 </span>            :                  else</a>
<a name="24944"><span class="lineNum">   24944 </span>            :                   {</a>
<a name="24945"><span class="lineNum">   24945 </span>            :                  // DQ (12/15/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="24946"><span class="lineNum">   24946 </span><span class="lineCov">      97711 :                     SgNonrealType* X_templateType = isSgNonrealType(X_element_type);</span></a>
<a name="24947"><span class="lineNum">   24947 </span><span class="lineCov">      97711 :                     SgNonrealType* Y_templateType = isSgNonrealType(Y_element_type);</span></a>
<a name="24948"><span class="lineNum">   24948 </span>            : </a>
<a name="24949"><span class="lineNum">   24949 </span>            :                  // DQ (12/15/2015): We need to check that the array size is the same.</a>
<a name="24950"><span class="lineNum">   24950 </span><span class="lineCov">      97711 :                     if (X_templateType != NULL &amp;&amp; Y_templateType != NULL)</span></a>
<a name="24951"><span class="lineNum">   24951 </span>            :                        {</a>
<a name="24952"><span class="lineNum">   24952 </span><span class="lineCov">      55852 :                          string X_name = X_templateType-&gt;get_name();</span></a>
<a name="24953"><span class="lineNum">   24953 </span><span class="lineCov">      55852 :                          string Y_name = Y_templateType-&gt;get_name();</span></a>
<a name="24954"><span class="lineNum">   24954 </span>            : </a>
<a name="24955"><span class="lineNum">   24955 </span><span class="lineCov">      27926 :                          SgNonrealDecl* X_templateDecl = isSgNonrealDecl(X_templateType-&gt;get_declaration());</span></a>
<a name="24956"><span class="lineNum">   24956 </span><span class="lineCov">      27926 :                          ROSE_ASSERT(X_templateDecl != NULL);</span></a>
<a name="24957"><span class="lineNum">   24957 </span><span class="lineCov">      27926 :                          SgNonrealDecl* Y_templateDecl = isSgNonrealDecl(Y_templateType-&gt;get_declaration());</span></a>
<a name="24958"><span class="lineNum">   24958 </span><span class="lineCov">      27926 :                          ROSE_ASSERT(Y_templateDecl != NULL);</span></a>
<a name="24959"><span class="lineNum">   24959 </span>            : </a>
<a name="24960"><span class="lineNum">   24960 </span><span class="lineCov">      27926 :                          int X_template_parameter_position = X_templateDecl-&gt;get_template_parameter_position();</span></a>
<a name="24961"><span class="lineNum">   24961 </span><span class="lineCov">      27926 :                          int Y_template_parameter_position = Y_templateDecl-&gt;get_template_parameter_position();</span></a>
<a name="24962"><span class="lineNum">   24962 </span>            : </a>
<a name="24963"><span class="lineNum">   24963 </span><span class="lineCov">      27926 :                          SgNode * X_parent = X_templateDecl-&gt;get_parent();</span></a>
<a name="24964"><span class="lineNum">   24964 </span><span class="lineCov">      27926 :                          SgNode * Y_parent = Y_templateDecl-&gt;get_parent();</span></a>
<a name="24965"><span class="lineNum">   24965 </span>            : </a>
<a name="24966"><span class="lineNum">   24966 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="24967"><span class="lineNum">   24967 </span>            :                          SgNode * X_parent_parent = X_parent ? X_parent-&gt;get_parent() : NULL;</a>
<a name="24968"><span class="lineNum">   24968 </span>            :                          SgNode * Y_parent_parent = Y_parent ? Y_parent-&gt;get_parent() : NULL;</a>
<a name="24969"><span class="lineNum">   24969 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): case SgNonrealType:\n&quot;);</a>
<a name="24970"><span class="lineNum">   24970 </span>            :                          printf (&quot;  -- X_name = %s Y_name = %s\n&quot;, X_name.c_str(),Y_name.c_str());</a>
<a name="24971"><span class="lineNum">   24971 </span>            :                          printf (&quot;  -- X_template_parameter_position = %d Y_template_parameter_position = %d\n&quot;, X_template_parameter_position,Y_template_parameter_position);</a>
<a name="24972"><span class="lineNum">   24972 </span>            :                          printf (&quot;  -- X_parent = %p (%s) Y_parent = %p (%s)\n&quot;, X_parent, X_parent ? X_parent-&gt;class_name().c_str() : &quot;&quot;, Y_parent, Y_parent ? Y_parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="24973"><span class="lineNum">   24973 </span>            :                          printf (&quot;  -- X_parent_parent = %p (%s) Y_parent_parent = %p (%s)\n&quot;, X_parent_parent, X_parent_parent ? X_parent_parent-&gt;class_name().c_str() : &quot;&quot;, Y_parent_parent, Y_parent_parent ? Y_parent_parent-&gt;class_name().c_str() : &quot;&quot;);</a>
<a name="24974"><span class="lineNum">   24974 </span>            :                          printf (&quot;  -- X_templateDecl-&gt;get_mangled_name() = %s\n&quot;, X_templateDecl-&gt;get_mangled_name().str());</a>
<a name="24975"><span class="lineNum">   24975 </span>            :                          printf (&quot;  -- Y_templateDecl-&gt;get_mangled_name() = %s\n&quot;, Y_templateDecl-&gt;get_mangled_name().str());</a>
<a name="24976"><span class="lineNum">   24976 </span>            : #endif</a>
<a name="24977"><span class="lineNum">   24977 </span><span class="lineCov">      27926 :                          bool value = (X_parent == Y_parent);</span></a>
<a name="24978"><span class="lineNum">   24978 </span>            : </a>
<a name="24979"><span class="lineNum">   24979 </span><span class="lineCov">      27926 :                          if (value &amp;&amp; X_templateDecl-&gt;get_is_template_param() &amp;&amp; Y_templateDecl-&gt;get_is_template_param()) {</span></a>
<a name="24980"><span class="lineNum">   24980 </span><span class="lineCov">      12069 :                            value = (X_template_parameter_position == Y_template_parameter_position);</span></a>
<a name="24981"><span class="lineNum">   24981 </span><span class="lineCov">      15857 :                          } else if (value &amp;&amp; X_templateDecl-&gt;get_is_class_member() &amp;&amp; Y_templateDecl-&gt;get_is_class_member()) {</span></a>
<a name="24982"><span class="lineNum">   24982 </span><span class="lineCov">          6 :                            value = (X_name == Y_name);</span></a>
<a name="24983"><span class="lineNum">   24983 </span>            :                          }</a>
<a name="24984"><span class="lineNum">   24984 </span>            : </a>
<a name="24985"><span class="lineNum">   24985 </span><span class="lineCov">      27926 :                          counter--;</span></a>
<a name="24986"><span class="lineNum">   24986 </span>            : </a>
<a name="24987"><span class="lineNum">   24987 </span><span class="lineCov">      27926 :                          return value;</span></a>
<a name="24988"><span class="lineNum">   24988 </span>            :                        }</a>
<a name="24989"><span class="lineNum">   24989 </span>            :                       else</a>
<a name="24990"><span class="lineNum">   24990 </span>            :                        {</a>
<a name="24991"><span class="lineNum">   24991 </span>            :                       // DQ (2/13/2018): I an unclear if we are really done since they could have resolved to different types or the same type.</a>
<a name="24992"><span class="lineNum">   24992 </span>            :                       // Nothing to do here since we have explored all uniform pairs of intermediate types possible.</a>
<a name="24993"><span class="lineNum">   24993 </span>            : #if 0</a>
<a name="24994"><span class="lineNum">   24994 </span>            :                          printf (&quot;Nothing to do here since we have explored all uniform pairs of intermediate types possible: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="24995"><span class="lineNum">   24995 </span>            :                       // printf (&quot;   --- X_element_type = %p = %s \n&quot;,X_element_type,X_element_type-&gt;unparseToString().c_str());</a>
<a name="24996"><span class="lineNum">   24996 </span>            :                       // printf (&quot;   --- Y_element_type = %p = %s \n&quot;,Y_element_type,Y_element_type-&gt;unparseToString().c_str());</a>
<a name="24997"><span class="lineNum">   24997 </span>            :                          printf (&quot;   --- lhs = %p = %s \n&quot;,lhs,lhs-&gt;unparseToString().c_str());</a>
<a name="24998"><span class="lineNum">   24998 </span>            :                          printf (&quot;   --- rhs = %p = %s \n&quot;,rhs,rhs-&gt;unparseToString().c_str());</a>
<a name="24999"><span class="lineNum">   24999 </span>            : #endif</a>
<a name="25000"><span class="lineNum">   25000 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25001"><span class="lineNum">   25001 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: Nothing to do here since we have explored all uniform pairs of intermediate types possible: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25002"><span class="lineNum">   25002 </span>            : #endif</a>
<a name="25003"><span class="lineNum">   25003 </span>            :                        }</a>
<a name="25004"><span class="lineNum">   25004 </span>            :                   }</a>
<a name="25005"><span class="lineNum">   25005 </span>            :              }</a>
<a name="25006"><span class="lineNum">   25006 </span>            :         } // end if reference type, pointer type, array type, and template type</a>
<a name="25007"><span class="lineNum">   25007 </span>            : </a>
<a name="25008"><span class="lineNum">   25008 </span><span class="lineCov">      69785 :      SgModifierType* X_modifierType = isSgModifierType(X_element_type);</span></a>
<a name="25009"><span class="lineNum">   25009 </span><span class="lineCov">      69785 :      SgModifierType* Y_modifierType = isSgModifierType(Y_element_type);</span></a>
<a name="25010"><span class="lineNum">   25010 </span>            : </a>
<a name="25011"><span class="lineNum">   25011 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25012"><span class="lineNum">   25012 </span>            :      printf (&quot;In SageInterface::isEquivalentType(): counter = %d: type chain X_element_type = %p = %s Y_element_type = %p = %s \n&quot;,</a>
<a name="25013"><span class="lineNum">   25013 </span>            :           counter,X_element_type,X_element_type-&gt;class_name().c_str(),Y_element_type,Y_element_type-&gt;class_name().c_str());</a>
<a name="25014"><span class="lineNum">   25014 </span>            : #endif</a>
<a name="25015"><span class="lineNum">   25015 </span>            : </a>
<a name="25016"><span class="lineNum">   25016 </span><span class="lineCov">      69785 :      if (X_modifierType != NULL &amp;&amp; Y_modifierType != NULL)</span></a>
<a name="25017"><span class="lineNum">   25017 </span>            :         {</a>
<a name="25018"><span class="lineNum">   25018 </span>            :        // Handle the case of both modifiers.</a>
<a name="25019"><span class="lineNum">   25019 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25020"><span class="lineNum">   25020 </span>            :           printf (&quot;In SageInterface::isEquivalentType(): loop: these are the both SgModifierType nodes: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25021"><span class="lineNum">   25021 </span>            : #endif</a>
<a name="25022"><span class="lineNum">   25022 </span><span class="lineCov">       7066 :           if (X_modifierType == Y_modifierType)</span></a>
<a name="25023"><span class="lineNum">   25023 </span>            :              {</a>
<a name="25024"><span class="lineNum">   25024 </span>            :                isSame = true;</a>
<a name="25025"><span class="lineNum">   25025 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25026"><span class="lineNum">   25026 </span>            :                printf (&quot;In SageInterface::isEquivalentType(): loop: these are the same modifier type: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25027"><span class="lineNum">   25027 </span>            : #endif</a>
<a name="25028"><span class="lineNum">   25028 </span>            :              }</a>
<a name="25029"><span class="lineNum">   25029 </span>            :             else</a>
<a name="25030"><span class="lineNum">   25030 </span>            :              {</a>
<a name="25031"><span class="lineNum">   25031 </span><span class="lineCov">       5690 :                if (X_modifierType-&gt;get_typeModifier() == Y_modifierType-&gt;get_typeModifier())</span></a>
<a name="25032"><span class="lineNum">   25032 </span>            :                   {</a>
<a name="25033"><span class="lineNum">   25033 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25034"><span class="lineNum">   25034 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: these are equivalent modifiers: check the base type: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25035"><span class="lineNum">   25035 </span>            : #endif</a>
<a name="25036"><span class="lineNum">   25036 </span>            :                  // Recursive call.</a>
<a name="25037"><span class="lineNum">   25037 </span>            :                  // isSame = (*X_modifierType-&gt;get_base_type()) == (*Y_modifierType-&gt;get_base_type());</a>
<a name="25038"><span class="lineNum">   25038 </span><span class="lineCov">       5078 :                     isSame = isEquivalentType(X_modifierType-&gt;get_base_type(),Y_modifierType-&gt;get_base_type());</span></a>
<a name="25039"><span class="lineNum">   25039 </span>            :                   }</a>
<a name="25040"><span class="lineNum">   25040 </span>            :                  else</a>
<a name="25041"><span class="lineNum">   25041 </span>            :                   {</a>
<a name="25042"><span class="lineNum">   25042 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25043"><span class="lineNum">   25043 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: these are not equivalent modifier types: check for default settings: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25044"><span class="lineNum">   25044 </span>            : #endif</a>
<a name="25045"><span class="lineNum">   25045 </span>            :                  // DQ (5/22/2016): fixing bug which cansed infinite recursion (case there the SgModifiers were different).</a>
<a name="25046"><span class="lineNum">   25046 </span><span class="lineCov">        612 :                     bool skippingOverIdentityModifier = false;</span></a>
<a name="25047"><span class="lineNum">   25047 </span>            : </a>
<a name="25048"><span class="lineNum">   25048 </span>            :                  // if (X_modifierType-&gt;get_typeModifier().isDefault() == true)</a>
<a name="25049"><span class="lineNum">   25049 </span><span class="lineCov">        612 :                     if (X_modifierType-&gt;get_typeModifier().isIdentity() == true)</span></a>
<a name="25050"><span class="lineNum">   25050 </span>            :                        {</a>
<a name="25051"><span class="lineNum">   25051 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25052"><span class="lineNum">   25052 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: found self-similar setting for lhs: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25053"><span class="lineNum">   25053 </span>            : #endif</a>
<a name="25054"><span class="lineNum">   25054 </span><span class="lineCov">        412 :                          X_element_type = X_modifierType-&gt;get_base_type();</span></a>
<a name="25055"><span class="lineNum">   25055 </span>            : </a>
<a name="25056"><span class="lineNum">   25056 </span>            :                       // DQ (5/22/2016): Record that progress was made in uncovering the relevant base type, and trigger reevaluation.</a>
<a name="25057"><span class="lineNum">   25057 </span><span class="lineCov">        412 :                          skippingOverIdentityModifier = true;</span></a>
<a name="25058"><span class="lineNum">   25058 </span>            :                        }</a>
<a name="25059"><span class="lineNum">   25059 </span>            : </a>
<a name="25060"><span class="lineNum">   25060 </span>            :                  // if (Y_modifierType-&gt;get_typeModifier().isDefault() == true)</a>
<a name="25061"><span class="lineNum">   25061 </span><span class="lineCov">        612 :                     if (Y_modifierType-&gt;get_typeModifier().isIdentity() == true)</span></a>
<a name="25062"><span class="lineNum">   25062 </span>            :                        {</a>
<a name="25063"><span class="lineNum">   25063 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25064"><span class="lineNum">   25064 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: found self-similar setting for rhs: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25065"><span class="lineNum">   25065 </span>            : #endif</a>
<a name="25066"><span class="lineNum">   25066 </span><span class="lineCov">        200 :                          Y_element_type = Y_modifierType-&gt;get_base_type();</span></a>
<a name="25067"><span class="lineNum">   25067 </span>            : </a>
<a name="25068"><span class="lineNum">   25068 </span>            :                       // DQ (5/22/2016): Record that progress was made in uncovering the relevant base type, and trigger reevaluation.</a>
<a name="25069"><span class="lineNum">   25069 </span><span class="lineCov">        200 :                          skippingOverIdentityModifier = true;</span></a>
<a name="25070"><span class="lineNum">   25070 </span>            :                        }</a>
<a name="25071"><span class="lineNum">   25071 </span>            : </a>
<a name="25072"><span class="lineNum">   25072 </span>            :                  // NOTE: If either of these are a SgTypedefType then the typedefs will be stripped away at the top of the recursive call.</a>
<a name="25073"><span class="lineNum">   25073 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25074"><span class="lineNum">   25074 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: skippingOverIdentityModifier = %s \n&quot;,skippingOverIdentityModifier ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25075"><span class="lineNum">   25075 </span>            : #endif</a>
<a name="25076"><span class="lineNum">   25076 </span>            :                  // Recursive call on non-default modifier base types.</a>
<a name="25077"><span class="lineNum">   25077 </span>            :                  // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25078"><span class="lineNum">   25078 </span>            :                  // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25079"><span class="lineNum">   25079 </span><span class="lineCov">        612 :                     if (skippingOverIdentityModifier == true)</span></a>
<a name="25080"><span class="lineNum">   25080 </span>            :                        {</a>
<a name="25081"><span class="lineNum">   25081 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25082"><span class="lineNum">   25082 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: recursive call on different adjusted modifier types: before recursive call to compare base types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25083"><span class="lineNum">   25083 </span>            : #endif</a>
<a name="25084"><span class="lineNum">   25084 </span>            :                       // If we have made progress in skipping over an identity modifier then we need to reevaluate if these are the equivalent types.</a>
<a name="25085"><span class="lineNum">   25085 </span><span class="lineCov">        612 :                          isSame = isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="25086"><span class="lineNum">   25086 </span>            :                        }</a>
<a name="25087"><span class="lineNum">   25087 </span>            :                       else</a>
<a name="25088"><span class="lineNum">   25088 </span>            :                        {</a>
<a name="25089"><span class="lineNum">   25089 </span>            :                       // If we have not skipped over an identity modifier then noting will change in the recursive call and these types are not equivalent (return false).</a>
<a name="25090"><span class="lineNum">   25090 </span>            :                          isSame = false;</a>
<a name="25091"><span class="lineNum">   25091 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25092"><span class="lineNum">   25092 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: no progress was made in resolving the base type, so returning isSame set to false: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25093"><span class="lineNum">   25093 </span>            : #endif</a>
<a name="25094"><span class="lineNum">   25094 </span>            :                        }</a>
<a name="25095"><span class="lineNum">   25095 </span>            : </a>
<a name="25096"><span class="lineNum">   25096 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25097"><span class="lineNum">   25097 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: these are different modifier types: after recursive call to compare base types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25098"><span class="lineNum">   25098 </span>            : #endif</a>
<a name="25099"><span class="lineNum">   25099 </span>            :                   }</a>
<a name="25100"><span class="lineNum">   25100 </span>            :              }</a>
<a name="25101"><span class="lineNum">   25101 </span>            :         }</a>
<a name="25102"><span class="lineNum">   25102 </span>            :        else</a>
<a name="25103"><span class="lineNum">   25103 </span>            :         {</a>
<a name="25104"><span class="lineNum">   25104 </span>            :        // At least one of these is not a SgModifierType.</a>
<a name="25105"><span class="lineNum">   25105 </span>            : </a>
<a name="25106"><span class="lineNum">   25106 </span><span class="lineCov">      62719 :           if (X_modifierType != NULL || Y_modifierType != NULL)</span></a>
<a name="25107"><span class="lineNum">   25107 </span>            :              {</a>
<a name="25108"><span class="lineNum">   25108 </span><span class="lineCov">       2443 :                bool isReduceable = false;</span></a>
<a name="25109"><span class="lineNum">   25109 </span>            : </a>
<a name="25110"><span class="lineNum">   25110 </span>            :             // if (X_modifierType != NULL &amp;&amp; X_modifierType-&gt;get_typeModifier().isDefault() == true)</a>
<a name="25111"><span class="lineNum">   25111 </span><span class="lineCov">       2443 :                if (X_modifierType != NULL &amp;&amp; X_modifierType-&gt;get_typeModifier().isIdentity() == true)</span></a>
<a name="25112"><span class="lineNum">   25112 </span>            :                   {</a>
<a name="25113"><span class="lineNum">   25113 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25114"><span class="lineNum">   25114 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: found default setting for lhs: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25115"><span class="lineNum">   25115 </span>            : #endif</a>
<a name="25116"><span class="lineNum">   25116 </span><span class="lineCov">        645 :                     X_element_type = X_modifierType-&gt;get_base_type();</span></a>
<a name="25117"><span class="lineNum">   25117 </span><span class="lineCov">        645 :                     isReduceable = true;</span></a>
<a name="25118"><span class="lineNum">   25118 </span>            :                   }</a>
<a name="25119"><span class="lineNum">   25119 </span>            : </a>
<a name="25120"><span class="lineNum">   25120 </span>            :             // if (Y_modifierType != NULL &amp;&amp; Y_modifierType-&gt;get_typeModifier().isDefault() == true)</a>
<a name="25121"><span class="lineNum">   25121 </span>            :             // if (Y_modifierType != NULL &amp;&amp; Y_modifierType-&gt;get_typeModifier().isIdentity() == true)</a>
<a name="25122"><span class="lineNum">   25122 </span><span class="lineCov">       2443 :                if (Y_modifierType != NULL &amp;&amp; Y_modifierType-&gt;get_typeModifier().isIdentity() == true)</span></a>
<a name="25123"><span class="lineNum">   25123 </span>            :                   {</a>
<a name="25124"><span class="lineNum">   25124 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25125"><span class="lineNum">   25125 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): loop: found default setting for rhs: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25126"><span class="lineNum">   25126 </span>            : #endif</a>
<a name="25127"><span class="lineNum">   25127 </span><span class="lineCov">        203 :                     Y_element_type = Y_modifierType-&gt;get_base_type();</span></a>
<a name="25128"><span class="lineNum">   25128 </span><span class="lineCov">        203 :                     isReduceable = true;</span></a>
<a name="25129"><span class="lineNum">   25129 </span>            :                   }</a>
<a name="25130"><span class="lineNum">   25130 </span>            : </a>
<a name="25131"><span class="lineNum">   25131 </span>            :             // NOTE: If either of these are a SgTypedefType then the typedefs will be stripped away at the top of the recursive call.</a>
<a name="25132"><span class="lineNum">   25132 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25133"><span class="lineNum">   25133 </span>            :                printf (&quot;In SageInterface::isEquivalentType(): loop: these are different modifier types: after recursive call to compare base types: isReduceable = %s \n&quot;,isReduceable ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25134"><span class="lineNum">   25134 </span>            : #endif</a>
<a name="25135"><span class="lineNum">   25135 </span><span class="lineCov">       2443 :                if (isReduceable == true)</span></a>
<a name="25136"><span class="lineNum">   25136 </span>            :                   {</a>
<a name="25137"><span class="lineNum">   25137 </span>            :                  // Recursive call on non-default modifier base types.</a>
<a name="25138"><span class="lineNum">   25138 </span>            :                  // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25139"><span class="lineNum">   25139 </span><span class="lineCov">        848 :                     isSame = isEquivalentType(X_element_type,Y_element_type);</span></a>
<a name="25140"><span class="lineNum">   25140 </span>            :                   }</a>
<a name="25141"><span class="lineNum">   25141 </span>            :                  else</a>
<a name="25142"><span class="lineNum">   25142 </span>            :                   {</a>
<a name="25143"><span class="lineNum">   25143 </span>            :                  // Neither of these types were reducable.</a>
<a name="25144"><span class="lineNum">   25144 </span>            :                     isSame = false;</a>
<a name="25145"><span class="lineNum">   25145 </span>            :                   }</a>
<a name="25146"><span class="lineNum">   25146 </span>            : </a>
<a name="25147"><span class="lineNum">   25147 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25148"><span class="lineNum">   25148 </span>            :                printf (&quot;In SageInterface::isEquivalentType(): loop: these are different modifier types: after recursive call to compare base types: isReduceable = %s isSame = %s \n&quot;,</a>
<a name="25149"><span class="lineNum">   25149 </span>            :                     isReduceable ? &quot;true&quot; : &quot;false&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25150"><span class="lineNum">   25150 </span>            : #endif</a>
<a name="25151"><span class="lineNum">   25151 </span>            :              }</a>
<a name="25152"><span class="lineNum">   25152 </span>            :             else</a>
<a name="25153"><span class="lineNum">   25153 </span>            :              {</a>
<a name="25154"><span class="lineNum">   25154 </span>            :             // Neither of these are SgModifierType nodes.</a>
<a name="25155"><span class="lineNum">   25155 </span>            :             // X_element_type = X_element_type-&gt;stripType( STRIP_TYPEDEF_TYPE );</a>
<a name="25156"><span class="lineNum">   25156 </span>            :             // Y_element_type = Y_element_type-&gt;stripType( STRIP_TYPEDEF_TYPE );</a>
<a name="25157"><span class="lineNum">   25157 </span>            : </a>
<a name="25158"><span class="lineNum">   25158 </span><span class="lineCov">      60276 :                if (X_element_type == Y_element_type)</span></a>
<a name="25159"><span class="lineNum">   25159 </span>            :                   {</a>
<a name="25160"><span class="lineNum">   25160 </span>            :                     isSame = true;</a>
<a name="25161"><span class="lineNum">   25161 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25162"><span class="lineNum">   25162 </span>            :                  // printf (&quot;In SageInterface::isEquivalentType(): resolved to equal types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25163"><span class="lineNum">   25163 </span>            :                     printf (&quot;In SageInterface::isEquivalentType(): resolved to equal types: isSame = %s lhs = %p = %s rhs = %p = %s \n&quot;,</a>
<a name="25164"><span class="lineNum">   25164 </span>            :                          isSame ? &quot;true&quot; : &quot;false&quot;,lhs,lhs-&gt;unparseToString().c_str(),rhs,rhs-&gt;unparseToString().c_str());</a>
<a name="25165"><span class="lineNum">   25165 </span>            : #endif</a>
<a name="25166"><span class="lineNum">   25166 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25167"><span class="lineNum">   25167 </span>            :                  // DQ (2/13/2018): Debugging type equivalence. If they are the same typedef, they</a>
<a name="25168"><span class="lineNum">   25168 </span>            :                  // still might not be interchangable if one is defined in a restrcited scope.</a>
<a name="25169"><span class="lineNum">   25169 </span>            :                     const SgTypedefType* lhs_typedefType = isSgTypedefType(lhs);</a>
<a name="25170"><span class="lineNum">   25170 </span>            :                     const SgTypedefType* rhs_typedefType = isSgTypedefType(rhs);</a>
<a name="25171"><span class="lineNum">   25171 </span>            : </a>
<a name="25172"><span class="lineNum">   25172 </span>            :                     if (lhs_typedefType != NULL || rhs_typedefType != NULL)</a>
<a name="25173"><span class="lineNum">   25173 </span>            :                        {</a>
<a name="25174"><span class="lineNum">   25174 </span>            : #if 0</a>
<a name="25175"><span class="lineNum">   25175 </span>            :                          if (lhs_typedefType != NULL)</a>
<a name="25176"><span class="lineNum">   25176 </span>            :                             {</a>
<a name="25177"><span class="lineNum">   25177 </span>            :                               printf (&quot;lhs was a typedef: lhs = %p = %s \n&quot;,lhs,lhs-&gt;unparseToString().c_str());</a>
<a name="25178"><span class="lineNum">   25178 </span>            :                             }</a>
<a name="25179"><span class="lineNum">   25179 </span>            :                          if (rhs_typedefType != NULL)</a>
<a name="25180"><span class="lineNum">   25180 </span>            :                             {</a>
<a name="25181"><span class="lineNum">   25181 </span>            :                               printf (&quot;rhs was a typedef: rhs = %p = %s \n&quot;,rhs,rhs-&gt;unparseToString().c_str());</a>
<a name="25182"><span class="lineNum">   25182 </span>            :                             }</a>
<a name="25183"><span class="lineNum">   25183 </span>            : #else</a>
<a name="25184"><span class="lineNum">   25184 </span>            :                          printf (&quot;   --- one was a typedef: lhs = %p = %s \n&quot;,lhs,lhs-&gt;unparseToString().c_str());</a>
<a name="25185"><span class="lineNum">   25185 </span>            :                          printf (&quot;   --- one was a typedef: rhs = %p = %s \n&quot;,rhs,rhs-&gt;unparseToString().c_str());</a>
<a name="25186"><span class="lineNum">   25186 </span>            : #endif</a>
<a name="25187"><span class="lineNum">   25187 </span>            :                        }</a>
<a name="25188"><span class="lineNum">   25188 </span>            : #endif</a>
<a name="25189"><span class="lineNum">   25189 </span>            :                   }</a>
<a name="25190"><span class="lineNum">   25190 </span>            :                  else</a>
<a name="25191"><span class="lineNum">   25191 </span>            :                   {</a>
<a name="25192"><span class="lineNum">   25192 </span>            :                  // DQ (3/20/2016): This is reported by GNU as set but not used.</a>
<a name="25193"><span class="lineNum">   25193 </span>            :                  // bool isReduceable = false;</a>
<a name="25194"><span class="lineNum">   25194 </span>            : </a>
<a name="25195"><span class="lineNum">   25195 </span>            :                  // DQ (11/29/2015): We need to handle reference (when they are both references we can support then uniformally).</a>
<a name="25196"><span class="lineNum">   25196 </span><span class="lineCov">      18108 :                     SgReferenceType* X_referenceType = isSgReferenceType(X_element_type);</span></a>
<a name="25197"><span class="lineNum">   25197 </span><span class="lineCov">      18108 :                     SgReferenceType* Y_referenceType = isSgReferenceType(Y_element_type);</span></a>
<a name="25198"><span class="lineNum">   25198 </span>            : </a>
<a name="25199"><span class="lineNum">   25199 </span><span class="lineCov">      18108 :                     if (X_referenceType != NULL || Y_referenceType != NULL)</span></a>
<a name="25200"><span class="lineNum">   25200 </span>            :                        {</a>
<a name="25201"><span class="lineNum">   25201 </span>            : #if 0</a>
<a name="25202"><span class="lineNum">   25202 </span>            :                          if (X_referenceType != NULL)</a>
<a name="25203"><span class="lineNum">   25203 </span>            :                             {</a>
<a name="25204"><span class="lineNum">   25204 </span>            :                               X_element_type = X_referenceType-&gt;get_base_type();</a>
<a name="25205"><span class="lineNum">   25205 </span>            : </a>
<a name="25206"><span class="lineNum">   25206 </span>            :                            // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a reference.</a>
<a name="25207"><span class="lineNum">   25207 </span>            :                            // isReduceable = true;</a>
<a name="25208"><span class="lineNum">   25208 </span>            :                               isReduceable = false;</a>
<a name="25209"><span class="lineNum">   25209 </span>            :                             }</a>
<a name="25210"><span class="lineNum">   25210 </span>            : </a>
<a name="25211"><span class="lineNum">   25211 </span>            :                          if (Y_referenceType != NULL)</a>
<a name="25212"><span class="lineNum">   25212 </span>            :                             {</a>
<a name="25213"><span class="lineNum">   25213 </span>            :                               Y_element_type = Y_referenceType-&gt;get_base_type();</a>
<a name="25214"><span class="lineNum">   25214 </span>            : </a>
<a name="25215"><span class="lineNum">   25215 </span>            :                            // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a reference.</a>
<a name="25216"><span class="lineNum">   25216 </span>            :                            // isReduceable = true;</a>
<a name="25217"><span class="lineNum">   25217 </span>            :                               isReduceable = false;</a>
<a name="25218"><span class="lineNum">   25218 </span>            :                             }</a>
<a name="25219"><span class="lineNum">   25219 </span>            : </a>
<a name="25220"><span class="lineNum">   25220 </span>            :                          if (isReduceable == true)</a>
<a name="25221"><span class="lineNum">   25221 </span>            :                             {</a>
<a name="25222"><span class="lineNum">   25222 </span>            :                            // Recursive call on non-default modifier base types.</a>
<a name="25223"><span class="lineNum">   25223 </span>            :                            // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25224"><span class="lineNum">   25224 </span>            :                               isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25225"><span class="lineNum">   25225 </span>            :                             }</a>
<a name="25226"><span class="lineNum">   25226 </span>            :                            else</a>
<a name="25227"><span class="lineNum">   25227 </span>            :                             {</a>
<a name="25228"><span class="lineNum">   25228 </span>            :                            // Neither of these types were reducable.</a>
<a name="25229"><span class="lineNum">   25229 </span>            :                               isSame = false;</a>
<a name="25230"><span class="lineNum">   25230 </span>            :                             }</a>
<a name="25231"><span class="lineNum">   25231 </span>            : #else</a>
<a name="25232"><span class="lineNum">   25232 </span>            :                          isSame = false;</a>
<a name="25233"><span class="lineNum">   25233 </span>            : #endif</a>
<a name="25234"><span class="lineNum">   25234 </span>            :                        }</a>
<a name="25235"><span class="lineNum">   25235 </span>            :                       else</a>
<a name="25236"><span class="lineNum">   25236 </span>            :                        {</a>
<a name="25237"><span class="lineNum">   25237 </span>            :                       // Recursive call on non-typedef base types.</a>
<a name="25238"><span class="lineNum">   25238 </span>            :                       // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25239"><span class="lineNum">   25239 </span>            :                       // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25240"><span class="lineNum">   25240 </span>            : </a>
<a name="25241"><span class="lineNum">   25241 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25242"><span class="lineNum">   25242 </span>            :                          printf (&quot;In SageInterface::isEquivalentType(): loop: evaluation of inner types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25243"><span class="lineNum">   25243 </span>            : #endif</a>
<a name="25244"><span class="lineNum">   25244 </span>            : </a>
<a name="25245"><span class="lineNum">   25245 </span>            :                       // DQ (11/29/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="25246"><span class="lineNum">   25246 </span><span class="lineCov">      17023 :                          SgPointerType* X_pointerType = isSgPointerType(X_element_type);</span></a>
<a name="25247"><span class="lineNum">   25247 </span><span class="lineCov">      17023 :                          SgPointerType* Y_pointerType = isSgPointerType(Y_element_type);</span></a>
<a name="25248"><span class="lineNum">   25248 </span>            : </a>
<a name="25249"><span class="lineNum">   25249 </span><span class="lineCov">      17023 :                          if (X_pointerType != NULL || Y_pointerType != NULL)</span></a>
<a name="25250"><span class="lineNum">   25250 </span>            :                             {</a>
<a name="25251"><span class="lineNum">   25251 </span>            : #if 0</a>
<a name="25252"><span class="lineNum">   25252 </span>            :                               if (X_pointerType != NULL)</a>
<a name="25253"><span class="lineNum">   25253 </span>            :                                  {</a>
<a name="25254"><span class="lineNum">   25254 </span>            :                                    X_element_type = X_pointerType-&gt;get_base_type();</a>
<a name="25255"><span class="lineNum">   25255 </span>            : </a>
<a name="25256"><span class="lineNum">   25256 </span>            :                                 // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a pointer.</a>
<a name="25257"><span class="lineNum">   25257 </span>            :                                 // isReduceable = true;</a>
<a name="25258"><span class="lineNum">   25258 </span>            :                                    isReduceable = false;</a>
<a name="25259"><span class="lineNum">   25259 </span>            :                                  }</a>
<a name="25260"><span class="lineNum">   25260 </span>            : </a>
<a name="25261"><span class="lineNum">   25261 </span>            :                               if (Y_pointerType != NULL)</a>
<a name="25262"><span class="lineNum">   25262 </span>            :                                  {</a>
<a name="25263"><span class="lineNum">   25263 </span>            :                                    Y_element_type = Y_pointerType-&gt;get_base_type();</a>
<a name="25264"><span class="lineNum">   25264 </span>            : </a>
<a name="25265"><span class="lineNum">   25265 </span>            :                                 // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a pointer.</a>
<a name="25266"><span class="lineNum">   25266 </span>            :                                 // isReduceable = true;</a>
<a name="25267"><span class="lineNum">   25267 </span>            :                                    isReduceable = false;</a>
<a name="25268"><span class="lineNum">   25268 </span>            :                                  }</a>
<a name="25269"><span class="lineNum">   25269 </span>            : </a>
<a name="25270"><span class="lineNum">   25270 </span>            :                               if (isReduceable == true)</a>
<a name="25271"><span class="lineNum">   25271 </span>            :                                  {</a>
<a name="25272"><span class="lineNum">   25272 </span>            :                                 // Recursive call on non-default modifier base types.</a>
<a name="25273"><span class="lineNum">   25273 </span>            :                                 // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25274"><span class="lineNum">   25274 </span>            :                                    isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25275"><span class="lineNum">   25275 </span>            :                                  }</a>
<a name="25276"><span class="lineNum">   25276 </span>            :                                 else</a>
<a name="25277"><span class="lineNum">   25277 </span>            :                                  {</a>
<a name="25278"><span class="lineNum">   25278 </span>            :                                 // Neither of these types were reducable.</a>
<a name="25279"><span class="lineNum">   25279 </span>            :                                    isSame = false;</a>
<a name="25280"><span class="lineNum">   25280 </span>            :                                  }</a>
<a name="25281"><span class="lineNum">   25281 </span>            : #else</a>
<a name="25282"><span class="lineNum">   25282 </span>            :                               isSame = false;</a>
<a name="25283"><span class="lineNum">   25283 </span>            : #endif</a>
<a name="25284"><span class="lineNum">   25284 </span>            :                             }</a>
<a name="25285"><span class="lineNum">   25285 </span>            :                            else</a>
<a name="25286"><span class="lineNum">   25286 </span>            :                             {</a>
<a name="25287"><span class="lineNum">   25287 </span>            :                            // Recursive call on non-typedef base types.</a>
<a name="25288"><span class="lineNum">   25288 </span>            :                            // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25289"><span class="lineNum">   25289 </span>            :                            // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25290"><span class="lineNum">   25290 </span>            : </a>
<a name="25291"><span class="lineNum">   25291 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25292"><span class="lineNum">   25292 </span>            :                               printf (&quot;In SageInterface::isEquivalentType(): loop: evaluation of inner types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25293"><span class="lineNum">   25293 </span>            : #endif</a>
<a name="25294"><span class="lineNum">   25294 </span>            : </a>
<a name="25295"><span class="lineNum">   25295 </span>            :                            // DQ (11/29/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="25296"><span class="lineNum">   25296 </span><span class="lineCov">      14652 :                               SgArrayType* X_arrayType = isSgArrayType(X_element_type);</span></a>
<a name="25297"><span class="lineNum">   25297 </span><span class="lineCov">      14652 :                               SgArrayType* Y_arrayType = isSgArrayType(Y_element_type);</span></a>
<a name="25298"><span class="lineNum">   25298 </span>            : </a>
<a name="25299"><span class="lineNum">   25299 </span><span class="lineCov">      14652 :                               if (X_arrayType != NULL || Y_arrayType != NULL)</span></a>
<a name="25300"><span class="lineNum">   25300 </span>            :                                  {</a>
<a name="25301"><span class="lineNum">   25301 </span>            : #if 0</a>
<a name="25302"><span class="lineNum">   25302 </span>            :                                    if (X_arrayType != NULL)</a>
<a name="25303"><span class="lineNum">   25303 </span>            :                                       {</a>
<a name="25304"><span class="lineNum">   25304 </span>            :                                         X_element_type = X_arrayType-&gt;get_base_type();</a>
<a name="25305"><span class="lineNum">   25305 </span>            : </a>
<a name="25306"><span class="lineNum">   25306 </span>            :                                      // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a array.</a>
<a name="25307"><span class="lineNum">   25307 </span>            :                                      // isReduceable = true;</a>
<a name="25308"><span class="lineNum">   25308 </span>            :                                         isReduceable = false;</a>
<a name="25309"><span class="lineNum">   25309 </span>            :                                       }</a>
<a name="25310"><span class="lineNum">   25310 </span>            : </a>
<a name="25311"><span class="lineNum">   25311 </span>            :                                    if (Y_arrayType != NULL)</a>
<a name="25312"><span class="lineNum">   25312 </span>            :                                       {</a>
<a name="25313"><span class="lineNum">   25313 </span>            :                                         Y_element_type = Y_arrayType-&gt;get_base_type();</a>
<a name="25314"><span class="lineNum">   25314 </span>            : </a>
<a name="25315"><span class="lineNum">   25315 </span>            :                                      // DQ (12/8/2015): Note that we don't want to compare base types if only one of these was a array.</a>
<a name="25316"><span class="lineNum">   25316 </span>            :                                      // isReduceable = true;</a>
<a name="25317"><span class="lineNum">   25317 </span>            :                                         isReduceable = false;</a>
<a name="25318"><span class="lineNum">   25318 </span>            :                                       }</a>
<a name="25319"><span class="lineNum">   25319 </span>            : </a>
<a name="25320"><span class="lineNum">   25320 </span>            :                                    if (isReduceable == true)</a>
<a name="25321"><span class="lineNum">   25321 </span>            :                                       {</a>
<a name="25322"><span class="lineNum">   25322 </span>            :                                      // Recursive call on non-default modifier base types.</a>
<a name="25323"><span class="lineNum">   25323 </span>            :                                      // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25324"><span class="lineNum">   25324 </span>            :                                         isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25325"><span class="lineNum">   25325 </span>            :                                       }</a>
<a name="25326"><span class="lineNum">   25326 </span>            :                                      else</a>
<a name="25327"><span class="lineNum">   25327 </span>            :                                       {</a>
<a name="25328"><span class="lineNum">   25328 </span>            :                                      // Neither of these types were reducable.</a>
<a name="25329"><span class="lineNum">   25329 </span>            :                                         isSame = false;</a>
<a name="25330"><span class="lineNum">   25330 </span>            :                                       }</a>
<a name="25331"><span class="lineNum">   25331 </span>            : #else</a>
<a name="25332"><span class="lineNum">   25332 </span>            :                                    isSame = false;</a>
<a name="25333"><span class="lineNum">   25333 </span>            : #endif</a>
<a name="25334"><span class="lineNum">   25334 </span>            :                                  }</a>
<a name="25335"><span class="lineNum">   25335 </span>            :                                 else</a>
<a name="25336"><span class="lineNum">   25336 </span>            :                                  {</a>
<a name="25337"><span class="lineNum">   25337 </span>            :                                 // Recursive call on non-typedef base types.</a>
<a name="25338"><span class="lineNum">   25338 </span>            :                                 // isSame = (*X_element_type) == (*Y_element_type);</a>
<a name="25339"><span class="lineNum">   25339 </span>            :                                 // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25340"><span class="lineNum">   25340 </span>            : </a>
<a name="25341"><span class="lineNum">   25341 </span>            : #if DEBUG_TYPE_EQUIVALENCE</a>
<a name="25342"><span class="lineNum">   25342 </span>            :                                    printf (&quot;In SageInterface::isEquivalentType(): loop: evaluation of inner types: isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25343"><span class="lineNum">   25343 </span>            : #endif</a>
<a name="25344"><span class="lineNum">   25344 </span>            : </a>
<a name="25345"><span class="lineNum">   25345 </span>            :                                 // DQ (11/29/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="25346"><span class="lineNum">   25346 </span><span class="lineCov">      14651 :                                    SgFunctionType* X_functionType = isSgFunctionType(X_element_type);</span></a>
<a name="25347"><span class="lineNum">   25347 </span><span class="lineCov">      14651 :                                    SgFunctionType* Y_functionType = isSgFunctionType(Y_element_type);</span></a>
<a name="25348"><span class="lineNum">   25348 </span>            : </a>
<a name="25349"><span class="lineNum">   25349 </span><span class="lineCov">      14651 :                                    if (X_functionType != NULL || Y_functionType != NULL)</span></a>
<a name="25350"><span class="lineNum">   25350 </span>            :                                       {</a>
<a name="25351"><span class="lineNum">   25351 </span><span class="lineNoCov">          0 :                                         bool value = ( (X_functionType != NULL &amp;&amp; Y_functionType != NULL) &amp;&amp; (X_functionType == Y_functionType) );</span></a>
<a name="25352"><span class="lineNum">   25352 </span>            :                                         //TODO: Liao, 9/15/2016, better comparison of function types</a>
<a name="25353"><span class="lineNum">   25353 </span>            :                                         //bool value = ( (X_functionType != NULL &amp;&amp; Y_functionType != NULL) &amp;&amp; (isEquivalentFunctionType(X_functionType, Y_functionType)) );</a>
<a name="25354"><span class="lineNum">   25354 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25355"><span class="lineNum">   25355 </span>            :                                         printf (&quot;In SageInterface::isEquivalentType(): loop: Process case of SgFunctionType: value = %s \n&quot;,value ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25356"><span class="lineNum">   25356 </span>            : #endif</a>
<a name="25357"><span class="lineNum">   25357 </span>            :                                      // DQ (3/20/2016): This is reported by GNU as a meaningless statement.</a>
<a name="25358"><span class="lineNum">   25358 </span>            :                                      // isSame == value;</a>
<a name="25359"><span class="lineNum">   25359 </span>            :                                         isSame = value;</a>
<a name="25360"><span class="lineNum">   25360 </span>            : </a>
<a name="25361"><span class="lineNum">   25361 </span>            :                                      // DQ (3/20/2016): This is reported by GNU as set but not used.</a>
<a name="25362"><span class="lineNum">   25362 </span>            :                                      // isReduceable = false;</a>
<a name="25363"><span class="lineNum">   25363 </span>            :                                       }</a>
<a name="25364"><span class="lineNum">   25364 </span>            :                                      else</a>
<a name="25365"><span class="lineNum">   25365 </span>            :                                       {</a>
<a name="25366"><span class="lineNum">   25366 </span>            :                                      // Recursive call on non-typedef base types.</a>
<a name="25367"><span class="lineNum">   25367 </span>            :                                      // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25368"><span class="lineNum">   25368 </span>            : </a>
<a name="25369"><span class="lineNum">   25369 </span>            :                                      // DQ (11/29/2015): We need to handle pointers (when they are both pointers we can support then uniformally).</a>
<a name="25370"><span class="lineNum">   25370 </span><span class="lineCov">      14651 :                                         SgMemberFunctionType* X_memberFunctionType = isSgMemberFunctionType(X_element_type);</span></a>
<a name="25371"><span class="lineNum">   25371 </span><span class="lineCov">      14651 :                                         SgMemberFunctionType* Y_memberFunctionType = isSgMemberFunctionType(Y_element_type);</span></a>
<a name="25372"><span class="lineNum">   25372 </span>            : </a>
<a name="25373"><span class="lineNum">   25373 </span><span class="lineCov">      14651 :                                         if (X_memberFunctionType != NULL || Y_memberFunctionType != NULL)</span></a>
<a name="25374"><span class="lineNum">   25374 </span>            :                                            {</a>
<a name="25375"><span class="lineNum">   25375 </span>            :                                           // DQ (12/15/2015): This code should be unreachable since it would have executed the code above (the case of SgFunctionType).</a>
<a name="25376"><span class="lineNum">   25376 </span><span class="lineNoCov">          0 :                                              printf (&quot;This should be unreachable code \n&quot;);</span></a>
<a name="25377"><span class="lineNum">   25377 </span><span class="lineNoCov">          0 :                                              ROSE_ABORT();</span></a>
<a name="25378"><span class="lineNum">   25378 </span>            : </a>
<a name="25379"><span class="lineNum">   25379 </span>            : #if 0 // [Robb Matzke 2021-03-24]: unreachable</a>
<a name="25380"><span class="lineNum">   25380 </span>            :                                              bool value = ( (X_memberFunctionType != NULL &amp;&amp; Y_memberFunctionType != NULL) &amp;&amp; (X_memberFunctionType == Y_memberFunctionType) );</a>
<a name="25381"><span class="lineNum">   25381 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25382"><span class="lineNum">   25382 </span>            :                                              printf (&quot;In SageInterface::isEquivalentType(): loop: Process case of SgMemberFunctionType: value = %s \n&quot;,value ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25383"><span class="lineNum">   25383 </span>            : #endif</a>
<a name="25384"><span class="lineNum">   25384 </span>            :                                           // DQ (3/20/2016): This is reported by GNU as a meaningless statement.</a>
<a name="25385"><span class="lineNum">   25385 </span>            :                                           // isSame == value;</a>
<a name="25386"><span class="lineNum">   25386 </span>            :                                              isSame = value;</a>
<a name="25387"><span class="lineNum">   25387 </span>            : #endif</a>
<a name="25388"><span class="lineNum">   25388 </span>            :                                            }</a>
<a name="25389"><span class="lineNum">   25389 </span>            :                                           else</a>
<a name="25390"><span class="lineNum">   25390 </span>            :                                            {</a>
<a name="25391"><span class="lineNum">   25391 </span>            :                                           // Recursive call on non-typedef base types.</a>
<a name="25392"><span class="lineNum">   25392 </span>            :                                           // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25393"><span class="lineNum">   25393 </span>            : #if 0</a>
<a name="25394"><span class="lineNum">   25394 </span>            :                                           // Check for irreducable types.</a>
<a name="25395"><span class="lineNum">   25395 </span>            :                                              bool X_isReduceable = true;</a>
<a name="25396"><span class="lineNum">   25396 </span>            :                                              if (isSgTypeSignedLong(X_element_type)  != NULL ||</a>
<a name="25397"><span class="lineNum">   25397 </span>            :                                                  isSgTypeUnsignedInt(X_element_type) != NULL ||</a>
<a name="25398"><span class="lineNum">   25398 </span>            :                                                  isSgTypeBool(X_element_type) != NULL ||</a>
<a name="25399"><span class="lineNum">   25399 </span>            :                                                  isSgTypeInt(X_element_type) != NULL)</a>
<a name="25400"><span class="lineNum">   25400 </span>            :                                                 {</a>
<a name="25401"><span class="lineNum">   25401 </span>            :                                                   X_isReduceable = false;</a>
<a name="25402"><span class="lineNum">   25402 </span>            :                                                 }</a>
<a name="25403"><span class="lineNum">   25403 </span>            : </a>
<a name="25404"><span class="lineNum">   25404 </span>            :                                              bool Y_isReduceable = true;</a>
<a name="25405"><span class="lineNum">   25405 </span>            :                                              if (isSgTypeSignedLong(Y_element_type)  != NULL ||</a>
<a name="25406"><span class="lineNum">   25406 </span>            :                                                  isSgTypeUnsignedInt(Y_element_type) != NULL ||</a>
<a name="25407"><span class="lineNum">   25407 </span>            :                                                  isSgTypeBool(Y_element_type) != NULL ||</a>
<a name="25408"><span class="lineNum">   25408 </span>            :                                                  isSgTypeInt(Y_element_type) != NULL)</a>
<a name="25409"><span class="lineNum">   25409 </span>            :                                                 {</a>
<a name="25410"><span class="lineNum">   25410 </span>            :                                                   Y_isReduceable = false;</a>
<a name="25411"><span class="lineNum">   25411 </span>            :                                                 }</a>
<a name="25412"><span class="lineNum">   25412 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25413"><span class="lineNum">   25413 </span>            :                                              printf (&quot;In SageInterface::isEquivalentType(): loop: Process default case: X_isReduceable = %s Y_isReduceable = %s \n&quot;,</a>
<a name="25414"><span class="lineNum">   25414 </span>            :                                                   X_isReduceable ? &quot;true&quot; : &quot;false&quot;,Y_isReduceable ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25415"><span class="lineNum">   25415 </span>            : #endif</a>
<a name="25416"><span class="lineNum">   25416 </span>            :                                              if (X_isReduceable == true || Y_isReduceable == true)</a>
<a name="25417"><span class="lineNum">   25417 </span>            :                                                 {</a>
<a name="25418"><span class="lineNum">   25418 </span>            :                                                // Recursive call on non-default modifier base types.</a>
<a name="25419"><span class="lineNum">   25419 </span>            :                                                   isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25420"><span class="lineNum">   25420 </span>            :                                                 }</a>
<a name="25421"><span class="lineNum">   25421 </span>            :                                                else</a>
<a name="25422"><span class="lineNum">   25422 </span>            :                                                 {</a>
<a name="25423"><span class="lineNum">   25423 </span>            :                                                // Neither of these types were reducable.</a>
<a name="25424"><span class="lineNum">   25424 </span>            :                                                   isSame = false;</a>
<a name="25425"><span class="lineNum">   25425 </span>            :                                                 }</a>
<a name="25426"><span class="lineNum">   25426 </span>            : #else</a>
<a name="25427"><span class="lineNum">   25427 </span>            :                                           // DQ (12/20/2015): This is the default case for irreducable types.</a>
<a name="25428"><span class="lineNum">   25428 </span><span class="lineCov">      14651 :                                              if (X_element_type-&gt;variantT() == Y_element_type-&gt;variantT())</span></a>
<a name="25429"><span class="lineNum">   25429 </span>            :                                                 {</a>
<a name="25430"><span class="lineNum">   25430 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25431"><span class="lineNum">   25431 </span>            :                                                   printf (&quot;In SageInterface::isEquivalentType(): loop: Process default case: X_element_type = %p = %s Y_element_type = %p = %s \n&quot;,</a>
<a name="25432"><span class="lineNum">   25432 </span>            :                                                        X_element_type,X_element_type-&gt;class_name().c_str(),Y_element_type,Y_element_type-&gt;class_name().c_str());</a>
<a name="25433"><span class="lineNum">   25433 </span>            : #endif</a>
<a name="25434"><span class="lineNum">   25434 </span>            :                                                // DQ (5/26/2016): It is not good enough that the variants match.</a>
<a name="25435"><span class="lineNum">   25435 </span>            :                                                // isSame = true;</a>
<a name="25436"><span class="lineNum">   25436 </span>            :                                                // isSame = isEquivalentType(X_element_type,Y_element_type);</a>
<a name="25437"><span class="lineNum">   25437 </span>            :                                                   isSame = (X_element_type == Y_element_type);</a>
<a name="25438"><span class="lineNum">   25438 </span>            :                                                 }</a>
<a name="25439"><span class="lineNum">   25439 </span>            :                                                else</a>
<a name="25440"><span class="lineNum">   25440 </span>            :                                                 {</a>
<a name="25441"><span class="lineNum">   25441 </span>            :                                                // Neither of these types were reducable or equal.</a>
<a name="25442"><span class="lineNum">   25442 </span>            :                                                   isSame = false;</a>
<a name="25443"><span class="lineNum">   25443 </span>            :                                                 }</a>
<a name="25444"><span class="lineNum">   25444 </span>            : #endif</a>
<a name="25445"><span class="lineNum">   25445 </span>            :                                            }</a>
<a name="25446"><span class="lineNum">   25446 </span>            :                                       }</a>
<a name="25447"><span class="lineNum">   25447 </span>            :                                  }</a>
<a name="25448"><span class="lineNum">   25448 </span>            :                             }</a>
<a name="25449"><span class="lineNum">   25449 </span>            :                        }</a>
<a name="25450"><span class="lineNum">   25450 </span>            :                   }</a>
<a name="25451"><span class="lineNum">   25451 </span>            :              }</a>
<a name="25452"><span class="lineNum">   25452 </span>            :         }</a>
<a name="25453"><span class="lineNum">   25453 </span>            : </a>
<a name="25454"><span class="lineNum">   25454 </span>            :   // Decrement the static variable to control the recursive depth while we debug this.</a>
<a name="25455"><span class="lineNum">   25455 </span><span class="lineCov">      69785 :      counter--;</span></a>
<a name="25456"><span class="lineNum">   25456 </span>            : </a>
<a name="25457"><span class="lineNum">   25457 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25458"><span class="lineNum">   25458 </span>            :      printf (&quot;In SageInterface::isEquivalentType(): isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25459"><span class="lineNum">   25459 </span>            : #endif</a>
<a name="25460"><span class="lineNum">   25460 </span>            : </a>
<a name="25461"><span class="lineNum">   25461 </span>            : #if DEBUG_TYPE_EQUIVALENCE || 0</a>
<a name="25462"><span class="lineNum">   25462 </span>            :   // if (counter == 1)</a>
<a name="25463"><span class="lineNum">   25463 </span>            :      if (counter == 1 &amp;&amp; isSame == true)</a>
<a name="25464"><span class="lineNum">   25464 </span>            :         {</a>
<a name="25465"><span class="lineNum">   25465 </span>            :           printf (&quot;In SageInterface::isEquivalentType(): counter = %d: isSame = %s type chain X_element_type = %s Y_element_type = %s \n&quot;,counter,isSame ? &quot;true&quot; : &quot;false&quot;,X.class_name().c_str(),Y.class_name().c_str());</a>
<a name="25466"><span class="lineNum">   25466 </span>            : </a>
<a name="25467"><span class="lineNum">   25467 </span>            :        // Debugging output.</a>
<a name="25468"><span class="lineNum">   25468 </span>            :           Rose_STL_Container&lt;SgType*&gt; X_typeChain = X.getInternalTypes();</a>
<a name="25469"><span class="lineNum">   25469 </span>            :           Rose_STL_Container&lt;SgType*&gt; Y_typeChain = Y.getInternalTypes();</a>
<a name="25470"><span class="lineNum">   25470 </span>            : </a>
<a name="25471"><span class="lineNum">   25471 </span>            :        // Debugging output.</a>
<a name="25472"><span class="lineNum">   25472 </span>            :           printf (&quot;   --- Output of type chain for lhs: \n&quot;);</a>
<a name="25473"><span class="lineNum">   25473 </span>            :           for (size_t i = 0; i &lt; X_typeChain.size(); i++)</a>
<a name="25474"><span class="lineNum">   25474 </span>            :              {</a>
<a name="25475"><span class="lineNum">   25475 </span>            :                SgType* element_type = X_typeChain[i];</a>
<a name="25476"><span class="lineNum">   25476 </span>            :                printf (&quot;   --- --- X_element_type = %p = %s \n&quot;,element_type,element_type-&gt;class_name().c_str());</a>
<a name="25477"><span class="lineNum">   25477 </span>            :                SgModifierType* modifierType = isSgModifierType(element_type);</a>
<a name="25478"><span class="lineNum">   25478 </span>            :                if (modifierType != NULL)</a>
<a name="25479"><span class="lineNum">   25479 </span>            :                   {</a>
<a name="25480"><span class="lineNum">   25480 </span>            :                  // modifierType-&gt;get_typeModifier().display(&quot;X type chain&quot;);</a>
<a name="25481"><span class="lineNum">   25481 </span>            :                     string s = modifierType-&gt;get_typeModifier().displayString();</a>
<a name="25482"><span class="lineNum">   25482 </span>            :                     printf (&quot;   --- type chain modifier: %s \n&quot;,s.c_str());</a>
<a name="25483"><span class="lineNum">   25483 </span>            :                   }</a>
<a name="25484"><span class="lineNum">   25484 </span>            :              }</a>
<a name="25485"><span class="lineNum">   25485 </span>            : </a>
<a name="25486"><span class="lineNum">   25486 </span>            :           printf (&quot;   --- Output of type chain for rhs: \n&quot;);</a>
<a name="25487"><span class="lineNum">   25487 </span>            :           for (size_t i = 0; i &lt; Y_typeChain.size(); i++)</a>
<a name="25488"><span class="lineNum">   25488 </span>            :              {</a>
<a name="25489"><span class="lineNum">   25489 </span>            :                SgType* element_type = Y_typeChain[i];</a>
<a name="25490"><span class="lineNum">   25490 </span>            :                printf (&quot;   --- --- Y_element_type = %p = %s \n&quot;,element_type,element_type-&gt;class_name().c_str());</a>
<a name="25491"><span class="lineNum">   25491 </span>            :                SgModifierType* modifierType = isSgModifierType(element_type);</a>
<a name="25492"><span class="lineNum">   25492 </span>            :                if (modifierType != NULL)</a>
<a name="25493"><span class="lineNum">   25493 </span>            :                   {</a>
<a name="25494"><span class="lineNum">   25494 </span>            :                  // modifierType-&gt;get_typeModifier().display(&quot;Y type chain&quot;);</a>
<a name="25495"><span class="lineNum">   25495 </span>            :                     string s = modifierType-&gt;get_typeModifier().displayString();</a>
<a name="25496"><span class="lineNum">   25496 </span>            :                     printf (&quot;   --- --- type chain modifier: %s \n&quot;,s.c_str());</a>
<a name="25497"><span class="lineNum">   25497 </span>            :                   }</a>
<a name="25498"><span class="lineNum">   25498 </span>            :              }</a>
<a name="25499"><span class="lineNum">   25499 </span>            :         }</a>
<a name="25500"><span class="lineNum">   25500 </span>            : #endif</a>
<a name="25501"><span class="lineNum">   25501 </span>            : </a>
<a name="25502"><span class="lineNum">   25502 </span>            : #if 0</a>
<a name="25503"><span class="lineNum">   25503 </span>            :      if (counter == 0)</a>
<a name="25504"><span class="lineNum">   25504 </span>            :         {</a>
<a name="25505"><span class="lineNum">   25505 </span>            :       // if (counter == 1 &amp;&amp; isSame == true)</a>
<a name="25506"><span class="lineNum">   25506 </span>            :           if (isSame == true)</a>
<a name="25507"><span class="lineNum">   25507 </span>            :              {</a>
<a name="25508"><span class="lineNum">   25508 </span>            :             // printf (&quot;In SageInterface::isEquivalentType(): counter = %d: isSame = %s type chain X_element_type = %s Y_element_type = %s \n&quot;,counter,isSame ? &quot;true&quot; : &quot;false&quot;,X.class_name().c_str(),Y.class_name().c_str());</a>
<a name="25509"><span class="lineNum">   25509 </span>            :                printf (&quot;   --- isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25510"><span class="lineNum">   25510 </span>            :             // printf (&quot;   --- --- X_element_type = %p = %s = %s \n&quot;,X_element_type,X_element_type-&gt;class_name().c_str(),X_element_type-&gt;unparseToString().c_str());</a>
<a name="25511"><span class="lineNum">   25511 </span>            :             // printf (&quot;   --- --- Y_element_type = %p = %s = %s \n&quot;,Y_element_type,Y_element_type-&gt;class_name().c_str(),Y_element_type-&gt;unparseToString().c_str());</a>
<a name="25512"><span class="lineNum">   25512 </span>            :                printf (&quot;   --- --- X_element_type = %p = %s = %s \n&quot;,X_element_type,X_element_type-&gt;class_name().c_str(),X_element_type-&gt;unparseToString().c_str());</a>
<a name="25513"><span class="lineNum">   25513 </span>            :                printf (&quot;   --- --- Y_element_type = %p = %s = %s \n&quot;,Y_element_type,Y_element_type-&gt;class_name().c_str(),Y_element_type-&gt;unparseToString().c_str());</a>
<a name="25514"><span class="lineNum">   25514 </span>            :              }</a>
<a name="25515"><span class="lineNum">   25515 </span>            :             else</a>
<a name="25516"><span class="lineNum">   25516 </span>            :              {</a>
<a name="25517"><span class="lineNum">   25517 </span>            :             // printf (&quot;In SageInterface::isEquivalentType(): counter = %d: isSame = %s type chain X_element_type = %s Y_element_type = %s \n&quot;,counter,isSame ? &quot;true&quot; : &quot;false&quot;,X.class_name().c_str(),Y.class_name().c_str());</a>
<a name="25518"><span class="lineNum">   25518 </span>            :                printf (&quot;   --- isSame = %s \n&quot;,isSame ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25519"><span class="lineNum">   25519 </span>            :              }</a>
<a name="25520"><span class="lineNum">   25520 </span>            :         }</a>
<a name="25521"><span class="lineNum">   25521 </span>            :        else</a>
<a name="25522"><span class="lineNum">   25522 </span>            :         {</a>
<a name="25523"><span class="lineNum">   25523 </span>            :           printf (&quot;   --- counter = %d \n&quot;,counter);</a>
<a name="25524"><span class="lineNum">   25524 </span>            :         }</a>
<a name="25525"><span class="lineNum">   25525 </span>            : #endif</a>
<a name="25526"><span class="lineNum">   25526 </span>            : </a>
<a name="25527"><span class="lineNum">   25527 </span><span class="lineCov">      69785 :      return isSame;</span></a>
<a name="25528"><span class="lineNum">   25528 </span>            :    }</a>
<a name="25529"><span class="lineNum">   25529 </span>            : </a>
<a name="25530"><span class="lineNum">   25530 </span>            : </a>
<a name="25531"><span class="lineNum">   25531 </span>            : #if 0</a>
<a name="25532"><span class="lineNum">   25532 </span>            : // This is modified to be a template function and so must be moved to the header file.</a>
<a name="25533"><span class="lineNum">   25533 </span>            : // DQ (8/30/2016): Added function to detect EDG AST normalization.</a>
<a name="25534"><span class="lineNum">   25534 </span>            : bool</a>
<a name="25535"><span class="lineNum">   25535 </span>            : SageInterface::isNormalizedTemplateInstantiation (SgFunctionDeclaration* function)</a>
<a name="25536"><span class="lineNum">   25536 </span>            :    {</a>
<a name="25537"><span class="lineNum">   25537 </span>            :   // This function is called in the Call graph generation to avoid filtering out EDG normalized</a>
<a name="25538"><span class="lineNum">   25538 </span>            :   // function template instnatiations (which come from normalized template functions and member functions).</a>
<a name="25539"><span class="lineNum">   25539 </span>            : </a>
<a name="25540"><span class="lineNum">   25540 </span>            :      bool retval = false;</a>
<a name="25541"><span class="lineNum">   25541 </span>            : </a>
<a name="25542"><span class="lineNum">   25542 </span>            : #if 1</a>
<a name="25543"><span class="lineNum">   25543 </span>            :   // DQ (8/30/2016): We need to mark this as an EDG normalization so that we can detect it as an exception</a>
<a name="25544"><span class="lineNum">   25544 </span>            :   // to some simple attempts to filter the AST (e.g. for the Call Graph implementation which filters on only</a>
<a name="25545"><span class="lineNum">   25545 </span>            :   // functions in the current directory).  This explicit makring makes it much easier to get this test correct.</a>
<a name="25546"><span class="lineNum">   25546 </span>            :   // But we still need to look at if the location of the parent template is something that we wnat to output.</a>
<a name="25547"><span class="lineNum">   25547 </span>            :   // If tis is a template instantiation then it is not enough to look only at the non-defining declaration if</a>
<a name="25548"><span class="lineNum">   25548 </span>            :   // it is not compiler generated.</a>
<a name="25549"><span class="lineNum">   25549 </span>            :      retval = function-&gt;get_marked_as_edg_normalization();</a>
<a name="25550"><span class="lineNum">   25550 </span>            : #else</a>
<a name="25551"><span class="lineNum">   25551 </span>            :   // Test for this to be a template instantation (in which case it was marked as</a>
<a name="25552"><span class="lineNum">   25552 </span>            :   // compiler generated but we may want to allow it to be used in the call graph,</a>
<a name="25553"><span class="lineNum">   25553 </span>            :   // if it's template was a part was defined in the current directory).</a>
<a name="25554"><span class="lineNum">   25554 </span>            :      SgTemplateInstantiationFunctionDecl*       templateInstantiationFunction       = isSgTemplateInstantiationFunctionDecl(function);</a>
<a name="25555"><span class="lineNum">   25555 </span>            :      SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(function);</a>
<a name="25556"><span class="lineNum">   25556 </span>            : </a>
<a name="25557"><span class="lineNum">   25557 </span>            :      if (templateInstantiationFunction != NULL)</a>
<a name="25558"><span class="lineNum">   25558 </span>            :         {</a>
<a name="25559"><span class="lineNum">   25559 </span>            :        // When the defining function has been normalized by EDG, only the non-defining declaration will have a source position.</a>
<a name="25560"><span class="lineNum">   25560 </span>            :           templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(templateInstantiationFunction-&gt;get_firstNondefiningDeclaration());</a>
<a name="25561"><span class="lineNum">   25561 </span>            :           SgTemplateFunctionDeclaration* templateFunctionDeclaration = templateInstantiationFunction-&gt;get_templateDeclaration();</a>
<a name="25562"><span class="lineNum">   25562 </span>            :           if (templateFunctionDeclaration != NULL)</a>
<a name="25563"><span class="lineNum">   25563 </span>            :              {</a>
<a name="25564"><span class="lineNum">   25564 </span>            :             // retval = operator()(templateFunctionDeclaration);</a>
<a name="25565"><span class="lineNum">   25565 </span>            :                retval = (templateFunctionDeclaration-&gt;isCompilerGenerated() == false);</a>
<a name="25566"><span class="lineNum">   25566 </span>            :              }</a>
<a name="25567"><span class="lineNum">   25567 </span>            :             else</a>
<a name="25568"><span class="lineNum">   25568 </span>            :              {</a>
<a name="25569"><span class="lineNum">   25569 </span>            :              // Assume false.</a>
<a name="25570"><span class="lineNum">   25570 </span>            :              }</a>
<a name="25571"><span class="lineNum">   25571 </span>            : </a>
<a name="25572"><span class="lineNum">   25572 </span>            : #if DEBUG_SELECTOR</a>
<a name="25573"><span class="lineNum">   25573 </span>            :           printf (&quot;   --- case of templateInstantiationFunction: retval = %s \n&quot;,retval ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25574"><span class="lineNum">   25574 </span>            : #endif</a>
<a name="25575"><span class="lineNum">   25575 </span>            :         }</a>
<a name="25576"><span class="lineNum">   25576 </span>            :        else</a>
<a name="25577"><span class="lineNum">   25577 </span>            :         {</a>
<a name="25578"><span class="lineNum">   25578 </span>            :           if (templateInstantiationMemberFunction != NULL)</a>
<a name="25579"><span class="lineNum">   25579 </span>            :              {</a>
<a name="25580"><span class="lineNum">   25580 </span>            :             // When the defining function has been normalized by EDG, only the non-defining declaration will have a source position.</a>
<a name="25581"><span class="lineNum">   25581 </span>            :                templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(templateInstantiationMemberFunction-&gt;get_firstNondefiningDeclaration());</a>
<a name="25582"><span class="lineNum">   25582 </span>            :                SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = templateInstantiationMemberFunction-&gt;get_templateDeclaration();</a>
<a name="25583"><span class="lineNum">   25583 </span>            :                if (templateMemberFunctionDeclaration != NULL)</a>
<a name="25584"><span class="lineNum">   25584 </span>            :                   {</a>
<a name="25585"><span class="lineNum">   25585 </span>            :                  // retval = operator()(templateMemberFunctionDeclaration);</a>
<a name="25586"><span class="lineNum">   25586 </span>            :                     retval = (templateMemberFunctionDeclaration-&gt;isCompilerGenerated() == false);</a>
<a name="25587"><span class="lineNum">   25587 </span>            :                   }</a>
<a name="25588"><span class="lineNum">   25588 </span>            :                  else</a>
<a name="25589"><span class="lineNum">   25589 </span>            :                   {</a>
<a name="25590"><span class="lineNum">   25590 </span>            :                  // Assume false.</a>
<a name="25591"><span class="lineNum">   25591 </span>            :                   }</a>
<a name="25592"><span class="lineNum">   25592 </span>            : </a>
<a name="25593"><span class="lineNum">   25593 </span>            : #if DEBUG_SELECTOR</a>
<a name="25594"><span class="lineNum">   25594 </span>            :                printf (&quot;   --- case of templateInstantiationMemberFunction: retval = %s \n&quot;,retval ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25595"><span class="lineNum">   25595 </span>            : #endif</a>
<a name="25596"><span class="lineNum">   25596 </span>            :              }</a>
<a name="25597"><span class="lineNum">   25597 </span>            :         }</a>
<a name="25598"><span class="lineNum">   25598 </span>            : #endif</a>
<a name="25599"><span class="lineNum">   25599 </span>            : </a>
<a name="25600"><span class="lineNum">   25600 </span>            :      return retval;</a>
<a name="25601"><span class="lineNum">   25601 </span>            :    }</a>
<a name="25602"><span class="lineNum">   25602 </span>            : #endif</a>
<a name="25603"><span class="lineNum">   25603 </span>            : </a>
<a name="25604"><span class="lineNum">   25604 </span><span class="lineCov">   39966000 : void SageInterface::detectCycleInType(SgType * type, const std::string &amp; from) {</span></a>
<a name="25605"><span class="lineNum">   25605 </span>            : #if 0</a>
<a name="25606"><span class="lineNum">   25606 </span>            :   printf(&quot;In detectCycleInType():\n&quot;);</a>
<a name="25607"><span class="lineNum">   25607 </span>            :   printf(&quot; -- from = %s\n&quot;, from.c_str());</a>
<a name="25608"><span class="lineNum">   25608 </span>            :   printf(&quot; -- type = %p (%s)\n&quot;, type, type-&gt;class_name().c_str());</a>
<a name="25609"><span class="lineNum">   25609 </span>            : #endif</a>
<a name="25610"><span class="lineNum">   25610 </span><span class="lineCov">   39966000 :   std::vector&lt;SgType *&gt; seen_types;</span></a>
<a name="25611"><span class="lineNum">   25611 </span>            : </a>
<a name="25612"><span class="lineNum">   25612 </span><span class="lineCov">   74559000 :   while (type != NULL) {</span></a>
<a name="25613"><span class="lineNum">   25613 </span>            : </a>
<a name="25614"><span class="lineNum">   25614 </span>            :  // DQ (4/15/2019): Added assertion.</a>
<a name="25615"><span class="lineNum">   25615 </span><span class="lineCov">   74559000 :     ROSE_ASSERT(type != NULL);</span></a>
<a name="25616"><span class="lineNum">   25616 </span>            : </a>
<a name="25617"><span class="lineNum">   25617 </span><span class="lineCov">   74559000 :     std::vector&lt;SgType *&gt;::const_iterator it = std::find(seen_types.begin(), seen_types.end(), type);</span></a>
<a name="25618"><span class="lineNum">   25618 </span><span class="lineCov">   74559000 :     if (it != seen_types.end()) {</span></a>
<a name="25619"><span class="lineNum">   25619 </span><span class="lineNoCov">          0 :       printf(&quot;ERROR: Cycle found in type = %p (%s):\n&quot;, type, type-&gt;class_name().c_str());</span></a>
<a name="25620"><span class="lineNum">   25620 </span><span class="lineNoCov">          0 :       size_t i = 0;</span></a>
<a name="25621"><span class="lineNum">   25621 </span><span class="lineNoCov">          0 :       for (; it != seen_types.end(); it++) {</span></a>
<a name="25622"><span class="lineNum">   25622 </span><span class="lineNoCov">          0 :         printf(&quot;  [%zd] %p (%s)\n&quot;, i, *it, (*it)-&gt;class_name().c_str());</span></a>
<a name="25623"><span class="lineNum">   25623 </span><span class="lineNoCov">          0 :         i++;</span></a>
<a name="25624"><span class="lineNum">   25624 </span>            :       }</a>
<a name="25625"><span class="lineNum">   25625 </span><span class="lineNoCov">          0 :       printf(&quot;-&gt; detectCycleInType() was called from: %s\n&quot;, from.c_str());</span></a>
<a name="25626"><span class="lineNum">   25626 </span><span class="lineNoCov">          0 :       ROSE_ABORT();</span></a>
<a name="25627"><span class="lineNum">   25627 </span>            :     }</a>
<a name="25628"><span class="lineNum">   25628 </span><span class="lineCov">   74559000 :     seen_types.push_back(type);</span></a>
<a name="25629"><span class="lineNum">   25629 </span>            : </a>
<a name="25630"><span class="lineNum">   25630 </span><span class="lineCov">   74559000 :     SgModifierType *  modType     = isSgModifierType(type);</span></a>
<a name="25631"><span class="lineNum">   25631 </span><span class="lineCov">   74559000 :     SgPointerType *   pointType   = isSgPointerType(type);</span></a>
<a name="25632"><span class="lineNum">   25632 </span><span class="lineCov">   74559000 :     SgReferenceType * refType     = isSgReferenceType(type);</span></a>
<a name="25633"><span class="lineNum">   25633 </span><span class="lineCov">   74559000 :     SgArrayType *     arrayType   = isSgArrayType(type);</span></a>
<a name="25634"><span class="lineNum">   25634 </span><span class="lineCov">   74559000 :     SgTypedefType *   typedefType = isSgTypedefType(type);</span></a>
<a name="25635"><span class="lineNum">   25635 </span>            : </a>
<a name="25636"><span class="lineNum">   25636 </span>            : #if 0</a>
<a name="25637"><span class="lineNum">   25637 </span>            :  // DQ (4/15/2019): Don't count SgPointerMemberType (also fixed in SgType::stripType() function).</a>
<a name="25638"><span class="lineNum">   25638 </span>            :     if (isSgPointerMemberType(type) != NULL)</a>
<a name="25639"><span class="lineNum">   25639 </span>            :       {</a>
<a name="25640"><span class="lineNum">   25640 </span>            :         pointType = NULL;</a>
<a name="25641"><span class="lineNum">   25641 </span>            :       }</a>
<a name="25642"><span class="lineNum">   25642 </span>            : #endif</a>
<a name="25643"><span class="lineNum">   25643 </span>            : </a>
<a name="25644"><span class="lineNum">   25644 </span><span class="lineCov">   74559000 :     if ( modType ) {</span></a>
<a name="25645"><span class="lineNum">   25645 </span><span class="lineCov">    1187420 :       type = modType-&gt;get_base_type();</span></a>
<a name="25646"><span class="lineNum">   25646 </span><span class="lineCov">   73371600 :     } else if ( refType ) {</span></a>
<a name="25647"><span class="lineNum">   25647 </span><span class="lineCov">     408384 :       type = refType-&gt;get_base_type();</span></a>
<a name="25648"><span class="lineNum">   25648 </span><span class="lineCov">   72963200 :     } else if ( pointType ) {</span></a>
<a name="25649"><span class="lineNum">   25649 </span><span class="lineCov">    1940960 :       type = pointType-&gt;get_base_type();</span></a>
<a name="25650"><span class="lineNum">   25650 </span>            :  // } else if ( pointerMemberType ) {</a>
<a name="25651"><span class="lineNum">   25651 </span>            :  //   type = pointerMemberType-&gt;get_base_type();</a>
<a name="25652"><span class="lineNum">   25652 </span><span class="lineCov">   71022200 :     } else if ( arrayType ) {</span></a>
<a name="25653"><span class="lineNum">   25653 </span><span class="lineCov">      46535 :       type = arrayType-&gt;get_base_type();</span></a>
<a name="25654"><span class="lineNum">   25654 </span><span class="lineCov">   70975700 :     } else if ( typedefType ) {</span></a>
<a name="25655"><span class="lineNum">   25655 </span><span class="lineCov">   31009700 :       type = typedefType-&gt;get_base_type();</span></a>
<a name="25656"><span class="lineNum">   25656 </span>            :     } else {</a>
<a name="25657"><span class="lineNum">   25657 </span>            :       break;</a>
<a name="25658"><span class="lineNum">   25658 </span>            :     }</a>
<a name="25659"><span class="lineNum">   25659 </span><span class="lineCov">   34593000 :     ROSE_ASSERT(type != NULL);</span></a>
<a name="25660"><span class="lineNum">   25660 </span>            :   }</a>
<a name="25661"><span class="lineNum">   25661 </span><span class="lineCov">   39966000 : }</span></a>
<a name="25662"><span class="lineNum">   25662 </span>            : </a>
<a name="25663"><span class="lineNum">   25663 </span>            : </a>
<a name="25664"><span class="lineNum">   25664 </span>            : #if 0</a>
<a name="25665"><span class="lineNum">   25665 </span>            : // DQ (11/10/2019): Older original version of the function.</a>
<a name="25666"><span class="lineNum">   25666 </span>            : </a>
<a name="25667"><span class="lineNum">   25667 </span>            : // DQ (6/6/2019): Move this to the SageInteface namespace.</a>
<a name="25668"><span class="lineNum">   25668 </span>            : void</a>
<a name="25669"><span class="lineNum">   25669 </span>            : SageInterface::convertFunctionDefinitionsToFunctionPrototypes(SgNode* node)</a>
<a name="25670"><span class="lineNum">   25670 </span>            :    {</a>
<a name="25671"><span class="lineNum">   25671 </span>            :   // DQ (3/20/2019): This function operates on the new file used to support outlined function definitions.</a>
<a name="25672"><span class="lineNum">   25672 </span>            :   // We use a copy of the file where the code will be outlined FROM, so that if there are references to</a>
<a name="25673"><span class="lineNum">   25673 </span>            :   // declarations in the outlined code we can support the outpiled code with those references.  This</a>
<a name="25674"><span class="lineNum">   25674 </span>            :   // approach has the added advantage of also supporting the same include file tree as the original</a>
<a name="25675"><span class="lineNum">   25675 </span>            :   // file where the outlined code is being taken from.</a>
<a name="25676"><span class="lineNum">   25676 </span>            : </a>
<a name="25677"><span class="lineNum">   25677 </span>            :      class TransformFunctionDefinitionsTraversal : public AstSimpleProcessing</a>
<a name="25678"><span class="lineNum">   25678 </span>            :         {</a>
<a name="25679"><span class="lineNum">   25679 </span>            :           public:</a>
<a name="25680"><span class="lineNum">   25680 </span>            :                std::vector&lt;SgFunctionDeclaration*&gt; functionList;</a>
<a name="25681"><span class="lineNum">   25681 </span>            :                SgSourceFile* sourceFile;</a>
<a name="25682"><span class="lineNum">   25682 </span>            :                int sourceFileId;</a>
<a name="25683"><span class="lineNum">   25683 </span>            :                string filenameWithPath;</a>
<a name="25684"><span class="lineNum">   25684 </span>            : </a>
<a name="25685"><span class="lineNum">   25685 </span>            :           public:</a>
<a name="25686"><span class="lineNum">   25686 </span>            :                TransformFunctionDefinitionsTraversal(): sourceFile(NULL), sourceFileId(-99) {}</a>
<a name="25687"><span class="lineNum">   25687 </span>            : </a>
<a name="25688"><span class="lineNum">   25688 </span>            :                void visit (SgNode* node)</a>
<a name="25689"><span class="lineNum">   25689 </span>            :                   {</a>
<a name="25690"><span class="lineNum">   25690 </span>            : #if 0</a>
<a name="25691"><span class="lineNum">   25691 </span>            :                     printf (&quot;In convertFunctionDefinitionsToFunctionPrototypes visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="25692"><span class="lineNum">   25692 </span>            : #endif</a>
<a name="25693"><span class="lineNum">   25693 </span>            :                     SgSourceFile* temp_sourceFile = isSgSourceFile(node);</a>
<a name="25694"><span class="lineNum">   25694 </span>            :                     if (temp_sourceFile != NULL)</a>
<a name="25695"><span class="lineNum">   25695 </span>            :                        {</a>
<a name="25696"><span class="lineNum">   25696 </span>            :                          sourceFile       = temp_sourceFile;</a>
<a name="25697"><span class="lineNum">   25697 </span>            :                          sourceFileId     = sourceFile-&gt;get_file_info()-&gt;get_file_id();</a>
<a name="25698"><span class="lineNum">   25698 </span>            : </a>
<a name="25699"><span class="lineNum">   25699 </span>            :                       // The file_id is not sufficnet, not clear why, but the filenames match.</a>
<a name="25700"><span class="lineNum">   25700 </span>            :                          filenameWithPath = sourceFile-&gt;get_sourceFileNameWithPath();</a>
<a name="25701"><span class="lineNum">   25701 </span>            : </a>
<a name="25702"><span class="lineNum">   25702 </span>            :                          printf (&quot;Found source file: id = %d name = %s \n&quot;,sourceFileId,sourceFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="25703"><span class="lineNum">   25703 </span>            : </a>
<a name="25704"><span class="lineNum">   25704 </span>            :                        }</a>
<a name="25705"><span class="lineNum">   25705 </span>            : </a>
<a name="25706"><span class="lineNum">   25706 </span>            :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);</a>
<a name="25707"><span class="lineNum">   25707 </span>            :                     if (functionDeclaration != NULL)</a>
<a name="25708"><span class="lineNum">   25708 </span>            :                        {</a>
<a name="25709"><span class="lineNum">   25709 </span>            :                       // This should have been set already.</a>
<a name="25710"><span class="lineNum">   25710 </span>            :                          ROSE_ASSERT(sourceFile != NULL);</a>
<a name="25711"><span class="lineNum">   25711 </span>            : </a>
<a name="25712"><span class="lineNum">   25712 </span>            :                          SgFunctionDeclaration* definingFunctionDeclaration = isSgFunctionDeclaration(functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="25713"><span class="lineNum">   25713 </span>            :                          if (functionDeclaration == definingFunctionDeclaration)</a>
<a name="25714"><span class="lineNum">   25714 </span>            :                             {</a>
<a name="25715"><span class="lineNum">   25715 </span>            : #if 1</a>
<a name="25716"><span class="lineNum">   25716 </span>            :                               printf (&quot;Found a defining function declaration: functionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="25717"><span class="lineNum">   25717 </span>            :                                    functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="25718"><span class="lineNum">   25718 </span>            : </a>
<a name="25719"><span class="lineNum">   25719 </span>            :                               printf (&quot; --- recorded source file: id = %d name = %s \n&quot;,sourceFileId,sourceFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="25720"><span class="lineNum">   25720 </span>            :                               printf (&quot; --- source file: file_info: id = %d name = %s \n&quot;,</a>
<a name="25721"><span class="lineNum">   25721 </span>            :                                    functionDeclaration-&gt;get_file_info()-&gt;get_file_id(),functionDeclaration-&gt;get_file_info()-&gt;get_filenameString().c_str());</a>
<a name="25722"><span class="lineNum">   25722 </span>            : #endif</a>
<a name="25723"><span class="lineNum">   25723 </span>            :                            // DQ (3/20/2019): The file_id is not sufficent, using the filename with path to do string equality.</a>
<a name="25724"><span class="lineNum">   25724 </span>            :                            // bool isInSourceFile = (sourceFileId == functionDeclaration-&gt;get_file_info()-&gt;get_file_id());</a>
<a name="25725"><span class="lineNum">   25725 </span>            :                               bool isInSourceFile = (filenameWithPath == functionDeclaration-&gt;get_file_info()-&gt;get_filenameString());</a>
<a name="25726"><span class="lineNum">   25726 </span>            : #if 1</a>
<a name="25727"><span class="lineNum">   25727 </span>            :                               printf (&quot; --- isInSourceFile = %s \n&quot;,isInSourceFile ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25728"><span class="lineNum">   25728 </span>            : #endif</a>
<a name="25729"><span class="lineNum">   25729 </span>            :                            // Remove the defining declaration as a test.</a>
<a name="25730"><span class="lineNum">   25730 </span>            :                               SgScopeStatement* functionDeclarationScope = isSgScopeStatement(functionDeclaration-&gt;get_parent());</a>
<a name="25731"><span class="lineNum">   25731 </span>            :                               if (isInSourceFile == true &amp;&amp; functionDeclarationScope != NULL)</a>
<a name="25732"><span class="lineNum">   25732 </span>            :                                  {</a>
<a name="25733"><span class="lineNum">   25733 </span>            : #if 1</a>
<a name="25734"><span class="lineNum">   25734 </span>            :                                    printf (&quot; --- Found a defining function declaration: functionDeclarationScope = %p = %s \n&quot;,</a>
<a name="25735"><span class="lineNum">   25735 </span>            :                                         functionDeclarationScope,functionDeclarationScope-&gt;class_name().c_str());</a>
<a name="25736"><span class="lineNum">   25736 </span>            : #endif</a>
<a name="25737"><span class="lineNum">   25737 </span>            :                                 // functionDeclarationScope-&gt;removeStatement(functionDeclaration);</a>
<a name="25738"><span class="lineNum">   25738 </span>            :                                 // removeStatement(functionDeclaration);</a>
<a name="25739"><span class="lineNum">   25739 </span>            :                                    functionList.push_back(functionDeclaration);</a>
<a name="25740"><span class="lineNum">   25740 </span>            :                                  }</a>
<a name="25741"><span class="lineNum">   25741 </span>            :                             }</a>
<a name="25742"><span class="lineNum">   25742 </span>            :                        }</a>
<a name="25743"><span class="lineNum">   25743 </span>            :                   }</a>
<a name="25744"><span class="lineNum">   25744 </span>            :         };</a>
<a name="25745"><span class="lineNum">   25745 </span>            : </a>
<a name="25746"><span class="lineNum">   25746 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="25747"><span class="lineNum">   25747 </span>            :      TransformFunctionDefinitionsTraversal traversal;</a>
<a name="25748"><span class="lineNum">   25748 </span>            :      traversal.traverse(node, preorder);</a>
<a name="25749"><span class="lineNum">   25749 </span>            : </a>
<a name="25750"><span class="lineNum">   25750 </span>            :      std::vector&lt;SgFunctionDeclaration*&gt; &amp; functionList = traversal.functionList;</a>
<a name="25751"><span class="lineNum">   25751 </span>            : </a>
<a name="25752"><span class="lineNum">   25752 </span>            : #if 1</a>
<a name="25753"><span class="lineNum">   25753 </span>            :      printf (&quot;In convertFunctionDefinitionsToFunctionPrototypes(): functionList.size() = %zu \n&quot;,functionList.size());</a>
<a name="25754"><span class="lineNum">   25754 </span>            : #endif</a>
<a name="25755"><span class="lineNum">   25755 </span>            : </a>
<a name="25756"><span class="lineNum">   25756 </span>            :      std::vector&lt;SgFunctionDeclaration*&gt;::iterator i = functionList.begin();</a>
<a name="25757"><span class="lineNum">   25757 </span>            :      while (i != functionList.end())</a>
<a name="25758"><span class="lineNum">   25758 </span>            :         {</a>
<a name="25759"><span class="lineNum">   25759 </span>            :           SgFunctionDeclaration* functionDeclaration = *i;</a>
<a name="25760"><span class="lineNum">   25760 </span>            :           ROSE_ASSERT(functionDeclaration != NULL);</a>
<a name="25761"><span class="lineNum">   25761 </span>            : </a>
<a name="25762"><span class="lineNum">   25762 </span>            :           SgFunctionDeclaration* nondefiningFunctionDeclaration = isSgFunctionDeclaration(functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="25763"><span class="lineNum">   25763 </span>            :           ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="25764"><span class="lineNum">   25764 </span>            : </a>
<a name="25765"><span class="lineNum">   25765 </span>            : #if 1</a>
<a name="25766"><span class="lineNum">   25766 </span>            :           printf (&quot; --- Removing function declaration: functionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="25767"><span class="lineNum">   25767 </span>            :                functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="25768"><span class="lineNum">   25768 </span>            : #endif</a>
<a name="25769"><span class="lineNum">   25769 </span>            :        // Likely we should build a new nondefining function declaration instead of reusing the existing non-defining declaration.</a>
<a name="25770"><span class="lineNum">   25770 </span>            :        // removeStatement(functionDeclaration);</a>
<a name="25771"><span class="lineNum">   25771 </span>            :           replaceStatement(functionDeclaration,nondefiningFunctionDeclaration);</a>
<a name="25772"><span class="lineNum">   25772 </span>            : </a>
<a name="25773"><span class="lineNum">   25773 </span>            :           i++;</a>
<a name="25774"><span class="lineNum">   25774 </span>            :         }</a>
<a name="25775"><span class="lineNum">   25775 </span>            : </a>
<a name="25776"><span class="lineNum">   25776 </span>            : #if 0</a>
<a name="25777"><span class="lineNum">   25777 </span>            :      printf (&quot;In convertFunctionDefinitionsToFunctionPrototypes(): exiting as a test! \n&quot;);</a>
<a name="25778"><span class="lineNum">   25778 </span>            :      ROSE_ABORT();</a>
<a name="25779"><span class="lineNum">   25779 </span>            : #endif</a>
<a name="25780"><span class="lineNum">   25780 </span>            :    }</a>
<a name="25781"><span class="lineNum">   25781 </span>            : #endif</a>
<a name="25782"><span class="lineNum">   25782 </span>            : </a>
<a name="25783"><span class="lineNum">   25783 </span>            : </a>
<a name="25784"><span class="lineNum">   25784 </span>            : void</a>
<a name="25785"><span class="lineNum">   25785 </span><span class="lineNoCov">          0 : SageInterface::displayScope(SgScopeStatement* scope)</span></a>
<a name="25786"><span class="lineNum">   25786 </span>            :    {</a>
<a name="25787"><span class="lineNum">   25787 </span>            :   // DQ (10/31/2020): Display function for scopes (useful for debugging).</a>
<a name="25788"><span class="lineNum">   25788 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope != NULL);</span></a>
<a name="25789"><span class="lineNum">   25789 </span>            : </a>
<a name="25790"><span class="lineNum">   25790 </span><span class="lineNoCov">          0 :      printf (&quot;Output the statements in scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</span></a>
<a name="25791"><span class="lineNum">   25791 </span>            : </a>
<a name="25792"><span class="lineNum">   25792 </span>            :   // This makes a copy (on the stack) and is inefficent, but this is only for debugging.</a>
<a name="25793"><span class="lineNum">   25793 </span><span class="lineNoCov">          0 :      SgStatementPtrList statementList = scope-&gt;generateStatementList();</span></a>
<a name="25794"><span class="lineNum">   25794 </span><span class="lineNoCov">          0 :      for (size_t i = 0; i &lt; statementList.size(); i++)</span></a>
<a name="25795"><span class="lineNum">   25795 </span>            :         {</a>
<a name="25796"><span class="lineNum">   25796 </span><span class="lineNoCov">          0 :           SgStatement* statement =  statementList[i];</span></a>
<a name="25797"><span class="lineNum">   25797 </span><span class="lineNoCov">          0 :           printf (&quot; --- statement: %zu ptr: %p IR node: %s name: %s \n&quot;,i,statement,statement-&gt;class_name().c_str(),SageInterface::get_name(statement).c_str());</span></a>
<a name="25798"><span class="lineNum">   25798 </span>            :         }</a>
<a name="25799"><span class="lineNum">   25799 </span>            : </a>
<a name="25800"><span class="lineNum">   25800 </span>            : #if 0</a>
<a name="25801"><span class="lineNum">   25801 </span>            :      printf (&quot;Exiting as a test at the end of evaluation of global scope! \n&quot;);</a>
<a name="25802"><span class="lineNum">   25802 </span>            :      ROSE_ABORT();</a>
<a name="25803"><span class="lineNum">   25803 </span>            : #endif</a>
<a name="25804"><span class="lineNum">   25804 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="25805"><span class="lineNum">   25805 </span>            : </a>
<a name="25806"><span class="lineNum">   25806 </span>            : </a>
<a name="25807"><span class="lineNum">   25807 </span>            : SgFunctionDeclaration*</a>
<a name="25808"><span class="lineNum">   25808 </span><span class="lineNoCov">          0 : SageInterface::buildFunctionPrototype ( SgFunctionDeclaration* functionDeclaration )</span></a>
<a name="25809"><span class="lineNum">   25809 </span>            :    {</a>
<a name="25810"><span class="lineNum">   25810 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* nondefiningFunctionDeclaration = NULL;</span></a>
<a name="25811"><span class="lineNum">   25811 </span>            :   // SgDeclarationStatement* nondefiningFunctionDeclaration = NULL;</a>
<a name="25812"><span class="lineNum">   25812 </span>            : </a>
<a name="25813"><span class="lineNum">   25813 </span>            : #if 0</a>
<a name="25814"><span class="lineNum">   25814 </span>            :      printf (&quot;In SageInterface::buildFunctionPrototype(): functionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="25815"><span class="lineNum">   25815 </span>            :           functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="25816"><span class="lineNum">   25816 </span>            : #endif</a>
<a name="25817"><span class="lineNum">   25817 </span>            : </a>
<a name="25818"><span class="lineNum">   25818 </span>            :   // DQ (11/21/2019): Check if this is a constructor, this is a temporary fix.</a>
<a name="25819"><span class="lineNum">   25819 </span><span class="lineNoCov">          0 :      bool isConstructor = false;</span></a>
<a name="25820"><span class="lineNum">   25820 </span><span class="lineNoCov">          0 :      SgMemberFunctionDeclaration* tmp_memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="25821"><span class="lineNum">   25821 </span><span class="lineNoCov">          0 :      if (tmp_memberFunctionDeclaration != NULL)</span></a>
<a name="25822"><span class="lineNum">   25822 </span>            :         {</a>
<a name="25823"><span class="lineNum">   25823 </span><span class="lineNoCov">          0 :           isConstructor = tmp_memberFunctionDeclaration-&gt;get_specialFunctionModifier().isConstructor();</span></a>
<a name="25824"><span class="lineNum">   25824 </span>            : </a>
<a name="25825"><span class="lineNum">   25825 </span>            : #if 0</a>
<a name="25826"><span class="lineNum">   25826 </span>            :           if (isConstructor == true)</a>
<a name="25827"><span class="lineNum">   25827 </span>            :              {</a>
<a name="25828"><span class="lineNum">   25828 </span>            :                printf (&quot;Skipping case of constructors (in building prototype from defining function declaration) \n&quot;);</a>
<a name="25829"><span class="lineNum">   25829 </span>            :                return;</a>
<a name="25830"><span class="lineNum">   25830 </span>            :              }</a>
<a name="25831"><span class="lineNum">   25831 </span>            : #endif</a>
<a name="25832"><span class="lineNum">   25832 </span>            :         }</a>
<a name="25833"><span class="lineNum">   25833 </span>            : </a>
<a name="25834"><span class="lineNum">   25834 </span>            :   // DQ (12/2/2019): Need to support member functions which can't be declared when outside of their class.</a>
<a name="25835"><span class="lineNum">   25835 </span>            :   // bool replaceWithEmptyDeclaration = false;</a>
<a name="25836"><span class="lineNum">   25836 </span>            :   // SgDeclarationStatement* emptyDeclaration = NULL;</a>
<a name="25837"><span class="lineNum">   25837 </span>            : </a>
<a name="25838"><span class="lineNum">   25838 </span><span class="lineNoCov">          0 :      SgName name                         = functionDeclaration-&gt;get_name();</span></a>
<a name="25839"><span class="lineNum">   25839 </span><span class="lineNoCov">          0 :      SgType* return_type                 = functionDeclaration-&gt;get_type()-&gt;get_return_type();</span></a>
<a name="25840"><span class="lineNum">   25840 </span>            : </a>
<a name="25841"><span class="lineNum">   25841 </span>            : #if 0</a>
<a name="25842"><span class="lineNum">   25842 </span>            :   // DQ (12/10/2020): The issue is that the default arguments defined in template functions are represented in the AST.</a>
<a name="25843"><span class="lineNum">   25843 </span>            :   // Where we output the template as a string, it is included, and in the template instantiation it is represented in</a>
<a name="25844"><span class="lineNum">   25844 </span>            :   // the AST.  So where it is used, default arguments are not represented in the AST and so the are not generated in</a>
<a name="25845"><span class="lineNum">   25845 </span>            :   // this function that builds the function prototype from the defining function.</a>
<a name="25846"><span class="lineNum">   25846 </span>            : </a>
<a name="25847"><span class="lineNum">   25847 </span>            :      printf (&quot;In SageInterface::buildFunctionPrototype(): functionDeclaration = %p \n&quot;,functionDeclaration);</a>
<a name="25848"><span class="lineNum">   25848 </span>            :      printf (&quot;In SageInterface::buildFunctionPrototype(): functionDeclaration-&gt;get_firstNondefiningDeclaration() = %p \n&quot;,functionDeclaration-&gt;get_firstNondefiningDeclaration());</a>
<a name="25849"><span class="lineNum">   25849 </span>            :      printf (&quot;In SageInterface::buildFunctionPrototype(): functionDeclaration-&gt;get_definingDeclaration()         = %p \n&quot;,functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="25850"><span class="lineNum">   25850 </span>            : </a>
<a name="25851"><span class="lineNum">   25851 </span>            :   // DQ (12/9/2020): Check if there is a default argument.  Need to figure out how default arguments</a>
<a name="25852"><span class="lineNum">   25852 </span>            :   // are specified in the function declarations, and make sure the prototype reproduces them.</a>
<a name="25853"><span class="lineNum">   25853 </span>            :      for (size_t i = 0; i &lt; functionDeclaration-&gt;get_args().size(); i++)</a>
<a name="25854"><span class="lineNum">   25854 </span>            :        {</a>
<a name="25855"><span class="lineNum">   25855 </span>            :          SgInitializedName* arg = functionDeclaration-&gt;get_args()[i];</a>
<a name="25856"><span class="lineNum">   25856 </span>            : #if 1</a>
<a name="25857"><span class="lineNum">   25857 </span>            :          printf (&quot;In SageInterface::buildFunctionPrototype(): functionDeclaration-&gt;get_args(): (i = %zu) arg = %p = %s isDefaultArgument = %s \n&quot;,</a>
<a name="25858"><span class="lineNum">   25858 </span>            :               i,arg,arg-&gt;get_name().str(),arg-&gt;get_file_info()-&gt;isDefaultArgument() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="25859"><span class="lineNum">   25859 </span>            :          printf (&quot; --- arg-&gt;get_initializer() = %p \n&quot;,arg-&gt;get_initializer());</a>
<a name="25860"><span class="lineNum">   25860 </span>            : #endif</a>
<a name="25861"><span class="lineNum">   25861 </span>            :          if (arg-&gt;get_file_info()-&gt;isDefaultArgument() == true)</a>
<a name="25862"><span class="lineNum">   25862 </span>            :             {</a>
<a name="25863"><span class="lineNum">   25863 </span>            :               printf (&quot;NOTE: default argument (i = %zu) not reproduced in function prototype: arg = %p = %s \n&quot;,i,arg,arg-&gt;get_name().str());</a>
<a name="25864"><span class="lineNum">   25864 </span>            :             }</a>
<a name="25865"><span class="lineNum">   25865 </span>            :        }</a>
<a name="25866"><span class="lineNum">   25866 </span>            : #endif</a>
<a name="25867"><span class="lineNum">   25867 </span>            : </a>
<a name="25868"><span class="lineNum">   25868 </span>            : #if 1</a>
<a name="25869"><span class="lineNum">   25869 </span><span class="lineNoCov">          0 :      SgFunctionParameterList* param_list = buildFunctionParameterList( functionDeclaration-&gt;get_type()-&gt;get_argument_list());</span></a>
<a name="25870"><span class="lineNum">   25870 </span>            : #else</a>
<a name="25871"><span class="lineNum">   25871 </span>            :   // DQ (9/26/2019): We need to avoid building SgFunctionParameterList IR nodes and then not attaching them to anything (parent pointers are checked in AST consistancy testing).</a>
<a name="25872"><span class="lineNum">   25872 </span>            :   // SgFunctionParameterList *param_list = functionDeclaration-&gt;get_parlist();</a>
<a name="25873"><span class="lineNum">   25873 </span>            :      SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</a>
<a name="25874"><span class="lineNum">   25874 </span>            :      SgFunctionParameterList* param_list = NULL;</a>
<a name="25875"><span class="lineNum">   25875 </span>            : </a>
<a name="25876"><span class="lineNum">   25876 </span>            :      if (templateInstantiationFunctionDecl == NULL)</a>
<a name="25877"><span class="lineNum">   25877 </span>            :         {</a>
<a name="25878"><span class="lineNum">   25878 </span>            :           param_list = buildFunctionParameterList( functionDeclaration-&gt;get_type()-&gt;get_argument_list());</a>
<a name="25879"><span class="lineNum">   25879 </span>            :         }</a>
<a name="25880"><span class="lineNum">   25880 </span>            :        else</a>
<a name="25881"><span class="lineNum">   25881 </span>            :         {</a>
<a name="25882"><span class="lineNum">   25882 </span>            :           SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);</a>
<a name="25883"><span class="lineNum">   25883 </span>            :           if (templateInstantiationMemberFunctionDecl == NULL)</a>
<a name="25884"><span class="lineNum">   25884 </span>            :              {</a>
<a name="25885"><span class="lineNum">   25885 </span>            :                param_list = buildFunctionParameterList( functionDeclaration-&gt;get_type()-&gt;get_argument_list());</a>
<a name="25886"><span class="lineNum">   25886 </span>            :              }</a>
<a name="25887"><span class="lineNum">   25887 </span>            :         }</a>
<a name="25888"><span class="lineNum">   25888 </span>            : #endif</a>
<a name="25889"><span class="lineNum">   25889 </span>            : </a>
<a name="25890"><span class="lineNum">   25890 </span>            : </a>
<a name="25891"><span class="lineNum">   25891 </span>            :   // bool isTemplateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration) != NULL);</a>
<a name="25892"><span class="lineNum">   25892 </span><span class="lineNoCov">          0 :      bool isTemplateInstantiationMemberFunctionDecl = false;</span></a>
<a name="25893"><span class="lineNum">   25893 </span>            : </a>
<a name="25894"><span class="lineNum">   25894 </span><span class="lineNoCov">          0 :      SgScopeStatement* scope             = functionDeclaration-&gt;get_scope();</span></a>
<a name="25895"><span class="lineNum">   25895 </span>            :   // SgTemplateParameterPtrList* templateParameterList = NULL; // functionDeclaration-&gt;get_templateParameterList();</a>
<a name="25896"><span class="lineNum">   25896 </span><span class="lineNoCov">          0 :      SgExprListExp* python_decoratorList = NULL;</span></a>
<a name="25897"><span class="lineNum">   25897 </span><span class="lineNoCov">          0 :      bool buildTemplateInstantiation     = false;</span></a>
<a name="25898"><span class="lineNum">   25898 </span><span class="lineNoCov">          0 :      SgTemplateArgumentPtrList* templateArgumentsList = NULL;</span></a>
<a name="25899"><span class="lineNum">   25899 </span>            : </a>
<a name="25900"><span class="lineNum">   25900 </span>            :   // DQ (9/26/2019): Tracing down a null parent pointer.</a>
<a name="25901"><span class="lineNum">   25901 </span>            :   // ROSE_ASSERT(param_list-&gt;get_parent() != NULL);</a>
<a name="25902"><span class="lineNum">   25902 </span>            :   // ROSE_ASSERT(param_list-&gt;get_parent() == NULL);</a>
<a name="25903"><span class="lineNum">   25903 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(param_list == NULL || param_list-&gt;get_parent() == NULL);</span></a>
<a name="25904"><span class="lineNum">   25904 </span>            : </a>
<a name="25905"><span class="lineNum">   25905 </span><span class="lineNoCov">          0 :      switch (functionDeclaration-&gt;variantT())</span></a>
<a name="25906"><span class="lineNum">   25906 </span>            :         {</a>
<a name="25907"><span class="lineNum">   25907 </span><span class="lineNoCov">          0 :           case V_SgTemplateMemberFunctionDeclaration:</span></a>
<a name="25908"><span class="lineNum">   25908 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="25909"><span class="lineNum">   25909 </span>            : #if 0</a>
<a name="25910"><span class="lineNum">   25910 </span>            :                printf (&quot;This function to replace the defining declaration with a non-defining declaration does not yet support template member functions \n&quot;);</a>
<a name="25911"><span class="lineNum">   25911 </span>            : #endif</a>
<a name="25912"><span class="lineNum">   25912 </span><span class="lineNoCov">          0 :                SgTemplateMemberFunctionDeclaration* original_templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="25913"><span class="lineNum">   25913 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(original_templateMemberFunctionDeclaration != NULL);</span></a>
<a name="25914"><span class="lineNum">   25914 </span>            : </a>
<a name="25915"><span class="lineNum">   25915 </span><span class="lineNoCov">          0 :                SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = NULL;</span></a>
<a name="25916"><span class="lineNum">   25916 </span>            : </a>
<a name="25917"><span class="lineNum">   25917 </span><span class="lineNoCov">          0 :                unsigned int functionConstVolatileFlags = 0;</span></a>
<a name="25918"><span class="lineNum">   25918 </span>            : </a>
<a name="25919"><span class="lineNum">   25919 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(original_templateMemberFunctionDeclaration-&gt;get_type() != NULL);</span></a>
<a name="25920"><span class="lineNum">   25920 </span>            : </a>
<a name="25921"><span class="lineNum">   25921 </span>            :             // Need to call:</a>
<a name="25922"><span class="lineNum">   25922 </span>            :             // unsigned int get_mfunc_specifier();</a>
<a name="25923"><span class="lineNum">   25923 </span>            : </a>
<a name="25924"><span class="lineNum">   25924 </span><span class="lineNoCov">          0 :                SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(original_templateMemberFunctionDeclaration-&gt;get_type());</span></a>
<a name="25925"><span class="lineNum">   25925 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(memberFunctionType != NULL);</span></a>
<a name="25926"><span class="lineNum">   25926 </span>            : </a>
<a name="25927"><span class="lineNum">   25927 </span><span class="lineNoCov">          0 :                functionConstVolatileFlags = memberFunctionType-&gt;get_mfunc_specifier();</span></a>
<a name="25928"><span class="lineNum">   25928 </span>            : </a>
<a name="25929"><span class="lineNum">   25929 </span>            :             // SgTemplateMemberFunctionDeclaration*</a>
<a name="25930"><span class="lineNum">   25930 </span>            :             // buildNondefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist,</a>
<a name="25931"><span class="lineNum">   25931 </span>            :             //      SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateParameterPtrList* templateParameterList );</a>
<a name="25932"><span class="lineNum">   25932 </span>            : </a>
<a name="25933"><span class="lineNum">   25933 </span><span class="lineNoCov">          0 :                SgTemplateParameterPtrList templateParameterList = original_templateMemberFunctionDeclaration-&gt;get_templateParameters();</span></a>
<a name="25934"><span class="lineNum">   25934 </span>            :             // ROSE_ASSERT(templateParameterList != NULL);</a>
<a name="25935"><span class="lineNum">   25935 </span>            : </a>
<a name="25936"><span class="lineNum">   25936 </span><span class="lineNoCov">          0 :                templateMemberFunctionDeclaration =</span></a>
<a name="25937"><span class="lineNum">   25937 </span><span class="lineNoCov">          0 :                     buildNondefiningTemplateMemberFunctionDeclaration ( name, return_type, param_list, scope, python_decoratorList, functionConstVolatileFlags, &amp;templateParameterList );</span></a>
<a name="25938"><span class="lineNum">   25938 </span>            : #if 0</a>
<a name="25939"><span class="lineNum">   25939 </span>            :                printf (&quot;ERROR: Template functions are not yet supported! \n&quot;);</a>
<a name="25940"><span class="lineNum">   25940 </span>            :                ROSE_ABORT();</a>
<a name="25941"><span class="lineNum">   25941 </span>            : #endif</a>
<a name="25942"><span class="lineNum">   25942 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration = templateMemberFunctionDeclaration;</span></a>
<a name="25943"><span class="lineNum">   25943 </span>            : </a>
<a name="25944"><span class="lineNum">   25944 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</span></a>
<a name="25945"><span class="lineNum">   25945 </span>            : </a>
<a name="25946"><span class="lineNum">   25946 </span>            :             // DQ (11/21/2019): Handle constructors.</a>
<a name="25947"><span class="lineNum">   25947 </span><span class="lineNoCov">          0 :                if (isConstructor == true)</span></a>
<a name="25948"><span class="lineNum">   25948 </span>            :                   {</a>
<a name="25949"><span class="lineNum">   25949 </span><span class="lineNoCov">          0 :                     templateMemberFunctionDeclaration-&gt;get_specialFunctionModifier().setConstructor();</span></a>
<a name="25950"><span class="lineNum">   25950 </span>            :                   }</a>
<a name="25951"><span class="lineNum">   25951 </span>            : </a>
<a name="25952"><span class="lineNum">   25952 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="25953"><span class="lineNum">   25953 </span>            :              }</a>
<a name="25954"><span class="lineNum">   25954 </span>            : </a>
<a name="25955"><span class="lineNum">   25955 </span><span class="lineNoCov">          0 :           case V_SgTemplateFunctionDeclaration:</span></a>
<a name="25956"><span class="lineNum">   25956 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="25957"><span class="lineNum">   25957 </span>            : #if 0</a>
<a name="25958"><span class="lineNum">   25958 </span>            :                printf (&quot;This function to replace the defining declaration with a non-defining declaration does not yet support template functions \n&quot;);</a>
<a name="25959"><span class="lineNum">   25959 </span>            : #endif</a>
<a name="25960"><span class="lineNum">   25960 </span><span class="lineNoCov">          0 :                SgTemplateFunctionDeclaration* original_templateFunctionDeclaration = isSgTemplateFunctionDeclaration(functionDeclaration);</span></a>
<a name="25961"><span class="lineNum">   25961 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(original_templateFunctionDeclaration != NULL);</span></a>
<a name="25962"><span class="lineNum">   25962 </span>            : </a>
<a name="25963"><span class="lineNum">   25963 </span><span class="lineNoCov">          0 :                SgTemplateFunctionDeclaration* templateFunctionDeclaration = NULL; // isSgTemplateFunctionDeclaration(functionDeclaration);</span></a>
<a name="25964"><span class="lineNum">   25964 </span>            : </a>
<a name="25965"><span class="lineNum">   25965 </span>            :             // SgTemplateFunctionDeclaration*</a>
<a name="25966"><span class="lineNum">   25966 </span>            :             // buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist,</a>
<a name="25967"><span class="lineNum">   25967 </span>            :             //      SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, SgTemplateParameterPtrList* templateParameterList = NULL);</a>
<a name="25968"><span class="lineNum">   25968 </span>            : </a>
<a name="25969"><span class="lineNum">   25969 </span><span class="lineNoCov">          0 :                SgTemplateParameterPtrList templateParameterList = original_templateFunctionDeclaration-&gt;get_templateParameters();</span></a>
<a name="25970"><span class="lineNum">   25970 </span>            : </a>
<a name="25971"><span class="lineNum">   25971 </span><span class="lineNoCov">          0 :                templateFunctionDeclaration = buildNondefiningTemplateFunctionDeclaration ( name, return_type, param_list, scope, python_decoratorList, &amp;templateParameterList );</span></a>
<a name="25972"><span class="lineNum">   25972 </span>            : #if 0</a>
<a name="25973"><span class="lineNum">   25973 </span>            :                printf (&quot;ERROR: Template functions are not yet supported! \n&quot;);</a>
<a name="25974"><span class="lineNum">   25974 </span>            :                ROSE_ABORT();</a>
<a name="25975"><span class="lineNum">   25975 </span>            : #endif</a>
<a name="25976"><span class="lineNum">   25976 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration = templateFunctionDeclaration;</span></a>
<a name="25977"><span class="lineNum">   25977 </span>            : </a>
<a name="25978"><span class="lineNum">   25978 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</span></a>
<a name="25979"><span class="lineNum">   25979 </span>            : </a>
<a name="25980"><span class="lineNum">   25980 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="25981"><span class="lineNum">   25981 </span>            :              }</a>
<a name="25982"><span class="lineNum">   25982 </span>            : </a>
<a name="25983"><span class="lineNum">   25983 </span>            :        // DQ (10/29/2020): Added new case.</a>
<a name="25984"><span class="lineNum">   25984 </span><span class="lineNoCov">          0 :           case V_SgTemplateInstantiationMemberFunctionDecl:</span></a>
<a name="25985"><span class="lineNum">   25985 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="25986"><span class="lineNum">   25986 </span><span class="lineNoCov">          0 :                buildTemplateInstantiation = true;</span></a>
<a name="25987"><span class="lineNum">   25987 </span>            : </a>
<a name="25988"><span class="lineNum">   25988 </span><span class="lineNoCov">          0 :                isTemplateInstantiationMemberFunctionDecl = true;</span></a>
<a name="25989"><span class="lineNum">   25989 </span>            : </a>
<a name="25990"><span class="lineNum">   25990 </span><span class="lineNoCov">          0 :                SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);</span></a>
<a name="25991"><span class="lineNum">   25991 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateInstantiationMemberFunctionDecl != NULL);</span></a>
<a name="25992"><span class="lineNum">   25992 </span><span class="lineNoCov">          0 :                templateArgumentsList = &amp;(templateInstantiationMemberFunctionDecl-&gt;get_templateArguments());</span></a>
<a name="25993"><span class="lineNum">   25993 </span>            : #if 0</a>
<a name="25994"><span class="lineNum">   25994 </span>            :                printf (&quot;name from functionDeclaration-&gt;get_name(): name                                       = %s \n&quot;,name.str());</a>
<a name="25995"><span class="lineNum">   25995 </span>            :             // printf (&quot;name from templateInstantiationMemberFunctionDecl-&gt;get_template_name(): template_name = %s \n&quot;,templateInstantiationMemberFunctionDecl-&gt;get_template_name().str());</a>
<a name="25996"><span class="lineNum">   25996 </span>            :                printf (&quot;name from templateInstantiationMemberFunctionDecl-&gt;get_templateName(): template_name  = %s \n&quot;,templateInstantiationMemberFunctionDecl-&gt;get_templateName().str());</a>
<a name="25997"><span class="lineNum">   25997 </span>            :                SgTemplateMemberFunctionDeclaration* templateDeclaration = templateInstantiationMemberFunctionDecl-&gt;get_templateDeclaration();</a>
<a name="25998"><span class="lineNum">   25998 </span>            :                if (templateDeclaration != NULL)</a>
<a name="25999"><span class="lineNum">   25999 </span>            :                   {</a>
<a name="26000"><span class="lineNum">   26000 </span>            :                     printf (&quot;name from templateInstantiationMemberFunctionDecl-&gt;get_template_declaration()-&gt;get_name(): template_name  = %s \n&quot;,templateDeclaration-&gt;get_name().str());</a>
<a name="26001"><span class="lineNum">   26001 </span>            :                     printf (&quot;name from templateInstantiationMemberFunctionDecl-&gt;get_template_declaration()-&gt;get_template_name(): template_name  = %s \n&quot;,templateDeclaration-&gt;get_template_name().str());</a>
<a name="26002"><span class="lineNum">   26002 </span>            :                   }</a>
<a name="26003"><span class="lineNum">   26003 </span>            : #endif</a>
<a name="26004"><span class="lineNum">   26004 </span>            :             // name = functionDeclaration-&gt;get_name();</a>
<a name="26005"><span class="lineNum">   26005 </span>            :             // name = templateInstantiationMemberFunctionDecl-&gt;get_template_name();</a>
<a name="26006"><span class="lineNum">   26006 </span><span class="lineNoCov">          0 :                name = templateInstantiationMemberFunctionDecl-&gt;get_templateName();</span></a>
<a name="26007"><span class="lineNum">   26007 </span>            : #if 0</a>
<a name="26008"><span class="lineNum">   26008 </span>            :                printf (&quot;In case V_SgTemplateInstantiationMemberFunctionDecl: using name = %s \n&quot;,name.str());</a>
<a name="26009"><span class="lineNum">   26009 </span>            : #endif</a>
<a name="26010"><span class="lineNum">   26010 </span>            :             // DQ (10/29/2020): Change this to include the functionality to build the member function support without fall-through.</a>
<a name="26011"><span class="lineNum">   26011 </span>            :              }</a>
<a name="26012"><span class="lineNum">   26012 </span>            :              // fall through</a>
<a name="26013"><span class="lineNum">   26013 </span><span class="lineNoCov">          0 :           case V_SgMemberFunctionDeclaration:</span></a>
<a name="26014"><span class="lineNum">   26014 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="26015"><span class="lineNum">   26015 </span>            : #if 0</a>
<a name="26016"><span class="lineNum">   26016 </span>            :                printf (&quot;This function to replace the defining declaration with a non-defining declaration does not yet support member functions \n&quot;);</a>
<a name="26017"><span class="lineNum">   26017 </span>            : #endif</a>
<a name="26018"><span class="lineNum">   26018 </span><span class="lineNoCov">          0 :                SgMemberFunctionDeclaration* original_memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="26019"><span class="lineNum">   26019 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(original_memberFunctionDeclaration != NULL);</span></a>
<a name="26020"><span class="lineNum">   26020 </span>            : </a>
<a name="26021"><span class="lineNum">   26021 </span><span class="lineNoCov">          0 :                SgMemberFunctionDeclaration* memberFunctionDeclaration = NULL; // isSgMemberFunctionDeclaration(functionDeclaration);</span></a>
<a name="26022"><span class="lineNum">   26022 </span>            : </a>
<a name="26023"><span class="lineNum">   26023 </span>            :             // SgMemberFunctionDeclaration*</a>
<a name="26024"><span class="lineNum">   26024 </span>            :             // buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist,</a>
<a name="26025"><span class="lineNum">   26025 </span>            :             //      SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="26026"><span class="lineNum">   26026 </span>            : </a>
<a name="26027"><span class="lineNum">   26027 </span><span class="lineNoCov">          0 :                unsigned int functionConstVolatileFlags = 0;</span></a>
<a name="26028"><span class="lineNum">   26028 </span>            : </a>
<a name="26029"><span class="lineNum">   26029 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(original_memberFunctionDeclaration-&gt;get_type() != NULL);</span></a>
<a name="26030"><span class="lineNum">   26030 </span>            : </a>
<a name="26031"><span class="lineNum">   26031 </span>            :             // Need to call:</a>
<a name="26032"><span class="lineNum">   26032 </span>            :             // unsigned int get_mfunc_specifier();</a>
<a name="26033"><span class="lineNum">   26033 </span>            : </a>
<a name="26034"><span class="lineNum">   26034 </span>            :             // DQ (12/2/2019): If it is defined outside of the class, then don't replace with member function prototype,</a>
<a name="26035"><span class="lineNum">   26035 </span>            :             // since they is not allowed to be declared outside of the class they are a member of.</a>
<a name="26036"><span class="lineNum">   26036 </span>            : </a>
<a name="26037"><span class="lineNum">   26037 </span>            :             // We do want to build prototypes for template instantiation member functions, and template instantiation non-member functions (see below).</a>
<a name="26038"><span class="lineNum">   26038 </span><span class="lineNoCov">          0 :                bool buildPrototype = isTemplateInstantiationMemberFunctionDecl || original_memberFunctionDeclaration-&gt;get_parent() == original_memberFunctionDeclaration-&gt;get_scope();</span></a>
<a name="26039"><span class="lineNum">   26039 </span>            : #if 0</a>
<a name="26040"><span class="lineNum">   26040 </span>            :                printf (&quot;In SageInterface::buildFunctionPrototype(): buildPrototype = %s \n&quot;,buildPrototype ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="26041"><span class="lineNum">   26041 </span>            : #endif</a>
<a name="26042"><span class="lineNum">   26042 </span>            :             // if (original_memberFunctionDeclaration-&gt;get_parent() == original_memberFunctionDeclaration-&gt;get_scope())</a>
<a name="26043"><span class="lineNum">   26043 </span><span class="lineNoCov">          0 :                if (buildPrototype == true)</span></a>
<a name="26044"><span class="lineNum">   26044 </span>            :                   {</a>
<a name="26045"><span class="lineNum">   26045 </span><span class="lineNoCov">          0 :                     SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(original_memberFunctionDeclaration-&gt;get_type());</span></a>
<a name="26046"><span class="lineNum">   26046 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(memberFunctionType != NULL);</span></a>
<a name="26047"><span class="lineNum">   26047 </span>            : #if 0</a>
<a name="26048"><span class="lineNum">   26048 </span>            :                     printf (&quot;original_memberFunctionDeclaration-&gt;get_parent() == original_memberFunctionDeclaration-&gt;get_scope() \n&quot;);</a>
<a name="26049"><span class="lineNum">   26049 </span>            : #endif</a>
<a name="26050"><span class="lineNum">   26050 </span><span class="lineNoCov">          0 :                     functionConstVolatileFlags = memberFunctionType-&gt;get_mfunc_specifier();</span></a>
<a name="26051"><span class="lineNum">   26051 </span>            : </a>
<a name="26052"><span class="lineNum">   26052 </span><span class="lineNoCov">          0 :                     memberFunctionDeclaration =</span></a>
<a name="26053"><span class="lineNum">   26053 </span>            :                          buildNondefiningMemberFunctionDeclaration</a>
<a name="26054"><span class="lineNum">   26054 </span><span class="lineNoCov">          0 :                               ( name, return_type, param_list, scope, python_decoratorList, functionConstVolatileFlags,</span></a>
<a name="26055"><span class="lineNum">   26055 </span>            :                                 buildTemplateInstantiation,templateArgumentsList );</a>
<a name="26056"><span class="lineNum">   26056 </span>            : #if 0</a>
<a name="26057"><span class="lineNum">   26057 </span>            :                     printf (&quot;ERROR: Member functions are not yet supported! \n&quot;);</a>
<a name="26058"><span class="lineNum">   26058 </span>            :                     ROSE_ABORT();</a>
<a name="26059"><span class="lineNum">   26059 </span>            : #endif</a>
<a name="26060"><span class="lineNum">   26060 </span>            :                  // DQ (11/21/2019): Handle constructors.</a>
<a name="26061"><span class="lineNum">   26061 </span><span class="lineNoCov">          0 :                     if (isConstructor == true)</span></a>
<a name="26062"><span class="lineNum">   26062 </span>            :                        {</a>
<a name="26063"><span class="lineNum">   26063 </span><span class="lineNoCov">          0 :                          memberFunctionDeclaration-&gt;get_specialFunctionModifier().setConstructor();</span></a>
<a name="26064"><span class="lineNum">   26064 </span>            :                        }</a>
<a name="26065"><span class="lineNum">   26065 </span>            : </a>
<a name="26066"><span class="lineNum">   26066 </span><span class="lineNoCov">          0 :                     nondefiningFunctionDeclaration = memberFunctionDeclaration;</span></a>
<a name="26067"><span class="lineNum">   26067 </span>            : </a>
<a name="26068"><span class="lineNum">   26068 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</span></a>
<a name="26069"><span class="lineNum">   26069 </span>            :                   }</a>
<a name="26070"><span class="lineNum">   26070 </span>            :                  else</a>
<a name="26071"><span class="lineNum">   26071 </span>            :                   {</a>
<a name="26072"><span class="lineNum">   26072 </span>            :                  // Case of member function defined outside of it's class.</a>
<a name="26073"><span class="lineNum">   26073 </span>            : #if 0</a>
<a name="26074"><span class="lineNum">   26074 </span>            :                     printf (&quot;NOTE: Member functions defined outside of their class can not be output as member function prototypes (not allowed in C++) \n&quot;);</a>
<a name="26075"><span class="lineNum">   26075 </span>            : #endif</a>
<a name="26076"><span class="lineNum">   26076 </span>            :                  // We want to build a SgEmptyDeclaration using buildEmptyDeclaration() but this is not a function.</a>
<a name="26077"><span class="lineNum">   26077 </span>            :                  // nondefiningFunctionDeclaration = buildEmptyDeclaration();</a>
<a name="26078"><span class="lineNum">   26078 </span><span class="lineNoCov">          0 :                     nondefiningFunctionDeclaration = NULL;</span></a>
<a name="26079"><span class="lineNum">   26079 </span>            : #if 0</a>
<a name="26080"><span class="lineNum">   26080 </span>            :                     nondefiningFunctionDeclaration = NULL;</a>
<a name="26081"><span class="lineNum">   26081 </span>            : </a>
<a name="26082"><span class="lineNum">   26082 </span>            :                     replaceWithEmptyDeclaration = true;</a>
<a name="26083"><span class="lineNum">   26083 </span>            :                     emptyDeclaration = buildEmptyDeclaration();</a>
<a name="26084"><span class="lineNum">   26084 </span>            :                     ROSE_ASSERT(emptyDeclaration != NULL);</a>
<a name="26085"><span class="lineNum">   26085 </span>            : #endif</a>
<a name="26086"><span class="lineNum">   26086 </span>            :                  // DQ (10/29/2020): Commented out as part of move to used SgFunctionDeclaration return type.</a>
<a name="26087"><span class="lineNum">   26087 </span>            :                  // ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="26088"><span class="lineNum">   26088 </span>            : </a>
<a name="26089"><span class="lineNum">   26089 </span>            :                  // Since we din't build a member function we don't need the parameter list.</a>
<a name="26090"><span class="lineNum">   26090 </span><span class="lineNoCov">          0 :                     delete param_list;</span></a>
<a name="26091"><span class="lineNum">   26091 </span>            :                     param_list = NULL;</a>
<a name="26092"><span class="lineNum">   26092 </span>            : #if 0</a>
<a name="26093"><span class="lineNum">   26093 </span>            :                     printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="26094"><span class="lineNum">   26094 </span>            :                     ROSE_ABORT();</a>
<a name="26095"><span class="lineNum">   26095 </span>            : #endif</a>
<a name="26096"><span class="lineNum">   26096 </span>            :                   }</a>
<a name="26097"><span class="lineNum">   26097 </span>            : </a>
<a name="26098"><span class="lineNum">   26098 </span>            :             // DQ (10/29/2020): Commented out as part of move to used SgFunctionDeclaration return type.</a>
<a name="26099"><span class="lineNum">   26099 </span>            :             // ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="26100"><span class="lineNum">   26100 </span>            :                break;</a>
<a name="26101"><span class="lineNum">   26101 </span>            :              }</a>
<a name="26102"><span class="lineNum">   26102 </span>            : </a>
<a name="26103"><span class="lineNum">   26103 </span><span class="lineNoCov">          0 :           case V_SgFunctionDeclaration:</span></a>
<a name="26104"><span class="lineNum">   26104 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="26105"><span class="lineNum">   26105 </span>            :             // This is for a non-member non-template function declaration.</a>
<a name="26106"><span class="lineNum">   26106 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration = buildNondefiningFunctionDeclaration (name, return_type, param_list, scope, python_decoratorList, buildTemplateInstantiation,templateArgumentsList);</span></a>
<a name="26107"><span class="lineNum">   26107 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</span></a>
<a name="26108"><span class="lineNum">   26108 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="26109"><span class="lineNum">   26109 </span>            :              }</a>
<a name="26110"><span class="lineNum">   26110 </span>            : </a>
<a name="26111"><span class="lineNum">   26111 </span>            :        // DQ (10/29/2020): Added new case.</a>
<a name="26112"><span class="lineNum">   26112 </span><span class="lineNoCov">          0 :           case V_SgTemplateInstantiationFunctionDecl:</span></a>
<a name="26113"><span class="lineNum">   26113 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="26114"><span class="lineNum">   26114 </span>            :             // This is for a non-member non-template function declaration.</a>
<a name="26115"><span class="lineNum">   26115 </span><span class="lineNoCov">          0 :                buildTemplateInstantiation = true;</span></a>
<a name="26116"><span class="lineNum">   26116 </span><span class="lineNoCov">          0 :                SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</span></a>
<a name="26117"><span class="lineNum">   26117 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(templateInstantiationFunctionDecl != NULL);</span></a>
<a name="26118"><span class="lineNum">   26118 </span><span class="lineNoCov">          0 :                templateArgumentsList = &amp;(templateInstantiationFunctionDecl-&gt;get_templateArguments());</span></a>
<a name="26119"><span class="lineNum">   26119 </span>            : #if 0</a>
<a name="26120"><span class="lineNum">   26120 </span>            :                printf (&quot;name from functionDeclaration-&gt;get_name(): name                                       = %s \n&quot;,name.str());</a>
<a name="26121"><span class="lineNum">   26121 </span>            :             // printf (&quot;name from templateInstantiationFunctionDecl-&gt;get_template_name(): template_name = %s \n&quot;,templateInstantiationFunctionDecl-&gt;get_template_name().str());</a>
<a name="26122"><span class="lineNum">   26122 </span>            :                printf (&quot;name from templateInstantiationFunctionDecl-&gt;get_templateName(): template_name  = %s \n&quot;,templateInstantiationFunctionDecl-&gt;get_templateName().str());</a>
<a name="26123"><span class="lineNum">   26123 </span>            :                SgTemplateFunctionDeclaration* templateDeclaration = templateInstantiationFunctionDecl-&gt;get_templateDeclaration();</a>
<a name="26124"><span class="lineNum">   26124 </span>            :                if (templateDeclaration != NULL)</a>
<a name="26125"><span class="lineNum">   26125 </span>            :                   {</a>
<a name="26126"><span class="lineNum">   26126 </span>            :                     printf (&quot;name from templateInstantiationFunctionDecl-&gt;get_template_declaration()-&gt;get_name(): template_name  = %s \n&quot;,templateDeclaration-&gt;get_name().str());</a>
<a name="26127"><span class="lineNum">   26127 </span>            :                     printf (&quot;name from templateInstantiationFunctionDecl-&gt;get_template_declaration()-&gt;get_template_name(): template_name  = %s \n&quot;,templateDeclaration-&gt;get_template_name().str());</a>
<a name="26128"><span class="lineNum">   26128 </span>            :                   }</a>
<a name="26129"><span class="lineNum">   26129 </span>            : #endif</a>
<a name="26130"><span class="lineNum">   26130 </span><span class="lineNoCov">          0 :                name = templateInstantiationFunctionDecl-&gt;get_templateName();</span></a>
<a name="26131"><span class="lineNum">   26131 </span>            : #if 0</a>
<a name="26132"><span class="lineNum">   26132 </span>            :                printf (&quot;In case V_SgTemplateInstantiationFunctionDecl: using name = %s \n&quot;,name.str());</a>
<a name="26133"><span class="lineNum">   26133 </span>            : #endif</a>
<a name="26134"><span class="lineNum">   26134 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration = buildNondefiningFunctionDeclaration (name, return_type, param_list, scope, python_decoratorList, buildTemplateInstantiation,templateArgumentsList);</span></a>
<a name="26135"><span class="lineNum">   26135 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</span></a>
<a name="26136"><span class="lineNum">   26136 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="26137"><span class="lineNum">   26137 </span>            :              }</a>
<a name="26138"><span class="lineNum">   26138 </span>            : </a>
<a name="26139"><span class="lineNum">   26139 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="26140"><span class="lineNum">   26140 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="26141"><span class="lineNum">   26141 </span>            :             // DQ (12/4/2019): If this is any other case than that handled above, then we just return.</a>
<a name="26142"><span class="lineNum">   26142 </span>            :             // These cases would be only template instantiations.</a>
<a name="26143"><span class="lineNum">   26143 </span>            : </a>
<a name="26144"><span class="lineNum">   26144 </span>            :             // Nothing to do, except delete the parameter list we built, and return.</a>
<a name="26145"><span class="lineNum">   26145 </span><span class="lineNoCov">          0 :                delete param_list;</span></a>
<a name="26146"><span class="lineNum">   26146 </span><span class="lineNoCov">          0 :                param_list = NULL;</span></a>
<a name="26147"><span class="lineNum">   26147 </span>            : </a>
<a name="26148"><span class="lineNum">   26148 </span>            :                return NULL;</a>
<a name="26149"><span class="lineNum">   26149 </span>            :              }</a>
<a name="26150"><span class="lineNum">   26150 </span>            :         }</a>
<a name="26151"><span class="lineNum">   26151 </span>            : </a>
<a name="26152"><span class="lineNum">   26152 </span>            :   // DQ (10/29/2020): We should be able to change this now that we support SgTemplateInstantiationFunctionDecl and SgTemplateInstantiationMemberFunctionDecl IR nodes.</a>
<a name="26153"><span class="lineNum">   26153 </span>            :   // DQ (9/26/2019): Tracing down a null parent pointer.</a>
<a name="26154"><span class="lineNum">   26154 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(param_list == NULL || param_list-&gt;get_parent() != NULL);</span></a>
<a name="26155"><span class="lineNum">   26155 </span>            :   // ROSE_ASSERT(param_list != NULL);</a>
<a name="26156"><span class="lineNum">   26156 </span>            :   // ROSE_ASSERT(param_list-&gt;get_parent() != NULL);</a>
<a name="26157"><span class="lineNum">   26157 </span>            : </a>
<a name="26158"><span class="lineNum">   26158 </span>            :   // ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="26159"><span class="lineNum">   26159 </span>            : </a>
<a name="26160"><span class="lineNum">   26160 </span><span class="lineNoCov">          0 :      if (nondefiningFunctionDeclaration != NULL)</span></a>
<a name="26161"><span class="lineNum">   26161 </span>            :         {</a>
<a name="26162"><span class="lineNum">   26162 </span><span class="lineNoCov">          0 :           if (nondefiningFunctionDeclaration-&gt;get_firstNondefiningDeclaration() == NULL)</span></a>
<a name="26163"><span class="lineNum">   26163 </span>            :              {</a>
<a name="26164"><span class="lineNum">   26164 </span>            : #if 0</a>
<a name="26165"><span class="lineNum">   26165 </span>            :                printf (&quot;Setting the firstNondefiningDeclaration \n&quot;);</a>
<a name="26166"><span class="lineNum">   26166 </span>            : #endif</a>
<a name="26167"><span class="lineNum">   26167 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;set_firstNondefiningDeclaration(functionDeclaration-&gt;get_firstNondefiningDeclaration());</span></a>
<a name="26168"><span class="lineNum">   26168 </span>            :              }</a>
<a name="26169"><span class="lineNum">   26169 </span>            : </a>
<a name="26170"><span class="lineNum">   26170 </span><span class="lineNoCov">          0 :           if (nondefiningFunctionDeclaration-&gt;get_definingDeclaration() == NULL)</span></a>
<a name="26171"><span class="lineNum">   26171 </span>            :              {</a>
<a name="26172"><span class="lineNum">   26172 </span>            : #if 0</a>
<a name="26173"><span class="lineNum">   26173 </span>            :                printf (&quot;Setting the definingDeclaration \n&quot;);</a>
<a name="26174"><span class="lineNum">   26174 </span>            : #endif</a>
<a name="26175"><span class="lineNum">   26175 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;set_definingDeclaration(functionDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="26176"><span class="lineNum">   26176 </span>            :              }</a>
<a name="26177"><span class="lineNum">   26177 </span>            : </a>
<a name="26178"><span class="lineNum">   26178 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefiningFunctionDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="26179"><span class="lineNum">   26179 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefiningFunctionDeclaration-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="26180"><span class="lineNum">   26180 </span>            : </a>
<a name="26181"><span class="lineNum">   26181 </span>            :        // DQ (12/17/2020): This is a required fix that was only caught as an issue by some customer code.</a>
<a name="26182"><span class="lineNum">   26182 </span><span class="lineNoCov">          0 :           if (nondefiningFunctionDeclaration != NULL)</span></a>
<a name="26183"><span class="lineNum">   26183 </span>            :              {</a>
<a name="26184"><span class="lineNum">   26184 </span>            :             // DQ (11/22/2020): These can't be the same list else we will have a case of iterator invalidation.</a>
<a name="26185"><span class="lineNum">   26185 </span>            :             // This is a bug in the support for building a new prototype from a defining function declaration</a>
<a name="26186"><span class="lineNum">   26186 </span>            :             // and caused this problem. This assertion will prevent this sort of error from happening again.</a>
<a name="26187"><span class="lineNum">   26187 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;getAttachedPreprocessingInfo() == NULL ||</span></a>
<a name="26188"><span class="lineNum">   26188 </span>            :                            functionDeclaration-&gt;getAttachedPreprocessingInfo() != nondefiningFunctionDeclaration-&gt;getAttachedPreprocessingInfo());</a>
<a name="26189"><span class="lineNum">   26189 </span>            :              }</a>
<a name="26190"><span class="lineNum">   26190 </span>            :         }</a>
<a name="26191"><span class="lineNum">   26191 </span>            : </a>
<a name="26192"><span class="lineNum">   26192 </span>            :      return nondefiningFunctionDeclaration;</a>
<a name="26193"><span class="lineNum">   26193 </span>            :    }</a>
<a name="26194"><span class="lineNum">   26194 </span>            : </a>
<a name="26195"><span class="lineNum">   26195 </span>            : </a>
<a name="26196"><span class="lineNum">   26196 </span>            : // DQ (10/27/2020): Need to return the generated function prototype (incase we want to mark it for output or template unparsing from the AST).</a>
<a name="26197"><span class="lineNum">   26197 </span>            : // void SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration )</a>
<a name="26198"><span class="lineNum">   26198 </span>            : // SgDeclarationStatement* SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration )</a>
<a name="26199"><span class="lineNum">   26199 </span>            : SgFunctionDeclaration*</a>
<a name="26200"><span class="lineNum">   26200 </span><span class="lineNoCov">          0 : SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype ( SgFunctionDeclaration* functionDeclaration )</span></a>
<a name="26201"><span class="lineNum">   26201 </span>            :    {</a>
<a name="26202"><span class="lineNum">   26202 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* nondefiningFunctionDeclaration = NULL;</span></a>
<a name="26203"><span class="lineNum">   26203 </span>            :   // SgDeclarationStatement* nondefiningFunctionDeclaration = NULL;</a>
<a name="26204"><span class="lineNum">   26204 </span>            : </a>
<a name="26205"><span class="lineNum">   26205 </span>            :   // DQ (11/12/2020): Added assertion.</a>
<a name="26206"><span class="lineNum">   26206 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="26207"><span class="lineNum">   26207 </span>            : </a>
<a name="26208"><span class="lineNum">   26208 </span>            : #if 0</a>
<a name="26209"><span class="lineNum">   26209 </span>            :      printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="26210"><span class="lineNum">   26210 </span>            :      printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): functionDeclaration = %s \n&quot;,functionDeclaration-&gt;unparseToString().c_str());</a>
<a name="26211"><span class="lineNum">   26211 </span>            : </a>
<a name="26212"><span class="lineNum">   26212 </span>            :      printf (&quot;   --- functionDeclaration-&gt;isExternBrace()                                            = %s \n&quot;,functionDeclaration-&gt;isExternBrace() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="26213"><span class="lineNum">   26213 </span>            :      printf (&quot;   --- functionDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() = %s \n&quot;,functionDeclaration-&gt;get_declarationModifier().get_storageModifier().isExtern() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="26214"><span class="lineNum">   26214 </span>            :      printf (&quot;   --- functionDeclaration-&gt;get_linkage().empty()                                      = %s \n&quot;,functionDeclaration-&gt;get_linkage().empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="26215"><span class="lineNum">   26215 </span>            :      printf (&quot;   --- functionDeclaration-&gt;get_linkage()                                              = %s \n&quot;,functionDeclaration-&gt;get_linkage().c_str());</a>
<a name="26216"><span class="lineNum">   26216 </span>            :      SgScopeStatement* scopeOfFunctionDeclaration = functionDeclaration-&gt;get_scope();</a>
<a name="26217"><span class="lineNum">   26217 </span>            :      printf (&quot; --- functionDeclaration-&gt;get_scope() = %p = %s name = %s \n&quot;,scopeOfFunctionDeclaration,scopeOfFunctionDeclaration-&gt;class_name().c_str(),get_name(scopeOfFunctionDeclaration).c_str());</a>
<a name="26218"><span class="lineNum">   26218 </span>            : </a>
<a name="26219"><span class="lineNum">   26219 </span>            :      SgMemberFunctionDeclaration* tmp_memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);</a>
<a name="26220"><span class="lineNum">   26220 </span>            :      if (tmp_memberFunctionDeclaration != NULL &amp;&amp; tmp_memberFunctionDeclaration-&gt;get_parent() != tmp_memberFunctionDeclaration-&gt;get_scope())</a>
<a name="26221"><span class="lineNum">   26221 </span>            :         {</a>
<a name="26222"><span class="lineNum">   26222 </span>            :           printf (&quot; --- this is a member function defined outside of its class, so no replacement with a fucntion prototype is possible (not legal C++): name = %s \n&quot;,</a>
<a name="26223"><span class="lineNum">   26223 </span>            :                functionDeclaration-&gt;get_name().str());</a>
<a name="26224"><span class="lineNum">   26224 </span>            :        // return NULL;</a>
<a name="26225"><span class="lineNum">   26225 </span>            :         }</a>
<a name="26226"><span class="lineNum">   26226 </span>            : #endif</a>
<a name="26227"><span class="lineNum">   26227 </span>            : </a>
<a name="26228"><span class="lineNum">   26228 </span>            : #if 0</a>
<a name="26229"><span class="lineNum">   26229 </span>            :      printf (&quot;****************************************************************** \n&quot;);</a>
<a name="26230"><span class="lineNum">   26230 </span>            :      printf (&quot;Attached comments and CPP directives: defining functionDeclaration \n&quot;);</a>
<a name="26231"><span class="lineNum">   26231 </span>            :      SageInterface::printOutComments (functionDeclaration);</a>
<a name="26232"><span class="lineNum">   26232 </span>            :      printf (&quot;****************************************************************** \n&quot;);</a>
<a name="26233"><span class="lineNum">   26233 </span>            : #endif</a>
<a name="26234"><span class="lineNum">   26234 </span>            : </a>
<a name="26235"><span class="lineNum">   26235 </span>            :   // DQ (10/15/2019): Find the file_id associated with the current file, and make the transformation with the same file_id value so that it will be unparsed.</a>
<a name="26236"><span class="lineNum">   26236 </span>            : </a>
<a name="26237"><span class="lineNum">   26237 </span>            :   // DQ (10/29/2020): This is the refactored code.</a>
<a name="26238"><span class="lineNum">   26238 </span><span class="lineNoCov">          0 :      nondefiningFunctionDeclaration = buildFunctionPrototype(functionDeclaration);</span></a>
<a name="26239"><span class="lineNum">   26239 </span>            : </a>
<a name="26240"><span class="lineNum">   26240 </span>            : #if 0</a>
<a name="26241"><span class="lineNum">   26241 </span>            :      printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): nondefiningFunctionDeclaration = %p \n&quot;,nondefiningFunctionDeclaration);</a>
<a name="26242"><span class="lineNum">   26242 </span>            :      if (nondefiningFunctionDeclaration != NULL)</a>
<a name="26243"><span class="lineNum">   26243 </span>            :         {</a>
<a name="26244"><span class="lineNum">   26244 </span>            :           printf (&quot; --- nondefiningFunctionDeclaration = %p = %s name = %s \n&quot;,nondefiningFunctionDeclaration,</a>
<a name="26245"><span class="lineNum">   26245 </span>            :                nondefiningFunctionDeclaration-&gt;class_name().c_str(),nondefiningFunctionDeclaration-&gt;get_name().str());</a>
<a name="26246"><span class="lineNum">   26246 </span>            :           SgScopeStatement* scopeOfPrototype = nondefiningFunctionDeclaration-&gt;get_scope();</a>
<a name="26247"><span class="lineNum">   26247 </span>            :           printf (&quot; --- nondefiningFunctionDeclaration-&gt;get_scope() = %p = %s name = %s \n&quot;,scopeOfPrototype,scopeOfPrototype-&gt;class_name().c_str(),get_name(scopeOfPrototype).c_str());</a>
<a name="26248"><span class="lineNum">   26248 </span>            :         }</a>
<a name="26249"><span class="lineNum">   26249 </span>            : #endif</a>
<a name="26250"><span class="lineNum">   26250 </span>            : </a>
<a name="26251"><span class="lineNum">   26251 </span>            :   // DQ (12/17/2020): This is a required fix that was only caught as an issue by some customer code.</a>
<a name="26252"><span class="lineNum">   26252 </span><span class="lineNoCov">          0 :      if (nondefiningFunctionDeclaration != NULL)</span></a>
<a name="26253"><span class="lineNum">   26253 </span>            :         {</a>
<a name="26254"><span class="lineNum">   26254 </span>            :        // DQ (11/22/2020): These can't be the same list else we will have a case of iterator invalidation.</a>
<a name="26255"><span class="lineNum">   26255 </span>            :        // This is a bug in the support for building a new prototype from a defining function declaration</a>
<a name="26256"><span class="lineNum">   26256 </span>            :        // and caused this problem. This assertion will prevent this sort of error from happening again.</a>
<a name="26257"><span class="lineNum">   26257 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionDeclaration-&gt;getAttachedPreprocessingInfo() == NULL ||</span></a>
<a name="26258"><span class="lineNum">   26258 </span>            :                       functionDeclaration-&gt;getAttachedPreprocessingInfo() != nondefiningFunctionDeclaration-&gt;getAttachedPreprocessingInfo());</a>
<a name="26259"><span class="lineNum">   26259 </span>            :          }</a>
<a name="26260"><span class="lineNum">   26260 </span>            : </a>
<a name="26261"><span class="lineNum">   26261 </span><span class="lineNoCov">          0 :      SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</span></a>
<a name="26262"><span class="lineNum">   26262 </span>            : </a>
<a name="26263"><span class="lineNum">   26263 </span>            : #if 0</a>
<a name="26264"><span class="lineNum">   26264 </span>            :      printf (&quot;After buildFunctionPrototype(): templateInstantiationFunctionDecl = %p \n&quot;,templateInstantiationFunctionDecl);</a>
<a name="26265"><span class="lineNum">   26265 </span>            : #endif</a>
<a name="26266"><span class="lineNum">   26266 </span>            : </a>
<a name="26267"><span class="lineNum">   26267 </span>            : </a>
<a name="26268"><span class="lineNum">   26268 </span>            :   // DQ (7/14/2019): I wonder if we want this code?</a>
<a name="26269"><span class="lineNum">   26269 </span>            :   // SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(functionDeclaration);</a>
<a name="26270"><span class="lineNum">   26270 </span>            : </a>
<a name="26271"><span class="lineNum">   26271 </span>            : #if 0</a>
<a name="26272"><span class="lineNum">   26272 </span>            :      printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): templateInstantiationFunctionDecl = %p \n&quot;,templateInstantiationFunctionDecl);</a>
<a name="26273"><span class="lineNum">   26273 </span>            : #endif</a>
<a name="26274"><span class="lineNum">   26274 </span>            : </a>
<a name="26275"><span class="lineNum">   26275 </span><span class="lineNoCov">          0 :      if (templateInstantiationFunctionDecl == NULL)</span></a>
<a name="26276"><span class="lineNum">   26276 </span>            :         {</a>
<a name="26277"><span class="lineNum">   26277 </span>            : #if 0</a>
<a name="26278"><span class="lineNum">   26278 </span>            :           if (nondefiningFunctionDeclaration == NULL)</a>
<a name="26279"><span class="lineNum">   26279 </span>            :              {</a>
<a name="26280"><span class="lineNum">   26280 </span>            :                printf (&quot;SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(); functionDeclaration = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="26281"><span class="lineNum">   26281 </span>            :                SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);</a>
<a name="26282"><span class="lineNum">   26282 </span>            :                if (templateInstantiationMemberFunction != NULL)</a>
<a name="26283"><span class="lineNum">   26283 </span>            :                   {</a>
<a name="26284"><span class="lineNum">   26284 </span>            :                     printf (&quot; --- templateInstantiationMemberFunction-&gt;get_name() = %s \n&quot;,templateInstantiationMemberFunction-&gt;get_name().str());</a>
<a name="26285"><span class="lineNum">   26285 </span>            : </a>
<a name="26286"><span class="lineNum">   26286 </span>            :                     delete param_list;</a>
<a name="26287"><span class="lineNum">   26287 </span>            :                     param_list = NULL;</a>
<a name="26288"><span class="lineNum">   26288 </span>            : </a>
<a name="26289"><span class="lineNum">   26289 </span>            :                     return NULL;</a>
<a name="26290"><span class="lineNum">   26290 </span>            :                   }</a>
<a name="26291"><span class="lineNum">   26291 </span>            :              }</a>
<a name="26292"><span class="lineNum">   26292 </span>            : #endif</a>
<a name="26293"><span class="lineNum">   26293 </span>            :        // ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);</a>
<a name="26294"><span class="lineNum">   26294 </span><span class="lineNoCov">          0 :           if (nondefiningFunctionDeclaration != NULL)</span></a>
<a name="26295"><span class="lineNum">   26295 </span>            :              {</a>
<a name="26296"><span class="lineNum">   26296 </span>            :             // DQ (10/29/2020): Match the associated declaration modifiers.</a>
<a name="26297"><span class="lineNum">   26297 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;get_declarationModifier() = functionDeclaration-&gt;get_declarationModifier();</span></a>
<a name="26298"><span class="lineNum">   26298 </span>            : </a>
<a name="26299"><span class="lineNum">   26299 </span>            :             // DQ (11/11/2020): Match the associated other kinds of modifiers.</a>
<a name="26300"><span class="lineNum">   26300 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;get_functionModifier()        = functionDeclaration-&gt;get_functionModifier();</span></a>
<a name="26301"><span class="lineNum">   26301 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;get_specialFunctionModifier() = functionDeclaration-&gt;get_specialFunctionModifier();</span></a>
<a name="26302"><span class="lineNum">   26302 </span>            : </a>
<a name="26303"><span class="lineNum">   26303 </span>            :             // std::string get_linkage() const</a>
<a name="26304"><span class="lineNum">   26304 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;set_linkage( functionDeclaration-&gt;get_linkage() );</span></a>
<a name="26305"><span class="lineNum">   26305 </span>            : </a>
<a name="26306"><span class="lineNum">   26306 </span>            :             // bool get_externBrace() const</a>
<a name="26307"><span class="lineNum">   26307 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;set_externBrace( functionDeclaration-&gt;get_externBrace() );</span></a>
<a name="26308"><span class="lineNum">   26308 </span>            : </a>
<a name="26309"><span class="lineNum">   26309 </span>            :             // bool get_forward() const</a>
<a name="26310"><span class="lineNum">   26310 </span>            :             // nondefiningFunctionDeclaration-&gt;set_forward( functionDeclaration-&gt;get_forward() );</a>
<a name="26311"><span class="lineNum">   26311 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration-&gt;get_forward() == true);</span></a>
<a name="26312"><span class="lineNum">   26312 </span>            : #if 0</a>
<a name="26313"><span class="lineNum">   26313 </span>            :             // DQ (11/11/2020): Match the associated other kinds of bool and pointers.</a>
<a name="26314"><span class="lineNum">   26314 </span>            :                nondefiningFunctionDeclaration-&gt;set_oldStyleDefinition    ( functionDeclaration-&gt;get_oldStyleDefinition() );</a>
<a name="26315"><span class="lineNum">   26315 </span>            :                nondefiningFunctionDeclaration-&gt;set_gnu_regparm_attribute ( functionDeclaration-&gt;get_gnu_regparm_attribute() );</a>
<a name="26316"><span class="lineNum">   26316 </span>            : </a>
<a name="26317"><span class="lineNum">   26317 </span>            :             // enforce these to be false or copy the associated pointer:</a>
<a name="26318"><span class="lineNum">   26318 </span>            :             // if get_type_syntax_is_available() == true then copy get_type_syntax()</a>
<a name="26319"><span class="lineNum">   26319 </span>            :             // pointer: parameterList_syntax</a>
<a name="26320"><span class="lineNum">   26320 </span>            :             // bool: using_C11_Noreturn_keyword</a>
<a name="26321"><span class="lineNum">   26321 </span>            :             // bool: is_constexpr</a>
<a name="26322"><span class="lineNum">   26322 </span>            :             // bool: using_new_function_return_type_syntax</a>
<a name="26323"><span class="lineNum">   26323 </span>            :             // bool: marked_as_edg_normalization</a>
<a name="26324"><span class="lineNum">   26324 </span>            :             // bool: is_implicit_function</a>
<a name="26325"><span class="lineNum">   26325 </span>            : </a>
<a name="26326"><span class="lineNum">   26326 </span>            :             // nondefiningFunctionDeclaration-&gt;set_parameterList_syntax                  ( functionDeclaration-&gt;get_parameterList_syntax() );</a>
<a name="26327"><span class="lineNum">   26327 </span>            :                nondefiningFunctionDeclaration-&gt;set_using_C11_Noreturn_keyword            ( functionDeclaration-&gt;get_using_C11_Noreturn_keyword() );</a>
<a name="26328"><span class="lineNum">   26328 </span>            :                nondefiningFunctionDeclaration-&gt;set_is_constexpr                          ( functionDeclaration-&gt;get_is_constexpr() );</a>
<a name="26329"><span class="lineNum">   26329 </span>            :                nondefiningFunctionDeclaration-&gt;set_using_new_function_return_type_syntax ( functionDeclaration-&gt;get_using_new_function_return_type_syntax() );</a>
<a name="26330"><span class="lineNum">   26330 </span>            :                nondefiningFunctionDeclaration-&gt;set_marked_as_edg_normalization           ( functionDeclaration-&gt;get_marked_as_edg_normalization() );</a>
<a name="26331"><span class="lineNum">   26331 </span>            :                nondefiningFunctionDeclaration-&gt;set_is_implicit_function                  ( functionDeclaration-&gt;get_is_implicit_function() );</a>
<a name="26332"><span class="lineNum">   26332 </span>            : #endif</a>
<a name="26333"><span class="lineNum">   26333 </span>            : #if 0</a>
<a name="26334"><span class="lineNum">   26334 </span>            :                SgMemberFunctionDeclaration* nondefiningMemberFunctionDeclaration = isSgMemberFunctionDeclaration(nondefiningFunctionDeclaration);</a>
<a name="26335"><span class="lineNum">   26335 </span>            :                if (nondefiningMemberFunctionDeclaration != NULL)</a>
<a name="26336"><span class="lineNum">   26336 </span>            :                   {</a>
<a name="26337"><span class="lineNum">   26337 </span>            :                     SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(nondefiningFunctionDeclaration);</a>
<a name="26338"><span class="lineNum">   26338 </span>            :                     ROSE_ASSERT(memberFunctionDeclaration != NULL);</a>
<a name="26339"><span class="lineNum">   26339 </span>            : </a>
<a name="26340"><span class="lineNum">   26340 </span>            :                  // DQ (11/11/2020): Match the associated other kinds of modifiers (for member functions).</a>
<a name="26341"><span class="lineNum">   26341 </span>            :                  // nondefiningMemberFunctionDeclaration-&gt;set_isDefinedInClass ( memberFunctionDeclaration-&gt;isDefinedInClass() );</a>
<a name="26342"><span class="lineNum">   26342 </span>            :                   }</a>
<a name="26343"><span class="lineNum">   26343 </span>            : #endif</a>
<a name="26344"><span class="lineNum">   26344 </span>            :             // DQ (10/15/2019): Set the physical_file_id of the transformation to match that of the original defining declaration.</a>
<a name="26345"><span class="lineNum">   26345 </span><span class="lineNoCov">          0 :                int file_id = functionDeclaration-&gt;get_file_info()-&gt;get_physical_file_id();</span></a>
<a name="26346"><span class="lineNum">   26346 </span><span class="lineNoCov">          0 :                nondefiningFunctionDeclaration-&gt;get_file_info()-&gt;set_physical_file_id(file_id);</span></a>
<a name="26347"><span class="lineNum">   26347 </span>            : #if 0</a>
<a name="26348"><span class="lineNum">   26348 </span>            :             // DQ (11/22/2020): This sould be done within the insertion step into the AST (e.g. SageInterface::replaceStatement() function).</a>
<a name="26349"><span class="lineNum">   26349 </span>            :             // Otherwise this code will copy the same AttachedPreprocessingInfoType to both statements and when they are moved from one</a>
<a name="26350"><span class="lineNum">   26350 </span>            :             // statement to the other it will cause an iterator invalidation error.</a>
<a name="26351"><span class="lineNum">   26351 </span>            :             // DQ (10/15/2019): Move any attached comments and CPP directives.</a>
<a name="26352"><span class="lineNum">   26352 </span>            :                AttachedPreprocessingInfoType* comments = functionDeclaration-&gt;getAttachedPreprocessingInfo();</a>
<a name="26353"><span class="lineNum">   26353 </span>            :                if (comments != NULL)</a>
<a name="26354"><span class="lineNum">   26354 </span>            :                   {</a>
<a name="26355"><span class="lineNum">   26355 </span>            :                  // attachedPreprocessingInfoPtr</a>
<a name="26356"><span class="lineNum">   26356 </span>            :                  // nondefiningFunctionDeclaration-&gt;setAttachedPreprocessingInfo(comments);</a>
<a name="26357"><span class="lineNum">   26357 </span>            :                     nondefiningFunctionDeclaration-&gt;set_attachedPreprocessingInfoPtr(comments);</a>
<a name="26358"><span class="lineNum">   26358 </span>            :                   }</a>
<a name="26359"><span class="lineNum">   26359 </span>            : #endif</a>
<a name="26360"><span class="lineNum">   26360 </span>            : #if 0</a>
<a name="26361"><span class="lineNum">   26361 </span>            :                printf (&quot; --- Removing function declaration: functionDeclaration = %p = %s name = %s file_id = %d \n&quot;,</a>
<a name="26362"><span class="lineNum">   26362 </span>            :                     functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str(),file_id);</a>
<a name="26363"><span class="lineNum">   26363 </span>            :                SgFunctionDeclaration* local_nondefiningFunctionDeclaration = isSgFunctionDeclaration(nondefiningFunctionDeclaration);</a>
<a name="26364"><span class="lineNum">   26364 </span>            :             // ROSE_ASSERT(local_nondefiningFunctionDeclaration != NULL);</a>
<a name="26365"><span class="lineNum">   26365 </span>            :                if (local_nondefiningFunctionDeclaration != NULL)</a>
<a name="26366"><span class="lineNum">   26366 </span>            :                   {</a>
<a name="26367"><span class="lineNum">   26367 </span>            :                     printf (&quot; --- Replacing with nondefining function declaration: local_nondefiningFunctionDeclaration = %p = %s name = %s file_id = %d \n&quot;,</a>
<a name="26368"><span class="lineNum">   26368 </span>            :                          local_nondefiningFunctionDeclaration,local_nondefiningFunctionDeclaration-&gt;class_name().c_str(),local_nondefiningFunctionDeclaration-&gt;get_name().str(),file_id);</a>
<a name="26369"><span class="lineNum">   26369 </span>            :                   }</a>
<a name="26370"><span class="lineNum">   26370 </span>            :                  else</a>
<a name="26371"><span class="lineNum">   26371 </span>            :                   {</a>
<a name="26372"><span class="lineNum">   26372 </span>            :                     printf (&quot; --- nondefiningFunctionDeclaration = %p \n&quot;,nondefiningFunctionDeclaration);</a>
<a name="26373"><span class="lineNum">   26373 </span>            :                     if (nondefiningFunctionDeclaration != NULL)</a>
<a name="26374"><span class="lineNum">   26374 </span>            :                        {</a>
<a name="26375"><span class="lineNum">   26375 </span>            :                          printf (&quot; --- nondefiningFunctionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="26376"><span class="lineNum">   26376 </span>            :                                  nondefiningFunctionDeclaration,nondefiningFunctionDeclaration-&gt;class_name().c_str(),SageInterface::get_name(nondefiningFunctionDeclaration).c_str());</a>
<a name="26377"><span class="lineNum">   26377 </span>            :                        }</a>
<a name="26378"><span class="lineNum">   26378 </span>            :                   }</a>
<a name="26379"><span class="lineNum">   26379 </span>            : #endif</a>
<a name="26380"><span class="lineNum">   26380 </span>            : </a>
<a name="26381"><span class="lineNum">   26381 </span>            : #if 1</a>
<a name="26382"><span class="lineNum">   26382 </span>            :             // Likely we should build a new nondefining function declaration instead of reusing the existing non-defining declaration.</a>
<a name="26383"><span class="lineNum">   26383 </span>            :             // removeStatement(functionDeclaration);</a>
<a name="26384"><span class="lineNum">   26384 </span>            : #if 0</a>
<a name="26385"><span class="lineNum">   26385 </span>            :                printf (&quot;functionDeclaration            = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="26386"><span class="lineNum">   26386 </span>            :                printf (&quot;nondefiningFunctionDeclaration = %p = %s name = %s \n&quot;,nondefiningFunctionDeclaration,nondefiningFunctionDeclaration-&gt;class_name().c_str(),nondefiningFunctionDeclaration-&gt;get_name().str());</a>
<a name="26387"><span class="lineNum">   26387 </span>            :                SgDeclarationStatement* definingDeclaration = functionDeclaration-&gt;get_definingDeclaration();</a>
<a name="26388"><span class="lineNum">   26388 </span>            :                ROSE_ASSERT(definingDeclaration != NULL);</a>
<a name="26389"><span class="lineNum">   26389 </span>            :                printf (&quot;definingDeclaration = %p = %s name = %s \n&quot;,definingDeclaration,definingDeclaration-&gt;class_name().c_str(),get_name(definingDeclaration).c_str());</a>
<a name="26390"><span class="lineNum">   26390 </span>            : #endif</a>
<a name="26391"><span class="lineNum">   26391 </span>            : #if 0</a>
<a name="26392"><span class="lineNum">   26392 </span>            :                SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</a>
<a name="26393"><span class="lineNum">   26393 </span>            :                printf (&quot;calling displayScope: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="26394"><span class="lineNum">   26394 </span>            :                displayScope(scope);</a>
<a name="26395"><span class="lineNum">   26395 </span>            : #endif</a>
<a name="26396"><span class="lineNum">   26396 </span>            : #if 0</a>
<a name="26397"><span class="lineNum">   26397 </span>            :                SgScopeStatement* parent_scope = isSgScopeStatement(functionDeclaration-&gt;get_parent());</a>
<a name="26398"><span class="lineNum">   26398 </span>            :                printf (&quot;calling displayScope: parent_scope = %p = %s \n&quot;,parent_scope,parent_scope-&gt;class_name().c_str());</a>
<a name="26399"><span class="lineNum">   26399 </span>            :                displayScope(parent_scope);</a>
<a name="26400"><span class="lineNum">   26400 </span>            : #endif</a>
<a name="26401"><span class="lineNum">   26401 </span>            : #if 0</a>
<a name="26402"><span class="lineNum">   26402 </span>            :                printf (&quot;Calling replaceStatement(): functionDeclaration            = %p = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str());</a>
<a name="26403"><span class="lineNum">   26403 </span>            :                printf (&quot;Calling replaceStatement(): nondefiningFunctionDeclaration = %p = %s \n&quot;,nondefiningFunctionDeclaration,nondefiningFunctionDeclaration-&gt;class_name().c_str());</a>
<a name="26404"><span class="lineNum">   26404 </span>            : #endif</a>
<a name="26405"><span class="lineNum">   26405 </span>            :             // DQ (11/22/2020): Note that this step will move the comments and CPP directives to the new statement</a>
<a name="26406"><span class="lineNum">   26406 </span>            :             // (better in this step than in the copy of the pointer to the list above, which cause an iterator invalidation error).</a>
<a name="26407"><span class="lineNum">   26407 </span>            :             // DQ (10/21/2020): I think we may want to return the orignal defining function declaration.</a>
<a name="26408"><span class="lineNum">   26408 </span>            :             // DQ (12/2/2019): Need to support member functions which can't be declared when outside of their class.</a>
<a name="26409"><span class="lineNum">   26409 </span>            :             // DQ (11/15/2020): Note that the default is false, and we need true.</a>
<a name="26410"><span class="lineNum">   26410 </span><span class="lineNoCov">          0 :                bool movePreprocessingInfo = true;</span></a>
<a name="26411"><span class="lineNum">   26411 </span><span class="lineNoCov">          0 :                replaceStatement(functionDeclaration,nondefiningFunctionDeclaration,movePreprocessingInfo);</span></a>
<a name="26412"><span class="lineNum">   26412 </span>            : #if 0</a>
<a name="26413"><span class="lineNum">   26413 </span>            :                printf (&quot;******************************************************************** \n&quot;);</a>
<a name="26414"><span class="lineNum">   26414 </span>            :                printf (&quot;Attached comments and CPP directives: nondefiningFunctionDeclaration \n&quot;);</a>
<a name="26415"><span class="lineNum">   26415 </span>            :                SageInterface::printOutComments (nondefiningFunctionDeclaration);</a>
<a name="26416"><span class="lineNum">   26416 </span>            :                printf (&quot;******************************************************************** \n&quot;);</a>
<a name="26417"><span class="lineNum">   26417 </span>            : #endif</a>
<a name="26418"><span class="lineNum">   26418 </span>            : </a>
<a name="26419"><span class="lineNum">   26419 </span>            :             // DQ (11/25/2020): This is the cause of a problem in the outliner caught in the resetParentPointer.C (definingDeclaration-&gt;get_parent() != __null).</a>
<a name="26420"><span class="lineNum">   26420 </span>            :             // DQ (11/24/2020): Maybe we should set the parent of the functionDeclaration to NULL, so that we will know to set it properly later.</a>
<a name="26421"><span class="lineNum">   26421 </span>            :             // This is the cause of a name qualification bug when the functionDeclaration is inserted into global scope and the name qualification</a>
<a name="26422"><span class="lineNum">   26422 </span>            :             // is not computed correctly (since the parent was still the namespace scope where it was originally.</a>
<a name="26423"><span class="lineNum">   26423 </span>            :             // functionDeclaration-&gt;set_parent(NULL);</a>
<a name="26424"><span class="lineNum">   26424 </span>            : #if 0</a>
<a name="26425"><span class="lineNum">   26425 </span>            :                printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): Skip resetting the parent pointer to NULL \n&quot;);</a>
<a name="26426"><span class="lineNum">   26426 </span>            : #endif</a>
<a name="26427"><span class="lineNum">   26427 </span>            :             // DQ (10/22/2020): Added assertion.</a>
<a name="26428"><span class="lineNum">   26428 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(nondefiningFunctionDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="26429"><span class="lineNum">   26429 </span>            : #else</a>
<a name="26430"><span class="lineNum">   26430 </span>            :             // DQ (7/12/2019): Debugging test_17.cpp.</a>
<a name="26431"><span class="lineNum">   26431 </span>            : </a>
<a name="26432"><span class="lineNum">   26432 </span>            : #error &quot;DEAD CODE!&quot;</a>
<a name="26433"><span class="lineNum">   26433 </span>            : </a>
<a name="26434"><span class="lineNum">   26434 </span>            :                printf (&quot;SKIPPING CALL TO REPLACE STATEMENT: functionDeclaration = %p nondefiningFunctionDeclaration = %p \n&quot;,functionDeclaration,nondefiningFunctionDeclaration);</a>
<a name="26435"><span class="lineNum">   26435 </span>            : #endif</a>
<a name="26436"><span class="lineNum">   26436 </span>            :              }</a>
<a name="26437"><span class="lineNum">   26437 </span>            :             else</a>
<a name="26438"><span class="lineNum">   26438 </span>            :              {</a>
<a name="26439"><span class="lineNum">   26439 </span>            : #if 0</a>
<a name="26440"><span class="lineNum">   26440 </span>            :                printf (&quot; --- If the nondefiningFunctionDeclaration is NULL, then we need to remove the functionDeclaration = %p name = %s instead of replacing it \n&quot;,</a>
<a name="26441"><span class="lineNum">   26441 </span>            :                     functionDeclaration,functionDeclaration-&gt;get_name().str());</a>
<a name="26442"><span class="lineNum">   26442 </span>            :                printf (&quot; --- However, we can't do that from this SageInterface function, since it could corrupt a traversal calling this function \n&quot;);</a>
<a name="26443"><span class="lineNum">   26443 </span>            : #endif</a>
<a name="26444"><span class="lineNum">   26444 </span>            : #if 0</a>
<a name="26445"><span class="lineNum">   26445 </span>            :                printf (&quot; --- functionDeclaration            = %p = %s name = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="26446"><span class="lineNum">   26446 </span>            :             // printf (&quot; --- nondefiningFunctionDeclaration = %p = %s name = %s \n&quot;,nondefiningFunctionDeclaration,nondefiningFunctionDeclaration-&gt;class_name().c_str(),nondefiningFunctionDeclaration-&gt;get_name().str());</a>
<a name="26447"><span class="lineNum">   26447 </span>            :                SgDeclarationStatement* definingDeclaration = functionDeclaration-&gt;get_definingDeclaration();</a>
<a name="26448"><span class="lineNum">   26448 </span>            :                ROSE_ASSERT(definingDeclaration != NULL);</a>
<a name="26449"><span class="lineNum">   26449 </span>            :                printf (&quot; --- definingDeclaration = %p = %s name = %s \n&quot;,definingDeclaration,definingDeclaration-&gt;class_name().c_str(),get_name(definingDeclaration).c_str());</a>
<a name="26450"><span class="lineNum">   26450 </span>            :                SgSourceFile* parentSourceFile = SageInterface::getEnclosingNode&lt;SgSourceFile&gt;(functionDeclaration);</a>
<a name="26451"><span class="lineNum">   26451 </span>            :                ROSE_ASSERT(parentSourceFile != NULL);</a>
<a name="26452"><span class="lineNum">   26452 </span>            :                printf (&quot; --- parentSourceFile = %p name = %s \n&quot;,parentSourceFile,parentSourceFile-&gt;getFileName().c_str());</a>
<a name="26453"><span class="lineNum">   26453 </span>            : #endif</a>
<a name="26454"><span class="lineNum">   26454 </span>            : #if 0</a>
<a name="26455"><span class="lineNum">   26455 </span>            :                SgScopeStatement* scope = functionDeclaration-&gt;get_scope();</a>
<a name="26456"><span class="lineNum">   26456 </span>            :                printf (&quot; --- calling displayScope: scope = %p = %s \n&quot;,scope,scope-&gt;class_name().c_str());</a>
<a name="26457"><span class="lineNum">   26457 </span>            :                displayScope(scope);</a>
<a name="26458"><span class="lineNum">   26458 </span>            :                SgScopeStatement* parent_scope = isSgScopeStatement(functionDeclaration-&gt;get_parent());</a>
<a name="26459"><span class="lineNum">   26459 </span>            :                printf (&quot; --- calling displayScope: parent_scope = %p = %s \n&quot;,parent_scope,parent_scope-&gt;class_name().c_str());</a>
<a name="26460"><span class="lineNum">   26460 </span>            :                displayScope(parent_scope);</a>
<a name="26461"><span class="lineNum">   26461 </span>            : #endif</a>
<a name="26462"><span class="lineNum">   26462 </span>            :             // DQ (10/31/2020): We can't remove this since this function is called within a traversal and will corrupt the traversal.</a>
<a name="26463"><span class="lineNum">   26463 </span>            :             // removeStatement(functionDeclaration);</a>
<a name="26464"><span class="lineNum">   26464 </span>            :              }</a>
<a name="26465"><span class="lineNum">   26465 </span>            :         }</a>
<a name="26466"><span class="lineNum">   26466 </span>            :        else</a>
<a name="26467"><span class="lineNum">   26467 </span>            :         {</a>
<a name="26468"><span class="lineNum">   26468 </span>            :        // DQ (7/12/2019): Template instantiations are not directly from the source code, so we don't have to move them.</a>
<a name="26469"><span class="lineNum">   26469 </span>            : #if 0</a>
<a name="26470"><span class="lineNum">   26470 </span>            :           printf (&quot;In SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): Ignore template instantiations as functions: nondefiningFunctionDeclaration = %p \n&quot;,</a>
<a name="26471"><span class="lineNum">   26471 </span>            :                nondefiningFunctionDeclaration);</a>
<a name="26472"><span class="lineNum">   26472 </span>            : #endif</a>
<a name="26473"><span class="lineNum">   26473 </span>            : </a>
<a name="26474"><span class="lineNum">   26474 </span>            :        // DQ (10/27/2020): I think in this case we want to return NULL.</a>
<a name="26475"><span class="lineNum">   26475 </span>            :           nondefiningFunctionDeclaration = NULL;</a>
<a name="26476"><span class="lineNum">   26476 </span>            :         }</a>
<a name="26477"><span class="lineNum">   26477 </span>            : </a>
<a name="26478"><span class="lineNum">   26478 </span>            :   // Check that static declaration is preserved.</a>
<a name="26479"><span class="lineNum">   26479 </span><span class="lineNoCov">          0 :      if (functionDeclaration-&gt;get_declarationModifier().get_storageModifier().isStatic() == true)</span></a>
<a name="26480"><span class="lineNum">   26480 </span>            :         {</a>
<a name="26481"><span class="lineNum">   26481 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(nondefiningFunctionDeclaration-&gt;get_declarationModifier().get_storageModifier().isStatic() == true);</span></a>
<a name="26482"><span class="lineNum">   26482 </span>            :         }</a>
<a name="26483"><span class="lineNum">   26483 </span>            : </a>
<a name="26484"><span class="lineNum">   26484 </span>            : #if 0</a>
<a name="26485"><span class="lineNum">   26485 </span>            :   // DQ (11/12/2020): Added assertion.</a>
<a name="26486"><span class="lineNum">   26486 </span>            :      if (nondefiningFunctionDeclaration != NULL)</a>
<a name="26487"><span class="lineNum">   26487 </span>            :         {</a>
<a name="26488"><span class="lineNum">   26488 </span>            :           printf (&quot;Leaving SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): nondefiningFunctionDeclaration = %s \n&quot;,nondefiningFunctionDeclaration-&gt;unparseToString().c_str());</a>
<a name="26489"><span class="lineNum">   26489 </span>            :           SgScopeStatement* scopeOfPrototype = nondefiningFunctionDeclaration-&gt;get_scope();</a>
<a name="26490"><span class="lineNum">   26490 </span>            :           printf (&quot; --- nondefiningFunctionDeclaration-&gt;get_scope() = %p = %s name = %s \n&quot;,scopeOfPrototype,scopeOfPrototype-&gt;class_name().c_str(),get_name(scopeOfPrototype).c_str());</a>
<a name="26491"><span class="lineNum">   26491 </span>            :           printf (&quot; --- nondefiningFunctionDeclaration-&gt;get_definingDeclaration() = %p \n&quot;,nondefiningFunctionDeclaration-&gt;get_definingDeclaration());</a>
<a name="26492"><span class="lineNum">   26492 </span>            :           printf (&quot; --- functionDeclaration                                       = %p \n&quot;,functionDeclaration);</a>
<a name="26493"><span class="lineNum">   26493 </span>            :           printf (&quot; --- functionDeclaration-&gt;get_definingDeclaration()            = %p \n&quot;,functionDeclaration-&gt;get_definingDeclaration());</a>
<a name="26494"><span class="lineNum">   26494 </span>            :           SgScopeStatement* scopeOfFunction = functionDeclaration-&gt;get_scope();</a>
<a name="26495"><span class="lineNum">   26495 </span>            :           printf (&quot; --- functionDeclaration-&gt;get_scope() = %p = %s name = %s \n&quot;,scopeOfFunction,scopeOfFunction-&gt;class_name().c_str(),get_name(scopeOfFunction).c_str());</a>
<a name="26496"><span class="lineNum">   26496 </span>            :         }</a>
<a name="26497"><span class="lineNum">   26497 </span>            :        else</a>
<a name="26498"><span class="lineNum">   26498 </span>            :         {</a>
<a name="26499"><span class="lineNum">   26499 </span>            :           printf (&quot;Leaving SageInterface::replaceDefiningFunctionDeclarationWithFunctionPrototype(): nondefiningFunctionDeclaration = %p \n&quot;,nondefiningFunctionDeclaration);</a>
<a name="26500"><span class="lineNum">   26500 </span>            :         }</a>
<a name="26501"><span class="lineNum">   26501 </span>            : #endif</a>
<a name="26502"><span class="lineNum">   26502 </span>            : </a>
<a name="26503"><span class="lineNum">   26503 </span>            :   // DQ (10/27/2020): Added return value so that we can access the new function prototype.</a>
<a name="26504"><span class="lineNum">   26504 </span><span class="lineNoCov">          0 :      return nondefiningFunctionDeclaration;</span></a>
<a name="26505"><span class="lineNum">   26505 </span>            :    }</a>
<a name="26506"><span class="lineNum">   26506 </span>            : </a>
<a name="26507"><span class="lineNum">   26507 </span>            : </a>
<a name="26508"><span class="lineNum">   26508 </span>            : </a>
<a name="26509"><span class="lineNum">   26509 </span>            : </a>
<a name="26510"><span class="lineNum">   26510 </span>            : std::vector&lt;SgFunctionDeclaration*&gt;</a>
<a name="26511"><span class="lineNum">   26511 </span><span class="lineNoCov">          0 : SageInterface::generateFunctionDefinitionsList(SgNode* node)</span></a>
<a name="26512"><span class="lineNum">   26512 </span>            :    {</a>
<a name="26513"><span class="lineNum">   26513 </span>            :   // DQ (3/20/2019): This function operates on the new file used to support outlined function definitions.</a>
<a name="26514"><span class="lineNum">   26514 </span>            :   // We use a copy of the file where the code will be outlined FROM, so that if there are references to</a>
<a name="26515"><span class="lineNum">   26515 </span>            :   // declarations in the outlined code we can support the outpiled code with those references.  This</a>
<a name="26516"><span class="lineNum">   26516 </span>            :   // approach has the added advantage of also supporting the same include file tree as the original</a>
<a name="26517"><span class="lineNum">   26517 </span>            :   // file where the outlined code is being taken from.</a>
<a name="26518"><span class="lineNum">   26518 </span>            : </a>
<a name="26519"><span class="lineNum">   26519 </span><span class="lineNoCov">          0 :      class FunctionDefinitionsTraversal : public AstSimpleProcessing</span></a>
<a name="26520"><span class="lineNum">   26520 </span>            :         {</a>
<a name="26521"><span class="lineNum">   26521 </span>            :           public:</a>
<a name="26522"><span class="lineNum">   26522 </span>            :                std::vector&lt;SgFunctionDeclaration*&gt; functionList;</a>
<a name="26523"><span class="lineNum">   26523 </span>            :             // SgSourceFile* sourceFile;</a>
<a name="26524"><span class="lineNum">   26524 </span>            :             // int sourceFileId;</a>
<a name="26525"><span class="lineNum">   26525 </span>            :             // string filenameWithPath;</a>
<a name="26526"><span class="lineNum">   26526 </span>            : </a>
<a name="26527"><span class="lineNum">   26527 </span>            :           public:</a>
<a name="26528"><span class="lineNum">   26528 </span>            :             // FunctionDefinitionsTraversal(): sourceFile(NULL), sourceFileId(-99) {}</a>
<a name="26529"><span class="lineNum">   26529 </span><span class="lineNoCov">          0 :                FunctionDefinitionsTraversal() {}</span></a>
<a name="26530"><span class="lineNum">   26530 </span>            : </a>
<a name="26531"><span class="lineNum">   26531 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="26532"><span class="lineNum">   26532 </span>            :                   {</a>
<a name="26533"><span class="lineNum">   26533 </span>            : #if 0</a>
<a name="26534"><span class="lineNum">   26534 </span>            :                     printf (&quot;In generateFunctionDefinitionsList visit(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="26535"><span class="lineNum">   26535 </span>            : #endif</a>
<a name="26536"><span class="lineNum">   26536 </span>            : #if 0</a>
<a name="26537"><span class="lineNum">   26537 </span>            :                     SgSourceFile* temp_sourceFile = isSgSourceFile(node);</a>
<a name="26538"><span class="lineNum">   26538 </span>            :                     if (temp_sourceFile != NULL)</a>
<a name="26539"><span class="lineNum">   26539 </span>            :                        {</a>
<a name="26540"><span class="lineNum">   26540 </span>            :                          sourceFile       = temp_sourceFile;</a>
<a name="26541"><span class="lineNum">   26541 </span>            :                          sourceFileId     = sourceFile-&gt;get_file_info()-&gt;get_file_id();</a>
<a name="26542"><span class="lineNum">   26542 </span>            : </a>
<a name="26543"><span class="lineNum">   26543 </span>            :                       // The file_id is not sufficnet, not clear why, but the filenames match.</a>
<a name="26544"><span class="lineNum">   26544 </span>            :                          filenameWithPath = sourceFile-&gt;get_sourceFileNameWithPath();</a>
<a name="26545"><span class="lineNum">   26545 </span>            : </a>
<a name="26546"><span class="lineNum">   26546 </span>            :                          printf (&quot;Found source file: id = %d name = %s \n&quot;,sourceFileId,sourceFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="26547"><span class="lineNum">   26547 </span>            : </a>
<a name="26548"><span class="lineNum">   26548 </span>            :                        }</a>
<a name="26549"><span class="lineNum">   26549 </span>            : #endif</a>
<a name="26550"><span class="lineNum">   26550 </span><span class="lineNoCov">          0 :                     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);</span></a>
<a name="26551"><span class="lineNum">   26551 </span><span class="lineNoCov">          0 :                     if (functionDeclaration != NULL)</span></a>
<a name="26552"><span class="lineNum">   26552 </span>            :                        {</a>
<a name="26553"><span class="lineNum">   26553 </span>            :                       // This should have been set already.</a>
<a name="26554"><span class="lineNum">   26554 </span>            :                       // ROSE_ASSERT(sourceFile != NULL);</a>
<a name="26555"><span class="lineNum">   26555 </span>            : </a>
<a name="26556"><span class="lineNum">   26556 </span><span class="lineNoCov">          0 :                          SgFunctionDeclaration* definingFunctionDeclaration = isSgFunctionDeclaration(functionDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="26557"><span class="lineNum">   26557 </span><span class="lineNoCov">          0 :                          if (functionDeclaration == definingFunctionDeclaration)</span></a>
<a name="26558"><span class="lineNum">   26558 </span>            :                             {</a>
<a name="26559"><span class="lineNum">   26559 </span>            : #if 0</a>
<a name="26560"><span class="lineNum">   26560 </span>            :                               printf (&quot;Found a defining function declaration: functionDeclaration = %p = %s name = %s \n&quot;,</a>
<a name="26561"><span class="lineNum">   26561 </span>            :                                    functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="26562"><span class="lineNum">   26562 </span>            : #endif</a>
<a name="26563"><span class="lineNum">   26563 </span>            : #if 0</a>
<a name="26564"><span class="lineNum">   26564 </span>            :                               printf (&quot; --- recorded source file: id = %d name = %s \n&quot;,sourceFileId,sourceFile-&gt;get_sourceFileNameWithPath().c_str());</a>
<a name="26565"><span class="lineNum">   26565 </span>            :                               printf (&quot; --- source file: file_info: id = %d name = %s \n&quot;,</a>
<a name="26566"><span class="lineNum">   26566 </span>            :                                    functionDeclaration-&gt;get_file_info()-&gt;get_file_id(),functionDeclaration-&gt;get_file_info()-&gt;get_filenameString().c_str());</a>
<a name="26567"><span class="lineNum">   26567 </span>            : #endif</a>
<a name="26568"><span class="lineNum">   26568 </span>            : #if 0</a>
<a name="26569"><span class="lineNum">   26569 </span>            :                            // DQ (3/20/2019): The file_id is not sufficent, using the filename with path to do string equality.</a>
<a name="26570"><span class="lineNum">   26570 </span>            :                            // bool isInSourceFile = (sourceFileId == functionDeclaration-&gt;get_file_info()-&gt;get_file_id());</a>
<a name="26571"><span class="lineNum">   26571 </span>            :                               bool isInSourceFile = (filenameWithPath == functionDeclaration-&gt;get_file_info()-&gt;get_filenameString());</a>
<a name="26572"><span class="lineNum">   26572 </span>            : #if 0</a>
<a name="26573"><span class="lineNum">   26573 </span>            :                               printf (&quot; --- isInSourceFile = %s \n&quot;,isInSourceFile ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="26574"><span class="lineNum">   26574 </span>            : #endif</a>
<a name="26575"><span class="lineNum">   26575 </span>            : #endif</a>
<a name="26576"><span class="lineNum">   26576 </span>            :                            // Remove the defining declaration as a test.</a>
<a name="26577"><span class="lineNum">   26577 </span><span class="lineNoCov">          0 :                               SgScopeStatement* functionDeclarationScope = isSgScopeStatement(functionDeclaration-&gt;get_parent());</span></a>
<a name="26578"><span class="lineNum">   26578 </span>            :                            // if (isInSourceFile == true &amp;&amp; functionDeclarationScope != NULL)</a>
<a name="26579"><span class="lineNum">   26579 </span><span class="lineNoCov">          0 :                               if (functionDeclarationScope != NULL)</span></a>
<a name="26580"><span class="lineNum">   26580 </span>            :                                  {</a>
<a name="26581"><span class="lineNum">   26581 </span>            : #if 0</a>
<a name="26582"><span class="lineNum">   26582 </span>            :                                    printf (&quot; --- Found a defining function declaration: functionDeclarationScope = %p = %s \n&quot;,</a>
<a name="26583"><span class="lineNum">   26583 </span>            :                                         functionDeclarationScope,functionDeclarationScope-&gt;class_name().c_str());</a>
<a name="26584"><span class="lineNum">   26584 </span>            : #endif</a>
<a name="26585"><span class="lineNum">   26585 </span>            :                                 // functionDeclarationScope-&gt;removeStatement(functionDeclaration);</a>
<a name="26586"><span class="lineNum">   26586 </span>            :                                 // removeStatement(functionDeclaration);</a>
<a name="26587"><span class="lineNum">   26587 </span><span class="lineNoCov">          0 :                                    functionList.push_back(functionDeclaration);</span></a>
<a name="26588"><span class="lineNum">   26588 </span>            :                                  }</a>
<a name="26589"><span class="lineNum">   26589 </span>            :                             }</a>
<a name="26590"><span class="lineNum">   26590 </span>            :                        }</a>
<a name="26591"><span class="lineNum">   26591 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="26592"><span class="lineNum">   26592 </span>            :         };</a>
<a name="26593"><span class="lineNum">   26593 </span>            : </a>
<a name="26594"><span class="lineNum">   26594 </span>            :   // Now buid the traveral object and call the traversal (preorder) on the AST subtree.</a>
<a name="26595"><span class="lineNum">   26595 </span><span class="lineNoCov">          0 :      FunctionDefinitionsTraversal traversal;</span></a>
<a name="26596"><span class="lineNum">   26596 </span>            : </a>
<a name="26597"><span class="lineNum">   26597 </span>            : #if 0</a>
<a name="26598"><span class="lineNum">   26598 </span>            :      printf (&quot;In (TOP) generateFunctionDefinitionsList(): node = %p = %s \n&quot;,node,node-&gt;class_name().c_str());</a>
<a name="26599"><span class="lineNum">   26599 </span>            : #endif</a>
<a name="26600"><span class="lineNum">   26600 </span>            : </a>
<a name="26601"><span class="lineNum">   26601 </span>            :   // traversal.traverse(node, preorder);</a>
<a name="26602"><span class="lineNum">   26602 </span><span class="lineNoCov">          0 :      traversal.traverseWithinFile(node, preorder);</span></a>
<a name="26603"><span class="lineNum">   26603 </span>            : </a>
<a name="26604"><span class="lineNum">   26604 </span><span class="lineNoCov">          0 :      std::vector&lt;SgFunctionDeclaration*&gt; &amp; functionList = traversal.functionList;</span></a>
<a name="26605"><span class="lineNum">   26605 </span>            : </a>
<a name="26606"><span class="lineNum">   26606 </span>            : #if 0</a>
<a name="26607"><span class="lineNum">   26607 </span>            :      printf (&quot;Leaving generateFunctionDefinitionsList(): functionList.size() = %zu \n&quot;,functionList.size());</a>
<a name="26608"><span class="lineNum">   26608 </span>            : #endif</a>
<a name="26609"><span class="lineNum">   26609 </span>            : </a>
<a name="26610"><span class="lineNum">   26610 </span><span class="lineNoCov">          0 :      return functionList;</span></a>
<a name="26611"><span class="lineNum">   26611 </span>            :    }</a>
<a name="26612"><span class="lineNum">   26612 </span>            : </a>
<a name="26613"><span class="lineNum">   26613 </span>            : </a>
<a name="26614"><span class="lineNum">   26614 </span>            : void</a>
<a name="26615"><span class="lineNum">   26615 </span><span class="lineNoCov">          0 : SageInterface::convertFunctionDefinitionsToFunctionPrototypes(SgNode* node)</span></a>
<a name="26616"><span class="lineNum">   26616 </span>            :    {</a>
<a name="26617"><span class="lineNum">   26617 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="26618"><span class="lineNum">   26618 </span>            : </a>
<a name="26619"><span class="lineNum">   26619 </span><span class="lineNoCov">          0 :      std::vector&lt;SgFunctionDeclaration*&gt; functionList = generateFunctionDefinitionsList(node);</span></a>
<a name="26620"><span class="lineNum">   26620 </span>            : </a>
<a name="26621"><span class="lineNum">   26621 </span>            : #if 0</a>
<a name="26622"><span class="lineNum">   26622 </span>            :      printf (&quot;In convertFunctionDefinitionsToFunctionPrototypes(): functionList.size() = %zu \n&quot;,functionList.size());</a>
<a name="26623"><span class="lineNum">   26623 </span>            : #endif</a>
<a name="26624"><span class="lineNum">   26624 </span>            : </a>
<a name="26625"><span class="lineNum">   26625 </span><span class="lineNoCov">          0 :      std::vector&lt;SgFunctionDeclaration*&gt;::iterator i = functionList.begin();</span></a>
<a name="26626"><span class="lineNum">   26626 </span><span class="lineNoCov">          0 :      while (i != functionList.end())</span></a>
<a name="26627"><span class="lineNum">   26627 </span>            :         {</a>
<a name="26628"><span class="lineNum">   26628 </span><span class="lineNoCov">          0 :           SgFunctionDeclaration* functionDeclaration = *i;</span></a>
<a name="26629"><span class="lineNum">   26629 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="26630"><span class="lineNum">   26630 </span>            : #if 1</a>
<a name="26631"><span class="lineNum">   26631 </span>            :        // Transform into prototype.</a>
<a name="26632"><span class="lineNum">   26632 </span><span class="lineNoCov">          0 :           replaceDefiningFunctionDeclarationWithFunctionPrototype(functionDeclaration);</span></a>
<a name="26633"><span class="lineNum">   26633 </span>            : #else</a>
<a name="26634"><span class="lineNum">   26634 </span>            :        // DQ (10/15/2019): Testing unparsing without this function call.</a>
<a name="26635"><span class="lineNum">   26635 </span>            :           printf (&quot;Skipping replaceDefiningFunctionDeclarationWithFunctionPrototype() \n&quot;);</a>
<a name="26636"><span class="lineNum">   26636 </span>            : #endif</a>
<a name="26637"><span class="lineNum">   26637 </span>            : #if 0</a>
<a name="26638"><span class="lineNum">   26638 </span>            :           printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="26639"><span class="lineNum">   26639 </span>            :           ROSE_ABORT();</a>
<a name="26640"><span class="lineNum">   26640 </span>            : #endif</a>
<a name="26641"><span class="lineNum">   26641 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="26642"><span class="lineNum">   26642 </span>            :         }</a>
<a name="26643"><span class="lineNum">   26643 </span>            : </a>
<a name="26644"><span class="lineNum">   26644 </span>            : #if 0</a>
<a name="26645"><span class="lineNum">   26645 </span>            :      printf (&quot;In convertFunctionDefinitionsToFunctionPrototypes(): exiting as a test! \n&quot;);</a>
<a name="26646"><span class="lineNum">   26646 </span>            :      ROSE_ABORT();</a>
<a name="26647"><span class="lineNum">   26647 </span>            : #endif</a>
<a name="26648"><span class="lineNum">   26648 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="26649"><span class="lineNum">   26649 </span>            : </a>
<a name="26650"><span class="lineNum">   26650 </span>            : </a>
<a name="26651"><span class="lineNum">   26651 </span>            : </a>
<a name="26652"><span class="lineNum">   26652 </span>            : // DQ (7/14/2020): Added test for initializers to support debugging of Cxx11_tests/test2020_69.C.</a>
<a name="26653"><span class="lineNum">   26653 </span>            : void</a>
<a name="26654"><span class="lineNum">   26654 </span><span class="lineNoCov">          0 : SageInterface::checkForInitializers( SgNode* node )</span></a>
<a name="26655"><span class="lineNum">   26655 </span>            :    {</a>
<a name="26656"><span class="lineNum">   26656 </span>            :   // This function checks variable declarations for initializers.  An issue (bug) in EDG 6.0</a>
<a name="26657"><span class="lineNum">   26657 </span>            :   // support for variable declarations initialized using lambda functions is that the initalizer</a>
<a name="26658"><span class="lineNum">   26658 </span>            :   // is discarded at some point in the processing of the AST.  This function reports on all</a>
<a name="26659"><span class="lineNum">   26659 </span>            :   // variable declarations and if they contain initializers and if so what kind of initializer.</a>
<a name="26660"><span class="lineNum">   26660 </span>            : </a>
<a name="26661"><span class="lineNum">   26661 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(node != NULL);</span></a>
<a name="26662"><span class="lineNum">   26662 </span>            : </a>
<a name="26663"><span class="lineNum">   26663 </span>            :   // Preorder traversal to uniquely label the scopes (SgScopeStatements)</a>
<a name="26664"><span class="lineNum">   26664 </span><span class="lineNoCov">          0 :      class CheckInitializerTraversal : public AstSimpleProcessing</span></a>
<a name="26665"><span class="lineNum">   26665 </span>            :         {</a>
<a name="26666"><span class="lineNum">   26666 </span>            :           public:</a>
<a name="26667"><span class="lineNum">   26667 </span><span class="lineNoCov">          0 :                void visit (SgNode* node)</span></a>
<a name="26668"><span class="lineNum">   26668 </span>            :                   {</a>
<a name="26669"><span class="lineNum">   26669 </span><span class="lineNoCov">          0 :                     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(node);</span></a>
<a name="26670"><span class="lineNum">   26670 </span><span class="lineNoCov">          0 :                     if (variableDeclaration != NULL)</span></a>
<a name="26671"><span class="lineNum">   26671 </span>            :                        {</a>
<a name="26672"><span class="lineNum">   26672 </span><span class="lineNoCov">          0 :                          SgInitializedName* initializedName = getFirstInitializedName(variableDeclaration);</span></a>
<a name="26673"><span class="lineNum">   26673 </span><span class="lineNoCov">          0 :                          SgExpression* initializer = initializedName-&gt;get_initializer();</span></a>
<a name="26674"><span class="lineNum">   26674 </span>            : </a>
<a name="26675"><span class="lineNum">   26675 </span><span class="lineNoCov">          0 :                          printf (&quot;variableDeclaration = %p initializedName = %p = %s initializer = %p \n&quot;,</span></a>
<a name="26676"><span class="lineNum">   26676 </span><span class="lineNoCov">          0 :                               variableDeclaration,initializedName,initializedName-&gt;get_name().str(),initializer);</span></a>
<a name="26677"><span class="lineNum">   26677 </span>            : </a>
<a name="26678"><span class="lineNum">   26678 </span><span class="lineNoCov">          0 :                          if (initializer != NULL)</span></a>
<a name="26679"><span class="lineNum">   26679 </span>            :                             {</a>
<a name="26680"><span class="lineNum">   26680 </span><span class="lineNoCov">          0 :                               printf (&quot; --- initializer = %s \n&quot;,initializer-&gt;class_name().c_str());</span></a>
<a name="26681"><span class="lineNum">   26681 </span>            :                             }</a>
<a name="26682"><span class="lineNum">   26682 </span>            :                        }</a>
<a name="26683"><span class="lineNum">   26683 </span><span class="lineNoCov">          0 :                   }</span></a>
<a name="26684"><span class="lineNum">   26684 </span>            :         };</a>
<a name="26685"><span class="lineNum">   26685 </span>            : </a>
<a name="26686"><span class="lineNum">   26686 </span>            :     // Now buid the traveral object and call the traversal (preorder) on the project.</a>
<a name="26687"><span class="lineNum">   26687 </span><span class="lineNoCov">          0 :        CheckInitializerTraversal traversal;</span></a>
<a name="26688"><span class="lineNum">   26688 </span><span class="lineNoCov">          0 :        traversal.traverse(node, preorder);</span></a>
<a name="26689"><span class="lineNum">   26689 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="26690"><span class="lineNum">   26690 </span>            : </a>
<a name="26691"><span class="lineNum">   26691 </span>            : namespace</a>
<a name="26692"><span class="lineNum">   26692 </span>            : {</a>
<a name="26693"><span class="lineNum">   26693 </span><span class="lineNoCov">          0 :   struct DeclaredType : sg::DispatchHandler&lt;SgType*&gt;</span></a>
<a name="26694"><span class="lineNum">   26694 </span>            :   {</a>
<a name="26695"><span class="lineNum">   26695 </span>            :     void handle(SgNode&amp; n, SgNode&amp;) { SG_UNEXPECTED_NODE(n); }</a>
<a name="26696"><span class="lineNum">   26696 </span>            : </a>
<a name="26697"><span class="lineNum">   26697 </span>            :     template &lt;class SageDeclarationStatement&gt;</a>
<a name="26698"><span class="lineNum">   26698 </span><span class="lineNoCov">          0 :     void handle(SageDeclarationStatement&amp; n, SgDeclarationStatement&amp;)</span></a>
<a name="26699"><span class="lineNum">   26699 </span>            :     {</a>
<a name="26700"><span class="lineNum">   26700 </span><span class="lineNoCov">          0 :       res = n.get_type();</span></a>
<a name="26701"><span class="lineNum">   26701 </span>            :     }</a>
<a name="26702"><span class="lineNum">   26702 </span>            : </a>
<a name="26703"><span class="lineNum">   26703 </span>            :     template &lt;class SageNode&gt;</a>
<a name="26704"><span class="lineNum">   26704 </span><span class="lineNoCov">          0 :     void handle(SageNode&amp; n)</span></a>
<a name="26705"><span class="lineNum">   26705 </span>            :     {</a>
<a name="26706"><span class="lineNum">   26706 </span><span class="lineNoCov">          0 :       handle(n, n);</span></a>
<a name="26707"><span class="lineNum">   26707 </span>            :     }</a>
<a name="26708"><span class="lineNum">   26708 </span>            :   };</a>
<a name="26709"><span class="lineNum">   26709 </span>            : }</a>
<a name="26710"><span class="lineNum">   26710 </span>            : </a>
<a name="26711"><span class="lineNum">   26711 </span><span class="lineNoCov">          0 : SgType* SageInterface::getDeclaredType(const SgDeclarationStatement* declaration)</span></a>
<a name="26712"><span class="lineNum">   26712 </span>            : {</a>
<a name="26713"><span class="lineNum">   26713 </span><span class="lineNoCov">          0 :   return sg::dispatch(DeclaredType{}, declaration);</span></a>
<a name="26714"><span class="lineNum">   26714 </span>            : }</a>
<a name="26715"><span class="lineNum">   26715 </span>            : </a>
<a name="26716"><span class="lineNum">   26716 </span><span class="lineNoCov">          0 : void SageInterface::clearSharedGlobalScopes(SgProject * project) {</span></a>
<a name="26717"><span class="lineNum">   26717 </span><span class="lineNoCov">          0 :   SgGlobal * gsaf = project-&gt;get_globalScopeAcrossFiles();</span></a>
<a name="26718"><span class="lineNum">   26718 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(gsaf != nullptr);</span></a>
<a name="26719"><span class="lineNum">   26719 </span><span class="lineNoCov">          0 :   SgSymbolTable * st = gsaf-&gt;get_symbol_table();</span></a>
<a name="26720"><span class="lineNum">   26720 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(st != nullptr);</span></a>
<a name="26721"><span class="lineNum">   26721 </span><span class="lineNoCov">          0 :   rose_hash_multimap * hmm = st-&gt;get_table();</span></a>
<a name="26722"><span class="lineNum">   26722 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(hmm != nullptr);</span></a>
<a name="26723"><span class="lineNum">   26723 </span><span class="lineNoCov">          0 :   hmm-&gt;clear();</span></a>
<a name="26724"><span class="lineNum">   26724 </span>            : </a>
<a name="26725"><span class="lineNum">   26725 </span><span class="lineNoCov">          0 :   st = SgNode::get_globalTypeTable()-&gt;get_type_table();</span></a>
<a name="26726"><span class="lineNum">   26726 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(st != nullptr);</span></a>
<a name="26727"><span class="lineNum">   26727 </span><span class="lineNoCov">          0 :   hmm = st-&gt;get_table();</span></a>
<a name="26728"><span class="lineNum">   26728 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(hmm != nullptr);</span></a>
<a name="26729"><span class="lineNum">   26729 </span><span class="lineNoCov">          0 :   hmm-&gt;clear();</span></a>
<a name="26730"><span class="lineNum">   26730 </span>            : </a>
<a name="26731"><span class="lineNum">   26731 </span><span class="lineNoCov">          0 :   st = SgNode::get_globalFunctionTypeTable()-&gt;get_function_type_table();</span></a>
<a name="26732"><span class="lineNum">   26732 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(st != nullptr);</span></a>
<a name="26733"><span class="lineNum">   26733 </span><span class="lineNoCov">          0 :   hmm = st-&gt;get_table();</span></a>
<a name="26734"><span class="lineNum">   26734 </span><span class="lineNoCov">          0 :   ROSE_ASSERT(hmm != nullptr);</span></a>
<a name="26735"><span class="lineNum">   26735 </span><span class="lineNoCov">          0 :   hmm-&gt;clear();</span></a>
<a name="26736"><span class="lineNum">   26736 </span><span class="lineNoCov">          0 : }</span></a>
<a name="26737"><span class="lineNum">   26737 </span>            : </a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
