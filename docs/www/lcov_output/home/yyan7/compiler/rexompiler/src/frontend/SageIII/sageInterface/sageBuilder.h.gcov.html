<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface/sageBuilder.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/SageIII/sageInterface</a> - sageBuilder.h<span style="font-size: 80%;"> (source / <a href="sageBuilder.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">42</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryHi">91.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntry">152</td>
            <td class="headerCovTableEntryLo">38.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ROSE_SAGE_BUILDER_INTERFACE</a>
<a name="2"><span class="lineNum">       2 </span>            : #define ROSE_SAGE_BUILDER_INTERFACE</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            : #include &lt;string&gt;</a>
<a name="5"><span class="lineNum">       5 </span>            : </a>
<a name="6"><span class="lineNum">       6 </span>            : /*!</a>
<a name="7"><span class="lineNum">       7 </span>            :   \defgroup frontendSageHighLevelInterface High level AST builders</a>
<a name="8"><span class="lineNum">       8 </span>            :   \ingroup ROSE_FrontEndGroup</a>
<a name="9"><span class="lineNum">       9 </span>            :   \brief This namespace contains high level SAGE III AST node and subtree builders</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            :   Building AST trees using raw SgNode constructors is tedious and error-prone. It becomes</a>
<a name="12"><span class="lineNum">      12 </span>            :   even more difficult with the presence of symbol tables. This namespace contains major</a>
<a name="13"><span class="lineNum">      13 </span>            :   AST node builders on top of the constructors to take care of symbol tables, various</a>
<a name="14"><span class="lineNum">      14 </span>            :   edges to scope,  parent and so on.</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            :   \authors Chunhua Liao (last modified 2/12/2008)</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : */</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : #include &quot;sageInterface.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : </a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;Rose/Diagnostics.h&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : // forward declarations required for templated functions using those functions</a>
<a name="25"><span class="lineNum">      25 </span>            : namespace SageInterface {</a>
<a name="26"><span class="lineNum">      26 </span>            :   ROSE_DLL_API void setOneSourcePositionForTransformation (SgNode * root);</a>
<a name="27"><span class="lineNum">      27 </span>            :   ROSE_DLL_API void setSourcePosition(SgNode* node);</a>
<a name="28"><span class="lineNum">      28 </span>            : }</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : /** Functions that build an AST. */</a>
<a name="31"><span class="lineNum">      31 </span>            : namespace SageBuilder</a>
<a name="32"><span class="lineNum">      32 </span>            : {</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : // DQ (3/24/2016): Adding Robb's meageage mechanism (data member and function).</a>
<a name="35"><span class="lineNum">      35 </span>            :   extern Sawyer::Message::Facility mlog;</a>
<a name="36"><span class="lineNum">      36 </span>            :   void initDiagnostics();</a>
<a name="37"><span class="lineNum">      37 </span>            : </a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : #if 0</a>
<a name="40"><span class="lineNum">      40 </span>            : //---------------------AST creation/building/construction-----------------</a>
<a name="41"><span class="lineNum">      41 </span>            :   SgExpression* buildConst(SgType* t, const string &amp; val);</a>
<a name="42"><span class="lineNum">      42 </span>            :   SgExpression* buildConstInt(int val);</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            :   // build sth in languages, but not in SAGE AST</a>
<a name="45"><span class="lineNum">      45 </span>            :   // how to specify position info?  then</a>
<a name="46"><span class="lineNum">      46 </span>            : </a>
<a name="47"><span class="lineNum">      47 </span>            :   SgClassDeclaration* buildClassDeclaration(...,class_type);</a>
<a name="48"><span class="lineNum">      48 </span>            :   // or</a>
<a name="49"><span class="lineNum">      49 </span>            :   SgClassDeclaration* buildStruct(...);</a>
<a name="50"><span class="lineNum">      50 </span>            :   SgClassDeclaration* buildClass(...);</a>
<a name="51"><span class="lineNum">      51 </span>            :   SgClassDeclaration* buildUnion(...);</a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span>            :   // build B from dependent A</a>
<a name="54"><span class="lineNum">      54 </span>            :  SgTemplateInstantiationMemberFunctionDecl*  buildForwardFunctionDeclaration</a>
<a name="55"><span class="lineNum">      55 </span>            :      (SgTemplateInstantiationMemberFunctionDecl * memberFunctionInstantiation);</a>
<a name="56"><span class="lineNum">      56 </span>            : </a>
<a name="57"><span class="lineNum">      57 </span>            :   //previous attempt: src/midend/astUtil/astInterface</a>
<a name="58"><span class="lineNum">      58 </span>            :   //  AstNodePtr AstInterface::CreateConst( const string&amp; val, const string&amp; valtype) const</a>
<a name="59"><span class="lineNum">      59 </span>            :   //  AstNodePtr AstInterfaceBase::CreateConstInt( int val)</a>
<a name="60"><span class="lineNum">      60 </span>            : #endif</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : //----------------------------------------------------------</a>
<a name="63"><span class="lineNum">      63 </span>            : //@{</a>
<a name="64"><span class="lineNum">      64 </span>            : /*! @name Scope stack interfaces</a>
<a name="65"><span class="lineNum">      65 </span>            :     \brief  a global data structure to store current scope and parent scopes.</a>
<a name="66"><span class="lineNum">      66 </span>            : </a>
<a name="67"><span class="lineNum">      67 </span>            : Scope stack is provided as an alternative to manually passing scope parameters to builder functions. It is not required to be used. Please use the recommendeded operation functions for maintaining the scope stack. Don't use raw container access functions to ScopeStack.  e.g. avoid ScopeStack.push_back(), using pushScopeStack() instead.</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            :  \todo consider complex cases:</a>
<a name="70"><span class="lineNum">      70 </span>            :         - how many scope stacks to keep? one. examine only one transparently</a>
<a name="71"><span class="lineNum">      71 </span>            :         - regular: push a child scope of current scope, add symbols etc.</a>
<a name="72"><span class="lineNum">      72 </span>            :         - irregular: push an arbitrary scope temporarily,  add some symbol, then pop</a>
<a name="73"><span class="lineNum">      73 </span>            :         - even push a chain of scopes</a>
<a name="74"><span class="lineNum">      74 </span>            :         - restore scopes</a>
<a name="75"><span class="lineNum">      75 </span>            : */</a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            : /*! \brief intended to be a private member, don't access it directly. could be changed any time</a>
<a name="78"><span class="lineNum">      78 </span>            : */</a>
<a name="79"><span class="lineNum">      79 </span>            : extern std::list&lt;SgScopeStatement*&gt; ScopeStack;</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            : // DQ (11/30/2010): Added support for building Fortran case insensitive symbol table handling.</a>
<a name="82"><span class="lineNum">      82 </span>            : //! Support for construction of case sensitive/insensitive symbol table handling in scopes.</a>
<a name="83"><span class="lineNum">      83 </span>            : extern bool symbol_table_case_insensitive_semantics;</a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            : //! Public interfaces of the scope stack, should be stable</a>
<a name="86"><span class="lineNum">      86 </span>            : ROSE_DLL_API void pushScopeStack (SgScopeStatement* stmt);</a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span>            : // DQ (3/20/2017): This function is not called (the function above is the more useful one that is used).</a>
<a name="89"><span class="lineNum">      89 </span>            : // ROSE_DLL_API void pushScopeStack (SgNode* node);</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            : ROSE_DLL_API void popScopeStack();</a>
<a name="92"><span class="lineNum">      92 </span>            : ROSE_DLL_API SgScopeStatement* topScopeStack();</a>
<a name="93"><span class="lineNum">      93 </span>            : ROSE_DLL_API bool emptyScopeStack();</a>
<a name="94"><span class="lineNum">      94 </span>            : ROSE_DLL_API void clearScopeStack();</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span>            : // DQ (3/11/2012): Added new function to the API for the internal scope stack.</a>
<a name="97"><span class="lineNum">      97 </span>            : //! Support to retrive the SgGlobal from the internal scope stack (error if not present in a non-empty list, return null for empty list).</a>
<a name="98"><span class="lineNum">      98 </span>            : SgScopeStatement* getGlobalScopeFromScopeStack();</a>
<a name="99"><span class="lineNum">      99 </span>            : </a>
<a name="100"><span class="lineNum">     100 </span>            : // DQ (3/20/2017): This function is not used.</a>
<a name="101"><span class="lineNum">     101 </span>            : // bool isInScopeStack(SgScopeStatement * scope);</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            : bool inSwitchScope();</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            : // DQ (3/20/2017): This function is not used.</a>
<a name="106"><span class="lineNum">     106 </span>            : // TV: for debug purpose</a>
<a name="107"><span class="lineNum">     107 </span>            : // std::string stringFromScopeStack();</a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<a name="110"><span class="lineNum">     110 </span>            : //@}</a>
<a name="111"><span class="lineNum">     111 </span>            : </a>
<a name="112"><span class="lineNum">     112 </span>            : #if 0</a>
<a name="113"><span class="lineNum">     113 </span>            : // DQ (3/20/2017): These functions are not used (suggest using the API in the symbol table initialization).</a>
<a name="114"><span class="lineNum">     114 </span>            : //----------------------------------------------------------</a>
<a name="115"><span class="lineNum">     115 </span>            : //@{</a>
<a name="116"><span class="lineNum">     116 </span>            : /*! @name Case sensitivity interfaces</a>
<a name="117"><span class="lineNum">     117 </span>            :     \brief  Allows for setting case sensitivity for constructed scopes.</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            : Nodes constructed for a Fortran file should be constructed with case insensitive.  All other should be case sensitive.  This interface supports multiple languages within the project.  The default is based on the type of file last parsed in the project.</a>
<a name="120"><span class="lineNum">     120 </span>            : */</a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span>            : //! Set to insensitive case (Fortran files)</a>
<a name="123"><span class="lineNum">     123 </span>            : ROSE_DLL_API void setCaseInsensitive();</a>
<a name="124"><span class="lineNum">     124 </span>            : //! Set to sensitive case (all other languages)</a>
<a name="125"><span class="lineNum">     125 </span>            : ROSE_DLL_API void setCaseSensitive();</a>
<a name="126"><span class="lineNum">     126 </span>            : //! Set to that of an exsiting scope statement</a>
<a name="127"><span class="lineNum">     127 </span>            : ROSE_DLL_API void setCaseFromScope(SgScopeStatement* scope);</a>
<a name="128"><span class="lineNum">     128 </span>            : </a>
<a name="129"><span class="lineNum">     129 </span>            : //@}</a>
<a name="130"><span class="lineNum">     130 </span>            : #endif</a>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            : // *************************************************************************************************************</a>
<a name="134"><span class="lineNum">     134 </span>            : // DQ (5/1/2012): This is another possible interface: supporting how we set the source code position and mark is</a>
<a name="135"><span class="lineNum">     135 </span>            : // as either a transformation or as actual code to be assigned a source position as part of the AST construction.</a>
<a name="136"><span class="lineNum">     136 </span>            : // *************************************************************************************************************</a>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<a name="138"><span class="lineNum">     138 </span>            : enum SourcePositionClassification</a>
<a name="139"><span class="lineNum">     139 </span>            :    {</a>
<a name="140"><span class="lineNum">     140 </span>            :      e_sourcePositionError,                //! Error value for enum.</a>
<a name="141"><span class="lineNum">     141 </span>            :      e_sourcePositionDefault,              //! Default source position.</a>
<a name="142"><span class="lineNum">     142 </span>            :      e_sourcePositionTransformation,       //! Classify as a transformation.</a>
<a name="143"><span class="lineNum">     143 </span>            :      e_sourcePositionCompilerGenerated,    //! Classify as compiler generated code (e.g. template instantiation).</a>
<a name="144"><span class="lineNum">     144 </span>            :      e_sourcePositionNullPointers,         //! Set pointers to Sg_File_Info objects to NULL.</a>
<a name="145"><span class="lineNum">     145 </span>            :      e_sourcePositionFrontendConstruction, //! Specify as source position to be filled in as part of AST construction in the front-end.</a>
<a name="146"><span class="lineNum">     146 </span>            :      e_sourcePosition_last                 //! Last entry in enum.</a>
<a name="147"><span class="lineNum">     147 </span>            :    };</a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            : //! C++ SageBuilder namespace specific state for storage of the source code position state (used to control how the source code positon is defined for IR nodes built within the SageBuilder interface).</a>
<a name="150"><span class="lineNum">     150 </span>            : extern SourcePositionClassification SourcePositionClassificationMode;</a>
<a name="151"><span class="lineNum">     151 </span>            : </a>
<a name="152"><span class="lineNum">     152 </span>            : //! Get the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).</a>
<a name="153"><span class="lineNum">     153 </span>            : ROSE_DLL_API SourcePositionClassification getSourcePositionClassificationMode();</a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            : //! display function for debugging</a>
<a name="156"><span class="lineNum">     156 </span>            : ROSE_DLL_API std::string display(SourcePositionClassification &amp; scp);</a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span>            : //! Set the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).</a>
<a name="159"><span class="lineNum">     159 </span>            : ROSE_DLL_API void setSourcePositionClassificationMode(SourcePositionClassification X);</a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            : //! DQ (7/27/2012): changed semantics from removing the template arguments in names to adding the template arguments to names.</a>
<a name="162"><span class="lineNum">     162 </span>            : ROSE_DLL_API SgName appendTemplateArgumentsToName( const SgName &amp; name, const SgTemplateArgumentPtrList &amp; templateArgumentsList);</a>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<a name="164"><span class="lineNum">     164 </span>            : //! DQ (3/9/2018): Added to support debugging.</a>
<a name="165"><span class="lineNum">     165 </span>            : SgName unparseTemplateArgumentToString (SgTemplateArgument* templateArgument);</a>
<a name="166"><span class="lineNum">     166 </span>            : </a>
<a name="167"><span class="lineNum">     167 </span>            : // *************************************************************************************************************</a>
<a name="168"><span class="lineNum">     168 </span>            : </a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            : </a>
<a name="171"><span class="lineNum">     171 </span>            : //--------------------------------------------------------------</a>
<a name="172"><span class="lineNum">     172 </span>            : //@{</a>
<a name="173"><span class="lineNum">     173 </span>            : /*! @name Builders for SgType</a>
<a name="174"><span class="lineNum">     174 </span>            :   \brief Builders for simple and complex SgType nodes, such as integer type, function type, array type, struct type, etc.</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span>            :   \todo SgModifierType,SgNamedType(SgClassType,SgEnumType,SgTypedefType), SgQualifiedNameType, SgTemplateType,SgTypeComplex, SgTypeDefault,SgTypeEllipse,SgTypeGlobalVoid,SgTypeImaginary</a>
<a name="177"><span class="lineNum">     177 </span>            : */</a>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<a name="179"><span class="lineNum">     179 </span>            : //! Built in simple types</a>
<a name="180"><span class="lineNum">     180 </span>            : ROSE_DLL_API SgTypeBool *  buildBoolType();</a>
<a name="181"><span class="lineNum">     181 </span>            : ROSE_DLL_API SgTypeNullptr* buildNullptrType();</a>
<a name="182"><span class="lineNum">     182 </span>            : ROSE_DLL_API SgTypeChar *  buildCharType();</a>
<a name="183"><span class="lineNum">     183 </span>            : ROSE_DLL_API SgTypeDouble* buildDoubleType();</a>
<a name="184"><span class="lineNum">     184 </span>            : ROSE_DLL_API SgTypeFloat*  buildFloatType();</a>
<a name="185"><span class="lineNum">     185 </span>            : ROSE_DLL_API SgTypeInt *   buildIntType();</a>
<a name="186"><span class="lineNum">     186 </span>            : ROSE_DLL_API SgTypeLong*    buildLongType();</a>
<a name="187"><span class="lineNum">     187 </span>            : ROSE_DLL_API SgTypeLongDouble* buildLongDoubleType();</a>
<a name="188"><span class="lineNum">     188 </span>            : ROSE_DLL_API SgTypeLongLong * buildLongLongType();</a>
<a name="189"><span class="lineNum">     189 </span>            : ROSE_DLL_API SgTypeShort*    buildShortType();</a>
<a name="190"><span class="lineNum">     190 </span>            : ROSE_DLL_API SgTypeFloat80*  buildFloat80Type();</a>
<a name="191"><span class="lineNum">     191 </span>            : ROSE_DLL_API SgTypeFloat128* buildFloat128Type();</a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span>            : // CR (2/20/2020): Added builder for Jovial fixed type</a>
<a name="194"><span class="lineNum">     194 </span>            : //! Build a Jovial fixed type with a fraction specifier and a scale specifier</a>
<a name="195"><span class="lineNum">     195 </span>            : ROSE_DLL_API SgTypeFixed* buildFixedType(SgExpression* fraction, SgExpression* scale);</a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            : //! DQ (8/21/2010): We want to move to the new buildStringType( SgExpression*,size_t) function over the older buildStringType() function.</a>
<a name="198"><span class="lineNum">     198 </span>            : ROSE_DLL_API SgTypeString* buildStringType();</a>
<a name="199"><span class="lineNum">     199 </span>            : // SgTypeString* buildStringType( SgExpression* stringLengthExpression, size_t stringLengthLiteral );</a>
<a name="200"><span class="lineNum">     200 </span>            : ROSE_DLL_API SgTypeString* buildStringType( SgExpression* stringLengthExpression );</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            : ROSE_DLL_API SgTypeVoid * buildVoidType();</a>
<a name="203"><span class="lineNum">     203 </span>            : ROSE_DLL_API SgTypeWchar* buildWcharType();</a>
<a name="204"><span class="lineNum">     204 </span>            : </a>
<a name="205"><span class="lineNum">     205 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="206"><span class="lineNum">     206 </span>            : ROSE_DLL_API SgTypeChar16* buildChar16Type();</a>
<a name="207"><span class="lineNum">     207 </span>            : ROSE_DLL_API SgTypeChar32* buildChar32Type();</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            : ROSE_DLL_API SgTypeSignedChar*  buildSignedCharType();</a>
<a name="210"><span class="lineNum">     210 </span>            : ROSE_DLL_API SgTypeSignedInt*   buildSignedIntType();</a>
<a name="211"><span class="lineNum">     211 </span>            : ROSE_DLL_API SgTypeSignedLong*  buildSignedLongType();</a>
<a name="212"><span class="lineNum">     212 </span>            : ROSE_DLL_API SgTypeSignedLongLong* buildSignedLongLongType();</a>
<a name="213"><span class="lineNum">     213 </span>            : ROSE_DLL_API SgTypeSignedShort* buildSignedShortType();</a>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<a name="215"><span class="lineNum">     215 </span>            : #if 1</a>
<a name="216"><span class="lineNum">     216 </span>            : ROSE_DLL_API SgTypeSigned128bitInteger* buildSigned128bitIntegerType();</a>
<a name="217"><span class="lineNum">     217 </span>            : ROSE_DLL_API SgTypeUnsigned128bitInteger* buildUnsigned128bitIntegerType();</a>
<a name="218"><span class="lineNum">     218 </span>            : #endif</a>
<a name="219"><span class="lineNum">     219 </span>            : </a>
<a name="220"><span class="lineNum">     220 </span>            : ROSE_DLL_API SgTypeUnsignedChar* buildUnsignedCharType();</a>
<a name="221"><span class="lineNum">     221 </span>            : ROSE_DLL_API SgTypeUnsignedInt* buildUnsignedIntType();</a>
<a name="222"><span class="lineNum">     222 </span>            : ROSE_DLL_API SgTypeUnsignedLong*    buildUnsignedLongType();</a>
<a name="223"><span class="lineNum">     223 </span>            : ROSE_DLL_API SgTypeUnsignedLongLong*    buildUnsignedLongLongType();</a>
<a name="224"><span class="lineNum">     224 </span>            : ROSE_DLL_API SgTypeUnsignedShort*    buildUnsignedShortType();</a>
<a name="225"><span class="lineNum">     225 </span>            : ROSE_DLL_API SgTypeUnknown * buildUnknownType();</a>
<a name="226"><span class="lineNum">     226 </span>            : </a>
<a name="227"><span class="lineNum">     227 </span>            : ROSE_DLL_API SgAutoType * buildAutoType();</a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span>            : // CR (2/20/2020): Added builder functions for type size (kind) expressions for Fortran and Jovial</a>
<a name="230"><span class="lineNum">     230 </span>            : //! Builder functions for primitive types with type size (kind) expressions</a>
<a name="231"><span class="lineNum">     231 </span>            : ROSE_DLL_API SgTypeBool * buildBoolType(SgExpression* kind_expr);</a>
<a name="232"><span class="lineNum">     232 </span>            : ROSE_DLL_API SgTypeInt * buildIntType(SgExpression* kind_expr);</a>
<a name="233"><span class="lineNum">     233 </span>            : ROSE_DLL_API SgTypeFloat * buildFloatType(SgExpression* kind_expr);</a>
<a name="234"><span class="lineNum">     234 </span>            : ROSE_DLL_API SgTypeUnsignedInt* buildUnsignedIntType(SgExpression* kind_expr);</a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span>            : //! Build a type based on Fortran's implicit typing rules.</a>
<a name="237"><span class="lineNum">     237 </span>            : //! Currently this interface does not take into account possible implicit</a>
<a name="238"><span class="lineNum">     238 </span>            : //! statements that change the rules.</a>
<a name="239"><span class="lineNum">     239 </span>            : ROSE_DLL_API SgType* buildFortranImplicitType(SgName name);</a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            : //! Build a pointer type</a>
<a name="242"><span class="lineNum">     242 </span>            : ROSE_DLL_API SgPointerType* buildPointerType(SgType *base_type = NULL);</a>
<a name="243"><span class="lineNum">     243 </span>            : </a>
<a name="244"><span class="lineNum">     244 </span>            : //! Build a reference type</a>
<a name="245"><span class="lineNum">     245 </span>            : ROSE_DLL_API SgReferenceType* buildReferenceType(SgType *base_type = NULL);</a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span>            : //! Build a rvalue reference type</a>
<a name="248"><span class="lineNum">     248 </span>            : ROSE_DLL_API SgRvalueReferenceType* buildRvalueReferenceType(SgType *base_type);</a>
<a name="249"><span class="lineNum">     249 </span>            : </a>
<a name="250"><span class="lineNum">     250 </span>            : //! Build a decltype reference type</a>
<a name="251"><span class="lineNum">     251 </span>            : ROSE_DLL_API SgDeclType* buildDeclType(SgExpression *base_expression, SgType* base_type);</a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span>            : //! Build a GNU typeof operator</a>
<a name="254"><span class="lineNum">     254 </span>            : ROSE_DLL_API SgTypeOfType* buildTypeOfType(SgExpression *base_expression, SgType* base_type);</a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span>            : // Liao, entirely phase out this function ! Build a modifier type with no modifiers set</a>
<a name="257"><span class="lineNum">     257 </span>            : //SgModifierType* buildModifierType(SgType *base_type = NULL);</a>
<a name="258"><span class="lineNum">     258 </span>            : </a>
<a name="259"><span class="lineNum">     259 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType for a number of the functions below.</a>
<a name="260"><span class="lineNum">     260 </span>            : //! Build a modifier type.</a>
<a name="261"><span class="lineNum">     261 </span>            : ROSE_DLL_API SgModifierType* buildModifierType(SgType* base_type = NULL);</a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span>            : //! Build a const type.</a>
<a name="264"><span class="lineNum">     264 </span>            : ROSE_DLL_API SgModifierType* buildConstType(SgType* base_type = NULL);</a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span>            : //! Build an aliased type for Ada.</a>
<a name="267"><span class="lineNum">     267 </span>            : ROSE_DLL_API SgModifierType* buildAliasedType(SgType* base_type = NULL);</a>
<a name="268"><span class="lineNum">     268 </span>            : </a>
<a name="269"><span class="lineNum">     269 </span>            : //! Build a volatile type.</a>
<a name="270"><span class="lineNum">     270 </span>            : ROSE_DLL_API SgModifierType* buildVolatileType(SgType* base_type = NULL);</a>
<a name="271"><span class="lineNum">     271 </span>            : </a>
<a name="272"><span class="lineNum">     272 </span>            : //! Build a const volatile type.</a>
<a name="273"><span class="lineNum">     273 </span>            : ROSE_DLL_API SgModifierType* buildConstVolatileType(SgType* base_type = NULL);</a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span>            : //! Build a restrict type.</a>
<a name="276"><span class="lineNum">     276 </span>            : ROSE_DLL_API SgModifierType* buildRestrictType(SgType* base_type);</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            : //! Build ArrayType</a>
<a name="279"><span class="lineNum">     279 </span>            : ROSE_DLL_API SgArrayType* buildArrayType(SgType* base_type=NULL, SgExpression* index=NULL);</a>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<a name="281"><span class="lineNum">     281 </span>            : // RASMUSSEN (1/25/2018)</a>
<a name="282"><span class="lineNum">     282 </span>            : //! Build an ArrayType based on dimension information.</a>
<a name="283"><span class="lineNum">     283 </span>            : //! Note, the index member variable will be set to a NullExpression.</a>
<a name="284"><span class="lineNum">     284 </span>            : //!</a>
<a name="285"><span class="lineNum">     285 </span>            : //! \param base_type The base type of the array.</a>
<a name="286"><span class="lineNum">     286 </span>            : //!        Note that if the base type is itself an array type, the shape of the array may be changed.</a>
<a name="287"><span class="lineNum">     287 </span>            : //! \param dim_info A list of expressions describing the shape of the array.</a>
<a name="288"><span class="lineNum">     288 </span>            : //!        The rank of the array is set from the length of this list.</a>
<a name="289"><span class="lineNum">     289 </span>            : ROSE_DLL_API SgArrayType* buildArrayType(SgType* base_type, SgExprListExp* dim_info);</a>
<a name="290"><span class="lineNum">     290 </span>            : </a>
<a name="291"><span class="lineNum">     291 </span>            : // DQ (8/27/2010): Added Fortran specific support for types based on kind expressions.</a>
<a name="292"><span class="lineNum">     292 </span>            : //! Build a type based on the Fortran kind mechanism</a>
<a name="293"><span class="lineNum">     293 </span>            : ROSE_DLL_API SgModifierType* buildFortranKindType(SgType* base_type, SgExpression* kindExpression );</a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span>            : //! Build function type from return type and parameter type list</a>
<a name="296"><span class="lineNum">     296 </span>            : ROSE_DLL_API SgFunctionType* buildFunctionType(SgType* return_type, SgFunctionParameterTypeList * typeList=NULL);</a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span>            : //! Build function type from return type and parameter list</a>
<a name="299"><span class="lineNum">     299 </span>            : ROSE_DLL_API SgFunctionType* buildFunctionType(SgType* return_type, SgFunctionParameterList * argList=NULL);</a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span>            : // DQ (1/10/2020): removed the default argument since we need to make sure it is used.</a>
<a name="302"><span class="lineNum">     302 </span>            : //! DQ (1/16/2009): Added to support member function in C++ (for new interface)</a>
<a name="303"><span class="lineNum">     303 </span>            : // ROSE_DLL_API SgMemberFunctionType* buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList * typeList, SgScopeStatement *struct_name, unsigned int mfunc_specifier, unsigned int ref_qualifiers = 0);</a>
<a name="304"><span class="lineNum">     304 </span>            : ROSE_DLL_API SgMemberFunctionType* buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList * typeList, SgScopeStatement *struct_name, unsigned int mfunc_specifier, unsigned int ref_qualifiers = 0);</a>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<a name="306"><span class="lineNum">     306 </span>            : // DQ (3/20/2017): This function is not used (so let's see if we can remove it).</a>
<a name="307"><span class="lineNum">     307 </span>            : //! DQ (12/2/2011): Added for symetry with other functios to generate SgFunctionType</a>
<a name="308"><span class="lineNum">     308 </span>            : // ROSE_DLL_API SgMemberFunctionType* buildMemberFunctionType(SgType* return_type, SgFunctionParameterList* argList = NULL, SgClassDefinition *struct_name = NULL, unsigned int mfunc_specifier = 0);</a>
<a name="309"><span class="lineNum">     309 </span>            : </a>
<a name="310"><span class="lineNum">     310 </span>            : //! DQ (8/19/2012): Refactored some of the code supporting construction of the SgMemberFunctionType.</a>
<a name="311"><span class="lineNum">     311 </span>            : ROSE_DLL_API SgMemberFunctionType* buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList, SgType *classType, unsigned int mfunc_specifier, unsigned int ref_qualifiers = 0);</a>
<a name="312"><span class="lineNum">     312 </span>            : </a>
<a name="313"><span class="lineNum">     313 </span>            : // PP (07/14/2016):</a>
<a name="314"><span class="lineNum">     314 </span>            : //! Some support for building class template instantiation declarations.</a>
<a name="315"><span class="lineNum">     315 </span>            : //! Note, the template is not actually instantiated, but a `forward declaration'</a>
<a name="316"><span class="lineNum">     316 </span>            : //! node is created.</a>
<a name="317"><span class="lineNum">     317 </span>            : //!</a>
<a name="318"><span class="lineNum">     318 </span>            : //! \param template_decl the template class declaration</a>
<a name="319"><span class="lineNum">     319 </span>            : //!        (e.g., template &lt;class T&gt; struct matrix {};)</a>
<a name="320"><span class="lineNum">     320 </span>            : //! \param template_args the arguments of the template instantiation.</a>
<a name="321"><span class="lineNum">     321 </span>            : //!        (e.g., [SgTypeFloat]).</a>
<a name="322"><span class="lineNum">     322 </span>            : //!        WARNING: the objects in this list will be linked into the template declaration</a>
<a name="323"><span class="lineNum">     323 </span>            : //!                 and their parent pointer may change. Thus it is the caller's</a>
<a name="324"><span class="lineNum">     324 </span>            : //!                 responsibility to clone nodes if used elsewhere.</a>
<a name="325"><span class="lineNum">     325 </span>            : //!                 e.g., SomeClass&lt;0&gt; &lt;- the expression representing 0 may be modified.</a>
<a name="326"><span class="lineNum">     326 </span>            : //! \result a class type for the instantiated template (e.g., matrix&lt;float&gt;)</a>
<a name="327"><span class="lineNum">     327 </span>            : ROSE_DLL_API</a>
<a name="328"><span class="lineNum">     328 </span>            : SgClassType*</a>
<a name="329"><span class="lineNum">     329 </span>            : buildClassTemplateType(SgTemplateClassDeclaration* template_decl, Rose_STL_Container&lt;SgNode *&gt;&amp; template_args);</a>
<a name="330"><span class="lineNum">     330 </span>            : </a>
<a name="331"><span class="lineNum">     331 </span>            : //! Same as buildClassTemplateType(), just better name</a>
<a name="332"><span class="lineNum">     332 </span>            : ROSE_DLL_API</a>
<a name="333"><span class="lineNum">     333 </span>            : SgClassType*</a>
<a name="334"><span class="lineNum">     334 </span>            : buildTemplateClassType(SgTemplateClassDeclaration* template_decl, Rose_STL_Container&lt;SgNode *&gt;&amp; template_args);</a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span>            :  //! Build an opaque type with a name, useful when a type's details are unknown during transformation, especially for a runtime library's internal type. Must provide scope here.</a>
<a name="337"><span class="lineNum">     337 </span>            :  /*! Some types are not known during translation but nevertheless are needed. For example, some</a>
<a name="338"><span class="lineNum">     338 </span>            :   * internal types from a runtime library.  To work around this problem: this function prepends a hidden typedef declaration into scope</a>
<a name="339"><span class="lineNum">     339 </span>            :   * 'typedef int OpaqueTypeName;'</a>
<a name="340"><span class="lineNum">     340 </span>            :   * The translation-generated code is expected to include the runtime library's headers to</a>
<a name="341"><span class="lineNum">     341 </span>            :   * have the real type declarations.</a>
<a name="342"><span class="lineNum">     342 </span>            :   */</a>
<a name="343"><span class="lineNum">     343 </span>            : ROSE_DLL_API SgType* buildOpaqueType(std::string const type_name, SgScopeStatement * scope);</a>
<a name="344"><span class="lineNum">     344 </span>            : </a>
<a name="345"><span class="lineNum">     345 </span>            : // DQ (7/29/2010): Changed return type from SgType to SgModifierType for a number of the functions below.</a>
<a name="346"><span class="lineNum">     346 </span>            : //! Build a UPC strict type</a>
<a name="347"><span class="lineNum">     347 </span>            : ROSE_DLL_API SgModifierType* buildUpcStrictType(SgType *base_type = NULL);</a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span>            : //! Build a UPC relaxed type</a>
<a name="350"><span class="lineNum">     350 </span>            : ROSE_DLL_API SgModifierType* buildUpcRelaxedType(SgType *base_type = NULL);</a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span>            : //! Build a UPC shared type</a>
<a name="353"><span class="lineNum">     353 </span>            : ROSE_DLL_API SgModifierType* buildUpcSharedType(SgType *base_type = NULL, long layout = -1);</a>
<a name="354"><span class="lineNum">     354 </span>            : // SgModifierType* buildUpcSharedType(SgType *base_type = NULL);</a>
<a name="355"><span class="lineNum">     355 </span>            : </a>
<a name="356"><span class="lineNum">     356 </span>            : //! Build a UPC shared[] type</a>
<a name="357"><span class="lineNum">     357 </span>            : ROSE_DLL_API SgModifierType* buildUpcBlockIndefiniteType(SgType *base_type = NULL);</a>
<a name="358"><span class="lineNum">     358 </span>            : </a>
<a name="359"><span class="lineNum">     359 </span>            : //! Build a UPC shared[*] type</a>
<a name="360"><span class="lineNum">     360 </span>            : ROSE_DLL_API SgModifierType* buildUpcBlockStarType(SgType *base_type = NULL);</a>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span>            : //! Build a UPC shared[n] type</a>
<a name="363"><span class="lineNum">     363 </span>            : ROSE_DLL_API SgModifierType* buildUpcBlockNumberType(SgType *base_type, long block_factor);</a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            : //! Build a complex type</a>
<a name="366"><span class="lineNum">     366 </span>            : ROSE_DLL_API SgTypeComplex* buildComplexType(SgType *base_type = NULL);</a>
<a name="367"><span class="lineNum">     367 </span>            : </a>
<a name="368"><span class="lineNum">     368 </span>            : //! Build an imaginary type</a>
<a name="369"><span class="lineNum">     369 </span>            : ROSE_DLL_API SgTypeImaginary* buildImaginaryType(SgType *base_type = NULL);</a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span>            : //! Build a const/volatile type qualifier</a>
<a name="372"><span class="lineNum">     372 </span>            : ROSE_DLL_API SgConstVolatileModifier * buildConstVolatileModifier (SgConstVolatileModifier::cv_modifier_enum mtype=SgConstVolatileModifier::e_unknown);</a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            : //! Build a Matlab Matrix Type</a>
<a name="375"><span class="lineNum">     375 </span>            : ROSE_DLL_API SgTypeMatrix* buildMatrixType();</a>
<a name="376"><span class="lineNum">     376 </span>            : </a>
<a name="377"><span class="lineNum">     377 </span>            : //! Build a tuple of types. Useful for a function returning multiple variables of different types</a>
<a name="378"><span class="lineNum">     378 </span>            : ROSE_DLL_API SgTypeTuple* buildTupleType(SgType *t1 = NULL, SgType *t2 = NULL, SgType *t3 = NULL, SgType *t4 = NULL, SgType *t5 = NULL, SgType *t6 = NULL, SgType *t7 = NULL, SgType *t8 = NULL, SgType *t9 = NULL, SgType *t10 = NULL);</a>
<a name="379"><span class="lineNum">     379 </span>            : </a>
<a name="380"><span class="lineNum">     380 </span>            : //! Build a non real type used for template parameter. Internally a SgNorealDecl is also built.</a>
<a name="381"><span class="lineNum">     381 </span>            : ROSE_DLL_API SgNonrealType* buildNonrealType(const SgName &amp; name,  SgDeclarationScope* scope);</a>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<a name="383"><span class="lineNum">     383 </span>            : //@}</a>
<a name="384"><span class="lineNum">     384 </span>            : </a>
<a name="385"><span class="lineNum">     385 </span>            : //--------------------------------------------------------------</a>
<a name="386"><span class="lineNum">     386 </span>            : //@{</a>
<a name="387"><span class="lineNum">     387 </span>            : /*! @name Builders for expressions</a>
<a name="388"><span class="lineNum">     388 </span>            :   \brief handle side effects of parent pointers, Sg_File_Info, lvalue etc.</a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span>            : Expressions are usually built using bottomup approach, i.e. buiding operands first, then the expression operating on the operands. It is also possible to build expressions with NULL operands or empty values first, then set them afterwards.</a>
<a name="391"><span class="lineNum">     391 </span>            :   - Value string is not included in the argument list for simplicty. It can be set afterwards using set_valueString()</a>
<a name="392"><span class="lineNum">     392 </span>            :   - Expression builders are organized roughtly in the order of class hierarchy list of ROSE Web Reference</a>
<a name="393"><span class="lineNum">     393 </span>            :   - default values for arguments are provided to support top-down construction. Should use SageInterface::setOperand(),setLhsOperand(), setRhsOperand() etc to set operands and handle side effects.</a>
<a name="394"><span class="lineNum">     394 </span>            :   \todo SgAsmOp, SgAsteriskShapeExp,</a>
<a name="395"><span class="lineNum">     395 </span>            :   SgValueExp, SgEnumVal,</a>
<a name="396"><span class="lineNum">     396 </span>            :   SgThrowOp,</a>
<a name="397"><span class="lineNum">     397 </span>            : */</a>
<a name="398"><span class="lineNum">     398 </span>            : </a>
<a name="399"><span class="lineNum">     399 </span>            : // JJW (11/19/2008): _nfi versions of functions set file info objects to NULL (used in frontend)</a>
<a name="400"><span class="lineNum">     400 </span>            : </a>
<a name="401"><span class="lineNum">     401 </span>            : ROSE_DLL_API SgVariantExpression * buildVariantExpression();</a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span>            : //! Build a null expression, set file info as the default one</a>
<a name="404"><span class="lineNum">     404 </span>            : ROSE_DLL_API SgNullExpression* buildNullExpression();</a>
<a name="405"><span class="lineNum">     405 </span>            : //! No file info version of buildNullExpression(). File info is to be set later on.</a>
<a name="406"><span class="lineNum">     406 </span>            : ROSE_DLL_API SgNullExpression* buildNullExpression_nfi();</a>
<a name="407"><span class="lineNum">     407 </span>            : </a>
<a name="408"><span class="lineNum">     408 </span>            : //! Build a bool value expression, the name convention of SgBoolValExp is little different from others for some unknown reason</a>
<a name="409"><span class="lineNum">     409 </span>            : ROSE_DLL_API SgBoolValExp* buildBoolValExp(int value = 0);</a>
<a name="410"><span class="lineNum">     410 </span>            : ROSE_DLL_API SgBoolValExp* buildBoolValExp(bool value = 0);</a>
<a name="411"><span class="lineNum">     411 </span>            : ROSE_DLL_API SgBoolValExp* buildBoolValExp_nfi(int value);</a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span>            : ROSE_DLL_API SgCharVal* buildCharVal(char value = 0);</a>
<a name="414"><span class="lineNum">     414 </span>            : ROSE_DLL_API SgCharVal* buildCharVal_nfi(char value, const std::string&amp; str);</a>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<a name="416"><span class="lineNum">     416 </span>            : //! DQ (7/31/2014): Adding support for C++11 nullptr const value expressions.</a>
<a name="417"><span class="lineNum">     417 </span>            : ROSE_DLL_API SgNullptrValExp* buildNullptrValExp();</a>
<a name="418"><span class="lineNum">     418 </span>            : ROSE_DLL_API SgNullptrValExp* buildNullptrValExp_nfi();</a>
<a name="419"><span class="lineNum">     419 </span>            : </a>
<a name="420"><span class="lineNum">     420 </span>            : //! DQ (2/14/2019): Adding support for C++14 void value expressions.</a>
<a name="421"><span class="lineNum">     421 </span>            : ROSE_DLL_API SgVoidVal* buildVoidVal();</a>
<a name="422"><span class="lineNum">     422 </span>            : ROSE_DLL_API SgVoidVal* buildVoidVal_nfi();</a>
<a name="423"><span class="lineNum">     423 </span>            : </a>
<a name="424"><span class="lineNum">     424 </span>            : ROSE_DLL_API SgWcharVal* buildWcharVal(wchar_t value = 0);</a>
<a name="425"><span class="lineNum">     425 </span>            : ROSE_DLL_API SgWcharVal* buildWcharVal_nfi(wchar_t value, const std::string&amp; str);</a>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<a name="427"><span class="lineNum">     427 </span>            : // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).</a>
<a name="428"><span class="lineNum">     428 </span>            : ROSE_DLL_API SgChar16Val* buildChar16Val(unsigned short value = 0);</a>
<a name="429"><span class="lineNum">     429 </span>            : ROSE_DLL_API SgChar16Val* buildChar16Val_nfi(unsigned short value, const std::string&amp; str);</a>
<a name="430"><span class="lineNum">     430 </span>            : ROSE_DLL_API SgChar32Val* buildChar32Val(unsigned int value = 0);</a>
<a name="431"><span class="lineNum">     431 </span>            : ROSE_DLL_API SgChar32Val* buildChar32Val_nfi(unsigned int value, const std::string&amp; str);</a>
<a name="432"><span class="lineNum">     432 </span>            : </a>
<a name="433"><span class="lineNum">     433 </span>            : // DQ (3/20/2017): This function has never existed (inputs must be SgValueExp pointers).</a>
<a name="434"><span class="lineNum">     434 </span>            : // ROSE_DLL_API SgComplexVal* buildComplexVal(long double real_value = 0.0, long double imaginary_value = 0.0 );</a>
<a name="435"><span class="lineNum">     435 </span>            : ROSE_DLL_API SgComplexVal* buildComplexVal(SgValueExp* real_value, SgValueExp* imaginary_value);</a>
<a name="436"><span class="lineNum">     436 </span>            : ROSE_DLL_API SgComplexVal* buildComplexVal_nfi(SgValueExp* real_value, SgValueExp* imaginary_value, const std::string&amp; str);</a>
<a name="437"><span class="lineNum">     437 </span>            : ROSE_DLL_API SgComplexVal* buildImaginaryVal(long double imaginary_value);</a>
<a name="438"><span class="lineNum">     438 </span>            : ROSE_DLL_API SgComplexVal* buildImaginaryVal(SgValueExp* imaginary_value);</a>
<a name="439"><span class="lineNum">     439 </span>            : ROSE_DLL_API SgComplexVal* buildImaginaryVal_nfi(SgValueExp* imaginary_value, const std::string&amp; str);</a>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<a name="441"><span class="lineNum">     441 </span>            : //! Build a double value expression</a>
<a name="442"><span class="lineNum">     442 </span>            : ROSE_DLL_API SgDoubleVal* buildDoubleVal(double value = 0.0);</a>
<a name="443"><span class="lineNum">     443 </span>            : ROSE_DLL_API SgDoubleVal* buildDoubleVal_nfi(double value, const std::string&amp; str);</a>
<a name="444"><span class="lineNum">     444 </span>            : </a>
<a name="445"><span class="lineNum">     445 </span>            : ROSE_DLL_API SgFloatVal* buildFloatVal(float value = 0.0);</a>
<a name="446"><span class="lineNum">     446 </span>            : ROSE_DLL_API SgFloatVal* buildFloatVal_nfi(float value = 0.0);</a>
<a name="447"><span class="lineNum">     447 </span>            : ROSE_DLL_API SgFloatVal* buildFloatVal_nfi(float value, const std::string&amp; str);</a>
<a name="448"><span class="lineNum">     448 </span>            : //! Build a float value expression by converting the string</a>
<a name="449"><span class="lineNum">     449 </span>            : ROSE_DLL_API SgFloatVal* buildFloatVal_nfi(const std::string&amp; str);</a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span>            : //! Build an integer value expression</a>
<a name="452"><span class="lineNum">     452 </span>            : ROSE_DLL_API SgIntVal* buildIntVal(int value = 0);</a>
<a name="453"><span class="lineNum">     453 </span>            : ROSE_DLL_API SgIntVal* buildIntValHex(int value = 0);</a>
<a name="454"><span class="lineNum">     454 </span>            : ROSE_DLL_API SgIntVal* buildIntVal_nfi(int value = 0);</a>
<a name="455"><span class="lineNum">     455 </span>            : ROSE_DLL_API SgIntVal* buildIntVal_nfi(int value, const std::string&amp; str);</a>
<a name="456"><span class="lineNum">     456 </span>            : //! Build an integer value expression by converting the string</a>
<a name="457"><span class="lineNum">     457 </span>            : ROSE_DLL_API SgIntVal* buildIntVal_nfi(const std::string&amp; str);</a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span>            : //! Build a long integer value expression</a>
<a name="460"><span class="lineNum">     460 </span>            : ROSE_DLL_API SgLongIntVal* buildLongIntVal(long value = 0);</a>
<a name="461"><span class="lineNum">     461 </span>            : ROSE_DLL_API SgLongIntVal* buildLongIntValHex(long value = 0);</a>
<a name="462"><span class="lineNum">     462 </span>            : ROSE_DLL_API SgLongIntVal* buildLongIntVal_nfi(long value, const std::string&amp; str);</a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span>            : //! Build a long long integer value expression</a>
<a name="465"><span class="lineNum">     465 </span>            : ROSE_DLL_API SgLongLongIntVal* buildLongLongIntVal(long long value = 0);</a>
<a name="466"><span class="lineNum">     466 </span>            : ROSE_DLL_API SgLongLongIntVal* buildLongLongIntValHex(long long value = 0);</a>
<a name="467"><span class="lineNum">     467 </span>            : ROSE_DLL_API SgLongLongIntVal* buildLongLongIntVal_nfi(long long value, const std::string&amp; str);</a>
<a name="468"><span class="lineNum">     468 </span>            : // !Build enum val without file info: nfi</a>
<a name="469"><span class="lineNum">     469 </span>            : ROSE_DLL_API SgEnumVal* buildEnumVal_nfi(long long int value, SgEnumDeclaration* decl, SgName name);</a>
<a name="470"><span class="lineNum">     470 </span>            : // !Build enum val with transformation file info</a>
<a name="471"><span class="lineNum">     471 </span>            : ROSE_DLL_API SgEnumVal* buildEnumVal(long long int value, SgEnumDeclaration* decl, SgName name);</a>
<a name="472"><span class="lineNum">     472 </span>            : ROSE_DLL_API SgEnumVal* buildEnumVal(SgEnumFieldSymbol * sym);</a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span>            : ROSE_DLL_API SgLongDoubleVal* buildLongDoubleVal(long double value = 0.0);</a>
<a name="475"><span class="lineNum">     475 </span>            : ROSE_DLL_API SgLongDoubleVal* buildLongDoubleVal_nfi(long double value, const std::string&amp; str);</a>
<a name="476"><span class="lineNum">     476 </span>            : </a>
<a name="477"><span class="lineNum">     477 </span>            : ROSE_DLL_API SgFloat80Val* buildFloat80Val(long double value = 0.0);</a>
<a name="478"><span class="lineNum">     478 </span>            : ROSE_DLL_API SgFloat80Val* buildFloat80Val_nfi(long double value, const std::string&amp; str);</a>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<a name="480"><span class="lineNum">     480 </span>            : ROSE_DLL_API SgFloat128Val* buildFloat128Val(long double value = 0.0);</a>
<a name="481"><span class="lineNum">     481 </span>            : ROSE_DLL_API SgFloat128Val* buildFloat128Val_nfi(long double value, const std::string&amp; str);</a>
<a name="482"><span class="lineNum">     482 </span>            : </a>
<a name="483"><span class="lineNum">     483 </span>            : ROSE_DLL_API SgShortVal* buildShortVal(short value = 0);</a>
<a name="484"><span class="lineNum">     484 </span>            : ROSE_DLL_API SgShortVal* buildShortValHex(short value = 0);</a>
<a name="485"><span class="lineNum">     485 </span>            : ROSE_DLL_API SgShortVal* buildShortVal_nfi(short value, const std::string&amp; str);</a>
<a name="486"><span class="lineNum">     486 </span>            : </a>
<a name="487"><span class="lineNum">     487 </span>            : ROSE_DLL_API SgStringVal* buildStringVal(std::string value=&quot;&quot;);</a>
<a name="488"><span class="lineNum">     488 </span>            : ROSE_DLL_API SgStringVal* buildStringVal_nfi(std::string value);</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span>            : //! Build an unsigned char</a>
<a name="491"><span class="lineNum">     491 </span>            : ROSE_DLL_API SgUnsignedCharVal* buildUnsignedCharVal(unsigned char v = 0);</a>
<a name="492"><span class="lineNum">     492 </span>            : ROSE_DLL_API SgUnsignedCharVal* buildUnsignedCharValHex(unsigned char v = 0);</a>
<a name="493"><span class="lineNum">     493 </span>            : ROSE_DLL_API SgUnsignedCharVal* buildUnsignedCharVal_nfi(unsigned char v, const std::string&amp; str);</a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span>            : //! Build an unsigned short integer</a>
<a name="496"><span class="lineNum">     496 </span>            : ROSE_DLL_API SgUnsignedShortVal* buildUnsignedShortVal(unsigned short v = 0);</a>
<a name="497"><span class="lineNum">     497 </span>            : ROSE_DLL_API SgUnsignedShortVal* buildUnsignedShortValHex(unsigned short v = 0);</a>
<a name="498"><span class="lineNum">     498 </span>            : ROSE_DLL_API SgUnsignedShortVal* buildUnsignedShortVal_nfi(unsigned short v, const std::string&amp; str);</a>
<a name="499"><span class="lineNum">     499 </span>            : </a>
<a name="500"><span class="lineNum">     500 </span>            : //! Build an unsigned integer</a>
<a name="501"><span class="lineNum">     501 </span>            : ROSE_DLL_API SgUnsignedIntVal* buildUnsignedIntVal(unsigned int v = 0);</a>
<a name="502"><span class="lineNum">     502 </span>            : ROSE_DLL_API SgUnsignedIntVal* buildUnsignedIntValHex(unsigned int v = 0);</a>
<a name="503"><span class="lineNum">     503 </span>            : ROSE_DLL_API SgUnsignedIntVal* buildUnsignedIntVal_nfi(unsigned int v, const std::string&amp; str);</a>
<a name="504"><span class="lineNum">     504 </span>            : </a>
<a name="505"><span class="lineNum">     505 </span>            : //! Build a unsigned long integer</a>
<a name="506"><span class="lineNum">     506 </span>            : ROSE_DLL_API SgUnsignedLongVal* buildUnsignedLongVal(unsigned long v = 0);</a>
<a name="507"><span class="lineNum">     507 </span>            : ROSE_DLL_API SgUnsignedLongVal* buildUnsignedLongValHex(unsigned long v = 0);</a>
<a name="508"><span class="lineNum">     508 </span>            : ROSE_DLL_API SgUnsignedLongVal* buildUnsignedLongVal_nfi(unsigned long v, const std::string&amp; str);</a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span>            : //! Build an unsigned long long integer</a>
<a name="511"><span class="lineNum">     511 </span>            : ROSE_DLL_API SgUnsignedLongLongIntVal* buildUnsignedLongLongIntVal(unsigned long long v = 0);</a>
<a name="512"><span class="lineNum">     512 </span>            : ROSE_DLL_API SgUnsignedLongLongIntVal* buildUnsignedLongLongIntValHex(unsigned long long v = 0);</a>
<a name="513"><span class="lineNum">     513 </span>            : ROSE_DLL_API SgUnsignedLongLongIntVal* buildUnsignedLongLongIntVal_nfi(unsigned long long v, const std::string&amp; str);</a>
<a name="514"><span class="lineNum">     514 </span>            : </a>
<a name="515"><span class="lineNum">     515 </span>            : //! Build an template parameter value expression</a>
<a name="516"><span class="lineNum">     516 </span>            : ROSE_DLL_API SgTemplateParameterVal* buildTemplateParameterVal(int template_parameter_position = -1);</a>
<a name="517"><span class="lineNum">     517 </span>            : ROSE_DLL_API SgTemplateParameterVal* buildTemplateParameterVal_nfi(int template_parameter_position, const std::string&amp; str);</a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span>            : //! Build a template type, used for template parameter and later argument</a>
<a name="520"><span class="lineNum">     520 </span>            : ROSE_DLL_API SgTemplateType* buildTemplateType(SgName name=&quot;&quot;);</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span>            : //! Build a template parameter, passing enum kind and SgTemplateType</a>
<a name="523"><span class="lineNum">     523 </span>            : //! template_parameter_enum { parameter_undefined = 0, type_parameter = 1, nontype_parameter = 2,  template_parameter = 3}</a>
<a name="524"><span class="lineNum">     524 </span>            : ROSE_DLL_API SgTemplateParameter * buildTemplateParameter (SgTemplateParameter::template_parameter_enum parameterType, SgType*);</a>
<a name="525"><span class="lineNum">     525 </span>            : </a>
<a name="526"><span class="lineNum">     526 </span>            : //! Build a declaration of a non-real class or class-member representing template parameters and their members</a>
<a name="527"><span class="lineNum">     527 </span>            : ROSE_DLL_API SgNonrealDecl * buildNonrealDecl(const SgName &amp; name, SgDeclarationScope * scope, SgDeclarationScope * child_scope = NULL);</a>
<a name="528"><span class="lineNum">     528 </span>            : </a>
<a name="529"><span class="lineNum">     529 </span>            : //! Build a reference to the non-real declaration of a member of a non-real class</a>
<a name="530"><span class="lineNum">     530 </span>            : ROSE_DLL_API SgNonrealRefExp * buildNonrealRefExp_nfi(SgNonrealSymbol * sym);</a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span>            : //! Build UPC THREADS (integer expression)</a>
<a name="533"><span class="lineNum">     533 </span>            : ROSE_DLL_API SgUpcThreads* buildUpcThreads();</a>
<a name="534"><span class="lineNum">     534 </span>            : ROSE_DLL_API SgUpcThreads* buildUpcThreads_nfi();</a>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<a name="536"><span class="lineNum">     536 </span>            : //! Build UPC  MYTHREAD (integer expression)</a>
<a name="537"><span class="lineNum">     537 </span>            : ROSE_DLL_API SgUpcMythread* buildUpcMythread();</a>
<a name="538"><span class="lineNum">     538 </span>            : ROSE_DLL_API SgUpcMythread* buildUpcMythread_nfi();</a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span>            : //! Build this pointer</a>
<a name="541"><span class="lineNum">     541 </span>            : ROSE_DLL_API SgThisExp* buildThisExp(SgSymbol* sym);</a>
<a name="542"><span class="lineNum">     542 </span>            : ROSE_DLL_API SgThisExp* buildThisExp_nfi(SgSymbol* sym);</a>
<a name="543"><span class="lineNum">     543 </span>            : </a>
<a name="544"><span class="lineNum">     544 </span>            : //! Build super pointer</a>
<a name="545"><span class="lineNum">     545 </span>            : ROSE_DLL_API SgSuperExp* buildSuperExp(SgClassSymbol* sym);</a>
<a name="546"><span class="lineNum">     546 </span>            : ROSE_DLL_API SgSuperExp* buildSuperExp_nfi(SgClassSymbol* sym);</a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span>            : //! Build class pointer</a>
<a name="549"><span class="lineNum">     549 </span>            : ROSE_DLL_API SgClassExp* buildClassExp(SgClassSymbol* sym);</a>
<a name="550"><span class="lineNum">     550 </span>            : ROSE_DLL_API SgClassExp* buildClassExp_nfi(SgClassSymbol* sym);</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span>            : //! Build lambda expression</a>
<a name="553"><span class="lineNum">     553 </span>            : ROSE_DLL_API SgLambdaRefExp* buildLambdaRefExp(SgType* return_type, SgFunctionParameterList* params, SgScopeStatement* scope);</a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span>            : #define BUILD_UNARY_PROTO(suffix) \</a>
<a name="556"><span class="lineNum">     556 </span>            : ROSE_DLL_API Sg##suffix * build##suffix(SgExpression* op =NULL); \</a>
<a name="557"><span class="lineNum">     557 </span>            : ROSE_DLL_API Sg##suffix * build##suffix##_nfi(SgExpression* op);</a>
<a name="558"><span class="lineNum">     558 </span>            : </a>
<a name="559"><span class="lineNum">     559 </span>            : BUILD_UNARY_PROTO(AddressOfOp)</a>
<a name="560"><span class="lineNum">     560 </span>            : BUILD_UNARY_PROTO(BitComplementOp)</a>
<a name="561"><span class="lineNum">     561 </span>            : BUILD_UNARY_PROTO(MinusOp)</a>
<a name="562"><span class="lineNum">     562 </span>            : BUILD_UNARY_PROTO(NotOp)</a>
<a name="563"><span class="lineNum">     563 </span>            : BUILD_UNARY_PROTO(PointerDerefExp)</a>
<a name="564"><span class="lineNum">     564 </span>            : BUILD_UNARY_PROTO(UnaryAddOp)</a>
<a name="565"><span class="lineNum">     565 </span>            : BUILD_UNARY_PROTO(MinusMinusOp)</a>
<a name="566"><span class="lineNum">     566 </span>            : BUILD_UNARY_PROTO(PlusPlusOp)</a>
<a name="567"><span class="lineNum">     567 </span>            : BUILD_UNARY_PROTO(RealPartOp)</a>
<a name="568"><span class="lineNum">     568 </span>            : BUILD_UNARY_PROTO(ImagPartOp)</a>
<a name="569"><span class="lineNum">     569 </span>            : BUILD_UNARY_PROTO(ConjugateOp)</a>
<a name="570"><span class="lineNum">     570 </span>            : BUILD_UNARY_PROTO(VarArgStartOneOperandOp)</a>
<a name="571"><span class="lineNum">     571 </span>            : BUILD_UNARY_PROTO(VarArgEndOp)</a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span>            : //Matlab transpose op</a>
<a name="574"><span class="lineNum">     574 </span>            : BUILD_UNARY_PROTO(MatrixTransposeOp)</a>
<a name="575"><span class="lineNum">     575 </span>            : </a>
<a name="576"><span class="lineNum">     576 </span>            : //! Build a type casting expression</a>
<a name="577"><span class="lineNum">     577 </span>            : ROSE_DLL_API SgCastExp * buildCastExp(SgExpression *  operand_i = NULL,</a>
<a name="578"><span class="lineNum">     578 </span>            :                 SgType * expression_type = NULL,</a>
<a name="579"><span class="lineNum">     579 </span>            :                 SgCastExp::cast_type_enum cast_type = SgCastExp::e_C_style_cast);</a>
<a name="580"><span class="lineNum">     580 </span>            : ROSE_DLL_API SgCastExp * buildCastExp_nfi(SgExpression *  operand_i,</a>
<a name="581"><span class="lineNum">     581 </span>            :                 SgType * expression_type,</a>
<a name="582"><span class="lineNum">     582 </span>            :                 SgCastExp::cast_type_enum cast_type);</a>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<a name="584"><span class="lineNum">     584 </span>            : //! Build vararg op expression</a>
<a name="585"><span class="lineNum">     585 </span>            : ROSE_DLL_API SgVarArgOp * buildVarArgOp_nfi(SgExpression *  operand_i, SgType * expression_type);</a>
<a name="586"><span class="lineNum">     586 </span>            : </a>
<a name="587"><span class="lineNum">     587 </span>            : //! Build -- expression, Sgop_mode is a value of either SgUnaryOp::prefix or SgUnaryOp::postfix</a>
<a name="588"><span class="lineNum">     588 </span>            : ROSE_DLL_API SgMinusOp *buildMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="589"><span class="lineNum">     589 </span>            : ROSE_DLL_API SgMinusOp *buildMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="590"><span class="lineNum">     590 </span>            : ROSE_DLL_API SgMinusMinusOp *buildMinusMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="591"><span class="lineNum">     591 </span>            : ROSE_DLL_API SgMinusMinusOp *buildMinusMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            : //! Build ++x or x++ , specify prefix or postfix using either SgUnaryOp::prefix or SgUnaryOp::postfix</a>
<a name="594"><span class="lineNum">     594 </span>            : ROSE_DLL_API SgPlusPlusOp* buildPlusPlusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="595"><span class="lineNum">     595 </span>            : ROSE_DLL_API SgPlusPlusOp* buildPlusPlusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode);</a>
<a name="596"><span class="lineNum">     596 </span>            : </a>
<a name="597"><span class="lineNum">     597 </span>            : //! Build a ThrowOp expression</a>
<a name="598"><span class="lineNum">     598 </span>            : ROSE_DLL_API SgThrowOp* buildThrowOp(SgExpression *, SgThrowOp::e_throw_kind);</a>
<a name="599"><span class="lineNum">     599 </span>            : </a>
<a name="600"><span class="lineNum">     600 </span>            : ROSE_DLL_API SgNewExp * buildNewExp(SgType* type,</a>
<a name="601"><span class="lineNum">     601 </span>            :                        SgExprListExp* exprListExp,</a>
<a name="602"><span class="lineNum">     602 </span>            :                        SgConstructorInitializer* constInit,</a>
<a name="603"><span class="lineNum">     603 </span>            :                        SgExpression* expr,</a>
<a name="604"><span class="lineNum">     604 </span>            :                        short int val,</a>
<a name="605"><span class="lineNum">     605 </span>            :                        SgFunctionDeclaration* funcDecl);</a>
<a name="606"><span class="lineNum">     606 </span>            : </a>
<a name="607"><span class="lineNum">     607 </span>            : ROSE_DLL_API SgDeleteExp* buildDeleteExp(SgExpression* variable,</a>
<a name="608"><span class="lineNum">     608 </span>            :                             short is_array,</a>
<a name="609"><span class="lineNum">     609 </span>            :                             short need_global_specifier,</a>
<a name="610"><span class="lineNum">     610 </span>            :                             SgFunctionDeclaration* deleteOperatorDeclaration);</a>
<a name="611"><span class="lineNum">     611 </span>            : </a>
<a name="612"><span class="lineNum">     612 </span>            : //! DQ (1/25/2013): Added support for typeId operators.</a>
<a name="613"><span class="lineNum">     613 </span>            : ROSE_DLL_API SgTypeIdOp* buildTypeIdOp(SgExpression *operand_expr, SgType *operand_type);</a>
<a name="614"><span class="lineNum">     614 </span>            : </a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span>            : #undef BUILD_UNARY_PROTO</a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span>            : /*! The instantiated functions' prototypes are not shown since they are expanded using macros.</a>
<a name="619"><span class="lineNum">     619 </span>            :  * Doxygen is not smart enough to handle macro expansion.</a>
<a name="620"><span class="lineNum">     620 </span>            :  */</a>
<a name="621"><span class="lineNum">     621 </span>            : </a>
<a name="622"><span class="lineNum">     622 </span>            : #define BUILD_BINARY_PROTO(suffix) \</a>
<a name="623"><span class="lineNum">     623 </span>            : ROSE_DLL_API Sg##suffix * build##suffix(SgExpression* lhs =NULL, SgExpression* rhs =NULL); \</a>
<a name="624"><span class="lineNum">     624 </span>            : ROSE_DLL_API Sg##suffix * build##suffix##_nfi(SgExpression* lhs, SgExpression* rhs);</a>
<a name="625"><span class="lineNum">     625 </span>            : </a>
<a name="626"><span class="lineNum">     626 </span>            : BUILD_BINARY_PROTO(AddOp)</a>
<a name="627"><span class="lineNum">     627 </span>            : BUILD_BINARY_PROTO(AndAssignOp)</a>
<a name="628"><span class="lineNum">     628 </span>            : BUILD_BINARY_PROTO(AndOp)</a>
<a name="629"><span class="lineNum">     629 </span>            : BUILD_BINARY_PROTO(ArrowExp)</a>
<a name="630"><span class="lineNum">     630 </span>            : BUILD_BINARY_PROTO(ArrowStarOp)</a>
<a name="631"><span class="lineNum">     631 </span>            : BUILD_BINARY_PROTO(AssignOp)</a>
<a name="632"><span class="lineNum">     632 </span>            : BUILD_BINARY_PROTO(BitAndOp)</a>
<a name="633"><span class="lineNum">     633 </span>            : BUILD_BINARY_PROTO(BitOrOp)</a>
<a name="634"><span class="lineNum">     634 </span>            : BUILD_BINARY_PROTO(BitXorOp)</a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span>            : BUILD_BINARY_PROTO(CommaOpExp)</a>
<a name="637"><span class="lineNum">     637 </span>            : BUILD_BINARY_PROTO(ConcatenationOp)</a>
<a name="638"><span class="lineNum">     638 </span>            : BUILD_BINARY_PROTO(DivAssignOp)</a>
<a name="639"><span class="lineNum">     639 </span>            : BUILD_BINARY_PROTO(DivideOp)</a>
<a name="640"><span class="lineNum">     640 </span>            : BUILD_BINARY_PROTO(DotExp)</a>
<a name="641"><span class="lineNum">     641 </span>            : BUILD_BINARY_PROTO(DotStarOp)</a>
<a name="642"><span class="lineNum">     642 </span>            : BUILD_BINARY_PROTO(EqualityOp)</a>
<a name="643"><span class="lineNum">     643 </span>            : </a>
<a name="644"><span class="lineNum">     644 </span>            : BUILD_BINARY_PROTO(ExponentiationOp)</a>
<a name="645"><span class="lineNum">     645 </span>            : BUILD_BINARY_PROTO(ExponentiationAssignOp)</a>
<a name="646"><span class="lineNum">     646 </span>            : BUILD_BINARY_PROTO(GreaterOrEqualOp)</a>
<a name="647"><span class="lineNum">     647 </span>            : BUILD_BINARY_PROTO(GreaterThanOp)</a>
<a name="648"><span class="lineNum">     648 </span>            : BUILD_BINARY_PROTO(IntegerDivideOp)</a>
<a name="649"><span class="lineNum">     649 </span>            : BUILD_BINARY_PROTO(IntegerDivideAssignOp)</a>
<a name="650"><span class="lineNum">     650 </span>            : BUILD_BINARY_PROTO(IorAssignOp)</a>
<a name="651"><span class="lineNum">     651 </span>            : BUILD_BINARY_PROTO(IsOp)</a>
<a name="652"><span class="lineNum">     652 </span>            : BUILD_BINARY_PROTO(IsNotOp)</a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span>            : BUILD_BINARY_PROTO(LessOrEqualOp)</a>
<a name="655"><span class="lineNum">     655 </span>            : BUILD_BINARY_PROTO(LessThanOp)</a>
<a name="656"><span class="lineNum">     656 </span>            : BUILD_BINARY_PROTO(LshiftAssignOp)</a>
<a name="657"><span class="lineNum">     657 </span>            : BUILD_BINARY_PROTO(LshiftOp)</a>
<a name="658"><span class="lineNum">     658 </span>            : </a>
<a name="659"><span class="lineNum">     659 </span>            : BUILD_BINARY_PROTO(MembershipOp)</a>
<a name="660"><span class="lineNum">     660 </span>            : BUILD_BINARY_PROTO(MinusAssignOp)</a>
<a name="661"><span class="lineNum">     661 </span>            : BUILD_BINARY_PROTO(ModAssignOp)</a>
<a name="662"><span class="lineNum">     662 </span>            : BUILD_BINARY_PROTO(ModOp)</a>
<a name="663"><span class="lineNum">     663 </span>            : BUILD_BINARY_PROTO(MultAssignOp)</a>
<a name="664"><span class="lineNum">     664 </span>            : BUILD_BINARY_PROTO(MultiplyOp)</a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span>            : BUILD_BINARY_PROTO(NonMembershipOp)</a>
<a name="667"><span class="lineNum">     667 </span>            : BUILD_BINARY_PROTO(NotEqualOp)</a>
<a name="668"><span class="lineNum">     668 </span>            : BUILD_BINARY_PROTO(OrOp)</a>
<a name="669"><span class="lineNum">     669 </span>            : BUILD_BINARY_PROTO(PlusAssignOp)</a>
<a name="670"><span class="lineNum">     670 </span>            : BUILD_BINARY_PROTO(PntrArrRefExp)</a>
<a name="671"><span class="lineNum">     671 </span>            : BUILD_BINARY_PROTO(RshiftAssignOp)</a>
<a name="672"><span class="lineNum">     672 </span>            : </a>
<a name="673"><span class="lineNum">     673 </span>            : BUILD_BINARY_PROTO(RshiftOp)</a>
<a name="674"><span class="lineNum">     674 </span>            : BUILD_BINARY_PROTO(ScopeOp)</a>
<a name="675"><span class="lineNum">     675 </span>            : BUILD_BINARY_PROTO(SubtractOp)</a>
<a name="676"><span class="lineNum">     676 </span>            : BUILD_BINARY_PROTO(XorAssignOp)</a>
<a name="677"><span class="lineNum">     677 </span>            : </a>
<a name="678"><span class="lineNum">     678 </span>            : BUILD_BINARY_PROTO(VarArgCopyOp)</a>
<a name="679"><span class="lineNum">     679 </span>            : BUILD_BINARY_PROTO(VarArgStartOp)</a>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<a name="681"><span class="lineNum">     681 </span>            : BUILD_BINARY_PROTO(PowerOp);</a>
<a name="682"><span class="lineNum">     682 </span>            : BUILD_BINARY_PROTO(ElementwisePowerOp);</a>
<a name="683"><span class="lineNum">     683 </span>            : BUILD_BINARY_PROTO(ElementwiseMultiplyOp);</a>
<a name="684"><span class="lineNum">     684 </span>            : BUILD_BINARY_PROTO(ElementwiseDivideOp);</a>
<a name="685"><span class="lineNum">     685 </span>            : BUILD_BINARY_PROTO(LeftDivideOp);</a>
<a name="686"><span class="lineNum">     686 </span>            : BUILD_BINARY_PROTO(ElementwiseLeftDivideOp);</a>
<a name="687"><span class="lineNum">     687 </span>            : BUILD_BINARY_PROTO(ElementwiseAddOp);</a>
<a name="688"><span class="lineNum">     688 </span>            : BUILD_BINARY_PROTO(ElementwiseSubtractOp);</a>
<a name="689"><span class="lineNum">     689 </span>            : </a>
<a name="690"><span class="lineNum">     690 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="691"><span class="lineNum">     691 </span>            : BUILD_BINARY_PROTO(SpaceshipOp)</a>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<a name="693"><span class="lineNum">     693 </span>            : #undef BUILD_BINARY_PROTO</a>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<a name="695"><span class="lineNum">     695 </span>            : //! Build a conditional expression ?:</a>
<a name="696"><span class="lineNum">     696 </span>            : ROSE_DLL_API SgConditionalExp * buildConditionalExp(SgExpression* test =NULL, SgExpression* a =NULL, SgExpression* b =NULL);</a>
<a name="697"><span class="lineNum">     697 </span>            : SgConditionalExp * buildConditionalExp_nfi(SgExpression* test, SgExpression* a, SgExpression* b, SgType* t);</a>
<a name="698"><span class="lineNum">     698 </span>            : </a>
<a name="699"><span class="lineNum">     699 </span>            : //! Build a SgExprListExp, used for function call parameter list etc.</a>
<a name="700"><span class="lineNum">     700 </span>            : ROSE_DLL_API SgExprListExp * buildExprListExp(SgExpression * expr1 = NULL, SgExpression* expr2 = NULL, SgExpression* expr3 = NULL, SgExpression* expr4 = NULL, SgExpression* expr5 = NULL, SgExpression* expr6 = NULL, SgExpression* expr7 = NULL, SgExpression* expr8 = NULL, SgExpression* expr9 = NULL, SgExpression* expr10 = NULL);</a>
<a name="701"><span class="lineNum">     701 </span>            : ROSE_DLL_API SgExprListExp * buildExprListExp(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="702"><span class="lineNum">     702 </span>            : SgExprListExp * buildExprListExp_nfi();</a>
<a name="703"><span class="lineNum">     703 </span>            : SgExprListExp * buildExprListExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="704"><span class="lineNum">     704 </span>            : </a>
<a name="705"><span class="lineNum">     705 </span>            : //! Build a SgSubscriptExpression, used for array shape expressions.  The lower bound and stride may be nullptrs</a>
<a name="706"><span class="lineNum">     706 </span>            : SgSubscriptExpression * buildSubscriptExpression_nfi(SgExpression* lower_bound, SgExpression* upper_bound, SgExpression* stride);</a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span>            : //! Build a SgTupleExp</a>
<a name="709"><span class="lineNum">     709 </span>            : ROSE_DLL_API SgTupleExp * buildTupleExp(SgExpression * expr1 = NULL, SgExpression* expr2 = NULL, SgExpression* expr3 = NULL, SgExpression* expr4 = NULL, SgExpression* expr5 = NULL, SgExpression* expr6 = NULL, SgExpression* expr7 = NULL, SgExpression* expr8 = NULL, SgExpression* expr9 = NULL, SgExpression* expr10 = NULL);</a>
<a name="710"><span class="lineNum">     710 </span>            : ROSE_DLL_API SgTupleExp * buildTupleExp(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="711"><span class="lineNum">     711 </span>            : SgTupleExp * buildTupleExp_nfi();</a>
<a name="712"><span class="lineNum">     712 </span>            : SgTupleExp * buildTupleExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="713"><span class="lineNum">     713 </span>            : </a>
<a name="714"><span class="lineNum">     714 </span>            : //! Build a SgListExp</a>
<a name="715"><span class="lineNum">     715 </span>            : ROSE_DLL_API SgListExp * buildListExp(SgExpression * expr1 = NULL, SgExpression* expr2 = NULL, SgExpression* expr3 = NULL, SgExpression* expr4 = NULL, SgExpression* expr5 = NULL, SgExpression* expr6 = NULL, SgExpression* expr7 = NULL, SgExpression* expr8 = NULL, SgExpression* expr9 = NULL, SgExpression* expr10 = NULL);</a>
<a name="716"><span class="lineNum">     716 </span>            : ROSE_DLL_API SgListExp * buildListExp(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="717"><span class="lineNum">     717 </span>            : SgListExp * buildListExp_nfi();</a>
<a name="718"><span class="lineNum">     718 </span>            : SgListExp * buildListExp_nfi(const std::vector&lt;SgExpression*&gt;&amp; exprs);</a>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<a name="720"><span class="lineNum">     720 </span>            : ROSE_DLL_API SgComprehension * buildComprehension(SgExpression *target, SgExpression *iter, SgExprListExp *ifs);</a>
<a name="721"><span class="lineNum">     721 </span>            : SgComprehension * buildComprehension_nfi(SgExpression *target, SgExpression *iter, SgExprListExp *ifs);</a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span>            : ROSE_DLL_API SgListComprehension * buildListComprehension(SgExpression *elt, SgExprListExp *generators);</a>
<a name="724"><span class="lineNum">     724 </span>            : SgListComprehension * buildListComprehension_nfi(SgExpression *elt, SgExprListExp *generators);</a>
<a name="725"><span class="lineNum">     725 </span>            : </a>
<a name="726"><span class="lineNum">     726 </span>            : ROSE_DLL_API SgSetComprehension * buildSetComprehension(SgExpression *elt, SgExprListExp *generators);</a>
<a name="727"><span class="lineNum">     727 </span>            : SgSetComprehension * buildSetComprehension_nfi(SgExpression *elt, SgExprListExp *generators);</a>
<a name="728"><span class="lineNum">     728 </span>            : </a>
<a name="729"><span class="lineNum">     729 </span>            : ROSE_DLL_API SgDictionaryComprehension * buildDictionaryComprehension(SgKeyDatumPair *kd_pair, SgExprListExp *generators);</a>
<a name="730"><span class="lineNum">     730 </span>            : SgDictionaryComprehension * buildDictionaryComprehension_nfi(SgKeyDatumPair *kd_pair, SgExprListExp *generators);</a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span>            : //! Build SgVarRefExp based on a variable's Sage name. It will lookup the name in the symbol table internally starting from scope. A variable name is unique so type can be inferred (double check this).</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            : /*!</a>
<a name="735"><span class="lineNum">     735 </span>            : It is possible to build a reference to a variable with known name before the variable is declared, especially during bottomup construction of AST. In this case, SgTypeUnknown is used to indicate the variable reference needing postprocessing fix using fixVariableReferences() once the AST is complete and all variable declarations exist. But the side effect is that some get_type() operations may not recognize the unknown type before the fix. So far, I extended SgPointerDerefExp::get_type() and SgPntrArrRefExp::get_type() for SgTypeUnknown. There may be others needing the same extension.</a>
<a name="736"><span class="lineNum">     736 </span>            : */</a>
<a name="737"><span class="lineNum">     737 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="738"><span class="lineNum">     738 </span>            : </a>
<a name="739"><span class="lineNum">     739 </span>            : //! Build SgVarRefExp based on a variable's name. It will lookup symbol table internally starting from scope. A variable is unique so type can be inferred.</a>
<a name="740"><span class="lineNum">     740 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(const std::string&amp; varName, SgScopeStatement* scope=NULL);</a>
<a name="741"><span class="lineNum">     741 </span>            : </a>
<a name="742"><span class="lineNum">     742 </span>            : //! Build a variable reference using a C style char array</a>
<a name="743"><span class="lineNum">     743 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(const char* varName, SgScopeStatement* scope=NULL);</a>
<a name="744"><span class="lineNum">     744 </span>            : </a>
<a name="745"><span class="lineNum">     745 </span>            : //! Build a variable reference from an existing symbol</a>
<a name="746"><span class="lineNum">     746 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(SgVariableSymbol* varSymbol);</a>
<a name="747"><span class="lineNum">     747 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp_nfi(SgVariableSymbol* varSymbol);</a>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<a name="749"><span class="lineNum">     749 </span>            : //! Build a variable reference from an existing variable declaration. The assumption is a SgVariableDeclartion only declares one variable in the ROSE AST.</a>
<a name="750"><span class="lineNum">     750 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(SgVariableDeclaration* vardecl);</a>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<a name="752"><span class="lineNum">     752 </span>            : //!Build a variable reference from an initialized name</a>
<a name="753"><span class="lineNum">     753 </span>            : //!It first tries to grab the associated symbol, then call buildVarRefExp(const SgName&amp; name, SgScopeStatement*) if symbol does not exist.</a>
<a name="754"><span class="lineNum">     754 </span>            : ROSE_DLL_API SgVarRefExp * buildVarRefExp(SgInitializedName* initname, SgScopeStatement* scope=NULL);</a>
<a name="755"><span class="lineNum">     755 </span>            : </a>
<a name="756"><span class="lineNum">     756 </span>            : //!Build a variable reference expression at scope to an opaque variable which has unknown information except for its name.  Used when referring to an internal variable defined in some headers of runtime libraries.(The headers are not yet inserted into the file during translation). Similar to buildOpaqueType();</a>
<a name="757"><span class="lineNum">     757 </span>            : /*! It will declare a hidden int varName  at the specified scope to cheat the AST consistence tests.</a>
<a name="758"><span class="lineNum">     758 </span>            :  */</a>
<a name="759"><span class="lineNum">     759 </span>            : ROSE_DLL_API SgVarRefExp* buildOpaqueVarRefExp(const std::string&amp; varName,SgScopeStatement* scope=NULL);</a>
<a name="760"><span class="lineNum">     760 </span>            : </a>
<a name="761"><span class="lineNum">     761 </span>            : // DQ (9/4/2013): Added support for building compound literals (similar to a SgVarRefExp).</a>
<a name="762"><span class="lineNum">     762 </span>            : //! Build function for compound literals (uses a SgVariableSymbol and is similar to buildVarRefExp_nfi()).</a>
<a name="763"><span class="lineNum">     763 </span>            : SgCompoundLiteralExp* buildCompoundLiteralExp_nfi(SgVariableSymbol* varSymbol);</a>
<a name="764"><span class="lineNum">     764 </span>            : SgCompoundLiteralExp* buildCompoundLiteralExp(SgVariableSymbol* varSymbol);</a>
<a name="765"><span class="lineNum">     765 </span>            : </a>
<a name="766"><span class="lineNum">     766 </span>            : //! Build a Fortran numeric label ref exp</a>
<a name="767"><span class="lineNum">     767 </span>            : ROSE_DLL_API SgLabelRefExp * buildLabelRefExp(SgLabelSymbol * s);</a>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<a name="769"><span class="lineNum">     769 </span>            : //! Build SgFunctionRefExp based on a C++ function's name and function type. It will lookup symbol table internally starting from scope. A hidden prototype will be created internally to introduce a new function symbol if the function symbol cannot be found.</a>
<a name="770"><span class="lineNum">     770 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(const SgName&amp; name, const SgType* func_type, SgScopeStatement* scope=NULL);</a>
<a name="771"><span class="lineNum">     771 </span>            : </a>
<a name="772"><span class="lineNum">     772 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(const char* name, const SgType* func_type, SgScopeStatement* scope=NULL);</a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span>            : //! Build SgFunctionRefExp based on a C function's name. It will lookup symbol table internally starting from scope and return the first matching function.</a>
<a name="775"><span class="lineNum">     775 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(const SgName&amp; name,SgScopeStatement* scope=NULL);</a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(const char* name,SgScopeStatement* scope=NULL);</a>
<a name="778"><span class="lineNum">     778 </span>            : </a>
<a name="779"><span class="lineNum">     779 </span>            : //! Build SgFunctionRefExp based on a function's declaration.</a>
<a name="780"><span class="lineNum">     780 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(const SgFunctionDeclaration* func_decl);</a>
<a name="781"><span class="lineNum">     781 </span>            : </a>
<a name="782"><span class="lineNum">     782 </span>            : //! Build SgFunctionRefExp based on a function's symbol.</a>
<a name="783"><span class="lineNum">     783 </span>            : ROSE_DLL_API SgFunctionRefExp * buildFunctionRefExp(SgFunctionSymbol* sym);</a>
<a name="784"><span class="lineNum">     784 </span>            : </a>
<a name="785"><span class="lineNum">     785 </span>            : SgFunctionRefExp * buildFunctionRefExp_nfi(SgFunctionSymbol* sym);</a>
<a name="786"><span class="lineNum">     786 </span>            : </a>
<a name="787"><span class="lineNum">     787 </span>            : //! DQ (12/15/2011): Adding template declaration support to the AST.</a>
<a name="788"><span class="lineNum">     788 </span>            : SgTemplateFunctionRefExp* buildTemplateFunctionRefExp_nfi(SgTemplateFunctionSymbol* sym);</a>
<a name="789"><span class="lineNum">     789 </span>            : </a>
<a name="790"><span class="lineNum">     790 </span>            : //! DQ (12/29/2011): Adding template declaration support to the AST.</a>
<a name="791"><span class="lineNum">     791 </span>            : SgTemplateMemberFunctionRefExp* buildTemplateMemberFunctionRefExp_nfi(SgTemplateMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier);</a>
<a name="792"><span class="lineNum">     792 </span>            : </a>
<a name="793"><span class="lineNum">     793 </span>            : SgMemberFunctionRefExp * buildMemberFunctionRefExp_nfi(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier);</a>
<a name="794"><span class="lineNum">     794 </span>            : ROSE_DLL_API SgMemberFunctionRefExp * buildMemberFunctionRefExp(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier);</a>
<a name="795"><span class="lineNum">     795 </span>            : SgClassNameRefExp * buildClassNameRefExp_nfi(SgClassSymbol* sym);</a>
<a name="796"><span class="lineNum">     796 </span>            : ROSE_DLL_API SgClassNameRefExp * buildClassNameRefExp(SgClassSymbol* sym);</a>
<a name="797"><span class="lineNum">     797 </span>            : </a>
<a name="798"><span class="lineNum">     798 </span>            : //! Build a function call expression</a>
<a name="799"><span class="lineNum">     799 </span>            : ROSE_DLL_API SgFunctionCallExp* buildFunctionCallExp(SgFunctionSymbol* sym, SgExprListExp* parameters=NULL);</a>
<a name="800"><span class="lineNum">     800 </span>            : SgFunctionCallExp* buildFunctionCallExp_nfi(SgExpression* f, SgExprListExp* parameters=NULL);</a>
<a name="801"><span class="lineNum">     801 </span>            : ROSE_DLL_API SgFunctionCallExp* buildFunctionCallExp(SgExpression* f, SgExprListExp* parameters=NULL);</a>
<a name="802"><span class="lineNum">     802 </span>            : </a>
<a name="803"><span class="lineNum">     803 </span>            : //! Build a function call expression,it will automatically search for function symbols internally to build a right function reference etc. It tolerates the lack of the function symbol to support generating calls to library functions whose headers have not yet been inserted.</a>
<a name="804"><span class="lineNum">     804 </span>            : ROSE_DLL_API SgFunctionCallExp*</a>
<a name="805"><span class="lineNum">     805 </span>            : buildFunctionCallExp(const SgName&amp; name, SgType* return_type, SgExprListExp* parameters=NULL, SgScopeStatement* scope=NULL);</a>
<a name="806"><span class="lineNum">     806 </span>            : </a>
<a name="807"><span class="lineNum">     807 </span>            : </a>
<a name="808"><span class="lineNum">     808 </span>            : //! Build member function calls</a>
<a name="809"><span class="lineNum">     809 </span>            : /*!</a>
<a name="810"><span class="lineNum">     810 </span>            :  *Create a member function call</a>
<a name="811"><span class="lineNum">     811 </span>            :  *  This function looks for the function symbol in the given className</a>
<a name="812"><span class="lineNum">     812 </span>            :  *  The function should exist in the class</a>
<a name="813"><span class="lineNum">     813 </span>            :  *  The class should be #included or present in the source file parsed by frontend</a>
<a name="814"><span class="lineNum">     814 </span>            :  *</a>
<a name="815"><span class="lineNum">     815 </span>            :  * Parameters:</a>
<a name="816"><span class="lineNum">     816 </span>            :  *  className: template class name, e.g. vector</a>
<a name="817"><span class="lineNum">     817 </span>            :  *  objectExpression: the variable reference expression to an object of template class instantiation:  vector&lt;int&gt; var1;</a>
<a name="818"><span class="lineNum">     818 </span>            :  *  functionName: member function name: size</a>
<a name="819"><span class="lineNum">     819 </span>            :  *  params: function parameter list</a>
<a name="820"><span class="lineNum">     820 </span>            :  *  scope: the scope this function call expression will be inserted into.</a>
<a name="821"><span class="lineNum">     821 </span>            :  * Credit to Peter's previous work at:</a>
<a name="822"><span class="lineNum">     822 </span>            :  * projects/MatlabTranslation/src/transformations/MatlabSimpleTransformer.cc</a>
<a name="823"><span class="lineNum">     823 </span>            :  */</a>
<a name="824"><span class="lineNum">     824 </span>            : ROSE_DLL_API SgFunctionCallExp*</a>
<a name="825"><span class="lineNum">     825 </span>            : buildMemberFunctionCall (std::string className, SgExpression *objectExpression, std::string functionName, SgExprListExp *params, SgScopeStatement *scope);</a>
<a name="826"><span class="lineNum">     826 </span>            : </a>
<a name="827"><span class="lineNum">     827 </span>            : //! Build member function calls. objectExpression: the variable reference expression to an object of template class instantiation:  vector&lt;int&gt; var1;</a>
<a name="828"><span class="lineNum">     828 </span>            : ROSE_DLL_API SgFunctionCallExp* buildMemberFunctionCall (SgExpression*     objectExpression, SgMemberFunctionSymbol* functionSymbol,</a>
<a name="829"><span class="lineNum">     829 </span>            :                                           SgExprListExp*    params);</a>
<a name="830"><span class="lineNum">     830 </span>            : </a>
<a name="831"><span class="lineNum">     831 </span>            : SgTypeTraitBuiltinOperator*</a>
<a name="832"><span class="lineNum">     832 </span>            : buildTypeTraitBuiltinOperator(SgName functionName, SgNodePtrList parameters);</a>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<a name="834"><span class="lineNum">     834 </span>            : //! Build a CUDA kernel call expression (kernel&lt;&lt;&lt;config&gt;&gt;&gt;(parameters))</a>
<a name="835"><span class="lineNum">     835 </span>            : SgCudaKernelCallExp * buildCudaKernelCallExp_nfi(</a>
<a name="836"><span class="lineNum">     836 </span>            :   SgExpression * kernel,</a>
<a name="837"><span class="lineNum">     837 </span>            :   SgExprListExp* parameters = NULL,</a>
<a name="838"><span class="lineNum">     838 </span>            :   SgCudaKernelExecConfig * config = NULL</a>
<a name="839"><span class="lineNum">     839 </span>            : );</a>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<a name="841"><span class="lineNum">     841 </span>            : //! Build a CUDA kernel execution configuration (&lt;&lt;&lt;grid, blocks, shared, stream&gt;&gt;&gt;)</a>
<a name="842"><span class="lineNum">     842 </span>            : SgCudaKernelExecConfig * buildCudaKernelExecConfig_nfi(</a>
<a name="843"><span class="lineNum">     843 </span>            :   SgExpression *grid = NULL,</a>
<a name="844"><span class="lineNum">     844 </span>            :   SgExpression *blocks = NULL,</a>
<a name="845"><span class="lineNum">     845 </span>            :   SgExpression *shared = NULL,</a>
<a name="846"><span class="lineNum">     846 </span>            :   SgExpression *stream = NULL</a>
<a name="847"><span class="lineNum">     847 </span>            : );</a>
<a name="848"><span class="lineNum">     848 </span>            : </a>
<a name="849"><span class="lineNum">     849 </span>            : //! Build the rhs of a variable declaration which includes an assignment</a>
<a name="850"><span class="lineNum">     850 </span>            : ROSE_DLL_API SgAssignInitializer * buildAssignInitializer(SgExpression * operand_i = NULL, SgType * expression_type = NULL);</a>
<a name="851"><span class="lineNum">     851 </span>            : ROSE_DLL_API SgAssignInitializer * buildAssignInitializer_nfi(SgExpression * operand_i = NULL, SgType * expression_type = NULL);</a>
<a name="852"><span class="lineNum">     852 </span>            : </a>
<a name="853"><span class="lineNum">     853 </span>            : //! Build an aggregate initializer</a>
<a name="854"><span class="lineNum">     854 </span>            : ROSE_DLL_API SgAggregateInitializer * buildAggregateInitializer(SgExprListExp * initializers = NULL, SgType * type = NULL);</a>
<a name="855"><span class="lineNum">     855 </span>            : ROSE_DLL_API SgAggregateInitializer * buildAggregateInitializer_nfi(SgExprListExp * initializers, SgType * type = NULL);</a>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<a name="857"><span class="lineNum">     857 </span>            : //! Build a compound initializer, for vector type initialization</a>
<a name="858"><span class="lineNum">     858 </span>            : ROSE_DLL_API SgCompoundInitializer * buildCompoundInitializer(SgExprListExp * initializers = NULL, SgType * type = NULL);</a>
<a name="859"><span class="lineNum">     859 </span>            : ROSE_DLL_API SgCompoundInitializer * buildCompoundInitializer_nfi(SgExprListExp * initializers, SgType * type = NULL);</a>
<a name="860"><span class="lineNum">     860 </span>            : </a>
<a name="861"><span class="lineNum">     861 </span>            : // DQ (!/4/2009): Added support for building SgConstructorInitializer</a>
<a name="862"><span class="lineNum">     862 </span>            : ROSE_DLL_API SgConstructorInitializer * buildConstructorInitializer( SgMemberFunctionDeclaration *declaration,SgExprListExp *args,SgType *expression_type,bool need_name,bool need_qualifier,bool need_parenthesis_after_name,bool associated_class_unknown);</a>
<a name="863"><span class="lineNum">     863 </span>            : ROSE_DLL_API SgConstructorInitializer * buildConstructorInitializer_nfi( SgMemberFunctionDeclaration *declaration,SgExprListExp *args,SgType *expression_type,bool need_name,bool need_qualifier,bool need_parenthesis_after_name,bool associated_class_unknown);</a>
<a name="864"><span class="lineNum">     864 </span>            : </a>
<a name="865"><span class="lineNum">     865 </span>            : //! Build an braced initializer</a>
<a name="866"><span class="lineNum">     866 </span>            : ROSE_DLL_API SgBracedInitializer * buildBracedInitializer(SgExprListExp * initializers = NULL, SgType * expression_type = NULL);</a>
<a name="867"><span class="lineNum">     867 </span>            : ROSE_DLL_API SgBracedInitializer * buildBracedInitializer_nfi(SgExprListExp * initializers = NULL, SgType * expression_type = NULL);</a>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<a name="869"><span class="lineNum">     869 </span>            : //! Build sizeof() expression with an expression parameter</a>
<a name="870"><span class="lineNum">     870 </span>            : ROSE_DLL_API SgSizeOfOp* buildSizeOfOp(SgExpression* exp = NULL);</a>
<a name="871"><span class="lineNum">     871 </span>            : ROSE_DLL_API SgSizeOfOp* buildSizeOfOp_nfi(SgExpression* exp);</a>
<a name="872"><span class="lineNum">     872 </span>            : </a>
<a name="873"><span class="lineNum">     873 </span>            : //! Build sizeof() expression with a type parameter</a>
<a name="874"><span class="lineNum">     874 </span>            : ROSE_DLL_API SgSizeOfOp* buildSizeOfOp(SgType* type = NULL);</a>
<a name="875"><span class="lineNum">     875 </span>            : ROSE_DLL_API SgSizeOfOp* buildSizeOfOp_nfi(SgType* type);</a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span>            : //! Build __alignof__() expression with an expression parameter</a>
<a name="878"><span class="lineNum">     878 </span>            : ROSE_DLL_API SgAlignOfOp* buildAlignOfOp(SgExpression* exp = NULL);</a>
<a name="879"><span class="lineNum">     879 </span>            : ROSE_DLL_API SgAlignOfOp* buildAlignOfOp_nfi(SgExpression* exp);</a>
<a name="880"><span class="lineNum">     880 </span>            : </a>
<a name="881"><span class="lineNum">     881 </span>            : //! Build __alignof__() expression with a type parameter</a>
<a name="882"><span class="lineNum">     882 </span>            : ROSE_DLL_API SgAlignOfOp* buildAlignOfOp(SgType* type = NULL);</a>
<a name="883"><span class="lineNum">     883 </span>            : ROSE_DLL_API SgAlignOfOp* buildAlignOfOp_nfi(SgType* type);</a>
<a name="884"><span class="lineNum">     884 </span>            : </a>
<a name="885"><span class="lineNum">     885 </span>            : //! Build noexcept operator expression with an expression parameter</a>
<a name="886"><span class="lineNum">     886 </span>            : ROSE_DLL_API SgNoexceptOp* buildNoexceptOp(SgExpression* exp = NULL);</a>
<a name="887"><span class="lineNum">     887 </span>            : ROSE_DLL_API SgNoexceptOp* buildNoexceptOp_nfi(SgExpression* exp);</a>
<a name="888"><span class="lineNum">     888 </span>            : </a>
<a name="889"><span class="lineNum">     889 </span>            : //! DQ (7/24/2014): Adding support for c11 generic operands.</a>
<a name="890"><span class="lineNum">     890 </span>            : ROSE_DLL_API SgTypeExpression *buildTypeExpression(SgType* type);</a>
<a name="891"><span class="lineNum">     891 </span>            : </a>
<a name="892"><span class="lineNum">     892 </span>            : // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.</a>
<a name="893"><span class="lineNum">     893 </span>            : ROSE_DLL_API SgFunctionParameterRefExp *buildFunctionParameterRefExp(int parameter_number, int parameter_level );</a>
<a name="894"><span class="lineNum">     894 </span>            : ROSE_DLL_API SgFunctionParameterRefExp *buildFunctionParameterRefExp_nfi(int parameter_number, int parameter_level );</a>
<a name="895"><span class="lineNum">     895 </span>            : </a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span>            : //! DQ (9/3/2014): Adding support for C++11 Lambda expressions</a>
<a name="898"><span class="lineNum">     898 </span>            : ROSE_DLL_API SgLambdaExp* buildLambdaExp    (SgLambdaCaptureList* lambda_capture_list, SgClassDeclaration* lambda_closure_class, SgFunctionDeclaration* lambda_function);</a>
<a name="899"><span class="lineNum">     899 </span>            : ROSE_DLL_API SgLambdaExp* buildLambdaExp_nfi(SgLambdaCaptureList* lambda_capture_list, SgClassDeclaration* lambda_closure_class, SgFunctionDeclaration* lambda_function);</a>
<a name="900"><span class="lineNum">     900 </span>            : </a>
<a name="901"><span class="lineNum">     901 </span>            : #if 0</a>
<a name="902"><span class="lineNum">     902 </span>            : ROSE_DLL_API SgLambdaCapture* buildLambdaCapture    (SgInitializedName* capture_variable, SgInitializedName* source_closure_variable, SgInitializedName* closure_variable);</a>
<a name="903"><span class="lineNum">     903 </span>            : ROSE_DLL_API SgLambdaCapture* buildLambdaCapture_nfi(SgInitializedName* capture_variable, SgInitializedName* source_closure_variable, SgInitializedName* closure_variable);</a>
<a name="904"><span class="lineNum">     904 </span>            : #else</a>
<a name="905"><span class="lineNum">     905 </span>            : ROSE_DLL_API SgLambdaCapture* buildLambdaCapture    (SgExpression* capture_variable, SgExpression* source_closure_variable, SgExpression* closure_variable);</a>
<a name="906"><span class="lineNum">     906 </span>            : ROSE_DLL_API SgLambdaCapture* buildLambdaCapture_nfi(SgExpression* capture_variable, SgExpression* source_closure_variable, SgExpression* closure_variable);</a>
<a name="907"><span class="lineNum">     907 </span>            : #endif</a>
<a name="908"><span class="lineNum">     908 </span>            : </a>
<a name="909"><span class="lineNum">     909 </span>            : ROSE_DLL_API SgLambdaCaptureList* buildLambdaCaptureList    ();</a>
<a name="910"><span class="lineNum">     910 </span>            : ROSE_DLL_API SgLambdaCaptureList* buildLambdaCaptureList_nfi();</a>
<a name="911"><span class="lineNum">     911 </span>            : </a>
<a name="912"><span class="lineNum">     912 </span>            : // DQ (7/25/2020): Adding C++17 support</a>
<a name="913"><span class="lineNum">     913 </span>            :  ROSE_DLL_API SgFoldExpression * buildFoldExpression(SgExpression* operands, std::string operator_token_string, bool is_left_associative);</a>
<a name="914"><span class="lineNum">     914 </span>            : ROSE_DLL_API SgFoldExpression * buildFoldExpression_nfi(SgExpression* operands, std::string operator_token_string, bool is_left_associative);</a>
<a name="915"><span class="lineNum">     915 </span>            : </a>
<a name="916"><span class="lineNum">     916 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="917"><span class="lineNum">     917 </span>            : ROSE_DLL_API SgAwaitExpression * buildAwaitExpression();</a>
<a name="918"><span class="lineNum">     918 </span>            : ROSE_DLL_API SgAwaitExpression * buildAwaitExpression_nfi();</a>
<a name="919"><span class="lineNum">     919 </span>            : </a>
<a name="920"><span class="lineNum">     920 </span>            : // DQ (7/25/2020): Adding C++20 support</a>
<a name="921"><span class="lineNum">     921 </span>            : ROSE_DLL_API SgChooseExpression * buildChooseExpression();</a>
<a name="922"><span class="lineNum">     922 </span>            : ROSE_DLL_API SgChooseExpression * buildChooseExpression_nfi();</a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            : </a>
<a name="925"><span class="lineNum">     925 </span>            : //@}</a>
<a name="926"><span class="lineNum">     926 </span>            : </a>
<a name="927"><span class="lineNum">     927 </span>            : //@{</a>
<a name="928"><span class="lineNum">     928 </span>            : /*! @name Builders for Matlab nodes</a>
<a name="929"><span class="lineNum">     929 </span>            :  */</a>
<a name="930"><span class="lineNum">     930 </span>            : //! Build a Matlab range expression like start:end or start:stride:end</a>
<a name="931"><span class="lineNum">     931 </span>            :  ROSE_DLL_API SgRangeExp* buildRangeExp(SgExpression *start);</a>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<a name="933"><span class="lineNum">     933 </span>            : </a>
<a name="934"><span class="lineNum">     934 </span>            :  //! Build a Matlab Matrix</a>
<a name="935"><span class="lineNum">     935 </span>            :  ROSE_DLL_API SgMatrixExp* buildMatrixExp(SgExprListExp *firstRow);</a>
<a name="936"><span class="lineNum">     936 </span>            : </a>
<a name="937"><span class="lineNum">     937 </span>            :  //! Build a Matlab colon expression :</a>
<a name="938"><span class="lineNum">     938 </span>            :  ROSE_DLL_API SgMagicColonExp* buildMagicColonExp();</a>
<a name="939"><span class="lineNum">     939 </span>            : </a>
<a name="940"><span class="lineNum">     940 </span>            : //@}</a>
<a name="941"><span class="lineNum">     941 </span>            : </a>
<a name="942"><span class="lineNum">     942 </span>            : //@{</a>
<a name="943"><span class="lineNum">     943 </span>            : /*! @name Builders for Ada nodes</a>
<a name="944"><span class="lineNum">     944 </span>            :  */</a>
<a name="945"><span class="lineNum">     945 </span>            : </a>
<a name="946"><span class="lineNum">     946 </span>            : // ! Build a range expression using start:end:stride for Ada</a>
<a name="947"><span class="lineNum">     947 </span>            :  ROSE_DLL_API SgRangeExp* buildRangeExp(SgExpression *start, SgExpression *end, SgExpression *stride);</a>
<a name="948"><span class="lineNum">     948 </span>            : </a>
<a name="949"><span class="lineNum">     949 </span>            : //@}</a>
<a name="950"><span class="lineNum">     950 </span>            : //</a>
<a name="951"><span class="lineNum">     951 </span>            : //--------------------------------------------------------------</a>
<a name="952"><span class="lineNum">     952 </span>            : //@{</a>
<a name="953"><span class="lineNum">     953 </span>            : /*! @name Builders for support nodes</a>
<a name="954"><span class="lineNum">     954 </span>            :   \brief AST high level builders for SgSupport nodes</a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span>            : */</a>
<a name="957"><span class="lineNum">     957 </span>            : //! Initialized names are tricky, their scope vary depending on context, so scope and symbol information are not needed until the initialized name is being actually used somewhere.</a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            : /*!e.g the scope of arguments of functions are different for defining and nondefining functions.</a>
<a name="960"><span class="lineNum">     960 </span>            : */</a>
<a name="961"><span class="lineNum">     961 </span>            : ROSE_DLL_API SgInitializedName* buildInitializedName(const SgName &amp; name, SgType* type, SgInitializer* init = NULL);</a>
<a name="962"><span class="lineNum">     962 </span>            : ROSE_DLL_API SgInitializedName* buildInitializedName(const std::string &amp;name, SgType* type);</a>
<a name="963"><span class="lineNum">     963 </span>            : ROSE_DLL_API SgInitializedName* buildInitializedName(const char* name, SgType* type);</a>
<a name="964"><span class="lineNum">     964 </span>            : ROSE_DLL_API SgInitializedName* buildInitializedName_nfi(const SgName &amp; name, SgType* type, SgInitializer* init);</a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span>            : //! Build SgFunctionParameterTypeList from SgFunctionParameterList</a>
<a name="967"><span class="lineNum">     967 </span>            : ROSE_DLL_API SgFunctionParameterTypeList *</a>
<a name="968"><span class="lineNum">     968 </span>            : buildFunctionParameterTypeList(SgFunctionParameterList * paralist);</a>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<a name="970"><span class="lineNum">     970 </span>            : //! Build SgFunctionParameterTypeList from an expression list, useful when building a function call</a>
<a name="971"><span class="lineNum">     971 </span>            : ROSE_DLL_API SgFunctionParameterTypeList *</a>
<a name="972"><span class="lineNum">     972 </span>            : buildFunctionParameterTypeList(SgExprListExp * expList);</a>
<a name="973"><span class="lineNum">     973 </span>            : </a>
<a name="974"><span class="lineNum">     974 </span>            : //! Build an SgFunctionParameterTypeList from SgTypes. To build an</a>
<a name="975"><span class="lineNum">     975 </span>            : ROSE_DLL_API SgFunctionParameterTypeList *</a>
<a name="976"><span class="lineNum">     976 </span>            : buildFunctionParameterTypeList(SgType* type0 = NULL, SgType* type1 = NULL,</a>
<a name="977"><span class="lineNum">     977 </span>            :                                SgType* type2 = NULL, SgType* type3 = NULL,</a>
<a name="978"><span class="lineNum">     978 </span>            :                                SgType* type4 = NULL, SgType* type5 = NULL,</a>
<a name="979"><span class="lineNum">     979 </span>            :                                SgType* type6 = NULL, SgType* type7 = NULL);</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            : </a>
<a name="982"><span class="lineNum">     982 </span>            : //--------------------------------------------------------------</a>
<a name="983"><span class="lineNum">     983 </span>            : //@{</a>
<a name="984"><span class="lineNum">     984 </span>            : /*! @name Builders for statements</a>
<a name="985"><span class="lineNum">     985 </span>            :   \brief AST high level builders for SgStatement, explicit scope parameters are allowed for flexibility.</a>
<a name="986"><span class="lineNum">     986 </span>            :   Please use SageInterface::appendStatement(), prependStatement(), and insertStatement() to attach the newly built statements into an AST tree. Calling member functions like SgScopeStatement::prepend_statement() or using container functions such as pushback() is discouraged since they don't handle many side effects for symbol tables, source file information, scope and parent pointers etc.</a>
<a name="987"><span class="lineNum">     987 </span>            : </a>
<a name="988"><span class="lineNum">     988 </span>            : */</a>
<a name="989"><span class="lineNum">     989 </span>            : </a>
<a name="990"><span class="lineNum">     990 </span>            : //! Build a variable declaration, handle symbol table transparently</a>
<a name="991"><span class="lineNum">     991 </span>            : ROSE_DLL_API SgVariableDeclaration*</a>
<a name="992"><span class="lineNum">     992 </span>            : buildVariableDeclaration(const SgName &amp; name, SgType *type, SgInitializer *varInit=NULL, SgScopeStatement* scope=NULL);</a>
<a name="993"><span class="lineNum">     993 </span>            : </a>
<a name="994"><span class="lineNum">     994 </span>            : ROSE_DLL_API SgVariableDeclaration*</a>
<a name="995"><span class="lineNum">     995 </span>            : buildVariableDeclaration(const std::string &amp; name, SgType *type, SgInitializer *varInit=NULL, SgScopeStatement* scope=NULL);</a>
<a name="996"><span class="lineNum">     996 </span>            : </a>
<a name="997"><span class="lineNum">     997 </span>            : ROSE_DLL_API SgVariableDeclaration*</a>
<a name="998"><span class="lineNum">     998 </span>            : buildVariableDeclaration(const char* name, SgType *type, SgInitializer *varInit=NULL, SgScopeStatement* scope=NULL);</a>
<a name="999"><span class="lineNum">     999 </span>            : </a>
<a name="1000"><span class="lineNum">    1000 </span>            : // DQ (6/25/2019): Added support to force building the varialbe declaration from the variable use (e.g. within a class)</a>
<a name="1001"><span class="lineNum">    1001 </span>            : // instead of from a declaration.  Variable declaration built from a use are reused when the declaration is seen (later</a>
<a name="1002"><span class="lineNum">    1002 </span>            : // in processing of the class members).</a>
<a name="1003"><span class="lineNum">    1003 </span>            : // ROSE_DLL_API SgVariableDeclaration*</a>
<a name="1004"><span class="lineNum">    1004 </span>            : // buildVariableDeclaration_nfi(const SgName &amp; name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope);</a>
<a name="1005"><span class="lineNum">    1005 </span>            : ROSE_DLL_API SgVariableDeclaration*</a>
<a name="1006"><span class="lineNum">    1006 </span>            : buildVariableDeclaration_nfi(const SgName &amp; name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope, bool builtFromUseOnly = false, SgStorageModifier::storage_modifier_enum sm = SgStorageModifier::e_default);</a>
<a name="1007"><span class="lineNum">    1007 </span>            : </a>
<a name="1008"><span class="lineNum">    1008 </span>            : //! Build variable definition</a>
<a name="1009"><span class="lineNum">    1009 </span>            : ROSE_DLL_API SgVariableDefinition*</a>
<a name="1010"><span class="lineNum">    1010 </span>            : buildVariableDefinition_nfi (SgVariableDeclaration* decl, SgInitializedName* init_name,  SgInitializer *init);</a>
<a name="1011"><span class="lineNum">    1011 </span>            : </a>
<a name="1012"><span class="lineNum">    1012 </span>            : </a>
<a name="1013"><span class="lineNum">    1013 </span>            : // DQ (8/31/2012): Note that this macro can't be used in header files since it can only be set</a>
<a name="1014"><span class="lineNum">    1014 </span>            : // after sage3.h has been read.  The reason is that this is a portability problem when &quot;rose_config.h&quot;</a>
<a name="1015"><span class="lineNum">    1015 </span>            : // appears in header files of applications using ROSE's header files.</a>
<a name="1016"><span class="lineNum">    1016 </span>            : // DQ (12/6/2011): Adding support for template declarations into the AST.</a>
<a name="1017"><span class="lineNum">    1017 </span>            : // SgTemplateDeclaration*</a>
<a name="1018"><span class="lineNum">    1018 </span>            : ROSE_DLL_API SgTemplateVariableDeclaration* buildTemplateVariableDeclaration_nfi(const SgName &amp; name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope);</a>
<a name="1019"><span class="lineNum">    1019 </span>            : </a>
<a name="1020"><span class="lineNum">    1020 </span>            : //! Build template variable declarations</a>
<a name="1021"><span class="lineNum">    1021 </span>            : ROSE_DLL_API SgTemplateVariableDeclaration* buildTemplateVariableDeclaration(const SgName &amp; name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope);</a>
<a name="1022"><span class="lineNum">    1022 </span>            : </a>
<a name="1023"><span class="lineNum">    1023 </span>            : //!Build a typedef declaration, such as: typedef int myint;  typedef struct A {..} s_A;</a>
<a name="1024"><span class="lineNum">    1024 </span>            : ROSE_DLL_API SgTypedefDeclaration*</a>
<a name="1025"><span class="lineNum">    1025 </span>            : buildTypedefDeclaration(const std::string&amp; name, SgType* base_type, SgScopeStatement* scope = NULL, bool has_defining_base=false);</a>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<a name="1027"><span class="lineNum">    1027 </span>            : ROSE_DLL_API SgTypedefDeclaration*</a>
<a name="1028"><span class="lineNum">    1028 </span>            : buildTypedefDeclaration_nfi(const std::string&amp; name, SgType* base_type, SgScopeStatement* scope = NULL, bool has_defining_base=false);</a>
<a name="1029"><span class="lineNum">    1029 </span>            : </a>
<a name="1030"><span class="lineNum">    1030 </span>            : ROSE_DLL_API SgTemplateTypedefDeclaration*</a>
<a name="1031"><span class="lineNum">    1031 </span>            : buildTemplateTypedefDeclaration_nfi(const SgName &amp; name, SgType* base_type, SgScopeStatement* scope = NULL, bool has_defining_base=false);</a>
<a name="1032"><span class="lineNum">    1032 </span>            : </a>
<a name="1033"><span class="lineNum">    1033 </span>            : #if 1</a>
<a name="1034"><span class="lineNum">    1034 </span>            : // ROSE_DLL_API SgTemplateInstantiationTypedefDeclaration*</a>
<a name="1035"><span class="lineNum">    1035 </span>            : // buildTemplateInstantiationTypedefDeclaration_nfi(SgName name, SgType* base_type, SgScopeStatement* scope, bool has_defining_base, SgTemplateTypedefDeclaration* templateTypedefDeclaration, SgTemplateArgumentPtrList templateArgumentList);</a>
<a name="1036"><span class="lineNum">    1036 </span>            : // ROSE_DLL_API SgTemplateInstantiationTypedefDeclaration*</a>
<a name="1037"><span class="lineNum">    1037 </span>            : // buildTemplateInstantiationTypedefDeclaration_nfi(SgName name, SgType* base_type, SgScopeStatement* scope, bool has_defining_base, SgTemplateTypedefDeclaration* templateTypedefDeclaration);</a>
<a name="1038"><span class="lineNum">    1038 </span>            : // ROSE_DLL_API SgTemplateInstantiationTypedefDeclaration*</a>
<a name="1039"><span class="lineNum">    1039 </span>            : // buildTemplateInstantiationTypedefDeclaration_nfi();</a>
<a name="1040"><span class="lineNum">    1040 </span>            : ROSE_DLL_API SgTemplateInstantiationTypedefDeclaration*</a>
<a name="1041"><span class="lineNum">    1041 </span>            : buildTemplateInstantiationTypedefDeclaration_nfi(SgName &amp; name, SgType* base_type, SgScopeStatement* scope, bool has_defining_base, SgTemplateTypedefDeclaration* templateTypedefDeclaration, SgTemplateArgumentPtrList &amp; templateArgumentsList);</a>
<a name="1042"><span class="lineNum">    1042 </span>            : #endif</a>
<a name="1043"><span class="lineNum">    1043 </span>            : </a>
<a name="1044"><span class="lineNum">    1044 </span>            : //! Build an empty SgFunctionParameterList, possibly with some initialized names filled in</a>
<a name="1045"><span class="lineNum">    1045 </span>            : ROSE_DLL_API SgFunctionParameterList * buildFunctionParameterList(SgInitializedName* in1 = NULL, SgInitializedName* in2 = NULL, SgInitializedName* in3 = NULL, SgInitializedName* in4 = NULL, SgInitializedName* in5 = NULL, SgInitializedName* in6 = NULL, SgInitializedName* in7 = NULL, SgInitializedName* in8 = NULL, SgInitializedName* in9 = NULL, SgInitializedName* in10 = NULL);</a>
<a name="1046"><span class="lineNum">    1046 </span>            : SgFunctionParameterList * buildFunctionParameterList_nfi();</a>
<a name="1047"><span class="lineNum">    1047 </span>            : </a>
<a name="1048"><span class="lineNum">    1048 </span>            : //! Build an SgFunctionParameterList from SgFunctionParameterTypeList, like (int, float,...), used for parameter list of prototype functions when function type( including parameter type list) is known.</a>
<a name="1049"><span class="lineNum">    1049 </span>            : ROSE_DLL_API SgFunctionParameterList*</a>
<a name="1050"><span class="lineNum">    1050 </span>            : buildFunctionParameterList(SgFunctionParameterTypeList * paraTypeList);</a>
<a name="1051"><span class="lineNum">    1051 </span>            : </a>
<a name="1052"><span class="lineNum">    1052 </span>            : ROSE_DLL_API SgFunctionParameterList*</a>
<a name="1053"><span class="lineNum">    1053 </span>            : buildFunctionParameterList_nfi(SgFunctionParameterTypeList * paraTypeList);</a>
<a name="1054"><span class="lineNum">    1054 </span>            : </a>
<a name="1055"><span class="lineNum">    1055 </span>            : SgCtorInitializerList * buildCtorInitializerList_nfi();</a>
<a name="1056"><span class="lineNum">    1056 </span>            : //! DQ (2/11/2012): Added support to set the template name in function template instantiations (member and non-member).</a>
<a name="1057"><span class="lineNum">    1057 </span>            : ROSE_DLL_API void setTemplateNameInTemplateInstantiations( SgFunctionDeclaration* func, const SgName &amp; name );</a>
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<a name="1059"><span class="lineNum">    1059 </span>            : // DQ (9/13/2012): Need to set the parents of SgTemplateArgument IR nodes now that they are passed in as part of the SageBuilder API.</a>
<a name="1060"><span class="lineNum">    1060 </span>            : ROSE_DLL_API void setTemplateArgumentParents( SgDeclarationStatement* decl );</a>
<a name="1061"><span class="lineNum">    1061 </span>            : ROSE_DLL_API void testTemplateArgumentParents( SgDeclarationStatement* decl );</a>
<a name="1062"><span class="lineNum">    1062 </span>            : ROSE_DLL_API SgTemplateArgumentPtrList* getTemplateArgumentList( SgDeclarationStatement* decl );</a>
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<a name="1064"><span class="lineNum">    1064 </span>            : //! DQ (9/16/2012): Added function to support setting the template parameters and setting their parents (and for any relevant declaration).</a>
<a name="1065"><span class="lineNum">    1065 </span>            : ROSE_DLL_API void testTemplateParameterParents( SgDeclarationStatement* decl );</a>
<a name="1066"><span class="lineNum">    1066 </span>            : ROSE_DLL_API void setTemplateParameterParents( SgDeclarationStatement* decl );</a>
<a name="1067"><span class="lineNum">    1067 </span>            : ROSE_DLL_API SgTemplateParameterPtrList* getTemplateParameterList( SgDeclarationStatement* decl );</a>
<a name="1068"><span class="lineNum">    1068 </span>            : </a>
<a name="1069"><span class="lineNum">    1069 </span>            : //! DQ (9/16/2012): Added function to support setting the template arguments and setting their parents (and for any relevant declaration).</a>
<a name="1070"><span class="lineNum">    1070 </span>            : ROSE_DLL_API void setTemplateArgumentsInDeclaration               ( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateArgumentsList_input );</a>
<a name="1071"><span class="lineNum">    1071 </span>            : ROSE_DLL_API void setTemplateSpecializationArgumentsInDeclaration ( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateSpecializationArgumentsList_input );</a>
<a name="1072"><span class="lineNum">    1072 </span>            : ROSE_DLL_API void setTemplateParametersInDeclaration              ( SgDeclarationStatement* decl, SgTemplateParameterPtrList* templateParametersList_input );</a>
<a name="1073"><span class="lineNum">    1073 </span>            : </a>
<a name="1074"><span class="lineNum">    1074 </span>            : //! Build a prototype for a function, handle function type, symbol etc transparently</a>
<a name="1075"><span class="lineNum">    1075 </span>            : // DQ (7/26/2012): Changing the API to include template arguments so that we can generate names with and without template arguments (to support name mangiling).</a>
<a name="1076"><span class="lineNum">    1076 </span>            : ROSE_DLL_API SgFunctionDeclaration * buildNondefiningFunctionDeclaration(</a>
<a name="1077"><span class="lineNum">    1077 </span>            :   const SgName &amp; name,</a>
<a name="1078"><span class="lineNum">    1078 </span>            :   SgType * return_type,</a>
<a name="1079"><span class="lineNum">    1079 </span>            :   SgFunctionParameterList *parlist,</a>
<a name="1080"><span class="lineNum">    1080 </span>            :   SgScopeStatement* scope = NULL,</a>
<a name="1081"><span class="lineNum">    1081 </span>            :   SgExprListExp* decoratorList = NULL,</a>
<a name="1082"><span class="lineNum">    1082 </span>            :   bool buildTemplateInstantiation = false,</a>
<a name="1083"><span class="lineNum">    1083 </span>            :   SgTemplateArgumentPtrList * templateArgumentsList = NULL,</a>
<a name="1084"><span class="lineNum">    1084 </span>            :   SgStorageModifier::storage_modifier_enum sm = SgStorageModifier::e_default</a>
<a name="1085"><span class="lineNum">    1085 </span>            : );</a>
<a name="1086"><span class="lineNum">    1086 </span>            : </a>
<a name="1087"><span class="lineNum">    1087 </span>            : //! Build a prototype for an existing function declaration (defining or nondefining is fine)</a>
<a name="1088"><span class="lineNum">    1088 </span>            : ROSE_DLL_API SgFunctionDeclaration * buildNondefiningFunctionDeclaration(</a>
<a name="1089"><span class="lineNum">    1089 </span>            :   const SgFunctionDeclaration * funcdecl,</a>
<a name="1090"><span class="lineNum">    1090 </span>            :   SgScopeStatement * scope = NULL,</a>
<a name="1091"><span class="lineNum">    1091 </span>            :   SgExprListExp * decoratorList = NULL</a>
<a name="1092"><span class="lineNum">    1092 </span>            : );</a>
<a name="1093"><span class="lineNum">    1093 </span>            : </a>
<a name="1094"><span class="lineNum">    1094 </span>            : // DQ (8/11/2013): Even though template functions can't use partial specialization, they can be specialized,</a>
<a name="1095"><span class="lineNum">    1095 </span>            : // however the specialization does not define a template and instead defines a template instantiation, so we</a>
<a name="1096"><span class="lineNum">    1096 </span>            : // don't need the SgTemplateArgumentPtrList in this function.</a>
<a name="1097"><span class="lineNum">    1097 </span>            : // SgTemplateFunctionDeclaration* buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL);</a>
<a name="1098"><span class="lineNum">    1098 </span>            : ROSE_DLL_API SgTemplateFunctionDeclaration*</a>
<a name="1099"><span class="lineNum">    1099 </span>            : buildNondefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, SgTemplateParameterPtrList* templateParameterList = NULL);</a>
<a name="1100"><span class="lineNum">    1100 </span>            : </a>
<a name="1101"><span class="lineNum">    1101 </span>            : // DQ (8/11/2013): Note that access to the SgTemplateParameterPtrList should be handled through the first_nondefining_declaration (which is a required parameter).</a>
<a name="1102"><span class="lineNum">    1102 </span>            : // DQ (12/1/2011): Adding support for template declarations into the AST.</a>
<a name="1103"><span class="lineNum">    1103 </span>            : ROSE_DLL_API SgTemplateFunctionDeclaration*</a>
<a name="1104"><span class="lineNum">    1104 </span>            : buildDefiningTemplateFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateFunctionDeclaration* first_nondefining_declaration);</a>
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<a name="1106"><span class="lineNum">    1106 </span>            : // DQ (11/8/2020): Define a function to build a default constructor for a class.</a>
<a name="1107"><span class="lineNum">    1107 </span>            : // ROSE_DLL_API SgMemberFunctionDeclaration* buildConstructor ( const SgName &amp; typeName, SgClassType* initializedName_classType, SgClassDefinition* classDefinition);</a>
<a name="1108"><span class="lineNum">    1108 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration* buildDefaultConstructor ( SgClassType* classType );</a>
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<a name="1110"><span class="lineNum">    1110 </span>            : //! Build a prototype member function declaration</a>
<a name="1111"><span class="lineNum">    1111 </span>            : // SgMemberFunctionDeclaration * buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL);</a>
<a name="1112"><span class="lineNum">    1112 </span>            : // SgMemberFunctionDeclaration * buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, unsigned int functionConstVolatileFlags = 0);</a>
<a name="1113"><span class="lineNum">    1113 </span>            : // SgMemberFunctionDeclaration* buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, unsigned int functionConstVolatileFlags = 0, bool buildTemplateInstantiation = false);</a>
<a name="1114"><span class="lineNum">    1114 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration*</a>
<a name="1115"><span class="lineNum">    1115 </span>            : buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="1116"><span class="lineNum">    1116 </span>            : </a>
<a name="1117"><span class="lineNum">    1117 </span>            : // DQ (8/12/2013): This function needs to supporte SgTemplateParameterPtrList and SgTemplateArgumentPtrList parameters.</a>
<a name="1118"><span class="lineNum">    1118 </span>            : // SgTemplateMemberFunctionDeclaration* buildNondefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope = NULL, SgExprListExp* decoratorList = NULL, unsigned int functionConstVolatileFlags = 0);</a>
<a name="1119"><span class="lineNum">    1119 </span>            : ROSE_DLL_API SgTemplateMemberFunctionDeclaration*</a>
<a name="1120"><span class="lineNum">    1120 </span>            : buildNondefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateParameterPtrList* templateParameterList );</a>
<a name="1121"><span class="lineNum">    1121 </span>            : </a>
<a name="1122"><span class="lineNum">    1122 </span>            : // DQ (12/1/2011): Adding support for template declarations in the AST.</a>
<a name="1123"><span class="lineNum">    1123 </span>            : ROSE_DLL_API SgTemplateMemberFunctionDeclaration*</a>
<a name="1124"><span class="lineNum">    1124 </span>            : buildDefiningTemplateMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateMemberFunctionDeclaration* first_nondefing_declaration );</a>
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<a name="1126"><span class="lineNum">    1126 </span>            : ////! Build a prototype member function declaration</a>
<a name="1127"><span class="lineNum">    1127 </span>            : // SgMemberFunctionDeclaration* buildNondefiningMemberFunctionDeclaration (const SgName &amp; name, SgMemberFunctionType* func_type, SgFunctionParameterList* paralist, SgScopeStatement* scope=NULL);</a>
<a name="1128"><span class="lineNum">    1128 </span>            : </a>
<a name="1129"><span class="lineNum">    1129 </span>            : // DQ (8/11/2013): Note that the specification of the SgTemplateArgumentPtrList is somewhat redundant with the required parameter first_nondefinng_declaration (I think).</a>
<a name="1130"><span class="lineNum">    1130 </span>            : //! Build a defining ( non-prototype) member function declaration</a>
<a name="1131"><span class="lineNum">    1131 </span>            : // SgMemberFunctionDeclaration* buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefinng_declaration);</a>
<a name="1132"><span class="lineNum">    1132 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration*</a>
<a name="1133"><span class="lineNum">    1133 </span>            : buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList *parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefinng_declaration, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="1134"><span class="lineNum">    1134 </span>            : </a>
<a name="1135"><span class="lineNum">    1135 </span>            : #if 0</a>
<a name="1136"><span class="lineNum">    1136 </span>            : // DQ (3/20/2017): This function is not used (so let's see if we can remove it).</a>
<a name="1137"><span class="lineNum">    1137 </span>            : // DQ (8/29/2012): This is re-enabled because the backstroke project is using it (also added back the default parameters; which I don't think I like in the API).</a>
<a name="1138"><span class="lineNum">    1138 </span>            : // DQ (7/26/2012): I would like to remove this from the API (at least for now while debugging the newer API required for template argument handling).</a>
<a name="1139"><span class="lineNum">    1139 </span>            : //! Build a defining ( non-prototype) member function declaration from a SgMemberFunctionType</a>
<a name="1140"><span class="lineNum">    1140 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration*</a>
<a name="1141"><span class="lineNum">    1141 </span>            : buildDefiningMemberFunctionDeclaration (const SgName &amp; name, SgMemberFunctionType* func_type, SgScopeStatement* scope, SgExprListExp* decoratorList = NULL /* , unsigned int functionConstVolatileFlags = 0 */, SgMemberFunctionDeclaration* first_nondefinng_declaration = NULL);</a>
<a name="1142"><span class="lineNum">    1142 </span>            : #endif</a>
<a name="1143"><span class="lineNum">    1143 </span>            : </a>
<a name="1144"><span class="lineNum">    1144 </span>            : #if 0</a>
<a name="1145"><span class="lineNum">    1145 </span>            : // DQ (3/20/2017): This function is not used (so let's see if we can remove it).</a>
<a name="1146"><span class="lineNum">    1146 </span>            : //! Build a prototype for an existing member function declaration (defining or nondefining is fine)</a>
<a name="1147"><span class="lineNum">    1147 </span>            : // SgMemberFunctionDeclaration*</a>
<a name="1148"><span class="lineNum">    1148 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration*</a>
<a name="1149"><span class="lineNum">    1149 </span>            : buildNondefiningMemberFunctionDeclaration (const SgMemberFunctionDeclaration* funcdecl, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL, unsigned int functionConstVolatileFlags = 0);</a>
<a name="1150"><span class="lineNum">    1150 </span>            : #endif</a>
<a name="1151"><span class="lineNum">    1151 </span>            : </a>
<a name="1152"><span class="lineNum">    1152 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).</a>
<a name="1153"><span class="lineNum">    1153 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="1154"><span class="lineNum">    1154 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration* buildNondefiningMemberFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list, SgScopeStatement* scope = NULL);</a>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<a name="1156"><span class="lineNum">    1156 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).</a>
<a name="1157"><span class="lineNum">    1157 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="1158"><span class="lineNum">    1158 </span>            : ROSE_DLL_API SgMemberFunctionDeclaration* buildDefiningMemberFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list, SgScopeStatement* scope = NULL);</a>
<a name="1159"><span class="lineNum">    1159 </span>            : </a>
<a name="1160"><span class="lineNum">    1160 </span>            : // DQ (8/11/2013): Note that the specification of the SgTemplateArgumentPtrList is somewhat redundant with the required parameter first_nondefinng_declaration (I think).</a>
<a name="1161"><span class="lineNum">    1161 </span>            : //! Build a function declaration with a function body</a>
<a name="1162"><span class="lineNum">    1162 </span>            : // SgFunctionDeclaration* buildDefiningFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgFunctionDeclaration* first_nondefinng_declaration);</a>
<a name="1163"><span class="lineNum">    1163 </span>            : ROSE_DLL_API SgFunctionDeclaration*</a>
<a name="1164"><span class="lineNum">    1164 </span>            : buildDefiningFunctionDeclaration (const SgName &amp; name, SgType* return_type, SgFunctionParameterList * parlist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation = false, SgFunctionDeclaration* first_nondefinng_declaration = NULL, SgTemplateArgumentPtrList* templateArgumentsList = NULL);</a>
<a name="1165"><span class="lineNum">    1165 </span>            : </a>
<a name="1166"><span class="lineNum">    1166 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficient).</a>
<a name="1167"><span class="lineNum">    1167 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="1168"><span class="lineNum">    1168 </span>            : ROSE_DLL_API SgFunctionDeclaration* buildDefiningFunctionDeclaration(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list, SgScopeStatement* scope = NULL);</a>
<a name="1169"><span class="lineNum">    1169 </span>            : </a>
<a name="1170"><span class="lineNum">    1170 </span>            : // DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficient).</a>
<a name="1171"><span class="lineNum">    1171 </span>            : // We need to decide if the SageBuilder API should include these sorts of functions.</a>
<a name="1172"><span class="lineNum">    1172 </span>            : ROSE_DLL_API SgProcedureHeaderStatement* buildProcedureHeaderStatement(const SgName&amp; name, SgType* return_type, SgFunctionParameterList* parameter_list, SgProcedureHeaderStatement::subprogram_kind_enum, SgScopeStatement* scope = NULL);</a>
<a name="1173"><span class="lineNum">    1173 </span>            : </a>
<a name="1174"><span class="lineNum">    1174 </span>            : //! Build a Fortran subroutine or procedure</a>
<a name="1175"><span class="lineNum">    1175 </span>            : ROSE_DLL_API SgProcedureHeaderStatement*</a>
<a name="1176"><span class="lineNum">    1176 </span>            : buildProcedureHeaderStatement(const char* name, SgType* return_type, SgFunctionParameterList * parlist, SgProcedureHeaderStatement::subprogram_kind_enum, SgScopeStatement* scope, SgProcedureHeaderStatement* first_nondefining_declaration );</a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            : // CR (9/24/2020)</a>
<a name="1179"><span class="lineNum">    1179 </span>            : //! Build a nondefining SgProcedureHeaderStatement, handle function type, symbol etc transparently</a>
<a name="1180"><span class="lineNum">    1180 </span>            : ROSE_DLL_API SgProcedureHeaderStatement*</a>
<a name="1181"><span class="lineNum">    1181 </span>            : buildNondefiningProcedureHeaderStatement(const SgName &amp; name, SgType* return_type, SgFunctionParameterList* param_list,</a>
<a name="1182"><span class="lineNum">    1182 </span>            :                                          SgProcedureHeaderStatement::subprogram_kind_enum, SgScopeStatement* scope=NULL);</a>
<a name="1183"><span class="lineNum">    1183 </span>            : </a>
<a name="1184"><span class="lineNum">    1184 </span>            : //! Build a regular function call statement</a>
<a name="1185"><span class="lineNum">    1185 </span>            : ROSE_DLL_API SgExprStatement*</a>
<a name="1186"><span class="lineNum">    1186 </span>            : buildFunctionCallStmt(const SgName&amp; name, SgType* return_type, SgExprListExp* parameters=NULL, SgScopeStatement* scope=NULL);</a>
<a name="1187"><span class="lineNum">    1187 </span>            : </a>
<a name="1188"><span class="lineNum">    1188 </span>            : //! Build a function call statement using function expression and argument list only, like (*funcPtr)(args);</a>
<a name="1189"><span class="lineNum">    1189 </span>            : ROSE_DLL_API SgExprStatement*</a>
<a name="1190"><span class="lineNum">    1190 </span>            : buildFunctionCallStmt(SgExpression* function, SgExprListExp* parameters=NULL);</a>
<a name="1191"><span class="lineNum">    1191 </span>            : </a>
<a name="1192"><span class="lineNum">    1192 </span>            : </a>
<a name="1193"><span class="lineNum">    1193 </span>            : //! Build a label statement, name is the label's name. Handling label symbol and scope internally.</a>
<a name="1194"><span class="lineNum">    1194 </span>            : </a>
<a name="1195"><span class="lineNum">    1195 </span>            : //! Note that the scope of a label statement is special. It is SgFunctionDefinition,</a>
<a name="1196"><span class="lineNum">    1196 </span>            : //! not the closest scope statement such as SgBasicBlock.</a>
<a name="1197"><span class="lineNum">    1197 </span>            : ROSE_DLL_API SgLabelStatement * buildLabelStatement(const SgName&amp; name, SgStatement * stmt = NULL, SgScopeStatement* scope=NULL);</a>
<a name="1198"><span class="lineNum">    1198 </span>            : SgLabelStatement * buildLabelStatement_nfi(const SgName&amp; name, SgStatement * stmt, SgScopeStatement* scope);</a>
<a name="1199"><span class="lineNum">    1199 </span>            : </a>
<a name="1200"><span class="lineNum">    1200 </span>            : //! Build a goto statement</a>
<a name="1201"><span class="lineNum">    1201 </span>            : ROSE_DLL_API SgGotoStatement * buildGotoStatement(SgLabelStatement *  label=NULL);</a>
<a name="1202"><span class="lineNum">    1202 </span>            : SgGotoStatement * buildGotoStatement_nfi(SgLabelStatement *  label);</a>
<a name="1203"><span class="lineNum">    1203 </span>            : </a>
<a name="1204"><span class="lineNum">    1204 </span>            : //! Build a goto statement from a label symbol, supporting both C/C++ and Fortran cases</a>
<a name="1205"><span class="lineNum">    1205 </span>            : ROSE_DLL_API SgGotoStatement * buildGotoStatement(SgLabelSymbol*  symbol);</a>
<a name="1206"><span class="lineNum">    1206 </span>            : </a>
<a name="1207"><span class="lineNum">    1207 </span>            : // DQ (11/22/2017): Added support for computed code goto as defined by GNU C/C++ extension.</a>
<a name="1208"><span class="lineNum">    1208 </span>            : //! Build a goto statement from a label expression, supporting only C/C++ and not Fortran cases</a>
<a name="1209"><span class="lineNum">    1209 </span>            : SgGotoStatement * buildGotoStatement_nfi(SgExpression*  expr);</a>
<a name="1210"><span class="lineNum">    1210 </span>            : </a>
<a name="1211"><span class="lineNum">    1211 </span>            : //! Build a case option statement</a>
<a name="1212"><span class="lineNum">    1212 </span>            : ROSE_DLL_API SgCaseOptionStmt * buildCaseOptionStmt( SgExpression * key = NULL,SgStatement *body = NULL);</a>
<a name="1213"><span class="lineNum">    1213 </span>            : SgCaseOptionStmt * buildCaseOptionStmt_nfi( SgExpression * key,SgStatement *body);</a>
<a name="1214"><span class="lineNum">    1214 </span>            : </a>
<a name="1215"><span class="lineNum">    1215 </span>            : //! Build a default option statement</a>
<a name="1216"><span class="lineNum">    1216 </span>            : ROSE_DLL_API SgDefaultOptionStmt * buildDefaultOptionStmt( SgStatement *body = NULL);</a>
<a name="1217"><span class="lineNum">    1217 </span>            : SgDefaultOptionStmt * buildDefaultOptionStmt_nfi( SgStatement *body);</a>
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<a name="1219"><span class="lineNum">    1219 </span>            : //! Build a SgExprStatement, set File_Info automatically</a>
<a name="1220"><span class="lineNum">    1220 </span>            : ROSE_DLL_API SgExprStatement* buildExprStatement(SgExpression*  exp = NULL);</a>
<a name="1221"><span class="lineNum">    1221 </span>            : SgExprStatement* buildExprStatement_nfi(SgExpression*  exp);</a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span>            : // DQ (3/27/2015): Added support for SgStatementExpression.</a>
<a name="1224"><span class="lineNum">    1224 </span>            : //! Build a GNU statement expression</a>
<a name="1225"><span class="lineNum">    1225 </span>            : ROSE_DLL_API SgStatementExpression* buildStatementExpression(SgStatement* exp);</a>
<a name="1226"><span class="lineNum">    1226 </span>            : ROSE_DLL_API SgStatementExpression* buildStatementExpression_nfi(SgStatement* exp);</a>
<a name="1227"><span class="lineNum">    1227 </span>            : </a>
<a name="1228"><span class="lineNum">    1228 </span>            : //! Build a switch statement</a>
<a name="1229"><span class="lineNum">    1229 </span>            : ROSE_DLL_API SgSwitchStatement* buildSwitchStatement(SgStatement *item_selector = NULL,SgStatement *body = NULL);</a>
<a name="1230"><span class="lineNum">    1230 </span>            : inline SgSwitchStatement* buildSwitchStatement(SgExpression *item_selector, SgStatement *body = NULL) {</a>
<a name="1231"><span class="lineNum">    1231 </span>            :   return buildSwitchStatement(buildExprStatement(item_selector), body);</a>
<a name="1232"><span class="lineNum">    1232 </span>            : }</a>
<a name="1233"><span class="lineNum">    1233 </span>            : ROSE_DLL_API SgSwitchStatement* buildSwitchStatement_nfi(SgStatement *item_selector,SgStatement *body);</a>
<a name="1234"><span class="lineNum">    1234 </span>            : </a>
<a name="1235"><span class="lineNum">    1235 </span>            : //! Build if statement</a>
<a name="1236"><span class="lineNum">    1236 </span>            : ROSE_DLL_API SgIfStmt * buildIfStmt(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body);</a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineNoCov">          0 : inline SgIfStmt * buildIfStmt(SgExpression* conditional, SgStatement * true_body, SgStatement * false_body) {</span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   return buildIfStmt(buildExprStatement(conditional), true_body, false_body);</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            : }</a>
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<a name="1241"><span class="lineNum">    1241 </span>            : ROSE_DLL_API SgIfStmt* buildIfStmt_nfi(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body);</a>
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<a name="1243"><span class="lineNum">    1243 </span>            : // CR (9/3/2018)</a>
<a name="1244"><span class="lineNum">    1244 </span>            : //! Build a Fortran do construct</a>
<a name="1245"><span class="lineNum">    1245 </span>            : ROSE_DLL_API SgFortranDo * buildFortranDo(SgExpression* initialization, SgExpression* bound, SgExpression* increment, SgBasicBlock* loop_body);</a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span>            : //! Build a for init statement</a>
<a name="1248"><span class="lineNum">    1248 </span>            : ROSE_DLL_API SgForInitStatement* buildForInitStatement();</a>
<a name="1249"><span class="lineNum">    1249 </span>            : ROSE_DLL_API SgForInitStatement* buildForInitStatement(const SgStatementPtrList &amp; statements);</a>
<a name="1250"><span class="lineNum">    1250 </span>            : ROSE_DLL_API SgForInitStatement* buildForInitStatement_nfi(SgStatementPtrList &amp; statements);</a>
<a name="1251"><span class="lineNum">    1251 </span>            : </a>
<a name="1252"><span class="lineNum">    1252 </span>            : // DQ (10/12/2012): Added new function for a single statement.</a>
<a name="1253"><span class="lineNum">    1253 </span>            : ROSE_DLL_API SgForInitStatement* buildForInitStatement( SgStatement* statement );</a>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<a name="1255"><span class="lineNum">    1255 </span>            : //!Build a for statement, assume none of the arguments is NULL</a>
<a name="1256"><span class="lineNum">    1256 </span>            : ROSE_DLL_API SgForStatement * buildForStatement(SgStatement* initialize_stmt,  SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body = NULL);</a>
<a name="1257"><span class="lineNum">    1257 </span>            : ROSE_DLL_API SgForStatement * buildForStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body = NULL);</a>
<a name="1258"><span class="lineNum">    1258 </span>            : ROSE_DLL_API SgForStatement * buildForStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body = NULL);</a>
<a name="1259"><span class="lineNum">    1259 </span>            : ROSE_DLL_API void buildForStatement_nfi(SgForStatement* result, SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body = NULL);</a>
<a name="1260"><span class="lineNum">    1260 </span>            : </a>
<a name="1261"><span class="lineNum">    1261 </span>            : // DQ (3/26/2018): Adding support for range based for statement.</a>
<a name="1262"><span class="lineNum">    1262 </span>            : // ROSE_DLL_API SgRangeBasedForStatement* buildRangeBasedForStatement_nfi(SgVariableDeclaration* initializer, SgExpression* range, SgStatement* body);</a>
<a name="1263"><span class="lineNum">    1263 </span>            : ROSE_DLL_API SgRangeBasedForStatement* buildRangeBasedForStatement_nfi(</a>
<a name="1264"><span class="lineNum">    1264 </span>            :      SgVariableDeclaration* initializer, SgVariableDeclaration* range,</a>
<a name="1265"><span class="lineNum">    1265 </span>            :      SgVariableDeclaration* begin_declaration, SgVariableDeclaration* end_declaration,</a>
<a name="1266"><span class="lineNum">    1266 </span>            :      SgExpression* not_equal_expression, SgExpression* increment_expression,</a>
<a name="1267"><span class="lineNum">    1267 </span>            :      SgStatement* body);</a>
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<a name="1269"><span class="lineNum">    1269 </span>            : // EDG 4.8 handled the do-while statement differently (more similar to a block scope than before in EDG 4.7 (i.e. with an end-of-construct statement).</a>
<a name="1270"><span class="lineNum">    1270 </span>            : // So we need an builder function that can use the existing SgDoWhileStatement scope already on the stack.</a>
<a name="1271"><span class="lineNum">    1271 </span>            : ROSE_DLL_API void buildDoWhileStatement_nfi(SgDoWhileStmt* result, SgStatement * body, SgStatement * condition);</a>
<a name="1272"><span class="lineNum">    1272 </span>            : </a>
<a name="1273"><span class="lineNum">    1273 </span>            : //! Build a UPC forall statement</a>
<a name="1274"><span class="lineNum">    1274 </span>            : ROSE_DLL_API SgUpcForAllStatement * buildUpcForAllStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body);</a>
<a name="1275"><span class="lineNum">    1275 </span>            : ROSE_DLL_API SgUpcForAllStatement * buildUpcForAllStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body);</a>
<a name="1276"><span class="lineNum">    1276 </span>            : </a>
<a name="1277"><span class="lineNum">    1277 </span>            : // DQ (3/3/2013): Added UPC specific build functions.</a>
<a name="1278"><span class="lineNum">    1278 </span>            : //! Build a UPC notify statement</a>
<a name="1279"><span class="lineNum">    1279 </span>            : ROSE_DLL_API SgUpcNotifyStatement* buildUpcNotifyStatement_nfi(SgExpression* exp);</a>
<a name="1280"><span class="lineNum">    1280 </span>            : </a>
<a name="1281"><span class="lineNum">    1281 </span>            : //! Build a UPC wait statement</a>
<a name="1282"><span class="lineNum">    1282 </span>            : ROSE_DLL_API SgUpcWaitStatement* buildUpcWaitStatement_nfi(SgExpression* exp);</a>
<a name="1283"><span class="lineNum">    1283 </span>            : </a>
<a name="1284"><span class="lineNum">    1284 </span>            : //! Build a UPC barrier statement</a>
<a name="1285"><span class="lineNum">    1285 </span>            : ROSE_DLL_API SgUpcBarrierStatement* buildUpcBarrierStatement_nfi(SgExpression* exp);</a>
<a name="1286"><span class="lineNum">    1286 </span>            : </a>
<a name="1287"><span class="lineNum">    1287 </span>            : //! Build a UPC fence statement</a>
<a name="1288"><span class="lineNum">    1288 </span>            : ROSE_DLL_API SgUpcFenceStatement* buildUpcFenceStatement_nfi();</a>
<a name="1289"><span class="lineNum">    1289 </span>            : </a>
<a name="1290"><span class="lineNum">    1290 </span>            : </a>
<a name="1291"><span class="lineNum">    1291 </span>            : //! Build while statement</a>
<a name="1292"><span class="lineNum">    1292 </span>            : ROSE_DLL_API SgWhileStmt * buildWhileStmt(SgStatement *  condition, SgStatement *body, SgStatement *else_body = NULL);</a>
<a name="1293"><span class="lineNum">    1293 </span><span class="lineNoCov">          0 : inline SgWhileStmt * buildWhileStmt(SgExpression *  condition, SgStatement *body, SgStatement* else_body = NULL) {</span></a>
<a name="1294"><span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   return buildWhileStmt(buildExprStatement(condition), body, else_body);</span></a>
<a name="1295"><span class="lineNum">    1295 </span>            : }</a>
<a name="1296"><span class="lineNum">    1296 </span>            : SgWhileStmt * buildWhileStmt_nfi(SgStatement *  condition, SgStatement *body, SgStatement *else_body = NULL);</a>
<a name="1297"><span class="lineNum">    1297 </span>            : </a>
<a name="1298"><span class="lineNum">    1298 </span>            : //! Build a with statement</a>
<a name="1299"><span class="lineNum">    1299 </span>            : ROSE_DLL_API SgWithStatement* buildWithStatement(SgExpression* expr, SgStatement* body);</a>
<a name="1300"><span class="lineNum">    1300 </span>            : SgWithStatement* buildWithStatement_nfi(SgExpression* expr, SgStatement* body);</a>
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<a name="1302"><span class="lineNum">    1302 </span>            : //! Build do-while statement</a>
<a name="1303"><span class="lineNum">    1303 </span>            : ROSE_DLL_API SgDoWhileStmt * buildDoWhileStmt(SgStatement *  body, SgStatement *condition);</a>
<a name="1304"><span class="lineNum">    1304 </span>            : inline SgDoWhileStmt * buildDoWhileStmt(SgStatement* body, SgExpression *  condition) {</a>
<a name="1305"><span class="lineNum">    1305 </span>            :   return buildDoWhileStmt(body, buildExprStatement(condition));</a>
<a name="1306"><span class="lineNum">    1306 </span>            : }</a>
<a name="1307"><span class="lineNum">    1307 </span>            : SgDoWhileStmt * buildDoWhileStmt_nfi(SgStatement *  body, SgStatement *condition);</a>
<a name="1308"><span class="lineNum">    1308 </span>            : </a>
<a name="1309"><span class="lineNum">    1309 </span>            : //! Build pragma declaration, handle SgPragma and defining/nondefining pointers internally</a>
<a name="1310"><span class="lineNum">    1310 </span>            : ROSE_DLL_API SgPragmaDeclaration * buildPragmaDeclaration(const std::string &amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1311"><span class="lineNum">    1311 </span>            : SgPragmaDeclaration * buildPragmaDeclaration_nfi(const std::string &amp; name, SgScopeStatement* scope);</a>
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<a name="1313"><span class="lineNum">    1313 </span>            : //!Build SgPragma</a>
<a name="1314"><span class="lineNum">    1314 </span>            : ROSE_DLL_API SgPragma* buildPragma(const std::string &amp; name);</a>
<a name="1315"><span class="lineNum">    1315 </span>            : </a>
<a name="1316"><span class="lineNum">    1316 </span>            : //! Build an empty declaration (useful for adding precission to comments and CPP handling under token-based unparsing).</a>
<a name="1317"><span class="lineNum">    1317 </span>            : ROSE_DLL_API SgEmptyDeclaration* buildEmptyDeclaration();</a>
<a name="1318"><span class="lineNum">    1318 </span>            : </a>
<a name="1319"><span class="lineNum">    1319 </span>            : //! Build a SgBasicBlock, setting file info internally</a>
<a name="1320"><span class="lineNum">    1320 </span>            : ROSE_DLL_API SgBasicBlock * buildBasicBlock(SgStatement * stmt1 = NULL, SgStatement* stmt2 = NULL, SgStatement* stmt3 = NULL, SgStatement* stmt4 = NULL, SgStatement* stmt5 = NULL, SgStatement* stmt6 = NULL, SgStatement* stmt7 = NULL, SgStatement* stmt8 = NULL, SgStatement* stmt9 = NULL, SgStatement* stmt10 = NULL);</a>
<a name="1321"><span class="lineNum">    1321 </span>            : ROSE_DLL_API SgBasicBlock * buildBasicBlock_nfi();</a>
<a name="1322"><span class="lineNum">    1322 </span>            : SgBasicBlock * buildBasicBlock_nfi(const std::vector&lt;SgStatement*&gt;&amp;);</a>
<a name="1323"><span class="lineNum">    1323 </span>            : </a>
<a name="1324"><span class="lineNum">    1324 </span>            : // CR (7/24/2020): Added additional functionality</a>
<a name="1325"><span class="lineNum">    1325 </span>            : //! Build a SgBasicBlock and set its parent. This function does NOT link the parent scope to the block.</a>
<a name="1326"><span class="lineNum">    1326 </span>            : SgBasicBlock * buildBasicBlock_nfi(SgScopeStatement* parent);</a>
<a name="1327"><span class="lineNum">    1327 </span>            : </a>
<a name="1328"><span class="lineNum">    1328 </span>            : //! Build an assignment statement from lefthand operand and right hand operand</a>
<a name="1329"><span class="lineNum">    1329 </span>            : ROSE_DLL_API SgExprStatement*</a>
<a name="1330"><span class="lineNum">    1330 </span>            : buildAssignStatement(SgExpression* lhs,SgExpression* rhs);</a>
<a name="1331"><span class="lineNum">    1331 </span>            : </a>
<a name="1332"><span class="lineNum">    1332 </span>            : // DQ (8/16/2011): Generated a new version of this function to define consistant semantics.</a>
<a name="1333"><span class="lineNum">    1333 </span>            : //! This version does not recursively reset the file info as a transformation.</a>
<a name="1334"><span class="lineNum">    1334 </span>            : ROSE_DLL_API SgExprStatement* buildAssignStatement_ast_translate(SgExpression* lhs,SgExpression* rhs);</a>
<a name="1335"><span class="lineNum">    1335 </span>            : </a>
<a name="1336"><span class="lineNum">    1336 </span>            : //! Build a break statement</a>
<a name="1337"><span class="lineNum">    1337 </span>            : ROSE_DLL_API SgBreakStmt* buildBreakStmt();</a>
<a name="1338"><span class="lineNum">    1338 </span>            : SgBreakStmt* buildBreakStmt_nfi();</a>
<a name="1339"><span class="lineNum">    1339 </span>            : </a>
<a name="1340"><span class="lineNum">    1340 </span>            : //! Build a continue statement</a>
<a name="1341"><span class="lineNum">    1341 </span>            : ROSE_DLL_API SgContinueStmt* buildContinueStmt();</a>
<a name="1342"><span class="lineNum">    1342 </span>            : SgContinueStmt* buildContinueStmt_nfi();</a>
<a name="1343"><span class="lineNum">    1343 </span>            : </a>
<a name="1344"><span class="lineNum">    1344 </span>            : //! Build a pass statement</a>
<a name="1345"><span class="lineNum">    1345 </span>            : ROSE_DLL_API SgPassStatement* buildPassStatement();</a>
<a name="1346"><span class="lineNum">    1346 </span>            : SgPassStatement* buildPassStatement_nfi();</a>
<a name="1347"><span class="lineNum">    1347 </span>            : </a>
<a name="1348"><span class="lineNum">    1348 </span>            : //! Build a Assert statement</a>
<a name="1349"><span class="lineNum">    1349 </span>            : ROSE_DLL_API SgAssertStmt* buildAssertStmt(SgExpression* test);</a>
<a name="1350"><span class="lineNum">    1350 </span>            : ROSE_DLL_API SgAssertStmt* buildAssertStmt(SgExpression *test, SgExpression *exceptionArgument);</a>
<a name="1351"><span class="lineNum">    1351 </span>            : SgAssertStmt* buildAssertStmt_nfi(SgExpression* test);</a>
<a name="1352"><span class="lineNum">    1352 </span>            : </a>
<a name="1353"><span class="lineNum">    1353 </span>            : //! Build a yield statement</a>
<a name="1354"><span class="lineNum">    1354 </span>            : ROSE_DLL_API SgYieldExpression* buildYieldExpression(SgExpression* value);</a>
<a name="1355"><span class="lineNum">    1355 </span>            : SgYieldExpression* buildYieldExpression_nfi(SgExpression* value);</a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span>            : //! Build a key-datum pair</a>
<a name="1358"><span class="lineNum">    1358 </span>            : ROSE_DLL_API SgKeyDatumPair* buildKeyDatumPair    (SgExpression* key, SgExpression* datum);</a>
<a name="1359"><span class="lineNum">    1359 </span>            : SgKeyDatumPair* buildKeyDatumPair_nfi(SgExpression* key, SgExpression* datum);</a>
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<a name="1361"><span class="lineNum">    1361 </span>            : //! Build a list of key-datum pairs</a>
<a name="1362"><span class="lineNum">    1362 </span>            : ROSE_DLL_API SgDictionaryExp* buildDictionaryExp    (std::vector&lt;SgKeyDatumPair*&gt; pairs);</a>
<a name="1363"><span class="lineNum">    1363 </span>            : SgDictionaryExp* buildDictionaryExp_nfi(std::vector&lt;SgKeyDatumPair*&gt; pairs);</a>
<a name="1364"><span class="lineNum">    1364 </span>            : </a>
<a name="1365"><span class="lineNum">    1365 </span>            : //! Build an Actual Argument Expression</a>
<a name="1366"><span class="lineNum">    1366 </span>            : ROSE_DLL_API SgActualArgumentExpression* buildActualArgumentExpression(SgName arg_name, SgExpression* arg);</a>
<a name="1367"><span class="lineNum">    1367 </span>            : SgActualArgumentExpression* buildActualArgumentExpression_nfi(SgName arg_name, SgExpression* arg);</a>
<a name="1368"><span class="lineNum">    1368 </span>            : </a>
<a name="1369"><span class="lineNum">    1369 </span>            : //! Build a delete statement</a>
<a name="1370"><span class="lineNum">    1370 </span>            : ROSE_DLL_API SgDeleteExp* buildDeleteExp(SgExpression *target, bool is_array = false, bool need_global_specifier = false, SgFunctionDeclaration *deleteOperatorDeclaration = NULL);</a>
<a name="1371"><span class="lineNum">    1371 </span>            : SgDeleteExp* buildDeleteExp_nfi(SgExpression *target, bool is_array = false, bool need_global_specifier = false, SgFunctionDeclaration *deleteOperatorDeclaration = NULL);</a>
<a name="1372"><span class="lineNum">    1372 </span>            : </a>
<a name="1373"><span class="lineNum">    1373 </span>            : //! Build a scope statement. Used to build SgNonrealDecl and SgNonrealType</a>
<a name="1374"><span class="lineNum">    1374 </span>            : ROSE_DLL_API SgDeclarationScope * buildDeclarationScope();</a>
<a name="1375"><span class="lineNum">    1375 </span>            : </a>
<a name="1376"><span class="lineNum">    1376 </span>            : //! Build a class definition scope statement</a>
<a name="1377"><span class="lineNum">    1377 </span>            : // SgClassDefinition* buildClassDefinition(SgClassDeclaration *d = NULL);</a>
<a name="1378"><span class="lineNum">    1378 </span>            : ROSE_DLL_API SgClassDefinition* buildClassDefinition(SgClassDeclaration *d = NULL, bool buildTemplateInstantiation = false);</a>
<a name="1379"><span class="lineNum">    1379 </span>            : </a>
<a name="1380"><span class="lineNum">    1380 </span>            : //! Build a class definition scope statement</a>
<a name="1381"><span class="lineNum">    1381 </span>            : // SgClassDefinition* buildClassDefinition_nfi(SgClassDeclaration *d = NULL);</a>
<a name="1382"><span class="lineNum">    1382 </span>            : SgClassDefinition* buildClassDefinition_nfi(SgClassDeclaration *d = NULL, bool buildTemplateInstantiation = false);</a>
<a name="1383"><span class="lineNum">    1383 </span>            : </a>
<a name="1384"><span class="lineNum">    1384 </span>            : // DQ (11/19/2011): Added more template declaration support.</a>
<a name="1385"><span class="lineNum">    1385 </span>            : //! Build a template class definition statement</a>
<a name="1386"><span class="lineNum">    1386 </span>            : SgTemplateClassDefinition* buildTemplateClassDefinition(SgTemplateClassDeclaration *d = NULL );</a>
<a name="1387"><span class="lineNum">    1387 </span>            : </a>
<a name="1388"><span class="lineNum">    1388 </span>            : //! Build a structure first nondefining declaration, without file info</a>
<a name="1389"><span class="lineNum">    1389 </span>            : // DQ (6/6/2012): Added support to get the template arguments into place before computing the type.</a>
<a name="1390"><span class="lineNum">    1390 </span>            : // SgClassDeclaration* buildNondefiningClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope);</a>
<a name="1391"><span class="lineNum">    1391 </span>            : // SgClassDeclaration* buildNondefiningClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, bool buildTemplateInstantiation = false);</a>
<a name="1392"><span class="lineNum">    1392 </span>            : ROSE_DLL_API SgClassDeclaration* buildNondefiningClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="1393"><span class="lineNum">    1393 </span>            : </a>
<a name="1394"><span class="lineNum">    1394 </span>            : // DQ (8/11/2013): We need to hand in both the SgTemplateParameterPtrList and the SgTemplateArgumentPtrList because class templates can be partially specialized.</a>
<a name="1395"><span class="lineNum">    1395 </span>            : //! DQ (11/29/2011): Adding template declaration support to the AST.</a>
<a name="1396"><span class="lineNum">    1396 </span>            : ROSE_DLL_API SgTemplateClassDeclaration* buildNondefiningTemplateClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList);</a>
<a name="1397"><span class="lineNum">    1397 </span>            : </a>
<a name="1398"><span class="lineNum">    1398 </span>            : //!buildNondefiningTemplateClassDeclaration()</a>
<a name="1399"><span class="lineNum">    1399 </span>            : ROSE_DLL_API SgTemplateClassDeclaration* buildNondefiningTemplateClassDeclaration(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList);</a>
<a name="1400"><span class="lineNum">    1400 </span>            : </a>
<a name="1401"><span class="lineNum">    1401 </span>            : //! DQ (11/7/2009): Added functions to build C++ class.</a>
<a name="1402"><span class="lineNum">    1402 </span>            : ROSE_DLL_API SgClassDeclaration* buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope );</a>
<a name="1403"><span class="lineNum">    1403 </span>            : ROSE_DLL_API SgClassDeclaration* buildDefiningClassDeclaration    ( SgName name, SgScopeStatement* scope );</a>
<a name="1404"><span class="lineNum">    1404 </span>            : </a>
<a name="1405"><span class="lineNum">    1405 </span>            : //! DQ (11/7/2009): Added function to build C++ class (builds both the non-defining and defining declarations; in that order).</a>
<a name="1406"><span class="lineNum">    1406 </span>            : ROSE_DLL_API SgClassDeclaration* buildClassDeclaration    ( SgName name, SgScopeStatement* scope );</a>
<a name="1407"><span class="lineNum">    1407 </span>            : </a>
<a name="1408"><span class="lineNum">    1408 </span>            : //! Build an enum first nondefining declaration, without file info</a>
<a name="1409"><span class="lineNum">    1409 </span>            : ROSE_DLL_API SgEnumDeclaration* buildNondefiningEnumDeclaration_nfi(const SgName&amp; name, SgScopeStatement* scope);</a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span>            : //! Build a structure, It is also a declaration statement in SAGE III</a>
<a name="1412"><span class="lineNum">    1412 </span>            : ROSE_DLL_API SgClassDeclaration * buildStructDeclaration(const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1413"><span class="lineNum">    1413 </span>            : ROSE_DLL_API SgClassDeclaration * buildStructDeclaration(const std::string&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1414"><span class="lineNum">    1414 </span>            : ROSE_DLL_API SgClassDeclaration * buildStructDeclaration(const char* name, SgScopeStatement* scope=NULL);</a>
<a name="1415"><span class="lineNum">    1415 </span>            : </a>
<a name="1416"><span class="lineNum">    1416 </span>            : //! Build a StmtDeclarationStmt</a>
<a name="1417"><span class="lineNum">    1417 </span>            : ROSE_DLL_API SgStmtDeclarationStatement* buildStmtDeclarationStatement(SgStatement* stmt);</a>
<a name="1418"><span class="lineNum">    1418 </span>            : ROSE_DLL_API SgStmtDeclarationStatement* buildStmtDeclarationStatement_nfi(SgStatement* stmt);</a>
<a name="1419"><span class="lineNum">    1419 </span>            : </a>
<a name="1420"><span class="lineNum">    1420 </span>            : //! tps (09/02/2009) : Added support for building namespaces</a>
<a name="1421"><span class="lineNum">    1421 </span>            : ROSE_DLL_API SgNamespaceDeclarationStatement *  buildNamespaceDeclaration(const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1422"><span class="lineNum">    1422 </span>            : ROSE_DLL_API SgNamespaceDeclarationStatement *  buildNamespaceDeclaration_nfi(const SgName&amp; name, bool unnamednamespace, SgScopeStatement* scope );</a>
<a name="1423"><span class="lineNum">    1423 </span>            : ROSE_DLL_API SgNamespaceDefinitionStatement * buildNamespaceDefinition(SgNamespaceDeclarationStatement* d=NULL);</a>
<a name="1424"><span class="lineNum">    1424 </span>            : </a>
<a name="1425"><span class="lineNum">    1425 </span>            : //! driscoll6 (7/20/11) : Support n-ary operators for python</a>
<a name="1426"><span class="lineNum">    1426 </span>            : ROSE_DLL_API SgNaryComparisonOp* buildNaryComparisonOp(SgExpression* lhs);</a>
<a name="1427"><span class="lineNum">    1427 </span>            : ROSE_DLL_API SgNaryComparisonOp* buildNaryComparisonOp_nfi(SgExpression* lhs);</a>
<a name="1428"><span class="lineNum">    1428 </span>            : ROSE_DLL_API SgNaryBooleanOp* buildNaryBooleanOp(SgExpression* lhs);</a>
<a name="1429"><span class="lineNum">    1429 </span>            : ROSE_DLL_API SgNaryBooleanOp* buildNaryBooleanOp_nfi(SgExpression* lhs);</a>
<a name="1430"><span class="lineNum">    1430 </span>            : </a>
<a name="1431"><span class="lineNum">    1431 </span>            : ROSE_DLL_API SgStringConversion* buildStringConversion(SgExpression* exp);</a>
<a name="1432"><span class="lineNum">    1432 </span>            : ROSE_DLL_API SgStringConversion* buildStringConversion_nfi(SgExpression* exp);</a>
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<a name="1434"><span class="lineNum">    1434 </span>            : // DQ (6/6/2012): Addeding support to include template arguments in the generated type (template argument must be provided as early as possible).</a>
<a name="1435"><span class="lineNum">    1435 </span>            : // DQ (1/24/2009): Added this &quot;_nfi&quot; function but refactored buildStructDeclaration to also use it (this needs to be done uniformally).</a>
<a name="1436"><span class="lineNum">    1436 </span>            : // SgClassDeclaration * buildClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl, bool buildTemplateInstantiation = false);</a>
<a name="1437"><span class="lineNum">    1437 </span>            : // SgClassDeclaration * buildClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl, bool buildTemplateInstantiation);</a>
<a name="1438"><span class="lineNum">    1438 </span>            : ROSE_DLL_API SgClassDeclaration* buildClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList);</a>
<a name="1439"><span class="lineNum">    1439 </span>            : </a>
<a name="1440"><span class="lineNum">    1440 </span>            : // DQ (8/11/2013): I think that the specification of both SgTemplateParameterPtrList and SgTemplateArgumentPtrList is redundant with the nonDefiningDecl (which is a required parameter).</a>
<a name="1441"><span class="lineNum">    1441 </span>            : // DQ (11/19/2011): Added to support template class declaration using EDG 4.x support (to support the template declarations directly in the AST).</a>
<a name="1442"><span class="lineNum">    1442 </span>            : ROSE_DLL_API SgTemplateClassDeclaration* buildTemplateClassDeclaration_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl,</a>
<a name="1443"><span class="lineNum">    1443 </span>            :                                                                            SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList );</a>
<a name="1444"><span class="lineNum">    1444 </span>            : //! Build tempplate class declaration</a>
<a name="1445"><span class="lineNum">    1445 </span>            : ROSE_DLL_API SgTemplateClassDeclaration* buildTemplateClassDeclaration(const SgName&amp; name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl,</a>
<a name="1446"><span class="lineNum">    1446 </span>            :                                                                            SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList );</a>
<a name="1447"><span class="lineNum">    1447 </span>            : </a>
<a name="1448"><span class="lineNum">    1448 </span>            : //! Build an SgDerivedTypeStatement Fortran derived type declaration with a</a>
<a name="1449"><span class="lineNum">    1449 </span>            : //! class declaration and definition (creating both the defining and nondefining declarations as required).</a>
<a name="1450"><span class="lineNum">    1450 </span>            : ROSE_DLL_API SgDerivedTypeStatement * buildDerivedTypeStatement (const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1451"><span class="lineNum">    1451 </span>            : </a>
<a name="1452"><span class="lineNum">    1452 </span>            : //! Build a Fortran module declaration.</a>
<a name="1453"><span class="lineNum">    1453 </span>            : ROSE_DLL_API SgModuleStatement * buildModuleStatement(const SgName&amp; name, SgScopeStatement* scope /*=NULL*/);</a>
<a name="1454"><span class="lineNum">    1454 </span>            : </a>
<a name="1455"><span class="lineNum">    1455 </span>            : //! Build a generic class declaration statement (SgClassDeclaration or subclass) with a</a>
<a name="1456"><span class="lineNum">    1456 </span>            : //! class declaration and definition (creating both the defining and nondefining declarations as required.</a>
<a name="1457"><span class="lineNum">    1457 </span>            : template &lt;class DeclClass&gt; ROSE_DLL_API</a>
<a name="1458"><span class="lineNum">    1458 </span>            : DeclClass * buildClassDeclarationStatement_nfi(const SgName&amp; name, SgClassDeclaration::class_types kind,</a>
<a name="1459"><span class="lineNum">    1459 </span>            :                                                SgScopeStatement* scope=NULL, SgClassDeclaration* nonDefiningDecl=NULL);</a>
<a name="1460"><span class="lineNum">    1460 </span>            : </a>
<a name="1461"><span class="lineNum">    1461 </span>            : //! Build an enum, It is also a declaration statement in SAGE III</a>
<a name="1462"><span class="lineNum">    1462 </span>            : ROSE_DLL_API SgEnumDeclaration * buildEnumDeclaration(const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1463"><span class="lineNum">    1463 </span>            : </a>
<a name="1464"><span class="lineNum">    1464 </span>            : //! Build an enum, It is also a declaration statement in SAGE III</a>
<a name="1465"><span class="lineNum">    1465 </span>            : ROSE_DLL_API SgEnumDeclaration * buildEnumDeclaration_nfi(const SgName&amp; name, SgScopeStatement* scope=NULL);</a>
<a name="1466"><span class="lineNum">    1466 </span>            : </a>
<a name="1467"><span class="lineNum">    1467 </span>            : //! Build a return statement</a>
<a name="1468"><span class="lineNum">    1468 </span>            : ROSE_DLL_API SgReturnStmt* buildReturnStmt(SgExpression* expression = NULL);</a>
<a name="1469"><span class="lineNum">    1469 </span>            : ROSE_DLL_API SgReturnStmt* buildReturnStmt_nfi(SgExpression* expression);</a>
<a name="1470"><span class="lineNum">    1470 </span>            : </a>
<a name="1471"><span class="lineNum">    1471 </span>            : //! Build a NULL statement</a>
<a name="1472"><span class="lineNum">    1472 </span>            : ROSE_DLL_API SgNullStatement* buildNullStatement();</a>
<a name="1473"><span class="lineNum">    1473 </span>            : SgNullStatement* buildNullStatement_nfi();</a>
<a name="1474"><span class="lineNum">    1474 </span>            : </a>
<a name="1475"><span class="lineNum">    1475 </span>            : //! Build Fortran attribute specification statement</a>
<a name="1476"><span class="lineNum">    1476 </span>            : ROSE_DLL_API SgAttributeSpecificationStatement * buildAttributeSpecificationStatement(SgAttributeSpecificationStatement::attribute_spec_enum kind);</a>
<a name="1477"><span class="lineNum">    1477 </span>            : </a>
<a name="1478"><span class="lineNum">    1478 </span>            : //! Build Fortran include line</a>
<a name="1479"><span class="lineNum">    1479 </span>            : ROSE_DLL_API SgFortranIncludeLine* buildFortranIncludeLine(std::string filename);</a>
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<a name="1481"><span class="lineNum">    1481 </span>            : //! Build a Fortran common block, possibly with a name</a>
<a name="1482"><span class="lineNum">    1482 </span>            : ROSE_DLL_API SgCommonBlockObject* buildCommonBlockObject(std::string name=&quot;&quot;, SgExprListExp* exp_list=NULL);</a>
<a name="1483"><span class="lineNum">    1483 </span>            : </a>
<a name="1484"><span class="lineNum">    1484 </span>            : //! Build a Fortran Common statement</a>
<a name="1485"><span class="lineNum">    1485 </span>            : ROSE_DLL_API SgCommonBlock* buildCommonBlock(SgCommonBlockObject* first_block=NULL);</a>
<a name="1486"><span class="lineNum">    1486 </span>            : </a>
<a name="1487"><span class="lineNum">    1487 </span>            : // driscoll6 (6/9/2011): Adding support for try stmts.</a>
<a name="1488"><span class="lineNum">    1488 </span>            : //! Build a catch statement.</a>
<a name="1489"><span class="lineNum">    1489 </span>            : ROSE_DLL_API SgCatchOptionStmt* buildCatchOptionStmt(SgVariableDeclaration* condition=NULL, SgStatement* body=NULL);</a>
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<a name="1491"><span class="lineNum">    1491 </span>            : // driscoll6 (6/9/2011): Adding support for try stmts.</a>
<a name="1492"><span class="lineNum">    1492 </span>            : //! Build a try statement.</a>
<a name="1493"><span class="lineNum">    1493 </span>            : ROSE_DLL_API SgTryStmt* buildTryStmt(SgStatement* body,</a>
<a name="1494"><span class="lineNum">    1494 </span>            :                                      SgCatchOptionStmt* catch0=NULL,</a>
<a name="1495"><span class="lineNum">    1495 </span>            :                                      SgCatchOptionStmt* catch1=NULL,</a>
<a name="1496"><span class="lineNum">    1496 </span>            :                                      SgCatchOptionStmt* catch2=NULL,</a>
<a name="1497"><span class="lineNum">    1497 </span>            :                                      SgCatchOptionStmt* catch3=NULL,</a>
<a name="1498"><span class="lineNum">    1498 </span>            :                                      SgCatchOptionStmt* catch4=NULL);</a>
<a name="1499"><span class="lineNum">    1499 </span>            : </a>
<a name="1500"><span class="lineNum">    1500 </span>            : // charles4 (9/16/2011): Adding support for try stmts.</a>
<a name="1501"><span class="lineNum">    1501 </span>            : //! Build a try statement.</a>
<a name="1502"><span class="lineNum">    1502 </span>            : //SgTryStmt* buildTryStmt(SgStatement *try_body, SgCatchStatementSeq *catches, SgStatement *finally_body = NULL);</a>
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<a name="1504"><span class="lineNum">    1504 </span>            : // charles4 (9/16/2011): Adding support for try stmts.</a>
<a name="1505"><span class="lineNum">    1505 </span>            : //! Build a try statement.</a>
<a name="1506"><span class="lineNum">    1506 </span>            : ROSE_DLL_API SgTryStmt* buildTryStmt(SgBasicBlock *try_body, SgBasicBlock *finally_body = NULL);</a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span>            : // charles4 (9/16/2011): Adding support for Catch Blocks.</a>
<a name="1509"><span class="lineNum">    1509 </span>            : //! Build an initial sequence of Catch blocks containing 0 or 1 element.</a>
<a name="1510"><span class="lineNum">    1510 </span>            : ROSE_DLL_API SgCatchStatementSeq *buildCatchStatementSeq(SgCatchOptionStmt * = NULL);</a>
<a name="1511"><span class="lineNum">    1511 </span>            : </a>
<a name="1512"><span class="lineNum">    1512 </span>            : //! Build an exec statement</a>
<a name="1513"><span class="lineNum">    1513 </span>            : ROSE_DLL_API SgExecStatement* buildExecStatement(SgExpression* executable, SgExpression* globals = NULL, SgExpression* locals = NULL);</a>
<a name="1514"><span class="lineNum">    1514 </span>            : SgExecStatement* buildExecStatement_nfi(SgExpression* executable, SgExpression* globals = NULL, SgExpression* locals = NULL);</a>
<a name="1515"><span class="lineNum">    1515 </span>            : </a>
<a name="1516"><span class="lineNum">    1516 </span>            : // DQ (4/30/2010): Added support for building asm statements.</a>
<a name="1517"><span class="lineNum">    1517 </span>            : //! Build a NULL statement</a>
<a name="1518"><span class="lineNum">    1518 </span>            : ROSE_DLL_API SgAsmStmt* buildAsmStatement(std::string s);</a>
<a name="1519"><span class="lineNum">    1519 </span>            : SgAsmStmt* buildAsmStatement_nfi(std::string s);</a>
<a name="1520"><span class="lineNum">    1520 </span>            : </a>
<a name="1521"><span class="lineNum">    1521 </span>            : //! DQ (4/30/2010): Added support for building nop statement using asm statement</a>
<a name="1522"><span class="lineNum">    1522 </span>            : //! Building nop statement using asm statement</a>
<a name="1523"><span class="lineNum">    1523 </span>            : ROSE_DLL_API SgAsmStmt* buildMultibyteNopStatement( int n );</a>
<a name="1524"><span class="lineNum">    1524 </span>            : </a>
<a name="1525"><span class="lineNum">    1525 </span>            : //! DQ (5/6/2013): Added build functions to support SgBaseClass construction.</a>
<a name="1526"><span class="lineNum">    1526 </span>            : ROSE_DLL_API SgBaseClass* buildBaseClass ( SgClassDeclaration* classDeclaration, SgClassDefinition* classDefinition, bool isVirtual, bool isDirect );</a>
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<a name="1528"><span class="lineNum">    1528 </span>            : ROSE_DLL_API SgNonrealBaseClass* buildNonrealBaseClass ( SgNonrealDecl* classDeclaration, SgClassDefinition* classDefinition, bool isVirtual, bool isDirect );</a>
<a name="1529"><span class="lineNum">    1529 </span>            : </a>
<a name="1530"><span class="lineNum">    1530 </span>            : // SgAccessModifier buildAccessModifier ( unsigned int access );</a>
<a name="1531"><span class="lineNum">    1531 </span>            : </a>
<a name="1532"><span class="lineNum">    1532 </span>            : //! DQ (7/25/2014): Adding support for C11 static assertions.</a>
<a name="1533"><span class="lineNum">    1533 </span>            : ROSE_DLL_API SgStaticAssertionDeclaration* buildStaticAssertionDeclaration(SgExpression* condition, const SgName &amp; string_literal);</a>
<a name="1534"><span class="lineNum">    1534 </span>            : </a>
<a name="1535"><span class="lineNum">    1535 </span>            : //! DQ (8/17/2014): Adding support for Microsoft MSVC specific attributes.</a>
<a name="1536"><span class="lineNum">    1536 </span>            : ROSE_DLL_API SgMicrosoftAttributeDeclaration* buildMicrosoftAttributeDeclaration (const SgName &amp; name);</a>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<a name="1538"><span class="lineNum">    1538 </span>            : //! Liao (9/18/2015): experimental support of building a statement from a string</a>
<a name="1539"><span class="lineNum">    1539 </span>            : ROSE_DLL_API SgStatement* buildStatementFromString(const std::string &amp; stmt_str, SgScopeStatement* scope);</a>
<a name="1540"><span class="lineNum">    1540 </span>            : </a>
<a name="1541"><span class="lineNum">    1541 </span>            : //! Build a using directive statement</a>
<a name="1542"><span class="lineNum">    1542 </span>            : ROSE_DLL_API SgUsingDirectiveStatement* buildUsingDirectiveStatement(SgNamespaceDeclarationStatement * ns_decl);</a>
<a name="1543"><span class="lineNum">    1543 </span>            : //@}</a>
<a name="1544"><span class="lineNum">    1544 </span>            : </a>
<a name="1545"><span class="lineNum">    1545 </span>            : //--------------------------------------------------------------</a>
<a name="1546"><span class="lineNum">    1546 </span>            : //@{</a>
<a name="1547"><span class="lineNum">    1547 </span>            : /*! @name Builders for others</a>
<a name="1548"><span class="lineNum">    1548 </span>            :   \brief AST high level builders for others</a>
<a name="1549"><span class="lineNum">    1549 </span>            : </a>
<a name="1550"><span class="lineNum">    1550 </span>            : */</a>
<a name="1551"><span class="lineNum">    1551 </span>            : //! Build a SgFile node and attach it to SgProject</a>
<a name="1552"><span class="lineNum">    1552 </span>            : /*! The input file will be loaded if exists, or an empty one will be generated from scratch transparently. Output file name is used to specify the output file name of unparsing. The final SgFile will be inserted to project automatically. If not provided, a new SgProject will be generated internally. Using SgFile-&gt;get_project() to retrieve it in this case.</a>
<a name="1553"><span class="lineNum">    1553 </span>            :  */</a>
<a name="1554"><span class="lineNum">    1554 </span>            : ROSE_DLL_API SgFile* buildFile(const std::string&amp; inputFileName,const std::string&amp; outputFileName, SgProject* project = NULL, bool clear_globalScopeAcrossFiles = false);</a>
<a name="1555"><span class="lineNum">    1555 </span>            : </a>
<a name="1556"><span class="lineNum">    1556 </span>            : //! Build a SgFile node and attach it to SgProject</a>
<a name="1557"><span class="lineNum">    1557 </span>            : /*! The file will be build with an empty global scope to support declarations being added.</a>
<a name="1558"><span class="lineNum">    1558 </span>            :  */</a>
<a name="1559"><span class="lineNum">    1559 </span>            : ROSE_DLL_API SgSourceFile* buildSourceFile(const std::string&amp; outputFileName, SgProject* project=NULL, bool clear_globalScopeAcrossFiles = false);</a>
<a name="1560"><span class="lineNum">    1560 </span>            : </a>
<a name="1561"><span class="lineNum">    1561 </span>            : //! Build a SgSourceFile node and attach it to SgProject</a>
<a name="1562"><span class="lineNum">    1562 </span>            : /*! The input file will be loaded if exists, or an empty one will be generated from scratch transparently. Output file name is used to specify the output file name of unparsing. The final SgFile will be inserted to project automatically. If not provided, a new SgProject will be generated internally. Using SgFile-&gt;get_project() to retrieve it in this case.</a>
<a name="1563"><span class="lineNum">    1563 </span>            :  */</a>
<a name="1564"><span class="lineNum">    1564 </span>            : ROSE_DLL_API SgSourceFile* buildSourceFile(const std::string&amp; inputFileName, const std::string&amp; outputFileName, SgProject* project, bool clear_globalScopeAcrossFiles = false);</a>
<a name="1565"><span class="lineNum">    1565 </span>            : </a>
<a name="1566"><span class="lineNum">    1566 </span>            : // DQ (11/8/2019): Support function for the new file (to support changing the file names in the source position info objects of each AST subtree node.</a>
<a name="1567"><span class="lineNum">    1567 </span>            : //! Change the source file associated with the source position information in the AST.</a>
<a name="1568"><span class="lineNum">    1568 </span>            : // ROSE_DLL_API void fixupSourcePositionFileSpecification(SgNode* subtreeRoot, const std::string&amp; newFileName);</a>
<a name="1569"><span class="lineNum">    1569 </span>            : ROSE_DLL_API void fixupSourcePositionFileSpecification(SgNode* subtreeRoot, const std::string&amp; newFileName);</a>
<a name="1570"><span class="lineNum">    1570 </span>            : </a>
<a name="1571"><span class="lineNum">    1571 </span>            : // DQ (11/10/2019): Support for sharing IR nodes when buildFile() is applied to an existing file.</a>
<a name="1572"><span class="lineNum">    1572 </span>            : //! Sharing IR nodes requires that the file id be added to the fileIDsToUnparse held in the Sg_File_Info object.</a>
<a name="1573"><span class="lineNum">    1573 </span>            : ROSE_DLL_API void fixupSharingSourcePosition(SgNode* subtreeRoot, int new_file_id);</a>
<a name="1574"><span class="lineNum">    1574 </span>            : </a>
<a name="1575"><span class="lineNum">    1575 </span>            : //! Build and attach a comment, comment style is inferred from the language type of the target node if not provided. It is indeed a wrapper of SageInterface::attachComment().</a>
<a name="1576"><span class="lineNum">    1576 </span>            : ROSE_DLL_API PreprocessingInfo* buildComment(SgLocatedNode* target, const std::string &amp; content,</a>
<a name="1577"><span class="lineNum">    1577 </span>            :                PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before,</a>
<a name="1578"><span class="lineNum">    1578 </span>            :                PreprocessingInfo::DirectiveType dtype= PreprocessingInfo::CpreprocessorUnknownDeclaration);</a>
<a name="1579"><span class="lineNum">    1579 </span>            : </a>
<a name="1580"><span class="lineNum">    1580 </span>            : //! Build and attach #define XX directives, pass &quot;#define xxx xxx&quot; as content.</a>
<a name="1581"><span class="lineNum">    1581 </span>            : ROSE_DLL_API PreprocessingInfo* buildCpreprocessorDefineDeclaration(SgLocatedNode* target,</a>
<a name="1582"><span class="lineNum">    1582 </span>            :                 const std::string &amp; content,</a>
<a name="1583"><span class="lineNum">    1583 </span>            :                PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before);</a>
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<a name="1585"><span class="lineNum">    1585 </span>            : //! Build a dangling #include &quot;x.h&quot; header,  insertHeader() is needed to actually insert it</a>
<a name="1586"><span class="lineNum">    1586 </span>            : ROSE_DLL_API PreprocessingInfo* buildHeader(const std::string&amp; header_filename,</a>
<a name="1587"><span class="lineNum">    1587 </span>            :                PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before,</a>
<a name="1588"><span class="lineNum">    1588 </span>            :                bool isSystemHeader =false);</a>
<a name="1589"><span class="lineNum">    1589 </span>            : </a>
<a name="1590"><span class="lineNum">    1590 </span>            : </a>
<a name="1591"><span class="lineNum">    1591 </span>            : #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</a>
<a name="1592"><span class="lineNum">    1592 </span>            : //! Build an abstract handle from a SgNode</a>
<a name="1593"><span class="lineNum">    1593 </span>            : ROSE_DLL_API AbstractHandle::abstract_handle * buildAbstractHandle(SgNode* n);</a>
<a name="1594"><span class="lineNum">    1594 </span>            : #endif</a>
<a name="1595"><span class="lineNum">    1595 </span>            : </a>
<a name="1596"><span class="lineNum">    1596 </span>            : // 03/17/2014 PHL</a>
<a name="1597"><span class="lineNum">    1597 </span>            : // //! Build an equivalence statement from two expression operands</a>
<a name="1598"><span class="lineNum">    1598 </span>            : ROSE_DLL_API SgEquivalenceStatement*</a>
<a name="1599"><span class="lineNum">    1599 </span>            : buildEquivalenceStatement(SgExpression* lhs,SgExpression* rhs);</a>
<a name="1600"><span class="lineNum">    1600 </span>            : </a>
<a name="1601"><span class="lineNum">    1601 </span>            : </a>
<a name="1602"><span class="lineNum">    1602 </span>            : //! Fixup any AST moved from one file two another (references to symbols, types, etc.).</a>
<a name="1603"><span class="lineNum">    1603 </span>            : ROSE_DLL_API void fixupCopyOfAstFromSeparateFileInNewTargetAst(SgStatement *insertionPoint, bool insertionPointIsScope,</a>
<a name="1604"><span class="lineNum">    1604 </span>            :                                                                SgStatement *toInsert, SgStatement* original_before_copy);</a>
<a name="1605"><span class="lineNum">    1605 </span>            : ROSE_DLL_API void fixupCopyOfNodeFromSeparateFileInNewTargetAst(SgStatement* insertionPoint, bool insertionPointIsScope,</a>
<a name="1606"><span class="lineNum">    1606 </span>            :                                                                 SgNode* node_copy, SgNode* node_original);</a>
<a name="1607"><span class="lineNum">    1607 </span>            : ROSE_DLL_API SgType* getTargetFileTypeSupport(SgType* snippet_type, SgScopeStatement* targetScope);</a>
<a name="1608"><span class="lineNum">    1608 </span>            : ROSE_DLL_API SgType* getTargetFileType(SgType* snippet_type, SgScopeStatement* targetScope);</a>
<a name="1609"><span class="lineNum">    1609 </span>            : </a>
<a name="1610"><span class="lineNum">    1610 </span>            : // DQ (12/6/2020): This is the original function (modified slightly, but mostly I have defined a new function that</a>
<a name="1611"><span class="lineNum">    1611 </span>            : // will not effect the AST snippet support that is used by this function.</a>
<a name="1612"><span class="lineNum">    1612 </span>            : ROSE_DLL_API SgSymbol* findAssociatedSymbolInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope);</a>
<a name="1613"><span class="lineNum">    1613 </span>            : </a>
<a name="1614"><span class="lineNum">    1614 </span>            : // DQ (12/6/2020): This is the new function (modified in API and made suitable for the codeSegregation support).</a>
<a name="1615"><span class="lineNum">    1615 </span>            : ROSE_DLL_API SgDeclarationStatement* findAssociatedDeclarationInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope);</a>
<a name="1616"><span class="lineNum">    1616 </span>            : </a>
<a name="1617"><span class="lineNum">    1617 </span>            : //! Error checking the inserted snippet AST.</a>
<a name="1618"><span class="lineNum">    1618 </span>            : ROSE_DLL_API void errorCheckingTargetAST (SgNode* node_copy, SgNode* node_original, SgFile* targetFile, bool failOnWarning);</a>
<a name="1619"><span class="lineNum">    1619 </span>            : </a>
<a name="1620"><span class="lineNum">    1620 </span>            : //@}</a>
<a name="1621"><span class="lineNum">    1621 </span>            : </a>
<a name="1622"><span class="lineNum">    1622 </span>            : </a>
<a name="1623"><span class="lineNum">    1623 </span>            : //----------------------------------------------------------</a>
<a name="1624"><span class="lineNum">    1624 </span>            : //@{</a>
<a name="1625"><span class="lineNum">    1625 </span>            : /*! @name Untyped IR Node Build Interfaces</a>
<a name="1626"><span class="lineNum">    1626 </span>            :     \brief  Build function for ROSE AST's in terms of Untyped IR nodes.</a>
<a name="1627"><span class="lineNum">    1627 </span>            : </a>
<a name="1628"><span class="lineNum">    1628 </span>            : The ROSE Untyped IR nodes can be a starting place for defining the new language frontend, these IR nodes</a>
<a name="1629"><span class="lineNum">    1629 </span>            : address the interface from an external language parser and the construction of the ROSE Untyped AST.</a>
<a name="1630"><span class="lineNum">    1630 </span>            : Later iterations on the ROSE Untyped AST can be used to translate (or construct) a proper ROSE AST in</a>
<a name="1631"><span class="lineNum">    1631 </span>            : terms of non-untyped IR nodes.</a>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<a name="1633"><span class="lineNum">    1633 </span>            : All untyped IR nodes have been removed and this interface removed. Ultimately it proved easier to</a>
<a name="1634"><span class="lineNum">    1634 </span>            : construct regular IR nodes from the Jovial parser. Using the untyped system just led to an</a>
<a name="1635"><span class="lineNum">    1635 </span>            : unnecessary step and wasted effort.</a>
<a name="1636"><span class="lineNum">    1636 </span>            : </a>
<a name="1637"><span class="lineNum">    1637 </span>            : */</a>
<a name="1638"><span class="lineNum">    1638 </span>            : //@}</a>
<a name="1639"><span class="lineNum">    1639 </span>            : </a>
<a name="1640"><span class="lineNum">    1640 </span>            : </a>
<a name="1641"><span class="lineNum">    1641 </span>            : </a>
<a name="1642"><span class="lineNum">    1642 </span>            :  //----------------------build unary expressions----------------------</a>
<a name="1643"><span class="lineNum">    1643 </span>            : //!  Template function to build a unary expression of type T. Instantiated functions include:buildAddressOfOp(),buildBitComplementOp(),buildBitComplementOp(),buildMinusOp(),buildNotOp(),buildPointerDerefExp(),buildUnaryAddOp(),buildMinusMinusOp(),buildPlusPlusOp().  They are also used for the unary vararg operators (which are not technically unary operators).</a>
<a name="1644"><span class="lineNum">    1644 </span>            : /*! The instantiated functions' prototypes are not shown since they are expanded using macros.</a>
<a name="1645"><span class="lineNum">    1645 </span>            :  * Doxygen is not smart enough to handle macro expansion.</a>
<a name="1646"><span class="lineNum">    1646 </span>            :  */</a>
<a name="1647"><span class="lineNum">    1647 </span>            : </a>
<a name="1648"><span class="lineNum">    1648 </span>            : template &lt;class T&gt;</a>
<a name="1649"><span class="lineNum">    1649 </span><span class="lineCov">         15 :   T* buildUnaryExpression(SgExpression* operand) {</span></a>
<a name="1650"><span class="lineNum">    1650 </span><span class="lineCov">         15 :   SgExpression* myoperand=operand;</span></a>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineCov">         15 :   T* result = new T(myoperand, NULL);</span></a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineCov">         15 :   ROSE_ASSERT(result);</span></a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineCov">         15 :   if (myoperand!=NULL) {</span></a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineCov">         15 :     myoperand-&gt;set_parent(result);</span></a>
<a name="1655"><span class="lineNum">    1655 </span>            :     // set lvalue, it asserts operand!=NULL</a>
<a name="1656"><span class="lineNum">    1656 </span><span class="lineCov">         15 :     markLhsValues(result);</span></a>
<a name="1657"><span class="lineNum">    1657 </span>            :   }</a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineCov">         15 :   SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="1659"><span class="lineNum">    1659 </span><span class="lineCov">         15 :   return result;</span></a>
<a name="1660"><span class="lineNum">    1660 </span>            :  }</a>
<a name="1661"><span class="lineNum">    1661 </span>            : </a>
<a name="1662"><span class="lineNum">    1662 </span>            : //!  Template function to build a unary expression of type T with no file info. Instantiated functions include:buildAddressOfOp(),buildBitComplementOp(),buildBitComplementOp(),buildMinusOp(),buildNotOp(),buildPointerDerefExp(),buildUnaryAddOp(),buildMinusMinusOp(),buildPlusPlusOp().  They are also used for the unary vararg operators (which are not technically unary operators).</a>
<a name="1663"><span class="lineNum">    1663 </span>            : /*! The instantiated functions' prototypes are not shown since they are expanded using macros.</a>
<a name="1664"><span class="lineNum">    1664 </span>            :  * Doxygen is not smart enough to handle macro expansion.</a>
<a name="1665"><span class="lineNum">    1665 </span>            :  */</a>
<a name="1666"><span class="lineNum">    1666 </span>            : template &lt;class T&gt;</a>
<a name="1667"><span class="lineNum">    1667 </span><span class="lineCov">       9831 : T* buildUnaryExpression_nfi(SgExpression* operand) {</span></a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineCov">       9831 :   SgExpression* myoperand = operand;</span></a>
<a name="1669"><span class="lineNum">    1669 </span><span class="lineCov">       9831 :   T* result = new T(myoperand, NULL);</span></a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">       9831 :   ROSE_ASSERT(result);</span></a>
<a name="1671"><span class="lineNum">    1671 </span>            : </a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineCov">       9831 :   if (myoperand != NULL) {</span></a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineCov">       9831 :     myoperand-&gt;set_parent(result);</span></a>
<a name="1674"><span class="lineNum">    1674 </span>            :     // set lvalue, it asserts operand!=NULL</a>
<a name="1675"><span class="lineNum">    1675 </span><span class="lineCov">       9831 :     markLhsValues(result);</span></a>
<a name="1676"><span class="lineNum">    1676 </span>            :   }</a>
<a name="1677"><span class="lineNum">    1677 </span><span class="lineCov">       9831 :   SageInterface::setSourcePosition(result);</span></a>
<a name="1678"><span class="lineNum">    1678 </span>            : </a>
<a name="1679"><span class="lineNum">    1679 </span><span class="lineCov">       9831 :   result-&gt;set_need_paren(false);</span></a>
<a name="1680"><span class="lineNum">    1680 </span><span class="lineCov">       9831 :   return result;</span></a>
<a name="1681"><span class="lineNum">    1681 </span>            :  }</a>
<a name="1682"><span class="lineNum">    1682 </span>            : </a>
<a name="1683"><span class="lineNum">    1683 </span>            : //---------------------binary expressions-----------------------</a>
<a name="1684"><span class="lineNum">    1684 </span>            : </a>
<a name="1685"><span class="lineNum">    1685 </span>            : //! Template function to build a binary expression of type T, taking care of parent pointers, file info, lvalue, etc. Available instances include: buildAddOp(), buildAndAssignOp(), buildAndOp(), buildArrowExp(),buildArrowStarOp(),buildAtOp, buildAssignOp(),buildBitAndOp(),buildBitOrOp(),buildBitXorOp(),buildCommaOpExp(), buildConcatenationOp(),buildDivAssignOp(),buildDivideOp(),buildDotExp(),buildEqualityOp(),buildExponentiationOp(),buildGreaterOrEqualOp(),buildGreaterThanOp(),buildIntegerDivideOp(),buildIorAssignOp(),buildLessOrEqualOp(),buildLessThanOp(),buildLshiftAssignOp(),buildLshiftOp(),buildMinusAssignOp(),buildModAssignOp(),buildModOp(),buildMultAssignOp(),buildMultiplyOp(),buildNotEqualOp(),buildOrOp(),buildPlusAssignOp(),buildPntrArrRefExp(),buildRshiftAssignOp(),buildRshiftOp(),buildReplicationOp,buildScopeOp(),buildSubtractOp()buildXorAssignOp()</a>
<a name="1686"><span class="lineNum">    1686 </span>            : /*! The instantiated functions' prototypes are not shown since they are expanded using macros.</a>
<a name="1687"><span class="lineNum">    1687 </span>            :  * Doxygen is not smart enough to handle macro expansion.</a>
<a name="1688"><span class="lineNum">    1688 </span>            :  */</a>
<a name="1689"><span class="lineNum">    1689 </span>            :  template &lt;class T&gt;</a>
<a name="1690"><span class="lineNum">    1690 </span><span class="lineCov">       1035 :    T* buildBinaryExpression(SgExpression* lhs, SgExpression* rhs) {</span></a>
<a name="1691"><span class="lineNum">    1691 </span>            :    SgExpression* mylhs, *myrhs;</a>
<a name="1692"><span class="lineNum">    1692 </span><span class="lineCov">       1035 :    mylhs = lhs;</span></a>
<a name="1693"><span class="lineNum">    1693 </span><span class="lineCov">       1035 :    myrhs = rhs;</span></a>
<a name="1694"><span class="lineNum">    1694 </span><span class="lineCov">       1035 :    T* result = new T(mylhs,myrhs, NULL);</span></a>
<a name="1695"><span class="lineNum">    1695 </span><span class="lineCov">       1035 :    ROSE_ASSERT(result);</span></a>
<a name="1696"><span class="lineNum">    1696 </span><span class="lineCov">       1035 :    if (mylhs!=NULL) {</span></a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">       1034 :      mylhs-&gt;set_parent(result);</span></a>
<a name="1698"><span class="lineNum">    1698 </span>            :      // set lvalue</a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineCov">       1034 :      markLhsValues(result);</span></a>
<a name="1700"><span class="lineNum">    1700 </span>            :    }</a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineCov">       1035 :    if (myrhs!=NULL) myrhs-&gt;set_parent(result);</span></a>
<a name="1702"><span class="lineNum">    1702 </span><span class="lineCov">       1035 :    SageInterface::setOneSourcePositionForTransformation(result);</span></a>
<a name="1703"><span class="lineNum">    1703 </span><span class="lineCov">       1035 :    return result;</span></a>
<a name="1704"><span class="lineNum">    1704 </span>            :  }</a>
<a name="1705"><span class="lineNum">    1705 </span>            : </a>
<a name="1706"><span class="lineNum">    1706 </span>            : //! Template function to build a binary expression of type T, taking care of parent pointers, but without file-info. Available instances include: buildAddOp(), buildAndAssignOp(), buildAndOp(), buildArrowExp(),buildArrowStarOp(),buildAtOp, buildAssignOp(),buildBitAndOp(),buildBitOrOp(),buildBitXorOp(),buildCommaOpExp(), buildConcatenationOp(),buildDivAssignOp(),buildDivideOp(),buildDotExp(),buildEqualityOp(),buildExponentiationOp(),buildGreaterOrEqualOp(),buildGreaterThanOp(),buildIntegerDivideOp(),buildIorAssignOp(),buildLessOrEqualOp(),buildLessThanOp(),buildLshiftAssignOp(),buildLshiftOp(),buildMinusAssignOp(),buildModAssignOp(),buildModOp(),buildMultAssignOp(),buildMultiplyOp(),buildNotEqualOp(),buildOrOp(),buildPlusAssignOp(),buildPntrArrRefExp(),buildRshiftAssignOp(),buildRshiftOp(),buildReplicationOp(),buildScopeOp(),buildSubtractOp()buildXorAssignOp()</a>
<a name="1707"><span class="lineNum">    1707 </span>            : /*! The instantiated functions' prototypes are not shown since they are expanded using macros.</a>
<a name="1708"><span class="lineNum">    1708 </span>            :  * Doxygen is not smart enough to handle macro expansion.</a>
<a name="1709"><span class="lineNum">    1709 </span>            :  */</a>
<a name="1710"><span class="lineNum">    1710 </span>            :  template &lt;class T&gt;</a>
<a name="1711"><span class="lineNum">    1711 </span><span class="lineCov">      51590 :    T* buildBinaryExpression_nfi(SgExpression* lhs, SgExpression* rhs) {</span></a>
<a name="1712"><span class="lineNum">    1712 </span>            :    SgExpression* mylhs, *myrhs;</a>
<a name="1713"><span class="lineNum">    1713 </span><span class="lineCov">      51590 :    mylhs = lhs;</span></a>
<a name="1714"><span class="lineNum">    1714 </span><span class="lineCov">      51590 :    myrhs = rhs;</span></a>
<a name="1715"><span class="lineNum">    1715 </span><span class="lineCov">      51590 :    T* result = new T(mylhs,myrhs, NULL);</span></a>
<a name="1716"><span class="lineNum">    1716 </span><span class="lineCov">      51590 :    ROSE_ASSERT(result);</span></a>
<a name="1717"><span class="lineNum">    1717 </span><span class="lineCov">      51590 :    if (mylhs!=NULL)  {</span></a>
<a name="1718"><span class="lineNum">    1718 </span><span class="lineCov">      51590 :     mylhs-&gt;set_parent(result);</span></a>
<a name="1719"><span class="lineNum">    1719 </span>            :     // set lvalue</a>
<a name="1720"><span class="lineNum">    1720 </span><span class="lineCov">      51590 :     markLhsValues(result);</span></a>
<a name="1721"><span class="lineNum">    1721 </span>            :    }</a>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineCov">      51590 :    if (myrhs!=NULL) myrhs-&gt;set_parent(result);</span></a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineCov">      51590 :    SageInterface::setSourcePosition(result);</span></a>
<a name="1724"><span class="lineNum">    1724 </span><span class="lineCov">      51590 :    result-&gt;set_need_paren(false);</span></a>
<a name="1725"><span class="lineNum">    1725 </span>            : </a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineCov">      51590 :    return result;</span></a>
<a name="1727"><span class="lineNum">    1727 </span>            :  }</a>
<a name="1728"><span class="lineNum">    1728 </span>            : </a>
<a name="1729"><span class="lineNum">    1729 </span>            : } // end of namespace</a>
<a name="1730"><span class="lineNum">    1730 </span>            : </a>
<a name="1731"><span class="lineNum">    1731 </span>            : #endif //ROSE_SAGE_BUILDER_INTERFACE</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
