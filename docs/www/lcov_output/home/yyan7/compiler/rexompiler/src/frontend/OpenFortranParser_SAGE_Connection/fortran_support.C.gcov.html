<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ROSE - /home/yyan7/compiler/rexompiler/src/frontend/OpenFortranParser_SAGE_Connection/fortran_support.C</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">home/yyan7/compiler/rexompiler/src/frontend/OpenFortranParser_SAGE_Connection</a> - fortran_support.C<span style="font-size: 80%;"> (source / <a href="fortran_support.C.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ROSE</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">994</td>
            <td class="headerCovTableEntry">2247</td>
            <td class="headerCovTableEntryLo">44.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2022-12-08 13:48:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntry">90</td>
            <td class="headerCovTableEntryLo">63.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;sage3basic.h&quot;</a>
<a name="2"><span class="lineNum">       2 </span>            : </a>
<a name="3"><span class="lineNum">       3 </span>            : // DQ (10/14/2010):  This should only be included by source files that require it.</a>
<a name="4"><span class="lineNum">       4 </span>            : // This fixed a reported bug which caused conflicts with autoconf macros (e.g. PACKAGE_BUGREPORT).</a>
<a name="5"><span class="lineNum">       5 </span>            : // Interestingly it must be at the top of the list of include files.</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &quot;rose_config.h&quot;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : #include &quot;fortran_support.h&quot;</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : // FMZ: Location of global variables</a>
<a name="11"><span class="lineNum">      11 </span>            : #include &quot;FortranParserState.h&quot;</a>
<a name="12"><span class="lineNum">      12 </span>            : </a>
<a name="13"><span class="lineNum">      13 </span>            : SgSourceFile* OpenFortranParser_globalFilePointer = NULL;</a>
<a name="14"><span class="lineNum">      14 </span>            : </a>
<a name="15"><span class="lineNum">      15 </span>            : using namespace std;</a>
<a name="16"><span class="lineNum">      16 </span>            : using namespace Rose;</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : std::list&lt;SgInterfaceStatement*&gt; astInterfaceStack;</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : #include &quot;token.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : </a>
<a name="22"><span class="lineNum">      22 </span><span class="lineCov">       5304 : Token_t *create_token(int line, int col, int type, const char *text)</span></a>
<a name="23"><span class="lineNum">      23 </span>            :   {</a>
<a name="24"><span class="lineNum">      24 </span><span class="lineCov">       5304 :          Token_t *tmp_token = NULL;</span></a>
<a name="25"><span class="lineNum">      25 </span>            : </a>
<a name="26"><span class="lineNum">      26 </span>            :       // DQ (11/5/2016): Can't use C++ &quot;delete&quot; in token.c file from OFP jar file since it is compiled using a C compiler (so use malloc here).</a>
<a name="27"><span class="lineNum">      27 </span>            :       // DQ (11/5/2016): Updated the token.c file in the OFP jar file to fix this bug and make the new (here) consistant with the delete (there).</a>
<a name="28"><span class="lineNum">      28 </span>            :       // DQ (11/4/2016): Since in the OFP this is deleted using free (token.c in the build tree), we want </a>
<a name="29"><span class="lineNum">      29 </span>            :       // to allocate it using the associated C style malloc (bug caught using address sanitizer).</a>
<a name="30"><span class="lineNum">      30 </span>            :       // DQ (9/11/2011): We want to use the C++ new and delete memory allocation </a>
<a name="31"><span class="lineNum">      31 </span>            :       // and not mix C's malloc/free with C++'s new/delete mechanisms.</a>
<a name="32"><span class="lineNum">      32 </span>            :       // tmp_token = (Token_t*) malloc(sizeof(Token_t));</a>
<a name="33"><span class="lineNum">      33 </span>            :       // tmp_token = new Token_t();</a>
<a name="34"><span class="lineNum">      34 </span><span class="lineCov">       5304 :          tmp_token = (Token_t*) malloc(sizeof(Token_t));</span></a>
<a name="35"><span class="lineNum">      35 </span><span class="lineCov">       5304 :          ROSE_ASSERT(tmp_token != NULL);</span></a>
<a name="36"><span class="lineNum">      36 </span><span class="lineCov">       5304 :          tmp_token-&gt;line = line;</span></a>
<a name="37"><span class="lineNum">      37 </span><span class="lineCov">       5304 :          tmp_token-&gt;col = col;</span></a>
<a name="38"><span class="lineNum">      38 </span><span class="lineCov">       5304 :          tmp_token-&gt;type = type;</span></a>
<a name="39"><span class="lineNum">      39 </span>            :  /* Make a copy of our own to make sure it isn't freed on us.  */</a>
<a name="40"><span class="lineNum">      40 </span><span class="lineCov">       5304 :     if (text != NULL)</span></a>
<a name="41"><span class="lineNum">      41 </span><span class="lineCov">       5304 :          tmp_token-&gt;text = strdup(text);</span></a>
<a name="42"><span class="lineNum">      42 </span>            :       else</a>
<a name="43"><span class="lineNum">      43 </span><span class="lineNoCov">          0 :          tmp_token-&gt;text = NULL;</span></a>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<a name="45"><span class="lineNum">      45 </span><span class="lineCov">       5304 :          return tmp_token;</span></a>
<a name="46"><span class="lineNum">      46 </span>            :   }</a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span>            : </a>
<a name="49"><span class="lineNum">      49 </span>            : string</a>
<a name="50"><span class="lineNum">      50 </span><span class="lineCov">       3360 : getCurrentFilename()</span></a>
<a name="51"><span class="lineNum">      51 </span>            :    {</a>
<a name="52"><span class="lineNum">      52 </span>            :   // DQ (12/18/2008): Added comment:  This function supports the Fortran &quot;include&quot; </a>
<a name="53"><span class="lineNum">      53 </span>            :   // mechanism and is independent of the CPP specific &quot;#include&quot; mechanism.</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span><span class="lineCov">       3360 :      string filename;</span></a>
<a name="56"><span class="lineNum">      56 </span>            :   // ROSE_ASSERT (astIncludeStack.empty() == false);</a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span><span class="lineCov">       3360 :      if (astIncludeStack.size() &lt;= 1)</span></a>
<a name="59"><span class="lineNum">      59 </span>            :         {</a>
<a name="60"><span class="lineNum">      60 </span>            :        // Note that the original source file in OFP does not have to use an absolute file name so use the one from ROSE.</a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">       1300 :           filename = OpenFortranParser_globalFilePointer-&gt;get_sourceFileNameWithPath();</span></a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">       1300 :           if (OpenFortranParser_globalFilePointer-&gt;get_requires_C_preprocessor() == true)</span></a>
<a name="64"><span class="lineNum">      64 </span>            :              {</a>
<a name="65"><span class="lineNum">      65 </span>            :             // This source file requires CPP processing, so this would be the generated file with the &quot;_preprocessed.f*&quot; suffix.</a>
<a name="66"><span class="lineNum">      66 </span><span class="lineNoCov">          0 :                filename = OpenFortranParser_globalFilePointer-&gt;generate_C_preprocessor_intermediate_filename(filename);</span></a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            :             // printf (&quot;##### Using filename = %s for the name in the file_info for a CPP generated file \n&quot;,filename.c_str());</a>
<a name="69"><span class="lineNum">      69 </span>            :              }</a>
<a name="70"><span class="lineNum">      70 </span>            :         }</a>
<a name="71"><span class="lineNum">      71 </span>            :        else</a>
<a name="72"><span class="lineNum">      72 </span>            :         {</a>
<a name="73"><span class="lineNum">      73 </span>            :        // If the astIncludeStack.size() &gt; 1 then we are in an include file and we need to get the filename so that </a>
<a name="74"><span class="lineNum">      74 </span>            :        // we can associate the source position with the correct file.</a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">       2060 :           filename = astIncludeStack.back();</span></a>
<a name="76"><span class="lineNum">      76 </span>            :         }</a>
<a name="77"><span class="lineNum">      77 </span>            : </a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">       3360 :      return filename;</span></a>
<a name="79"><span class="lineNum">      79 </span>            :    }</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            : void</a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">       1786 : setSourcePosition( SgLocatedNode* locatedNode )</span></a>
<a name="83"><span class="lineNum">      83 </span>            :    {</a>
<a name="84"><span class="lineNum">      84 </span>            :   // This function sets the source position to be marked as not available (since we often don't have token information)</a>
<a name="85"><span class="lineNum">      85 </span>            :   // These nodes WILL be unparsed in the code generation phase.</a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">       1786 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            :   // Make sure we never try to reset the source position of the global scope (set elsewhere in ROSE).</a>
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">       1786 :      ROSE_ASSERT(isSgGlobal(locatedNode) == NULL);</span></a>
<a name="92"><span class="lineNum">      92 </span>            : </a>
<a name="93"><span class="lineNum">      93 </span>            :   // Check the endOfConstruct first since it is most likely NULL (helpful in debugging)</a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">       1786 :      if (locatedNode-&gt;get_endOfConstruct() != NULL || locatedNode-&gt;get_startOfConstruct() != NULL)</span></a>
<a name="95"><span class="lineNum">      95 </span>            :         {</a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition(SgLocatedNode* locatedNode): locatedNode = %p = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</span></a>
<a name="97"><span class="lineNum">      97 </span>            :         }</a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">       1786 :      ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct()   == NULL);</span></a>
<a name="99"><span class="lineNum">      99 </span><span class="lineCov">       1786 :      ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() == NULL);</span></a>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<a name="101"><span class="lineNum">     101 </span>            :   // DQ (2/25/2013): Use the SageInterface::setSourcePosition() function since it is the interface </a>
<a name="102"><span class="lineNum">     102 </span>            :   // into the source position support in SageInterface.  This makes the use consistant with that of</a>
<a name="103"><span class="lineNum">     103 </span>            :   // the new C11/C++11 work.</a>
<a name="104"><span class="lineNum">     104 </span>            :   // Call a mechanism defined in the SageInterface support</a>
<a name="105"><span class="lineNum">     105 </span>            :   // SageInterface::setSourcePosition(locatedNode);</a>
<a name="106"><span class="lineNum">     106 </span>            :   // Liao, 11/12/2012. The semantics of SageInterface::setSourcePosition() has changed, which now relies on an internal model variable </a>
<a name="107"><span class="lineNum">     107 </span>            :   // (default to transformation generated file info, which does not fit to this context).</a>
<a name="108"><span class="lineNum">     108 </span>            :   // So we directly use the real function we want: set to default position info.</a>
<a name="109"><span class="lineNum">     109 </span>            :   // SageInterface::setSourcePositionToDefault(locatedNode);</a>
<a name="110"><span class="lineNum">     110 </span><span class="lineCov">       1786 :      SageInterface::setSourcePosition(locatedNode);</span></a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">       1786 :    }</span></a>
<a name="112"><span class="lineNum">     112 </span>            : </a>
<a name="113"><span class="lineNum">     113 </span>            : void</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 : setSourceEndPosition  ( SgLocatedNode* locatedNode, Token_t* token )</span></a>
<a name="115"><span class="lineNum">     115 </span>            :    {</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :      string filename = getCurrentFilename();</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :      locatedNode-&gt;set_endOfConstruct(new Sg_File_Info(filename,token-&gt;line, token-&gt;col));</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :      locatedNode-&gt;get_endOfConstruct()-&gt;set_parent(locatedNode);</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            : void</a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 : setSourcePositionCompilerGenerated( SgLocatedNode* locatedNode )</span></a>
<a name="123"><span class="lineNum">     123 </span>            :    {</a>
<a name="124"><span class="lineNum">     124 </span>            :   // This function sets the source position to be marked as compiler generated.</a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="128"><span class="lineNum">     128 </span>            : </a>
<a name="129"><span class="lineNum">     129 </span>            : #if 0</a>
<a name="130"><span class="lineNum">     130 </span>            :      printf (&quot;In setSourcePositionCompilerGenerated(): locatedNode = %p = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</a>
<a name="131"><span class="lineNum">     131 </span>            : #endif</a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            :   // Check the endOfConstruct first since it is most likely NULL (helpful in debugging)</a>
<a name="134"><span class="lineNum">     134 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :      locatedNode-&gt;get_startOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :      locatedNode-&gt;get_endOfConstruct()-&gt;setCompilerGenerated();</span></a>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span>            :   // DQ (2/15/2013): Added support to set the operatorPosition source position consistantly.</a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :      SgExpression* expression = isSgExpression(locatedNode);</span></a>
<a name="142"><span class="lineNum">     142 </span><span class="lineNoCov">          0 :      if (expression != NULL)</span></a>
<a name="143"><span class="lineNum">     143 </span>            :         {</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(expression-&gt;get_operatorPosition() != NULL);</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :           expression-&gt;get_operatorPosition()-&gt;setCompilerGenerated();</span></a>
<a name="146"><span class="lineNum">     146 </span>            :         }</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            : void</a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">         33 : setSourcePosition( SgInitializedName* initializedName )</span></a>
<a name="151"><span class="lineNum">     151 </span>            :    {</a>
<a name="152"><span class="lineNum">     152 </span>            :   // This function sets the source position to be marked as not available (since we often don't have token information)</a>
<a name="153"><span class="lineNum">     153 </span>            :   // These nodes WILL be unparsed in the conde generation phase.</a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :   // Specifically, these will be marked as:</a>
<a name="156"><span class="lineNum">     156 </span>            :   //    1) isSourcePositionUnavailableInFrontend = true</a>
<a name="157"><span class="lineNum">     157 </span>            :   //    2) isOutputInCodeGeneration = true</a>
<a name="158"><span class="lineNum">     158 </span>            : </a>
<a name="159"><span class="lineNum">     159 </span>            :   // The SgInitializedName only has a startOfConstruct source position.</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineCov">         33 :      ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="161"><span class="lineNum">     161 </span>            :   // ROSE_ASSERT(initializedName-&gt;get_startOfConstruct() == NULL);</a>
<a name="162"><span class="lineNum">     162 </span>            :   // initializedName-&gt;set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());</a>
<a name="163"><span class="lineNum">     163 </span>            :   // initializedName-&gt;set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode());</a>
<a name="164"><span class="lineNum">     164 </span>            : </a>
<a name="165"><span class="lineNum">     165 </span><span class="lineCov">         33 :      if (initializedName-&gt;get_startOfConstruct() == NULL)</span></a>
<a name="166"><span class="lineNum">     166 </span>            :         {</a>
<a name="167"><span class="lineNum">     167 </span><span class="lineCov">         23 :           Sg_File_Info* fileInfo = new Sg_File_Info(getCurrentFilename(),0,0);</span></a>
<a name="168"><span class="lineNum">     168 </span><span class="lineCov">         23 :           fileInfo-&gt;setSourcePositionUnavailableInFrontend();</span></a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            :        // This is required for the unparser to output the code from the AST.</a>
<a name="171"><span class="lineNum">     171 </span><span class="lineCov">         23 :           fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span><span class="lineCov">         23 :           initializedName-&gt;set_startOfConstruct(fileInfo);</span></a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span><span class="lineCov">         23 :           initializedName-&gt;get_startOfConstruct()-&gt;set_parent(initializedName);</span></a>
<a name="176"><span class="lineNum">     176 </span>            :         }</a>
<a name="177"><span class="lineNum">     177 </span>            :        else</a>
<a name="178"><span class="lineNum">     178 </span>            :         {</a>
<a name="179"><span class="lineNum">     179 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 :                printf (&quot;Unnecessary call to setSourcePosition(SgInitializedName = %p = %s ) for start info. \n&quot;,initializedName,SageInterface::get_name(initializedName).c_str());</span></a>
<a name="181"><span class="lineNum">     181 </span>            :         }</a>
<a name="182"><span class="lineNum">     182 </span>            : </a>
<a name="183"><span class="lineNum">     183 </span>            :        // Liao 11/5/2010, add end file info</a>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">         33 :      if (initializedName-&gt;get_endOfConstruct() == NULL)</span></a>
<a name="185"><span class="lineNum">     185 </span>            :         {</a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">         23 :           Sg_File_Info* fileInfo = new Sg_File_Info(getCurrentFilename(),0,0);</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">         23 :           fileInfo-&gt;setSourcePositionUnavailableInFrontend();</span></a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :        // This is required for the unparser to output the code from the AST.</a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">         23 :           fileInfo-&gt;setOutputInCodeGeneration();</span></a>
<a name="191"><span class="lineNum">     191 </span>            : </a>
<a name="192"><span class="lineNum">     192 </span><span class="lineCov">         23 :           initializedName-&gt;set_endOfConstruct(fileInfo);</span></a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span><span class="lineCov">         23 :           initializedName-&gt;get_endOfConstruct()-&gt;set_parent(initializedName);</span></a>
<a name="195"><span class="lineNum">     195 </span>            :         }</a>
<a name="196"><span class="lineNum">     196 </span>            :        else</a>
<a name="197"><span class="lineNum">     197 </span>            :         {</a>
<a name="198"><span class="lineNum">     198 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :                printf (&quot;Unnecessary call to setSourcePosition(SgInitializedName = %p = %s ) for end info. \n&quot;,initializedName,SageInterface::get_name(initializedName).c_str());</span></a>
<a name="200"><span class="lineNum">     200 </span>            :         }</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">         33 :    }</span></a>
<a name="204"><span class="lineNum">     204 </span>            : </a>
<a name="205"><span class="lineNum">     205 </span>            : void</a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">         54 : setSourcePosition( SgLocatedNode* locatedNode, const TokenListType &amp; tokenList )</span></a>
<a name="207"><span class="lineNum">     207 </span>            :    {</a>
<a name="208"><span class="lineNum">     208 </span>            :   // printf (&quot;In setSourcePosition locatedNode = %p = %s tokenList.size() = %ld \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),tokenList.size());</a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">         54 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="212"><span class="lineNum">     212 </span>            : </a>
<a name="213"><span class="lineNum">     213 </span>            :   // Get the first and last tokens from the token list (information about middle tokens </a>
<a name="214"><span class="lineNum">     214 </span>            :   // is held in the token strean to be attached to the AST).</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">         54 :      const Token_t* firstToken = tokenList.front();</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">         54 :      const Token_t* lastToken  = tokenList.back();</span></a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">         54 :      ROSE_ASSERT(firstToken != NULL);</span></a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">         54 :      ROSE_ASSERT(lastToken  != NULL);</span></a>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">         54 :      ROSE_ASSERT(firstToken-&gt;text != NULL);</span></a>
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">         54 :      ROSE_ASSERT(lastToken-&gt;text  != NULL);</span></a>
<a name="223"><span class="lineNum">     223 </span>            : </a>
<a name="224"><span class="lineNum">     224 </span>            :   // printf (&quot;firstToken-&gt;text = %s \n&quot;,firstToken-&gt;text);</a>
<a name="225"><span class="lineNum">     225 </span>            :   // printf (&quot;lastToken-&gt;text  = %s \n&quot;,lastToken-&gt;text);</a>
<a name="226"><span class="lineNum">     226 </span>            : </a>
<a name="227"><span class="lineNum">     227 </span><span class="lineCov">         54 :      ROSE_ASSERT(firstToken-&gt;line &gt; 0);</span></a>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">         54 :      ROSE_ASSERT(lastToken-&gt;line  &gt; 0);</span></a>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<a name="230"><span class="lineNum">     230 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineCov">         54 :      string filename = getCurrentFilename();</span></a>
<a name="232"><span class="lineNum">     232 </span>            : </a>
<a name="233"><span class="lineNum">     233 </span><span class="lineCov">         54 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="234"><span class="lineNum">     234 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition(%p = %s) line = %d column = %d filename = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),firstToken-&gt;line,firstToken-&gt;col,filename.c_str());</span></a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">         54 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="237"><span class="lineNum">     237 </span>            : </a>
<a name="238"><span class="lineNum">     238 </span>            :   // DQ (1/23/2008): New assertions</a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">         54 :      if (locatedNode-&gt;get_startOfConstruct() != NULL)</span></a>
<a name="240"><span class="lineNum">     240 </span>            :         {</a>
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: removing predefined START Sg_File_Info object in locatedNode = %p = %s = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),SageInterface::get_name(locatedNode).c_str());</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineNoCov">          0 :           delete locatedNode-&gt;get_startOfConstruct();</span></a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :           locatedNode-&gt;set_startOfConstruct(NULL);</span></a>
<a name="244"><span class="lineNum">     244 </span>            :         }</a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            :   // DQ (1/23/2008): New assertions</a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">         54 :      if (locatedNode-&gt;get_endOfConstruct() != NULL)</span></a>
<a name="248"><span class="lineNum">     248 </span>            :         {</a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: removing predefined END Sg_File_Info object in locatedNode = %p = %s = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),SageInterface::get_name(locatedNode).c_str());</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :           delete locatedNode-&gt;get_endOfConstruct();</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :           locatedNode-&gt;set_endOfConstruct(NULL);</span></a>
<a name="252"><span class="lineNum">     252 </span>            :         }</a>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<a name="254"><span class="lineNum">     254 </span>            :   // DQ (1/23/2008): New assertions</a>
<a name="255"><span class="lineNum">     255 </span><span class="lineCov">         54 :      ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() == NULL);</span></a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">         54 :      ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct()   == NULL);</span></a>
<a name="257"><span class="lineNum">     257 </span>            : </a>
<a name="258"><span class="lineNum">     258 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="259"><span class="lineNum">     259 </span><span class="lineCov">         54 :      locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(filename,firstToken-&gt;line,firstToken-&gt;col));</span></a>
<a name="260"><span class="lineNum">     260 </span><span class="lineCov">         54 :      locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(filename,lastToken-&gt;line, lastToken-&gt;col));</span></a>
<a name="261"><span class="lineNum">     261 </span>            : </a>
<a name="262"><span class="lineNum">     262 </span><span class="lineCov">         54 :      locatedNode-&gt;get_startOfConstruct()-&gt;set_parent(locatedNode);</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">         54 :      locatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(locatedNode);</span></a>
<a name="264"><span class="lineNum">     264 </span>            : </a>
<a name="265"><span class="lineNum">     265 </span>            :   // DQ (2/15/2013): Added support to set the operatorPosition source position consistantly.</a>
<a name="266"><span class="lineNum">     266 </span><span class="lineCov">         54 :      SgExpression* expression = isSgExpression(locatedNode);</span></a>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">         54 :      if (expression != NULL)</span></a>
<a name="268"><span class="lineNum">     268 </span>            :         {</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(expression-&gt;get_operatorPosition() != NULL);</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :           expression-&gt;get_operatorPosition()-&gt;updateSourcePosition(locatedNode-&gt;get_startOfConstruct());</span></a>
<a name="271"><span class="lineNum">     271 </span>            :         }</a>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">         54 :    }</span></a>
<a name="273"><span class="lineNum">     273 </span>            : </a>
<a name="274"><span class="lineNum">     274 </span>            : void</a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">        449 : setSourcePosition  ( SgInitializedName* initializedName, Token_t* token )</span></a>
<a name="276"><span class="lineNum">     276 </span>            :    {</a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">        449 :      if ( SgProject::get_verbose() &gt; 1 )</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition initializedName = %p = %s token = %p line = %d \n&quot;,initializedName,initializedName-&gt;get_name().str(),token,token != NULL ? token-&gt;line : -1);</span></a>
<a name="279"><span class="lineNum">     279 </span>            : </a>
<a name="280"><span class="lineNum">     280 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="281"><span class="lineNum">     281 </span><span class="lineCov">        449 :      ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="282"><span class="lineNum">     282 </span>            : </a>
<a name="283"><span class="lineNum">     283 </span><span class="lineCov">        449 :      ROSE_ASSERT(token != NULL);</span></a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">        449 :      ROSE_ASSERT(token-&gt;line &gt; 0);</span></a>
<a name="286"><span class="lineNum">     286 </span>            : </a>
<a name="287"><span class="lineNum">     287 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="288"><span class="lineNum">     288 </span><span class="lineCov">        449 :      string filename = getCurrentFilename();</span></a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span><span class="lineCov">        449 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="291"><span class="lineNum">     291 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition(SgInitializedName %p = %s) line = %d column = %d filename = %s \n&quot;,initializedName,initializedName-&gt;get_name().str(),token-&gt;line,token-&gt;col,filename.c_str());</span></a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span><span class="lineCov">        449 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="296"><span class="lineNum">     296 </span><span class="lineCov">        449 :      initializedName-&gt;set_startOfConstruct (new Sg_File_Info(filename,token-&gt;line,token-&gt;col));</span></a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span><span class="lineCov">        449 :      initializedName-&gt;get_startOfConstruct()-&gt;set_parent(initializedName);</span></a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span>            :    // Liao 11/5/2010, assuming the end info should be the same for now</a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">        449 :      initializedName-&gt;set_endOfConstruct (new Sg_File_Info(filename,token-&gt;line,token-&gt;col));</span></a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">        449 :      initializedName-&gt;get_endOfConstruct()-&gt;set_parent(initializedName);</span></a>
<a name="304"><span class="lineNum">     304 </span>            :    </a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">        449 :    }</span></a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span>            : void</a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">       2314 : setSourcePosition  ( SgLocatedNode* locatedNode, Token_t* token )</span></a>
<a name="309"><span class="lineNum">     309 </span>            :    {</a>
<a name="310"><span class="lineNum">     310 </span><span class="lineCov">       2314 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="311"><span class="lineNum">     311 </span>            :         {</a>
<a name="312"><span class="lineNum">     312 </span>            :        // DQ (1/26/2009): Output additional information as to what file we are in now that we support</a>
<a name="313"><span class="lineNum">     313 </span>            :        // more complex file include handling and we are testing more complex multi-file support.</a>
<a name="314"><span class="lineNum">     314 </span>            :        // printf (&quot;In setSourcePosition locatedNode = %p = %s token = %p line = %d \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),token,token != NULL ? token-&gt;line : -1);</a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition locatedNode = %p = %s token = %p (file = %s) line = %d \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),token,getCurrentFilename().c_str(),token != NULL ? token-&gt;line : -1);</span></a>
<a name="316"><span class="lineNum">     316 </span>            :         }</a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">       2314 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">       2314 :      ROSE_ASSERT(token != NULL);</span></a>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<a name="323"><span class="lineNum">     323 </span>            :   // DQ (12/11/2007): Modified to permit tokens to be built (as in R1219)</a>
<a name="324"><span class="lineNum">     324 </span>            :   //   ROSE_ASSERT(token-&gt;line &gt; 0);</a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">       2314 :      ROSE_ASSERT(token-&gt;line &gt;= 0);  // DXN (08/25/ 2011): FIXME - Workaround OFP bug that incorrectly returns a token with line number = 0, as in the following example:</span></a>
<a name="326"><span class="lineNum">     326 </span>            :      /*       subroutine FOURT()</a>
<a name="327"><span class="lineNum">     327 </span>            :       *       DO 125 I1=1, 2</a>
<a name="328"><span class="lineNum">     328 </span>            :       *       DO 125 I3= 3, 4</a>
<a name="329"><span class="lineNum">     329 </span>            :       * 125   CONTINUE</a>
<a name="330"><span class="lineNum">     330 </span>            :       *       END</a>
<a name="331"><span class="lineNum">     331 </span>            :       *</a>
<a name="332"><span class="lineNum">     332 </span>            :       *  Here the token is the label 125; when this label is parsed the second time around, label-&gt;line = 0 and label-&gt;col = -1</a>
<a name="333"><span class="lineNum">     333 </span>            :       */</a>
<a name="334"><span class="lineNum">     334 </span>            : </a>
<a name="335"><span class="lineNum">     335 </span>            :   // DQ (3/4/2013): Add a warning to support debuging this problem.</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">       2314 :      if (token-&gt;line == 0)</span></a>
<a name="337"><span class="lineNum">     337 </span>            :         {</a>
<a name="338"><span class="lineNum">     338 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: locatedNode = %p = %s using token-&gt;line == 0 to set source psoition information \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str());</span></a>
<a name="339"><span class="lineNum">     339 </span>            :         }</a>
<a name="340"><span class="lineNum">     340 </span>            : </a>
<a name="341"><span class="lineNum">     341 </span><span class="lineCov">       2314 :      if (locatedNode-&gt;get_startOfConstruct() != NULL)</span></a>
<a name="342"><span class="lineNum">     342 </span>            :         {</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: removing predefined START Sg_File_Info object in locatedNode = %p = %s = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),SageInterface::get_name(locatedNode).c_str());</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 :           delete locatedNode-&gt;get_startOfConstruct();</span></a>
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :           locatedNode-&gt;set_startOfConstruct(NULL);</span></a>
<a name="346"><span class="lineNum">     346 </span>            :         }</a>
<a name="347"><span class="lineNum">     347 </span>            : </a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">       2314 :      if (locatedNode-&gt;get_endOfConstruct() != NULL)</span></a>
<a name="349"><span class="lineNum">     349 </span>            :         {</a>
<a name="350"><span class="lineNum">     350 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: removing predefined END Sg_File_Info object in locatedNode = %p = %s = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),SageInterface::get_name(locatedNode).c_str());</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :           delete locatedNode-&gt;get_endOfConstruct();</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :           locatedNode-&gt;set_endOfConstruct(NULL);</span></a>
<a name="353"><span class="lineNum">     353 </span>            :         }</a>
<a name="354"><span class="lineNum">     354 </span>            : </a>
<a name="355"><span class="lineNum">     355 </span>            :   // DQ (1/23/2008): New assertions</a>
<a name="356"><span class="lineNum">     356 </span><span class="lineCov">       2314 :      ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() == NULL);</span></a>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">       2314 :      ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct() == NULL);</span></a>
<a name="358"><span class="lineNum">     358 </span>            : </a>
<a name="359"><span class="lineNum">     359 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">       2314 :      string filename = getCurrentFilename();</span></a>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">       2314 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition(SgInitializedName %p = %s) line = %d column = %d filename = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),token-&gt;line,token-&gt;col,filename.c_str());</span></a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">       2314 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<a name="367"><span class="lineNum">     367 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="368"><span class="lineNum">     368 </span><span class="lineCov">       2314 :      locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(filename,token-&gt;line,token-&gt;col));</span></a>
<a name="369"><span class="lineNum">     369 </span><span class="lineCov">       2314 :      locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(filename,token-&gt;line, token-&gt;col));</span></a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span><span class="lineCov">       2314 :      locatedNode-&gt;get_startOfConstruct()-&gt;set_parent(locatedNode);</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineCov">       2314 :      locatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(locatedNode);</span></a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            :   // DQ (2/15/2013): Added support to set the operatorPosition source position consistantly.</a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">       2314 :      SgExpression* expression = isSgExpression(locatedNode);</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">       2314 :      if (expression != NULL)</span></a>
<a name="377"><span class="lineNum">     377 </span>            :         {</a>
<a name="378"><span class="lineNum">     378 </span>            :        // ROSE_ASSERT(expression-&gt;get_operatorPosition() != NULL);</a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">        818 :           if (expression-&gt;get_operatorPosition() != NULL)</span></a>
<a name="380"><span class="lineNum">     380 </span>            :              {</a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :                expression-&gt;get_operatorPosition()-&gt;updateSourcePosition(locatedNode-&gt;get_startOfConstruct());</span></a>
<a name="382"><span class="lineNum">     382 </span>            :              }</a>
<a name="383"><span class="lineNum">     383 </span>            :             else</a>
<a name="384"><span class="lineNum">     384 </span>            :              {</a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">        818 :                expression-&gt;set_operatorPosition(new Sg_File_Info(filename,token-&gt;line,token-&gt;col));</span></a>
<a name="386"><span class="lineNum">     386 </span>            :              }</a>
<a name="387"><span class="lineNum">     387 </span>            :         }</a>
<a name="388"><span class="lineNum">     388 </span><span class="lineCov">       2314 :    }</span></a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span>            : void</a>
<a name="391"><span class="lineNum">     391 </span><span class="lineNoCov">          0 : setSourcePosition  ( SgInitializedName* initializedName, const TokenListType &amp; tokenList )</span></a>
<a name="392"><span class="lineNum">     392 </span>            :    {</a>
<a name="393"><span class="lineNum">     393 </span>            :   // printf (&quot;In setSourcePosition initializedName = %p = %s tokenList.size() = %ld \n&quot;,initializedName,initializedName-&gt;get_name().str(),tokenList.size());</a>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<a name="395"><span class="lineNum">     395 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<a name="398"><span class="lineNum">     398 </span>            :   // Get the first and last tokens from the token list (information about middle tokens </a>
<a name="399"><span class="lineNum">     399 </span>            :   // is held in the token strean to be attached to the AST).</a>
<a name="400"><span class="lineNum">     400 </span>            :   // const SgToken* firstToken = tokenList.front();</a>
<a name="401"><span class="lineNum">     401 </span>            :   // const SgToken* lastToken  = tokenList.back();</a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :      const Token_t* firstToken = tokenList.front();</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineNoCov">          0 :      const Token_t* lastToken  = tokenList.back();</span></a>
<a name="404"><span class="lineNum">     404 </span>            : </a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstToken != NULL);</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lastToken  != NULL);</span></a>
<a name="407"><span class="lineNum">     407 </span>            : </a>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstToken-&gt;line &gt; 0);</span></a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lastToken-&gt;line  &gt; 0);</span></a>
<a name="410"><span class="lineNum">     410 </span>            : </a>
<a name="411"><span class="lineNum">     411 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 :      string filename = getCurrentFilename();</span></a>
<a name="413"><span class="lineNum">     413 </span>            : </a>
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineNoCov">          0 :           printf (&quot;In setSourcePosition(SgInitializedName %p = %s) line = %d column = %d filename = %s \n&quot;,initializedName,initializedName-&gt;get_name().str(),firstToken-&gt;line,firstToken-&gt;col,filename.c_str());</span></a>
<a name="416"><span class="lineNum">     416 </span>            : </a>
<a name="417"><span class="lineNum">     417 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="418"><span class="lineNum">     418 </span>            : </a>
<a name="419"><span class="lineNum">     419 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="420"><span class="lineNum">     420 </span>            :   // locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(*(firstToken-&gt;get_startOfConstruct())));</a>
<a name="421"><span class="lineNum">     421 </span>            :   // locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(*(lastToken -&gt;get_endOfConstruct  ())));</a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :      initializedName-&gt;set_startOfConstruct (new Sg_File_Info(filename,firstToken-&gt;line,firstToken-&gt;col));</span></a>
<a name="423"><span class="lineNum">     423 </span>            : </a>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 :      initializedName-&gt;get_startOfConstruct()-&gt;set_parent(initializedName);</span></a>
<a name="425"><span class="lineNum">     425 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<a name="427"><span class="lineNum">     427 </span>            : </a>
<a name="428"><span class="lineNum">     428 </span>            : void</a>
<a name="429"><span class="lineNum">     429 </span><span class="lineCov">         24 : setOperatorSourcePosition  ( SgExpression* expr, Token_t* token )</span></a>
<a name="430"><span class="lineNum">     430 </span>            :    {</a>
<a name="431"><span class="lineNum">     431 </span>            :   // printf (&quot;In setOperatorSourcePosition expression = %p = %s token = %p \n&quot;,expr,expr-&gt;class_name().c_str(),token);</a>
<a name="432"><span class="lineNum">     432 </span>            : </a>
<a name="433"><span class="lineNum">     433 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="434"><span class="lineNum">     434 </span><span class="lineCov">         24 :      ROSE_ASSERT(expr != NULL);</span></a>
<a name="435"><span class="lineNum">     435 </span>            : </a>
<a name="436"><span class="lineNum">     436 </span><span class="lineCov">         24 :      ROSE_ASSERT(token != NULL);</span></a>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">         24 :      ROSE_ASSERT(token-&gt;line &gt; 0);</span></a>
<a name="439"><span class="lineNum">     439 </span>            : </a>
<a name="440"><span class="lineNum">     440 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">         24 :      string filename = getCurrentFilename();</span></a>
<a name="442"><span class="lineNum">     442 </span>            : </a>
<a name="443"><span class="lineNum">     443 </span><span class="lineCov">         24 :      if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :           printf (&quot;In setOperatorSourcePosition(SgExpression %p = %s) line = %d column = %d filename = %s \n&quot;,expr,expr-&gt;class_name().c_str(),token-&gt;line,token-&gt;col,filename.c_str());</span></a>
<a name="445"><span class="lineNum">     445 </span>            : </a>
<a name="446"><span class="lineNum">     446 </span><span class="lineCov">         24 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            :   // Set these based on the source position information from the operator token</a>
<a name="449"><span class="lineNum">     449 </span><span class="lineCov">         24 :      expr-&gt;set_operatorPosition (new Sg_File_Info(filename,token-&gt;line,token-&gt;col));</span></a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span><span class="lineCov">         24 :      expr-&gt;get_operatorPosition()-&gt;set_parent(expr);</span></a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">         24 :    }</span></a>
<a name="453"><span class="lineNum">     453 </span>            : </a>
<a name="454"><span class="lineNum">     454 </span>            : </a>
<a name="455"><span class="lineNum">     455 </span>            : </a>
<a name="456"><span class="lineNum">     456 </span>            : void</a>
<a name="457"><span class="lineNum">     457 </span><span class="lineNoCov">          0 : resetSourcePosition( SgLocatedNode* locatedNode, const TokenListType &amp; tokenList )</span></a>
<a name="458"><span class="lineNum">     458 </span>            :    {</a>
<a name="459"><span class="lineNum">     459 </span>            : #if 0</a>
<a name="460"><span class="lineNum">     460 </span>            :      printf (&quot;In resetSourcePosition locatedNode = %p = %s tokenList.size() = %ld \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),tokenList.size());</a>
<a name="461"><span class="lineNum">     461 </span>            : #endif</a>
<a name="462"><span class="lineNum">     462 </span>            : </a>
<a name="463"><span class="lineNum">     463 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode != NULL);</span></a>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<a name="466"><span class="lineNum">     466 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(locatedNode-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="468"><span class="lineNum">     468 </span>            : </a>
<a name="469"><span class="lineNum">     469 </span>            :   // Remove the existing Sg_File_Info objects, they will be reset below</a>
<a name="470"><span class="lineNum">     470 </span><span class="lineNoCov">          0 :      delete locatedNode-&gt;get_startOfConstruct();</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineNoCov">          0 :      delete locatedNode-&gt;get_endOfConstruct();</span></a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span>            :   // Get the first and last tokens from the token list (information about middle tokens </a>
<a name="474"><span class="lineNum">     474 </span>            :   // is held in the token strean to be attached to the AST).</a>
<a name="475"><span class="lineNum">     475 </span>            :   // const SgToken* firstToken = tokenList.front();</a>
<a name="476"><span class="lineNum">     476 </span>            :   // const SgToken* lastToken  = tokenList.back();</a>
<a name="477"><span class="lineNum">     477 </span><span class="lineNoCov">          0 :      const Token_t* firstToken = tokenList.front();</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :      const Token_t* lastToken  = tokenList.back();</span></a>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<a name="480"><span class="lineNum">     480 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstToken != NULL);</span></a>
<a name="481"><span class="lineNum">     481 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lastToken != NULL);</span></a>
<a name="482"><span class="lineNum">     482 </span>            : </a>
<a name="483"><span class="lineNum">     483 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(firstToken-&gt;line &gt; 0);</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(lastToken-&gt;line &gt; 0);</span></a>
<a name="485"><span class="lineNum">     485 </span>            : </a>
<a name="486"><span class="lineNum">     486 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :      string filename = getCurrentFilename();</span></a>
<a name="488"><span class="lineNum">     488 </span>            : </a>
<a name="489"><span class="lineNum">     489 </span>            :   // printf (&quot;In resetSourcePosition(%p = %s) filename = %s \n&quot;,locatedNode,locatedNode-&gt;class_name().c_str(),filename.c_str());</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<a name="492"><span class="lineNum">     492 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="493"><span class="lineNum">     493 </span>            :   // locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(*(firstToken-&gt;get_startOfConstruct())));</a>
<a name="494"><span class="lineNum">     494 </span>            :   // locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(*(lastToken -&gt;get_endOfConstruct  ())));</a>
<a name="495"><span class="lineNum">     495 </span><span class="lineNoCov">          0 :      locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(filename,firstToken-&gt;line,firstToken-&gt;col));</span></a>
<a name="496"><span class="lineNum">     496 </span><span class="lineNoCov">          0 :      locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(filename,lastToken-&gt;line, lastToken-&gt;col));</span></a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span><span class="lineNoCov">          0 :      locatedNode-&gt;get_startOfConstruct()-&gt;set_parent(locatedNode);</span></a>
<a name="499"><span class="lineNum">     499 </span><span class="lineNoCov">          0 :      locatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(locatedNode);</span></a>
<a name="500"><span class="lineNum">     500 </span>            : </a>
<a name="501"><span class="lineNum">     501 </span>            :   // DQ (2/15/2013): Added support to set the operatorPosition source position consistantly.</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineNoCov">          0 :      SgExpression* expression = isSgExpression(locatedNode);</span></a>
<a name="503"><span class="lineNum">     503 </span><span class="lineNoCov">          0 :      if (expression != NULL)</span></a>
<a name="504"><span class="lineNum">     504 </span>            :         {</a>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(expression-&gt;get_operatorPosition() != NULL);</span></a>
<a name="506"><span class="lineNum">     506 </span><span class="lineNoCov">          0 :           expression-&gt;get_operatorPosition()-&gt;updateSourcePosition(locatedNode-&gt;get_startOfConstruct());</span></a>
<a name="507"><span class="lineNum">     507 </span>            :         }</a>
<a name="508"><span class="lineNum">     508 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span>            : </a>
<a name="511"><span class="lineNum">     511 </span>            : void</a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">        141 : resetSourcePosition( SgLocatedNode* targetLocatedNode, const SgLocatedNode* sourceLocatedNode )</span></a>
<a name="513"><span class="lineNum">     513 </span>            :    {</a>
<a name="514"><span class="lineNum">     514 </span>            : #if 0</a>
<a name="515"><span class="lineNum">     515 </span>            :      printf (&quot;In resetSourcePosition targetLocatedNode = %p = %s sourceLocatedNode = %p = %s \n&quot;,</a>
<a name="516"><span class="lineNum">     516 </span>            :           targetLocatedNode,targetLocatedNode-&gt;class_name().c_str(),</a>
<a name="517"><span class="lineNum">     517 </span>            :           sourceLocatedNode,sourceLocatedNode-&gt;class_name().c_str());</a>
<a name="518"><span class="lineNum">     518 </span>            : #endif</a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            :   // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.</a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">        141 :      ROSE_ASSERT(targetLocatedNode != NULL);</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">        141 :      ROSE_ASSERT(sourceLocatedNode != NULL);</span></a>
<a name="523"><span class="lineNum">     523 </span>            : </a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">        141 :      ROSE_ASSERT(targetLocatedNode-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">        141 :      ROSE_ASSERT(targetLocatedNode-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">        141 :      ROSE_ASSERT(sourceLocatedNode-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">        141 :      ROSE_ASSERT(sourceLocatedNode-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="529"><span class="lineNum">     529 </span>            : </a>
<a name="530"><span class="lineNum">     530 </span>            :   // DQ (3/19/2017): Commented out to cleanup output spew.</a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">        141 :      if (sourceLocatedNode-&gt;get_startOfConstruct()-&gt;get_filenameString() == &quot;NULL_FILE&quot;)</span></a>
<a name="532"><span class="lineNum">     532 </span>            :         {</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: resetSourcePosition: sourceLocatedNode = %p = %s = %s \n&quot;,sourceLocatedNode,sourceLocatedNode-&gt;class_name().c_str(),SageInterface::get_name(sourceLocatedNode).c_str());</span></a>
<a name="534"><span class="lineNum">     534 </span>            : #if 0</a>
<a name="535"><span class="lineNum">     535 </span>            :           sourceLocatedNode-&gt;get_startOfConstruct()-&gt;display(&quot;get_filenameString() == NULL_FILE&quot;);</a>
<a name="536"><span class="lineNum">     536 </span>            : #endif</a>
<a name="537"><span class="lineNum">     537 </span>            :         }</a>
<a name="538"><span class="lineNum">     538 </span>            :   // ROSE_ASSERT(sourceLocatedNode-&gt;get_startOfConstruct()-&gt;get_filenameString() != &quot;NULL_FILE&quot;);</a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span>            :   // DQ (3/4/2013): Added test for zero line number.</a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">        141 :      if (sourceLocatedNode-&gt;get_startOfConstruct()-&gt;get_line() == 0)</span></a>
<a name="542"><span class="lineNum">     542 </span>            :         {</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 :           printf (&quot;WARNING: resetSourcePosition: sourceLocatedNode = %p = %s = %s \n&quot;,sourceLocatedNode,sourceLocatedNode-&gt;class_name().c_str(),SageInterface::get_name(sourceLocatedNode).c_str());</span></a>
<a name="544"><span class="lineNum">     544 </span>            : #if 0</a>
<a name="545"><span class="lineNum">     545 </span>            :           sourceLocatedNode-&gt;get_startOfConstruct()-&gt;display(&quot;get_line() == 0: debug&quot;);</a>
<a name="546"><span class="lineNum">     546 </span>            : #endif</a>
<a name="547"><span class="lineNum">     547 </span>            :         }</a>
<a name="548"><span class="lineNum">     548 </span>            :   // DQ (3/4/2013): We can't assert this since it fails to some test codes (e.g. test2010_120.f90).</a>
<a name="549"><span class="lineNum">     549 </span>            :   // ROSE_ASSERT(sourceLocatedNode-&gt;get_startOfConstruct()-&gt;get_line() != 0);</a>
<a name="550"><span class="lineNum">     550 </span>            : </a>
<a name="551"><span class="lineNum">     551 </span>            :   // Remove the existing Sg_File_Info objects, they will be reset below</a>
<a name="552"><span class="lineNum">     552 </span><span class="lineCov">        141 :      delete targetLocatedNode-&gt;get_startOfConstruct();</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">        141 :      delete targetLocatedNode-&gt;get_endOfConstruct();</span></a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span>            :   // This is required to handle both the Fortran specific &quot;include&quot; files and the CPP specific &quot;#include&quot; files.</a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">        141 :      string filename = getCurrentFilename();</span></a>
<a name="557"><span class="lineNum">     557 </span>            :   // printf (&quot;In resetSourcePosition(%p = %s) filename = %s \n&quot;,targetLocatedNode,targetLocatedNode-&gt;class_name().c_str(),filename.c_str());</a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">        141 :      ROSE_ASSERT(filename.empty() == false);</span></a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span>            :   // Set these based on the source position information from the tokens</a>
<a name="561"><span class="lineNum">     561 </span>            :   // locatedNode-&gt;set_startOfConstruct (new Sg_File_Info(*(firstToken-&gt;get_startOfConstruct())));</a>
<a name="562"><span class="lineNum">     562 </span>            :   // locatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(*(lastToken -&gt;get_endOfConstruct  ())));</a>
<a name="563"><span class="lineNum">     563 </span><span class="lineCov">        141 :      targetLocatedNode-&gt;set_startOfConstruct (new Sg_File_Info(*(sourceLocatedNode-&gt;get_startOfConstruct())));</span></a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">        141 :      targetLocatedNode-&gt;set_endOfConstruct   (new Sg_File_Info(*(sourceLocatedNode-&gt;get_endOfConstruct  ())));</span></a>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">        141 :      targetLocatedNode-&gt;get_startOfConstruct()-&gt;set_parent(targetLocatedNode);</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">        141 :      targetLocatedNode-&gt;get_endOfConstruct  ()-&gt;set_parent(targetLocatedNode);</span></a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span>            :   // DQ (2/15/2013): Added support to set the operatorPosition source position consistantly.</a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">        141 :      SgExpression* expression = isSgExpression(targetLocatedNode);</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineCov">        141 :      if (expression != NULL)</span></a>
<a name="572"><span class="lineNum">     572 </span>            :         {</a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">         98 :           ROSE_ASSERT(expression-&gt;get_operatorPosition() != NULL);</span></a>
<a name="574"><span class="lineNum">     574 </span>            :        // expression-&gt;get_operatorPosition()-&gt;updateSourcePosition(targetLocatedNode-&gt;get_startOfConstruct());</a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">         98 :           *(expression-&gt;get_operatorPosition()) = *(targetLocatedNode-&gt;get_startOfConstruct());</span></a>
<a name="576"><span class="lineNum">     576 </span>            :         }</a>
<a name="577"><span class="lineNum">     577 </span><span class="lineCov">        141 :    }</span></a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span>            : // void resetEndingSourcePosition( SgLocatedNode* targetLocatedNode, Token_t* token )</a>
<a name="580"><span class="lineNum">     580 </span>            : void</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">         90 : resetEndingSourcePosition( SgLocatedNode* targetLocatedNode, Token_t* token )</span></a>
<a name="582"><span class="lineNum">     582 </span>            :    {</a>
<a name="583"><span class="lineNum">     583 </span>            :   // DQ (10/10/2010): This function is added to support resetting the end </a>
<a name="584"><span class="lineNum">     584 </span>            :   // of the blocks (required to get comments woven into the AST properly).</a>
<a name="585"><span class="lineNum">     585 </span><span class="lineCov">         90 :      ROSE_ASSERT(token != NULL);</span></a>
<a name="586"><span class="lineNum">     586 </span><span class="lineCov">         90 :      int newLineNumber = token-&gt;line;</span></a>
<a name="587"><span class="lineNum">     587 </span>            : #if 0</a>
<a name="588"><span class="lineNum">     588 </span>            :      printf (&quot;Resetting the end of the target statement = %s to line = %d \n&quot;,targetLocatedNode-&gt;class_name().c_str(),newLineNumber);</a>
<a name="589"><span class="lineNum">     589 </span>            : #endif</a>
<a name="590"><span class="lineNum">     590 </span><span class="lineCov">         90 :      resetEndingSourcePosition(targetLocatedNode,newLineNumber);</span></a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">         90 :      SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(targetLocatedNode);</span></a>
<a name="593"><span class="lineNum">     593 </span><span class="lineCov">         90 :      if (functionDefinition != NULL)</span></a>
<a name="594"><span class="lineNum">     594 </span>            :         {</a>
<a name="595"><span class="lineNum">     595 </span>            :        // Also set the ending position of the function declaration.</a>
<a name="596"><span class="lineNum">     596 </span>            :        // printf (&quot;In resetEndingSourcePosition(): Set the ending position of the related function declaration \n&quot;);</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineCov">         13 :           SgDeclarationStatement* functionDeclaration = functionDefinition-&gt;get_declaration();</span></a>
<a name="598"><span class="lineNum">     598 </span><span class="lineCov">         13 :           ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">         13 :           resetEndingSourcePosition(functionDeclaration,token);</span></a>
<a name="600"><span class="lineNum">     600 </span>            :         }</a>
<a name="601"><span class="lineNum">     601 </span>            : </a>
<a name="602"><span class="lineNum">     602 </span>            :     // Liao 2/1/2010. The SgBasicBlock of a SgFortranDo has to be adjusted also</a>
<a name="603"><span class="lineNum">     603 </span>            :     // 1. the begin construct should be the same as the one of its first child statement</a>
<a name="604"><span class="lineNum">     604 </span>            :     // 2. the end construct should be the same as SgFortranDo's end of construct</a>
<a name="605"><span class="lineNum">     605 </span>            :     // This is the fix to bug 495: https://outreach.scidac.gov/tracker/index.php?func=detail&amp;aid=495&amp;group_id=24&amp;atid=185</a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">         90 :     SgFortranDo  * f_do = isSgFortranDo(targetLocatedNode);</span></a>
<a name="607"><span class="lineNum">     607 </span><span class="lineCov">         90 :     if (f_do != NULL)</span></a>
<a name="608"><span class="lineNum">     608 </span>            :     {</a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">         23 :       SgBasicBlock * body = f_do-&gt;get_body();</span></a>
<a name="610"><span class="lineNum">     610 </span><span class="lineCov">         23 :       ROSE_ASSERT (body != NULL);</span></a>
<a name="611"><span class="lineNum">     611 </span>            :       // adjust the startOfConstruct</a>
<a name="612"><span class="lineNum">     612 </span><span class="lineCov">         46 :       SgStatementPtrList stmt_list = body-&gt;get_statements(); </span></a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">         23 :       if (stmt_list.size()&gt;0)</span></a>
<a name="614"><span class="lineNum">     614 </span>            :        {</a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">         23 :          SgStatement* first_stmt = stmt_list[0];</span></a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">         23 :          ROSE_ASSERT(first_stmt !=NULL);</span></a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">         23 :          body-&gt;get_startOfConstruct()-&gt;set_filename(first_stmt-&gt;get_startOfConstruct()-&gt;get_filename());</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">         23 :          body-&gt;get_startOfConstruct()-&gt;set_line(first_stmt-&gt;get_startOfConstruct()-&gt;get_line());</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">         23 :          body-&gt;get_startOfConstruct()-&gt;set_col(first_stmt-&gt;get_startOfConstruct()-&gt;get_col());</span></a>
<a name="620"><span class="lineNum">     620 </span>            :        }</a>
<a name="621"><span class="lineNum">     621 </span>            :      // adjust the endOfConstruct:   </a>
<a name="622"><span class="lineNum">     622 </span>            :      // BTW. c_action_block () also tries to reset the end construct for the block.</a>
<a name="623"><span class="lineNum">     623 </span>            :      // But the line number set here can be larger than the new line number c_action_block () tries to set and </a>
<a name="624"><span class="lineNum">     624 </span>            :      // the larger one will be kept.</a>
<a name="625"><span class="lineNum">     625 </span><span class="lineCov">         23 :          body-&gt;get_endOfConstruct()-&gt;set_filename(f_do-&gt;get_endOfConstruct()-&gt;get_filename());</span></a>
<a name="626"><span class="lineNum">     626 </span><span class="lineCov">         23 :          body-&gt;get_endOfConstruct()-&gt;set_line(f_do-&gt;get_endOfConstruct()-&gt;get_line());</span></a>
<a name="627"><span class="lineNum">     627 </span><span class="lineCov">         23 :          body-&gt;get_endOfConstruct()-&gt;set_col(f_do-&gt;get_endOfConstruct()-&gt;get_col());</span></a>
<a name="628"><span class="lineNum">     628 </span>            :        </a>
<a name="629"><span class="lineNum">     629 </span>            :     }</a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            :   // If this is the top level scope then iterate over the outer scopes to reset the end of each scope on the stack.</a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">         90 :      if (astScopeStack.front() == targetLocatedNode)</span></a>
<a name="633"><span class="lineNum">     633 </span>            :         {</a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">         77 :           list&lt;SgScopeStatement*&gt;::iterator i = astScopeStack.begin();</span></a>
<a name="635"><span class="lineNum">     635 </span><span class="lineCov">         77 :           ROSE_ASSERT(targetLocatedNode == *i);</span></a>
<a name="636"><span class="lineNum">     636 </span><span class="lineCov">        320 :           while (i != astScopeStack.end())</span></a>
<a name="637"><span class="lineNum">     637 </span>            :              {</a>
<a name="638"><span class="lineNum">     638 </span>            : #if 0</a>
<a name="639"><span class="lineNum">     639 </span>            :                printf (&quot;In resetEndingSourcePosition(): Resetting the end of the block = %s to line = %d and file = %s \n&quot;,(*i)-&gt;class_name().c_str(),newLineNumber,getCurrentFilename().c_str());</a>
<a name="640"><span class="lineNum">     640 </span>            : #endif</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">        243 :                resetEndingSourcePosition(*i,newLineNumber);</span></a>
<a name="642"><span class="lineNum">     642 </span>            : </a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">        243 :                ROSE_ASSERT((*i)-&gt;isCaseInsensitive() == true);</span></a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span><span class="lineCov">        320 :                i++;</span></a>
<a name="646"><span class="lineNum">     646 </span>            :              }</a>
<a name="647"><span class="lineNum">     647 </span>            :         }</a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">         90 :    }</span></a>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">        111 : void resetEndingSourcePosition( SgLocatedNode* targetLocatedNode, SgStatement* sourceStatement )</span></a>
<a name="651"><span class="lineNum">     651 </span>            :    {</a>
<a name="652"><span class="lineNum">     652 </span>            :   // If this is not the same file then the line numbers will not make any sense.</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">        111 :      ROSE_ASSERT(targetLocatedNode-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">        111 :      ROSE_ASSERT(sourceStatement-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">        111 :      if (targetLocatedNode-&gt;get_endOfConstruct()-&gt;isSameFile(sourceStatement-&gt;get_endOfConstruct()) == true)</span></a>
<a name="656"><span class="lineNum">     656 </span>            :         {</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">         76 :           int newLineNumber = sourceStatement-&gt;get_endOfConstruct()-&gt;get_line();</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">         76 :           resetEndingSourcePosition(targetLocatedNode,newLineNumber);</span></a>
<a name="659"><span class="lineNum">     659 </span>            :         }</a>
<a name="660"><span class="lineNum">     660 </span>            :        else</a>
<a name="661"><span class="lineNum">     661 </span>            :         {</a>
<a name="662"><span class="lineNum">     662 </span>            :        // Increment the position by &quot;1&quot; since we have at least processed a Fortran include file on it's one line.</a>
<a name="663"><span class="lineNum">     663 </span>            : #if 0</a>
<a name="664"><span class="lineNum">     664 </span>            :           printf (&quot;Processing special case of source statement not in same file as the start of the scope. \n&quot;);</a>
<a name="665"><span class="lineNum">     665 </span>            : #endif</a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">         35 :           resetEndingSourcePosition(astScopeStack.front(),astScopeStack.front()-&gt;get_endOfConstruct()-&gt;get_line()+1);</span></a>
<a name="667"><span class="lineNum">     667 </span>            :         }</a>
<a name="668"><span class="lineNum">     668 </span><span class="lineCov">        111 :    }</span></a>
<a name="669"><span class="lineNum">     669 </span>            : </a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">        448 : void resetEndingSourcePosition( SgLocatedNode* targetLocatedNode, int newLineNumber )</span></a>
<a name="671"><span class="lineNum">     671 </span>            :    {</a>
<a name="672"><span class="lineNum">     672 </span>            :   // This function is called by the other &quot;resetEndingSourcePosition()&quot; functions.</a>
<a name="673"><span class="lineNum">     673 </span>            : </a>
<a name="674"><span class="lineNum">     674 </span>            : #if 0</a>
<a name="675"><span class="lineNum">     675 </span>            :      printf (&quot;targetLocatedNode = %p = %s get_startOfConstruct()-&gt;get_line() = %d \n&quot;,targetLocatedNode,targetLocatedNode-&gt;class_name().c_str(),targetLocatedNode-&gt;get_startOfConstruct()-&gt;get_line());</a>
<a name="676"><span class="lineNum">     676 </span>            :      printf (&quot;targetLocatedNode = %p = %s get_endOfConstruct()-&gt;get_line()   = %d \n&quot;,targetLocatedNode,targetLocatedNode-&gt;class_name().c_str(),targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line());</a>
<a name="677"><span class="lineNum">     677 </span>            : #endif</a>
<a name="678"><span class="lineNum">     678 </span>            :      // Liao, 11/12/2012. We don't expect transformation or compiler generated file info.</a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">        448 :      ROSE_ASSERT (targetLocatedNode-&gt;get_endOfConstruct()-&gt;isTransformation()!= true);</span></a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">        448 :      ROSE_ASSERT (targetLocatedNode-&gt;get_endOfConstruct()-&gt;isCompilerGenerated()!= true);</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">        448 :      int oldLineNumber = targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line();</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">        448 :      if (newLineNumber &gt; oldLineNumber)</span></a>
<a name="683"><span class="lineNum">     683 </span>            :         {</a>
<a name="684"><span class="lineNum">     684 </span>            :        // printf (&quot;Resetting the ending line number from %d to %d \n&quot;,oldLineNumber,newLineNumber);</a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">        250 :           targetLocatedNode-&gt;get_endOfConstruct()-&gt;set_line(newLineNumber);</span></a>
<a name="686"><span class="lineNum">     686 </span>            :        // this  fails if file info is compiler generated or transformation generated. (get_line() always return zero )</a>
<a name="687"><span class="lineNum">     687 </span>            : </a>
<a name="688"><span class="lineNum">     688 </span>            :        // If this is a different filename then change the filename as well.</a>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">        500 :           string currentFilename = getCurrentFilename();</span></a>
<a name="690"><span class="lineNum">     690 </span>            : #if 0</a>
<a name="691"><span class="lineNum">     691 </span>            :        // DQ (3/19/2017): Debugging new support to have undefined value (0) returned for frontend specific file info IR nodes.</a>
<a name="692"><span class="lineNum">     692 </span>            :           if (targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line () != newLineNumber)</a>
<a name="693"><span class="lineNum">     693 </span>            :              {</a>
<a name="694"><span class="lineNum">     694 </span>            : #if 1</a>
<a name="695"><span class="lineNum">     695 </span>            :                printf (&quot;##### currentFilename = %s \n&quot;,currentFilename.c_str());</a>
<a name="696"><span class="lineNum">     696 </span>            :                printf (&quot;##### targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString() = %s \n&quot;,targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString().c_str());</a>
<a name="697"><span class="lineNum">     697 </span>            : #endif</a>
<a name="698"><span class="lineNum">     698 </span>            :                printf (&quot;In resetEndingSourcePosition(): targetLocatedNode = %p = %s \n&quot;,targetLocatedNode,targetLocatedNode-&gt;class_name().c_str());</a>
<a name="699"><span class="lineNum">     699 </span>            :                printf (&quot;In resetEndingSourcePosition(): newLineNumber = %d \n&quot;,newLineNumber);</a>
<a name="700"><span class="lineNum">     700 </span>            :                targetLocatedNode-&gt;get_startOfConstruct()-&gt;display(&quot;targetLocatedNode-&gt;get_startOfConstruct()-&gt;get_line () != newLineNumber: debug&quot;);</a>
<a name="701"><span class="lineNum">     701 </span>            :                targetLocatedNode-&gt;get_endOfConstruct()-&gt;display(&quot;targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line () != newLineNumber: debug&quot;);</a>
<a name="702"><span class="lineNum">     702 </span>            :              }</a>
<a name="703"><span class="lineNum">     703 </span>            : #endif</a>
<a name="704"><span class="lineNum">     704 </span>            :        // DQ (3/19/2017): Only check the raw position due to new support to have undefined value (0) returned for frontend specific file info IR nodes.</a>
<a name="705"><span class="lineNum">     705 </span>            :        // ROSE_ASSERT (targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line () == newLineNumber);</a>
<a name="706"><span class="lineNum">     706 </span><span class="lineCov">        250 :           ROSE_ASSERT (targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_raw_line () == newLineNumber);</span></a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span><span class="lineCov">        250 :           if (targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString() != currentFilename)</span></a>
<a name="709"><span class="lineNum">     709 </span>            :              {</a>
<a name="710"><span class="lineNum">     710 </span>            : #if 0</a>
<a name="711"><span class="lineNum">     711 </span>            :                printf (&quot;##### currentFilename = %s \n&quot;,currentFilename.c_str());</a>
<a name="712"><span class="lineNum">     712 </span>            :                printf (&quot;##### targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString() = %s \n&quot;,targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString().c_str());</a>
<a name="713"><span class="lineNum">     713 </span>            : #endif</a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">         73 :                targetLocatedNode-&gt;get_startOfConstruct()-&gt;set_filenameString(currentFilename);</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">         73 :                ROSE_ASSERT (targetLocatedNode-&gt;get_startOfConstruct()-&gt;get_filenameString() == currentFilename);</span></a>
<a name="716"><span class="lineNum">     716 </span>            : </a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">         73 :                targetLocatedNode-&gt;get_endOfConstruct()-&gt;set_filenameString(currentFilename);</span></a>
<a name="718"><span class="lineNum">     718 </span><span class="lineCov">         73 :                ROSE_ASSERT (targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_filenameString() == currentFilename);</span></a>
<a name="719"><span class="lineNum">     719 </span>            :              }</a>
<a name="720"><span class="lineNum">     720 </span>            :         }</a>
<a name="721"><span class="lineNum">     721 </span>            : </a>
<a name="722"><span class="lineNum">     722 </span>            :   // DQ (3/19/2017): Added debugging code to catch where isSourcePositionUnavailableInFrontend() == true after calling set_line() and set_filenameString() functions.</a>
<a name="723"><span class="lineNum">     723 </span><span class="lineCov">        448 :      if (targetLocatedNode-&gt;get_startOfConstruct()-&gt;isSourcePositionUnavailableInFrontend() == true)</span></a>
<a name="724"><span class="lineNum">     724 </span>            :         {</a>
<a name="725"><span class="lineNum">     725 </span><span class="lineNoCov">          0 :           targetLocatedNode-&gt;get_startOfConstruct()-&gt;display(&quot;targetLocatedNode-&gt;get_startOfConstruct()-&gt;get_line () != newLineNumber: debug&quot;);</span></a>
<a name="726"><span class="lineNum">     726 </span>            :         }</a>
<a name="727"><span class="lineNum">     727 </span><span class="lineCov">        448 :      if (targetLocatedNode-&gt;get_endOfConstruct()-&gt;isSourcePositionUnavailableInFrontend() == true)</span></a>
<a name="728"><span class="lineNum">     728 </span>            :         {</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineNoCov">          0 :           targetLocatedNode-&gt;get_endOfConstruct()-&gt;display(&quot;targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line () != newLineNumber: debug&quot;);</span></a>
<a name="730"><span class="lineNum">     730 </span>            :         }</a>
<a name="731"><span class="lineNum">     731 </span><span class="lineCov">        448 :      ROSE_ASSERT(targetLocatedNode-&gt;get_endOfConstruct()-&gt;isSourcePositionUnavailableInFrontend() == false);</span></a>
<a name="732"><span class="lineNum">     732 </span><span class="lineCov">        448 :      ROSE_ASSERT(targetLocatedNode-&gt;get_startOfConstruct()-&gt;isSourcePositionUnavailableInFrontend() == false);</span></a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            :   // DQ (10/10/2010): See example test2007_17.f90 of if statment on a single line for were we can't enforce this.</a>
<a name="735"><span class="lineNum">     735 </span>            :   // ROSE_ASSERT(targetLocatedNode-&gt;get_endOfConstruct()-&gt;get_line() != targetLocatedNode-&gt;get_startOfConstruct()-&gt;get_line());</a>
<a name="736"><span class="lineNum">     736 </span><span class="lineCov">        448 :    }</span></a>
<a name="737"><span class="lineNum">     737 </span>            : </a>
<a name="738"><span class="lineNum">     738 </span>            : </a>
<a name="739"><span class="lineNum">     739 </span>            : SgType*</a>
<a name="740"><span class="lineNum">     740 </span><span class="lineCov">        400 : createType(int typeCode)</span></a>
<a name="741"><span class="lineNum">     741 </span>            :    {</a>
<a name="742"><span class="lineNum">     742 </span>            :   // This builds SgType IR nodes given the type code as input.</a>
<a name="743"><span class="lineNum">     743 </span><span class="lineCov">        400 :      SgType* result = NULL;</span></a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">        400 :      switch(typeCode)</span></a>
<a name="745"><span class="lineNum">     745 </span>            :         {</a>
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">        311 :           case IntrinsicTypeSpec_INTEGER:         result = SgTypeInt::createType();         break;</span></a>
<a name="747"><span class="lineNum">     747 </span><span class="lineCov">          5 :           case IntrinsicTypeSpec_REAL:            result = SgTypeFloat::createType();       break;</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineCov">         28 :           case IntrinsicTypeSpec_DOUBLEPRECISION: result = SgTypeDouble::createType();      break;</span></a>
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_DOUBLECOMPLEX:   result = SgTypeComplex::createType(SgTypeDouble::createType()); break;</span></a>
<a name="750"><span class="lineNum">     750 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_COMPLEX:         result = SgTypeComplex::createType(SgTypeFloat::createType());  break;</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_CHARACTER:       result = SgTypeChar::createType();        break;</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineCov">         56 :           case IntrinsicTypeSpec_LOGICAL:         result = SgTypeBool::createType();        break;</span></a>
<a name="753"><span class="lineNum">     753 </span>            :  </a>
<a name="754"><span class="lineNum">     754 </span>            :           // Rice CAF types</a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_TEAM:            result = SgTypeCAFTeam::createType();     break;</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_CRAYPOINTER:     result = SgTypeCrayPointer::createType(); break;</span></a>
<a name="757"><span class="lineNum">     757 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_TOPOLOGY:        result = SgTypeInt::createType();         break;</span></a>
<a name="758"><span class="lineNum">     758 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_EVENT:</span></a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_LOCK: </span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :           case IntrinsicTypeSpec_LOCKSET:  </span></a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :           {</span></a>
<a name="762"><span class="lineNum">     762 </span>            :               // TEMPORARY: need to add additional Rice type nodes to IR</a>
<a name="763"><span class="lineNum">     763 </span><span class="lineNoCov">          0 :               SgIntVal * kind = new SgIntVal(8, &quot;8&quot;);</span></a>
<a name="764"><span class="lineNum">     764 </span><span class="lineNoCov">          0 :               setSourcePosition(kind);</span></a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :               result = SgTypeComplex::createType(SgTypeDouble::createType(kind));</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="767"><span class="lineNum">     767 </span>            :           }</a>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<a name="769"><span class="lineNum">     769 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :           {   </span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :                printf (&quot;Default reached in createType: typeCode = %d \n&quot;,typeCode);</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="773"><span class="lineNum">     773 </span>            :           }</a>
<a name="774"><span class="lineNum">     774 </span>            :        }</a>
<a name="775"><span class="lineNum">     775 </span>            : </a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">        400 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineCov">        400 :      return result;</span></a>
<a name="778"><span class="lineNum">     778 </span>            :    }</a>
<a name="779"><span class="lineNum">     779 </span>            : </a>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<a name="781"><span class="lineNum">     781 </span>            : SgExpression*</a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 : createUnaryOperator ( SgExpression* exp, string name, bool is_user_defined_operator )</span></a>
<a name="783"><span class="lineNum">     783 </span>            :    {</a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(exp != NULL);</span></a>
<a name="785"><span class="lineNum">     785 </span><span class="lineNoCov">          0 :      SgExpression* result = NULL;</span></a>
<a name="786"><span class="lineNum">     786 </span>            : </a>
<a name="787"><span class="lineNum">     787 </span>            :   // DQ (10/9/2008): Added support for user defined operators</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :      if (is_user_defined_operator == true)</span></a>
<a name="789"><span class="lineNum">     789 </span>            :         {</a>
<a name="790"><span class="lineNum">     790 </span>            :        // Get the function symbol for the function defined by &quot;name&quot;</a>
<a name="791"><span class="lineNum">     791 </span><span class="lineNoCov">          0 :           SgScopeStatement* currentScope = astScopeStack.front();</span></a>
<a name="792"><span class="lineNum">     792 </span>            : </a>
<a name="793"><span class="lineNum">     793 </span>            :        // The name in the symbol table uses the form:</a>
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 :           name = &quot;operator(&quot; + name + &quot;)&quot;;</span></a>
<a name="795"><span class="lineNum">     795 </span>            : #if 0</a>
<a name="796"><span class="lineNum">     796 </span>            :           printf (&quot;name = %s \n&quot;,name.c_str());</a>
<a name="797"><span class="lineNum">     797 </span>            :           printf (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="798"><span class="lineNum">     798 </span>            : #endif</a>
<a name="799"><span class="lineNum">     799 </span>            :        // currentScope-&gt;print_symboltable (&quot;In createBinaryOperator()&quot;);</a>
<a name="800"><span class="lineNum">     800 </span>            : </a>
<a name="801"><span class="lineNum">     801 </span><span class="lineNoCov">          0 :           SgFunctionSymbol* functionSymbol = trace_back_through_parent_scopes_lookup_function_symbol(name,currentScope);</span></a>
<a name="802"><span class="lineNum">     802 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="803"><span class="lineNum">     803 </span>            : </a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :           result = new SgUserDefinedUnaryOp(exp,NULL,name,functionSymbol);</span></a>
<a name="805"><span class="lineNum">     805 </span>            : </a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(result != NULL);</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 :           return result;</span></a>
<a name="808"><span class="lineNum">     808 </span>            :         }</a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span><span class="lineNoCov">          0 :      int stringLength = name.length();</span></a>
<a name="811"><span class="lineNum">     811 </span><span class="lineNoCov">          0 :      if (stringLength == 1)</span></a>
<a name="812"><span class="lineNum">     812 </span>            :         {</a>
<a name="813"><span class="lineNum">     813 </span><span class="lineNoCov">          0 :           switch (name[0])</span></a>
<a name="814"><span class="lineNum">     814 </span>            :              {</a>
<a name="815"><span class="lineNum">     815 </span><span class="lineNoCov">          0 :                case '!':</span></a>
<a name="816"><span class="lineNum">     816 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="817"><span class="lineNum">     817 </span>            :                  // printf (&quot;Building a SgLessThanOp binary operator \n&quot;);</a>
<a name="818"><span class="lineNum">     818 </span><span class="lineNoCov">          0 :                     result = new SgNotOp(exp,NULL);</span></a>
<a name="819"><span class="lineNum">     819 </span>            :                     break;</a>
<a name="820"><span class="lineNum">     820 </span>            :                   }</a>
<a name="821"><span class="lineNum">     821 </span>            : </a>
<a name="822"><span class="lineNum">     822 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: default reached relOp = %s \n&quot;,name.c_str());</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="826"><span class="lineNum">     826 </span>            :                   }</a>
<a name="827"><span class="lineNum">     827 </span>            :              }</a>
<a name="828"><span class="lineNum">     828 </span>            :         }</a>
<a name="829"><span class="lineNum">     829 </span>            :        else</a>
<a name="830"><span class="lineNum">     830 </span>            :         {</a>
<a name="831"><span class="lineNum">     831 </span>            :        // ROSE_ASSERT(stringLength == 2);</a>
<a name="832"><span class="lineNum">     832 </span><span class="lineNoCov">          0 :           if (stringLength == 2)</span></a>
<a name="833"><span class="lineNum">     833 </span>            :              {</a>
<a name="834"><span class="lineNum">     834 </span>            :             // Not sure what these would be.</a>
<a name="835"><span class="lineNum">     835 </span><span class="lineNoCov">          0 :                printf (&quot;2 character unary operators not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="837"><span class="lineNum">     837 </span>            :              }</a>
<a name="838"><span class="lineNum">     838 </span>            :             else</a>
<a name="839"><span class="lineNum">     839 </span>            :              {</a>
<a name="840"><span class="lineNum">     840 </span><span class="lineNoCov">          0 :                if (stringLength == 4)</span></a>
<a name="841"><span class="lineNum">     841 </span>            :                   {</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :                     if (matchingName(name,&quot;.XX.&quot;) == true)</span></a>
<a name="843"><span class="lineNum">     843 </span>            :                        {</a>
<a name="844"><span class="lineNum">     844 </span>            :                        }</a>
<a name="845"><span class="lineNum">     845 </span>            :                       else</a>
<a name="846"><span class="lineNum">     846 </span>            :                        {</a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: not sure what the operator is: %s \n&quot;,name.c_str());</span></a>
<a name="848"><span class="lineNum">     848 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="849"><span class="lineNum">     849 </span>            :                        }</a>
<a name="850"><span class="lineNum">     850 </span>            :                   }</a>
<a name="851"><span class="lineNum">     851 </span>            :                  else</a>
<a name="852"><span class="lineNum">     852 </span>            :                   {</a>
<a name="853"><span class="lineNum">     853 </span><span class="lineNoCov">          0 :                     if (stringLength == 5)</span></a>
<a name="854"><span class="lineNum">     854 </span>            :                        {</a>
<a name="855"><span class="lineNum">     855 </span>            :                       // This is the case for &quot;.OR.&quot; etc.</a>
<a name="856"><span class="lineNum">     856 </span><span class="lineNoCov">          0 :                          if (matchingName(name,&quot;.NOT.&quot;) == true)</span></a>
<a name="857"><span class="lineNum">     857 </span>            :                             {</a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :                               result = new SgNotOp(exp,NULL);</span></a>
<a name="859"><span class="lineNum">     859 </span>            :                             }</a>
<a name="860"><span class="lineNum">     860 </span>            :                            else</a>
<a name="861"><span class="lineNum">     861 </span>            :                             {</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineNoCov">          0 :                               printf (&quot;n != 1,2,4,5 character operators not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="864"><span class="lineNum">     864 </span>            :                             }</a>
<a name="865"><span class="lineNum">     865 </span>            :                        }</a>
<a name="866"><span class="lineNum">     866 </span>            :                   }</a>
<a name="867"><span class="lineNum">     867 </span>            :              }</a>
<a name="868"><span class="lineNum">     868 </span>            :         }</a>
<a name="869"><span class="lineNum">     869 </span>            : </a>
<a name="870"><span class="lineNum">     870 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="871"><span class="lineNum">     871 </span><span class="lineNoCov">          0 :      return result;</span></a>
<a name="872"><span class="lineNum">     872 </span>            :    }</a>
<a name="873"><span class="lineNum">     873 </span>            : </a>
<a name="874"><span class="lineNum">     874 </span>            : SgExpression*</a>
<a name="875"><span class="lineNum">     875 </span><span class="lineCov">          1 : createBinaryOperator ( SgExpression* lhs, SgExpression* rhs, string name, bool is_user_defined_operator )</span></a>
<a name="876"><span class="lineNum">     876 </span>            :    {</a>
<a name="877"><span class="lineNum">     877 </span><span class="lineCov">          1 :      ROSE_ASSERT(lhs != NULL);</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineCov">          1 :      ROSE_ASSERT(rhs != NULL);</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineCov">          1 :      SgExpression* result = NULL;</span></a>
<a name="880"><span class="lineNum">     880 </span>            : </a>
<a name="881"><span class="lineNum">     881 </span>            :   // DQ (10/9/2008): Added support for user defined operators</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineCov">          1 :      if (is_user_defined_operator == true)</span></a>
<a name="883"><span class="lineNum">     883 </span>            :         {</a>
<a name="884"><span class="lineNum">     884 </span>            :        // Get the function symbol for the function defined by &quot;name&quot;</a>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 :           SgScopeStatement* currentScope = astScopeStack.front();</span></a>
<a name="886"><span class="lineNum">     886 </span>            : #if 0</a>
<a name="887"><span class="lineNum">     887 </span>            :           printf (&quot;name = %s \n&quot;,name.c_str());</a>
<a name="888"><span class="lineNum">     888 </span>            :           printf (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="889"><span class="lineNum">     889 </span>            : #endif</a>
<a name="890"><span class="lineNum">     890 </span>            :        // currentScope-&gt;print_symboltable (&quot;In createBinaryOperator()&quot;);</a>
<a name="891"><span class="lineNum">     891 </span>            : </a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :           SgFunctionSymbol* functionSymbol = trace_back_through_parent_scopes_lookup_function_symbol(name,currentScope);</span></a>
<a name="893"><span class="lineNum">     893 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="894"><span class="lineNum">     894 </span>            : </a>
<a name="895"><span class="lineNum">     895 </span><span class="lineNoCov">          0 :           result = new SgUserDefinedBinaryOp(lhs,rhs,NULL,name,functionSymbol);</span></a>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(result != NULL);</span></a>
<a name="898"><span class="lineNum">     898 </span><span class="lineNoCov">          0 :           return result;</span></a>
<a name="899"><span class="lineNum">     899 </span>            :         }</a>
<a name="900"><span class="lineNum">     900 </span>            : </a>
<a name="901"><span class="lineNum">     901 </span><span class="lineCov">          1 :      int stringLength = name.length();</span></a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">          1 :      if (stringLength == 1)</span></a>
<a name="903"><span class="lineNum">     903 </span>            :         {</a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :           switch (name[0])</span></a>
<a name="905"><span class="lineNum">     905 </span>            :              {</a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :                case '&lt;':</span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="908"><span class="lineNum">     908 </span>            :                  // printf (&quot;Building a SgLessThanOp binary operator \n&quot;);</a>
<a name="909"><span class="lineNum">     909 </span><span class="lineNoCov">          0 :                     result = new SgLessThanOp(lhs,rhs,NULL);</span></a>
<a name="910"><span class="lineNum">     910 </span>            :                     break;</a>
<a name="911"><span class="lineNum">     911 </span>            :                   }</a>
<a name="912"><span class="lineNum">     912 </span>            : </a>
<a name="913"><span class="lineNum">     913 </span><span class="lineNoCov">          0 :                case '&gt;':</span></a>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="915"><span class="lineNum">     915 </span>            :                  // printf (&quot;Building a SgLessThanOp binary operator \n&quot;);</a>
<a name="916"><span class="lineNum">     916 </span><span class="lineNoCov">          0 :                     result = new SgGreaterThanOp(lhs,rhs,NULL);</span></a>
<a name="917"><span class="lineNum">     917 </span>            :                     break;</a>
<a name="918"><span class="lineNum">     918 </span>            :                   }</a>
<a name="919"><span class="lineNum">     919 </span>            : </a>
<a name="920"><span class="lineNum">     920 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: default reached relOp = %s \n&quot;,name.c_str());</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="924"><span class="lineNum">     924 </span>            :                   }</a>
<a name="925"><span class="lineNum">     925 </span>            :              }</a>
<a name="926"><span class="lineNum">     926 </span>            :         }</a>
<a name="927"><span class="lineNum">     927 </span>            :        else</a>
<a name="928"><span class="lineNum">     928 </span>            :         {</a>
<a name="929"><span class="lineNum">     929 </span>            :        // ROSE_ASSERT(stringLength == 2);</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineCov">          1 :           if (stringLength == 2)</span></a>
<a name="931"><span class="lineNum">     931 </span>            :              {</a>
<a name="932"><span class="lineNum">     932 </span>            :             // This is likely the case of &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;/=&quot;, &quot;==&quot;</a>
<a name="933"><span class="lineNum">     933 </span>            :             // printf (&quot;2 character operators not implemented relOp = %s \n&quot;,name.c_str());</a>
<a name="934"><span class="lineNum">     934 </span>            :             // ROSE_ABORT();</a>
<a name="935"><span class="lineNum">     935 </span>            : </a>
<a name="936"><span class="lineNum">     936 </span><span class="lineNoCov">          0 :                if (name == &quot;&lt;=&quot;)</span></a>
<a name="937"><span class="lineNum">     937 </span>            :                   {</a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 :                     result = new SgLessOrEqualOp(lhs,rhs,NULL);</span></a>
<a name="939"><span class="lineNum">     939 </span>            :                   }</a>
<a name="940"><span class="lineNum">     940 </span>            :                  else</a>
<a name="941"><span class="lineNum">     941 </span>            :                   {</a>
<a name="942"><span class="lineNum">     942 </span><span class="lineNoCov">          0 :                     if (name == &quot;&gt;=&quot;)</span></a>
<a name="943"><span class="lineNum">     943 </span>            :                        {</a>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 :                          result = new SgGreaterOrEqualOp(lhs,rhs,NULL);</span></a>
<a name="945"><span class="lineNum">     945 </span>            :                        }</a>
<a name="946"><span class="lineNum">     946 </span>            :                       else</a>
<a name="947"><span class="lineNum">     947 </span>            :                        {</a>
<a name="948"><span class="lineNum">     948 </span><span class="lineNoCov">          0 :                          if (name == &quot;==&quot;)</span></a>
<a name="949"><span class="lineNum">     949 </span>            :                             {</a>
<a name="950"><span class="lineNum">     950 </span><span class="lineNoCov">          0 :                               result = new SgEqualityOp(lhs,rhs,NULL);</span></a>
<a name="951"><span class="lineNum">     951 </span>            :                             }</a>
<a name="952"><span class="lineNum">     952 </span>            :                            else</a>
<a name="953"><span class="lineNum">     953 </span>            :                             {</a>
<a name="954"><span class="lineNum">     954 </span>            :                            // In C this would be the &quot;!=&quot; operator, in fortran it is &quot;/=&quot;</a>
<a name="955"><span class="lineNum">     955 </span><span class="lineNoCov">          0 :                               if (name == &quot;/=&quot;)</span></a>
<a name="956"><span class="lineNum">     956 </span>            :                                  {</a>
<a name="957"><span class="lineNum">     957 </span><span class="lineNoCov">          0 :                                    result = new SgNotEqualOp(lhs,rhs,NULL);</span></a>
<a name="958"><span class="lineNum">     958 </span>            :                                  }</a>
<a name="959"><span class="lineNum">     959 </span>            :                                 else</a>
<a name="960"><span class="lineNum">     960 </span>            :                                  {</a>
<a name="961"><span class="lineNum">     961 </span><span class="lineNoCov">          0 :                                    if (name == &quot;//&quot;)</span></a>
<a name="962"><span class="lineNum">     962 </span>            :                                       {</a>
<a name="963"><span class="lineNum">     963 </span><span class="lineNoCov">          0 :                                         result = new SgConcatenationOp(lhs,rhs,NULL);</span></a>
<a name="964"><span class="lineNum">     964 </span>            :                                       }</a>
<a name="965"><span class="lineNum">     965 </span>            :                                      else</a>
<a name="966"><span class="lineNum">     966 </span>            :                                       {</a>
<a name="967"><span class="lineNum">     967 </span><span class="lineNoCov">          0 :                                         printf (&quot;2 character operator not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineNoCov">          0 :                                         ROSE_ABORT();</span></a>
<a name="969"><span class="lineNum">     969 </span>            :                                       }</a>
<a name="970"><span class="lineNum">     970 </span>            :                                  }</a>
<a name="971"><span class="lineNum">     971 </span>            :                             }</a>
<a name="972"><span class="lineNum">     972 </span>            :                        }</a>
<a name="973"><span class="lineNum">     973 </span>            :                   }</a>
<a name="974"><span class="lineNum">     974 </span>            :              }</a>
<a name="975"><span class="lineNum">     975 </span>            :             else</a>
<a name="976"><span class="lineNum">     976 </span>            :              {</a>
<a name="977"><span class="lineNum">     977 </span><span class="lineCov">          1 :                if (stringLength == 4)</span></a>
<a name="978"><span class="lineNum">     978 </span>            :                   {</a>
<a name="979"><span class="lineNum">     979 </span>            :                  // These are all case insensitive.</a>
<a name="980"><span class="lineNum">     980 </span>            :                  // This is the case for &quot;.LT.&quot;, &quot;.LE.&quot;, &quot;.EQ.&quot;, &quot;.NE.&quot;, &quot;.GT.&quot;, &quot;.GE.&quot;, and &quot;.OR.&quot; etc.</a>
<a name="981"><span class="lineNum">     981 </span><span class="lineCov">          2 :                     if (matchingName(name,&quot;.LT.&quot;) == true)</span></a>
<a name="982"><span class="lineNum">     982 </span>            :                        {</a>
<a name="983"><span class="lineNum">     983 </span><span class="lineNoCov">          0 :                          result = new SgLessThanOp(lhs,rhs,NULL);</span></a>
<a name="984"><span class="lineNum">     984 </span>            :                        }</a>
<a name="985"><span class="lineNum">     985 </span>            :                       else</a>
<a name="986"><span class="lineNum">     986 </span>            :                        {</a>
<a name="987"><span class="lineNum">     987 </span><span class="lineCov">          2 :                          if (matchingName(name,&quot;.LE.&quot;) == true)</span></a>
<a name="988"><span class="lineNum">     988 </span>            :                             {</a>
<a name="989"><span class="lineNum">     989 </span><span class="lineNoCov">          0 :                               result = new SgLessOrEqualOp(lhs,rhs,NULL);</span></a>
<a name="990"><span class="lineNum">     990 </span>            :                             }</a>
<a name="991"><span class="lineNum">     991 </span>            :                            else</a>
<a name="992"><span class="lineNum">     992 </span>            :                             {</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">          2 :                               if (matchingName(name,&quot;.EQ.&quot;) == true)</span></a>
<a name="994"><span class="lineNum">     994 </span>            :                                  {</a>
<a name="995"><span class="lineNum">     995 </span><span class="lineNoCov">          0 :                                    result = new SgEqualityOp(lhs,rhs,NULL);</span></a>
<a name="996"><span class="lineNum">     996 </span>            :                                  }</a>
<a name="997"><span class="lineNum">     997 </span>            :                                 else</a>
<a name="998"><span class="lineNum">     998 </span>            :                                  {</a>
<a name="999"><span class="lineNum">     999 </span><span class="lineCov">          2 :                                    if (matchingName(name,&quot;.NE.&quot;) == true)</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            :                                       {</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineCov">          1 :                                         result = new SgNotEqualOp(lhs,rhs,NULL);</span></a>
<a name="1002"><span class="lineNum">    1002 </span>            :                                       }</a>
<a name="1003"><span class="lineNum">    1003 </span>            :                                      else</a>
<a name="1004"><span class="lineNum">    1004 </span>            :                                       {</a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                                         if (matchingName(name,&quot;.GT.&quot;) == true)</span></a>
<a name="1006"><span class="lineNum">    1006 </span>            :                                            {</a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                                              result = new SgGreaterThanOp(lhs,rhs,NULL);</span></a>
<a name="1008"><span class="lineNum">    1008 </span>            :                                            }</a>
<a name="1009"><span class="lineNum">    1009 </span>            :                                           else</a>
<a name="1010"><span class="lineNum">    1010 </span>            :                                            {</a>
<a name="1011"><span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                                              if (matchingName(name,&quot;.GE.&quot;) == true)</span></a>
<a name="1012"><span class="lineNum">    1012 </span>            :                                                 {</a>
<a name="1013"><span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                                                   result = new SgGreaterOrEqualOp(lhs,rhs,NULL);</span></a>
<a name="1014"><span class="lineNum">    1014 </span>            :                                                 }</a>
<a name="1015"><span class="lineNum">    1015 </span>            :                                                else</a>
<a name="1016"><span class="lineNum">    1016 </span>            :                                                 {</a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                                                   if (matchingName(name,&quot;.OR.&quot;) == true)</span></a>
<a name="1018"><span class="lineNum">    1018 </span>            :                                                      {</a>
<a name="1019"><span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                                                        result = new SgOrOp(lhs,rhs,NULL);</span></a>
<a name="1020"><span class="lineNum">    1020 </span>            :                                                      }</a>
<a name="1021"><span class="lineNum">    1021 </span>            :                                                     else</a>
<a name="1022"><span class="lineNum">    1022 </span>            :                                                      {</a>
<a name="1023"><span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                                                        printf (&quot;4 character operator not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                                                        ROSE_ABORT();</span></a>
<a name="1025"><span class="lineNum">    1025 </span>            :                                                      }</a>
<a name="1026"><span class="lineNum">    1026 </span>            :                                                 }</a>
<a name="1027"><span class="lineNum">    1027 </span>            :                                            }</a>
<a name="1028"><span class="lineNum">    1028 </span>            :                                       }</a>
<a name="1029"><span class="lineNum">    1029 </span>            :                                  }</a>
<a name="1030"><span class="lineNum">    1030 </span>            :                             }</a>
<a name="1031"><span class="lineNum">    1031 </span>            :                        }</a>
<a name="1032"><span class="lineNum">    1032 </span>            :                   }</a>
<a name="1033"><span class="lineNum">    1033 </span>            :                  else</a>
<a name="1034"><span class="lineNum">    1034 </span>            :                   {</a>
<a name="1035"><span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                     if (stringLength == 5)</span></a>
<a name="1036"><span class="lineNum">    1036 </span>            :                        {</a>
<a name="1037"><span class="lineNum">    1037 </span>            :                       // These are all case insensitive.</a>
<a name="1038"><span class="lineNum">    1038 </span>            :                       // This is the case for &quot;.AND.&quot; etc.</a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                          if (matchingName(name,&quot;.AND.&quot;) == true)</span></a>
<a name="1040"><span class="lineNum">    1040 </span>            :                             {</a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineNoCov">          0 :                               result = new SgAndOp(lhs,rhs,NULL);</span></a>
<a name="1042"><span class="lineNum">    1042 </span>            :                             }</a>
<a name="1043"><span class="lineNum">    1043 </span>            :                            else</a>
<a name="1044"><span class="lineNum">    1044 </span>            :                             {</a>
<a name="1045"><span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                               if (matchingName(name,&quot;.EQV.&quot;) == true)</span></a>
<a name="1046"><span class="lineNum">    1046 </span>            :                                  {</a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                                    result = new SgEqualityOp(lhs,rhs,NULL);</span></a>
<a name="1048"><span class="lineNum">    1048 </span>            :                                  }</a>
<a name="1049"><span class="lineNum">    1049 </span>            :                                 else</a>
<a name="1050"><span class="lineNum">    1050 </span>            :                                  {</a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                                    printf (&quot;n != 2,4,5 character operators not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineNoCov">          0 :                                    ROSE_ABORT();</span></a>
<a name="1053"><span class="lineNum">    1053 </span>            :                                  }</a>
<a name="1054"><span class="lineNum">    1054 </span>            :                             }</a>
<a name="1055"><span class="lineNum">    1055 </span>            :                        }</a>
<a name="1056"><span class="lineNum">    1056 </span>            :                       else</a>
<a name="1057"><span class="lineNum">    1057 </span>            :                        {</a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                          if (stringLength == 6)</span></a>
<a name="1059"><span class="lineNum">    1059 </span>            :                             {</a>
<a name="1060"><span class="lineNum">    1060 </span>            :                            // This is the case for &quot;.NEQV.&quot; etc.</a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                               if (matchingName(name,&quot;.NEQV.&quot;) == true)</span></a>
<a name="1062"><span class="lineNum">    1062 </span>            :                                  {</a>
<a name="1063"><span class="lineNum">    1063 </span>            :                                 // DQ (8/5/2010): This might output .NE. instead of .NEQV. and the two are .NEQV.! </a>
<a name="1064"><span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                                    result = new SgNotEqualOp(lhs,rhs,NULL);</span></a>
<a name="1065"><span class="lineNum">    1065 </span>            :                                  }</a>
<a name="1066"><span class="lineNum">    1066 </span>            :                                 else</a>
<a name="1067"><span class="lineNum">    1067 </span>            :                                  {</a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                                    printf (&quot;n != 2,4,5,6 character operators not implemented relOp = %s \n&quot;,name.c_str());</span></a>
<a name="1069"><span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                                    ROSE_ABORT();</span></a>
<a name="1070"><span class="lineNum">    1070 </span>            :                                  }</a>
<a name="1071"><span class="lineNum">    1071 </span>            :                             }</a>
<a name="1072"><span class="lineNum">    1072 </span>            :                        }</a>
<a name="1073"><span class="lineNum">    1073 </span>            :                  // printf (&quot;n != 2,4 character operators not implemented relOp = %s \n&quot;,name.c_str());</a>
<a name="1074"><span class="lineNum">    1074 </span>            :                  // ROSE_ASSERT(false);</a>
<a name="1075"><span class="lineNum">    1075 </span>            :                   }</a>
<a name="1076"><span class="lineNum">    1076 </span>            :              }</a>
<a name="1077"><span class="lineNum">    1077 </span>            :         }</a>
<a name="1078"><span class="lineNum">    1078 </span>            : </a>
<a name="1079"><span class="lineNum">    1079 </span><span class="lineCov">          1 :      ROSE_ASSERT(result != NULL);</span></a>
<a name="1080"><span class="lineNum">    1080 </span><span class="lineCov">          1 :      return result;</span></a>
<a name="1081"><span class="lineNum">    1081 </span>            :    }</a>
<a name="1082"><span class="lineNum">    1082 </span>            : </a>
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<a name="1084"><span class="lineNum">    1084 </span>            : void</a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineNoCov">          0 : outputStateSupport( const std::string &amp; s, int fieldWidth )</span></a>
<a name="1086"><span class="lineNum">    1086 </span>            :    {</a>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineNoCov">          0 :      printf (&quot;(%s)&quot;,s.c_str());</span></a>
<a name="1088"><span class="lineNum">    1088 </span><span class="lineNoCov">          0 :      for (int j=s.length(); j &lt; fieldWidth; j++)</span></a>
<a name="1089"><span class="lineNum">    1089 </span>            :         {</a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineNoCov">          0 :           printf (&quot; &quot;);</span></a>
<a name="1091"><span class="lineNum">    1091 </span>            :         }</a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="1093"><span class="lineNum">    1093 </span>            : </a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineCov">       2603 : void outputState( const std::string label )</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            :    {</a>
<a name="1096"><span class="lineNum">    1096 </span>            :   // This function is used for debugging and outputs the data in the different </a>
<a name="1097"><span class="lineNum">    1097 </span>            :   // stacks used to accumulate intermeditate data as part of building the AST.</a>
<a name="1098"><span class="lineNum">    1098 </span>            :   // Output the stack information for: </a>
<a name="1099"><span class="lineNum">    1099 </span>            :   //      astScopeStack, </a>
<a name="1100"><span class="lineNum">    1100 </span>            :   //      astExpressionStack, </a>
<a name="1101"><span class="lineNum">    1101 </span>            :   //      astNodeStack, </a>
<a name="1102"><span class="lineNum">    1102 </span>            :   //      astNameStack, </a>
<a name="1103"><span class="lineNum">    1103 </span>            :   //      astTypeStack, </a>
<a name="1104"><span class="lineNum">    1104 </span>            :   //      astIntentSpecStack, </a>
<a name="1105"><span class="lineNum">    1105 </span>            :   //      astAttributeSpecStack,</a>
<a name="1106"><span class="lineNum">    1106 </span>            :   //      astDeclarationStatementStack,</a>
<a name="1107"><span class="lineNum">    1107 </span>            :   //      astInitializerStack, </a>
<a name="1108"><span class="lineNum">    1108 </span>            : </a>
<a name="1109"><span class="lineNum">    1109 </span><span class="lineCov">       2603 :      if ( SgProject::get_verbose() &lt;= 2 )</span></a>
<a name="1110"><span class="lineNum">    1110 </span>            :         {</a>
<a name="1111"><span class="lineNum">    1111 </span>            :        // Skip output of stack data for verbose levels less than or equal to 2</a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineCov">       2603 :           return;</span></a>
<a name="1113"><span class="lineNum">    1113 </span>            :         }</a>
<a name="1114"><span class="lineNum">    1114 </span>            : </a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :      size_t maxStackSize = astScopeStack.size();</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :      maxStackSize = astExpressionStack.size()           &gt; maxStackSize ? astExpressionStack.size()    : maxStackSize;</span></a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineNoCov">          0 :      maxStackSize = astNodeStack.size()                 &gt; maxStackSize ? astNodeStack.size()          : maxStackSize;</span></a>
<a name="1118"><span class="lineNum">    1118 </span><span class="lineNoCov">          0 :      maxStackSize = astNameStack.size()                 &gt; maxStackSize ? astNameStack.size()          : maxStackSize;</span></a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineNoCov">          0 :      maxStackSize = astBaseTypeStack.size()             &gt; maxStackSize ? astBaseTypeStack.size()      : maxStackSize;</span></a>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineNoCov">          0 :      maxStackSize = astTypeStack.size()                 &gt; maxStackSize ? astTypeStack.size()          : maxStackSize;</span></a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :      maxStackSize = astIntentSpecStack.size()           &gt; maxStackSize ? astIntentSpecStack.size()    : maxStackSize;</span></a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineNoCov">          0 :      maxStackSize = astAttributeSpecStack.size()        &gt; maxStackSize ? astAttributeSpecStack.size() : maxStackSize;</span></a>
<a name="1123"><span class="lineNum">    1123 </span>            :   // maxStackSize = astInitializerStack.size()          &gt; maxStackSize ? astInitializerStack.size()   : maxStackSize;</a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineNoCov">          0 :      maxStackSize = astTypeKindStack.size()             &gt; maxStackSize ? astTypeKindStack.size()      : maxStackSize;</span></a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineNoCov">          0 :      maxStackSize = astTypeParameterStack.size()        &gt; maxStackSize ? astTypeParameterStack.size() : maxStackSize;</span></a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineNoCov">          0 :      maxStackSize = astLabelSymbolStack.size()          &gt; maxStackSize ? astLabelSymbolStack.size()   : maxStackSize;</span></a>
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<a name="1128"><span class="lineNum">    1128 </span>            :   // maxStackSize = astDeclarationStatementStack.size() &gt; maxStackSize ? astDeclarationStatementStack.size() : maxStackSize;</a>
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1132"><span class="lineNum">    1132 </span><span class="lineNoCov">          0 :      printf (&quot;In outputState (%s): maxStackSize = %ld \n&quot;,label.c_str(),(long)maxStackSize);</span></a>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineNoCov">          0 :      std::list&lt;SgScopeStatement*&gt;      ::reverse_iterator astScopeStack_iterator                = astScopeStack.rbegin();</span></a>
<a name="1135"><span class="lineNum">    1135 </span><span class="lineNoCov">          0 :      std::list&lt;SgExpression*&gt;          ::reverse_iterator astExpressionStack_iterator           = astExpressionStack.rbegin();</span></a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineNoCov">          0 :      std::list&lt;SgNode*&gt;                ::reverse_iterator astNodeStack_iterator                 = astNodeStack.rbegin();</span></a>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineNoCov">          0 :      std::list&lt;AstNameType*&gt;           ::reverse_iterator astNameStack_iterator                 = astNameStack.rbegin();</span></a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineNoCov">          0 :      std::list&lt;SgType*&gt;                ::reverse_iterator astBaseTypeStack_iterator             = astBaseTypeStack.rbegin();</span></a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineNoCov">          0 :      std::list&lt;SgType*&gt;                ::reverse_iterator astTypeStack_iterator                 = astTypeStack.rbegin();</span></a>
<a name="1140"><span class="lineNum">    1140 </span><span class="lineNoCov">          0 :      std::list&lt;int&gt;                    ::reverse_iterator astIntentSpecStack_iterator           = astIntentSpecStack.rbegin();</span></a>
<a name="1141"><span class="lineNum">    1141 </span><span class="lineNoCov">          0 :      std::list&lt;int&gt;                    ::reverse_iterator astAttributeSpecStack_iterator        = astAttributeSpecStack.rbegin();</span></a>
<a name="1142"><span class="lineNum">    1142 </span>            :   // std::list&lt;SgExpression*&gt;          ::reverse_iterator astInitializerStack_iterator          = astInitializerStack.rbegin();</a>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineNoCov">          0 :      std::list&lt;SgExpression*&gt;          ::reverse_iterator astTypeKindStack_iterator             = astTypeKindStack.rbegin();</span></a>
<a name="1144"><span class="lineNum">    1144 </span><span class="lineNoCov">          0 :      std::list&lt;SgExpression*&gt;          ::reverse_iterator astTypeParameterStack_iterator        = astTypeParameterStack.rbegin();</span></a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineNoCov">          0 :      std::list&lt;SgLabelSymbol*&gt;         ::reverse_iterator astLabelSymbolStack_iterator          = astLabelSymbolStack.rbegin();</span></a>
<a name="1146"><span class="lineNum">    1146 </span>            : </a>
<a name="1147"><span class="lineNum">    1147 </span>            :   // std::list&lt;SgDeclarationStatement*&gt;::reverse_iterator astDeclarationStatementStack_iterator = astDeclarationStatementStack.rbegin();</a>
<a name="1148"><span class="lineNum">    1148 </span>            : </a>
<a name="1149"><span class="lineNum">    1149 </span>            :   // printf (&quot;     astScopeStack : astExpressionStack : astNodeStack : astDeclarationStatementStack : astTypeStack : astIntentSpecStack : astAttributeSpecStack \n&quot;);</a>
<a name="1150"><span class="lineNum">    1150 </span><span class="lineNoCov">          0 :      const int NumberOfStacks = 11;</span></a>
<a name="1151"><span class="lineNum">    1151 </span>            :   // string stackNames[NumberOfStacks] = { &quot;astScopeStack&quot;, &quot;astExpressionStack&quot;, &quot;astNodeStack&quot;, &quot;astNameStack&quot;, &quot;astTypeStack&quot;, &quot;astIntentSpecStack&quot;, &quot;astAttributeSpecStack&quot; };</a>
<a name="1152"><span class="lineNum">    1152 </span><span class="lineNoCov">          0 :      struct</span></a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineNoCov">          0 :         { std::string name;</span></a>
<a name="1154"><span class="lineNum">    1154 </span>            :           int fieldWidth;</a>
<a name="1155"><span class="lineNum">    1155 </span>            :         } stackNames[NumberOfStacks] = { {&quot;astScopeStack&quot;, 40} ,    {&quot;astExpressionStack&quot;,30} ,   {&quot;astNodeStack&quot;,30},</a>
<a name="1156"><span class="lineNum">    1156 </span>            :                                          {&quot;astNameStack&quot;,30} ,      {&quot;astBaseTypeStack&quot;,30},      {&quot;astTypeStack&quot;,30}, </a>
<a name="1157"><span class="lineNum">    1157 </span>            :                                          {&quot;astIntentSpecStack&quot;,30}, {&quot;astAttributeSpecStack&quot;,20}, /* {&quot;astInitializerStack&quot;,20}, */</a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineNoCov">          0 :                                          {&quot;astTypeKindStack&quot;,20},   {&quot;astTypeParameterStack&quot;,20}, {&quot;astLabelSymbolStack&quot;,20} };</span></a>
<a name="1159"><span class="lineNum">    1159 </span>            : </a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineNoCov">          0 :      for (int k=0; k &lt; NumberOfStacks; k++)</span></a>
<a name="1161"><span class="lineNum">    1161 </span>            :         {</a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineNoCov">          0 :           std::string s  = stackNames[k].name;</span></a>
<a name="1163"><span class="lineNum">    1163 </span><span class="lineNoCov">          0 :           int fieldWidth = stackNames[k].fieldWidth;</span></a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineNoCov">          0 :           outputStateSupport(s,fieldWidth);</span></a>
<a name="1165"><span class="lineNum">    1165 </span>            :         }</a>
<a name="1166"><span class="lineNum">    1166 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1167"><span class="lineNum">    1167 </span>            : </a>
<a name="1168"><span class="lineNum">    1168 </span>            :   // printf (&quot;-------------------------------------------------------------------------------------------------------------------------------------------------------\n&quot;);</a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineNoCov">          0 :      int fieldWidth = 25;</span></a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineNoCov">          0 :      for (int j=0; j &lt; fieldWidth*NumberOfStacks; j++)</span></a>
<a name="1171"><span class="lineNum">    1171 </span>            :         {</a>
<a name="1172"><span class="lineNum">    1172 </span><span class="lineNoCov">          0 :           printf (&quot;-&quot;);</span></a>
<a name="1173"><span class="lineNum">    1173 </span>            :         }</a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineNoCov">          0 :      for (size_t i=0; i &lt; maxStackSize; i++)</span></a>
<a name="1177"><span class="lineNum">    1177 </span>            :         {</a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 :           std::string s;</span></a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineNoCov">          0 :           if (astScopeStack_iterator != astScopeStack.rend())</span></a>
<a name="1180"><span class="lineNum">    1180 </span>            :              {</a>
<a name="1181"><span class="lineNum">    1181 </span>            :             // printf (&quot;     %p = %s = %s :&quot;,*astScopeStack_iterator,(*astScopeStack_iterator)-&gt;class_name().c_str(),SageInterface::get_name(*astScopeStack_iterator).c_str());</a>
<a name="1182"><span class="lineNum">    1182 </span>            :             // printf (&quot;     %p &quot;,*astScopeStack_iterator);</a>
<a name="1183"><span class="lineNum">    1183 </span>            :             // printf (&quot; %s &quot;,(*astScopeStack_iterator)-&gt;class_name().c_str());</a>
<a name="1184"><span class="lineNum">    1184 </span>            :             // printf (&quot;= %s &quot;,SageInterface::get_name(*astScopeStack_iterator).c_str());</a>
<a name="1185"><span class="lineNum">    1185 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1186"><span class="lineNum">    1186 </span>            : </a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                if (isSgBasicBlock(*astScopeStack_iterator) != NULL || isSgAssociateStatement(*astScopeStack_iterator) != NULL)</span></a>
<a name="1188"><span class="lineNum">    1188 </span>            :                   {</a>
<a name="1189"><span class="lineNum">    1189 </span>            :                  // If this is the SgBasicBlock or SgAssociateStatement then output the address instead </a>
<a name="1190"><span class="lineNum">    1190 </span>            :                  // of the &quot;default_name&quot; generated by SageInterface::get_name().</a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                     s = (*astScopeStack_iterator)-&gt;class_name() + &quot; : &quot; + StringUtility::numberToString(*astScopeStack_iterator);</span></a>
<a name="1192"><span class="lineNum">    1192 </span>            :                   }</a>
<a name="1193"><span class="lineNum">    1193 </span>            :                  else</a>
<a name="1194"><span class="lineNum">    1194 </span>            :                   {</a>
<a name="1195"><span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                     s = (*astScopeStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astScopeStack_iterator);</span></a>
<a name="1196"><span class="lineNum">    1196 </span>            :                   }</a>
<a name="1197"><span class="lineNum">    1197 </span>            : </a>
<a name="1198"><span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                astScopeStack_iterator++;</span></a>
<a name="1199"><span class="lineNum">    1199 </span>            :              }</a>
<a name="1200"><span class="lineNum">    1200 </span>            :             else</a>
<a name="1201"><span class="lineNum">    1201 </span>            :              {</a>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineNoCov">          0 :                s = &quot; No Scope &quot;;</span></a>
<a name="1203"><span class="lineNum">    1203 </span>            :              }</a>
<a name="1204"><span class="lineNum">    1204 </span>            : </a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[0].fieldWidth);</span></a>
<a name="1206"><span class="lineNum">    1206 </span>            : </a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineNoCov">          0 :           if (astExpressionStack_iterator != astExpressionStack.rend())</span></a>
<a name="1208"><span class="lineNum">    1208 </span>            :              {</a>
<a name="1209"><span class="lineNum">    1209 </span>            :             // printf (&quot;     %p = %s = %s :&quot;,*astExpressionStack_iterator,(*astExpressionStack_iterator)-&gt;class_name().c_str(),SageInterface::get_name(*astExpressionStack_iterator).c_str());</a>
<a name="1210"><span class="lineNum">    1210 </span>            :             // printf (&quot;     %p &quot;,*astExpressionStack_iterator);</a>
<a name="1211"><span class="lineNum">    1211 </span>            :             // printf (&quot; %s &quot;,(*astExpressionStack_iterator)-&gt;class_name().c_str());</a>
<a name="1212"><span class="lineNum">    1212 </span>            :             // printf (&quot;= %s &quot;,SageInterface::get_name(*astExpressionStack_iterator).c_str());</a>
<a name="1213"><span class="lineNum">    1213 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                s = (*astExpressionStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astExpressionStack_iterator);</span></a>
<a name="1215"><span class="lineNum">    1215 </span>            : </a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                astExpressionStack_iterator++;</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            :              }</a>
<a name="1218"><span class="lineNum">    1218 </span>            :             else</a>
<a name="1219"><span class="lineNum">    1219 </span>            :              {</a>
<a name="1220"><span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                s = &quot; No Expression &quot;;</span></a>
<a name="1221"><span class="lineNum">    1221 </span>            :              }</a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[1].fieldWidth);</span></a>
<a name="1224"><span class="lineNum">    1224 </span>            : </a>
<a name="1225"><span class="lineNum">    1225 </span><span class="lineNoCov">          0 :           if (astNodeStack_iterator != astNodeStack.rend())</span></a>
<a name="1226"><span class="lineNum">    1226 </span>            :              {</a>
<a name="1227"><span class="lineNum">    1227 </span>            :             // printf (&quot;     %p = %s = %s :&quot;,*astExpressionStack_iterator,(*astExpressionStack_iterator)-&gt;class_name().c_str(),SageInterface::get_name(*astExpressionStack_iterator).c_str());</a>
<a name="1228"><span class="lineNum">    1228 </span>            :             // printf (&quot;     %p &quot;,*astNodeStack_iterator);</a>
<a name="1229"><span class="lineNum">    1229 </span>            :             // printf (&quot; %s &quot;,(*astNodeStack_iterator)-&gt;class_name().c_str());</a>
<a name="1230"><span class="lineNum">    1230 </span>            :             // printf (&quot;= %s &quot;,SageInterface::get_name(*astNodeStack_iterator).c_str());</a>
<a name="1231"><span class="lineNum">    1231 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1232"><span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                s = (*astNodeStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astNodeStack_iterator);</span></a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                astNodeStack_iterator++;</span></a>
<a name="1235"><span class="lineNum">    1235 </span>            :              }</a>
<a name="1236"><span class="lineNum">    1236 </span>            :             else</a>
<a name="1237"><span class="lineNum">    1237 </span>            :              {</a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                s = &quot; No Node &quot;;</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            :              }</a>
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<a name="1241"><span class="lineNum">    1241 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[2].fieldWidth);</span></a>
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<a name="1243"><span class="lineNum">    1243 </span><span class="lineNoCov">          0 :           if (astNameStack_iterator != astNameStack.rend())</span></a>
<a name="1244"><span class="lineNum">    1244 </span>            :              {</a>
<a name="1245"><span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                s = (*astNameStack_iterator)-&gt;text;</span></a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                astNameStack_iterator++;</span></a>
<a name="1248"><span class="lineNum">    1248 </span>            :              }</a>
<a name="1249"><span class="lineNum">    1249 </span>            :             else</a>
<a name="1250"><span class="lineNum">    1250 </span>            :              {</a>
<a name="1251"><span class="lineNum">    1251 </span><span class="lineNoCov">          0 :                s = &quot; No Token &quot;;</span></a>
<a name="1252"><span class="lineNum">    1252 </span>            :              }</a>
<a name="1253"><span class="lineNum">    1253 </span>            : </a>
<a name="1254"><span class="lineNum">    1254 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[3].fieldWidth);</span></a>
<a name="1255"><span class="lineNum">    1255 </span>            : </a>
<a name="1256"><span class="lineNum">    1256 </span><span class="lineNoCov">          0 :           if (astBaseTypeStack_iterator != astBaseTypeStack.rend())</span></a>
<a name="1257"><span class="lineNum">    1257 </span>            :              {</a>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                s = (*astBaseTypeStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astBaseTypeStack_iterator);</span></a>
<a name="1259"><span class="lineNum">    1259 </span>            : </a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineNoCov">          0 :                astBaseTypeStack_iterator++;</span></a>
<a name="1261"><span class="lineNum">    1261 </span>            :              }</a>
<a name="1262"><span class="lineNum">    1262 </span>            :             else</a>
<a name="1263"><span class="lineNum">    1263 </span>            :              {</a>
<a name="1264"><span class="lineNum">    1264 </span><span class="lineNoCov">          0 :                s = &quot; No Type &quot;;</span></a>
<a name="1265"><span class="lineNum">    1265 </span>            :              }</a>
<a name="1266"><span class="lineNum">    1266 </span>            : </a>
<a name="1267"><span class="lineNum">    1267 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[4].fieldWidth);</span></a>
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineNoCov">          0 :           if (astTypeStack_iterator != astTypeStack.rend())</span></a>
<a name="1270"><span class="lineNum">    1270 </span>            :              {</a>
<a name="1271"><span class="lineNum">    1271 </span>            :             // printf (&quot;     %p = %s = %s :&quot;,*astExpressionStack_iterator,(*astExpressionStack_iterator)-&gt;class_name().c_str(),SageInterface::get_name(*astExpressionStack_iterator).c_str());</a>
<a name="1272"><span class="lineNum">    1272 </span>            :             // printf (&quot;     %p &quot;,*astTypeStack_iterator);</a>
<a name="1273"><span class="lineNum">    1273 </span>            :             // printf (&quot; %s &quot;,(*astTypeStack_iterator)-&gt;class_name().c_str());</a>
<a name="1274"><span class="lineNum">    1274 </span>            :             // printf (&quot;= %s &quot;,SageInterface::get_name(*astTypeStack_iterator).c_str());</a>
<a name="1275"><span class="lineNum">    1275 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1276"><span class="lineNum">    1276 </span><span class="lineNoCov">          0 :                s = (*astTypeStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astTypeStack_iterator);</span></a>
<a name="1277"><span class="lineNum">    1277 </span>            : </a>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineNoCov">          0 :                astTypeStack_iterator++;</span></a>
<a name="1279"><span class="lineNum">    1279 </span>            :              }</a>
<a name="1280"><span class="lineNum">    1280 </span>            :             else</a>
<a name="1281"><span class="lineNum">    1281 </span>            :              {</a>
<a name="1282"><span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                s = &quot; No Type &quot;;</span></a>
<a name="1283"><span class="lineNum">    1283 </span>            :              }</a>
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<a name="1285"><span class="lineNum">    1285 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[5].fieldWidth);</span></a>
<a name="1286"><span class="lineNum">    1286 </span>            : </a>
<a name="1287"><span class="lineNum">    1287 </span><span class="lineNoCov">          0 :           if (astIntentSpecStack_iterator != astIntentSpecStack.rend())</span></a>
<a name="1288"><span class="lineNum">    1288 </span>            :              {</a>
<a name="1289"><span class="lineNum">    1289 </span>            :             // printf (&quot; %d &quot;,*astIntentSpecStack_iterator);</a>
<a name="1290"><span class="lineNum">    1290 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                s = StringUtility::numberToString(*astIntentSpecStack_iterator);</span></a>
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<a name="1293"><span class="lineNum">    1293 </span><span class="lineNoCov">          0 :                astIntentSpecStack_iterator++;</span></a>
<a name="1294"><span class="lineNum">    1294 </span>            :              }</a>
<a name="1295"><span class="lineNum">    1295 </span>            :             else</a>
<a name="1296"><span class="lineNum">    1296 </span>            :              {</a>
<a name="1297"><span class="lineNum">    1297 </span><span class="lineNoCov">          0 :                s = &quot; No IntentSpec &quot;;</span></a>
<a name="1298"><span class="lineNum">    1298 </span>            :              }</a>
<a name="1299"><span class="lineNum">    1299 </span>            : </a>
<a name="1300"><span class="lineNum">    1300 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[6].fieldWidth);</span></a>
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<a name="1302"><span class="lineNum">    1302 </span><span class="lineNoCov">          0 :           if (astAttributeSpecStack_iterator != astAttributeSpecStack.rend())</span></a>
<a name="1303"><span class="lineNum">    1303 </span>            :              {</a>
<a name="1304"><span class="lineNum">    1304 </span>            :             // printf (&quot; %d &quot;,*astAttributeSpecStack_iterator);</a>
<a name="1305"><span class="lineNum">    1305 </span>            :             // printf (&quot;:&quot;);</a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                s = StringUtility::numberToString(*astAttributeSpecStack_iterator);</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            : </a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineNoCov">          0 :                astAttributeSpecStack_iterator++;</span></a>
<a name="1309"><span class="lineNum">    1309 </span>            :              }</a>
<a name="1310"><span class="lineNum">    1310 </span>            :             else</a>
<a name="1311"><span class="lineNum">    1311 </span>            :              {</a>
<a name="1312"><span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                s = &quot; No AttributeSpec &quot;;</span></a>
<a name="1313"><span class="lineNum">    1313 </span>            :              }</a>
<a name="1314"><span class="lineNum">    1314 </span>            : </a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[7].fieldWidth);</span></a>
<a name="1316"><span class="lineNum">    1316 </span>            : </a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineNoCov">          0 :           if (astTypeKindStack_iterator != astTypeKindStack.rend())</span></a>
<a name="1318"><span class="lineNum">    1318 </span>            :              {</a>
<a name="1319"><span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                s = (*astTypeKindStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astTypeKindStack_iterator);</span></a>
<a name="1320"><span class="lineNum">    1320 </span>            : </a>
<a name="1321"><span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                astTypeKindStack_iterator++;</span></a>
<a name="1322"><span class="lineNum">    1322 </span>            :              }</a>
<a name="1323"><span class="lineNum">    1323 </span>            :             else</a>
<a name="1324"><span class="lineNum">    1324 </span>            :              {</a>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                s = &quot; No Expression &quot;;</span></a>
<a name="1326"><span class="lineNum">    1326 </span>            :              }</a>
<a name="1327"><span class="lineNum">    1327 </span>            : </a>
<a name="1328"><span class="lineNum">    1328 </span>            :        // outputStateSupport(s,stackNames[9].fieldWidth);</a>
<a name="1329"><span class="lineNum">    1329 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[8].fieldWidth);</span></a>
<a name="1330"><span class="lineNum">    1330 </span>            : </a>
<a name="1331"><span class="lineNum">    1331 </span><span class="lineNoCov">          0 :           if (astTypeParameterStack_iterator != astTypeParameterStack.rend())</span></a>
<a name="1332"><span class="lineNum">    1332 </span>            :              {</a>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                s = (*astTypeParameterStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astTypeParameterStack_iterator);</span></a>
<a name="1334"><span class="lineNum">    1334 </span>            : </a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineNoCov">          0 :                astTypeParameterStack_iterator++;</span></a>
<a name="1336"><span class="lineNum">    1336 </span>            :              }</a>
<a name="1337"><span class="lineNum">    1337 </span>            :             else</a>
<a name="1338"><span class="lineNum">    1338 </span>            :              {</a>
<a name="1339"><span class="lineNum">    1339 </span><span class="lineNoCov">          0 :                s = &quot; No Expression &quot;;</span></a>
<a name="1340"><span class="lineNum">    1340 </span>            :              }</a>
<a name="1341"><span class="lineNum">    1341 </span>            : </a>
<a name="1342"><span class="lineNum">    1342 </span>            :        // outputStateSupport(s,stackNames[10].fieldWidth);</a>
<a name="1343"><span class="lineNum">    1343 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[9].fieldWidth);</span></a>
<a name="1344"><span class="lineNum">    1344 </span>            : </a>
<a name="1345"><span class="lineNum">    1345 </span><span class="lineNoCov">          0 :           if (astLabelSymbolStack_iterator != astLabelSymbolStack.rend())</span></a>
<a name="1346"><span class="lineNum">    1346 </span>            :              {</a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineNoCov">          0 :                s = (*astLabelSymbolStack_iterator)-&gt;class_name() + &quot; : &quot; + SageInterface::get_name(*astLabelSymbolStack_iterator);</span></a>
<a name="1348"><span class="lineNum">    1348 </span>            : </a>
<a name="1349"><span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                astLabelSymbolStack_iterator++;</span></a>
<a name="1350"><span class="lineNum">    1350 </span>            :              }</a>
<a name="1351"><span class="lineNum">    1351 </span>            :             else</a>
<a name="1352"><span class="lineNum">    1352 </span>            :              {</a>
<a name="1353"><span class="lineNum">    1353 </span><span class="lineNoCov">          0 :                s = &quot; No Symbol &quot;;</span></a>
<a name="1354"><span class="lineNum">    1354 </span>            :              }</a>
<a name="1355"><span class="lineNum">    1355 </span>            : </a>
<a name="1356"><span class="lineNum">    1356 </span>            :        // outputStateSupport(s,stackNames[11].fieldWidth);</a>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineNoCov">          0 :           outputStateSupport(s,stackNames[10].fieldWidth);</span></a>
<a name="1358"><span class="lineNum">    1358 </span>            : </a>
<a name="1359"><span class="lineNum">    1359 </span><span class="lineNoCov">          0 :           printf (&quot;\n&quot;);</span></a>
<a name="1360"><span class="lineNum">    1360 </span>            :         }</a>
<a name="1361"><span class="lineNum">    1361 </span>            : </a>
<a name="1362"><span class="lineNum">    1362 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1363"><span class="lineNum">    1363 </span><span class="lineNoCov">          0 :      printf (&quot;\n&quot;);</span></a>
<a name="1364"><span class="lineNum">    1364 </span>            :    }</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            : </a>
<a name="1367"><span class="lineNum">    1367 </span><span class="lineCov">       4904 : SgScopeStatement* getTopOfScopeStack()</span></a>
<a name="1368"><span class="lineNum">    1368 </span>            :    {</a>
<a name="1369"><span class="lineNum">    1369 </span>            :   // This function has to do into go into a different source file than fortran_support.C </a>
<a name="1370"><span class="lineNum">    1370 </span>            :   // since that is linked to librose while the astScopeStack variable is declared in this </a>
<a name="1371"><span class="lineNum">    1371 </span>            :   // file (so they at least have to stay together).</a>
<a name="1372"><span class="lineNum">    1372 </span>            : </a>
<a name="1373"><span class="lineNum">    1373 </span><span class="lineCov">       4904 :      ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="1374"><span class="lineNum">    1374 </span>            :   // SgScopeStatement* topOfStack = *(astScopeStack.begin());</a>
<a name="1375"><span class="lineNum">    1375 </span>            :   // printf (&quot;In getTopOfScopeStack() topOfStack = %p = %s \n&quot;,topOfStack,topOfStack-&gt;class_name().c_str());</a>
<a name="1376"><span class="lineNum">    1376 </span><span class="lineCov">       4904 :      SgScopeStatement* topOfStack = astScopeStack.front();</span></a>
<a name="1377"><span class="lineNum">    1377 </span>            : </a>
<a name="1378"><span class="lineNum">    1378 </span>            :   // Testing the scope stack...</a>
<a name="1379"><span class="lineNum">    1379 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="1380"><span class="lineNum">    1380 </span><span class="lineCov">       4904 :      std::list&lt;SgScopeStatement*&gt;::iterator scopeInterator = astScopeStack.begin();</span></a>
<a name="1381"><span class="lineNum">    1381 </span><span class="lineCov">      19801 :      while (scopeInterator != astScopeStack.end())</span></a>
<a name="1382"><span class="lineNum">    1382 </span>            :         {</a>
<a name="1383"><span class="lineNum">    1383 </span><span class="lineCov">      14897 :           if ((*scopeInterator)-&gt;isCaseInsensitive() == false)</span></a>
<a name="1384"><span class="lineNum">    1384 </span>            :              {</a>
<a name="1385"><span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                printf (&quot;##### Error: the scope handling is set to case sensitive scopeInterator = %p = %s \n&quot;,*scopeInterator,(*scopeInterator)-&gt;class_name().c_str());</span></a>
<a name="1386"><span class="lineNum">    1386 </span>            :             // (*scopeInterator)-&gt;setCaseInsensitive(true);</a>
<a name="1387"><span class="lineNum">    1387 </span>            :              }</a>
<a name="1388"><span class="lineNum">    1388 </span><span class="lineCov">      14897 :           ROSE_ASSERT((*scopeInterator)-&gt;isCaseInsensitive() == true);</span></a>
<a name="1389"><span class="lineNum">    1389 </span><span class="lineCov">      19801 :           scopeInterator++;</span></a>
<a name="1390"><span class="lineNum">    1390 </span>            :         }</a>
<a name="1391"><span class="lineNum">    1391 </span>            : </a>
<a name="1392"><span class="lineNum">    1392 </span><span class="lineCov">       4904 :      return topOfStack;</span></a>
<a name="1393"><span class="lineNum">    1393 </span>            :    }</a>
<a name="1394"><span class="lineNum">    1394 </span>            : </a>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineNoCov">          0 : SgType* getTopOfTypeStack()</span></a>
<a name="1396"><span class="lineNum">    1396 </span>            :    {</a>
<a name="1397"><span class="lineNum">    1397 </span>            :   // This function has to do into go into a different source file than fortran_support.C </a>
<a name="1398"><span class="lineNum">    1398 </span>            :   // since that is linked to librose while the astScopeStack variable is declared in this </a>
<a name="1399"><span class="lineNum">    1399 </span>            :   // file (so they at least have to stay together).</a>
<a name="1400"><span class="lineNum">    1400 </span>            : </a>
<a name="1401"><span class="lineNum">    1401 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(astTypeStack.empty() == false);</span></a>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineNoCov">          0 :      SgType* topOfStack = astTypeStack.front();</span></a>
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineNoCov">          0 :      return topOfStack;</span></a>
<a name="1405"><span class="lineNum">    1405 </span>            :    }</a>
<a name="1406"><span class="lineNum">    1406 </span>            : </a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">        231 : AstNameType* getTopOfNameStack()</span></a>
<a name="1408"><span class="lineNum">    1408 </span>            :    {</a>
<a name="1409"><span class="lineNum">    1409 </span>            :   // This function has to do into go into a different source file than fortran_support.C </a>
<a name="1410"><span class="lineNum">    1410 </span>            :   // since that is linked to librose while the astScopeStack variable is declared in this </a>
<a name="1411"><span class="lineNum">    1411 </span>            :   // file (so they at least have to stay together).</a>
<a name="1412"><span class="lineNum">    1412 </span>            : </a>
<a name="1413"><span class="lineNum">    1413 </span><span class="lineCov">        231 :      ROSE_ASSERT(astNameStack.empty() == false);</span></a>
<a name="1414"><span class="lineNum">    1414 </span>            :   // AstNameType* topOfStack = *(astNameStack.begin());</a>
<a name="1415"><span class="lineNum">    1415 </span><span class="lineCov">        231 :      AstNameType* topOfStack = astNameStack.front();</span></a>
<a name="1416"><span class="lineNum">    1416 </span>            :   // printf (&quot;In getTopOfNameStack() topOfStack = %p \n&quot;,topOfStack);</a>
<a name="1417"><span class="lineNum">    1417 </span>            : </a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineCov">        231 :      return topOfStack;</span></a>
<a name="1419"><span class="lineNum">    1419 </span>            :    }</a>
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<a name="1421"><span class="lineNum">    1421 </span><span class="lineCov">         43 : SgExpression* getTopOfExpressionStack()</span></a>
<a name="1422"><span class="lineNum">    1422 </span>            :    {</a>
<a name="1423"><span class="lineNum">    1423 </span>            :   // This function has to do into go into a different source file than fortran_support.C </a>
<a name="1424"><span class="lineNum">    1424 </span>            :   // since that is linked to librose while the astScopeStack variable is declared in this </a>
<a name="1425"><span class="lineNum">    1425 </span>            :   // file (so they at least have to stay together).</a>
<a name="1426"><span class="lineNum">    1426 </span>            : </a>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineCov">         43 :      ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="1428"><span class="lineNum">    1428 </span>            :   // SgExpression* topOfStack = *(astExpressionStack.begin());</a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineCov">         43 :      SgExpression* topOfStack = astExpressionStack.front();</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            :   // printf (&quot;In getTopOfExpressionStack() topOfStack = %p = %s \n&quot;,topOfStack,topOfStack-&gt;class_name().c_str());</a>
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineCov">         43 :      return topOfStack;</span></a>
<a name="1433"><span class="lineNum">    1433 </span>            :    }</a>
<a name="1434"><span class="lineNum">    1434 </span>            : </a>
<a name="1435"><span class="lineNum">    1435 </span>            : </a>
<a name="1436"><span class="lineNum">    1436 </span>            : SgExpression* </a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">         55 : buildLabelRefExp(SgExpression* expression)</span></a>
<a name="1438"><span class="lineNum">    1438 </span>            :    {</a>
<a name="1439"><span class="lineNum">    1439 </span><span class="lineCov">         55 :      SgExpression* returnExpression = expression;</span></a>
<a name="1440"><span class="lineNum">    1440 </span>            : </a>
<a name="1441"><span class="lineNum">    1441 </span>            :   // If this is an integer it is a format label and we want to generate a SgLabelRefExp</a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineCov">         55 :      SgIntVal* integerValue = isSgIntVal(expression);</span></a>
<a name="1443"><span class="lineNum">    1443 </span><span class="lineCov">         55 :      if (integerValue != NULL)</span></a>
<a name="1444"><span class="lineNum">    1444 </span>            :         {</a>
<a name="1445"><span class="lineNum">    1445 </span>            :        // If this is an integer, then generate a SgLabelRefExp.</a>
<a name="1446"><span class="lineNum">    1446 </span><span class="lineNoCov">          0 :           SgName name = StringUtility::numberToString(integerValue-&gt;get_value());</span></a>
<a name="1447"><span class="lineNum">    1447 </span>            : </a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineNoCov">          0 :           Token_t* format_label = create_token(1,0,0,name.str());</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineNoCov">          0 :           SgLabelSymbol* labelSymbol = buildNumericLabelSymbol(format_label);</span></a>
<a name="1450"><span class="lineNum">    1450 </span>            : </a>
<a name="1451"><span class="lineNum">    1451 </span>            :        // DQ (11/5/2016): The token support is using C style malloc, so we need to use C style free to be consistant.</a>
<a name="1452"><span class="lineNum">    1452 </span>            :        // delete format_label;</a>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineNoCov">          0 :           free(format_label);</span></a>
<a name="1454"><span class="lineNum">    1454 </span>            : </a>
<a name="1455"><span class="lineNum">    1455 </span><span class="lineNoCov">          0 :           format_label = NULL;</span></a>
<a name="1456"><span class="lineNum">    1456 </span>            : </a>
<a name="1457"><span class="lineNum">    1457 </span><span class="lineNoCov">          0 :           labelSymbol-&gt;set_label_type(SgLabelSymbol::e_start_label_type);</span></a>
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<a name="1459"><span class="lineNum">    1459 </span><span class="lineNoCov">          0 :           SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1460"><span class="lineNum">    1460 </span>            :        // printf (&quot;################## In buildLabelRefExp(): labelRefExp = %p value = %d \n&quot;,labelRefExp,labelRefExp-&gt;get_symbol()-&gt;get_numeric_label_value());</a>
<a name="1461"><span class="lineNum">    1461 </span>            : </a>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineNoCov">          0 :           setSourcePosition(labelRefExp);</span></a>
<a name="1463"><span class="lineNum">    1463 </span>            : </a>
<a name="1464"><span class="lineNum">    1464 </span>            :        // DQ (1/26/2009): Set the parent of the SgIntVal IR node.</a>
<a name="1465"><span class="lineNum">    1465 </span><span class="lineNoCov">          0 :           integerValue-&gt;set_parent(labelRefExp);</span></a>
<a name="1466"><span class="lineNum">    1466 </span>            : </a>
<a name="1467"><span class="lineNum">    1467 </span><span class="lineNoCov">          0 :           returnExpression = labelRefExp;</span></a>
<a name="1468"><span class="lineNum">    1468 </span>            :         }</a>
<a name="1469"><span class="lineNum">    1469 </span>            : </a>
<a name="1470"><span class="lineNum">    1470 </span><span class="lineCov">         55 :      return returnExpression;</span></a>
<a name="1471"><span class="lineNum">    1471 </span>            :    }</a>
<a name="1472"><span class="lineNum">    1472 </span>            : </a>
<a name="1473"><span class="lineNum">    1473 </span>            : </a>
<a name="1474"><span class="lineNum">    1474 </span>            : SgFunctionDefinition*</a>
<a name="1475"><span class="lineNum">    1475 </span><span class="lineNoCov">          0 : getFunctionDefinitionFromScopeStack()</span></a>
<a name="1476"><span class="lineNum">    1476 </span>            :    {</a>
<a name="1477"><span class="lineNum">    1477 </span>            :   // New function to refactor code used to get the SgFunctionDefinition off of the scope stack.</a>
<a name="1478"><span class="lineNum">    1478 </span><span class="lineNoCov">          0 :      SgFunctionDefinition* functionDefinition = NULL;</span></a>
<a name="1479"><span class="lineNum">    1479 </span>            : </a>
<a name="1480"><span class="lineNum">    1480 </span><span class="lineNoCov">          0 :      std::list&lt;SgScopeStatement*&gt;::iterator i = astScopeStack.begin();</span></a>
<a name="1481"><span class="lineNum">    1481 </span>            :   // printf (&quot;Defining iterator i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineNoCov">          0 :      while ( i != astScopeStack.end() &amp;&amp; isSgFunctionDefinition(*i) == NULL )</span></a>
<a name="1484"><span class="lineNum">    1484 </span>            :         {</a>
<a name="1485"><span class="lineNum">    1485 </span>            :        // printf (&quot;Looping iterator (before ++) i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1486"><span class="lineNum">    1486 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="1487"><span class="lineNum">    1487 </span>            :        // printf (&quot;Looping iterator i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1488"><span class="lineNum">    1488 </span>            :         }</a>
<a name="1489"><span class="lineNum">    1489 </span>            : </a>
<a name="1490"><span class="lineNum">    1490 </span><span class="lineNoCov">          0 :      if (i != astScopeStack.end())</span></a>
<a name="1491"><span class="lineNum">    1491 </span>            :         {</a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineNoCov">          0 :           functionDefinition = isSgFunctionDefinition(*i);</span></a>
<a name="1493"><span class="lineNum">    1493 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionDefinition != NULL);</span></a>
<a name="1494"><span class="lineNum">    1494 </span>            :         }</a>
<a name="1495"><span class="lineNum">    1495 </span>            : </a>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineNoCov">          0 :      return functionDefinition;</span></a>
<a name="1497"><span class="lineNum">    1497 </span>            :    }</a>
<a name="1498"><span class="lineNum">    1498 </span>            : </a>
<a name="1499"><span class="lineNum">    1499 </span>            : </a>
<a name="1500"><span class="lineNum">    1500 </span>            : </a>
<a name="1501"><span class="lineNum">    1501 </span>            : // SgLabelRefExp* buildNumericLabelSymbol(Token_t* label)</a>
<a name="1502"><span class="lineNum">    1502 </span>            : SgLabelSymbol*</a>
<a name="1503"><span class="lineNum">    1503 </span><span class="lineCov">          2 : buildNumericLabelSymbol(Token_t* label)</span></a>
<a name="1504"><span class="lineNum">    1504 </span>            :    {</a>
<a name="1505"><span class="lineNum">    1505 </span>            :   // This is the function we use to create the label that might refer to a </a>
<a name="1506"><span class="lineNum">    1506 </span>            :   // previously seen statement or a statement we will see in the future.</a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">          2 :      ROSE_ASSERT(label != NULL);</span></a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineCov">          2 :      ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1510"><span class="lineNum">    1510 </span>            : </a>
<a name="1511"><span class="lineNum">    1511 </span>            :   // DQ (11/22/2010): This is a bug in OFP, but I have to work around it for now.</a>
<a name="1512"><span class="lineNum">    1512 </span><span class="lineCov">          2 :      if (label-&gt;line == 0)</span></a>
<a name="1513"><span class="lineNum">    1513 </span>            :         {</a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineNoCov">          0 :           printf (&quot;Error (OFP bug): label-&gt;line == 0 for label-&gt;text = %s \n&quot;,label-&gt;text);</span></a>
<a name="1515"><span class="lineNum">    1515 </span>            :         }</a>
<a name="1516"><span class="lineNum">    1516 </span>            :   // ROSE_ASSERT(label-&gt;line &gt; 0);</a>
<a name="1517"><span class="lineNum">    1517 </span>            : </a>
<a name="1518"><span class="lineNum">    1518 </span><span class="lineCov">          2 :      SgLabelSymbol* returnSymbol = NULL;</span></a>
<a name="1519"><span class="lineNum">    1519 </span>            : </a>
<a name="1520"><span class="lineNum">    1520 </span>            : #if 0</a>
<a name="1521"><span class="lineNum">    1521 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="1522"><span class="lineNum">    1522 </span>            :      outputState(&quot;At TOP of buildNumericLabelSymbol()&quot;);</a>
<a name="1523"><span class="lineNum">    1523 </span>            : #endif</a>
<a name="1524"><span class="lineNum">    1524 </span>            : </a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">          2 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1526"><span class="lineNum">    1526 </span><span class="lineNoCov">          0 :           printf (&quot;This code can be replaced with a call to getFunctionDefinitionFromScopeStack() \n&quot;);</span></a>
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<a name="1528"><span class="lineNum">    1528 </span><span class="lineCov">          2 :      std::list&lt;SgScopeStatement*&gt;::iterator i = astScopeStack.begin();</span></a>
<a name="1529"><span class="lineNum">    1529 </span>            :   // printf (&quot;Defining iterator i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1530"><span class="lineNum">    1530 </span>            :   // while ( astScopeStack.empty() == false &amp;&amp; i != astScopeStack.end() &amp;&amp; isSgFunctionDefinition(*i) == NULL )</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">          6 :      while ( i != astScopeStack.end() &amp;&amp; isSgFunctionDefinition(*i) == NULL )</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :         {</a>
<a name="1533"><span class="lineNum">    1533 </span>            :        // printf (&quot;Looping iterator (before ++) i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineCov">          6 :           i++;</span></a>
<a name="1535"><span class="lineNum">    1535 </span>            :        // printf (&quot;Looping iterator i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1536"><span class="lineNum">    1536 </span>            :         }</a>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<a name="1538"><span class="lineNum">    1538 </span>            :   // A label on a program statement will not have a scope in which to be identified. &quot;10 program main&quot;</a>
<a name="1539"><span class="lineNum">    1539 </span>            :   // It is not clear what scope such a label should be added (global scope?).</a>
<a name="1540"><span class="lineNum">    1540 </span><span class="lineCov">          2 :      if (i != astScopeStack.end())</span></a>
<a name="1541"><span class="lineNum">    1541 </span>            :         {</a>
<a name="1542"><span class="lineNum">    1542 </span>            :        // printf (&quot;Looking for SgLabelSymbol i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1543"><span class="lineNum">    1543 </span><span class="lineCov">          2 :           ROSE_ASSERT(isSgFunctionDefinition(*i) != NULL);</span></a>
<a name="1544"><span class="lineNum">    1544 </span>            : </a>
<a name="1545"><span class="lineNum">    1545 </span>            :        // ROSE_ASSERT( i != astScopeStack.end() );</a>
<a name="1546"><span class="lineNum">    1546 </span><span class="lineCov">          4 :           SgName name = label-&gt;text;</span></a>
<a name="1547"><span class="lineNum">    1547 </span>            :        // SgLabelSymbol* returnSymbol = (*i)-&gt;lookup_label_symbol(name);</a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineCov">          2 :           returnSymbol = (*i)-&gt;lookup_label_symbol(name);</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            : </a>
<a name="1550"><span class="lineNum">    1550 </span>            :        // printf (&quot;In buildNumericLabelSymbol(): returnSymbol = %p \n&quot;,returnSymbol);</a>
<a name="1551"><span class="lineNum">    1551 </span><span class="lineCov">          2 :           if (returnSymbol == NULL)</span></a>
<a name="1552"><span class="lineNum">    1552 </span>            :              {</a>
<a name="1553"><span class="lineNum">    1553 </span>            :             // The symbol was not found, create a symbol so that statements can reference</a>
<a name="1554"><span class="lineNum">    1554 </span>            :             // it then we can fixup the statement in the symbol later (when we see it).</a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineNoCov">          0 :                int label_value = atoi(label-&gt;text);</span></a>
<a name="1556"><span class="lineNum">    1556 </span>            :             // printf (&quot;Building a SgLabelSymbol for a numeric label that we have not see yet: label_value = %d = %s \n&quot;,label_value,label-&gt;text);</a>
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<a name="1558"><span class="lineNum">    1558 </span><span class="lineNoCov">          0 :                returnSymbol = new SgLabelSymbol((SgLabelStatement*) NULL);</span></a>
<a name="1559"><span class="lineNum">    1559 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(returnSymbol != NULL);</span></a>
<a name="1560"><span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                returnSymbol-&gt;set_fortran_statement(NULL);</span></a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                returnSymbol-&gt;set_numeric_label_value(label_value);</span></a>
<a name="1562"><span class="lineNum">    1562 </span>            : </a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineNoCov">          0 :                SgStatement* label_statement = new SgNullStatement();</span></a>
<a name="1564"><span class="lineNum">    1564 </span>            :             // printf (&quot;Building SgNullStatement label_statement = %p \n&quot;,label_statement);</a>
<a name="1565"><span class="lineNum">    1565 </span>            : </a>
<a name="1566"><span class="lineNum">    1566 </span><span class="lineNoCov">          0 :                returnSymbol-&gt;set_fortran_statement(label_statement);</span></a>
<a name="1567"><span class="lineNum">    1567 </span>            : </a>
<a name="1568"><span class="lineNum">    1568 </span>            :             // DQ (1/20/2008): The parent of a statement can't be set to a SgSymbol, so make it point to the current scope for now!</a>
<a name="1569"><span class="lineNum">    1569 </span>            :             // label_statement-&gt;set_parent(returnSymbol);</a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                label_statement-&gt;set_parent(astScopeStack.front());</span></a>
<a name="1571"><span class="lineNum">    1571 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(label_statement-&gt;get_parent() != NULL);</span></a>
<a name="1572"><span class="lineNum">    1572 </span>            : </a>
<a name="1573"><span class="lineNum">    1573 </span>            :             // DQ (1/20/2008): If the label is not present, but is referenced then this has to be set.</a>
<a name="1574"><span class="lineNum">    1574 </span>            :             // Note that test2007_175.f demonstrates that if the lable is not present </a>
<a name="1575"><span class="lineNum">    1575 </span>            :             // then this label_statement fails because the source position is not set.</a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineNoCov">          0 :                setSourcePosition(label_statement);</span></a>
<a name="1577"><span class="lineNum">    1577 </span>            : </a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(isSgFunctionDefinition(*i) != NULL);</span></a>
<a name="1579"><span class="lineNum">    1579 </span>            :             // Insert the symbol into the function definition's symbol table so it will be found next time.</a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineNoCov">          0 :                (*i)-&gt;insert_symbol(name,returnSymbol);</span></a>
<a name="1581"><span class="lineNum">    1581 </span>            :              }</a>
<a name="1582"><span class="lineNum">    1582 </span>            : </a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineCov">          2 :           ROSE_ASSERT(returnSymbol != NULL);</span></a>
<a name="1584"><span class="lineNum">    1584 </span>            :         }</a>
<a name="1585"><span class="lineNum">    1585 </span>            :        else</a>
<a name="1586"><span class="lineNum">    1586 </span>            :         {</a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1588"><span class="lineNum">    1588 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING: label attached to construct not in a function scope! \n&quot;);</span></a>
<a name="1589"><span class="lineNum">    1589 </span>            : #if 0</a>
<a name="1590"><span class="lineNum">    1590 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="1591"><span class="lineNum">    1591 </span>            :           outputState(&quot;WARNING: At BOTTOM of buildNumericLabelSymbol()&quot;);</a>
<a name="1592"><span class="lineNum">    1592 </span>            : #endif</a>
<a name="1593"><span class="lineNum">    1593 </span>            :         }</a>
<a name="1594"><span class="lineNum">    1594 </span>            : </a>
<a name="1595"><span class="lineNum">    1595 </span>            :   // printf (&quot;Returning from buildNumericLabelSymbol() returnSymbol = %p \n&quot;,returnSymbol);</a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineCov">          2 :      return returnSymbol;</span></a>
<a name="1597"><span class="lineNum">    1597 </span>            :    }</a>
<a name="1598"><span class="lineNum">    1598 </span>            : </a>
<a name="1599"><span class="lineNum">    1599 </span>            : SgLabelSymbol* </a>
<a name="1600"><span class="lineNum">    1600 </span><span class="lineCov">          4 : buildNumericLabelSymbolAndAssociateWithStatement(SgStatement* stmt, Token_t* label)</span></a>
<a name="1601"><span class="lineNum">    1601 </span>            :    {</a>
<a name="1602"><span class="lineNum">    1602 </span>            :   // This is the function we use to associate a label with a statement.</a>
<a name="1603"><span class="lineNum">    1603 </span>            :   // The label may be been previously build if there was a forward </a>
<a name="1604"><span class="lineNum">    1604 </span>            :   // reference to the statement's label. This might also be the label for</a>
<a name="1605"><span class="lineNum">    1605 </span>            :   // the statements asociated end of construct (for the label associated</a>
<a name="1606"><span class="lineNum">    1606 </span>            :   // with &quot;end&quot; for example).</a>
<a name="1607"><span class="lineNum">    1607 </span>            : </a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineCov">          4 :      ROSE_ASSERT(label != NULL);</span></a>
<a name="1609"><span class="lineNum">    1609 </span>            :      // ROSE_ASSERT(label-&gt;line &gt; 0);</a>
<a name="1610"><span class="lineNum">    1610 </span><span class="lineCov">          4 :      ROSE_ASSERT(label-&gt;line &gt;= 0);  // DXN: FIXME - workaround OFP bug where label-&gt;line = 0 as in the following example:</span></a>
<a name="1611"><span class="lineNum">    1611 </span>            :                                      /*       subroutine FOURT()</a>
<a name="1612"><span class="lineNum">    1612 </span>            :                                       *       DO 125 I1=1, 2</a>
<a name="1613"><span class="lineNum">    1613 </span>            :                                       *       DO 125 I3= 3, 4</a>
<a name="1614"><span class="lineNum">    1614 </span>            :                                       * 125   CONTINUE</a>
<a name="1615"><span class="lineNum">    1615 </span>            :                                       *       END</a>
<a name="1616"><span class="lineNum">    1616 </span>            :                                       *</a>
<a name="1617"><span class="lineNum">    1617 </span>            :                                       *  When label is parsed the second time around, label-&gt;line = 0 and label-&gt;col = -1</a>
<a name="1618"><span class="lineNum">    1618 </span>            :                                       */</a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">          4 :      ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<a name="1621"><span class="lineNum">    1621 </span>            :   // Assumes simple string based representation of integer</a>
<a name="1622"><span class="lineNum">    1622 </span>            :   // I used atoi(), even though strtol() is suggested.  We store the </a>
<a name="1623"><span class="lineNum">    1623 </span>            :   // numeric lables in the AST as numeric values.</a>
<a name="1624"><span class="lineNum">    1624 </span>            :   // int numericLabel = atoi(label-&gt;text);</a>
<a name="1625"><span class="lineNum">    1625 </span>            :   // printf (&quot;label-&gt;text = %s numericLabel = %d \n&quot;,label-&gt;text,numericLabel);</a>
<a name="1626"><span class="lineNum">    1626 </span>            :   // stmt-&gt;set_numeric_label(numericLabel);</a>
<a name="1627"><span class="lineNum">    1627 </span>            : </a>
<a name="1628"><span class="lineNum">    1628 </span><span class="lineCov">          4 :      std::list&lt;SgScopeStatement*&gt;::iterator i = astScopeStack.begin();</span></a>
<a name="1629"><span class="lineNum">    1629 </span>            :   // printf (&quot;Starting at the scope = %s \n&quot;,(*i)-&gt;class_name().c_str());</a>
<a name="1630"><span class="lineNum">    1630 </span>            : </a>
<a name="1631"><span class="lineNum">    1631 </span>            :   // DQ (12/9/2007): Added support for numeric lables to be SgLabelSymbols.</a>
<a name="1632"><span class="lineNum">    1632 </span>            :   // It is unclear if we want to use the function scope of the global scope </a>
<a name="1633"><span class="lineNum">    1633 </span>            :   // (I have use the function scope, where the function is not explicit this </a>
<a name="1634"><span class="lineNum">    1634 </span>            :   // is still using the compiler generated function).</a>
<a name="1635"><span class="lineNum">    1635 </span><span class="lineCov">          8 :      while ( i != astScopeStack.end() &amp;&amp; isSgFunctionDefinition(*i) == NULL )</span></a>
<a name="1636"><span class="lineNum">    1636 </span>            :         {</a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineCov">          8 :           i++;</span></a>
<a name="1638"><span class="lineNum">    1638 </span>            :         }</a>
<a name="1639"><span class="lineNum">    1639 </span>            : </a>
<a name="1640"><span class="lineNum">    1640 </span><span class="lineCov">          4 :      ROSE_ASSERT( i != astScopeStack.end() );</span></a>
<a name="1641"><span class="lineNum">    1641 </span><span class="lineCov">          4 :      ROSE_ASSERT(isSgFunctionDefinition(*i) != NULL);</span></a>
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<a name="1643"><span class="lineNum">    1643 </span>            :   // printf (&quot;Looking for SgLabelSymbol i scope = %p = %s \n&quot;,*i,(*i)-&gt;class_name().c_str());</a>
<a name="1644"><span class="lineNum">    1644 </span>            : </a>
<a name="1645"><span class="lineNum">    1645 </span><span class="lineCov">          4 :      SgName name = label-&gt;text;</span></a>
<a name="1646"><span class="lineNum">    1646 </span><span class="lineCov">          4 :      SgLabelSymbol* label_symbol = (*i)-&gt;lookup_label_symbol(name);</span></a>
<a name="1647"><span class="lineNum">    1647 </span><span class="lineCov">          4 :      if (label_symbol == NULL)</span></a>
<a name="1648"><span class="lineNum">    1648 </span>            :         {</a>
<a name="1649"><span class="lineNum">    1649 </span>            :        // If this does not exist then build the associated label symbol and put it into the function's symbol table.</a>
<a name="1650"><span class="lineNum">    1650 </span><span class="lineCov">          2 :           label_symbol = new SgLabelSymbol((SgLabelStatement*) NULL);</span></a>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineCov">          2 :           label_symbol-&gt;set_fortran_statement(stmt);</span></a>
<a name="1652"><span class="lineNum">    1652 </span>            : </a>
<a name="1653"><span class="lineNum">    1653 </span>            :        // DQ (12/24/2007): The new design stores the numeric label value in the SgLabelSymbol.</a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineCov">          2 :           int label_value = atoi(label-&gt;text);</span></a>
<a name="1655"><span class="lineNum">    1655 </span>            :        // printf (&quot;Building a SgLabelSymbol for a numeric label that we have not see yet: label_value = %d = %s \n&quot;,label_value,label-&gt;text);</a>
<a name="1656"><span class="lineNum">    1656 </span><span class="lineCov">          2 :           label_symbol-&gt;set_numeric_label_value(label_value);</span></a>
<a name="1657"><span class="lineNum">    1657 </span>            : </a>
<a name="1658"><span class="lineNum">    1658 </span>            :        // printf (&quot;Warning in buildNumericLabelSymbolAndAssociateWithStatement(): setting label_type using SgLabelSymbol::e_end_label_type \n&quot;);</a>
<a name="1659"><span class="lineNum">    1659 </span><span class="lineCov">          2 :           label_symbol-&gt;set_label_type(SgLabelSymbol::e_end_label_type);</span></a>
<a name="1660"><span class="lineNum">    1660 </span>            : </a>
<a name="1661"><span class="lineNum">    1661 </span><span class="lineCov">          2 :           ROSE_ASSERT(isSgFunctionDefinition(*i) != NULL);</span></a>
<a name="1662"><span class="lineNum">    1662 </span><span class="lineCov">          2 :           (*i)-&gt;insert_symbol(name,label_symbol);</span></a>
<a name="1663"><span class="lineNum">    1663 </span>            : </a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineCov">          2 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1665"><span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                printf (&quot;Built a new SgLabelSymbol = %p (numeric value = %d) for name = %s associated with statement %p \n&quot;,label_symbol,label_value,name.str(),stmt);</span></a>
<a name="1666"><span class="lineNum">    1666 </span>            :         }</a>
<a name="1667"><span class="lineNum">    1667 </span>            :        else</a>
<a name="1668"><span class="lineNum">    1668 </span>            :         {</a>
<a name="1669"><span class="lineNum">    1669 </span>            :        // If this exists then it was build with a SgNullStatement and we have to replace the statement.</a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">          2 :           SgStatement* tempStatement = label_symbol-&gt;get_fortran_statement();</span></a>
<a name="1671"><span class="lineNum">    1671 </span>            : </a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineCov">          2 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineNoCov">          0 :               printf (&quot;Found an existing SgLabelSymbol = %p for name = %s associated with statement %p (deleted tempStatement = %p) \n&quot;,label_symbol,name.str(),stmt,tempStatement);</span></a>
<a name="1674"><span class="lineNum">    1674 </span>            : </a>
<a name="1675"><span class="lineNum">    1675 </span>            :        // DQ (12/24/2007): New implementation does not use SgNullStatement internally. NOT TRUE, we need these for forward references to numeric labels.</a>
<a name="1676"><span class="lineNum">    1676 </span>            :        // ROSE_ASSERT(isSgNullStatement(tempStatement) == NULL);</a>
<a name="1677"><span class="lineNum">    1677 </span>            : </a>
<a name="1678"><span class="lineNum">    1678 </span>            :        // DQ (12/24/2007): If this is associated with a SgFortranDo statement, then don't delete it.</a>
<a name="1679"><span class="lineNum">    1679 </span>            :        // Only delete it if it is a SgNullStatement. This should solve the problem with test2007_233.f </a>
<a name="1680"><span class="lineNum">    1680 </span>            :        // (fixed this problem, but not finished yet).</a>
<a name="1681"><span class="lineNum">    1681 </span><span class="lineCov">          2 :           if (isSgNullStatement(tempStatement) != NULL)</span></a>
<a name="1682"><span class="lineNum">    1682 </span>            :              {</a>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                delete tempStatement;</span></a>
<a name="1684"><span class="lineNum">    1684 </span><span class="lineCov">          2 :                tempStatement = NULL;</span></a>
<a name="1685"><span class="lineNum">    1685 </span>            :              }</a>
<a name="1686"><span class="lineNum">    1686 </span><span class="lineCov">          2 :           label_symbol-&gt;set_fortran_statement(NULL);</span></a>
<a name="1687"><span class="lineNum">    1687 </span><span class="lineCov">          2 :           label_symbol-&gt;set_fortran_statement(stmt);</span></a>
<a name="1688"><span class="lineNum">    1688 </span>            :         }</a>
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<a name="1690"><span class="lineNum">    1690 </span><span class="lineCov">          4 :      ROSE_ASSERT(label_symbol != NULL);</span></a>
<a name="1691"><span class="lineNum">    1691 </span><span class="lineCov">          4 :      return label_symbol;</span></a>
<a name="1692"><span class="lineNum">    1692 </span>            :    }</a>
<a name="1693"><span class="lineNum">    1693 </span>            : </a>
<a name="1694"><span class="lineNum">    1694 </span>            : </a>
<a name="1695"><span class="lineNum">    1695 </span>            : // DQ (12/8/2010): This is a new function that should likely not be implemented!</a>
<a name="1696"><span class="lineNum">    1696 </span>            : void</a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">         84 : processLabelOnStack( SgStatement* statement )</span></a>
<a name="1698"><span class="lineNum">    1698 </span>            :    {</a>
<a name="1699"><span class="lineNum">    1699 </span>            :   // The label functionality should be handled via the label toke passed as a function parameter and</a>
<a name="1700"><span class="lineNum">    1700 </span>            :   // we should disable the generation of SgLabelSymbol and pushing them onto the stack via R313</a>
<a name="1701"><span class="lineNum">    1701 </span>            :   // (a reference for this handling is the email with Scott 12/8/2010).</a>
<a name="1702"><span class="lineNum">    1702 </span>            : </a>
<a name="1703"><span class="lineNum">    1703 </span><span class="lineCov">         84 :      ROSE_ASSERT(statement != NULL);</span></a>
<a name="1704"><span class="lineNum">    1704 </span>            : </a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">         84 :      if (astLabelSymbolStack.empty() == false)</span></a>
<a name="1706"><span class="lineNum">    1706 </span>            :         {</a>
<a name="1707"><span class="lineNum">    1707 </span><span class="lineNoCov">          0 :           SgLabelSymbol* labelSymbol = astLabelSymbolStack.front();</span></a>
<a name="1708"><span class="lineNum">    1708 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="1709"><span class="lineNum">    1709 </span>            : </a>
<a name="1710"><span class="lineNum">    1710 </span><span class="lineNoCov">          0 :           astLabelSymbolStack.pop_front();</span></a>
<a name="1711"><span class="lineNum">    1711 </span>            :         }</a>
<a name="1712"><span class="lineNum">    1712 </span><span class="lineCov">         84 :    }</span></a>
<a name="1713"><span class="lineNum">    1713 </span>            : </a>
<a name="1714"><span class="lineNum">    1714 </span>            : </a>
<a name="1715"><span class="lineNum">    1715 </span>            : // DQ (12/8/2010): This is a new function that should likely not be implemented!</a>
<a name="1716"><span class="lineNum">    1716 </span>            : void</a>
<a name="1717"><span class="lineNum">    1717 </span><span class="lineCov">          1 : specialFixupForLabelOnStackAndNotPassedAsParameter( SgStatement* statement )</span></a>
<a name="1718"><span class="lineNum">    1718 </span>            :    {</a>
<a name="1719"><span class="lineNum">    1719 </span>            : // This is to make up for a bug in OFP where the label is pushed onto the stack</a>
<a name="1720"><span class="lineNum">    1720 </span>            : // but not also passed as a c_action function function argument.  So this is</a>
<a name="1721"><span class="lineNum">    1721 </span>            : // the only way to detect and process the label.</a>
<a name="1722"><span class="lineNum">    1722 </span>            : </a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineCov">          1 :      ROSE_ASSERT(statement != NULL);</span></a>
<a name="1724"><span class="lineNum">    1724 </span>            : </a>
<a name="1725"><span class="lineNum">    1725 </span><span class="lineCov">          1 :      if (astLabelSymbolStack.empty() == false)</span></a>
<a name="1726"><span class="lineNum">    1726 </span>            :         {</a>
<a name="1727"><span class="lineNum">    1727 </span><span class="lineNoCov">          0 :           SgLabelSymbol* labelSymbol = astLabelSymbolStack.front();</span></a>
<a name="1728"><span class="lineNum">    1728 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="1729"><span class="lineNum">    1729 </span>            : </a>
<a name="1730"><span class="lineNum">    1730 </span><span class="lineNoCov">          0 :           astLabelSymbolStack.pop_front();</span></a>
<a name="1731"><span class="lineNum">    1731 </span>            : </a>
<a name="1732"><span class="lineNum">    1732 </span>            :        // DQ (12/9/2010): We only want to pop the stack, the label is processed using</a>
<a name="1733"><span class="lineNum">    1733 </span>            :        // only the token from the c_action function parameter as suggested by Scott.</a>
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<a name="1735"><span class="lineNum">    1735 </span>            :        // SgVarRefExp* labelVarRef = SageBuilder::buildVarRefExp(labelSymbol);</a>
<a name="1736"><span class="lineNum">    1736 </span><span class="lineNoCov">          0 :           SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1737"><span class="lineNum">    1737 </span><span class="lineNoCov">          0 :           setSourcePosition(labelRefExp);</span></a>
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<a name="1739"><span class="lineNum">    1739 </span><span class="lineNoCov">          0 :           statement-&gt;set_numeric_label(labelRefExp);</span></a>
<a name="1740"><span class="lineNum">    1740 </span>            :         }</a>
<a name="1741"><span class="lineNum">    1741 </span><span class="lineCov">          1 :    }</span></a>
<a name="1742"><span class="lineNum">    1742 </span>            : </a>
<a name="1743"><span class="lineNum">    1743 </span>            : </a>
<a name="1744"><span class="lineNum">    1744 </span>            : void</a>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineCov">         81 : setStatementNumericLabelUsingStack(SgStatement* statement)</span></a>
<a name="1746"><span class="lineNum">    1746 </span>            :    {</a>
<a name="1747"><span class="lineNum">    1747 </span>            :   // DQ (12/9/2010): To provide consistant handling of labels we want to only process </a>
<a name="1748"><span class="lineNum">    1748 </span>            :   // labels passed as arguments to the appropriate c_action function.  So this processing</a>
<a name="1749"><span class="lineNum">    1749 </span>            :   // should be redundant with that and disallowed.</a>
<a name="1750"><span class="lineNum">    1750 </span>            : </a>
<a name="1751"><span class="lineNum">    1751 </span>            :   // Set the label using the stack </a>
<a name="1752"><span class="lineNum">    1752 </span><span class="lineCov">         81 :      if (astLabelSymbolStack.empty() == false)</span></a>
<a name="1753"><span class="lineNum">    1753 </span>            :         {</a>
<a name="1754"><span class="lineNum">    1754 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1755"><span class="lineNum">    1755 </span><span class="lineNoCov">          0 :                printf (&quot;There is a label on the stack \n&quot;);</span></a>
<a name="1756"><span class="lineNum">    1756 </span>            : </a>
<a name="1757"><span class="lineNum">    1757 </span>            :        // Get the label info from the astLabelSymbolStack</a>
<a name="1758"><span class="lineNum">    1758 </span><span class="lineNoCov">          0 :           SgLabelSymbol* labelSymbol = astLabelSymbolStack.front();</span></a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineNoCov">          0 :           astLabelSymbolStack.pop_front();</span></a>
<a name="1760"><span class="lineNum">    1760 </span>            : </a>
<a name="1761"><span class="lineNum">    1761 </span>            :        // The label should not overwrite an existing label (built using a label </a>
<a name="1762"><span class="lineNum">    1762 </span>            :        // Token_t passed as a function argument to a c_action_ function).</a>
<a name="1763"><span class="lineNum">    1763 </span>            :        // ROSE_ASSERT(statement-&gt;get_numeric_label() == NULL);</a>
<a name="1764"><span class="lineNum">    1764 </span><span class="lineNoCov">          0 :           if (statement-&gt;get_numeric_label() != NULL)</span></a>
<a name="1765"><span class="lineNum">    1765 </span>            :              {</a>
<a name="1766"><span class="lineNum">    1766 </span><span class="lineNoCov">          0 :                if (statement-&gt;get_numeric_label()-&gt;get_numeric_label_value() != labelSymbol-&gt;get_numeric_label_value())</span></a>
<a name="1767"><span class="lineNum">    1767 </span>            :                   {</a>
<a name="1768"><span class="lineNum">    1768 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: Overwriting an existing label on a statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</span></a>
<a name="1769"><span class="lineNum">    1769 </span><span class="lineNoCov">          0 :                     printf (&quot;   labelSymbol-&gt;get_numeric_label_value()                    = %d \n&quot;,labelSymbol-&gt;get_numeric_label_value());</span></a>
<a name="1770"><span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                     printf (&quot;   statement-&gt;get_numeric_label()-&gt;get_numeric_label_value() = %d \n&quot;,statement-&gt;get_numeric_label()-&gt;get_numeric_label_value());</span></a>
<a name="1771"><span class="lineNum">    1771 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(statement-&gt;get_numeric_label()-&gt;get_numeric_label_value() == labelSymbol-&gt;get_numeric_label_value());</span></a>
<a name="1772"><span class="lineNum">    1772 </span>            :                   }</a>
<a name="1773"><span class="lineNum">    1773 </span>            :              }</a>
<a name="1774"><span class="lineNum">    1774 </span>            : </a>
<a name="1775"><span class="lineNum">    1775 </span><span class="lineNoCov">          0 :           if (statement-&gt;get_numeric_label() == NULL)</span></a>
<a name="1776"><span class="lineNum">    1776 </span>            :              {</a>
<a name="1777"><span class="lineNum">    1777 </span>            :             // Set the label in the statement</a>
<a name="1778"><span class="lineNum">    1778 </span>            :             // statement-&gt;set_numeric_label(labelSymbol);</a>
<a name="1779"><span class="lineNum">    1779 </span>            : </a>
<a name="1780"><span class="lineNum">    1780 </span><span class="lineNoCov">          0 :                SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1781"><span class="lineNum">    1781 </span>            :             // printf (&quot;################## In setStatementNumericLabelUsingStack(): statement = %p labelRefExp = %p value = %d \n&quot;,statement,labelRefExp,labelRefExp-&gt;get_symbol()-&gt;get_numeric_label_value());</a>
<a name="1782"><span class="lineNum">    1782 </span>            : </a>
<a name="1783"><span class="lineNum">    1783 </span>            :             // printf (&quot;Exiting as a test! \n&quot;);</a>
<a name="1784"><span class="lineNum">    1784 </span>            :             // ROSE_ASSERT(false);</a>
<a name="1785"><span class="lineNum">    1785 </span>            : </a>
<a name="1786"><span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                statement-&gt;set_numeric_label(labelRefExp);</span></a>
<a name="1787"><span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                labelRefExp-&gt;set_parent(statement);</span></a>
<a name="1788"><span class="lineNum">    1788 </span><span class="lineNoCov">          0 :                setSourcePosition(labelRefExp);</span></a>
<a name="1789"><span class="lineNum">    1789 </span>            :              }</a>
<a name="1790"><span class="lineNum">    1790 </span>            :         }</a>
<a name="1791"><span class="lineNum">    1791 </span>            :        else</a>
<a name="1792"><span class="lineNum">    1792 </span>            :         {</a>
<a name="1793"><span class="lineNum">    1793 </span><span class="lineCov">         81 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1794"><span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                printf (&quot;astLabelSymbolStack.empty() == true, no label on stack for statement = %p = %s \n&quot;,statement,statement-&gt;class_name().c_str());</span></a>
<a name="1795"><span class="lineNum">    1795 </span>            :         }</a>
<a name="1796"><span class="lineNum">    1796 </span><span class="lineCov">         81 :    }</span></a>
<a name="1797"><span class="lineNum">    1797 </span>            : </a>
<a name="1798"><span class="lineNum">    1798 </span>            : </a>
<a name="1799"><span class="lineNum">    1799 </span>            : void</a>
<a name="1800"><span class="lineNum">    1800 </span><span class="lineCov">       1107 : setStatementNumericLabel(SgStatement* stmt, Token_t* label)</span></a>
<a name="1801"><span class="lineNum">    1801 </span>            :    {</a>
<a name="1802"><span class="lineNum">    1802 </span><span class="lineCov">       1107 :      if (label != NULL)</span></a>
<a name="1803"><span class="lineNum">    1803 </span>            :         {</a>
<a name="1804"><span class="lineNum">    1804 </span>            :          // ROSE_ASSERT(label-&gt;line &gt;= 0);</a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineCov">          2 :          ROSE_ASSERT(label-&gt;line &gt;= 0);  // DXN: FIXME - workaround OFP bug where label-&gt;line = 0 as in the following example:</span></a>
<a name="1806"><span class="lineNum">    1806 </span>            :                                           /*       subroutine FOURT()</a>
<a name="1807"><span class="lineNum">    1807 </span>            :                                            *       DO 125 I1=1, 2</a>
<a name="1808"><span class="lineNum">    1808 </span>            :                                            *       DO 125 I3= 3, 4</a>
<a name="1809"><span class="lineNum">    1809 </span>            :                                            * 125   CONTINUE</a>
<a name="1810"><span class="lineNum">    1810 </span>            :                                            *       END</a>
<a name="1811"><span class="lineNum">    1811 </span>            :                                            *</a>
<a name="1812"><span class="lineNum">    1812 </span>            :                                            *  When label is parsed the second time around, label-&gt;line = 0 and label-&gt;col = -1</a>
<a name="1813"><span class="lineNum">    1813 </span>            :                                            */</a>
<a name="1814"><span class="lineNum">    1814 </span><span class="lineCov">          2 :           ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1815"><span class="lineNum">    1815 </span>            : </a>
<a name="1816"><span class="lineNum">    1816 </span>            :        // DQ (2/18/2008): There are two mechanisms for setting labels, make sure that if </a>
<a name="1817"><span class="lineNum">    1817 </span>            :        // this one is being used that we don't leave labels on the astLabelSymbolStack</a>
<a name="1818"><span class="lineNum">    1818 </span>            :        // ROSE_ASSERT (astLabelSymbolStack.empty() == true);</a>
<a name="1819"><span class="lineNum">    1819 </span>            : </a>
<a name="1820"><span class="lineNum">    1820 </span><span class="lineCov">          2 :           SgLabelSymbol* labelSymbol = buildNumericLabelSymbolAndAssociateWithStatement(stmt,label);</span></a>
<a name="1821"><span class="lineNum">    1821 </span><span class="lineCov">          2 :           ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="1822"><span class="lineNum">    1822 </span>            : </a>
<a name="1823"><span class="lineNum">    1823 </span>            :        // printf (&quot;In setStatementNumericLabel(): Found statement =%p with label = %d \n&quot;,labelSymbol-&gt;get_fortran_statement(),labelSymbol-&gt;get_fortran_statement()-&gt;get_numeric_label());</a>
<a name="1824"><span class="lineNum">    1824 </span><span class="lineCov">          2 :           labelSymbol-&gt;set_label_type(SgLabelSymbol::e_start_label_type);</span></a>
<a name="1825"><span class="lineNum">    1825 </span>            :        // stmt-&gt;set_numeric_label(labelSymbol);</a>
<a name="1826"><span class="lineNum">    1826 </span>            : </a>
<a name="1827"><span class="lineNum">    1827 </span><span class="lineCov">          2 :           SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1828"><span class="lineNum">    1828 </span>            : </a>
<a name="1829"><span class="lineNum">    1829 </span>            :        // This providea a crude from of trace through the problem so that we can </a>
<a name="1830"><span class="lineNum">    1830 </span>            :        // map failures back to the relevant lines of code in a large application.</a>
<a name="1831"><span class="lineNum">    1831 </span>            :        // printf (&quot;################## In setStatementNumericLabel(): statement = %p labelRefExp = %p value = %d \n&quot;,stmt,labelRefExp,labelRefExp-&gt;get_symbol()-&gt;get_numeric_label_value());</a>
<a name="1832"><span class="lineNum">    1832 </span>            : </a>
<a name="1833"><span class="lineNum">    1833 </span><span class="lineCov">          2 :           stmt-&gt;set_numeric_label(labelRefExp);</span></a>
<a name="1834"><span class="lineNum">    1834 </span><span class="lineCov">          2 :           labelRefExp-&gt;set_parent(stmt);</span></a>
<a name="1835"><span class="lineNum">    1835 </span><span class="lineCov">          2 :           setSourcePosition(labelRefExp,label);</span></a>
<a name="1836"><span class="lineNum">    1836 </span>            :         }</a>
<a name="1837"><span class="lineNum">    1837 </span><span class="lineCov">       1107 :    }</span></a>
<a name="1838"><span class="lineNum">    1838 </span>            : </a>
<a name="1839"><span class="lineNum">    1839 </span>            : void</a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineCov">         48 : setStatementEndNumericLabel(SgStatement* stmt, Token_t* label)</span></a>
<a name="1841"><span class="lineNum">    1841 </span>            :    {</a>
<a name="1842"><span class="lineNum">    1842 </span>            : #if 0</a>
<a name="1843"><span class="lineNum">    1843 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="1844"><span class="lineNum">    1844 </span>            :      outputState(&quot;At TOP of setStatementEndNumericLabel()&quot;);</a>
<a name="1845"><span class="lineNum">    1845 </span>            : #endif</a>
<a name="1846"><span class="lineNum">    1846 </span>            : </a>
<a name="1847"><span class="lineNum">    1847 </span><span class="lineCov">         48 :      ROSE_ASSERT(stmt-&gt;has_end_numeric_label() == true);</span></a>
<a name="1848"><span class="lineNum">    1848 </span>            : </a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">         48 :      if (label != NULL)</span></a>
<a name="1850"><span class="lineNum">    1850 </span>            :         {</a>
<a name="1851"><span class="lineNum">    1851 </span><span class="lineCov">          2 :           ROSE_ASSERT(label-&gt;line &gt; 0);</span></a>
<a name="1852"><span class="lineNum">    1852 </span><span class="lineCov">          2 :           ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1853"><span class="lineNum">    1853 </span>            : </a>
<a name="1854"><span class="lineNum">    1854 </span><span class="lineCov">          2 :           SgLabelSymbol* labelSymbol = buildNumericLabelSymbolAndAssociateWithStatement(stmt,label);</span></a>
<a name="1855"><span class="lineNum">    1855 </span>            : </a>
<a name="1856"><span class="lineNum">    1856 </span>            :        // Mark the label as associated with the end of the statement (for block constructs)</a>
<a name="1857"><span class="lineNum">    1857 </span><span class="lineCov">          2 :           ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="1858"><span class="lineNum">    1858 </span>            : </a>
<a name="1859"><span class="lineNum">    1859 </span>            :        // printf (&quot;In setStatementEndNumericLabel(): Found statement =%p with label = %d \n&quot;,labelSymbol-&gt;get_fortran_statement(),labelSymbol-&gt;get_fortran_statement()-&gt;get_numeric_label());</a>
<a name="1860"><span class="lineNum">    1860 </span><span class="lineCov">          2 :           labelSymbol-&gt;set_label_type(SgLabelSymbol::e_end_label_type);</span></a>
<a name="1861"><span class="lineNum">    1861 </span>            :        // int numeric_label = atoi(label-&gt;text);</a>
<a name="1862"><span class="lineNum">    1862 </span>            :        // stmt-&gt;set_end_numeric_label(labelSymbol);</a>
<a name="1863"><span class="lineNum">    1863 </span>            : </a>
<a name="1864"><span class="lineNum">    1864 </span><span class="lineCov">          2 :           SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1865"><span class="lineNum">    1865 </span><span class="lineCov">          2 :           stmt-&gt;set_end_numeric_label(labelRefExp);</span></a>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">          2 :           labelRefExp-&gt;set_parent(stmt);</span></a>
<a name="1867"><span class="lineNum">    1867 </span><span class="lineCov">          2 :           setSourcePosition(labelRefExp,label);</span></a>
<a name="1868"><span class="lineNum">    1868 </span>            :         }</a>
<a name="1869"><span class="lineNum">    1869 </span><span class="lineCov">         48 :    }</span></a>
<a name="1870"><span class="lineNum">    1870 </span>            : </a>
<a name="1871"><span class="lineNum">    1871 </span>            : void</a>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineNoCov">          0 : setStatementElseNumericLabel(SgStatement* stmt, Token_t* label)</span></a>
<a name="1873"><span class="lineNum">    1873 </span>            :    {</a>
<a name="1874"><span class="lineNum">    1874 </span>            : #if 0</a>
<a name="1875"><span class="lineNum">    1875 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="1876"><span class="lineNum">    1876 </span>            :      outputState(&quot;At TOP of setStatementElseNumericLabel()&quot;);</a>
<a name="1877"><span class="lineNum">    1877 </span>            : #endif</a>
<a name="1878"><span class="lineNum">    1878 </span>            : </a>
<a name="1879"><span class="lineNum">    1879 </span>            :   // For now just trap the special case.  At some point this might also apply to the SgWhereStatement</a>
<a name="1880"><span class="lineNum">    1880 </span>            :   // ROSE_ASSERT(stmt-&gt;has_else_numeric_label() == true);</a>
<a name="1881"><span class="lineNum">    1881 </span>            : </a>
<a name="1882"><span class="lineNum">    1882 </span><span class="lineNoCov">          0 :      SgIfStmt* ifStatement = isSgIfStmt(stmt);</span></a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(ifStatement != NULL);</span></a>
<a name="1884"><span class="lineNum">    1884 </span>            : </a>
<a name="1885"><span class="lineNum">    1885 </span><span class="lineNoCov">          0 :      if (label != NULL)</span></a>
<a name="1886"><span class="lineNum">    1886 </span>            :         {</a>
<a name="1887"><span class="lineNum">    1887 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(label-&gt;line &gt; 0);</span></a>
<a name="1888"><span class="lineNum">    1888 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1889"><span class="lineNum">    1889 </span>            : </a>
<a name="1890"><span class="lineNum">    1890 </span><span class="lineNoCov">          0 :           SgLabelSymbol* labelSymbol = buildNumericLabelSymbolAndAssociateWithStatement(stmt,label);</span></a>
<a name="1891"><span class="lineNum">    1891 </span>            : </a>
<a name="1892"><span class="lineNum">    1892 </span>            :        // Mark the label as associated with the end of the statement (for block constructs)</a>
<a name="1893"><span class="lineNum">    1893 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(labelSymbol != NULL);</span></a>
<a name="1894"><span class="lineNum">    1894 </span>            : </a>
<a name="1895"><span class="lineNum">    1895 </span>            :        // printf (&quot;In setStatementElseNumericLabel(): Found statement =%p with label = %d \n&quot;,labelSymbol-&gt;get_fortran_statement(),labelSymbol-&gt;get_fortran_statement()-&gt;get_numeric_label());</a>
<a name="1896"><span class="lineNum">    1896 </span><span class="lineNoCov">          0 :           labelSymbol-&gt;set_label_type(SgLabelSymbol::e_else_label_type);</span></a>
<a name="1897"><span class="lineNum">    1897 </span>            :        // int numeric_label = atoi(label-&gt;text);</a>
<a name="1898"><span class="lineNum">    1898 </span>            :        // ifStatement-&gt;set_else_numeric_label(labelSymbol);</a>
<a name="1899"><span class="lineNum">    1899 </span>            : </a>
<a name="1900"><span class="lineNum">    1900 </span><span class="lineNoCov">          0 :           SgLabelRefExp* labelRefExp = new SgLabelRefExp(labelSymbol);</span></a>
<a name="1901"><span class="lineNum">    1901 </span>            :        // stmt-&gt;set_else_numeric_label(labelRefExp);</a>
<a name="1902"><span class="lineNum">    1902 </span><span class="lineNoCov">          0 :           ifStatement-&gt;set_else_numeric_label(labelRefExp);</span></a>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineNoCov">          0 :           labelRefExp-&gt;set_parent(ifStatement);</span></a>
<a name="1904"><span class="lineNum">    1904 </span><span class="lineNoCov">          0 :           setSourcePosition(labelRefExp,label);</span></a>
<a name="1905"><span class="lineNum">    1905 </span>            :         }</a>
<a name="1906"><span class="lineNum">    1906 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="1907"><span class="lineNum">    1907 </span>            : </a>
<a name="1908"><span class="lineNum">    1908 </span>            : void</a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineCov">         21 : setStatementStringLabel(SgStatement* stmt, Token_t* label)</span></a>
<a name="1910"><span class="lineNum">    1910 </span>            :    {</a>
<a name="1911"><span class="lineNum">    1911 </span><span class="lineCov">         21 :      if (label != NULL)</span></a>
<a name="1912"><span class="lineNum">    1912 </span>            :         {</a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(label-&gt;line &gt; 0);</span></a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(label-&gt;text != NULL);</span></a>
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<a name="1916"><span class="lineNum">    1916 </span>            :        // Note that an alternative to this switch would be to have the </a>
<a name="1917"><span class="lineNum">    1917 </span>            :        // apropriate virtual dunctioned defined in the IR nodes.</a>
<a name="1918"><span class="lineNum">    1918 </span><span class="lineNoCov">          0 :           switch (stmt-&gt;variantT())</span></a>
<a name="1919"><span class="lineNum">    1919 </span>            :              {</a>
<a name="1920"><span class="lineNum">    1920 </span><span class="lineNoCov">          0 :                case V_SgWhereStatement:</span></a>
<a name="1921"><span class="lineNum">    1921 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1922"><span class="lineNum">    1922 </span><span class="lineNoCov">          0 :                     SgWhereStatement* statement = isSgWhereStatement(stmt);</span></a>
<a name="1923"><span class="lineNum">    1923 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1924"><span class="lineNum">    1924 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1925"><span class="lineNum">    1925 </span>            :                   }</a>
<a name="1926"><span class="lineNum">    1926 </span>            : </a>
<a name="1927"><span class="lineNum">    1927 </span><span class="lineNoCov">          0 :                case V_SgFortranDo:</span></a>
<a name="1928"><span class="lineNum">    1928 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1929"><span class="lineNum">    1929 </span><span class="lineNoCov">          0 :                     SgFortranDo* statement = isSgFortranDo(stmt);</span></a>
<a name="1930"><span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1931"><span class="lineNum">    1931 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1932"><span class="lineNum">    1932 </span>            :                   }</a>
<a name="1933"><span class="lineNum">    1933 </span>            : </a>
<a name="1934"><span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                case V_SgIfStmt:</span></a>
<a name="1935"><span class="lineNum">    1935 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1936"><span class="lineNum">    1936 </span><span class="lineNoCov">          0 :                     SgIfStmt* statement = isSgIfStmt(stmt);</span></a>
<a name="1937"><span class="lineNum">    1937 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1938"><span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1939"><span class="lineNum">    1939 </span>            :                   }</a>
<a name="1940"><span class="lineNum">    1940 </span>            : </a>
<a name="1941"><span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                case V_SgForStatement:</span></a>
<a name="1942"><span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1943"><span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                     SgForStatement* statement = isSgForStatement(stmt);</span></a>
<a name="1944"><span class="lineNum">    1944 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1945"><span class="lineNum">    1945 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1946"><span class="lineNum">    1946 </span>            :                   }</a>
<a name="1947"><span class="lineNum">    1947 </span>            : </a>
<a name="1948"><span class="lineNum">    1948 </span><span class="lineNoCov">          0 :                case V_SgSwitchStatement:</span></a>
<a name="1949"><span class="lineNum">    1949 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1950"><span class="lineNum">    1950 </span><span class="lineNoCov">          0 :                     SgSwitchStatement* statement = isSgSwitchStatement(stmt);</span></a>
<a name="1951"><span class="lineNum">    1951 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1952"><span class="lineNum">    1952 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1953"><span class="lineNum">    1953 </span>            :                   }</a>
<a name="1954"><span class="lineNum">    1954 </span>            : </a>
<a name="1955"><span class="lineNum">    1955 </span><span class="lineNoCov">          0 :                case V_SgWhileStmt:</span></a>
<a name="1956"><span class="lineNum">    1956 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1957"><span class="lineNum">    1957 </span><span class="lineNoCov">          0 :                     SgWhileStmt* statement = isSgWhileStmt(stmt);</span></a>
<a name="1958"><span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                     statement-&gt;set_string_label(label-&gt;text);</span></a>
<a name="1959"><span class="lineNum">    1959 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="1960"><span class="lineNum">    1960 </span>            :                   }</a>
<a name="1961"><span class="lineNum">    1961 </span>            : </a>
<a name="1962"><span class="lineNum">    1962 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="1963"><span class="lineNum">    1963 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="1964"><span class="lineNum">    1964 </span><span class="lineNoCov">          0 :                     printf (&quot;Error: set_string_label() not defined for this statement = %p = %s \n&quot;,stmt,stmt-&gt;class_name().c_str());</span></a>
<a name="1965"><span class="lineNum">    1965 </span><span class="lineNoCov">          0 :                     ROSE_ABORT();</span></a>
<a name="1966"><span class="lineNum">    1966 </span>            :                   }</a>
<a name="1967"><span class="lineNum">    1967 </span>            :              }</a>
<a name="1968"><span class="lineNum">    1968 </span>            :         }</a>
<a name="1969"><span class="lineNum">    1969 </span><span class="lineCov">         21 :    }</span></a>
<a name="1970"><span class="lineNum">    1970 </span>            : </a>
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<a name="1972"><span class="lineNum">    1972 </span>            : void</a>
<a name="1973"><span class="lineNum">    1973 </span><span class="lineNoCov">          0 : trace_back_through_parent_scopes_searching_for_module (const SgName &amp; moduleName, SgScopeStatement* currentScope, SgClassSymbol* &amp; moduleSymbol )</span></a>
<a name="1974"><span class="lineNum">    1974 </span>            :    {</a>
<a name="1975"><span class="lineNum">    1975 </span>            :   // This function traces back through the parent scopes to search for the named module symbol in an outer scope</a>
<a name="1976"><span class="lineNum">    1976 </span>            :   // It returns NULL if it is not found in any scope.  It also chases all modules included via SgUseStatements.</a>
<a name="1977"><span class="lineNum">    1977 </span>            : </a>
<a name="1978"><span class="lineNum">    1978 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="1979"><span class="lineNum">    1979 </span><span class="lineNoCov">          0 :           printf (&quot;In trace_back_through_parent_scopes_searching_for_module(): moduleName = %s currentScope = %p \n&quot;,moduleName.str(),currentScope);</span></a>
<a name="1980"><span class="lineNum">    1980 </span>            : </a>
<a name="1981"><span class="lineNum">    1981 </span>            :   // Testing the scope stack...</a>
<a name="1982"><span class="lineNum">    1982 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="1983"><span class="lineNum">    1983 </span><span class="lineNoCov">          0 :      std::list&lt;SgScopeStatement*&gt;::iterator scopeInterator = astScopeStack.begin();</span></a>
<a name="1984"><span class="lineNum">    1984 </span><span class="lineNoCov">          0 :      while (scopeInterator != astScopeStack.end())</span></a>
<a name="1985"><span class="lineNum">    1985 </span>            :         {</a>
<a name="1986"><span class="lineNum">    1986 </span><span class="lineNoCov">          0 :           if ((*scopeInterator)-&gt;isCaseInsensitive() == false)</span></a>
<a name="1987"><span class="lineNum">    1987 </span>            :              {</a>
<a name="1988"><span class="lineNum">    1988 </span><span class="lineNoCov">          0 :                printf (&quot;##### Error (in initialize_global_scope_if_required): the scope handling is set to case sensitive scopeInterator = %p = %s \n&quot;,*scopeInterator,(*scopeInterator)-&gt;class_name().c_str());</span></a>
<a name="1989"><span class="lineNum">    1989 </span>            :             // (*scopeInterator)-&gt;setCaseInsensitive(true);</a>
<a name="1990"><span class="lineNum">    1990 </span>            :              }</a>
<a name="1991"><span class="lineNum">    1991 </span><span class="lineNoCov">          0 :           ROSE_ASSERT((*scopeInterator)-&gt;isCaseInsensitive() == true);</span></a>
<a name="1992"><span class="lineNum">    1992 </span><span class="lineNoCov">          0 :           scopeInterator++;</span></a>
<a name="1993"><span class="lineNum">    1993 </span>            :         }</a>
<a name="1994"><span class="lineNum">    1994 </span>            : </a>
<a name="1995"><span class="lineNum">    1995 </span>            :      SgScopeStatement* tempScope = currentScope;</a>
<a name="1996"><span class="lineNum">    1996 </span>            : </a>
<a name="1997"><span class="lineNum">    1997 </span>            :   // DQ (12/12/2007): Added test for if this is a function!</a>
<a name="1998"><span class="lineNum">    1998 </span><span class="lineNoCov">          0 :      while (moduleSymbol == NULL &amp;&amp; tempScope != NULL)</span></a>
<a name="1999"><span class="lineNum">    1999 </span>            :         {</a>
<a name="2000"><span class="lineNum">    2000 </span>            :        // Note that modules are represented at classes.</a>
<a name="2001"><span class="lineNum">    2001 </span><span class="lineNoCov">          0 :           moduleSymbol = tempScope-&gt;lookup_class_symbol(moduleName);</span></a>
<a name="2002"><span class="lineNum">    2002 </span>            : #if 0</a>
<a name="2003"><span class="lineNum">    2003 </span>            :           printf (&quot;In trace_back_through_parent_scopes_searching_for_module(): tempScope = %p = %s moduleSymbol = %p \n&quot;,</a>
<a name="2004"><span class="lineNum">    2004 </span>            :                tempScope,tempScope-&gt;class_name().c_str(),moduleSymbol);</a>
<a name="2005"><span class="lineNum">    2005 </span>            : #endif</a>
<a name="2006"><span class="lineNum">    2006 </span>            :        // If we have processed the global scope then we can stop (if we have not found the symbol at this</a>
<a name="2007"><span class="lineNum">    2007 </span>            :        // point then it is not available (or it is only availalbe through a USE statment.</a>
<a name="2008"><span class="lineNum">    2008 </span><span class="lineNoCov">          0 :           tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="2009"><span class="lineNum">    2009 </span>            :         }</a>
<a name="2010"><span class="lineNum">    2010 </span>            : </a>
<a name="2011"><span class="lineNum">    2011 </span>            :   // This function could have returned a NULL pointer if there was no symbol found ???</a>
<a name="2012"><span class="lineNum">    2012 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineNoCov">          0 :           printf (&quot;Leaving trace_back_through_parent_scopes_searching_for_module(): moduleSymbol = %p \n&quot;,moduleSymbol);</span></a>
<a name="2014"><span class="lineNum">    2014 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="2015"><span class="lineNum">    2015 </span>            : </a>
<a name="2016"><span class="lineNum">    2016 </span>            : void</a>
<a name="2017"><span class="lineNum">    2017 </span><span class="lineCov">        858 : trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(const SgName &amp; variableName, SgScopeStatement* currentScope, SgVariableSymbol* &amp; variableSymbol, SgFunctionSymbol* &amp; functionSymbol, SgClassSymbol* &amp; classSymbol)</span></a>
<a name="2018"><span class="lineNum">    2018 </span>            :    {</a>
<a name="2019"><span class="lineNum">    2019 </span>            :   // This function traces back through the parent scopes to search for the named symbol in an outer scope</a>
<a name="2020"><span class="lineNum">    2020 </span>            :   // It returns NULL if it is not found in any scope.  Is does not look in any scopes specified using a </a>
<a name="2021"><span class="lineNum">    2021 </span>            :   // C++ using declaration (SgUsingDeclarationStatement), using directives (SgUsingDirectiveStatement), a</a>
<a name="2022"><span class="lineNum">    2022 </span>            :   // Fortran use statement (SgUseStatement).  This will be done in another function, not yet implemented.</a>
<a name="2023"><span class="lineNum">    2023 </span>            : </a>
<a name="2024"><span class="lineNum">    2024 </span>            :   // DQ (4/29/2008): Added support for detecting SgClassSymbol IR nodes (fro drived types).</a>
<a name="2025"><span class="lineNum">    2025 </span>            : </a>
<a name="2026"><span class="lineNum">    2026 </span><span class="lineCov">        858 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2027"><span class="lineNum">    2027 </span><span class="lineNoCov">          0 :           printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(): variableName = %s currentScope = %p = %s \n&quot;,variableName.str(),currentScope,currentScope-&gt;class_name().c_str());</span></a>
<a name="2028"><span class="lineNum">    2028 </span>            : </a>
<a name="2029"><span class="lineNum">    2029 </span>            : #if 0</a>
<a name="2030"><span class="lineNum">    2030 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2031"><span class="lineNum">    2031 </span>            :      outputState(&quot;In trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable()&quot;);</a>
<a name="2032"><span class="lineNum">    2032 </span>            : #endif</a>
<a name="2033"><span class="lineNum">    2033 </span>            : </a>
<a name="2034"><span class="lineNum">    2034 </span>            :   // printf (&quot;############### Could this variable = %s be a data member in a module? ############## \n&quot;,variableName.str());</a>
<a name="2035"><span class="lineNum">    2035 </span>            : </a>
<a name="2036"><span class="lineNum">    2036 </span>            :   // Testing the scope stack...(debugging code for case insensitive symbol table handling)</a>
<a name="2037"><span class="lineNum">    2037 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="2038"><span class="lineNum">    2038 </span><span class="lineCov">        858 :      std::list&lt;SgScopeStatement*&gt;::iterator scopeInterator = astScopeStack.begin();</span></a>
<a name="2039"><span class="lineNum">    2039 </span><span class="lineCov">       3628 :      while (scopeInterator != astScopeStack.end())</span></a>
<a name="2040"><span class="lineNum">    2040 </span>            :         {</a>
<a name="2041"><span class="lineNum">    2041 </span><span class="lineCov">       2770 :           if ((*scopeInterator)-&gt;isCaseInsensitive() == false)</span></a>
<a name="2042"><span class="lineNum">    2042 </span>            :              {</a>
<a name="2043"><span class="lineNum">    2043 </span><span class="lineNoCov">          0 :                printf (&quot;##### Error (in initialize_global_scope_if_required): the scope handling is set to case sensitive scopeInterator = %p = %s \n&quot;,*scopeInterator,(*scopeInterator)-&gt;class_name().c_str());</span></a>
<a name="2044"><span class="lineNum">    2044 </span>            :             // (*scopeInterator)-&gt;setCaseInsensitive(true);</a>
<a name="2045"><span class="lineNum">    2045 </span>            :              }</a>
<a name="2046"><span class="lineNum">    2046 </span><span class="lineCov">       2770 :           ROSE_ASSERT((*scopeInterator)-&gt;isCaseInsensitive() == true);</span></a>
<a name="2047"><span class="lineNum">    2047 </span><span class="lineCov">       3628 :           scopeInterator++;</span></a>
<a name="2048"><span class="lineNum">    2048 </span>            :         }</a>
<a name="2049"><span class="lineNum">    2049 </span>            : </a>
<a name="2050"><span class="lineNum">    2050 </span>            :   // DQ (12/21/2010): Reset these to NULL before evaluating the current scoep for a variable, function, or class with the target name.</a>
<a name="2051"><span class="lineNum">    2051 </span><span class="lineCov">        858 :      variableSymbol = NULL;</span></a>
<a name="2052"><span class="lineNum">    2052 </span><span class="lineCov">        858 :      functionSymbol = NULL;</span></a>
<a name="2053"><span class="lineNum">    2053 </span><span class="lineCov">        858 :      classSymbol    = NULL;</span></a>
<a name="2054"><span class="lineNum">    2054 </span>            : </a>
<a name="2055"><span class="lineNum">    2055 </span>            :   // SgVariableSymbol* variableSymbol = NULL;</a>
<a name="2056"><span class="lineNum">    2056 </span>            :   // SgFunctionSymbol* functionSymbol = NULL;</a>
<a name="2057"><span class="lineNum">    2057 </span><span class="lineCov">        858 :      SgScopeStatement* tempScope = currentScope;</span></a>
<a name="2058"><span class="lineNum">    2058 </span>            : </a>
<a name="2059"><span class="lineNum">    2059 </span>            :   // DQ (12/12/2007): Added test for if this is a function!</a>
<a name="2060"><span class="lineNum">    2060 </span>            :   // while (variableSymbol == NULL &amp;&amp; tempScope != NULL)</a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineCov">       2899 :      while (variableSymbol == NULL &amp;&amp; functionSymbol == NULL &amp;&amp; classSymbol == NULL &amp;&amp; tempScope != NULL)</span></a>
<a name="2062"><span class="lineNum">    2062 </span>            :         {</a>
<a name="2063"><span class="lineNum">    2063 </span>            : #if 0</a>
<a name="2064"><span class="lineNum">    2064 </span>            :           printf (&quot;Searching in scope = %p = %s \n&quot;,tempScope,tempScope-&gt;class_name().c_str());</a>
<a name="2065"><span class="lineNum">    2065 </span>            :           tempScope-&gt;get_startOfConstruct()-&gt;display(&quot;Searching in scope&quot;);</a>
<a name="2066"><span class="lineNum">    2066 </span>            : #endif</a>
<a name="2067"><span class="lineNum">    2067 </span>            :        // DQ (11/26/2010): The variable name that we will search for needs to be case normalized (see test2010_112.f90).</a>
<a name="2068"><span class="lineNum">    2068 </span><span class="lineCov">       2041 :           variableSymbol = tempScope-&gt;lookup_variable_symbol(variableName);</span></a>
<a name="2069"><span class="lineNum">    2069 </span><span class="lineCov">       2041 :           functionSymbol = tempScope-&gt;lookup_function_symbol(variableName);</span></a>
<a name="2070"><span class="lineNum">    2070 </span><span class="lineCov">       2041 :           classSymbol    = tempScope-&gt;lookup_class_symbol(variableName);</span></a>
<a name="2071"><span class="lineNum">    2071 </span>            : #if 0</a>
<a name="2072"><span class="lineNum">    2072 </span>            :           printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(): tempScope = %p = %s variableSymbol = %p functionSymbol = %p classSymbol = %p \n&quot;,</a>
<a name="2073"><span class="lineNum">    2073 </span>            :                tempScope,tempScope-&gt;class_name().c_str(),variableSymbol,functionSymbol,classSymbol);</a>
<a name="2074"><span class="lineNum">    2074 </span>            : #endif</a>
<a name="2075"><span class="lineNum">    2075 </span>            : </a>
<a name="2076"><span class="lineNum">    2076 </span>            : #if 0</a>
<a name="2077"><span class="lineNum">    2077 </span>            :           tempScope-&gt;print_symboltable(&quot;In trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable()&quot;);</a>
<a name="2078"><span class="lineNum">    2078 </span>            : #endif</a>
<a name="2079"><span class="lineNum">    2079 </span>            : </a>
<a name="2080"><span class="lineNum">    2080 </span>            :        // If we have processed the global scope then we can stop (if we have not found the symbol at this</a>
<a name="2081"><span class="lineNum">    2081 </span>            :        // point then it is not available (or it is only available through a USE statment and we have not </a>
<a name="2082"><span class="lineNum">    2082 </span>            :        // implemented that support yet.</a>
<a name="2083"><span class="lineNum">    2083 </span><span class="lineCov">       2041 :           tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="2084"><span class="lineNum">    2084 </span>            :         }</a>
<a name="2085"><span class="lineNum">    2085 </span>            : </a>
<a name="2086"><span class="lineNum">    2086 </span>            : #if 0</a>
<a name="2087"><span class="lineNum">    2087 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2088"><span class="lineNum">    2088 </span>            :      outputState(&quot;At BOTTOM of trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable()&quot;);</a>
<a name="2089"><span class="lineNum">    2089 </span>            : #endif</a>
<a name="2090"><span class="lineNum">    2090 </span>            : </a>
<a name="2091"><span class="lineNum">    2091 </span>            : #if 0</a>
<a name="2092"><span class="lineNum">    2092 </span>            :   // This function could have returned a NULL pointer if there was no symbol found ???</a>
<a name="2093"><span class="lineNum">    2093 </span>            :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="2094"><span class="lineNum">    2094 </span>            :           printf (&quot;Leaving trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(): variableSymbol = %p functionSymbol = %p \n&quot;,variableSymbol,functionSymbol);</a>
<a name="2095"><span class="lineNum">    2095 </span>            : #endif</a>
<a name="2096"><span class="lineNum">    2096 </span><span class="lineCov">        858 :    }</span></a>
<a name="2097"><span class="lineNum">    2097 </span>            : </a>
<a name="2098"><span class="lineNum">    2098 </span>            : // void build_implicit_program_statement_if_required();</a>
<a name="2099"><span class="lineNum">    2099 </span>            : </a>
<a name="2100"><span class="lineNum">    2100 </span>            : SgVariableSymbol*</a>
<a name="2101"><span class="lineNum">    2101 </span><span class="lineCov">        156 : trace_back_through_parent_scopes_lookup_variable_symbol(const SgName &amp; variableName, SgScopeStatement* currentScope )</span></a>
<a name="2102"><span class="lineNum">    2102 </span>            :    {</a>
<a name="2103"><span class="lineNum">    2103 </span>            :   // This function traces back through the parent scopes to search for the named symbol in an outer scope</a>
<a name="2104"><span class="lineNum">    2104 </span>            :   // Semantics of this function:</a>
<a name="2105"><span class="lineNum">    2105 </span>            :   //    It returns NULL if the named variable is not found in any scope.</a>
<a name="2106"><span class="lineNum">    2106 </span>            :   //    If the variable should be implicitly defined then it is built, but the function still returns NULL.</a>
<a name="2107"><span class="lineNum">    2107 </span>            :   // Note that this means that using it to get the symbol for an implicitly defined variable that has not </a>
<a name="2108"><span class="lineNum">    2108 </span>            :   // been used required calling the function twice.</a>
<a name="2109"><span class="lineNum">    2109 </span>            : </a>
<a name="2110"><span class="lineNum">    2110 </span>            :   // Whe looking at scopes this function does not look in any scopes specified using a </a>
<a name="2111"><span class="lineNum">    2111 </span>            :   // C++ using declaration (SgUsingDeclarationStatement), using directives (SgUsingDirectiveStatement), a</a>
<a name="2112"><span class="lineNum">    2112 </span>            :   // Fortran use statement (SgUseStatement).  This is handled by having SgAliasSymbol to represent such </a>
<a name="2113"><span class="lineNum">    2113 </span>            :   // symbols that have been imported into the associated scope of the using declarations (or use statement </a>
<a name="2114"><span class="lineNum">    2114 </span>            :   // in fortran).</a>
<a name="2115"><span class="lineNum">    2115 </span>            : </a>
<a name="2116"><span class="lineNum">    2116 </span>            : #if 0</a>
<a name="2117"><span class="lineNum">    2117 </span>            :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="2118"><span class="lineNum">    2118 </span>            :           printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol(): variableName = %s currentScope = %p \n&quot;,variableName.str(),currentScope);</a>
<a name="2119"><span class="lineNum">    2119 </span>            : #endif</a>
<a name="2120"><span class="lineNum">    2120 </span>            : </a>
<a name="2121"><span class="lineNum">    2121 </span>            :   // An AttributeSpecification statement can be the first statement in a program</a>
<a name="2122"><span class="lineNum">    2122 </span>            :   // (see test2007_213.f, if so then this can be one of the first c_action statements called.</a>
<a name="2123"><span class="lineNum">    2123 </span>            :   // build_implicit_program_statement_if_required();</a>
<a name="2124"><span class="lineNum">    2124 </span>            : </a>
<a name="2125"><span class="lineNum">    2125 </span><span class="lineCov">        156 :      SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="2126"><span class="lineNum">    2126 </span><span class="lineCov">        156 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="2127"><span class="lineNum">    2127 </span><span class="lineCov">        156 :      SgClassSymbol*    classSymbol    = NULL;</span></a>
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<a name="2129"><span class="lineNum">    2129 </span>            :   // trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(variableName,currentScope,variableSymbol,functionSymbol);</a>
<a name="2130"><span class="lineNum">    2130 </span><span class="lineCov">        156 :      trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(variableName,currentScope,variableSymbol,functionSymbol,classSymbol);</span></a>
<a name="2131"><span class="lineNum">    2131 </span>            : </a>
<a name="2132"><span class="lineNum">    2132 </span>            : #if 0</a>
<a name="2133"><span class="lineNum">    2133 </span>            :      printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol(): variableSymbol = %p \n&quot;,variableSymbol);</a>
<a name="2134"><span class="lineNum">    2134 </span>            :      printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol(): functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="2135"><span class="lineNum">    2135 </span>            :      printf (&quot;In trace_back_through_parent_scopes_lookup_variable_symbol(): classSymbol    = %p \n&quot;,classSymbol);</a>
<a name="2136"><span class="lineNum">    2136 </span>            : #endif</a>
<a name="2137"><span class="lineNum">    2137 </span>            : </a>
<a name="2138"><span class="lineNum">    2138 </span>            : #if 0</a>
<a name="2139"><span class="lineNum">    2139 </span>            :      printf (&quot;Output the symbol table at the current scope (debugging): \n&quot;);</a>
<a name="2140"><span class="lineNum">    2140 </span>            :      currentScope-&gt;get_symbol_table()-&gt;print(&quot;Output the symbol table at the current scope&quot;);</a>
<a name="2141"><span class="lineNum">    2141 </span>            : #endif</a>
<a name="2142"><span class="lineNum">    2142 </span>            : </a>
<a name="2143"><span class="lineNum">    2143 </span><span class="lineCov">        169 :      if ( (variableSymbol == NULL) &amp;&amp; functionSymbol == NULL &amp;&amp; classSymbol == NULL &amp;&amp; (matchAgainstIntrinsicFunctionList(variableName.str()) == false) )</span></a>
<a name="2144"><span class="lineNum">    2144 </span>            :         {</a>
<a name="2145"><span class="lineNum">    2145 </span>            :        // FMZ(1/8/2010)</a>
<a name="2146"><span class="lineNum">    2146 </span>            :        // if the Id name is &quot;team_world&quot; or &quot;team_default&quot;, generate team,external:: declarations</a>
<a name="2147"><span class="lineNum">    2147 </span><span class="lineCov">         13 :           {</span></a>
<a name="2148"><span class="lineNum">    2148 </span><span class="lineCov">         13 :             string teamName = variableName.str();</span></a>
<a name="2149"><span class="lineNum">    2149 </span><span class="lineCov">         13 :             std::transform(teamName.begin(),teamName.end(),teamName.begin(),::tolower);</span></a>
<a name="2150"><span class="lineNum">    2150 </span>            : </a>
<a name="2151"><span class="lineNum">    2151 </span><span class="lineCov">         26 :             string teamWorld =   &quot;team_world&quot;;</span></a>
<a name="2152"><span class="lineNum">    2152 </span><span class="lineCov">         26 :             string teamDefault = &quot;team_default&quot;;</span></a>
<a name="2153"><span class="lineNum">    2153 </span><span class="lineCov">         13 :             if (teamName == teamWorld || teamName == teamDefault)</span></a>
<a name="2154"><span class="lineNum">    2154 </span>            :                {</a>
<a name="2155"><span class="lineNum">    2155 </span><span class="lineNoCov">          0 :                  return   add_external_team_decl(teamName);</span></a>
<a name="2156"><span class="lineNum">    2156 </span>            :                }</a>
<a name="2157"><span class="lineNum">    2157 </span>            :           }</a>
<a name="2158"><span class="lineNum">    2158 </span>            : </a>
<a name="2159"><span class="lineNum">    2159 </span><span class="lineCov">         13 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2160"><span class="lineNum">    2160 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: trace_back_through_parent_scopes_lookup_variable_symbol(): could not locate the specified variable (for %s) in any outer symbol table: astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,variableName.str(),astNameStack.size());</span></a>
<a name="2161"><span class="lineNum">    2161 </span>            :        // printf (&quot;astNameStack.front() = %p = %s = %s \n&quot;,astNameStack.front(),astNameStack.front()-&gt;class_name().c_str(),SageInterface::get_name(astNameStack.front()).c_str());</a>
<a name="2162"><span class="lineNum">    2162 </span>            : </a>
<a name="2163"><span class="lineNum">    2163 </span><span class="lineCov">         13 :           if (astNameStack.empty() == false)</span></a>
<a name="2164"><span class="lineNum">    2164 </span>            :              {</a>
<a name="2165"><span class="lineNum">    2165 </span><span class="lineCov">         13 :                if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2166"><span class="lineNum">    2166 </span><span class="lineNoCov">          0 :                     printf (&quot;astNameStack.front() = %p = %s \n&quot;,astNameStack.front(),astNameStack.front()-&gt;text);</span></a>
<a name="2167"><span class="lineNum">    2167 </span>            :              }</a>
<a name="2168"><span class="lineNum">    2168 </span>            : </a>
<a name="2169"><span class="lineNum">    2169 </span>            :        // Check if this is a scope using implicit none rules, however for now even if we know it is function we </a>
<a name="2170"><span class="lineNum">    2170 </span>            :        // first build it as a variable and later convert it to either an array or a function (or a derived type).</a>
<a name="2171"><span class="lineNum">    2171 </span><span class="lineCov">         13 :           bool isAnImplicitNoneScope = isImplicitNoneScope();</span></a>
<a name="2172"><span class="lineNum">    2172 </span><span class="lineCov">         13 :           if (isAnImplicitNoneScope == true)</span></a>
<a name="2173"><span class="lineNum">    2173 </span>            :              {</a>
<a name="2174"><span class="lineNum">    2174 </span>            :             // This has to be a function call since we can't be building a variable to represent an implicitly type variable. </a>
<a name="2175"><span class="lineNum">    2175 </span>            :             // See jacobi.f for an example of this. Also, currently test2010_45.f90 demonstrates a case of &quot;integer x = 42, y = x&quot; </a>
<a name="2176"><span class="lineNum">    2176 </span>            :             // where the initializer to &quot;y&quot; is not built as a symbol yet as part of the construction of the variable declaration.</a>
<a name="2177"><span class="lineNum">    2177 </span>            : #if 0</a>
<a name="2178"><span class="lineNum">    2178 </span>            :                outputState(&quot;scope marked as implicit none, so we must construct function in trace_back_through_parent_scopes_lookup_variable_symbol()&quot;);</a>
<a name="2179"><span class="lineNum">    2179 </span>            : #endif</a>
<a name="2180"><span class="lineNum">    2180 </span>            :             // DQ (9/11/2010): Since this must be a function, we can build a function reference expression and a function declaration, but in what scope.</a>
<a name="2181"><span class="lineNum">    2181 </span>            :             // Or we could define a list of unresolved functions and fix them up at the end of the module or global scope.  This is a general problem</a>
<a name="2182"><span class="lineNum">    2182 </span>            :             // and demonstrated by test2010_46.f90 </a>
<a name="2183"><span class="lineNum">    2183 </span><span class="lineNoCov">          0 :                if (astNameStack.empty() != false)</span></a>
<a name="2184"><span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                     cerr &lt;&lt; &quot;Error: name stack is empty when handling variable:&quot;&lt;&lt;variableName.str() &lt;&lt; endl;</span></a>
<a name="2185"><span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(astNameStack.empty() == false);</span></a>
<a name="2186"><span class="lineNum">    2186 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(astNameStack.front()-&gt;text != NULL);</span></a>
<a name="2187"><span class="lineNum">    2187 </span>            : </a>
<a name="2188"><span class="lineNum">    2188 </span><span class="lineNoCov">          0 :                SgName name = astNameStack.front()-&gt;text;</span></a>
<a name="2189"><span class="lineNum">    2189 </span>            :             // astNameStack.pop_front();</a>
<a name="2190"><span class="lineNum">    2190 </span>            : </a>
<a name="2191"><span class="lineNum">    2191 </span>            :             // Define this as a function returning void type for now, but it will have to be fixed when we finally see the function definition.</a>
<a name="2192"><span class="lineNum">    2192 </span><span class="lineNoCov">          0 :                SgFunctionType* functionType             = new SgFunctionType (SgTypeVoid::createType());</span></a>
<a name="2193"><span class="lineNum">    2193 </span>            : #if 0</a>
<a name="2194"><span class="lineNum">    2194 </span>            :                printf (&quot;#########################################  functionType = %p ####################################### \n&quot;,functionType);</a>
<a name="2195"><span class="lineNum">    2195 </span>            : #endif</a>
<a name="2196"><span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                SgFunctionDefinition* functionDefinition = NULL;</span></a>
<a name="2197"><span class="lineNum">    2197 </span>            : </a>
<a name="2198"><span class="lineNum">    2198 </span><span class="lineNoCov">          0 :                SgProcedureHeaderStatement* functionDeclaration = new SgProcedureHeaderStatement(name,functionType,functionDefinition);</span></a>
<a name="2199"><span class="lineNum">    2199 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration != NULL);</span></a>
<a name="2200"><span class="lineNum">    2200 </span>            : </a>
<a name="2201"><span class="lineNum">    2201 </span>            :             // We have not yet seen the declaration for this function so it can only be marked as compiler gnerated for now!</a>
<a name="2202"><span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                setSourcePosition(functionDeclaration);</span></a>
<a name="2203"><span class="lineNum">    2203 </span><span class="lineNoCov">          0 :                setSourcePosition(functionDeclaration-&gt;get_parameterList());</span></a>
<a name="2204"><span class="lineNum">    2204 </span>            : </a>
<a name="2205"><span class="lineNum">    2205 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="2206"><span class="lineNum">    2206 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="2207"><span class="lineNum">    2207 </span>            : </a>
<a name="2208"><span class="lineNum">    2208 </span><span class="lineNoCov">          0 :                setSourcePositionCompilerGenerated(functionDeclaration);</span></a>
<a name="2209"><span class="lineNum">    2209 </span><span class="lineNoCov">          0 :                setSourcePositionCompilerGenerated(functionDeclaration-&gt;get_parameterList());</span></a>
<a name="2210"><span class="lineNum">    2210 </span>            : </a>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="2212"><span class="lineNum">    2212 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="2213"><span class="lineNum">    2213 </span>            : </a>
<a name="2214"><span class="lineNum">    2214 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbol == NULL);</span></a>
<a name="2215"><span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                functionSymbol = new SgFunctionSymbol(functionDeclaration);</span></a>
<a name="2216"><span class="lineNum">    2216 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="2217"><span class="lineNum">    2217 </span>            : </a>
<a name="2218"><span class="lineNum">    2218 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="2219"><span class="lineNum">    2219 </span><span class="lineNoCov">          0 :                SgScopeStatement* scope = astScopeStack.back();</span></a>
<a name="2220"><span class="lineNum">    2220 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope != NULL);</span></a>
<a name="2221"><span class="lineNum">    2221 </span><span class="lineNoCov">          0 :                SgGlobal* globalScope = isSgGlobal(scope);</span></a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="2223"><span class="lineNum">    2223 </span>            : </a>
<a name="2224"><span class="lineNum">    2224 </span>            :                // Pei-Hung (07/18/2019) Set the scope to the module scope if a module exists.</a>
<a name="2225"><span class="lineNum">    2225 </span>            :                // There is a case in test2019_module_1_file.f90 and test2019_module_2_file.f90</a>
<a name="2226"><span class="lineNum">    2226 </span>            :                // that the function symbol lookup found the wrong function due to function name conflict</a>
<a name="2227"><span class="lineNum">    2227 </span><span class="lineNoCov">          0 :                SgScopeStatement* tempScope = currentScope;</span></a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineNoCov">          0 :                SgClassDefinition* moduleScope = NULL;</span></a>
<a name="2229"><span class="lineNum">    2229 </span>            :                // Set the scope to closest module scope if it exists</a>
<a name="2230"><span class="lineNum">    2230 </span><span class="lineNoCov">          0 :                while(moduleScope == NULL &amp;&amp; tempScope != globalScope)</span></a>
<a name="2231"><span class="lineNum">    2231 </span>            :                {</a>
<a name="2232"><span class="lineNum">    2232 </span><span class="lineNoCov">          0 :                   moduleScope = isSgClassDefinition(tempScope);</span></a>
<a name="2233"><span class="lineNum">    2233 </span><span class="lineNoCov">          0 :                   tempScope = tempScope-&gt;get_scope();</span></a>
<a name="2234"><span class="lineNum">    2234 </span>            :                }</a>
<a name="2235"><span class="lineNum">    2235 </span><span class="lineNoCov">          0 :                scope = (moduleScope == NULL) ? isSgScopeStatement(globalScope) : isSgScopeStatement(moduleScope);</span></a>
<a name="2236"><span class="lineNum">    2236 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(scope != NULL);</span></a>
<a name="2237"><span class="lineNum">    2237 </span>            : </a>
<a name="2238"><span class="lineNum">    2238 </span>            :             // Set the scope to be global scope since we have not yet seen the function definition!</a>
<a name="2239"><span class="lineNum">    2239 </span>            :             // If it was from a module, then the module should have been included. If we were in a </a>
<a name="2240"><span class="lineNum">    2240 </span>            :             // module then this should be fixed up at the end of the module scope (and we will have </a>
<a name="2241"><span class="lineNum">    2241 </span>            :             // seen the function definition by then).  If this needs to be fixed up in global scope </a>
<a name="2242"><span class="lineNum">    2242 </span>            :             // then we will see the function definition by then (at the end of the translation unit).</a>
<a name="2243"><span class="lineNum">    2243 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;set_scope(scope);</span></a>
<a name="2244"><span class="lineNum">    2244 </span>            : </a>
<a name="2245"><span class="lineNum">    2245 </span>            :             // We also have to set the first non-defining declaration.</a>
<a name="2246"><span class="lineNum">    2246 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;set_firstNondefiningDeclaration(functionDeclaration);</span></a>
<a name="2247"><span class="lineNum">    2247 </span>            : </a>
<a name="2248"><span class="lineNum">    2248 </span>            :             // We also have to set the parent...</a>
<a name="2249"><span class="lineNum">    2249 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_parent() == NULL);</span></a>
<a name="2250"><span class="lineNum">    2250 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;set_parent(scope);</span></a>
<a name="2251"><span class="lineNum">    2251 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionDeclaration-&gt;get_parent() != NULL);</span></a>
<a name="2252"><span class="lineNum">    2252 </span>            : </a>
<a name="2253"><span class="lineNum">    2253 </span>            :             // printf (&quot;Adding function name = %s to the global scope (even though we have not seen the definition yet) \n&quot;,name.str());</a>
<a name="2254"><span class="lineNum">    2254 </span><span class="lineNoCov">          0 :                scope-&gt;insert_symbol(name,functionSymbol);</span></a>
<a name="2255"><span class="lineNum">    2255 </span>            : </a>
<a name="2256"><span class="lineNum">    2256 </span>            :             // Add this function to the list of unresolved functions so that we can fixup the AST afterward (close of module scope or close of global scope).</a>
<a name="2257"><span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                astUnresolvedFunctionsList.push_front(functionDeclaration);</span></a>
<a name="2258"><span class="lineNum">    2258 </span>            : #if 0</a>
<a name="2259"><span class="lineNum">    2259 </span>            :                printf (&quot;Error: scope marked as implict none, so we must construct name = %s as a function (function reference expression) \n&quot;,variableName.str());</a>
<a name="2260"><span class="lineNum">    2260 </span>            :                ROSE_ABORT();</a>
<a name="2261"><span class="lineNum">    2261 </span>            : #endif</a>
<a name="2262"><span class="lineNum">    2262 </span>            :              }</a>
<a name="2263"><span class="lineNum">    2263 </span>            :             else</a>
<a name="2264"><span class="lineNum">    2264 </span>            :              {</a>
<a name="2265"><span class="lineNum">    2265 </span>            :             // printf (&quot;NOTE: CANCLED SEMANTICS THAT BUILD IMPLICIT VARIABLE SYMBOLS \n&quot;);</a>
<a name="2266"><span class="lineNum">    2266 </span>            :              }</a>
<a name="2267"><span class="lineNum">    2267 </span>            :         }</a>
<a name="2268"><span class="lineNum">    2268 </span>            : </a>
<a name="2269"><span class="lineNum">    2269 </span>            : #if 0</a>
<a name="2270"><span class="lineNum">    2270 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2271"><span class="lineNum">    2271 </span>            :      outputState(&quot;At BOTTOM of trace_back_through_parent_scopes_lookup_variable_symbol()&quot;);</a>
<a name="2272"><span class="lineNum">    2272 </span>            : #endif</a>
<a name="2273"><span class="lineNum">    2273 </span>            : </a>
<a name="2274"><span class="lineNum">    2274 </span>            : #if 0</a>
<a name="2275"><span class="lineNum">    2275 </span>            :   // This function could have returned a NULL pointer if there was no symbol found ???</a>
<a name="2276"><span class="lineNum">    2276 </span>            :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="2277"><span class="lineNum">    2277 </span>            :           printf (&quot;Leaving trace_back_through_parent_scopes_lookup_variable_symbol(): variableSymbol = %p functionSymbol = %p \n&quot;,variableSymbol,functionSymbol);</a>
<a name="2278"><span class="lineNum">    2278 </span>            : #endif</a>
<a name="2279"><span class="lineNum">    2279 </span>            : </a>
<a name="2280"><span class="lineNum">    2280 </span><span class="lineCov">        156 :      return variableSymbol;</span></a>
<a name="2281"><span class="lineNum">    2281 </span>            :    }</a>
<a name="2282"><span class="lineNum">    2282 </span>            : </a>
<a name="2283"><span class="lineNum">    2283 </span>            : // DXN (08/15/2011)</a>
<a name="2284"><span class="lineNum">    2284 </span>            : // Refactored code to find the scope of a given SgClassType;</a>
<a name="2285"><span class="lineNum">    2285 </span><span class="lineNoCov">          0 : void findClassTypeStructureScope (SgClassType* classType, SgScopeStatement*&amp; structureScope) {</span></a>
<a name="2286"><span class="lineNum">    2286 </span><span class="lineNoCov">          0 :     SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType-&gt;get_declaration());</span></a>
<a name="2287"><span class="lineNum">    2287 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(classDeclaration != NULL);</span></a>
<a name="2288"><span class="lineNum">    2288 </span><span class="lineNoCov">          0 :     SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration-&gt;get_definingDeclaration());</span></a>
<a name="2289"><span class="lineNum">    2289 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(definingClassDeclaration != NULL);</span></a>
<a name="2290"><span class="lineNum">    2290 </span><span class="lineNoCov">          0 :     SgClassDefinition* classDefinition = definingClassDeclaration-&gt;get_definition();</span></a>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineNoCov">          0 :     ROSE_ASSERT(classDefinition != NULL);</span></a>
<a name="2292"><span class="lineNum">    2292 </span><span class="lineNoCov">          0 :     structureScope = classDefinition;</span></a>
<a name="2293"><span class="lineNum">    2293 </span><span class="lineNoCov">          0 : }</span></a>
<a name="2294"><span class="lineNum">    2294 </span>            : </a>
<a name="2295"><span class="lineNum">    2295 </span>            : // DXN (08/15/2011)</a>
<a name="2296"><span class="lineNum">    2296 </span>            : // Refactored code to find the scope of a given type;</a>
<a name="2297"><span class="lineNum">    2297 </span>            : // Called by trace_back_through_parent_scopes_lookup_member_variable_symbol.</a>
<a name="2298"><span class="lineNum">    2298 </span><span class="lineCov">        248 : void findStructureScope (SgType* type, SgScopeStatement*&amp; structureScope)</span></a>
<a name="2299"><span class="lineNum">    2299 </span>            : {</a>
<a name="2300"><span class="lineNum">    2300 </span><span class="lineCov">        248 :     switch (type-&gt;variantT())</span></a>
<a name="2301"><span class="lineNum">    2301 </span>            :     {</a>
<a name="2302"><span class="lineNum">    2302 </span>            :     // This type will continue the search for multi-type references.</a>
<a name="2303"><span class="lineNum">    2303 </span><span class="lineNoCov">          0 :        case V_SgClassType:</span></a>
<a name="2304"><span class="lineNum">    2304 </span><span class="lineNoCov">          0 :           {</span></a>
<a name="2305"><span class="lineNum">    2305 </span><span class="lineNoCov">          0 :             findClassTypeStructureScope(isSgClassType(type), structureScope);</span></a>
<a name="2306"><span class="lineNum">    2306 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="2307"><span class="lineNum">    2307 </span>            :           }</a>
<a name="2308"><span class="lineNum">    2308 </span>            : </a>
<a name="2309"><span class="lineNum">    2309 </span><span class="lineCov">         24 :        case V_SgArrayType:</span></a>
<a name="2310"><span class="lineNum">    2310 </span><span class="lineCov">         24 :           {</span></a>
<a name="2311"><span class="lineNum">    2311 </span><span class="lineCov">         24 :             SgArrayType* arrayType = isSgArrayType(type);</span></a>
<a name="2312"><span class="lineNum">    2312 </span><span class="lineCov">         24 :             SgType* baseType = arrayType-&gt;get_base_type();</span></a>
<a name="2313"><span class="lineNum">    2313 </span><span class="lineCov">         24 :             ROSE_ASSERT(baseType != NULL);</span></a>
<a name="2314"><span class="lineNum">    2314 </span><span class="lineCov">         24 :             findStructureScope(baseType, structureScope);</span></a>
<a name="2315"><span class="lineNum">    2315 </span><span class="lineCov">         24 :             break;</span></a>
<a name="2316"><span class="lineNum">    2316 </span>            :           }</a>
<a name="2317"><span class="lineNum">    2317 </span>            : </a>
<a name="2318"><span class="lineNum">    2318 </span><span class="lineCov">          3 :        case V_SgPointerType:</span></a>
<a name="2319"><span class="lineNum">    2319 </span><span class="lineCov">          3 :           {</span></a>
<a name="2320"><span class="lineNum">    2320 </span><span class="lineCov">          3 :             SgPointerType* pointerType = isSgPointerType(type);</span></a>
<a name="2321"><span class="lineNum">    2321 </span><span class="lineCov">          3 :             SgType* baseType = pointerType-&gt;get_base_type();</span></a>
<a name="2322"><span class="lineNum">    2322 </span><span class="lineCov">          3 :             ROSE_ASSERT(baseType != NULL);</span></a>
<a name="2323"><span class="lineNum">    2323 </span><span class="lineCov">          3 :             findStructureScope(baseType, structureScope);</span></a>
<a name="2324"><span class="lineNum">    2324 </span><span class="lineCov">          3 :             break;</span></a>
<a name="2325"><span class="lineNum">    2325 </span>            :           }</a>
<a name="2326"><span class="lineNum">    2326 </span>            : </a>
<a name="2327"><span class="lineNum">    2327 </span>            :     // DQ (12/29/2010): Added new types...</a>
<a name="2328"><span class="lineNum">    2328 </span><span class="lineCov">        221 :        case V_SgTypeDouble:</span></a>
<a name="2329"><span class="lineNum">    2329 </span><span class="lineCov">        221 :        case V_SgTypeChar:</span></a>
<a name="2330"><span class="lineNum">    2330 </span>            : </a>
<a name="2331"><span class="lineNum">    2331 </span>            :     // These types will terminate the search for names from multi-part references.</a>
<a name="2332"><span class="lineNum">    2332 </span><span class="lineCov">        221 :        case V_SgTypeString:</span></a>
<a name="2333"><span class="lineNum">    2333 </span><span class="lineCov">        221 :        case V_SgTypeFloat:</span></a>
<a name="2334"><span class="lineNum">    2334 </span><span class="lineCov">        221 :        case V_SgTypeBool:</span></a>
<a name="2335"><span class="lineNum">    2335 </span><span class="lineCov">        221 :        case V_SgTypeInt:</span></a>
<a name="2336"><span class="lineNum">    2336 </span><span class="lineCov">        221 :           {</span></a>
<a name="2337"><span class="lineNum">    2337 </span><span class="lineCov">        221 :             structureScope = NULL;</span></a>
<a name="2338"><span class="lineNum">    2338 </span>            :          // printf (&quot;Set structureScope to NULL (for primative types) \n&quot;);</a>
<a name="2339"><span class="lineNum">    2339 </span><span class="lineCov">        221 :             break;</span></a>
<a name="2340"><span class="lineNum">    2340 </span>            :           }</a>
<a name="2341"><span class="lineNum">    2341 </span>            : </a>
<a name="2342"><span class="lineNum">    2342 </span>            :     // All currently unhandled types</a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineNoCov">          0 :        default:</span></a>
<a name="2344"><span class="lineNum">    2344 </span><span class="lineNoCov">          0 :           {</span></a>
<a name="2345"><span class="lineNum">    2345 </span><span class="lineNoCov">          0 :             structureScope = NULL;</span></a>
<a name="2346"><span class="lineNum">    2346 </span>            :           }</a>
<a name="2347"><span class="lineNum">    2347 </span>            :     }</a>
<a name="2348"><span class="lineNum">    2348 </span><span class="lineCov">        248 : }</span></a>
<a name="2349"><span class="lineNum">    2349 </span>            : // DQ (12/27/2010): We have to maek the return type std::vector&lt;SgSymbol*&gt; so that we have</a>
<a name="2350"><span class="lineNum">    2350 </span>            : // include SgFunctionSymbols to handle function return value initialization for defined types.</a>
<a name="2351"><span class="lineNum">    2351 </span>            : // DQ (12/14/2010): New support for structure members.</a>
<a name="2352"><span class="lineNum">    2352 </span>            : // std::vector&lt;SgVariableSymbol*&gt;</a>
<a name="2353"><span class="lineNum">    2353 </span>            : // std::vector&lt;SgSymbol*&gt; trace_back_through_parent_scopes_lookup_member_variable_symbol(const std::vector&lt;std::string&gt; &amp; qualifiedNameList, SgScopeStatement* currentScope )</a>
<a name="2354"><span class="lineNum">    2354 </span>            : std::vector&lt;SgSymbol*&gt;</a>
<a name="2355"><span class="lineNum">    2355 </span><span class="lineCov">        231 : trace_back_through_parent_scopes_lookup_member_variable_symbol(const std::vector&lt;MultipartReferenceType&gt; &amp; qualifiedNameList, SgScopeStatement* currentScope )</span></a>
<a name="2356"><span class="lineNum">    2356 </span>            :    {</a>
<a name="2357"><span class="lineNum">    2357 </span>            :   // This function takes an array of names representing multi-part references generated from repeated calls to R613.</a>
<a name="2358"><span class="lineNum">    2358 </span>            :   // This function permits structured data member lookup to be uniform with simple variable lookup.</a>
<a name="2359"><span class="lineNum">    2359 </span>            :   // The non-recursive implementation that this allows for R612 makes it easer to debug this code.</a>
<a name="2360"><span class="lineNum">    2360 </span>            : </a>
<a name="2361"><span class="lineNum">    2361 </span><span class="lineCov">        231 :      SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="2362"><span class="lineNum">    2362 </span><span class="lineCov">        231 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="2363"><span class="lineNum">    2363 </span><span class="lineCov">        231 :      SgClassSymbol*    classSymbol    = NULL;</span></a>
<a name="2364"><span class="lineNum">    2364 </span>            : </a>
<a name="2365"><span class="lineNum">    2365 </span>            :   // std::vector&lt;SgVariableSymbol*&gt; returnSymbolList;</a>
<a name="2366"><span class="lineNum">    2366 </span><span class="lineCov">        231 :      std::vector&lt;SgSymbol*&gt; returnSymbolList;</span></a>
<a name="2367"><span class="lineNum">    2367 </span>            : </a>
<a name="2368"><span class="lineNum">    2368 </span>            : #if 0</a>
<a name="2369"><span class="lineNum">    2369 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2370"><span class="lineNum">    2370 </span>            :      outputState(&quot;At TOP of trace_back_through_parent_scopes_lookup_member_variable_symbol(const std::vector&lt;std::string&gt;,SgScopeStatement*)&quot;);</a>
<a name="2371"><span class="lineNum">    2371 </span>            : #endif</a>
<a name="2372"><span class="lineNum">    2372 </span>            : </a>
<a name="2373"><span class="lineNum">    2373 </span>            : #if 0</a>
<a name="2374"><span class="lineNum">    2374 </span>            :      printf (&quot;qualifiedNameList name = %s \n&quot;,generateQualifiedName(qualifiedNameList).c_str());</a>
<a name="2375"><span class="lineNum">    2375 </span>            : #endif</a>
<a name="2376"><span class="lineNum">    2376 </span>            : </a>
<a name="2377"><span class="lineNum">    2377 </span><span class="lineCov">        231 :         {</span></a>
<a name="2378"><span class="lineNum">    2378 </span>            :        // This is the more sophisticated case (multi-part references)...</a>
<a name="2379"><span class="lineNum">    2379 </span>            :        // We actually want to call the version of the function that will not create a new implicit variable.</a>
<a name="2380"><span class="lineNum">    2380 </span><span class="lineCov">        231 :           SgScopeStatement* structureScope = currentScope;</span></a>
<a name="2381"><span class="lineNum">    2381 </span><span class="lineCov">        231 :           ROSE_ASSERT(structureScope != NULL);</span></a>
<a name="2382"><span class="lineNum">    2382 </span>            : </a>
<a name="2383"><span class="lineNum">    2383 </span><span class="lineCov">        231 :           string name;</span></a>
<a name="2384"><span class="lineNum">    2384 </span>            :        // size_t i = 0;</a>
<a name="2385"><span class="lineNum">    2385 </span>            :        // while (i &lt; qualifiedNameList.size())</a>
<a name="2386"><span class="lineNum">    2386 </span><span class="lineCov">        462 :           for (size_t i = 0; i &lt; qualifiedNameList.size(); i++)</span></a>
<a name="2387"><span class="lineNum">    2387 </span>            :              {</a>
<a name="2388"><span class="lineNum">    2388 </span>            :             // name = qualifiedNameList[i];</a>
<a name="2389"><span class="lineNum">    2389 </span><span class="lineCov">        231 :                name = qualifiedNameList[i].name;</span></a>
<a name="2390"><span class="lineNum">    2390 </span>            : </a>
<a name="2391"><span class="lineNum">    2391 </span><span class="lineCov">        231 :                ROSE_ASSERT(structureScope != NULL);</span></a>
<a name="2392"><span class="lineNum">    2392 </span>            : #if 0</a>
<a name="2393"><span class="lineNum">    2393 </span>            :                printf (&quot;structureScope = %p = %s name = %s \n&quot;,structureScope,structureScope-&gt;class_name().c_str(),name.c_str());</a>
<a name="2394"><span class="lineNum">    2394 </span>            : #endif</a>
<a name="2395"><span class="lineNum">    2395 </span>            : #if 0</a>
<a name="2396"><span class="lineNum">    2396 </span>            :                printf (&quot;Output the symbol table at the structureScope (debugging i = %&quot; PRIuPTR &quot;): \n&quot;,i);</a>
<a name="2397"><span class="lineNum">    2397 </span>            :                structureScope-&gt;get_symbol_table()-&gt;print(&quot;Output the symbol table at the current scope&quot;);</a>
<a name="2398"><span class="lineNum">    2398 </span>            : #endif</a>
<a name="2399"><span class="lineNum">    2399 </span>            : </a>
<a name="2400"><span class="lineNum">    2400 </span>            :             // variableSymbol = trace_back_through_parent_scopes_lookup_variable_symbol(qualifiedNameList[i],structureScope);</a>
<a name="2401"><span class="lineNum">    2401 </span>            :             // trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(qualifiedNameList[i],structureScope,variableSymbol,functionSymbol,classSymbol);</a>
<a name="2402"><span class="lineNum">    2402 </span><span class="lineCov">        231 :                trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(name,structureScope,variableSymbol,functionSymbol,classSymbol);</span></a>
<a name="2403"><span class="lineNum">    2403 </span>            : </a>
<a name="2404"><span class="lineNum">    2404 </span><span class="lineCov">        231 :                ROSE_ASSERT(structureScope != NULL);</span></a>
<a name="2405"><span class="lineNum">    2405 </span>            : </a>
<a name="2406"><span class="lineNum">    2406 </span>            : #if 0</a>
<a name="2407"><span class="lineNum">    2407 </span>            :                printf (&quot;In trace_back_through_parent_scopes_lookup_member_variable_symbol(): variableSymbol = %p \n&quot;,variableSymbol);</a>
<a name="2408"><span class="lineNum">    2408 </span>            :                printf (&quot;In trace_back_through_parent_scopes_lookup_member_variable_symbol(): functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="2409"><span class="lineNum">    2409 </span>            :                printf (&quot;In trace_back_through_parent_scopes_lookup_member_variable_symbol(): classSymbol    = %p \n&quot;,classSymbol);</a>
<a name="2410"><span class="lineNum">    2410 </span>            : #endif</a>
<a name="2411"><span class="lineNum">    2411 </span>            : </a>
<a name="2412"><span class="lineNum">    2412 </span><span class="lineCov">        231 :                if (variableSymbol != NULL)</span></a>
<a name="2413"><span class="lineNum">    2413 </span>            :                   {</a>
<a name="2414"><span class="lineNum">    2414 </span>            :                  // ROSE_ASSERT(variableSymbol-&gt;get_type() != NULL);</a>
<a name="2415"><span class="lineNum">    2415 </span>            : #if 0</a>
<a name="2416"><span class="lineNum">    2416 </span>            :                     printf (&quot;variable type = %s \n&quot;,variableSymbol-&gt;get_type()-&gt;class_name().c_str());</a>
<a name="2417"><span class="lineNum">    2417 </span>            : #endif</a>
<a name="2418"><span class="lineNum">    2418 </span>            :                  // This is a reference to a variable (perhaps a structure), and we can return variableSymbol as NULL.</a>
<a name="2419"><span class="lineNum">    2419 </span>            :                  // name = qualifiedNameList[i];</a>
<a name="2420"><span class="lineNum">    2420 </span>            : #if 0</a>
<a name="2421"><span class="lineNum">    2421 </span>            :                     printf (&quot;Found a variableSymbol = %p Next variable name = %s \n&quot;,variableSymbol,name.c_str());</a>
<a name="2422"><span class="lineNum">    2422 </span>            : #endif</a>
<a name="2423"><span class="lineNum">    2423 </span><span class="lineCov">        221 :                     SgType* type = variableSymbol-&gt;get_type();</span></a>
<a name="2424"><span class="lineNum">    2424 </span><span class="lineCov">        221 :                     ROSE_ASSERT(type != NULL);</span></a>
<a name="2425"><span class="lineNum">    2425 </span>            : #if 0</a>
<a name="2426"><span class="lineNum">    2426 </span>            :                     printf (&quot;associated variable type = %s \n&quot;,type-&gt;class_name().c_str());</a>
<a name="2427"><span class="lineNum">    2427 </span>            : #endif</a>
<a name="2428"><span class="lineNum">    2428 </span><span class="lineCov">        221 :                     findStructureScope(type, structureScope);  // DXN (08/12/2011)</span></a>
<a name="2429"><span class="lineNum">    2429 </span>            : </a>
<a name="2430"><span class="lineNum">    2430 </span>            :                  // Returning an empty list (returnSymbolList) is how we would return the equivalant of &quot;variableSymbol == NULL&quot;.</a>
<a name="2431"><span class="lineNum">    2431 </span><span class="lineCov">        221 :                     if (variableSymbol != NULL)</span></a>
<a name="2432"><span class="lineNum">    2432 </span>            :                        {</a>
<a name="2433"><span class="lineNum">    2433 </span><span class="lineCov">        221 :                          returnSymbolList.push_back(variableSymbol);</span></a>
<a name="2434"><span class="lineNum">    2434 </span>            :                        }</a>
<a name="2435"><span class="lineNum">    2435 </span>            :                   }</a>
<a name="2436"><span class="lineNum">    2436 </span>            :                  else</a>
<a name="2437"><span class="lineNum">    2437 </span>            :                   {</a>
<a name="2438"><span class="lineNum">    2438 </span>            : #if 0</a>
<a name="2439"><span class="lineNum">    2439 </span>            :                     printf (&quot;In trace_back_through_parent_scopes_lookup_member_variable_symbol(): functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="2440"><span class="lineNum">    2440 </span>            : #endif</a>
<a name="2441"><span class="lineNum">    2441 </span><span class="lineCov">         10 :                     if (functionSymbol != NULL)</span></a>
<a name="2442"><span class="lineNum">    2442 </span>            :                        {</a>
<a name="2443"><span class="lineNum">    2443 </span>            :                       // This is a reference to a function (maybe a member function of a module?), and we can return variableSymbol as NULL.</a>
<a name="2444"><span class="lineNum">    2444 </span>            :                       // See test2010_176.f90 for an example of this (setting a data member of the return value of a function returning a type!</a>
<a name="2445"><span class="lineNum">    2445 </span>            :                       // name = qualifiedNameList[i];</a>
<a name="2446"><span class="lineNum">    2446 </span>            : #if 0</a>
<a name="2447"><span class="lineNum">    2447 </span>            :                          printf (&quot;Found a functionSymbol = %p Next variable name = %s \n&quot;,functionSymbol,name.c_str());</a>
<a name="2448"><span class="lineNum">    2448 </span>            : #endif</a>
<a name="2449"><span class="lineNum">    2449 </span><span class="lineCov">          6 :                          SgType* type = functionSymbol-&gt;get_type();</span></a>
<a name="2450"><span class="lineNum">    2450 </span><span class="lineCov">          6 :                          ROSE_ASSERT(type != NULL);</span></a>
<a name="2451"><span class="lineNum">    2451 </span><span class="lineCov">          6 :                          SgFunctionType* functionType = isSgFunctionType(type);</span></a>
<a name="2452"><span class="lineNum">    2452 </span><span class="lineCov">          6 :                          ROSE_ASSERT(functionType != NULL);</span></a>
<a name="2453"><span class="lineNum">    2453 </span><span class="lineCov">          6 :                          SgType* functionReturnType = functionType-&gt;get_return_type();</span></a>
<a name="2454"><span class="lineNum">    2454 </span><span class="lineCov">          6 :                          ROSE_ASSERT(functionReturnType != NULL);</span></a>
<a name="2455"><span class="lineNum">    2455 </span>            : #if 0</a>
<a name="2456"><span class="lineNum">    2456 </span>            :                          printf (&quot;functionReturnType = %p = %s \n&quot;,functionReturnType,functionReturnType-&gt;class_name().c_str());</a>
<a name="2457"><span class="lineNum">    2457 </span>            : #endif</a>
<a name="2458"><span class="lineNum">    2458 </span><span class="lineCov">          6 :                          SgClassType* classType = isSgClassType(functionReturnType);</span></a>
<a name="2459"><span class="lineNum">    2459 </span><span class="lineCov">          6 :                          if (classType != NULL)</span></a>
<a name="2460"><span class="lineNum">    2460 </span>            :                             {</a>
<a name="2461"><span class="lineNum">    2461 </span>            :                            // printf (&quot;Found a function with SgClassType return type! \n&quot;);</a>
<a name="2462"><span class="lineNum">    2462 </span><span class="lineNoCov">          0 :                              findClassTypeStructureScope(classType, structureScope);</span></a>
<a name="2463"><span class="lineNum">    2463 </span>            :                            // printf (&quot;Set structureScope to %p \n&quot;,structureScope);</a>
<a name="2464"><span class="lineNum">    2464 </span>            : </a>
<a name="2465"><span class="lineNum">    2465 </span><span class="lineNoCov">          0 :                               returnSymbolList.push_back(functionSymbol);</span></a>
<a name="2466"><span class="lineNum">    2466 </span>            :                             }</a>
<a name="2467"><span class="lineNum">    2467 </span>            :                            else</a>
<a name="2468"><span class="lineNum">    2468 </span>            :                             {</a>
<a name="2469"><span class="lineNum">    2469 </span><span class="lineCov">          6 :                               structureScope = NULL;</span></a>
<a name="2470"><span class="lineNum">    2470 </span>            : </a>
<a name="2471"><span class="lineNum">    2471 </span>            :                            // See test2007_07.f90 for where this is required.</a>
<a name="2472"><span class="lineNum">    2472 </span><span class="lineCov">          6 :                               returnSymbolList.push_back(functionSymbol);</span></a>
<a name="2473"><span class="lineNum">    2473 </span>            :                             }</a>
<a name="2474"><span class="lineNum">    2474 </span>            :                        }</a>
<a name="2475"><span class="lineNum">    2475 </span>            :                       else</a>
<a name="2476"><span class="lineNum">    2476 </span>            :                        {</a>
<a name="2477"><span class="lineNum">    2477 </span>            : #if 0</a>
<a name="2478"><span class="lineNum">    2478 </span>            :                          printf (&quot;In trace_back_through_parent_scopes_lookup_member_variable_symbol(): classSymbol = %p \n&quot;,classSymbol);</a>
<a name="2479"><span class="lineNum">    2479 </span>            : #endif</a>
<a name="2480"><span class="lineNum">    2480 </span><span class="lineCov">          4 :                          if (classSymbol != NULL)</span></a>
<a name="2481"><span class="lineNum">    2481 </span>            :                             {</a>
<a name="2482"><span class="lineNum">    2482 </span>            :                            // This is a reference to a type, and we can return variableSymbol as NULL.</a>
<a name="2483"><span class="lineNum">    2483 </span>            :                            // printf (&quot;Found a classSymbol = %p \n&quot;,classSymbol);</a>
<a name="2484"><span class="lineNum">    2484 </span><span class="lineNoCov">          0 :                               structureScope = NULL;</span></a>
<a name="2485"><span class="lineNum">    2485 </span>            :                             }</a>
<a name="2486"><span class="lineNum">    2486 </span>            :                            else</a>
<a name="2487"><span class="lineNum">    2487 </span>            :                             {</a>
<a name="2488"><span class="lineNum">    2488 </span>            : #if 0</a>
<a name="2489"><span class="lineNum">    2489 </span>            :                                printf (&quot;########## This is reference has not been seen previously: name = %s qualifiedNameList.size() = %&quot; PRIuPTR &quot; \n&quot;,name.c_str(),qualifiedNameList.size());</a>
<a name="2490"><span class="lineNum">    2490 </span>            : #endif</a>
<a name="2491"><span class="lineNum">    2491 </span>            :                            // Nothing was found, so we can return variableSymbol as NULL.</a>
<a name="2492"><span class="lineNum">    2492 </span>            :                            // Note: types could be buried (modules defined in modules), but they are not likely a part of multi-part references (in Fortran).</a>
<a name="2493"><span class="lineNum">    2493 </span><span class="lineCov">          4 :                               structureScope = NULL;</span></a>
<a name="2494"><span class="lineNum">    2494 </span>            : </a>
<a name="2495"><span class="lineNum">    2495 </span>            :                            // DQ (12/28/2010): Added handling for implicit references.</a>
<a name="2496"><span class="lineNum">    2496 </span>            :                            // If nothing was found then this is an implicit reference (could be a variable or array reference, I think).</a>
<a name="2497"><span class="lineNum">    2497 </span>            :                            // But to be an implicit reference it must have only one part (qualifiedNameList.size() == 1).</a>
<a name="2498"><span class="lineNum">    2498 </span><span class="lineCov">          4 :                               if (qualifiedNameList.size() == 1)</span></a>
<a name="2499"><span class="lineNum">    2499 </span>            :                                  {</a>
<a name="2500"><span class="lineNum">    2500 </span>            :                                 // DQ (1/18/2011): This detects where we have used the semantics of implicitly building symbols for implicit variables.</a>
<a name="2501"><span class="lineNum">    2501 </span>            :                                 // printf (&quot;WARNING: This use of trace_back_through_parent_scopes_lookup_variable_symbol() used the side effect of building a symbol if the reference is not found! \n&quot;);</a>
<a name="2502"><span class="lineNum">    2502 </span>            :                                 // ROSE_ASSERT(false);</a>
<a name="2503"><span class="lineNum">    2503 </span>            : </a>
<a name="2504"><span class="lineNum">    2504 </span>            :                                 // This will build the variable symbol if the variable is not found.</a>
<a name="2505"><span class="lineNum">    2505 </span>            :                                 // variableSymbol = trace_back_through_parent_scopes_lookup_variable_symbol(qualifiedNameList[0],currentScope);</a>
<a name="2506"><span class="lineNum">    2506 </span><span class="lineCov">          4 :                                    variableSymbol = trace_back_through_parent_scopes_lookup_variable_symbol(name,currentScope);</span></a>
<a name="2507"><span class="lineNum">    2507 </span>            : </a>
<a name="2508"><span class="lineNum">    2508 </span>            :                                 // Returning an empty list (returnSymbolList) is how we would return the equivalant of &quot;variableSymbol == NULL&quot;.</a>
<a name="2509"><span class="lineNum">    2509 </span><span class="lineCov">          4 :                                    if (variableSymbol != NULL)</span></a>
<a name="2510"><span class="lineNum">    2510 </span>            :                                       {</a>
<a name="2511"><span class="lineNum">    2511 </span><span class="lineNoCov">          0 :                                         returnSymbolList.push_back(variableSymbol);</span></a>
<a name="2512"><span class="lineNum">    2512 </span>            :                                       }</a>
<a name="2513"><span class="lineNum">    2513 </span>            :                                      else</a>
<a name="2514"><span class="lineNum">    2514 </span>            :                                       {</a>
<a name="2515"><span class="lineNum">    2515 </span>            :                                      // I think this may be an error...output a message for now.</a>
<a name="2516"><span class="lineNum">    2516 </span>            : #if 0</a>
<a name="2517"><span class="lineNum">    2517 </span>            :                                         printf (&quot;Warning: variable symbol not built for expected implicit reference = %s \n&quot;,name.c_str());</a>
<a name="2518"><span class="lineNum">    2518 </span>            : #endif</a>
<a name="2519"><span class="lineNum">    2519 </span>            : #if 0</a>
<a name="2520"><span class="lineNum">    2520 </span>            :                                      // Returning a SgDefaultSymbol will be used to indicate that the name is not known and can be interpreted later.</a>
<a name="2521"><span class="lineNum">    2521 </span>            :                                         SgSymbol* defaultSymbol = new SgDefaultSymbol();</a>
<a name="2522"><span class="lineNum">    2522 </span>            :                                         returnSymbolList.push_back(defaultSymbol);</a>
<a name="2523"><span class="lineNum">    2523 </span>            : #endif</a>
<a name="2524"><span class="lineNum">    2524 </span>            :                                       }</a>
<a name="2525"><span class="lineNum">    2525 </span>            :                                  }</a>
<a name="2526"><span class="lineNum">    2526 </span>            :                             }</a>
<a name="2527"><span class="lineNum">    2527 </span>            :                        }</a>
<a name="2528"><span class="lineNum">    2528 </span>            :                   }</a>
<a name="2529"><span class="lineNum">    2529 </span>            : </a>
<a name="2530"><span class="lineNum">    2530 </span>            :             // Error checking...</a>
<a name="2531"><span class="lineNum">    2531 </span><span class="lineCov">        231 :                if (structureScope == NULL)</span></a>
<a name="2532"><span class="lineNum">    2532 </span>            :                   {</a>
<a name="2533"><span class="lineNum">    2533 </span>            :                  // This should be the last iteration!</a>
<a name="2534"><span class="lineNum">    2534 </span><span class="lineCov">        231 :                     if (i != (qualifiedNameList.size() - 1))</span></a>
<a name="2535"><span class="lineNum">    2535 </span>            :                        {</a>
<a name="2536"><span class="lineNum">    2536 </span><span class="lineNoCov">          0 :                          printf (&quot;WARNING: i != (qualifiedNameList.size() - 1) for LANL_POP code only! (i = %&quot; PRIuPTR &quot; qualifiedNameList.size() = %&quot; PRIuPTR &quot;) \n&quot;,i,qualifiedNameList.size());</span></a>
<a name="2537"><span class="lineNum">    2537 </span>            : </a>
<a name="2538"><span class="lineNum">    2538 </span>            :                       // Debugging...</a>
<a name="2539"><span class="lineNum">    2539 </span><span class="lineNoCov">          0 :                          printf (&quot;Leaving trace_back_through_parent_scopes_lookup_member_variable_symbol(): \n&quot;);</span></a>
<a name="2540"><span class="lineNum">    2540 </span><span class="lineNoCov">          0 :                          for (size_t i = 0; i &lt; returnSymbolList.size(); i++)</span></a>
<a name="2541"><span class="lineNum">    2541 </span>            :                             {</a>
<a name="2542"><span class="lineNum">    2542 </span><span class="lineNoCov">          0 :                                printf (&quot;--- returnSymbolList[%&quot; PRIuPTR &quot;] = %p = %s = %s \n&quot;,i,returnSymbolList[i],returnSymbolList[i]-&gt;class_name().c_str(),returnSymbolList[i]-&gt;get_name().str());</span></a>
<a name="2543"><span class="lineNum">    2543 </span>            :                             }</a>
<a name="2544"><span class="lineNum">    2544 </span>            :                        }</a>
<a name="2545"><span class="lineNum">    2545 </span>            : </a>
<a name="2546"><span class="lineNum">    2546 </span>            :                  // Note that if this fails is it always because there was some case missed above (and so the structureScope was not set properly to permit the search to be continued resolve a name in a nested type or scope).</a>
<a name="2547"><span class="lineNum">    2547 </span><span class="lineCov">        231 :                     ROSE_ASSERT(i == (qualifiedNameList.size() - 1));</span></a>
<a name="2548"><span class="lineNum">    2548 </span>            :                   }</a>
<a name="2549"><span class="lineNum">    2549 </span>            : </a>
<a name="2550"><span class="lineNum">    2550 </span>            :             // End of &quot;for loop&quot; over multi-part name parts.</a>
<a name="2551"><span class="lineNum">    2551 </span>            :              }</a>
<a name="2552"><span class="lineNum">    2552 </span>            :         }</a>
<a name="2553"><span class="lineNum">    2553 </span>            : </a>
<a name="2554"><span class="lineNum">    2554 </span>            : #if 0</a>
<a name="2555"><span class="lineNum">    2555 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2556"><span class="lineNum">    2556 </span>            :      outputState(&quot;At BOTTOM of trace_back_through_parent_scopes_lookup_member_variable_symbol(const std::vector&lt;std::string&gt;,SgScopeStatement*)&quot;);</a>
<a name="2557"><span class="lineNum">    2557 </span>            : #endif</a>
<a name="2558"><span class="lineNum">    2558 </span>            : </a>
<a name="2559"><span class="lineNum">    2559 </span>            : #if 0</a>
<a name="2560"><span class="lineNum">    2560 </span>            :   // This function could have returned a NULL pointer if there was no symbol found ???</a>
<a name="2561"><span class="lineNum">    2561 </span>            :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="2562"><span class="lineNum">    2562 </span>            :         {</a>
<a name="2563"><span class="lineNum">    2563 </span>            :           printf (&quot;Leaving trace_back_through_parent_scopes_lookup_member_variable_symbol(): \n&quot;);</a>
<a name="2564"><span class="lineNum">    2564 </span>            :           for (size_t i = 0; i &lt; returnSymbolList.size(); i++)</a>
<a name="2565"><span class="lineNum">    2565 </span>            :              {</a>
<a name="2566"><span class="lineNum">    2566 </span>            :                printf (&quot;--- returnSymbolList[%&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,returnSymbolList[i],returnSymbolList[i]-&gt;class_name().c_str());</a>
<a name="2567"><span class="lineNum">    2567 </span>            :              }</a>
<a name="2568"><span class="lineNum">    2568 </span>            :         }</a>
<a name="2569"><span class="lineNum">    2569 </span>            : #endif</a>
<a name="2570"><span class="lineNum">    2570 </span>            : </a>
<a name="2571"><span class="lineNum">    2571 </span>            : #if 0</a>
<a name="2572"><span class="lineNum">    2572 </span>            :   // DQ (1/19/2011): I think this is valid debugging code.</a>
<a name="2573"><span class="lineNum">    2573 </span>            :      if (returnSymbolList.empty() == true)</a>
<a name="2574"><span class="lineNum">    2574 </span>            :         {</a>
<a name="2575"><span class="lineNum">    2575 </span>            :           printf (&quot;*** WARNING: returnSymbolList is empty (might be an error) *** \n&quot;);</a>
<a name="2576"><span class="lineNum">    2576 </span>            :         }</a>
<a name="2577"><span class="lineNum">    2577 </span>            : #endif</a>
<a name="2578"><span class="lineNum">    2578 </span>            : </a>
<a name="2579"><span class="lineNum">    2579 </span>            :   // DQ (12/28/2010): Fixed this test to handle case of single part implicit references.</a>
<a name="2580"><span class="lineNum">    2580 </span>            :   // DQ (12/27/2010): Can we assert this?  Maybe not for implicitly declared variables (which are by definition only a single part, not multi-part).</a>
<a name="2581"><span class="lineNum">    2581 </span>            :   // if (returnSymbolList.size() != qualifiedNameList.size())</a>
<a name="2582"><span class="lineNum">    2582 </span><span class="lineCov">        231 :      if (qualifiedNameList.size() &gt; 1 &amp;&amp; returnSymbolList.size() != qualifiedNameList.size())</span></a>
<a name="2583"><span class="lineNum">    2583 </span>            :         {</a>
<a name="2584"><span class="lineNum">    2584 </span><span class="lineNoCov">          0 :           printf (&quot;Error: returnSymbolList.size() = %&quot; PRIuPTR &quot; qualifiedNameList.size() = %&quot; PRIuPTR &quot; \n&quot;,returnSymbolList.size(),qualifiedNameList.size());</span></a>
<a name="2585"><span class="lineNum">    2585 </span>            :         }</a>
<a name="2586"><span class="lineNum">    2586 </span>            :   // ROSE_ASSERT(returnSymbolList.size() == qualifiedNameList.size());</a>
<a name="2587"><span class="lineNum">    2587 </span><span class="lineCov">        231 :      ROSE_ASSERT(qualifiedNameList.size() == 1 || returnSymbolList.size() == qualifiedNameList.size());</span></a>
<a name="2588"><span class="lineNum">    2588 </span>            : </a>
<a name="2589"><span class="lineNum">    2589 </span><span class="lineCov">        231 :      return returnSymbolList;</span></a>
<a name="2590"><span class="lineNum">    2590 </span>            :    }</a>
<a name="2591"><span class="lineNum">    2591 </span>            : </a>
<a name="2592"><span class="lineNum">    2592 </span>            : </a>
<a name="2593"><span class="lineNum">    2593 </span>            : void</a>
<a name="2594"><span class="lineNum">    2594 </span><span class="lineCov">         10 : buildImplicitVariableDeclaration( const SgName &amp; variableName )</span></a>
<a name="2595"><span class="lineNum">    2595 </span>            :    {</a>
<a name="2596"><span class="lineNum">    2596 </span><span class="lineCov">         10 :      Token_t token;</span></a>
<a name="2597"><span class="lineNum">    2597 </span><span class="lineCov">         10 :      token.line = 1;</span></a>
<a name="2598"><span class="lineNum">    2598 </span><span class="lineCov">         10 :      token.col  = 1;</span></a>
<a name="2599"><span class="lineNum">    2599 </span><span class="lineCov">         10 :      token.type = 0;</span></a>
<a name="2600"><span class="lineNum">    2600 </span><span class="lineCov">         10 :      token.text = strdup(variableName.str());</span></a>
<a name="2601"><span class="lineNum">    2601 </span>            : </a>
<a name="2602"><span class="lineNum">    2602 </span>            :   // Push the name onto the stack</a>
<a name="2603"><span class="lineNum">    2603 </span><span class="lineCov">         10 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2604"><span class="lineNum">    2604 </span><span class="lineNoCov">          0 :           printf (&quot;Push the name onto the astNameStack \n&quot;);</span></a>
<a name="2605"><span class="lineNum">    2605 </span>            : </a>
<a name="2606"><span class="lineNum">    2606 </span><span class="lineCov">         10 :      astNameStack.push_front(&amp;token);</span></a>
<a name="2607"><span class="lineNum">    2607 </span><span class="lineCov">         10 :      ROSE_ASSERT(astNameStack.empty() == false);</span></a>
<a name="2608"><span class="lineNum">    2608 </span>            : </a>
<a name="2609"><span class="lineNum">    2609 </span>            :   // DQ (12/20/2007): The type here must be determined using implicit type rules.</a>
<a name="2610"><span class="lineNum">    2610 </span><span class="lineCov">         10 :      SgType* intrinsicType = generateImplicitType(variableName.str());</span></a>
<a name="2611"><span class="lineNum">    2611 </span><span class="lineCov">         10 :      ROSE_ASSERT(intrinsicType != NULL);</span></a>
<a name="2612"><span class="lineNum">    2612 </span>            : </a>
<a name="2613"><span class="lineNum">    2613 </span><span class="lineCov">         10 :      astTypeStack.push_front(intrinsicType);</span></a>
<a name="2614"><span class="lineNum">    2614 </span>            : </a>
<a name="2615"><span class="lineNum">    2615 </span><span class="lineCov">         10 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2616"><span class="lineNum">    2616 </span><span class="lineNoCov">          0 :           printf (&quot;Calling buildVariableDeclaration to build an implicitly defined variable: name = %s type = %s astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,variableName.str(),intrinsicType-&gt;class_name().c_str(),astNameStack.size());</span></a>
<a name="2617"><span class="lineNum">    2617 </span>            : </a>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineCov">         10 :      ROSE_ASSERT(astTypeStack.empty() == false);</span></a>
<a name="2619"><span class="lineNum">    2619 </span><span class="lineCov">         10 :      SgType* type = astTypeStack.front();</span></a>
<a name="2620"><span class="lineNum">    2620 </span><span class="lineCov">         10 :      astTypeStack.pop_front();</span></a>
<a name="2621"><span class="lineNum">    2621 </span>            : </a>
<a name="2622"><span class="lineNum">    2622 </span><span class="lineCov">         10 :      SgInitializedName* initializedName = new SgInitializedName(variableName,type,NULL,NULL,NULL);</span></a>
<a name="2623"><span class="lineNum">    2623 </span><span class="lineCov">         10 :      setSourcePosition(initializedName);</span></a>
<a name="2624"><span class="lineNum">    2624 </span>            : </a>
<a name="2625"><span class="lineNum">    2625 </span>            :   // printf (&quot;Built a new SgInitializedName = %p = %s \n&quot;,initializedName,variableName.str());</a>
<a name="2626"><span class="lineNum">    2626 </span>            :   // DQ (12/14/2007): This will be set in buildVariableDeclaration()</a>
<a name="2627"><span class="lineNum">    2627 </span>            :   // initializedName-&gt;set_scope(currentScope);</a>
<a name="2628"><span class="lineNum">    2628 </span>            : </a>
<a name="2629"><span class="lineNum">    2629 </span><span class="lineCov">         10 :      astNameStack.pop_front();</span></a>
<a name="2630"><span class="lineNum">    2630 </span><span class="lineCov">         10 :      astNodeStack.push_front(initializedName);</span></a>
<a name="2631"><span class="lineNum">    2631 </span>            : #if 0</a>
<a name="2632"><span class="lineNum">    2632 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2633"><span class="lineNum">    2633 </span>            :      outputState(&quot;Calling buildVariableDeclaration to build an implicitly defined variable from trace_back_through_parent_scopes_lookup_variable_symbol()&quot;);</a>
<a name="2634"><span class="lineNum">    2634 </span>            : #endif</a>
<a name="2635"><span class="lineNum">    2635 </span>            : </a>
<a name="2636"><span class="lineNum">    2636 </span>            :   // We need to explicitly specify that the variable is to be implicitly declarated (so that we will know to process only one variable at a time).</a>
<a name="2637"><span class="lineNum">    2637 </span><span class="lineCov">         10 :      bool buildingImplicitVariable = true;</span></a>
<a name="2638"><span class="lineNum">    2638 </span><span class="lineCov">         10 :      SgVariableDeclaration* variableDeclaration = buildVariableDeclaration(NULL,buildingImplicitVariable);</span></a>
<a name="2639"><span class="lineNum">    2639 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="2640"><span class="lineNum">    2640 </span>            : </a>
<a name="2641"><span class="lineNum">    2641 </span><span class="lineCov">         10 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2642"><span class="lineNum">    2642 </span><span class="lineNoCov">          0 :           printf (&quot;DONE: Calling buildVariableDeclaration to build an implicitly defined variable \n&quot;);</span></a>
<a name="2643"><span class="lineNum">    2643 </span>            : </a>
<a name="2644"><span class="lineNum">    2644 </span>            :   // ROSE_ASSERT(variableDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == true);</a>
<a name="2645"><span class="lineNum">    2645 </span>            : </a>
<a name="2646"><span class="lineNum">    2646 </span>            :   // Set this implicitly defined variable declaration to be compiler generated.</a>
<a name="2647"><span class="lineNum">    2647 </span>            :   // setSourcePositionCompilerGenerated(variableDeclaration);</a>
<a name="2648"><span class="lineNum">    2648 </span>            : </a>
<a name="2649"><span class="lineNum">    2649 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="2650"><span class="lineNum">    2650 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration-&gt;get_endOfConstruct() != NULL);</span></a>
<a name="2651"><span class="lineNum">    2651 </span>            : </a>
<a name="2652"><span class="lineNum">    2652 </span>            : #if 0</a>
<a name="2653"><span class="lineNum">    2653 </span>            :      if (variableDeclaration-&gt;get_startOfConstruct()-&gt;get_filenameString() == &quot;NULL_FILE&quot;)</a>
<a name="2654"><span class="lineNum">    2654 </span>            :         {</a>
<a name="2655"><span class="lineNum">    2655 </span>            :           variableDeclaration-&gt;get_startOfConstruct()-&gt;display(&quot;Implicit variable declaration within trace_back_through_parent_scopes_lookup_variable_symbol()&quot;);</a>
<a name="2656"><span class="lineNum">    2656 </span>            :         }</a>
<a name="2657"><span class="lineNum">    2657 </span>            :   // ROSE_ASSERT(variableDeclaration-&gt;get_startOfConstruct()-&gt;get_filenameString() != &quot;NULL_FILE&quot;);</a>
<a name="2658"><span class="lineNum">    2658 </span>            : #endif</a>
<a name="2659"><span class="lineNum">    2659 </span>            : </a>
<a name="2660"><span class="lineNum">    2660 </span>            :   // DQ (12/17/2007): Make sure the scope was set!</a>
<a name="2661"><span class="lineNum">    2661 </span><span class="lineCov">         10 :      ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="2662"><span class="lineNum">    2662 </span>            : </a>
<a name="2663"><span class="lineNum">    2663 </span>            :   // Set the variableSymbol we want to return...</a>
<a name="2664"><span class="lineNum">    2664 </span>            :   // ROSE_ASSERT(initializedName-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="2665"><span class="lineNum">    2665 </span><span class="lineCov">         10 :      SgSymbol* tempSymbol = initializedName-&gt;get_symbol_from_symbol_table();</span></a>
<a name="2666"><span class="lineNum">    2666 </span><span class="lineCov">         10 :      ROSE_ASSERT(tempSymbol != NULL);</span></a>
<a name="2667"><span class="lineNum">    2667 </span>            : </a>
<a name="2668"><span class="lineNum">    2668 </span>            :   // DQ (1/17/2011): Adding an additional test based on debugging test2007_94.f90.</a>
<a name="2669"><span class="lineNum">    2669 </span><span class="lineCov">         10 :      ROSE_ASSERT(initializedName-&gt;get_scope()-&gt;lookup_variable_symbol(variableName) != NULL);</span></a>
<a name="2670"><span class="lineNum">    2670 </span>            : </a>
<a name="2671"><span class="lineNum">    2671 </span>            : #if 0</a>
<a name="2672"><span class="lineNum">    2672 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="2673"><span class="lineNum">    2673 </span>            :      outputState(&quot;At BOTTOM of building an implicitly defined variable from trace_back_through_parent_scopes_lookup_variable_symbol()&quot;);</a>
<a name="2674"><span class="lineNum">    2674 </span>            : #endif</a>
<a name="2675"><span class="lineNum">    2675 </span><span class="lineCov">         10 :    }</span></a>
<a name="2676"><span class="lineNum">    2676 </span>            : </a>
<a name="2677"><span class="lineNum">    2677 </span>            : </a>
<a name="2678"><span class="lineNum">    2678 </span>            : </a>
<a name="2679"><span class="lineNum">    2679 </span>            : SgClassSymbol*</a>
<a name="2680"><span class="lineNum">    2680 </span><span class="lineCov">         10 : trace_back_through_parent_scopes_lookup_derived_type_symbol(const SgName &amp; derivedTypeName, SgScopeStatement* currentScope )</span></a>
<a name="2681"><span class="lineNum">    2681 </span>            :    {</a>
<a name="2682"><span class="lineNum">    2682 </span>            :   // This function traces back through the parent scopes to search for the named symbol in an outer scope</a>
<a name="2683"><span class="lineNum">    2683 </span>            :   // It retuens NULL if it is not found in any scope.  Is does not look in any scopes specified using a </a>
<a name="2684"><span class="lineNum">    2684 </span>            :   // C++ using declaration (SgUsingDeclarationStatement), using directives (SgUsingDirectiveStatement), a</a>
<a name="2685"><span class="lineNum">    2685 </span>            :   // Fortran use statement (SgUseStatement).  This will be done in another function, not yet implemented.</a>
<a name="2686"><span class="lineNum">    2686 </span>            : </a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineCov">         10 :      SgClassSymbol* derivedTypeSymbol = NULL;</span></a>
<a name="2688"><span class="lineNum">    2688 </span><span class="lineCov">         10 :      SgScopeStatement* tempScope = currentScope;</span></a>
<a name="2689"><span class="lineNum">    2689 </span><span class="lineCov">         46 :      while (derivedTypeSymbol == NULL &amp;&amp; tempScope != NULL)</span></a>
<a name="2690"><span class="lineNum">    2690 </span>            :         {</a>
<a name="2691"><span class="lineNum">    2691 </span><span class="lineCov">         36 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2692"><span class="lineNum">    2692 </span><span class="lineNoCov">          0 :                printf (&quot;In trace_back_through_parent_scopes_lookup_derived_type_symbol(): tempScope = %p = %s = %s \n&quot;,</span></a>
<a name="2693"><span class="lineNum">    2693 </span><span class="lineNoCov">          0 :                     tempScope,tempScope-&gt;class_name().c_str(),SageInterface::get_name(tempScope).c_str());</span></a>
<a name="2694"><span class="lineNum">    2694 </span>            : </a>
<a name="2695"><span class="lineNum">    2695 </span>            :        // We have to specify the class symbol since there could be other types (or declarations) with the same name, at least in C++ (unclear about Fortran 90).</a>
<a name="2696"><span class="lineNum">    2696 </span><span class="lineCov">         36 :           derivedTypeSymbol = tempScope-&gt;lookup_class_symbol(derivedTypeName);</span></a>
<a name="2697"><span class="lineNum">    2697 </span>            : </a>
<a name="2698"><span class="lineNum">    2698 </span>            :        // If we have processed the global scope then we can stop (if we have not found the symbol at this</a>
<a name="2699"><span class="lineNum">    2699 </span>            :        // point then it is not available (or it is only availalbe through a USE statment and we have not </a>
<a name="2700"><span class="lineNum">    2700 </span>            :        // implemented that support yet.</a>
<a name="2701"><span class="lineNum">    2701 </span>            :        // tempScope = tempScope-&gt;get_scope();</a>
<a name="2702"><span class="lineNum">    2702 </span><span class="lineCov">         36 :           tempScope = isSgGlobal(tempScope) ? NULL : tempScope-&gt;get_scope();</span></a>
<a name="2703"><span class="lineNum">    2703 </span>            :         }</a>
<a name="2704"><span class="lineNum">    2704 </span>            : </a>
<a name="2705"><span class="lineNum">    2705 </span>            :   // DQ (4/30/2008): I think it is not a problem to return a NULL pointer if no derived type was found (commented out assertion).</a>
<a name="2706"><span class="lineNum">    2706 </span><span class="lineCov">         10 :      if (derivedTypeSymbol == NULL)</span></a>
<a name="2707"><span class="lineNum">    2707 </span>            :         {</a>
<a name="2708"><span class="lineNum">    2708 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2709"><span class="lineNum">    2709 </span><span class="lineNoCov">          0 :                printf (&quot;Warning: trace_back_through_parent_scopes_lookup_derived_type_symbol(): could not locate the specified derived type %s in any outer symbol table \n&quot;,derivedTypeName.str());</span></a>
<a name="2710"><span class="lineNum">    2710 </span>            :        // ROSE_ASSERT(false);</a>
<a name="2711"><span class="lineNum">    2711 </span>            :         }</a>
<a name="2712"><span class="lineNum">    2712 </span>            : </a>
<a name="2713"><span class="lineNum">    2713 </span><span class="lineCov">         10 :      return derivedTypeSymbol;</span></a>
<a name="2714"><span class="lineNum">    2714 </span>            :    }</a>
<a name="2715"><span class="lineNum">    2715 </span>            : </a>
<a name="2716"><span class="lineNum">    2716 </span>            : SgFunctionSymbol*</a>
<a name="2717"><span class="lineNum">    2717 </span><span class="lineCov">        474 : trace_back_through_parent_scopes_lookup_function_symbol(const SgName &amp; functionName, SgScopeStatement* currentScope )</span></a>
<a name="2718"><span class="lineNum">    2718 </span>            :    {</a>
<a name="2719"><span class="lineNum">    2719 </span>            :   // DQ (11/24/2007): This function can return NULL.  It returns NULL when the function symbol is not found.</a>
<a name="2720"><span class="lineNum">    2720 </span>            :   // This can happen when a function is referenced before it it defined (no prototype mechanism in Fortran is required).</a>
<a name="2721"><span class="lineNum">    2721 </span>            : </a>
<a name="2722"><span class="lineNum">    2722 </span>            :   // This function was moved to the SageInteface so that the astPostProcessing could call it too.</a>
<a name="2723"><span class="lineNum">    2723 </span>            :   // return SageInterface::lookupFunctionSymbolInParentScopes(functionName,currentScope);</a>
<a name="2724"><span class="lineNum">    2724 </span>            :   // printf (&quot;Calling SageInterface::lookupFunctionSymbolInParentScopes(%s,%p = %s) \n&quot;,functionName.str(),currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="2725"><span class="lineNum">    2725 </span><span class="lineCov">        474 :      SgFunctionSymbol* functionSymbol = SageInterface::lookupFunctionSymbolInParentScopes(functionName,currentScope);</span></a>
<a name="2726"><span class="lineNum">    2726 </span>            : </a>
<a name="2727"><span class="lineNum">    2727 </span><span class="lineCov">        474 :      if (functionSymbol != NULL)</span></a>
<a name="2728"><span class="lineNum">    2728 </span>            :         {</a>
<a name="2729"><span class="lineNum">    2729 </span><span class="lineCov">         82 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="2730"><span class="lineNum">    2730 </span><span class="lineNoCov">          0 :                printf (&quot;Found a function for functionName = %s functionSymbol = %p \n&quot;,functionName.str(),functionSymbol);</span></a>
<a name="2731"><span class="lineNum">    2731 </span>            :         }</a>
<a name="2732"><span class="lineNum">    2732 </span>            :        else</a>
<a name="2733"><span class="lineNum">    2733 </span>            :         {</a>
<a name="2734"><span class="lineNum">    2734 </span>            :        // printf (&quot;In trace_back_through_parent_scopes_lookup_function_symbol(): Could not find function symbol for name = %s \n&quot;,functionName.str());</a>
<a name="2735"><span class="lineNum">    2735 </span>            :         }</a>
<a name="2736"><span class="lineNum">    2736 </span>            : </a>
<a name="2737"><span class="lineNum">    2737 </span><span class="lineCov">        474 :      return functionSymbol;</span></a>
<a name="2738"><span class="lineNum">    2738 </span>            :    }</a>
<a name="2739"><span class="lineNum">    2739 </span>            : </a>
<a name="2740"><span class="lineNum">    2740 </span>            : </a>
<a name="2741"><span class="lineNum">    2741 </span>            : SgModuleStatement*</a>
<a name="2742"><span class="lineNum">    2742 </span><span class="lineNoCov">          0 : buildModuleStatementAndDefinition (string name, SgScopeStatement* scope)</span></a>
<a name="2743"><span class="lineNum">    2743 </span>            :    {</a>
<a name="2744"><span class="lineNum">    2744 </span>            :   // This function builds a class declaration and definition </a>
<a name="2745"><span class="lineNum">    2745 </span>            :   // (both the defining and nondefining declarations as required).</a>
<a name="2746"><span class="lineNum">    2746 </span>            : </a>
<a name="2747"><span class="lineNum">    2747 </span>            :   // This is the class definition (the fileInfo is the position of the opening brace)</a>
<a name="2748"><span class="lineNum">    2748 </span><span class="lineNoCov">          0 :      SgClassDefinition* classDefinition   = new SgClassDefinition();</span></a>
<a name="2749"><span class="lineNum">    2749 </span><span class="lineNoCov">          0 :      assert(classDefinition != NULL);</span></a>
<a name="2750"><span class="lineNum">    2750 </span>            : </a>
<a name="2751"><span class="lineNum">    2751 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="2752"><span class="lineNum">    2752 </span><span class="lineNoCov">          0 :      classDefinition-&gt;setCaseInsensitive(true);</span></a>
<a name="2753"><span class="lineNum">    2753 </span>            : </a>
<a name="2754"><span class="lineNum">    2754 </span>            :   // classDefinition-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2755"><span class="lineNum">    2755 </span><span class="lineNoCov">          0 :      setSourcePosition(classDefinition);</span></a>
<a name="2756"><span class="lineNum">    2756 </span>            : </a>
<a name="2757"><span class="lineNum">    2757 </span>            :   // Set the end of construct explictly (where not a transformation this is the location of the closing brace)</a>
<a name="2758"><span class="lineNum">    2758 </span>            :   // classDefinition-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2759"><span class="lineNum">    2759 </span>            : </a>
<a name="2760"><span class="lineNum">    2760 </span>            :   // This is the defining declaration for the class (with a reference to the class definition)</a>
<a name="2761"><span class="lineNum">    2761 </span><span class="lineNoCov">          0 :      SgModuleStatement* classDeclaration = new SgModuleStatement(name.c_str(),SgClassDeclaration::e_struct,NULL,classDefinition);</span></a>
<a name="2762"><span class="lineNum">    2762 </span><span class="lineNoCov">          0 :      assert(classDeclaration != NULL);</span></a>
<a name="2763"><span class="lineNum">    2763 </span>            :   // classDeclaration-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2764"><span class="lineNum">    2764 </span>            : </a>
<a name="2765"><span class="lineNum">    2765 </span>            :   // This is set later when the source position is more accurately known</a>
<a name="2766"><span class="lineNum">    2766 </span>            :   // setSourcePosition(classDeclaration);</a>
<a name="2767"><span class="lineNum">    2767 </span>            : </a>
<a name="2768"><span class="lineNum">    2768 </span>            :   // Set the defining declaration in the defining declaration!</a>
<a name="2769"><span class="lineNum">    2769 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_definingDeclaration(classDeclaration);</span></a>
<a name="2770"><span class="lineNum">    2770 </span>            : </a>
<a name="2771"><span class="lineNum">    2771 </span>            :   // Set the non defining declaration in the defining declaration (both are required)</a>
<a name="2772"><span class="lineNum">    2772 </span><span class="lineNoCov">          0 :      SgModuleStatement* nondefiningClassDeclaration = new SgModuleStatement(name.c_str(),SgClassDeclaration::e_struct,NULL,NULL);</span></a>
<a name="2773"><span class="lineNum">    2773 </span><span class="lineNoCov">          0 :      assert(classDeclaration != NULL);</span></a>
<a name="2774"><span class="lineNum">    2774 </span>            :   // nondefiningClassDeclaration-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2775"><span class="lineNum">    2775 </span><span class="lineNoCov">          0 :      setSourcePosition(nondefiningClassDeclaration);</span></a>
<a name="2776"><span class="lineNum">    2776 </span>            : </a>
<a name="2777"><span class="lineNum">    2777 </span>            :   // DQ (3/4/2013): Set the firstNondefiningDeclaration declaration in the firstNondefiningDeclaration.</a>
<a name="2778"><span class="lineNum">    2778 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nondefiningClassDeclaration-&gt;get_firstNondefiningDeclaration() == NULL);</span></a>
<a name="2779"><span class="lineNum">    2779 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</span></a>
<a name="2780"><span class="lineNum">    2780 </span>            : </a>
<a name="2781"><span class="lineNum">    2781 </span>            :   // DQ (3/4/2013): Added assertion.</a>
<a name="2782"><span class="lineNum">    2782 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(nondefiningClassDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2783"><span class="lineNum">    2783 </span>            : </a>
<a name="2784"><span class="lineNum">    2784 </span>            :  // Liao 10/30/2009. we now ask for explicit creation of SgClassType. The constructor will not create it by default</a>
<a name="2785"><span class="lineNum">    2785 </span><span class="lineNoCov">          0 :      if (nondefiningClassDeclaration-&gt;get_type () == NULL)</span></a>
<a name="2786"><span class="lineNum">    2786 </span><span class="lineNoCov">          0 :           nondefiningClassDeclaration-&gt;set_type (SgClassType::createType(nondefiningClassDeclaration));</span></a>
<a name="2787"><span class="lineNum">    2787 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_type(nondefiningClassDeclaration-&gt;get_type());</span></a>
<a name="2788"><span class="lineNum">    2788 </span>            : </a>
<a name="2789"><span class="lineNum">    2789 </span>            :   // Set the internal reference to the non-defining declaration</a>
<a name="2790"><span class="lineNum">    2790 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</span></a>
<a name="2791"><span class="lineNum">    2791 </span>            : </a>
<a name="2792"><span class="lineNum">    2792 </span>            :   // Set the parent explicitly</a>
<a name="2793"><span class="lineNum">    2793 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_parent(scope);</span></a>
<a name="2794"><span class="lineNum">    2794 </span>            : </a>
<a name="2795"><span class="lineNum">    2795 </span>            :   // Set the defining and no-defining declarations in the non-defining class declaration!</a>
<a name="2796"><span class="lineNum">    2796 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</span></a>
<a name="2797"><span class="lineNum">    2797 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_definingDeclaration(classDeclaration);</span></a>
<a name="2798"><span class="lineNum">    2798 </span>            : </a>
<a name="2799"><span class="lineNum">    2799 </span>            :   // Set the nondefining declaration as a forward declaration!</a>
<a name="2800"><span class="lineNum">    2800 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;setForward();</span></a>
<a name="2801"><span class="lineNum">    2801 </span>            : </a>
<a name="2802"><span class="lineNum">    2802 </span>            :   // Don't forget the set the declaration in the definition (IR node constructors are side-effect free!)!</a>
<a name="2803"><span class="lineNum">    2803 </span><span class="lineNoCov">          0 :      classDefinition-&gt;set_declaration(classDeclaration);</span></a>
<a name="2804"><span class="lineNum">    2804 </span>            : </a>
<a name="2805"><span class="lineNum">    2805 </span>            :   // set the scope explicitly (name qualification tricks can imply it is not always the parent IR node!)</a>
<a name="2806"><span class="lineNum">    2806 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_scope(scope);</span></a>
<a name="2807"><span class="lineNum">    2807 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_scope(scope);</span></a>
<a name="2808"><span class="lineNum">    2808 </span>            : </a>
<a name="2809"><span class="lineNum">    2809 </span>            :   // Set the parent explicitly</a>
<a name="2810"><span class="lineNum">    2810 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_parent(scope);</span></a>
<a name="2811"><span class="lineNum">    2811 </span>            : </a>
<a name="2812"><span class="lineNum">    2812 </span>            :   // A type should have been build at this point, since we will need it later!</a>
<a name="2813"><span class="lineNum">    2813 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration-&gt;get_type() != NULL);</span></a>
<a name="2814"><span class="lineNum">    2814 </span>            : </a>
<a name="2815"><span class="lineNum">    2815 </span>            :   // We use the nondefiningClassDeclaration, though it might be that for Fortran the rules that cause this to be important are not so complex as for C/C++.</a>
<a name="2816"><span class="lineNum">    2816 </span><span class="lineNoCov">          0 :      SgClassSymbol* classSymbol = new SgClassSymbol(nondefiningClassDeclaration);</span></a>
<a name="2817"><span class="lineNum">    2817 </span>            : </a>
<a name="2818"><span class="lineNum">    2818 </span>            :   // Add the symbol to the current scope (the specified input scope)</a>
<a name="2819"><span class="lineNum">    2819 </span><span class="lineNoCov">          0 :      scope-&gt;insert_symbol(name,classSymbol);</span></a>
<a name="2820"><span class="lineNum">    2820 </span>            : </a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope-&gt;lookup_class_symbol(name) != NULL);</span></a>
<a name="2822"><span class="lineNum">    2822 </span>            : </a>
<a name="2823"><span class="lineNum">    2823 </span>            :   // some error checking</a>
<a name="2824"><span class="lineNum">    2824 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="2825"><span class="lineNum">    2825 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2826"><span class="lineNum">    2826 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="2827"><span class="lineNum">    2827 </span>            : </a>
<a name="2828"><span class="lineNum">    2828 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration-&gt;get_definition()-&gt;get_parent() != NULL);</span></a>
<a name="2829"><span class="lineNum">    2829 </span>            : </a>
<a name="2830"><span class="lineNum">    2830 </span><span class="lineNoCov">          0 :      return classDeclaration;</span></a>
<a name="2831"><span class="lineNum">    2831 </span>            :    }</a>
<a name="2832"><span class="lineNum">    2832 </span>            : </a>
<a name="2833"><span class="lineNum">    2833 </span>            : </a>
<a name="2834"><span class="lineNum">    2834 </span>            : SgDerivedTypeStatement*</a>
<a name="2835"><span class="lineNum">    2835 </span><span class="lineNoCov">          0 : buildDerivedTypeStatementAndDefinition (string name, SgScopeStatement* scope)</span></a>
<a name="2836"><span class="lineNum">    2836 </span>            :    {</a>
<a name="2837"><span class="lineNum">    2837 </span>            :   // This function builds a class declaration and definition </a>
<a name="2838"><span class="lineNum">    2838 </span>            :   // (both the defining and nondefining declarations as required).</a>
<a name="2839"><span class="lineNum">    2839 </span>            : </a>
<a name="2840"><span class="lineNum">    2840 </span>            :   // This is the class definition (the fileInfo is the position of the opening brace)</a>
<a name="2841"><span class="lineNum">    2841 </span><span class="lineNoCov">          0 :      SgClassDefinition* classDefinition   = new SgClassDefinition();</span></a>
<a name="2842"><span class="lineNum">    2842 </span><span class="lineNoCov">          0 :      assert(classDefinition != NULL);</span></a>
<a name="2843"><span class="lineNum">    2843 </span>            : </a>
<a name="2844"><span class="lineNum">    2844 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="2845"><span class="lineNum">    2845 </span><span class="lineNoCov">          0 :      classDefinition-&gt;setCaseInsensitive(true);</span></a>
<a name="2846"><span class="lineNum">    2846 </span>            : </a>
<a name="2847"><span class="lineNum">    2847 </span>            :   // classDefinition-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2848"><span class="lineNum">    2848 </span><span class="lineNoCov">          0 :      setSourcePosition(classDefinition);</span></a>
<a name="2849"><span class="lineNum">    2849 </span>            : </a>
<a name="2850"><span class="lineNum">    2850 </span>            :   // Set the end of construct explictly (where not a transformation this is the location of the closing brace)</a>
<a name="2851"><span class="lineNum">    2851 </span>            :   // classDefinition-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2852"><span class="lineNum">    2852 </span>            : </a>
<a name="2853"><span class="lineNum">    2853 </span>            :   // This is the defining declaration for the class (with a reference to the class definition)</a>
<a name="2854"><span class="lineNum">    2854 </span><span class="lineNoCov">          0 :      SgDerivedTypeStatement* classDeclaration = new SgDerivedTypeStatement(name.c_str(),SgClassDeclaration::e_struct,NULL,classDefinition);</span></a>
<a name="2855"><span class="lineNum">    2855 </span><span class="lineNoCov">          0 :      assert(classDeclaration != NULL);</span></a>
<a name="2856"><span class="lineNum">    2856 </span>            :   // classDeclaration-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2857"><span class="lineNum">    2857 </span>            : </a>
<a name="2858"><span class="lineNum">    2858 </span>            :   // This will be set later when the source position is known</a>
<a name="2859"><span class="lineNum">    2859 </span>            :   // setSourcePosition(classDeclaration);</a>
<a name="2860"><span class="lineNum">    2860 </span>            : </a>
<a name="2861"><span class="lineNum">    2861 </span>            :   // Set the defining declaration in the defining declaration!</a>
<a name="2862"><span class="lineNum">    2862 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_definingDeclaration(classDeclaration);</span></a>
<a name="2863"><span class="lineNum">    2863 </span>            : </a>
<a name="2864"><span class="lineNum">    2864 </span>            :   // Set the non defining declaration in the defining declaration (both are required)</a>
<a name="2865"><span class="lineNum">    2865 </span><span class="lineNoCov">          0 :      SgDerivedTypeStatement* nondefiningClassDeclaration = new SgDerivedTypeStatement(name.c_str(),SgClassDeclaration::e_struct,NULL,NULL);</span></a>
<a name="2866"><span class="lineNum">    2866 </span><span class="lineNoCov">          0 :      assert(classDeclaration != NULL);</span></a>
<a name="2867"><span class="lineNum">    2867 </span>            : </a>
<a name="2868"><span class="lineNum">    2868 </span>            :   // DQ (12/27/2010): Set the parent before calling the SgClassType::createType() since then name mangling will require it.</a>
<a name="2869"><span class="lineNum">    2869 </span>            :   // Set the parent explicitly</a>
<a name="2870"><span class="lineNum">    2870 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_parent(scope);</span></a>
<a name="2871"><span class="lineNum">    2871 </span>            : </a>
<a name="2872"><span class="lineNum">    2872 </span>            :   // Liao 10/30/2009. we now ask for explicit creation of SgClassType. The constructor will not create it by default</a>
<a name="2873"><span class="lineNum">    2873 </span><span class="lineNoCov">          0 :      if (nondefiningClassDeclaration-&gt;get_type () == NULL) </span></a>
<a name="2874"><span class="lineNum">    2874 </span><span class="lineNoCov">          0 :           nondefiningClassDeclaration-&gt;set_type (SgClassType::createType(nondefiningClassDeclaration));</span></a>
<a name="2875"><span class="lineNum">    2875 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_type(nondefiningClassDeclaration-&gt;get_type());</span></a>
<a name="2876"><span class="lineNum">    2876 </span>            : </a>
<a name="2877"><span class="lineNum">    2877 </span>            :   // nondefiningClassDeclaration-&gt;set_endOfConstruct(SOURCE_POSITION);</a>
<a name="2878"><span class="lineNum">    2878 </span>            : </a>
<a name="2879"><span class="lineNum">    2879 </span>            :   // Leave the nondefining declaration without a specific source code position.</a>
<a name="2880"><span class="lineNum">    2880 </span><span class="lineNoCov">          0 :      setSourcePosition(nondefiningClassDeclaration);</span></a>
<a name="2881"><span class="lineNum">    2881 </span>            : </a>
<a name="2882"><span class="lineNum">    2882 </span>            :   // Set the internal reference to the non-defining declaration</a>
<a name="2883"><span class="lineNum">    2883 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</span></a>
<a name="2884"><span class="lineNum">    2884 </span>            : </a>
<a name="2885"><span class="lineNum">    2885 </span>            :   // DQ (12/27/2010): Moved to before call to SgClassType::createType().</a>
<a name="2886"><span class="lineNum">    2886 </span>            :   // Set the parent explicitly</a>
<a name="2887"><span class="lineNum">    2887 </span>            :   // nondefiningClassDeclaration-&gt;set_parent(scope);</a>
<a name="2888"><span class="lineNum">    2888 </span>            : </a>
<a name="2889"><span class="lineNum">    2889 </span>            :   // Set the defining and no-defining declarations in the non-defining class declaration!</a>
<a name="2890"><span class="lineNum">    2890 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningClassDeclaration);</span></a>
<a name="2891"><span class="lineNum">    2891 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_definingDeclaration(classDeclaration);</span></a>
<a name="2892"><span class="lineNum">    2892 </span>            : </a>
<a name="2893"><span class="lineNum">    2893 </span>            :   // Set the nondefining declaration as a forward declaration!</a>
<a name="2894"><span class="lineNum">    2894 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;setForward();</span></a>
<a name="2895"><span class="lineNum">    2895 </span>            : </a>
<a name="2896"><span class="lineNum">    2896 </span>            :   // Don't forget the set the declaration in the definition (IR node constructors are side-effect free!)!</a>
<a name="2897"><span class="lineNum">    2897 </span><span class="lineNoCov">          0 :      classDefinition-&gt;set_declaration(classDeclaration);</span></a>
<a name="2898"><span class="lineNum">    2898 </span>            : </a>
<a name="2899"><span class="lineNum">    2899 </span>            :   // set the scope explicitly (name qualification tricks can imply it is not always the parent IR node!)</a>
<a name="2900"><span class="lineNum">    2900 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_scope(scope);</span></a>
<a name="2901"><span class="lineNum">    2901 </span><span class="lineNoCov">          0 :      nondefiningClassDeclaration-&gt;set_scope(scope);</span></a>
<a name="2902"><span class="lineNum">    2902 </span>            : </a>
<a name="2903"><span class="lineNum">    2903 </span>            :   // Set the parent explicitly</a>
<a name="2904"><span class="lineNum">    2904 </span><span class="lineNoCov">          0 :      classDeclaration-&gt;set_parent(scope);</span></a>
<a name="2905"><span class="lineNum">    2905 </span>            : </a>
<a name="2906"><span class="lineNum">    2906 </span>            :   // A type should have been build at this point, since we will need it later!</a>
<a name="2907"><span class="lineNum">    2907 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration-&gt;get_type() != NULL);</span></a>
<a name="2908"><span class="lineNum">    2908 </span>            : </a>
<a name="2909"><span class="lineNum">    2909 </span>            :   // We use the nondefiningClassDeclaration, though it might be that for Fortran the rules that cause this to be important are not so complex as for C/C++.</a>
<a name="2910"><span class="lineNum">    2910 </span><span class="lineNoCov">          0 :      SgClassSymbol* classSymbol = new SgClassSymbol(nondefiningClassDeclaration);</span></a>
<a name="2911"><span class="lineNum">    2911 </span>            : </a>
<a name="2912"><span class="lineNum">    2912 </span>            :   // Add the symbol to the current scope (the specified input scope)</a>
<a name="2913"><span class="lineNum">    2913 </span><span class="lineNoCov">          0 :      scope-&gt;insert_symbol(name,classSymbol);</span></a>
<a name="2914"><span class="lineNum">    2914 </span>            : </a>
<a name="2915"><span class="lineNum">    2915 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(scope-&gt;lookup_class_symbol(name) != NULL);</span></a>
<a name="2916"><span class="lineNum">    2916 </span>            : </a>
<a name="2917"><span class="lineNum">    2917 </span>            :   // some error checking</a>
<a name="2918"><span class="lineNum">    2918 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_definingDeclaration() != NULL);</span></a>
<a name="2919"><span class="lineNum">    2919 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_firstNondefiningDeclaration() != NULL);</span></a>
<a name="2920"><span class="lineNum">    2920 </span><span class="lineNoCov">          0 :      assert(classDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="2921"><span class="lineNum">    2921 </span>            : </a>
<a name="2922"><span class="lineNum">    2922 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(classDeclaration-&gt;get_definition()-&gt;get_parent() != NULL);</span></a>
<a name="2923"><span class="lineNum">    2923 </span>            : </a>
<a name="2924"><span class="lineNum">    2924 </span>            :   // DQ (8/28/2010): Save the attributes used and clear the astAttributeSpecStack for this declaration (see test2010_34.f90).</a>
<a name="2925"><span class="lineNum">    2925 </span><span class="lineNoCov">          0 :      while (astAttributeSpecStack.empty() == false)</span></a>
<a name="2926"><span class="lineNum">    2926 </span>            :         {</a>
<a name="2927"><span class="lineNum">    2927 </span>            : #if 0</a>
<a name="2928"><span class="lineNum">    2928 </span>            :           printf (&quot;In buildDerivedTypeStatementAndDefinition(): Process attribute spec %d \n&quot;,astAttributeSpecStack.front());</a>
<a name="2929"><span class="lineNum">    2929 </span>            : #endif</a>
<a name="2930"><span class="lineNum">    2930 </span><span class="lineNoCov">          0 :           setDeclarationAttributeSpec(classDeclaration,astAttributeSpecStack.front());</span></a>
<a name="2931"><span class="lineNum">    2931 </span>            : </a>
<a name="2932"><span class="lineNum">    2932 </span><span class="lineNoCov">          0 :           if (astAttributeSpecStack.front() == AttrSpec_PUBLIC || astAttributeSpecStack.front() == AttrSpec_PRIVATE)</span></a>
<a name="2933"><span class="lineNum">    2933 </span>            :              {</a>
<a name="2934"><span class="lineNum">    2934 </span>            :             // printf (&quot;astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astNameStack.size());</a>
<a name="2935"><span class="lineNum">    2935 </span><span class="lineNoCov">          0 :                if (astNameStack.empty() == false)</span></a>
<a name="2936"><span class="lineNum">    2936 </span>            :                   {</a>
<a name="2937"><span class="lineNum">    2937 </span><span class="lineNoCov">          0 :                     string type_attribute_string = astNameStack.front()-&gt;text;</span></a>
<a name="2938"><span class="lineNum">    2938 </span>            :                  // printf (&quot;type_attribute_string = %s \n&quot;,type_attribute_string.c_str());</a>
<a name="2939"><span class="lineNum">    2939 </span><span class="lineNoCov">          0 :                     astNameStack.pop_front();</span></a>
<a name="2940"><span class="lineNum">    2940 </span>            :                   }</a>
<a name="2941"><span class="lineNum">    2941 </span>            :              }</a>
<a name="2942"><span class="lineNum">    2942 </span>            : </a>
<a name="2943"><span class="lineNum">    2943 </span><span class="lineNoCov">          0 :           astAttributeSpecStack.pop_front();</span></a>
<a name="2944"><span class="lineNum">    2944 </span>            :         }</a>
<a name="2945"><span class="lineNum">    2945 </span>            : </a>
<a name="2946"><span class="lineNum">    2946 </span>            : #if 0</a>
<a name="2947"><span class="lineNum">    2947 </span>            :   // DQ (3/4/2013): Check that the access permission level is the same for the defining and nondefining </a>
<a name="2948"><span class="lineNum">    2948 </span>            :   // declarations (in new edg4x branch these are enforced to be set consistantly).</a>
<a name="2949"><span class="lineNum">    2949 </span>            :      printf (&quot;Checking access privilege level for defining and not defining declarations: classDeclaration = %p nondefiningClassDeclaration = %p \n&quot;,classDeclaration,nondefiningClassDeclaration);</a>
<a name="2950"><span class="lineNum">    2950 </span>            :      classDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;classDeclaration&quot;);</a>
<a name="2951"><span class="lineNum">    2951 </span>            :      nondefiningClassDeclaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;nondefiningClassDeclaration&quot;);</a>
<a name="2952"><span class="lineNum">    2952 </span>            : #endif</a>
<a name="2953"><span class="lineNum">    2953 </span>            : </a>
<a name="2954"><span class="lineNum">    2954 </span><span class="lineNoCov">          0 :      return classDeclaration;</span></a>
<a name="2955"><span class="lineNum">    2955 </span>            :    }</a>
<a name="2956"><span class="lineNum">    2956 </span>            : </a>
<a name="2957"><span class="lineNum">    2957 </span>            : </a>
<a name="2958"><span class="lineNum">    2958 </span>            : bool</a>
<a name="2959"><span class="lineNum">    2959 </span><span class="lineCov">         25 : isImplicitNoneScope()</span></a>
<a name="2960"><span class="lineNum">    2960 </span>            :    {</a>
<a name="2961"><span class="lineNum">    2961 </span>            :   // This function works by traversing the scopes to the SgFunctionDefinition scope and looking</a>
<a name="2962"><span class="lineNum">    2962 </span>            :   // for an implicit none statement.  We can make this more efficient at a later point.</a>
<a name="2963"><span class="lineNum">    2963 </span>            : </a>
<a name="2964"><span class="lineNum">    2964 </span>            :   // Default is that we are NOT in an implicit none scope.</a>
<a name="2965"><span class="lineNum">    2965 </span><span class="lineCov">         25 :      bool isImplicitNoneScope = false;</span></a>
<a name="2966"><span class="lineNum">    2966 </span>            : </a>
<a name="2967"><span class="lineNum">    2967 </span>            :   // DQ (12/10/2016): Eliminating a warning that we want to be an error: -Werror=unused-but-set-variable.</a>
<a name="2968"><span class="lineNum">    2968 </span>            :   // bool foundFunctionDefinition = false;</a>
<a name="2969"><span class="lineNum">    2969 </span>            : </a>
<a name="2970"><span class="lineNum">    2970 </span><span class="lineCov">         25 :      std::list&lt;SgScopeStatement*&gt;::iterator i = astScopeStack.begin();</span></a>
<a name="2971"><span class="lineNum">    2971 </span><span class="lineCov">        102 :      while ( i != astScopeStack.end() )</span></a>
<a name="2972"><span class="lineNum">    2972 </span>            :         {</a>
<a name="2973"><span class="lineNum">    2973 </span>            :        // Find the function definition, or where else an implicit statement can be!</a>
<a name="2974"><span class="lineNum">    2974 </span>            :        // module statement, interface statement</a>
<a name="2975"><span class="lineNum">    2975 </span>            : </a>
<a name="2976"><span class="lineNum">    2976 </span><span class="lineCov">         77 :           SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(*i);</span></a>
<a name="2977"><span class="lineNum">    2977 </span><span class="lineCov">         77 :           if (functionDefinition != NULL)</span></a>
<a name="2978"><span class="lineNum">    2978 </span>            :              {</a>
<a name="2979"><span class="lineNum">    2979 </span>            :             // DQ (12/10/2016): Eliminating a warning that we want to be an error: -Werror=unused-but-set-variable.</a>
<a name="2980"><span class="lineNum">    2980 </span>            :             // foundFunctionDefinition = true;</a>
<a name="2981"><span class="lineNum">    2981 </span><span class="lineCov">         25 :                std::vector&lt;SgStatement*&gt;::iterator j = functionDefinition-&gt;get_body()-&gt;get_statements().begin();</span></a>
<a name="2982"><span class="lineNum">    2982 </span><span class="lineCov">        185 :                while ( j != functionDefinition-&gt;get_body()-&gt;get_statements().end() )</span></a>
<a name="2983"><span class="lineNum">    2983 </span>            :                   {</a>
<a name="2984"><span class="lineNum">    2984 </span>            :                  // Look for the SgImplicitStatement, then test if it was specificed using &quot;none&quot;</a>
<a name="2985"><span class="lineNum">    2985 </span><span class="lineCov">        160 :                     SgImplicitStatement* implicitStatement = isSgImplicitStatement(*j);</span></a>
<a name="2986"><span class="lineNum">    2986 </span><span class="lineCov">        160 :                     if (implicitStatement != NULL &amp;&amp; implicitStatement-&gt;get_implicit_none() == true)</span></a>
<a name="2987"><span class="lineNum">    2987 </span>            :                        isImplicitNoneScope = true;</a>
<a name="2988"><span class="lineNum">    2988 </span>            : </a>
<a name="2989"><span class="lineNum">    2989 </span><span class="lineCov">        160 :                     j++;</span></a>
<a name="2990"><span class="lineNum">    2990 </span>            :                   }</a>
<a name="2991"><span class="lineNum">    2991 </span>            :              }</a>
<a name="2992"><span class="lineNum">    2992 </span>            :           // Pei-Hung (07/25/2019) search for implicit statement in modules</a>
<a name="2993"><span class="lineNum">    2993 </span><span class="lineCov">         77 :           SgClassDefinition* classDefinition = isSgClassDefinition(*i);</span></a>
<a name="2994"><span class="lineNum">    2994 </span><span class="lineCov">         77 :           if (classDefinition != NULL)</span></a>
<a name="2995"><span class="lineNum">    2995 </span>            :              {</a>
<a name="2996"><span class="lineNum">    2996 </span><span class="lineNoCov">          0 :                SgDeclarationStatementPtrList&amp; declStmtList = classDefinition-&gt;get_members();</span></a>
<a name="2997"><span class="lineNum">    2997 </span><span class="lineNoCov">          0 :                SgDeclarationStatementPtrList::const_iterator j = declStmtList.begin();</span></a>
<a name="2998"><span class="lineNum">    2998 </span><span class="lineNoCov">          0 :                while (j != declStmtList.end())</span></a>
<a name="2999"><span class="lineNum">    2999 </span>            :                {</a>
<a name="3000"><span class="lineNum">    3000 </span><span class="lineNoCov">          0 :                  SgImplicitStatement* implicitStatement = isSgImplicitStatement(*j);</span></a>
<a name="3001"><span class="lineNum">    3001 </span><span class="lineNoCov">          0 :                  if (implicitStatement != NULL &amp;&amp; implicitStatement-&gt;get_implicit_none() == true)</span></a>
<a name="3002"><span class="lineNum">    3002 </span>            :                    isImplicitNoneScope = true;</a>
<a name="3003"><span class="lineNum">    3003 </span><span class="lineNoCov">          0 :                  j++;</span></a>
<a name="3004"><span class="lineNum">    3004 </span>            :                }</a>
<a name="3005"><span class="lineNum">    3005 </span>            :              }</a>
<a name="3006"><span class="lineNum">    3006 </span><span class="lineCov">        102 :           i++;</span></a>
<a name="3007"><span class="lineNum">    3007 </span>            :         }</a>
<a name="3008"><span class="lineNum">    3008 </span>            : </a>
<a name="3009"><span class="lineNum">    3009 </span>            :   // DQ (5/21/2008): for the case of a module we will not find a SgFunctionDefinition (see test2008_35.f90)</a>
<a name="3010"><span class="lineNum">    3010 </span>            :   // ROSE_ASSERT(foundFunctionDefinition == true);</a>
<a name="3011"><span class="lineNum">    3011 </span>            : </a>
<a name="3012"><span class="lineNum">    3012 </span><span class="lineCov">         25 :      return isImplicitNoneScope;</span></a>
<a name="3013"><span class="lineNum">    3013 </span>            :    }</a>
<a name="3014"><span class="lineNum">    3014 </span>            : </a>
<a name="3015"><span class="lineNum">    3015 </span>            : </a>
<a name="3016"><span class="lineNum">    3016 </span>            : SgVariableDeclaration* </a>
<a name="3017"><span class="lineNum">    3017 </span><span class="lineCov">         10 : buildVariableDeclaration (Token_t * label, bool buildingImplicitVariable )</span></a>
<a name="3018"><span class="lineNum">    3018 </span>            :    {</a>
<a name="3019"><span class="lineNum">    3019 </span>            :   // DQ (5/17/2008): If we are building a variable using implicit type rules, </a>
<a name="3020"><span class="lineNum">    3020 </span>            :   // then make sure this is not in a scope (or in a nested scope) that has </a>
<a name="3021"><span class="lineNum">    3021 </span>            :   // been marked as &quot;implicit none&quot;.</a>
<a name="3022"><span class="lineNum">    3022 </span><span class="lineCov">         10 :      if (buildingImplicitVariable == true)</span></a>
<a name="3023"><span class="lineNum">    3023 </span>            :         {</a>
<a name="3024"><span class="lineNum">    3024 </span><span class="lineCov">         10 :           bool isAnImplicitNoneScope = isImplicitNoneScope();</span></a>
<a name="3025"><span class="lineNum">    3025 </span>            : </a>
<a name="3026"><span class="lineNum">    3026 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="3027"><span class="lineNum">    3027 </span><span class="lineNoCov">          0 :                printf (&quot;In buildVariableDeclaration(): isAnImplicitNoneScope = %s \n&quot;,(isAnImplicitNoneScope == true) ? &quot;true&quot; : &quot;false&quot;);</span></a>
<a name="3028"><span class="lineNum">    3028 </span>            : #if 0</a>
<a name="3029"><span class="lineNum">    3029 </span>            :           if (isAnImplicitNoneScope == true)</a>
<a name="3030"><span class="lineNum">    3030 </span>            :              {</a>
<a name="3031"><span class="lineNum">    3031 </span>            :                outputState(&quot;Warning: isAnImplicitNoneScope == true buildVariableDeclaration()&quot;);</a>
<a name="3032"><span class="lineNum">    3032 </span>            :              }</a>
<a name="3033"><span class="lineNum">    3033 </span>            : #endif</a>
<a name="3034"><span class="lineNum">    3034 </span>            :        // First we build it as a variable then we build it as a function (a few rules later)</a>
<a name="3035"><span class="lineNum">    3035 </span>            :        // So although we know at this point that this is going to be a function, we have to</a>
<a name="3036"><span class="lineNum">    3036 </span>            :        // build it as a varialbe so that it can be evaluated for converstion from a variable </a>
<a name="3037"><span class="lineNum">    3037 </span>            :        // into a function or array a bit later.</a>
<a name="3038"><span class="lineNum">    3038 </span>            :        // ROSE_ASSERT(isAnImplicitNoneScope == false);</a>
<a name="3039"><span class="lineNum">    3039 </span>            :         }</a>
<a name="3040"><span class="lineNum">    3040 </span>            : </a>
<a name="3041"><span class="lineNum">    3041 </span>            :   // printf (&quot;buildingImplicitVariable = %s \n&quot;,buildingImplicitVariable ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3042"><span class="lineNum">    3042 </span>            : </a>
<a name="3043"><span class="lineNum">    3043 </span>            :   // Currently I am skipping initializers</a>
<a name="3044"><span class="lineNum">    3044 </span><span class="lineCov">         10 :      SgVariableDeclaration* variableDeclaration = new SgVariableDeclaration();</span></a>
<a name="3045"><span class="lineNum">    3045 </span>            : </a>
<a name="3046"><span class="lineNum">    3046 </span>            :   // Set the position of the definition (not always the same, but most often the same)</a>
<a name="3047"><span class="lineNum">    3047 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="3048"><span class="lineNum">    3048 </span>            : </a>
<a name="3049"><span class="lineNum">    3049 </span><span class="lineCov">         10 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="3050"><span class="lineNum">    3050 </span><span class="lineNoCov">          0 :           printf (&quot;In buildVariableDeclaration(): variableDeclaration = %p being built astNodeStack.size() = %&quot; PRIuPTR &quot; \n&quot;,variableDeclaration,astNodeStack.size());</span></a>
<a name="3051"><span class="lineNum">    3051 </span>            : </a>
<a name="3052"><span class="lineNum">    3052 </span>            :   // Now the toke list has all the tokens from the start to the end (except the type, which never was a token, not sure what to do about that).</a>
<a name="3053"><span class="lineNum">    3053 </span>            :   // setSourcePosition(variableDeclaration,tokenList);</a>
<a name="3054"><span class="lineNum">    3054 </span>            :   // setSourcePosition(variableDeclaration,label);</a>
<a name="3055"><span class="lineNum">    3055 </span><span class="lineCov">         10 :      setSourcePosition(variableDeclaration);</span></a>
<a name="3056"><span class="lineNum">    3056 </span>            : </a>
<a name="3057"><span class="lineNum">    3057 </span>            :   // DQ (9/20/2007): Set the parent and definingDeclaration explicitly, the scopes is not defined.</a>
<a name="3058"><span class="lineNum">    3058 </span><span class="lineCov">         10 :      SgScopeStatement* currentScope = getTopOfScopeStack();</span></a>
<a name="3059"><span class="lineNum">    3059 </span><span class="lineCov">         10 :      variableDeclaration-&gt;set_parent(currentScope);</span></a>
<a name="3060"><span class="lineNum">    3060 </span><span class="lineCov">         10 :      variableDeclaration-&gt;set_definingDeclaration(variableDeclaration);</span></a>
<a name="3061"><span class="lineNum">    3061 </span>            : </a>
<a name="3062"><span class="lineNum">    3062 </span>            :   // Setup the label on the statement if it is available.</a>
<a name="3063"><span class="lineNum">    3063 </span><span class="lineCov">         10 :      setStatementNumericLabel(variableDeclaration,label);</span></a>
<a name="3064"><span class="lineNum">    3064 </span>            : </a>
<a name="3065"><span class="lineNum">    3065 </span>            :   // This should be the default, so I am not sure why we have to set it!</a>
<a name="3066"><span class="lineNum">    3066 </span><span class="lineCov">         10 :      variableDeclaration-&gt;set_variableDeclarationContainsBaseTypeDefiningDeclaration(false);</span></a>
<a name="3067"><span class="lineNum">    3067 </span>            : </a>
<a name="3068"><span class="lineNum">    3068 </span>            :   // Get the first SgInitializedName object and set its members</a>
<a name="3069"><span class="lineNum">    3069 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration-&gt;get_variables().empty() == true);</span></a>
<a name="3070"><span class="lineNum">    3070 </span><span class="lineCov">         10 :      ROSE_ASSERT(astNodeStack.empty() == false);</span></a>
<a name="3071"><span class="lineNum">    3071 </span>            : </a>
<a name="3072"><span class="lineNum">    3072 </span>            :   // printf (&quot;astNodeStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astNodeStack.size());</a>
<a name="3073"><span class="lineNum">    3073 </span>            : </a>
<a name="3074"><span class="lineNum">    3074 </span><span class="lineCov">         10 :      SgInitializedName* firstInitializedNameForSourcePosition = NULL;</span></a>
<a name="3075"><span class="lineNum">    3075 </span><span class="lineCov">         10 :      SgInitializedName* lastInitializedNameForSourcePosition  = NULL;</span></a>
<a name="3076"><span class="lineNum">    3076 </span>            : </a>
<a name="3077"><span class="lineNum">    3077 </span><span class="lineCov">         10 :      do {</span></a>
<a name="3078"><span class="lineNum">    3078 </span>            : #if 0</a>
<a name="3079"><span class="lineNum">    3079 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="3080"><span class="lineNum">    3080 </span>            :           outputState(&quot;In loop over variables in buildVariableDeclaration()&quot;);</a>
<a name="3081"><span class="lineNum">    3081 </span>            : #endif</a>
<a name="3082"><span class="lineNum">    3082 </span>            :        // printf (&quot;At TOP of processing list of variables declared in a single declaration \n&quot;);</a>
<a name="3083"><span class="lineNum">    3083 </span>            : </a>
<a name="3084"><span class="lineNum">    3084 </span><span class="lineCov">         10 :           SgInitializedName* initializedName = isSgInitializedName(astNodeStack.front());</span></a>
<a name="3085"><span class="lineNum">    3085 </span>            : </a>
<a name="3086"><span class="lineNum">    3086 </span>            :        // These are used to set the source position of the SgVariableDeclaration</a>
<a name="3087"><span class="lineNum">    3087 </span><span class="lineCov">         10 :           if (firstInitializedNameForSourcePosition == NULL)</span></a>
<a name="3088"><span class="lineNum">    3088 </span><span class="lineCov">         10 :                firstInitializedNameForSourcePosition = initializedName;</span></a>
<a name="3089"><span class="lineNum">    3089 </span><span class="lineCov">         10 :           lastInitializedNameForSourcePosition = initializedName;</span></a>
<a name="3090"><span class="lineNum">    3090 </span>            : </a>
<a name="3091"><span class="lineNum">    3091 </span>            :        // printf (&quot;In buildVariableDeclaration(): Processing initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</a>
<a name="3092"><span class="lineNum">    3092 </span>            :        // setSourcePosition(initializedName);</a>
<a name="3093"><span class="lineNum">    3093 </span>            : </a>
<a name="3094"><span class="lineNum">    3094 </span>            :        // initializedName-&gt;get_startOfConstruct()-&gt;display(&quot;buildVariableDeclaration(): initializedName&quot;);</a>
<a name="3095"><span class="lineNum">    3095 </span>            : </a>
<a name="3096"><span class="lineNum">    3096 </span><span class="lineCov">         20 :           SgName variableName = initializedName-&gt;get_name();</span></a>
<a name="3097"><span class="lineNum">    3097 </span><span class="lineCov">         10 :           initializedName-&gt;set_declptr(variableDeclaration);</span></a>
<a name="3098"><span class="lineNum">    3098 </span>            : </a>
<a name="3099"><span class="lineNum">    3099 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="3100"><span class="lineNum">    3100 </span><span class="lineNoCov">          0 :                printf (&quot;In buildVariableDeclaration(): initializedName = %p = %s initializer = %p \n&quot;,initializedName,initializedName-&gt;get_name().str(),initializedName-&gt;get_initializer());</span></a>
<a name="3101"><span class="lineNum">    3101 </span>            : </a>
<a name="3102"><span class="lineNum">    3102 </span>            :        // DQ (11/29/2007): This is an odd API in ROSE, the initializer (already a part of the SgInitializedName, must be provide seperately to the append_variable() member function).</a>
<a name="3103"><span class="lineNum">    3103 </span>            :        // variableDeclaration-&gt;append_variable(initializedName,initializedName-&gt;get_initializer());</a>
<a name="3104"><span class="lineNum">    3104 </span><span class="lineCov">         10 :           variableDeclaration-&gt;prepend_variable(initializedName,initializedName-&gt;get_initializer());</span></a>
<a name="3105"><span class="lineNum">    3105 </span>            : </a>
<a name="3106"><span class="lineNum">    3106 </span><span class="lineCov">         10 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="3107"><span class="lineNum">    3107 </span>            :              {</a>
<a name="3108"><span class="lineNum">    3108 </span><span class="lineNoCov">          0 :                printf (&quot;After variableDeclaration-&gt;prepend_variable(): initializedName = %p = %s initializer = %p \n&quot;,initializedName,initializedName-&gt;get_name().str(),initializedName-&gt;get_initializer());</span></a>
<a name="3109"><span class="lineNum">    3109 </span><span class="lineNoCov">          0 :                if (initializedName-&gt;get_initializer() != NULL)</span></a>
<a name="3110"><span class="lineNum">    3110 </span>            :                   {</a>
<a name="3111"><span class="lineNum">    3111 </span><span class="lineNoCov">          0 :                     SgExpression* initializer = initializedName-&gt;get_initializer();</span></a>
<a name="3112"><span class="lineNum">    3112 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(initializer != NULL);</span></a>
<a name="3113"><span class="lineNum">    3113 </span><span class="lineNoCov">          0 :                     printf (&quot;--- initializedName-&gt;get_initializer() = %p = %s = %s \n&quot;,initializer,initializer-&gt;class_name().c_str(),SageInterface::get_name(initializer).c_str());</span></a>
<a name="3114"><span class="lineNum">    3114 </span>            :                   }</a>
<a name="3115"><span class="lineNum">    3115 </span>            :              }</a>
<a name="3116"><span class="lineNum">    3116 </span>            : </a>
<a name="3117"><span class="lineNum">    3117 </span>            :        // setSourcePosition(initializedName-&gt;get_definition());</a>
<a name="3118"><span class="lineNum">    3118 </span><span class="lineCov">         10 :           ROSE_ASSERT(initializedName-&gt;get_definition()-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="3119"><span class="lineNum">    3119 </span>            : </a>
<a name="3120"><span class="lineNum">    3120 </span><span class="lineCov">         10 :           ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="3121"><span class="lineNum">    3121 </span><span class="lineCov">         10 :           ROSE_ASSERT(astScopeStack.front()-&gt;get_parent() != NULL);</span></a>
<a name="3122"><span class="lineNum">    3122 </span><span class="lineCov">         10 :           SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(astScopeStack.front()-&gt;get_parent());</span></a>
<a name="3123"><span class="lineNum">    3123 </span>            : </a>
<a name="3124"><span class="lineNum">    3124 </span>            :        // DQ (5/15/2008): This is allowed since the variable may have been previous built from a common block declaration.</a>
<a name="3125"><span class="lineNum">    3125 </span>            :        // ROSE_ASSERT(initializedName-&gt;get_scope() == NULL);</a>
<a name="3126"><span class="lineNum">    3126 </span>            : </a>
<a name="3127"><span class="lineNum">    3127 </span><span class="lineCov">         10 :           SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="3128"><span class="lineNum">    3128 </span><span class="lineCov">         10 :           if (functionDefinition != NULL)</span></a>
<a name="3129"><span class="lineNum">    3129 </span>            :              {</a>
<a name="3130"><span class="lineNum">    3130 </span><span class="lineCov">          9 :                variableSymbol = functionDefinition-&gt;lookup_variable_symbol(variableName);</span></a>
<a name="3131"><span class="lineNum">    3131 </span><span class="lineCov">          9 :                if (variableSymbol != NULL)</span></a>
<a name="3132"><span class="lineNum">    3132 </span>            :                   {</a>
<a name="3133"><span class="lineNum">    3133 </span>            :                  // This variable symbol has already been placed into the function definition's symbol table</a>
<a name="3134"><span class="lineNum">    3134 </span>            :                  // Link the SgInitializedName in the variable declaration with it's intry in the function parameter list.</a>
<a name="3135"><span class="lineNum">    3135 </span><span class="lineNoCov">          0 :                     initializedName-&gt;set_prev_decl_item(variableSymbol-&gt;get_declaration());</span></a>
<a name="3136"><span class="lineNum">    3136 </span>            : </a>
<a name="3137"><span class="lineNum">    3137 </span>            :                  // Set the referenced type in the function parameter to be the same as that in the declaration being processed.</a>
<a name="3138"><span class="lineNum">    3138 </span><span class="lineNoCov">          0 :                     variableSymbol-&gt;get_declaration()-&gt;set_type(initializedName-&gt;get_type());</span></a>
<a name="3139"><span class="lineNum">    3139 </span>            : </a>
<a name="3140"><span class="lineNum">    3140 </span>            :                  // Function parameters are in the scope of the function definition (same for C/C++)</a>
<a name="3141"><span class="lineNum">    3141 </span><span class="lineNoCov">          0 :                     initializedName-&gt;set_scope(functionDefinition);</span></a>
<a name="3142"><span class="lineNum">    3142 </span>            :                   }</a>
<a name="3143"><span class="lineNum">    3143 </span>            :              }</a>
<a name="3144"><span class="lineNum">    3144 </span>            : </a>
<a name="3145"><span class="lineNum">    3145 </span>            :        // If not just set above then this is not a function parameter, but it could have been built in a common block</a>
<a name="3146"><span class="lineNum">    3146 </span><span class="lineCov">          9 :           if (variableSymbol == NULL)</span></a>
<a name="3147"><span class="lineNum">    3147 </span>            :              {</a>
<a name="3148"><span class="lineNum">    3148 </span>            :             // ROSE_ASSERT(getTopOfScopeStack()-&gt;lookup_variable_symbol(variableName) == NULL);</a>
<a name="3149"><span class="lineNum">    3149 </span>            : </a>
<a name="3150"><span class="lineNum">    3150 </span>            :             // Check the current scope (function body)</a>
<a name="3151"><span class="lineNum">    3151 </span><span class="lineCov">         10 :                variableSymbol = getTopOfScopeStack()-&gt;lookup_variable_symbol(variableName);</span></a>
<a name="3152"><span class="lineNum">    3152 </span>            : </a>
<a name="3153"><span class="lineNum">    3153 </span><span class="lineCov">         10 :                initializedName-&gt;set_scope(astScopeStack.front());</span></a>
<a name="3154"><span class="lineNum">    3154 </span>            : </a>
<a name="3155"><span class="lineNum">    3155 </span><span class="lineCov">         10 :                if (variableSymbol == NULL)</span></a>
<a name="3156"><span class="lineNum">    3156 </span>            :                   {</a>
<a name="3157"><span class="lineNum">    3157 </span><span class="lineCov">         10 :                     variableSymbol = new SgVariableSymbol(initializedName);</span></a>
<a name="3158"><span class="lineNum">    3158 </span>            :                     //printf (&quot;Debug, built a var symbol %p\n&quot;,variableSymbol);</a>
<a name="3159"><span class="lineNum">    3159 </span><span class="lineCov">         10 :                     astScopeStack.front()-&gt;insert_symbol(variableName,variableSymbol);</span></a>
<a name="3160"><span class="lineNum">    3160 </span><span class="lineCov">         10 :                     ROSE_ASSERT (initializedName-&gt;get_symbol_from_symbol_table () != NULL);</span></a>
<a name="3161"><span class="lineNum">    3161 </span>            :                     //SgSymbolTable * parent = isSgSymbolTable(variableSymbol-&gt;get_parent());</a>
<a name="3162"><span class="lineNum">    3162 </span>            :                     //ROSE_ASSERT (parent != NULL);</a>
<a name="3163"><span class="lineNum">    3163 </span>            :                    // ROSE_ASSERT (parent-&gt;find_variable(initializedName-&gt;get_name()) == variableSymbol);</a>
<a name="3164"><span class="lineNum">    3164 </span>            : </a>
<a name="3165"><span class="lineNum">    3165 </span>            :                   }</a>
<a name="3166"><span class="lineNum">    3166 </span>            :              }</a>
<a name="3167"><span class="lineNum">    3167 </span>            : </a>
<a name="3168"><span class="lineNum">    3168 </span><span class="lineCov">         10 :           ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="3169"><span class="lineNum">    3169 </span><span class="lineCov">         10 :           ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="3170"><span class="lineNum">    3170 </span>            : </a>
<a name="3171"><span class="lineNum">    3171 </span>            :        // DQ (12/14/2007): Error checking... this should not have been specified as built in global scope!</a>
<a name="3172"><span class="lineNum">    3172 </span><span class="lineCov">         10 :           if (isSgGlobal(initializedName-&gt;get_scope()) != NULL)</span></a>
<a name="3173"><span class="lineNum">    3173 </span>            :              {</a>
<a name="3174"><span class="lineNum">    3174 </span><span class="lineNoCov">          0 :                printf (&quot;Error: isSgGlobal(initializedName-&gt;get_scope()) != NULL *** initializedName = %p = %s \n&quot;,initializedName,initializedName-&gt;get_name().str());</span></a>
<a name="3175"><span class="lineNum">    3175 </span>            :              }</a>
<a name="3176"><span class="lineNum">    3176 </span>            :        // Pei-Hung (11/15/2019) comment this out</a>
<a name="3177"><span class="lineNum">    3177 </span>            :        //   ROSE_ASSERT(isSgGlobal(initializedName-&gt;get_scope()) == NULL);</a>
<a name="3178"><span class="lineNum">    3178 </span>            : </a>
<a name="3179"><span class="lineNum">    3179 </span>            :        // DQ (1/25/2011): Failing for test2011_33.f90 (because the variables being added to the function were first </a>
<a name="3180"><span class="lineNum">    3180 </span>            :        // defined as function parameters.  This is I think an issue that the buildInterface tries to fix in the </a>
<a name="3181"><span class="lineNum">    3181 </span>            :        // SageBuilder::buildVariableDeclaration() function.</a>
<a name="3182"><span class="lineNum">    3182 </span>            :        // DQ (1/24/2011): I think that this test should pass.</a>
<a name="3183"><span class="lineNum">    3183 </span>            :        // ROSE_ASSERT(initializedName-&gt;get_symbol_from_symbol_table() != NULL);</a>
<a name="3184"><span class="lineNum">    3184 </span>            : </a>
<a name="3185"><span class="lineNum">    3185 </span>            : #if 0</a>
<a name="3186"><span class="lineNum">    3186 </span>            :        // Make sure that the variable does not already exist in this current scope!</a>
<a name="3187"><span class="lineNum">    3187 </span>            :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="3188"><span class="lineNum">    3188 </span>            :                printf (&quot;Looking for symbol for initializedName = %s scope = %p = %s \n&quot;,initializedName-&gt;get_name().str(),initializedName-&gt;get_scope(),initializedName-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="3189"><span class="lineNum">    3189 </span>            : #endif </a>
<a name="3190"><span class="lineNum">    3190 </span>            :        // Make sure we can find the newly added symbol!</a>
<a name="3191"><span class="lineNum">    3191 </span>            :        // ROSE_ASSERT(getTopOfScopeStack()-&gt;lookup_variable_symbol(variableName) != NULL);</a>
<a name="3192"><span class="lineNum">    3192 </span>            : </a>
<a name="3193"><span class="lineNum">    3193 </span><span class="lineCov">         10 :           setSourcePosition(initializedName);</span></a>
<a name="3194"><span class="lineNum">    3194 </span>            : #if 0</a>
<a name="3195"><span class="lineNum">    3195 </span>            :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</a>
<a name="3196"><span class="lineNum">    3196 </span>            :                printf (&quot;In buildVariableDeclaration(): initializedName = %p \n&quot;,initializedName);</a>
<a name="3197"><span class="lineNum">    3197 </span>            : #endif</a>
<a name="3198"><span class="lineNum">    3198 </span><span class="lineCov">         10 :           ROSE_ASSERT(astNodeStack.empty() == false);</span></a>
<a name="3199"><span class="lineNum">    3199 </span><span class="lineCov">         10 :           astNodeStack.pop_front();</span></a>
<a name="3200"><span class="lineNum">    3200 </span>            : </a>
<a name="3201"><span class="lineNum">    3201 </span>            :        // We should have at least one element in the variable list.</a>
<a name="3202"><span class="lineNum">    3202 </span><span class="lineCov">         10 :           ROSE_ASSERT(variableDeclaration-&gt;get_variables().empty() == false);</span></a>
<a name="3203"><span class="lineNum">    3203 </span>            : </a>
<a name="3204"><span class="lineNum">    3204 </span>            :        // printf (&quot;At BOTTOM of processing list of variables declared in a single declaration \n&quot;);</a>
<a name="3205"><span class="lineNum">    3205 </span>            :         }</a>
<a name="3206"><span class="lineNum">    3206 </span><span class="lineCov">         10 :      while ( (buildingImplicitVariable == false) &amp;&amp; (astNodeStack.empty() == false) );</span></a>
<a name="3207"><span class="lineNum">    3207 </span>            : </a>
<a name="3208"><span class="lineNum">    3208 </span>            :   // DQ (11/24/2007): Set the default to be undefined (new setting added to support Fortran)</a>
<a name="3209"><span class="lineNum">    3209 </span>            :   // Note that undefined access (niether PUBLIC nor PRIVATE) default to PUBLIC if there is not </a>
<a name="3210"><span class="lineNum">    3210 </span>            :   // PRIVATE statement specifically naming the variable or no PRIVATE statement with an empty list.</a>
<a name="3211"><span class="lineNum">    3211 </span>            :   // Note that either a PUBLIC or PRIVATE statement with no list changes the default setting!</a>
<a name="3212"><span class="lineNum">    3212 </span>            :   // So we default to an undefined setting.</a>
<a name="3213"><span class="lineNum">    3213 </span><span class="lineCov">         10 :      variableDeclaration-&gt;get_declarationModifier().get_accessModifier().setUndefined();</span></a>
<a name="3214"><span class="lineNum">    3214 </span>            : </a>
<a name="3215"><span class="lineNum">    3215 </span>            :   // DQ (11/18/2007): Save the attributes used and clear the astAttributeSpecStack for this declaration</a>
<a name="3216"><span class="lineNum">    3216 </span><span class="lineCov">         10 :      while (astAttributeSpecStack.empty() == false)   // DXN: TODO use the global VarAttrSpec instead</span></a>
<a name="3217"><span class="lineNum">    3217 </span>            :         {</a>
<a name="3218"><span class="lineNum">    3218 </span>            :        // printf (&quot;In buildVariableDeclaration(): Process attribute spec %d &quot;,astAttributeSpecStack.front());</a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineNoCov">          0 :           setDeclarationAttributeSpec(variableDeclaration,astAttributeSpecStack.front());</span></a>
<a name="3220"><span class="lineNum">    3220 </span>            : </a>
<a name="3221"><span class="lineNum">    3221 </span><span class="lineNoCov">          0 :           if (astAttributeSpecStack.front() == AttrSpec_PUBLIC || astAttributeSpecStack.front() == AttrSpec_PRIVATE)</span></a>
<a name="3222"><span class="lineNum">    3222 </span>            :              {</a>
<a name="3223"><span class="lineNum">    3223 </span>            :             // printf (&quot;astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astNameStack.size());</a>
<a name="3224"><span class="lineNum">    3224 </span><span class="lineNoCov">          0 :                if (astNameStack.empty() == false)</span></a>
<a name="3225"><span class="lineNum">    3225 </span>            :                   {</a>
<a name="3226"><span class="lineNum">    3226 </span><span class="lineNoCov">          0 :                     string type_attribute_string = astNameStack.front()-&gt;text;</span></a>
<a name="3227"><span class="lineNum">    3227 </span>            :                  // printf (&quot;type_attribute_string = %s \n&quot;,type_attribute_string.c_str());</a>
<a name="3228"><span class="lineNum">    3228 </span><span class="lineNoCov">          0 :                     astNameStack.pop_front();</span></a>
<a name="3229"><span class="lineNum">    3229 </span>            :                   }</a>
<a name="3230"><span class="lineNum">    3230 </span>            :              }</a>
<a name="3231"><span class="lineNum">    3231 </span>            : </a>
<a name="3232"><span class="lineNum">    3232 </span><span class="lineNoCov">          0 :           astAttributeSpecStack.pop_front();</span></a>
<a name="3233"><span class="lineNum">    3233 </span>            :         }</a>
<a name="3234"><span class="lineNum">    3234 </span>            : </a>
<a name="3235"><span class="lineNum">    3235 </span>            :   // Set the source position to be more precise than just: isCompilerGenerated = false position = 0:0 filename = NULL_FILE</a>
<a name="3236"><span class="lineNum">    3236 </span>            :   // Set the value using the firstInitializedNameForSourcePosition.</a>
<a name="3237"><span class="lineNum">    3237 </span><span class="lineCov">         10 :      ROSE_ASSERT(variableDeclaration-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="3238"><span class="lineNum">    3238 </span><span class="lineCov">         10 :      ROSE_ASSERT(firstInitializedNameForSourcePosition-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineCov">         10 :      ROSE_ASSERT(lastInitializedNameForSourcePosition-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="3240"><span class="lineNum">    3240 </span><span class="lineCov">         10 :      *(variableDeclaration-&gt;get_startOfConstruct()) = *(firstInitializedNameForSourcePosition-&gt;get_startOfConstruct());</span></a>
<a name="3241"><span class="lineNum">    3241 </span><span class="lineCov">         10 :      *(variableDeclaration-&gt;get_endOfConstruct())   = *(lastInitializedNameForSourcePosition-&gt;get_startOfConstruct());</span></a>
<a name="3242"><span class="lineNum">    3242 </span>            : </a>
<a name="3243"><span class="lineNum">    3243 </span>            :   // DQ (12/1/2007): It is better to not clear the stack here and instead clear it in R501</a>
<a name="3244"><span class="lineNum">    3244 </span>            : </a>
<a name="3245"><span class="lineNum">    3245 </span><span class="lineCov">         10 :      return variableDeclaration;</span></a>
<a name="3246"><span class="lineNum">    3246 </span>            :    }</a>
<a name="3247"><span class="lineNum">    3247 </span>            : </a>
<a name="3248"><span class="lineNum">    3248 </span>            : </a>
<a name="3249"><span class="lineNum">    3249 </span>            : void</a>
<a name="3250"><span class="lineNum">    3250 </span><span class="lineCov">       2622 : initialize_global_scope_if_required()</span></a>
<a name="3251"><span class="lineNum">    3251 </span>            :    {</a>
<a name="3252"><span class="lineNum">    3252 </span>            :   // First we have to get the global scope initialized (and pushed onto the stack).</a>
<a name="3253"><span class="lineNum">    3253 </span>            : </a>
<a name="3254"><span class="lineNum">    3254 </span>            :   // DQ (2/25/2013): Set the default for source position generation to be consistent with other languages (e.g. C/C++).</a>
<a name="3255"><span class="lineNum">    3255 </span><span class="lineCov">       2622 :      SageBuilder::setSourcePositionClassificationMode(SageBuilder::e_sourcePositionFrontendConstruction);</span></a>
<a name="3256"><span class="lineNum">    3256 </span>            : </a>
<a name="3257"><span class="lineNum">    3257 </span>            :   // printf (&quot;In initialize_global_scope_if_required(): astScopeStack.empty() = %s \n&quot;,astScopeStack.empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3258"><span class="lineNum">    3258 </span><span class="lineCov">       2622 :      if (astScopeStack.empty() == true)</span></a>
<a name="3259"><span class="lineNum">    3259 </span>            :         {</a>
<a name="3260"><span class="lineNum">    3260 </span><span class="lineCov">         37 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="3261"><span class="lineNum">    3261 </span><span class="lineNoCov">          0 :                printf (&quot;In initialize_global_scope_if_required(): OpenFortranParser_globalFilePointer = %p \n&quot;,OpenFortranParser_globalFilePointer);</span></a>
<a name="3262"><span class="lineNum">    3262 </span>            : </a>
<a name="3263"><span class="lineNum">    3263 </span><span class="lineCov">         37 :           ROSE_ASSERT(OpenFortranParser_globalFilePointer != NULL);</span></a>
<a name="3264"><span class="lineNum">    3264 </span><span class="lineCov">         37 :           SgSourceFile* file = OpenFortranParser_globalFilePointer;</span></a>
<a name="3265"><span class="lineNum">    3265 </span><span class="lineCov">         37 :           SgGlobal* globalScope = file-&gt;get_globalScope();</span></a>
<a name="3266"><span class="lineNum">    3266 </span><span class="lineCov">         37 :           ROSE_ASSERT(globalScope != NULL);</span></a>
<a name="3267"><span class="lineNum">    3267 </span><span class="lineCov">         37 :           ROSE_ASSERT(globalScope-&gt;get_parent() != NULL);</span></a>
<a name="3268"><span class="lineNum">    3268 </span>            : </a>
<a name="3269"><span class="lineNum">    3269 </span>            :        // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="3270"><span class="lineNum">    3270 </span><span class="lineCov">         37 :           globalScope-&gt;setCaseInsensitive(true);</span></a>
<a name="3271"><span class="lineNum">    3271 </span>            : </a>
<a name="3272"><span class="lineNum">    3272 </span>            :        // DQ (8/21/2008): endOfConstruct is not set to be consistant with startOfConstruct.</a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineCov">         37 :           ROSE_ASSERT(globalScope-&gt;get_endOfConstruct()   != NULL);</span></a>
<a name="3274"><span class="lineNum">    3274 </span><span class="lineCov">         37 :           ROSE_ASSERT(globalScope-&gt;get_startOfConstruct() != NULL);</span></a>
<a name="3275"><span class="lineNum">    3275 </span>            : </a>
<a name="3276"><span class="lineNum">    3276 </span>            :        // Scopes should be pushed onto the front of the stack (we define the top of the stack to</a>
<a name="3277"><span class="lineNum">    3277 </span>            :        // be the front).  I have used a vector instead of a stack for now, this might change later.</a>
<a name="3278"><span class="lineNum">    3278 </span><span class="lineCov">         37 :           ROSE_ASSERT(astScopeStack.empty() == true);</span></a>
<a name="3279"><span class="lineNum">    3279 </span><span class="lineCov">         37 :           astScopeStack.push_front(globalScope);</span></a>
<a name="3280"><span class="lineNum">    3280 </span>            : </a>
<a name="3281"><span class="lineNum">    3281 </span>            :        // DQ (10/10/2010): Set the start position of global scope to &quot;1&quot;.</a>
<a name="3282"><span class="lineNum">    3282 </span><span class="lineCov">         37 :           globalScope-&gt;get_startOfConstruct()-&gt;set_line(1);</span></a>
<a name="3283"><span class="lineNum">    3283 </span>            : </a>
<a name="3284"><span class="lineNum">    3284 </span>            :        // DQ (10/10/2010): Set this position to the same value so that if we increment </a>
<a name="3285"><span class="lineNum">    3285 </span>            :        // by &quot;1&quot; the start and end will not be the same value.</a>
<a name="3286"><span class="lineNum">    3286 </span><span class="lineCov">         37 :           globalScope-&gt;get_endOfConstruct()-&gt;set_line(1);</span></a>
<a name="3287"><span class="lineNum">    3287 </span>            : #if 0</a>
<a name="3288"><span class="lineNum">    3288 </span>            :           astScopeStack.front()-&gt;get_startOfConstruct()-&gt;display(&quot;In initialize_global_scope_if_required(): start&quot;);</a>
<a name="3289"><span class="lineNum">    3289 </span>            :           astScopeStack.front()-&gt;get_endOfConstruct  ()-&gt;display(&quot;In initialize_global_scope_if_required(): end&quot;);</a>
<a name="3290"><span class="lineNum">    3290 </span>            : #endif</a>
<a name="3291"><span class="lineNum">    3291 </span>            :         }</a>
<a name="3292"><span class="lineNum">    3292 </span>            : </a>
<a name="3293"><span class="lineNum">    3293 </span>            :   // Testing the scope stack...</a>
<a name="3294"><span class="lineNum">    3294 </span>            :   // DQ (11/28/2010): Added specification of case insensitivity for Fortran.</a>
<a name="3295"><span class="lineNum">    3295 </span><span class="lineCov">       2622 :      std::list&lt;SgScopeStatement*&gt;::iterator scopeInterator = astScopeStack.begin();</span></a>
<a name="3296"><span class="lineNum">    3296 </span><span class="lineCov">      10398 :      while (scopeInterator != astScopeStack.end())</span></a>
<a name="3297"><span class="lineNum">    3297 </span>            :         {</a>
<a name="3298"><span class="lineNum">    3298 </span><span class="lineCov">       7776 :           if ((*scopeInterator)-&gt;isCaseInsensitive() == false)</span></a>
<a name="3299"><span class="lineNum">    3299 </span>            :              {</a>
<a name="3300"><span class="lineNum">    3300 </span><span class="lineNoCov">          0 :                printf (&quot;##### Error (in initialize_global_scope_if_required): the scope handling is set to case sensitive scopeInterator = %p = %s \n&quot;,*scopeInterator,(*scopeInterator)-&gt;class_name().c_str());</span></a>
<a name="3301"><span class="lineNum">    3301 </span>            :             // (*scopeInterator)-&gt;setCaseInsensitive(true);</a>
<a name="3302"><span class="lineNum">    3302 </span>            :              }</a>
<a name="3303"><span class="lineNum">    3303 </span><span class="lineCov">       7776 :           ROSE_ASSERT((*scopeInterator)-&gt;isCaseInsensitive() == true);</span></a>
<a name="3304"><span class="lineNum">    3304 </span><span class="lineCov">      10398 :           scopeInterator++;</span></a>
<a name="3305"><span class="lineNum">    3305 </span>            :         }</a>
<a name="3306"><span class="lineNum">    3306 </span><span class="lineCov">       2622 :    }</span></a>
<a name="3307"><span class="lineNum">    3307 </span>            : </a>
<a name="3308"><span class="lineNum">    3308 </span>            : bool</a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">     133941 : matchingName ( string x, string y )</span></a>
<a name="3310"><span class="lineNum">    3310 </span>            :    {</a>
<a name="3311"><span class="lineNum">    3311 </span>            :   // This function checks a case insensitive match of x against y.</a>
<a name="3312"><span class="lineNum">    3312 </span>            :   // This is required because Fortran is case insensitive.</a>
<a name="3313"><span class="lineNum">    3313 </span>            : </a>
<a name="3314"><span class="lineNum">    3314 </span><span class="lineCov">     133941 :      size_t x_length = x.length();</span></a>
<a name="3315"><span class="lineNum">    3315 </span><span class="lineCov">     133941 :      size_t y_length = y.length();</span></a>
<a name="3316"><span class="lineNum">    3316 </span>            : </a>
<a name="3317"><span class="lineNum">    3317 </span><span class="lineCov">     133941 :      return (x_length == y_length) ? strncasecmp(x.c_str(),y.c_str(),x_length) == 0 : false;</span></a>
<a name="3318"><span class="lineNum">    3318 </span>            :    }</a>
<a name="3319"><span class="lineNum">    3319 </span>            : </a>
<a name="3320"><span class="lineNum">    3320 </span>            : // bool matchAgainstImplicitFunctionList( std::string s )</a>
<a name="3321"><span class="lineNum">    3321 </span>            : bool</a>
<a name="3322"><span class="lineNum">    3322 </span><span class="lineCov">        480 : matchAgainstIntrinsicFunctionList( std::string s )</span></a>
<a name="3323"><span class="lineNum">    3323 </span>            :    {</a>
<a name="3324"><span class="lineNum">    3324 </span>            :   // This function should likely break out the subroutines and procedures that would be associated with a &quot;call&quot; statement.</a>
<a name="3325"><span class="lineNum">    3325 </span>            : </a>
<a name="3326"><span class="lineNum">    3326 </span><span class="lineCov">        480 :      bool resultValue = false;</span></a>
<a name="3327"><span class="lineNum">    3327 </span>            : </a>
<a name="3328"><span class="lineNum">    3328 </span>            :   // Need caseinsensitive version: strncasecmp(keyword1-&gt;text,&quot;real&quot;,4) == 0</a>
<a name="3329"><span class="lineNum">    3329 </span>            : </a>
<a name="3330"><span class="lineNum">    3330 </span>            :   // bool isTypeInqueryFunction      = (s == &quot;associated&quot;) || (s == &quot;present&quot;)  || (s == &quot;kind&quot;);</a>
<a name="3331"><span class="lineNum">    3331 </span><span class="lineCov">       4122 :      bool isTypeInqueryFunction      = matchingName(s,&quot;associated&quot;) || matchingName(s,&quot;present&quot;)  || matchingName(s,&quot;kind&quot;);</span></a>
<a name="3332"><span class="lineNum">    3332 </span>            : </a>
<a name="3333"><span class="lineNum">    3333 </span><span class="lineCov">        480 :      bool isElementalNumericFunction = </span></a>
<a name="3334"><span class="lineNum">    3334 </span><span class="lineCov">       8922 :           matchingName(s,&quot;abs&quot;) || matchingName(s,&quot;aimag&quot;)  || matchingName(s,&quot;aint&quot;) || matchingName(s,&quot;anint&quot;) || matchingName(s,&quot;ceiling&quot;) || </span></a>
<a name="3335"><span class="lineNum">    3335 </span><span class="lineCov">       9120 :           matchingName(s,&quot;cmplx&quot;) || matchingName(s,&quot;floor&quot;) || matchingName(s,&quot;int&quot;) || matchingName(s,&quot;nint&quot;) || matchingName(s,&quot;real&quot;);</span></a>
<a name="3336"><span class="lineNum">    3336 </span>            : </a>
<a name="3337"><span class="lineNum">    3337 </span><span class="lineCov">        480 :      bool isElementalNonConversionFunction = </span></a>
<a name="3338"><span class="lineNum">    3338 </span><span class="lineCov">       9882 :           matchingName(s,&quot;conjg&quot;) || matchingName(s,&quot;dim&quot;) || matchingName(s,&quot;max&quot;) || matchingName(s,&quot;min&quot;) || matchingName(s,&quot;mod&quot;) || matchingName(s,&quot;modulo&quot;) || matchingName(s,&quot;sign&quot;);</span></a>
<a name="3339"><span class="lineNum">    3339 </span>            : </a>
<a name="3340"><span class="lineNum">    3340 </span><span class="lineCov">        480 :      bool isElementalMathFunction = </span></a>
<a name="3341"><span class="lineNum">    3341 </span><span class="lineCov">       8922 :           matchingName(s,&quot;acos&quot;) || matchingName(s,&quot;asin&quot;) || matchingName(s,&quot;atan&quot;) || matchingName(s,&quot;atan2&quot;) || matchingName(s,&quot;cos&quot;) || </span></a>
<a name="3342"><span class="lineNum">    3342 </span><span class="lineCov">       9600 :           matchingName(s,&quot;cosh&quot;) || matchingName(s,&quot;exp&quot;)  || matchingName(s,&quot;log&quot;)  || matchingName(s,&quot;log10&quot;) || matchingName(s,&quot;sin&quot;) || </span></a>
<a name="3343"><span class="lineNum">    3343 </span><span class="lineCov">       7680 :           matchingName(s,&quot;sinh&quot;) || matchingName(s,&quot;sqrt&quot;) || matchingName(s,&quot;tan&quot;)  || matchingName(s,&quot;tanh&quot;);</span></a>
<a name="3344"><span class="lineNum">    3344 </span>            : </a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineCov">        480 :      bool isCharacterConversionFunction = </span></a>
<a name="3346"><span class="lineNum">    3346 </span><span class="lineCov">       5562 :           matchingName(s,&quot;achar&quot;) || matchingName(s,&quot;char&quot;) || matchingName(s,&quot;iachar&quot;) || matchingName(s,&quot;ichar&quot;);</span></a>
<a name="3347"><span class="lineNum">    3347 </span>            : </a>
<a name="3348"><span class="lineNum">    3348 </span><span class="lineCov">       5562 :      bool isLexicalCompareFunction = matchingName(s,&quot;lge&quot;) || matchingName(s,&quot;lgt&quot;) || matchingName(s,&quot;lle&quot;) || matchingName(s,&quot;llt&quot;);</span></a>
<a name="3349"><span class="lineNum">    3349 </span>            : </a>
<a name="3350"><span class="lineNum">    3350 </span><span class="lineCov">        480 :      bool isStringHandlingElementalFunction = </span></a>
<a name="3351"><span class="lineNum">    3351 </span><span class="lineCov">       8442 :           matchingName(s,&quot;adjustl&quot;) || matchingName(s,&quot;adjustr&quot;) || matchingName(s,&quot;index&quot;) || matchingName(s,&quot;len_trim&quot;) || matchingName(s,&quot;scan&quot;) || matchingName(s,&quot;verify&quot;);</span></a>
<a name="3352"><span class="lineNum">    3352 </span>            : </a>
<a name="3353"><span class="lineNum">    3353 </span><span class="lineCov">       1242 :      bool isLogicalConversionFunction = matchingName(s,&quot;logical&quot;);</span></a>
<a name="3354"><span class="lineNum">    3354 </span>            : </a>
<a name="3355"><span class="lineNum">    3355 </span><span class="lineCov">       1242 :      bool isStringInqueryFunction = matchingName(s,&quot;len&quot;);</span></a>
<a name="3356"><span class="lineNum">    3356 </span>            : </a>
<a name="3357"><span class="lineNum">    3357 </span><span class="lineCov">       2682 :      bool isStringTransformationFunction = matchingName(s,&quot;repeat&quot;) || matchingName(s,&quot;trim&quot;);</span></a>
<a name="3358"><span class="lineNum">    3358 </span>            : </a>
<a name="3359"><span class="lineNum">    3359 </span><span class="lineCov">        480 :      bool isNumericInqueryFunction = </span></a>
<a name="3360"><span class="lineNum">    3360 </span><span class="lineCov">      12762 :           matchingName(s,&quot;digits&quot;) || matchingName(s,&quot;epsilon&quot;) || matchingName(s,&quot;huge&quot;) || matchingName(s,&quot;maxexponent&quot;) || matchingName(s,&quot;minexponent&quot;) || matchingName(s,&quot;precision&quot;) || matchingName(s,&quot;radix&quot;) || matchingName(s,&quot;range&quot;) || matchingName(s,&quot;tiny&quot;);</span></a>
<a name="3361"><span class="lineNum">    3361 </span>            : </a>
<a name="3362"><span class="lineNum">    3362 </span><span class="lineCov">        480 :      bool isElementalRealFunction = </span></a>
<a name="3363"><span class="lineNum">    3363 </span><span class="lineCov">       9882 :           matchingName(s,&quot;exponent&quot;) || matchingName(s,&quot;fraction&quot;) || matchingName(s,&quot;nearest&quot;) || matchingName(s,&quot;rrspacing&quot;) || matchingName(s,&quot;scale&quot;) || matchingName(s,&quot;set_exponent&quot;) || matchingName(s,&quot;spacing&quot;);</span></a>
<a name="3364"><span class="lineNum">    3364 </span>            : </a>
<a name="3365"><span class="lineNum">    3365 </span><span class="lineCov">       2682 :      bool isKindTransformationFunction = matchingName(s,&quot;selected_int_kind&quot;) || matchingName(s,&quot;selected_real_kind&quot;);</span></a>
<a name="3366"><span class="lineNum">    3366 </span>            : </a>
<a name="3367"><span class="lineNum">    3367 </span><span class="lineCov">       1242 :      bool isBitInqueryFunction = matchingName(s,&quot;bit_size&quot;);</span></a>
<a name="3368"><span class="lineNum">    3368 </span>            : </a>
<a name="3369"><span class="lineNum">    3369 </span><span class="lineCov">        480 :      bool isBitElementalFunction = </span></a>
<a name="3370"><span class="lineNum">    3370 </span><span class="lineCov">      10362 :           matchingName(s,&quot;btest&quot;) || matchingName(s,&quot;iand&quot;) || matchingName(s,&quot;ibclr&quot;) || matchingName(s,&quot;ibits&quot;) || matchingName(s,&quot;ibset&quot;) || matchingName(s,&quot;ieor&quot;) ||</span></a>
<a name="3371"><span class="lineNum">    3371 </span><span class="lineCov">       7680 :           matchingName(s,&quot;ior&quot;) || matchingName(s,&quot;ishft&quot;) || matchingName(s,&quot;ishftc&quot;) || matchingName(s,&quot;not&quot;);</span></a>
<a name="3372"><span class="lineNum">    3372 </span>            : </a>
<a name="3373"><span class="lineNum">    3373 </span>            :   // This is a procedure and so should be associated with a call statment and so it is different</a>
<a name="3374"><span class="lineNum">    3374 </span><span class="lineCov">       1242 :      bool isBitElementalSubroutine = matchingName(s,&quot;mvbits&quot;);</span></a>
<a name="3375"><span class="lineNum">    3375 </span>            : </a>
<a name="3376"><span class="lineNum">    3376 </span><span class="lineCov">       1242 :      bool isTransferFunction = matchingName(s,&quot;transfer&quot;);</span></a>
<a name="3377"><span class="lineNum">    3377 </span>            : </a>
<a name="3378"><span class="lineNum">    3378 </span><span class="lineCov">       2682 :      bool isVectorMatrixMultipyFunction = matchingName(s,&quot;dot_product&quot;) || matchingName(s,&quot;matmul&quot;);</span></a>
<a name="3379"><span class="lineNum">    3379 </span>            : </a>
<a name="3380"><span class="lineNum">    3380 </span>            :   // These can take one argument with an optional &quot;dim&quot; argument, also &quot;maxval&quot;, &quot;minval&quot;, &quot;product&quot;, &quot;sum&quot; can have a 3rd optional mask argument.</a>
<a name="3381"><span class="lineNum">    3381 </span><span class="lineCov">        480 :      bool isArrayReductionFunction = </span></a>
<a name="3382"><span class="lineNum">    3382 </span><span class="lineCov">       9882 :           matchingName(s,&quot;all&quot;) || matchingName(s,&quot;any&quot;) || matchingName(s,&quot;count&quot;) || matchingName(s,&quot;maxval&quot;) || matchingName(s,&quot;minval&quot;) || matchingName(s,&quot;product&quot;) || matchingName(s,&quot;sum&quot;);</span></a>
<a name="3383"><span class="lineNum">    3383 </span>            : </a>
<a name="3384"><span class="lineNum">    3384 </span><span class="lineCov">        480 :      bool isArrayInqueryFunction = </span></a>
<a name="3385"><span class="lineNum">    3385 </span><span class="lineCov">       7002 :           matchingName(s,&quot;allocated&quot;) || matchingName(s,&quot;lbound&quot;) || matchingName(s,&quot;shape&quot;) || matchingName(s,&quot;size&quot;) || matchingName(s,&quot;ubound&quot;);</span></a>
<a name="3386"><span class="lineNum">    3386 </span>            : </a>
<a name="3387"><span class="lineNum">    3387 </span><span class="lineCov">        480 :      bool isArrayConstructionAndManipulationFunction = </span></a>
<a name="3388"><span class="lineNum">    3388 </span><span class="lineCov">      11322 :           matchingName(s,&quot;merge&quot;) || matchingName(s,&quot;pack&quot;) || matchingName(s,&quot;unpack&quot;) || matchingName(s,&quot;reshape&quot;) || matchingName(s,&quot;spread&quot;) || matchingName(s,&quot;cshift&quot;) || matchingName(s,&quot;eoshift&quot;) || matchingName(s,&quot;transpose&quot;);</span></a>
<a name="3389"><span class="lineNum">    3389 </span>            : </a>
<a name="3390"><span class="lineNum">    3390 </span>            :   // These come in two flavors (depending of the use of s &quot;dim&quot; 2nd argument)</a>
<a name="3391"><span class="lineNum">    3391 </span><span class="lineCov">        480 :      bool isTransformationFunctionForGeometricLocation = </span></a>
<a name="3392"><span class="lineNum">    3392 </span><span class="lineCov">      11322 :           matchingName(s,&quot;maxloc&quot;) || matchingName(s,&quot;minloc&quot;) || matchingName(s,&quot;unpack&quot;) || matchingName(s,&quot;reshape&quot;) || matchingName(s,&quot;spread&quot;) || matchingName(s,&quot;cshift&quot;) || matchingName(s,&quot;eoshift&quot;) || matchingName(s,&quot;transpose&quot;);</span></a>
<a name="3393"><span class="lineNum">    3393 </span>            : </a>
<a name="3394"><span class="lineNum">    3394 </span><span class="lineCov">       1242 :      bool isTransformationFunctionForPointerDisassociation = matchingName(s,&quot;null&quot;);</span></a>
<a name="3395"><span class="lineNum">    3395 </span>            : </a>
<a name="3396"><span class="lineNum">    3396 </span>            :   // These are procedures and so are part of a call statement.</a>
<a name="3397"><span class="lineNum">    3397 </span><span class="lineCov">       4122 :      bool isTimeFunction = matchingName(s,&quot;data_and_time&quot;) || matchingName(s,&quot;system_clock&quot;) || matchingName(s,&quot;cpu_time&quot;);</span></a>
<a name="3398"><span class="lineNum">    3398 </span>            : </a>
<a name="3399"><span class="lineNum">    3399 </span>            :   // These are procedures and so are part of a call statement.</a>
<a name="3400"><span class="lineNum">    3400 </span><span class="lineCov">       2682 :      bool isSupportForRandomNumberFunction = matchingName(s,&quot;random_number&quot;) || matchingName(s,&quot;random_seed&quot;);</span></a>
<a name="3401"><span class="lineNum">    3401 </span>            : </a>
<a name="3402"><span class="lineNum">    3402 </span>            :   // DQ (11/25/2007): New Fortran 2003 intrinsic functions</a>
<a name="3403"><span class="lineNum">    3403 </span><span class="lineCov">       4122 :      bool isNewFortran2003Function = matchingName(s,&quot;is_iostat_end&quot;) || matchingName(s,&quot;is_iostat_eor&quot;) || matchingName(s,&quot;new_line&quot;);</span></a>
<a name="3404"><span class="lineNum">    3404 </span>            : </a>
<a name="3405"><span class="lineNum">    3405 </span>            :   // These are the generic intrinsic function name tests.</a>
<a name="3406"><span class="lineNum">    3406 </span><span class="lineCov">        480 :      if ( isTypeInqueryFunction || isElementalNumericFunction || isElementalNonConversionFunction || </span></a>
<a name="3407"><span class="lineNum">    3407 </span><span class="lineCov">        480 :           isElementalMathFunction || isCharacterConversionFunction || isLexicalCompareFunction || </span></a>
<a name="3408"><span class="lineNum">    3408 </span><span class="lineCov">        480 :           isStringHandlingElementalFunction || isLogicalConversionFunction || isStringInqueryFunction || </span></a>
<a name="3409"><span class="lineNum">    3409 </span><span class="lineCov">        480 :           isStringTransformationFunction || isNumericInqueryFunction || isElementalRealFunction || </span></a>
<a name="3410"><span class="lineNum">    3410 </span><span class="lineCov">        480 :           isKindTransformationFunction || isBitInqueryFunction || isBitElementalFunction || </span></a>
<a name="3411"><span class="lineNum">    3411 </span><span class="lineCov">        480 :           isBitElementalSubroutine || isTransferFunction || isVectorMatrixMultipyFunction || </span></a>
<a name="3412"><span class="lineNum">    3412 </span><span class="lineCov">        480 :           isArrayReductionFunction || isArrayInqueryFunction || isArrayConstructionAndManipulationFunction || </span></a>
<a name="3413"><span class="lineNum">    3413 </span><span class="lineCov">        480 :           isTransformationFunctionForGeometricLocation || isTransformationFunctionForPointerDisassociation || </span></a>
<a name="3414"><span class="lineNum">    3414 </span><span class="lineCov">        480 :           isTimeFunction || isSupportForRandomNumberFunction || isNewFortran2003Function)</span></a>
<a name="3415"><span class="lineNum">    3415 </span>            :         {</a>
<a name="3416"><span class="lineNum">    3416 </span><span class="lineNoCov">          0 :           resultValue = true;</span></a>
<a name="3417"><span class="lineNum">    3417 </span>            :         }</a>
<a name="3418"><span class="lineNum">    3418 </span>            : </a>
<a name="3419"><span class="lineNum">    3419 </span>            : // **************************************</a>
<a name="3420"><span class="lineNum">    3420 </span>            : // F77 specific types intrinsic functions</a>
<a name="3421"><span class="lineNum">    3421 </span>            : // **************************************</a>
<a name="3422"><span class="lineNum">    3422 </span>            : </a>
<a name="3423"><span class="lineNum">    3423 </span>            : /* Alternative names for abs:</a>
<a name="3424"><span class="lineNum">    3424 </span>            : IABS</a>
<a name="3425"><span class="lineNum">    3425 </span>            : ABS</a>
<a name="3426"><span class="lineNum">    3426 </span>            : DABS</a>
<a name="3427"><span class="lineNum">    3427 </span>            : CABS</a>
<a name="3428"><span class="lineNum">    3428 </span>            : QABS (sun)</a>
<a name="3429"><span class="lineNum">    3429 </span>            : ZABS (sun)</a>
<a name="3430"><span class="lineNum">    3430 </span>            : CDABS (sun)</a>
<a name="3431"><span class="lineNum">    3431 </span>            : CQABS (sun)</a>
<a name="3432"><span class="lineNum">    3432 </span>            : */</a>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineCov">       6042 :      bool isAlternativeName_abs = matchingName(s,&quot;iabs&quot;) || matchingName(s,&quot;dabs&quot;) || matchingName(s,&quot;cabs&quot;) ||</span></a>
<a name="3434"><span class="lineNum">    3434 </span><span class="lineCov">       7680 :                                  matchingName(s,&quot;qabs&quot;) || matchingName(s,&quot;zabs&quot;) || matchingName(s,&quot;cdabs&quot;) || matchingName(s,&quot;cqabs&quot;);</span></a>
<a name="3435"><span class="lineNum">    3435 </span>            : </a>
<a name="3436"><span class="lineNum">    3436 </span>            : /* Alternative names for int:</a>
<a name="3437"><span class="lineNum">    3437 </span>            : AINT</a>
<a name="3438"><span class="lineNum">    3438 </span>            : DINT</a>
<a name="3439"><span class="lineNum">    3439 </span>            : QINT (sun)</a>
<a name="3440"><span class="lineNum">    3440 </span>            : */</a>
<a name="3441"><span class="lineNum">    3441 </span><span class="lineCov">       4122 :      bool isAlternativeName_int = matchingName(s,&quot;aint&quot;) || matchingName(s,&quot;dint&quot;) || matchingName(s,&quot;qint&quot;);</span></a>
<a name="3442"><span class="lineNum">    3442 </span>            : </a>
<a name="3443"><span class="lineNum">    3443 </span>            : /* Alternative names for int (nearest whole number):</a>
<a name="3444"><span class="lineNum">    3444 </span>            : ANINT</a>
<a name="3445"><span class="lineNum">    3445 </span>            : DNINT</a>
<a name="3446"><span class="lineNum">    3446 </span>            : QNINT</a>
<a name="3447"><span class="lineNum">    3447 </span>            : </a>
<a name="3448"><span class="lineNum">    3448 </span>            : // Alternative names for int (nearest integer):</a>
<a name="3449"><span class="lineNum">    3449 </span>            : NINT</a>
<a name="3450"><span class="lineNum">    3450 </span>            : IDNINT</a>
<a name="3451"><span class="lineNum">    3451 </span>            : IQNINT (sun)</a>
<a name="3452"><span class="lineNum">    3452 </span>            : */</a>
<a name="3453"><span class="lineNum">    3453 </span><span class="lineCov">       7002 :      bool isAlternativeName_nint = matchingName(s,&quot;anint&quot;) || matchingName(s,&quot;dnint&quot;) || matchingName(s,&quot;qnint&quot;) || matchingName(s,&quot;idnint&quot;) || matchingName(s,&quot;iqnint&quot;);</span></a>
<a name="3454"><span class="lineNum">    3454 </span>            : </a>
<a name="3455"><span class="lineNum">    3455 </span>            : /* Alternative names for mod:</a>
<a name="3456"><span class="lineNum">    3456 </span>            : MOD</a>
<a name="3457"><span class="lineNum">    3457 </span>            : AMOD</a>
<a name="3458"><span class="lineNum">    3458 </span>            : DMOD</a>
<a name="3459"><span class="lineNum">    3459 </span>            : QMOD (sun)</a>
<a name="3460"><span class="lineNum">    3460 </span>            : */</a>
<a name="3461"><span class="lineNum">    3461 </span><span class="lineCov">       4122 :      bool isAlternativeName_mod = matchingName(s,&quot;amod&quot;) || matchingName(s,&quot;dmod&quot;) || matchingName(s,&quot;qmod&quot;);</span></a>
<a name="3462"><span class="lineNum">    3462 </span>            : </a>
<a name="3463"><span class="lineNum">    3463 </span>            : /* Alternative names for sign:</a>
<a name="3464"><span class="lineNum">    3464 </span>            : ISIGN</a>
<a name="3465"><span class="lineNum">    3465 </span>            : SIGN</a>
<a name="3466"><span class="lineNum">    3466 </span>            : DSIGN</a>
<a name="3467"><span class="lineNum">    3467 </span>            : QSIGN (sun)</a>
<a name="3468"><span class="lineNum">    3468 </span>            : */</a>
<a name="3469"><span class="lineNum">    3469 </span><span class="lineCov">       4122 :      bool isAlternativeName_sign = matchingName(s,&quot;isign&quot;) || matchingName(s,&quot;dsign&quot;) || matchingName(s,&quot;qsign&quot;);</span></a>
<a name="3470"><span class="lineNum">    3470 </span>            : </a>
<a name="3471"><span class="lineNum">    3471 </span>            : /* Alternative names for dim:</a>
<a name="3472"><span class="lineNum">    3472 </span>            : IDIM</a>
<a name="3473"><span class="lineNum">    3473 </span>            : DIM</a>
<a name="3474"><span class="lineNum">    3474 </span>            : DDIM</a>
<a name="3475"><span class="lineNum">    3475 </span>            : QDIM (sun)</a>
<a name="3476"><span class="lineNum">    3476 </span>            : */</a>
<a name="3477"><span class="lineNum">    3477 </span><span class="lineCov">       4122 :      bool isAlternativeName_dim = matchingName(s,&quot;idim&quot;) || matchingName(s,&quot;ddim&quot;) || matchingName(s,&quot;qdim&quot;);</span></a>
<a name="3478"><span class="lineNum">    3478 </span>            : </a>
<a name="3479"><span class="lineNum">    3479 </span>            : /* Alternative names for * (product):</a>
<a name="3480"><span class="lineNum">    3480 </span>            : DPROD</a>
<a name="3481"><span class="lineNum">    3481 </span>            : QPROD (sun)</a>
<a name="3482"><span class="lineNum">    3482 </span>            : */</a>
<a name="3483"><span class="lineNum">    3483 </span><span class="lineCov">       2682 :      bool isAlternativeName_prod = matchingName(s,&quot;dprod&quot;) || matchingName(s,&quot;qprod&quot;);</span></a>
<a name="3484"><span class="lineNum">    3484 </span>            : </a>
<a name="3485"><span class="lineNum">    3485 </span>            : /* Alternative names for max:</a>
<a name="3486"><span class="lineNum">    3486 </span>            : MAX0</a>
<a name="3487"><span class="lineNum">    3487 </span>            : AMAX1</a>
<a name="3488"><span class="lineNum">    3488 </span>            : DMAX1</a>
<a name="3489"><span class="lineNum">    3489 </span>            : QMAX1 (sun)</a>
<a name="3490"><span class="lineNum">    3490 </span>            : AMAX0</a>
<a name="3491"><span class="lineNum">    3491 </span>            : MAX1</a>
<a name="3492"><span class="lineNum">    3492 </span>            : */</a>
<a name="3493"><span class="lineNum">    3493 </span><span class="lineCov">       8442 :      bool isAlternativeName_max = matchingName(s,&quot;max0&quot;) || matchingName(s,&quot;amax0&quot;) || matchingName(s,&quot;max1&quot;) || matchingName(s,&quot;amax1&quot;) || matchingName(s,&quot;dmax1&quot;) || matchingName(s,&quot;qmax1&quot;);</span></a>
<a name="3494"><span class="lineNum">    3494 </span>            : </a>
<a name="3495"><span class="lineNum">    3495 </span>            : /* Alternative names for min:</a>
<a name="3496"><span class="lineNum">    3496 </span>            : MIN0</a>
<a name="3497"><span class="lineNum">    3497 </span>            : AMIN1</a>
<a name="3498"><span class="lineNum">    3498 </span>            : DMIN1</a>
<a name="3499"><span class="lineNum">    3499 </span>            : QMIN1 (sun)</a>
<a name="3500"><span class="lineNum">    3500 </span>            : AMIN0</a>
<a name="3501"><span class="lineNum">    3501 </span>            : MIN1</a>
<a name="3502"><span class="lineNum">    3502 </span>            : */</a>
<a name="3503"><span class="lineNum">    3503 </span><span class="lineCov">       8442 :      bool isAlternativeName_min = matchingName(s,&quot;min0&quot;) || matchingName(s,&quot;amin0&quot;) || matchingName(s,&quot;min1&quot;) || matchingName(s,&quot;amin1&quot;) || matchingName(s,&quot;dmin1&quot;) || matchingName(s,&quot;qmin1&quot;);</span></a>
<a name="3504"><span class="lineNum">    3504 </span>            : </a>
<a name="3505"><span class="lineNum">    3505 </span>            : /* Alternative names for int (conversion):</a>
<a name="3506"><span class="lineNum">    3506 </span>            : INT</a>
<a name="3507"><span class="lineNum">    3507 </span>            : IFIX</a>
<a name="3508"><span class="lineNum">    3508 </span>            : IDINT</a>
<a name="3509"><span class="lineNum">    3509 </span>            : IQINT (sun)</a>
<a name="3510"><span class="lineNum">    3510 </span>            : */</a>
<a name="3511"><span class="lineNum">    3511 </span><span class="lineCov">       4122 :      bool isAlternativeName_conversion_int = matchingName(s,&quot;ifix&quot;) || matchingName(s,&quot;idint&quot;) || matchingName(s,&quot;iqint&quot;);</span></a>
<a name="3512"><span class="lineNum">    3512 </span>            : </a>
<a name="3513"><span class="lineNum">    3513 </span>            : /* Alternative names for real (conversion):</a>
<a name="3514"><span class="lineNum">    3514 </span>            : REAL</a>
<a name="3515"><span class="lineNum">    3515 </span>            : FLOAT</a>
<a name="3516"><span class="lineNum">    3516 </span>            : SNGL</a>
<a name="3517"><span class="lineNum">    3517 </span>            : SNGLQ (sun)</a>
<a name="3518"><span class="lineNum">    3518 </span>            : FLOATK</a>
<a name="3519"><span class="lineNum">    3519 </span>            : */</a>
<a name="3520"><span class="lineNum">    3520 </span><span class="lineCov">       5562 :      bool isAlternativeName_conversion_real = matchingName(s,&quot;float&quot;) || matchingName(s,&quot;sngl&quot;) || matchingName(s,&quot;snglq&quot;) || matchingName(s,&quot;floatk&quot;);</span></a>
<a name="3521"><span class="lineNum">    3521 </span>            : </a>
<a name="3522"><span class="lineNum">    3522 </span>            : /* Alternative names for double (conversion):</a>
<a name="3523"><span class="lineNum">    3523 </span>            : DBLE</a>
<a name="3524"><span class="lineNum">    3524 </span>            : DFLOAT</a>
<a name="3525"><span class="lineNum">    3525 </span>            : DFLOATK</a>
<a name="3526"><span class="lineNum">    3526 </span>            : DREAL (sun)</a>
<a name="3527"><span class="lineNum">    3527 </span>            : DBLEQ (sun)</a>
<a name="3528"><span class="lineNum">    3528 </span>            : */</a>
<a name="3529"><span class="lineNum">    3529 </span><span class="lineCov">       7002 :      bool isAlternativeName_conversion_double = matchingName(s,&quot;dble&quot;) || matchingName(s,&quot;dfloat&quot;) || matchingName(s,&quot;dfloatk&quot;) || matchingName(s,&quot;dreal&quot;) || matchingName(s,&quot;dbleq&quot;);</span></a>
<a name="3530"><span class="lineNum">    3530 </span>            : </a>
<a name="3531"><span class="lineNum">    3531 </span>            : /* Alternative names for real*16:</a>
<a name="3532"><span class="lineNum">    3532 </span>            : QREAL (sun)</a>
<a name="3533"><span class="lineNum">    3533 </span>            : QFLOAT (sun)</a>
<a name="3534"><span class="lineNum">    3534 </span>            : QEXT (sun)</a>
<a name="3535"><span class="lineNum">    3535 </span>            : QEXTD (sun)</a>
<a name="3536"><span class="lineNum">    3536 </span>            : */</a>
<a name="3537"><span class="lineNum">    3537 </span><span class="lineCov">       5562 :      bool isAlternativeName_conversion_real_16 = matchingName(s,&quot;qreal&quot;) || matchingName(s,&quot;qfloat&quot;) || matchingName(s,&quot;qext&quot;) || matchingName(s,&quot;qextd&quot;);</span></a>
<a name="3538"><span class="lineNum">    3538 </span>            : </a>
<a name="3539"><span class="lineNum">    3539 </span>            : /* Alternative names for cmplx (conversion) (CMPLX is only name used)</a>
<a name="3540"><span class="lineNum">    3540 </span>            : CMPLX</a>
<a name="3541"><span class="lineNum">    3541 </span>            : DCMPLX (sun)</a>
<a name="3542"><span class="lineNum">    3542 </span>            : QCMPLX (sun)</a>
<a name="3543"><span class="lineNum">    3543 </span>            : */</a>
<a name="3544"><span class="lineNum">    3544 </span><span class="lineCov">       2682 :      bool isAlternativeName_conversion_cmplx = matchingName(s,&quot;dcmplx&quot;) || matchingName(s,&quot;qcmplx&quot;);</span></a>
<a name="3545"><span class="lineNum">    3545 </span>            : </a>
<a name="3546"><span class="lineNum">    3546 </span>            : /* Alternative names for sin:</a>
<a name="3547"><span class="lineNum">    3547 </span>            : SIN</a>
<a name="3548"><span class="lineNum">    3548 </span>            : DSIN</a>
<a name="3549"><span class="lineNum">    3549 </span>            : QSIN (sun)</a>
<a name="3550"><span class="lineNum">    3550 </span>            : CSIN</a>
<a name="3551"><span class="lineNum">    3551 </span>            : ZSIN (sun)</a>
<a name="3552"><span class="lineNum">    3552 </span>            : CDSIN (sun)</a>
<a name="3553"><span class="lineNum">    3553 </span>            : CQSIN (sun)</a>
<a name="3554"><span class="lineNum">    3554 </span>            : */</a>
<a name="3555"><span class="lineNum">    3555 </span><span class="lineCov">       8442 :      bool isAlternativeName_sin = matchingName(s,&quot;dsin&quot;) || matchingName(s,&quot;qsin&quot;) || matchingName(s,&quot;csin&quot;) || matchingName(s,&quot;zsin&quot;) || matchingName(s,&quot;cdsin&quot;) || matchingName(s,&quot;cqsin&quot;);</span></a>
<a name="3556"><span class="lineNum">    3556 </span>            : </a>
<a name="3557"><span class="lineNum">    3557 </span>            : /* Alternative names for sind (sun):</a>
<a name="3558"><span class="lineNum">    3558 </span>            : SIND (sun)</a>
<a name="3559"><span class="lineNum">    3559 </span>            : DSIND (sun)</a>
<a name="3560"><span class="lineNum">    3560 </span>            : QSIND (sun)</a>
<a name="3561"><span class="lineNum">    3561 </span>            : */</a>
<a name="3562"><span class="lineNum">    3562 </span><span class="lineCov">       2682 :      bool isAlternativeName_sind = matchingName(s,&quot;dsind&quot;) || matchingName(s,&quot;qsind&quot;);</span></a>
<a name="3563"><span class="lineNum">    3563 </span>            : </a>
<a name="3564"><span class="lineNum">    3564 </span>            : /* Alternative names for cos:</a>
<a name="3565"><span class="lineNum">    3565 </span>            : COS</a>
<a name="3566"><span class="lineNum">    3566 </span>            : DCOS</a>
<a name="3567"><span class="lineNum">    3567 </span>            : QCOS (sun)</a>
<a name="3568"><span class="lineNum">    3568 </span>            : CCOS</a>
<a name="3569"><span class="lineNum">    3569 </span>            : ZCOS (sun)</a>
<a name="3570"><span class="lineNum">    3570 </span>            : CDCOS (sun)</a>
<a name="3571"><span class="lineNum">    3571 </span>            : CQCOS (sun) </a>
<a name="3572"><span class="lineNum">    3572 </span>            : */</a>
<a name="3573"><span class="lineNum">    3573 </span><span class="lineCov">       8442 :      bool isAlternativeName_cos = matchingName(s,&quot;dcos&quot;) || matchingName(s,&quot;qcos&quot;) || matchingName(s,&quot;ccos&quot;) || matchingName(s,&quot;zcos&quot;) || matchingName(s,&quot;cdcos&quot;) || matchingName(s,&quot;cqcos&quot;);</span></a>
<a name="3574"><span class="lineNum">    3574 </span>            : </a>
<a name="3575"><span class="lineNum">    3575 </span>            : /* Alternative names for cosd (sun):</a>
<a name="3576"><span class="lineNum">    3576 </span>            : COSD (sun)</a>
<a name="3577"><span class="lineNum">    3577 </span>            : DCOSD (sun)</a>
<a name="3578"><span class="lineNum">    3578 </span>            : QCOSD (sun)</a>
<a name="3579"><span class="lineNum">    3579 </span>            : */</a>
<a name="3580"><span class="lineNum">    3580 </span><span class="lineCov">       2682 :      bool isAlternativeName_cosd = matchingName(s,&quot;dcosd&quot;) || matchingName(s,&quot;qcosd&quot;);</span></a>
<a name="3581"><span class="lineNum">    3581 </span>            : </a>
<a name="3582"><span class="lineNum">    3582 </span>            : /* Alternative names for tan:</a>
<a name="3583"><span class="lineNum">    3583 </span>            : TAN</a>
<a name="3584"><span class="lineNum">    3584 </span>            : DTAN</a>
<a name="3585"><span class="lineNum">    3585 </span>            : QTAN (sin) </a>
<a name="3586"><span class="lineNum">    3586 </span>            : */</a>
<a name="3587"><span class="lineNum">    3587 </span><span class="lineCov">       2682 :      bool isAlternativeName_tan = matchingName(s,&quot;dtan&quot;) || matchingName(s,&quot;qtan&quot;);</span></a>
<a name="3588"><span class="lineNum">    3588 </span>            : </a>
<a name="3589"><span class="lineNum">    3589 </span>            : /* Alternative names for tand (sun):</a>
<a name="3590"><span class="lineNum">    3590 </span>            : TAND (sun)</a>
<a name="3591"><span class="lineNum">    3591 </span>            : DTAND (sun)</a>
<a name="3592"><span class="lineNum">    3592 </span>            : QTAND (sun)</a>
<a name="3593"><span class="lineNum">    3593 </span>            : */</a>
<a name="3594"><span class="lineNum">    3594 </span><span class="lineCov">       2682 :      bool isAlternativeName_tand = matchingName(s,&quot;dtand&quot;) || matchingName(s,&quot;qtand&quot;);</span></a>
<a name="3595"><span class="lineNum">    3595 </span>            : </a>
<a name="3596"><span class="lineNum">    3596 </span>            : /* Alternative names for asin:</a>
<a name="3597"><span class="lineNum">    3597 </span>            : ASIN</a>
<a name="3598"><span class="lineNum">    3598 </span>            : DASIN</a>
<a name="3599"><span class="lineNum">    3599 </span>            : QASIN (sun)</a>
<a name="3600"><span class="lineNum">    3600 </span>            : </a>
<a name="3601"><span class="lineNum">    3601 </span>            : // Alternative names for asind (sun):</a>
<a name="3602"><span class="lineNum">    3602 </span>            : ASIND (sun)</a>
<a name="3603"><span class="lineNum">    3603 </span>            : DASIND (sun)</a>
<a name="3604"><span class="lineNum">    3604 </span>            : QASIND (sun)</a>
<a name="3605"><span class="lineNum">    3605 </span>            : */</a>
<a name="3606"><span class="lineNum">    3606 </span><span class="lineCov">       7002 :      bool isAlternativeName_asin = matchingName(s,&quot;dasin&quot;) || matchingName(s,&quot;qasin&quot;) || matchingName(s,&quot;asind&quot;) || matchingName(s,&quot;dasind&quot;) || matchingName(s,&quot;qasind&quot;);</span></a>
<a name="3607"><span class="lineNum">    3607 </span>            : </a>
<a name="3608"><span class="lineNum">    3608 </span>            : /* Alternative names for acos:</a>
<a name="3609"><span class="lineNum">    3609 </span>            : ACOS</a>
<a name="3610"><span class="lineNum">    3610 </span>            : DACOS</a>
<a name="3611"><span class="lineNum">    3611 </span>            : QACOS (sun)</a>
<a name="3612"><span class="lineNum">    3612 </span>            : </a>
<a name="3613"><span class="lineNum">    3613 </span>            : // Alternative names for acosd (sun):</a>
<a name="3614"><span class="lineNum">    3614 </span>            : ACOSD (sun)</a>
<a name="3615"><span class="lineNum">    3615 </span>            : DACOSD (sun)</a>
<a name="3616"><span class="lineNum">    3616 </span>            : QACOSD (sun)</a>
<a name="3617"><span class="lineNum">    3617 </span>            : */</a>
<a name="3618"><span class="lineNum">    3618 </span><span class="lineCov">       7002 :      bool isAlternativeName_acos = matchingName(s,&quot;dacos&quot;) || matchingName(s,&quot;qacos&quot;) || matchingName(s,&quot;acosd&quot;) || matchingName(s,&quot;dacosd&quot;) || matchingName(s,&quot;qacosd&quot;);</span></a>
<a name="3619"><span class="lineNum">    3619 </span>            : </a>
<a name="3620"><span class="lineNum">    3620 </span>            : /* Alternative names for atan:</a>
<a name="3621"><span class="lineNum">    3621 </span>            : ATAN</a>
<a name="3622"><span class="lineNum">    3622 </span>            : DATAN</a>
<a name="3623"><span class="lineNum">    3623 </span>            : QATAN (sun)</a>
<a name="3624"><span class="lineNum">    3624 </span>            : </a>
<a name="3625"><span class="lineNum">    3625 </span>            : // Alternative names for atand (sun):</a>
<a name="3626"><span class="lineNum">    3626 </span>            : ATAND (sun)</a>
<a name="3627"><span class="lineNum">    3627 </span>            : DATAND (sun)</a>
<a name="3628"><span class="lineNum">    3628 </span>            : QATAND (sun)</a>
<a name="3629"><span class="lineNum">    3629 </span>            : */</a>
<a name="3630"><span class="lineNum">    3630 </span><span class="lineCov">       7002 :      bool isAlternativeName_atan = matchingName(s,&quot;datan&quot;) || matchingName(s,&quot;qatan&quot;) || matchingName(s,&quot;atand&quot;) || matchingName(s,&quot;datand&quot;) || matchingName(s,&quot;qatand&quot;);</span></a>
<a name="3631"><span class="lineNum">    3631 </span>            : </a>
<a name="3632"><span class="lineNum">    3632 </span>            : /* Alternative names for atan2:</a>
<a name="3633"><span class="lineNum">    3633 </span>            : ATAN2</a>
<a name="3634"><span class="lineNum">    3634 </span>            : DATAN2</a>
<a name="3635"><span class="lineNum">    3635 </span>            : QATAN2 (sun)</a>
<a name="3636"><span class="lineNum">    3636 </span>            : </a>
<a name="3637"><span class="lineNum">    3637 </span>            : // Alternative names for atan2d (sun):</a>
<a name="3638"><span class="lineNum">    3638 </span>            : ATAN2D (sun)</a>
<a name="3639"><span class="lineNum">    3639 </span>            : DATAN2D (sun)</a>
<a name="3640"><span class="lineNum">    3640 </span>            : QATAN2D (sun)</a>
<a name="3641"><span class="lineNum">    3641 </span>            : */</a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineCov">       7002 :      bool isAlternativeName_atan2 = matchingName(s,&quot;datan2&quot;) || matchingName(s,&quot;qatan2&quot;) || matchingName(s,&quot;atan2d&quot;) || matchingName(s,&quot;datan2d&quot;) || matchingName(s,&quot;qatan2d&quot;);</span></a>
<a name="3643"><span class="lineNum">    3643 </span>            : </a>
<a name="3644"><span class="lineNum">    3644 </span>            : /* Alternative names for sinh (sun):</a>
<a name="3645"><span class="lineNum">    3645 </span>            : SINH (sun)</a>
<a name="3646"><span class="lineNum">    3646 </span>            : DSINH (sun)</a>
<a name="3647"><span class="lineNum">    3647 </span>            : QSINH (sun)</a>
<a name="3648"><span class="lineNum">    3648 </span>            : */</a>
<a name="3649"><span class="lineNum">    3649 </span><span class="lineCov">       2682 :      bool isAlternativeName_sinh = matchingName(s,&quot;dsinh&quot;) || matchingName(s,&quot;qsinh&quot;);</span></a>
<a name="3650"><span class="lineNum">    3650 </span>            : </a>
<a name="3651"><span class="lineNum">    3651 </span>            : /* Alternative names for cosh (sun):</a>
<a name="3652"><span class="lineNum">    3652 </span>            : COSH (sun)</a>
<a name="3653"><span class="lineNum">    3653 </span>            : DCOSH (sun)</a>
<a name="3654"><span class="lineNum">    3654 </span>            : QCOSH (sun)</a>
<a name="3655"><span class="lineNum">    3655 </span>            : */</a>
<a name="3656"><span class="lineNum">    3656 </span><span class="lineCov">       2682 :      bool isAlternativeName_cosh = matchingName(s,&quot;dcosh&quot;) || matchingName(s,&quot;qcosh&quot;);</span></a>
<a name="3657"><span class="lineNum">    3657 </span>            : </a>
<a name="3658"><span class="lineNum">    3658 </span>            : /* Alternative names for tanh (sun):</a>
<a name="3659"><span class="lineNum">    3659 </span>            : TANH (sun)</a>
<a name="3660"><span class="lineNum">    3660 </span>            : DTANH (sun)</a>
<a name="3661"><span class="lineNum">    3661 </span>            : QTANH (sun)</a>
<a name="3662"><span class="lineNum">    3662 </span>            : */</a>
<a name="3663"><span class="lineNum">    3663 </span><span class="lineCov">       2682 :      bool isAlternativeName_tanh = matchingName(s,&quot;dtanh&quot;) || matchingName(s,&quot;qtanh&quot;);</span></a>
<a name="3664"><span class="lineNum">    3664 </span>            : </a>
<a name="3665"><span class="lineNum">    3665 </span>            : /* Alternative names for imag:</a>
<a name="3666"><span class="lineNum">    3666 </span>            : AIMAG</a>
<a name="3667"><span class="lineNum">    3667 </span>            : DIMAG (sun)</a>
<a name="3668"><span class="lineNum">    3668 </span>            : QIMAG (sun)</a>
<a name="3669"><span class="lineNum">    3669 </span>            : */</a>
<a name="3670"><span class="lineNum">    3670 </span>            :   // AIMAG is part of the F77 standard listed above</a>
<a name="3671"><span class="lineNum">    3671 </span><span class="lineCov">       2682 :      bool isAlternativeName_imag = matchingName(s,&quot;dimag&quot;) || matchingName(s,&quot;qimag&quot;);</span></a>
<a name="3672"><span class="lineNum">    3672 </span>            : </a>
<a name="3673"><span class="lineNum">    3673 </span>            : /* Alternative names for conjg:</a>
<a name="3674"><span class="lineNum">    3674 </span>            : CONJG</a>
<a name="3675"><span class="lineNum">    3675 </span>            : DCONJG (sun)</a>
<a name="3676"><span class="lineNum">    3676 </span>            : QCONJG (sun)</a>
<a name="3677"><span class="lineNum">    3677 </span>            : */</a>
<a name="3678"><span class="lineNum">    3678 </span>            :   // conjg is part of the F77 standard listed above</a>
<a name="3679"><span class="lineNum">    3679 </span><span class="lineCov">       2682 :      bool isAlternativeName_conjg = matchingName(s,&quot;dconjg&quot;) || matchingName(s,&quot;qconjg&quot;);</span></a>
<a name="3680"><span class="lineNum">    3680 </span>            : </a>
<a name="3681"><span class="lineNum">    3681 </span>            : /* Alternative names for sqrt:</a>
<a name="3682"><span class="lineNum">    3682 </span>            : SQRT</a>
<a name="3683"><span class="lineNum">    3683 </span>            : DSQRT</a>
<a name="3684"><span class="lineNum">    3684 </span>            : QSQRT (sun)</a>
<a name="3685"><span class="lineNum">    3685 </span>            : CSQRT</a>
<a name="3686"><span class="lineNum">    3686 </span>            : ZSQRT (sun)</a>
<a name="3687"><span class="lineNum">    3687 </span>            : CDSQRT (sun)</a>
<a name="3688"><span class="lineNum">    3688 </span>            : CQSQRT (sun)</a>
<a name="3689"><span class="lineNum">    3689 </span>            : */</a>
<a name="3690"><span class="lineNum">    3690 </span><span class="lineCov">       8442 :      bool isAlternativeName_sqrt = matchingName(s,&quot;dsqrt&quot;) || matchingName(s,&quot;qsqrt&quot;) || matchingName(s,&quot;csqrt&quot;) || matchingName(s,&quot;zsqrt&quot;) || matchingName(s,&quot;cdsqrt&quot;) || matchingName(s,&quot;cqsqrt&quot;);</span></a>
<a name="3691"><span class="lineNum">    3691 </span>            : </a>
<a name="3692"><span class="lineNum">    3692 </span>            : /* Alternative names for cbrt (sun):</a>
<a name="3693"><span class="lineNum">    3693 </span>            : CBRT (sun)</a>
<a name="3694"><span class="lineNum">    3694 </span>            : DCBRT (sun)</a>
<a name="3695"><span class="lineNum">    3695 </span>            : QCBRT (sun)</a>
<a name="3696"><span class="lineNum">    3696 </span>            : CCBRT (sun)</a>
<a name="3697"><span class="lineNum">    3697 </span>            : ZCBRT (sun)</a>
<a name="3698"><span class="lineNum">    3698 </span>            : CDCBRT (sun)</a>
<a name="3699"><span class="lineNum">    3699 </span>            : CQCBRT (sun)</a>
<a name="3700"><span class="lineNum">    3700 </span>            : */</a>
<a name="3701"><span class="lineNum">    3701 </span><span class="lineCov">       9882 :      bool isAlternativeName_cbrt = matchingName(s,&quot;cbrt&quot;) || matchingName(s,&quot;dcbrt&quot;) || matchingName(s,&quot;qcbrt&quot;) || matchingName(s,&quot;ccbrt&quot;) || matchingName(s,&quot;zcbrt&quot;) || matchingName(s,&quot;cdcbrt&quot;) || matchingName(s,&quot;cqcbrt&quot;);</span></a>
<a name="3702"><span class="lineNum">    3702 </span>            : </a>
<a name="3703"><span class="lineNum">    3703 </span>            : /* Alternative names for exp:</a>
<a name="3704"><span class="lineNum">    3704 </span>            : EXP</a>
<a name="3705"><span class="lineNum">    3705 </span>            : DEXP</a>
<a name="3706"><span class="lineNum">    3706 </span>            : QEXP (sun)</a>
<a name="3707"><span class="lineNum">    3707 </span>            : CEXP</a>
<a name="3708"><span class="lineNum">    3708 </span>            : ZEXP (sun)</a>
<a name="3709"><span class="lineNum">    3709 </span>            : CDEXP (sun)</a>
<a name="3710"><span class="lineNum">    3710 </span>            : CQEXP (sun) </a>
<a name="3711"><span class="lineNum">    3711 </span>            : */</a>
<a name="3712"><span class="lineNum">    3712 </span><span class="lineCov">       8442 :      bool isAlternativeName_exp = matchingName(s,&quot;dexp&quot;) || matchingName(s,&quot;qexp&quot;) || matchingName(s,&quot;cexp&quot;) || matchingName(s,&quot;zexp&quot;) || matchingName(s,&quot;cdexp&quot;) || matchingName(s,&quot;cqexp&quot;);</span></a>
<a name="3713"><span class="lineNum">    3713 </span>            : </a>
<a name="3714"><span class="lineNum">    3714 </span>            : /* Alternative names for log:</a>
<a name="3715"><span class="lineNum">    3715 </span>            : ALOG</a>
<a name="3716"><span class="lineNum">    3716 </span>            : DLOG</a>
<a name="3717"><span class="lineNum">    3717 </span>            : QLOG (sun)</a>
<a name="3718"><span class="lineNum">    3718 </span>            : CLOG</a>
<a name="3719"><span class="lineNum">    3719 </span>            : ZLOG (sun)</a>
<a name="3720"><span class="lineNum">    3720 </span>            : CDLOG (sun)</a>
<a name="3721"><span class="lineNum">    3721 </span>            : CQLOG (sun)</a>
<a name="3722"><span class="lineNum">    3722 </span>            : */</a>
<a name="3723"><span class="lineNum">    3723 </span>            : </a>
<a name="3724"><span class="lineNum">    3724 </span><span class="lineCov">       9882 :      bool isAlternativeName_log = matchingName(s,&quot;alog&quot;) || matchingName(s,&quot;dlog&quot;) || matchingName(s,&quot;qlog&quot;) || matchingName(s,&quot;clog&quot;) || matchingName(s,&quot;zlog&quot;) || matchingName(s,&quot;cdlog&quot;) || matchingName(s,&quot;cqlog&quot;);</span></a>
<a name="3725"><span class="lineNum">    3725 </span>            : </a>
<a name="3726"><span class="lineNum">    3726 </span>            : /* Alternative names for log10:</a>
<a name="3727"><span class="lineNum">    3727 </span>            : ALOG10</a>
<a name="3728"><span class="lineNum">    3728 </span>            : DLOG10</a>
<a name="3729"><span class="lineNum">    3729 </span>            : QLOG10 (sun)</a>
<a name="3730"><span class="lineNum">    3730 </span>            : */</a>
<a name="3731"><span class="lineNum">    3731 </span><span class="lineCov">       4122 :      bool isAlternativeName_log10 = matchingName(s,&quot;alog10&quot;) || matchingName(s,&quot;dlog10&quot;) || matchingName(s,&quot;qlog10&quot;);</span></a>
<a name="3732"><span class="lineNum">    3732 </span>            : </a>
<a name="3733"><span class="lineNum">    3733 </span>            : /* Alternative names for erf:</a>
<a name="3734"><span class="lineNum">    3734 </span>            : ERF (sun)</a>
<a name="3735"><span class="lineNum">    3735 </span>            : DERF (sun)</a>
<a name="3736"><span class="lineNum">    3736 </span>            : */</a>
<a name="3737"><span class="lineNum">    3737 </span><span class="lineCov">       2682 :      bool isAlternativeName_erf = matchingName(s,&quot;erf&quot;) || matchingName(s,&quot;derf&quot;);</span></a>
<a name="3738"><span class="lineNum">    3738 </span>            : </a>
<a name="3739"><span class="lineNum">    3739 </span>            : /* Alternative names for erfc:</a>
<a name="3740"><span class="lineNum">    3740 </span>            : ERFC (sun)</a>
<a name="3741"><span class="lineNum">    3741 </span>            : DERFC (sun)</a>
<a name="3742"><span class="lineNum">    3742 </span>            : */</a>
<a name="3743"><span class="lineNum">    3743 </span><span class="lineCov">       2682 :      bool isAlternativeName_erfc = matchingName(s,&quot;erfc&quot;) || matchingName(s,&quot;derfc&quot;);</span></a>
<a name="3744"><span class="lineNum">    3744 </span>            : </a>
<a name="3745"><span class="lineNum">    3745 </span>            : /* Additional intrinsic environmental functions (non-standard):</a>
<a name="3746"><span class="lineNum">    3746 </span>            : EPBASE</a>
<a name="3747"><span class="lineNum">    3747 </span>            : EPPREC</a>
<a name="3748"><span class="lineNum">    3748 </span>            : EPEMIN</a>
<a name="3749"><span class="lineNum">    3749 </span>            : EPEMAX</a>
<a name="3750"><span class="lineNum">    3750 </span>            : EPTINY</a>
<a name="3751"><span class="lineNum">    3751 </span>            : EPHUGE</a>
<a name="3752"><span class="lineNum">    3752 </span>            : EPMRSP</a>
<a name="3753"><span class="lineNum">    3753 </span>            : */</a>
<a name="3754"><span class="lineNum">    3754 </span>            : </a>
<a name="3755"><span class="lineNum">    3755 </span><span class="lineCov">       9882 :      bool environment_functions = matchingName(s,&quot;epbase&quot;) || matchingName(s,&quot;epprec&quot;) || matchingName(s,&quot;epemin&quot;) || matchingName(s,&quot;epemax&quot;) || matchingName(s,&quot;eptiny&quot;) || matchingName(s,&quot;ephuge&quot;) || matchingName(s,&quot;epmrsp&quot;);</span></a>
<a name="3756"><span class="lineNum">    3756 </span>            : </a>
<a name="3757"><span class="lineNum">    3757 </span>            : /* Memory functions</a>
<a name="3758"><span class="lineNum">    3758 </span>            : LOC</a>
<a name="3759"><span class="lineNum">    3759 </span>            : MALLOC</a>
<a name="3760"><span class="lineNum">    3760 </span>            : MALLOC64</a>
<a name="3761"><span class="lineNum">    3761 </span>            : FREE</a>
<a name="3762"><span class="lineNum">    3762 </span>            : SIZEOF</a>
<a name="3763"><span class="lineNum">    3763 </span>            : */</a>
<a name="3764"><span class="lineNum">    3764 </span>            : </a>
<a name="3765"><span class="lineNum">    3765 </span><span class="lineCov">       7002 :      bool memory_functions = matchingName(s,&quot;loc&quot;) || matchingName(s,&quot;malloc&quot;) || matchingName(s,&quot;malloc64&quot;) || matchingName(s,&quot;free&quot;) || matchingName(s,&quot;sizeof&quot;);</span></a>
<a name="3766"><span class="lineNum">    3766 </span>            : </a>
<a name="3767"><span class="lineNum">    3767 </span>            : /* Bit functions:</a>
<a name="3768"><span class="lineNum">    3768 </span>            : </a>
<a name="3769"><span class="lineNum">    3769 </span>            : // As defined above:</a>
<a name="3770"><span class="lineNum">    3770 </span>            : //   bool isBitElementalFunction = </a>
<a name="3771"><span class="lineNum">    3771 </span>            : //        matchingName(s,&quot;btest&quot;) || matchingName(s,&quot;iand&quot;) || matchingName(s,&quot;ibclr&quot;) || matchingName(s,&quot;ibits&quot;) || matchingName(s,&quot;ibset&quot;) || matchingName(s,&quot;ieor&quot;) ||</a>
<a name="3772"><span class="lineNum">    3772 </span>            : //        matchingName(s,&quot;ior&quot;) || matchingName(s,&quot;ishft&quot;) || matchingName(s,&quot;ishftc&quot;) || matchingName(s,&quot;not&quot;);</a>
<a name="3773"><span class="lineNum">    3773 </span>            : </a>
<a name="3774"><span class="lineNum">    3774 </span>            : AND</a>
<a name="3775"><span class="lineNum">    3775 </span>            : OR</a>
<a name="3776"><span class="lineNum">    3776 </span>            : XOR</a>
<a name="3777"><span class="lineNum">    3777 </span>            : LSHFT</a>
<a name="3778"><span class="lineNum">    3778 </span>            : RSHFT</a>
<a name="3779"><span class="lineNum">    3779 </span>            : LRSHFT</a>
<a name="3780"><span class="lineNum">    3780 </span>            : */</a>
<a name="3781"><span class="lineNum">    3781 </span>            : </a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineCov">       8442 :      bool additional_bit_functions = matchingName(s,&quot;and&quot;) || matchingName(s,&quot;or&quot;) || matchingName(s,&quot;xor&quot;) || matchingName(s,&quot;lshft&quot;) || matchingName(s,&quot;rshft&quot;) || matchingName(s,&quot;lrshft&quot;);</span></a>
<a name="3783"><span class="lineNum">    3783 </span>            : </a>
<a name="3784"><span class="lineNum">    3784 </span>            : </a>
<a name="3785"><span class="lineNum">    3785 </span>            :   // DQ (12/14/2007): These are the non-generic intrinsic function name tests.</a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineCov">        480 :      if ( resultValue || isAlternativeName_abs || isAlternativeName_int || isAlternativeName_nint ||</span></a>
<a name="3787"><span class="lineNum">    3787 </span><span class="lineCov">        480 :           isAlternativeName_mod || isAlternativeName_sign || isAlternativeName_dim || isAlternativeName_prod ||</span></a>
<a name="3788"><span class="lineNum">    3788 </span><span class="lineCov">        480 :           isAlternativeName_max || isAlternativeName_min || isAlternativeName_conversion_int ||</span></a>
<a name="3789"><span class="lineNum">    3789 </span><span class="lineCov">        480 :           isAlternativeName_conversion_real || isAlternativeName_conversion_double || </span></a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineCov">        480 :           isAlternativeName_conversion_real_16 || isAlternativeName_conversion_cmplx ||</span></a>
<a name="3791"><span class="lineNum">    3791 </span><span class="lineCov">        480 :           isAlternativeName_sin || isAlternativeName_sind || isAlternativeName_cos || isAlternativeName_cosd ||</span></a>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineCov">        480 :           isAlternativeName_tan || isAlternativeName_tand || isAlternativeName_asin || isAlternativeName_acos ||</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineCov">        480 :           isAlternativeName_atan || isAlternativeName_atan2 || isAlternativeName_sinh ||  isAlternativeName_cosh ||</span></a>
<a name="3794"><span class="lineNum">    3794 </span><span class="lineCov">        480 :           isAlternativeName_tanh || isAlternativeName_imag || isAlternativeName_conjg || isAlternativeName_sqrt ||</span></a>
<a name="3795"><span class="lineNum">    3795 </span><span class="lineCov">        480 :           isAlternativeName_cbrt || isAlternativeName_exp || isAlternativeName_log || isAlternativeName_log10 ||</span></a>
<a name="3796"><span class="lineNum">    3796 </span><span class="lineCov">        480 :           isAlternativeName_erf || isAlternativeName_erfc || environment_functions || memory_functions ||</span></a>
<a name="3797"><span class="lineNum">    3797 </span>            :           additional_bit_functions)</a>
<a name="3798"><span class="lineNum">    3798 </span>            :         {</a>
<a name="3799"><span class="lineNum">    3799 </span><span class="lineNoCov">          0 :           resultValue = true;</span></a>
<a name="3800"><span class="lineNum">    3800 </span>            :         }</a>
<a name="3801"><span class="lineNum">    3801 </span>            : </a>
<a name="3802"><span class="lineNum">    3802 </span><span class="lineCov">        480 :      return resultValue;</span></a>
<a name="3803"><span class="lineNum">    3803 </span>            :    }</a>
<a name="3804"><span class="lineNum">    3804 </span>            : </a>
<a name="3805"><span class="lineNum">    3805 </span>            : bool</a>
<a name="3806"><span class="lineNum">    3806 </span><span class="lineNoCov">          0 : isIntrinsicFunctionReturningNonmatchingType( string s)</span></a>
<a name="3807"><span class="lineNum">    3807 </span>            :    {</a>
<a name="3808"><span class="lineNum">    3808 </span>            :   // Later we can figure out exactly which intrinsic function return type different from their</a>
<a name="3809"><span class="lineNum">    3809 </span>            :   // input types.  Examples include: sign, modulo (I think).</a>
<a name="3810"><span class="lineNum">    3810 </span><span class="lineNoCov">          0 :      return false;</span></a>
<a name="3811"><span class="lineNum">    3811 </span>            :    }</a>
<a name="3812"><span class="lineNum">    3812 </span>            : </a>
<a name="3813"><span class="lineNum">    3813 </span>            : </a>
<a name="3814"><span class="lineNum">    3814 </span>            : SgType*</a>
<a name="3815"><span class="lineNum">    3815 </span><span class="lineNoCov">          0 : generateIntrinsicFunctionReturnType( string s , SgExprListExp* argumentList )</span></a>
<a name="3816"><span class="lineNum">    3816 </span>            :    {</a>
<a name="3817"><span class="lineNum">    3817 </span>            :   // Maybe this function should break out the subroutines and procedures that </a>
<a name="3818"><span class="lineNum">    3818 </span>            :   // would be associated with a &quot;call&quot; statement.</a>
<a name="3819"><span class="lineNum">    3819 </span>            : </a>
<a name="3820"><span class="lineNum">    3820 </span>            :   // Intrinsic function return types depend on there arguments and also on the</a>
<a name="3821"><span class="lineNum">    3821 </span>            :   // specific intrinsic function.  </a>
<a name="3822"><span class="lineNum">    3822 </span>            : </a>
<a name="3823"><span class="lineNum">    3823 </span><span class="lineNoCov">          0 :      SgType* returnType = NULL;</span></a>
<a name="3824"><span class="lineNum">    3824 </span>            : </a>
<a name="3825"><span class="lineNum">    3825 </span><span class="lineNoCov">          0 :      bool isIntrinsicFunction = matchAgainstIntrinsicFunctionList(s);</span></a>
<a name="3826"><span class="lineNum">    3826 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(isIntrinsicFunction == true);</span></a>
<a name="3827"><span class="lineNum">    3827 </span>            : </a>
<a name="3828"><span class="lineNum">    3828 </span><span class="lineNoCov">          0 :      if (argumentList != NULL)</span></a>
<a name="3829"><span class="lineNum">    3829 </span>            :         {</a>
<a name="3830"><span class="lineNum">    3830 </span>            :        // Use the type of the arguments in the argumentList to figure out what type to return.</a>
<a name="3831"><span class="lineNum">    3831 </span><span class="lineNoCov">          0 :           if (isIntrinsicFunctionReturningNonmatchingType(s) == true)</span></a>
<a name="3832"><span class="lineNum">    3832 </span>            :              {</a>
<a name="3833"><span class="lineNum">    3833 </span>            :             // This may have to be handled on a case by case basis.</a>
<a name="3834"><span class="lineNum">    3834 </span>            : </a>
<a name="3835"><span class="lineNum">    3835 </span>            :             // For now, lets just use the implicit type rules, I will fix this later.</a>
<a name="3836"><span class="lineNum">    3836 </span><span class="lineNoCov">          0 :                returnType = generateImplicitType(s);</span></a>
<a name="3837"><span class="lineNum">    3837 </span>            :              }</a>
<a name="3838"><span class="lineNum">    3838 </span>            :             else</a>
<a name="3839"><span class="lineNum">    3839 </span>            :              {</a>
<a name="3840"><span class="lineNum">    3840 </span>            :             // If we have an expression list, then I assum it is non-empty, but check to make sure.</a>
<a name="3841"><span class="lineNum">    3841 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(argumentList-&gt;get_expressions().empty() == false);</span></a>
<a name="3842"><span class="lineNum">    3842 </span>            : </a>
<a name="3843"><span class="lineNum">    3843 </span>            :             // As I recall all the argument types are the same and the return type of the </a>
<a name="3844"><span class="lineNum">    3844 </span>            :             // implicit function matches the argument type.</a>
<a name="3845"><span class="lineNum">    3845 </span><span class="lineNoCov">          0 :                returnType = argumentList-&gt;get_expressions()[0]-&gt;get_type();</span></a>
<a name="3846"><span class="lineNum">    3846 </span>            :              }</a>
<a name="3847"><span class="lineNum">    3847 </span>            :         }</a>
<a name="3848"><span class="lineNum">    3848 </span>            :        else</a>
<a name="3849"><span class="lineNum">    3849 </span>            :         {</a>
<a name="3850"><span class="lineNum">    3850 </span>            :        // I can't think of anything else to do but compute the type using the implicit type rules.</a>
<a name="3851"><span class="lineNum">    3851 </span>            :        // If the user changes the implicit type rules then this would be incorrect, so we have to </a>
<a name="3852"><span class="lineNum">    3852 </span>            :        // have something better eventually.</a>
<a name="3853"><span class="lineNum">    3853 </span><span class="lineNoCov">          0 :           returnType = generateImplicitType(s);</span></a>
<a name="3854"><span class="lineNum">    3854 </span>            :         }</a>
<a name="3855"><span class="lineNum">    3855 </span>            : </a>
<a name="3856"><span class="lineNum">    3856 </span>            :   // Use the implicit type rules, however that is not likely good enough since </a>
<a name="3857"><span class="lineNum">    3857 </span>            :   // many intrinsic functions have explicitly predefined types.</a>
<a name="3858"><span class="lineNum">    3858 </span>            :   // return generateImplicitType(s);</a>
<a name="3859"><span class="lineNum">    3859 </span>            : </a>
<a name="3860"><span class="lineNum">    3860 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(returnType != NULL);</span></a>
<a name="3861"><span class="lineNum">    3861 </span><span class="lineNoCov">          0 :      return returnType;</span></a>
<a name="3862"><span class="lineNum">    3862 </span>            :    }</a>
<a name="3863"><span class="lineNum">    3863 </span>            : </a>
<a name="3864"><span class="lineNum">    3864 </span>            : SgType* </a>
<a name="3865"><span class="lineNum">    3865 </span><span class="lineCov">        488 : generateImplicitType( string name )</span></a>
<a name="3866"><span class="lineNum">    3866 </span>            :    {</a>
<a name="3867"><span class="lineNum">    3867 </span>            :   // Implement the default implicit type rules.</a>
<a name="3868"><span class="lineNum">    3868 </span>            :   // These will have to be modified to account for user defined implicit type rules later.</a>
<a name="3869"><span class="lineNum">    3869 </span>            : </a>
<a name="3870"><span class="lineNum">    3870 </span>            :   // The DEFAULT implicit typing is based on the first letter of the name Implicit type</a>
<a name="3871"><span class="lineNum">    3871 </span>            :   // A to H     REAL</a>
<a name="3872"><span class="lineNum">    3872 </span>            :   // I to N     INTEGER</a>
<a name="3873"><span class="lineNum">    3873 </span>            :   // O to Z     REAL</a>
<a name="3874"><span class="lineNum">    3874 </span>            : </a>
<a name="3875"><span class="lineNum">    3875 </span><span class="lineCov">        488 :      SgType* returnType = NULL;</span></a>
<a name="3876"><span class="lineNum">    3876 </span>            : </a>
<a name="3877"><span class="lineNum">    3877 </span>            : #if 0</a>
<a name="3878"><span class="lineNum">    3878 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="3879"><span class="lineNum">    3879 </span>            :      outputState(&quot;At TOP of generateImplicitType()&quot;);</a>
<a name="3880"><span class="lineNum">    3880 </span>            : #endif</a>
<a name="3881"><span class="lineNum">    3881 </span>            : </a>
<a name="3882"><span class="lineNum">    3882 </span>            :   // DQ (12/29/2010): Need to search for implicit statement in outer scope (if it exists)</a>
<a name="3883"><span class="lineNum">    3883 </span>            :   //    If it exists, then we need to use that information to associate types.</a>
<a name="3884"><span class="lineNum">    3884 </span>            :   //    We might have to take the union of the implicit statements to get the</a>
<a name="3885"><span class="lineNum">    3885 </span>            :   //    details correct.  This is out outstanding bug in ROSE and show up </a>
<a name="3886"><span class="lineNum">    3886 </span>            :   //    in the latest work reimplementing the R612 and R613 rules.</a>
<a name="3887"><span class="lineNum">    3887 </span>            : </a>
<a name="3888"><span class="lineNum">    3888 </span><span class="lineCov">        488 :      ROSE_ASSERT(tolower(name[0]) &gt;= 'a');</span></a>
<a name="3889"><span class="lineNum">    3889 </span><span class="lineCov">        488 :      ROSE_ASSERT(tolower(name[0]) &lt;= 'z');</span></a>
<a name="3890"><span class="lineNum">    3890 </span>            : </a>
<a name="3891"><span class="lineNum">    3891 </span>            :   // printf (&quot;***** In generateImplicitType(): name = %s name[0] = %c tolower(name[0]) = %c \n&quot;,name.c_str(),name[0],tolower(name[0]));</a>
<a name="3892"><span class="lineNum">    3892 </span>            : </a>
<a name="3893"><span class="lineNum">    3893 </span><span class="lineCov">        488 :      if (tolower(name[0]) &lt; 'i')</span></a>
<a name="3894"><span class="lineNum">    3894 </span>            :         {</a>
<a name="3895"><span class="lineNum">    3895 </span><span class="lineCov">         15 :           returnType = SgTypeFloat::createType();</span></a>
<a name="3896"><span class="lineNum">    3896 </span>            :         }</a>
<a name="3897"><span class="lineNum">    3897 </span>            :        else </a>
<a name="3898"><span class="lineNum">    3898 </span>            :         {</a>
<a name="3899"><span class="lineNum">    3899 </span><span class="lineCov">        473 :           if (tolower(name[0]) &lt; 'o')</span></a>
<a name="3900"><span class="lineNum">    3900 </span>            :              {</a>
<a name="3901"><span class="lineNum">    3901 </span><span class="lineCov">          8 :                returnType = SgTypeInt::createType();</span></a>
<a name="3902"><span class="lineNum">    3902 </span>            :              }</a>
<a name="3903"><span class="lineNum">    3903 </span>            :             else </a>
<a name="3904"><span class="lineNum">    3904 </span>            :              {</a>
<a name="3905"><span class="lineNum">    3905 </span><span class="lineCov">        465 :                returnType = SgTypeFloat::createType();</span></a>
<a name="3906"><span class="lineNum">    3906 </span>            :              }</a>
<a name="3907"><span class="lineNum">    3907 </span>            :         }</a>
<a name="3908"><span class="lineNum">    3908 </span>            : </a>
<a name="3909"><span class="lineNum">    3909 </span>            :   // printf (&quot;***** name = %s generating type = %s \n&quot;,name.c_str(),returnType-&gt;class_name().c_str());</a>
<a name="3910"><span class="lineNum">    3910 </span>            : </a>
<a name="3911"><span class="lineNum">    3911 </span><span class="lineCov">        488 :      ROSE_ASSERT(returnType != NULL);</span></a>
<a name="3912"><span class="lineNum">    3912 </span><span class="lineCov">        488 :      return returnType;</span></a>
<a name="3913"><span class="lineNum">    3913 </span>            :    }</a>
<a name="3914"><span class="lineNum">    3914 </span>            : </a>
<a name="3915"><span class="lineNum">    3915 </span>            : </a>
<a name="3916"><span class="lineNum">    3916 </span>            : </a>
<a name="3917"><span class="lineNum">    3917 </span><span class="lineCov">        457 : SgFunctionType* generateImplicitFunctionType( string functionName)</span></a>
<a name="3918"><span class="lineNum">    3918 </span>            :    {</a>
<a name="3919"><span class="lineNum">    3919 </span>            :   // This function generates a function type that is computed from the name of the function </a>
<a name="3920"><span class="lineNum">    3920 </span>            :   // and the types of the function arguments on the stack (astExpressionStack).</a>
<a name="3921"><span class="lineNum">    3921 </span>            : </a>
<a name="3922"><span class="lineNum">    3922 </span><span class="lineCov">        457 :      bool isIntrinsicFunction = matchAgainstIntrinsicFunctionList(functionName);</span></a>
<a name="3923"><span class="lineNum">    3923 </span><span class="lineCov">        457 :      bool argumentListOnStack = ( (astExpressionStack.empty() == false) &amp;&amp; (isSgExprListExp(astExpressionStack.front()) != NULL) );</span></a>
<a name="3924"><span class="lineNum">    3924 </span>            : </a>
<a name="3925"><span class="lineNum">    3925 </span><span class="lineCov">        457 :      SgType* returnType = NULL;</span></a>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineCov">        457 :      SgExprListExp* exprListExp = NULL;</span></a>
<a name="3927"><span class="lineNum">    3927 </span>            : </a>
<a name="3928"><span class="lineNum">    3928 </span>            :   // printf (&quot;argumentListOnStack = %s \n&quot;,argumentListOnStack ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3929"><span class="lineNum">    3929 </span>            :   // printf (&quot;isIntrinsicFunction = %s \n&quot;,isIntrinsicFunction ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineCov">        457 :      if (argumentListOnStack == true)</span></a>
<a name="3931"><span class="lineNum">    3931 </span>            :         {</a>
<a name="3932"><span class="lineNum">    3932 </span>            :        // If there is an argument list, then if it is a non-empty list then the return type of </a>
<a name="3933"><span class="lineNum">    3933 </span>            :        // the function is determined by the argument type.</a>
<a name="3934"><span class="lineNum">    3934 </span><span class="lineNoCov">          0 :           exprListExp = isSgExprListExp(astExpressionStack.front());</span></a>
<a name="3935"><span class="lineNum">    3935 </span>            : </a>
<a name="3936"><span class="lineNum">    3936 </span><span class="lineNoCov">          0 :           if (isIntrinsicFunction == true)</span></a>
<a name="3937"><span class="lineNum">    3937 </span>            :              {</a>
<a name="3938"><span class="lineNum">    3938 </span><span class="lineNoCov">          0 :                returnType = generateIntrinsicFunctionReturnType(functionName,exprListExp);</span></a>
<a name="3939"><span class="lineNum">    3939 </span>            :              }</a>
<a name="3940"><span class="lineNum">    3940 </span>            :             else</a>
<a name="3941"><span class="lineNum">    3941 </span>            :              {</a>
<a name="3942"><span class="lineNum">    3942 </span>            :             // We need to lookup the type by looking for a variable in the symbol table and using that type</a>
<a name="3943"><span class="lineNum">    3943 </span><span class="lineNoCov">          0 :                returnType = generateImplicitType(functionName);</span></a>
<a name="3944"><span class="lineNum">    3944 </span>            :              }</a>
<a name="3945"><span class="lineNum">    3945 </span>            :         }</a>
<a name="3946"><span class="lineNum">    3946 </span>            :        else</a>
<a name="3947"><span class="lineNum">    3947 </span>            :         {</a>
<a name="3948"><span class="lineNum">    3948 </span>            :        // This may be just a request to generate a function type from a function name.</a>
<a name="3949"><span class="lineNum">    3949 </span>            :        // In this case the type can not yet be precisely defined so we use some defaults </a>
<a name="3950"><span class="lineNum">    3950 </span>            :        // for the parts that we don't know (and fixup the information later in post-processing </a>
<a name="3951"><span class="lineNum">    3951 </span>            :        // phases).</a>
<a name="3952"><span class="lineNum">    3952 </span><span class="lineCov">        457 :           if (isIntrinsicFunction == true)</span></a>
<a name="3953"><span class="lineNum">    3953 </span>            :              {</a>
<a name="3954"><span class="lineNum">    3954 </span><span class="lineNoCov">          0 :                returnType = generateIntrinsicFunctionReturnType(functionName,NULL);</span></a>
<a name="3955"><span class="lineNum">    3955 </span>            :              }</a>
<a name="3956"><span class="lineNum">    3956 </span>            :             else</a>
<a name="3957"><span class="lineNum">    3957 </span>            :              {</a>
<a name="3958"><span class="lineNum">    3958 </span>            :             // We need to lookup the type by looking for a variable in the symbol table and using that type</a>
<a name="3959"><span class="lineNum">    3959 </span><span class="lineCov">        739 :                returnType = generateImplicitType(functionName);</span></a>
<a name="3960"><span class="lineNum">    3960 </span>            :              }</a>
<a name="3961"><span class="lineNum">    3961 </span>            : </a>
<a name="3962"><span class="lineNum">    3962 </span>            :         }</a>
<a name="3963"><span class="lineNum">    3963 </span>            : </a>
<a name="3964"><span class="lineNum">    3964 </span><span class="lineCov">        457 :      bool has_ellipses = false;</span></a>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineCov">        457 :      SgFunctionType* functionType = new SgFunctionType(returnType,has_ellipses);</span></a>
<a name="3966"><span class="lineNum">    3966 </span><span class="lineCov">        457 :      ROSE_ASSERT(functionType != NULL);</span></a>
<a name="3967"><span class="lineNum">    3967 </span><span class="lineCov">        457 :      ROSE_ASSERT(functionType-&gt;get_argument_list() != NULL);</span></a>
<a name="3968"><span class="lineNum">    3968 </span>            : #if 0</a>
<a name="3969"><span class="lineNum">    3969 </span>            :      printf (&quot;#########################################  functionType = %p ####################################### \n&quot;,functionType);</a>
<a name="3970"><span class="lineNum">    3970 </span>            : #endif</a>
<a name="3971"><span class="lineNum">    3971 </span>            : </a>
<a name="3972"><span class="lineNum">    3972 </span><span class="lineCov">        457 :      if (argumentListOnStack == true)</span></a>
<a name="3973"><span class="lineNum">    3973 </span>            :         {</a>
<a name="3974"><span class="lineNum">    3974 </span>            :        // If there was a SgExprListExp on the stack, then fillin the SgFunctionType with the types of the arguments.</a>
<a name="3975"><span class="lineNum">    3975 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(exprListExp != NULL);</span></a>
<a name="3976"><span class="lineNum">    3976 </span><span class="lineNoCov">          0 :           SgExpressionPtrList &amp; functionArgumentList = exprListExp-&gt;get_expressions();</span></a>
<a name="3977"><span class="lineNum">    3977 </span><span class="lineNoCov">          0 :           for (unsigned int i=0; i &lt; functionArgumentList.size(); i++)</span></a>
<a name="3978"><span class="lineNum">    3978 </span>            :              {</a>
<a name="3979"><span class="lineNum">    3979 </span><span class="lineNoCov">          0 :                functionType-&gt;append_argument(functionArgumentList[i]-&gt;get_type());</span></a>
<a name="3980"><span class="lineNum">    3980 </span>            :              }</a>
<a name="3981"><span class="lineNum">    3981 </span>            :         }</a>
<a name="3982"><span class="lineNum">    3982 </span>            : </a>
<a name="3983"><span class="lineNum">    3983 </span><span class="lineCov">        457 :      return functionType;</span></a>
<a name="3984"><span class="lineNum">    3984 </span>            :    }</a>
<a name="3985"><span class="lineNum">    3985 </span>            : </a>
<a name="3986"><span class="lineNum">    3986 </span>            : </a>
<a name="3987"><span class="lineNum">    3987 </span>            : SgAttributeSpecificationStatement*</a>
<a name="3988"><span class="lineNum">    3988 </span><span class="lineCov">        549 : buildAttributeSpecificationStatement ( SgAttributeSpecificationStatement::attribute_spec_enum kind, Token_t *label, Token_t *sourcePositionToken )</span></a>
<a name="3989"><span class="lineNum">    3989 </span>            :    {</a>
<a name="3990"><span class="lineNum">    3990 </span>            :   // We can't call build_implicit_program_statement_if_required() since it is defined in the c_action_&lt;name&gt; functions.</a>
<a name="3991"><span class="lineNum">    3991 </span>            :   // An AttributeSpecification statement can be the first statement in a program</a>
<a name="3992"><span class="lineNum">    3992 </span>            :   // (see test2007_147.f, the original Fortran I code from the IBM 704 Fortran Manual).</a>
<a name="3993"><span class="lineNum">    3993 </span>            :   // build_implicit_program_statement_if_required();</a>
<a name="3994"><span class="lineNum">    3994 </span>            : </a>
<a name="3995"><span class="lineNum">    3995 </span>            :   // printf (&quot;In buildAttributeSpecificationStatement(): kind = %d label = %s \n&quot;,kind,label != NULL ? label-&gt;text : &quot;NULL&quot;);</a>
<a name="3996"><span class="lineNum">    3996 </span>            : </a>
<a name="3997"><span class="lineNum">    3997 </span>            : #if 0</a>
<a name="3998"><span class="lineNum">    3998 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="3999"><span class="lineNum">    3999 </span>            :      outputState(&quot;At TOP of buildAttributeSpecificationStatement()&quot;);</a>
<a name="4000"><span class="lineNum">    4000 </span>            : #endif</a>
<a name="4001"><span class="lineNum">    4001 </span>            : </a>
<a name="4002"><span class="lineNum">    4002 </span><span class="lineCov">        549 :      SgAttributeSpecificationStatement *attributeSpecificationStatement = new SgAttributeSpecificationStatement();</span></a>
<a name="4003"><span class="lineNum">    4003 </span>            : </a>
<a name="4004"><span class="lineNum">    4004 </span>            :   // DQ (10/6/2008): It seems that we all of a sudden need this to be set!</a>
<a name="4005"><span class="lineNum">    4005 </span><span class="lineCov">        549 :      attributeSpecificationStatement-&gt;set_definingDeclaration(attributeSpecificationStatement);</span></a>
<a name="4006"><span class="lineNum">    4006 </span><span class="lineCov">        549 :      attributeSpecificationStatement-&gt;set_firstNondefiningDeclaration(attributeSpecificationStatement);</span></a>
<a name="4007"><span class="lineNum">    4007 </span>            : </a>
<a name="4008"><span class="lineNum">    4008 </span><span class="lineCov">        549 :      ROSE_ASSERT(sourcePositionToken != NULL);</span></a>
<a name="4009"><span class="lineNum">    4009 </span><span class="lineCov">        549 :      setSourcePosition(attributeSpecificationStatement,sourcePositionToken);</span></a>
<a name="4010"><span class="lineNum">    4010 </span>            : </a>
<a name="4011"><span class="lineNum">    4011 </span>            : #if 0</a>
<a name="4012"><span class="lineNum">    4012 </span>            :   // DQ (1/29/2009): the save statement will be associated with the wrong file if it is the</a>
<a name="4013"><span class="lineNum">    4013 </span>            :   // last statement of an include file.  See tests: test2009_12.f test2009_13.f</a>
<a name="4014"><span class="lineNum">    4014 </span>            :      attributeSpecificationStatement-&gt;get_file_info()-&gt;display(&quot;In buildAttributeSpecificationStatement()&quot;);</a>
<a name="4015"><span class="lineNum">    4015 </span>            : #endif</a>
<a name="4016"><span class="lineNum">    4016 </span>            : </a>
<a name="4017"><span class="lineNum">    4017 </span><span class="lineCov">        549 :      attributeSpecificationStatement-&gt;set_attribute_kind(kind);</span></a>
<a name="4018"><span class="lineNum">    4018 </span>            : </a>
<a name="4019"><span class="lineNum">    4019 </span>            :   // printf (&quot;In buildAttributeSpecificationStatement(): astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astNameStack.size());</a>
<a name="4020"><span class="lineNum">    4020 </span>            : </a>
<a name="4021"><span class="lineNum">    4021 </span>            :   // DQ (9/11/2010): Added support for F2003 &quot;protected&quot; statement.</a>
<a name="4022"><span class="lineNum">    4022 </span><span class="lineCov">        549 :      if (kind == SgAttributeSpecificationStatement::e_protectedStatement)</span></a>
<a name="4023"><span class="lineNum">    4023 </span>            :         {</a>
<a name="4024"><span class="lineNum">    4024 </span>            :        // Note that in Fortran &quot;protected&quot; only means that the variable cannot be modified, but it can be read, so this is different from C++.</a>
<a name="4025"><span class="lineNum">    4025 </span><span class="lineNoCov">          0 :           printf (&quot;In buildAttributeSpecificationStatement(): kind == SgAttributeSpecificationStatement::e_protectedStatement \n&quot;);</span></a>
<a name="4026"><span class="lineNum">    4026 </span>            : </a>
<a name="4027"><span class="lineNum">    4027 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="4028"><span class="lineNum">    4028 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astScopeStack.front() != NULL);</span></a>
<a name="4029"><span class="lineNum">    4029 </span>            : </a>
<a name="4030"><span class="lineNum">    4030 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astNameStack.empty() == false);</span></a>
<a name="4031"><span class="lineNum">    4031 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astNameStack.front()-&gt;text != NULL);</span></a>
<a name="4032"><span class="lineNum">    4032 </span><span class="lineNoCov">          0 :           SgName name = astNameStack.front()-&gt;text;</span></a>
<a name="4033"><span class="lineNum">    4033 </span><span class="lineNoCov">          0 :           printf (&quot;building protected statement for variable name = %s \n&quot;,name.str());</span></a>
<a name="4034"><span class="lineNum">    4034 </span><span class="lineNoCov">          0 :           SgVariableSymbol* variableSymbol = astScopeStack.front()-&gt;lookup_variable_symbol(name);</span></a>
<a name="4035"><span class="lineNum">    4035 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(variableSymbol != NULL);</span></a>
<a name="4036"><span class="lineNum">    4036 </span><span class="lineNoCov">          0 :           SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="4037"><span class="lineNum">    4037 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="4038"><span class="lineNum">    4038 </span>            : </a>
<a name="4039"><span class="lineNum">    4039 </span>            :        // Using new support for fortran &quot;protected&quot; specification of variables.</a>
<a name="4040"><span class="lineNum">    4040 </span><span class="lineNoCov">          0 :           initializedName-&gt;set_protected_declaration(true);</span></a>
<a name="4041"><span class="lineNum">    4041 </span>            : </a>
<a name="4042"><span class="lineNum">    4042 </span>            :        // printf (&quot;SgAttributeSpecificationStatement::e_protectedStatement is not yet supported \n&quot;);</a>
<a name="4043"><span class="lineNum">    4043 </span>            :        // ROSE_ASSERT(false);</a>
<a name="4044"><span class="lineNum">    4044 </span>            :         }</a>
<a name="4045"><span class="lineNum">    4045 </span>            : </a>
<a name="4046"><span class="lineNum">    4046 </span><span class="lineCov">        549 :      if (kind == SgAttributeSpecificationStatement::e_bindStatement)</span></a>
<a name="4047"><span class="lineNum">    4047 </span>            :         {</a>
<a name="4048"><span class="lineNum">    4048 </span>            :        // printf (&quot;In buildAttributeSpecificationStatement(): kind == SgAttributeSpecificationStatement::e_bindStatement \n&quot;);</a>
<a name="4049"><span class="lineNum">    4049 </span>            : </a>
<a name="4050"><span class="lineNum">    4050 </span>            :        // Build the SgExprListExp in the attributeSpecificationStatement if it has not already been built</a>
<a name="4051"><span class="lineNum">    4051 </span><span class="lineNoCov">          0 :           if (attributeSpecificationStatement-&gt;get_bind_list() == NULL)</span></a>
<a name="4052"><span class="lineNum">    4052 </span>            :              {</a>
<a name="4053"><span class="lineNum">    4053 </span><span class="lineNoCov">          0 :                SgExprListExp* bindList = new SgExprListExp();</span></a>
<a name="4054"><span class="lineNum">    4054 </span><span class="lineNoCov">          0 :                attributeSpecificationStatement-&gt;set_bind_list(bindList);</span></a>
<a name="4055"><span class="lineNum">    4055 </span><span class="lineNoCov">          0 :                bindList-&gt;set_parent(attributeSpecificationStatement);</span></a>
<a name="4056"><span class="lineNum">    4056 </span><span class="lineNoCov">          0 :                setSourcePosition(bindList);</span></a>
<a name="4057"><span class="lineNum">    4057 </span>            :              }</a>
<a name="4058"><span class="lineNum">    4058 </span>            : </a>
<a name="4059"><span class="lineNum">    4059 </span>            :        // There should be at least one variable specified!</a>
<a name="4060"><span class="lineNum">    4060 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="4061"><span class="lineNum">    4061 </span>            : </a>
<a name="4062"><span class="lineNum">    4062 </span>            :        // Put into local list so that we can reverse the list entries when inserting them into the attributeSpecificationStatement</a>
<a name="4063"><span class="lineNum">    4063 </span>            :        // SgExpressionPtrList localList;</a>
<a name="4064"><span class="lineNum">    4064 </span>            :        // while (astExpressionStack.empty() == false)</a>
<a name="4065"><span class="lineNum">    4065 </span>            :        // while (astExpressionStack.size() &gt; 1)</a>
<a name="4066"><span class="lineNum">    4066 </span><span class="lineNoCov">          0 :           while (astNodeStack.empty() == false)</span></a>
<a name="4067"><span class="lineNum">    4067 </span>            :              {</a>
<a name="4068"><span class="lineNum">    4068 </span><span class="lineNoCov">          0 :                SgExpression* bindExpression = isSgExpression(astNodeStack.front());</span></a>
<a name="4069"><span class="lineNum">    4069 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(bindExpression != NULL);</span></a>
<a name="4070"><span class="lineNum">    4070 </span>            : </a>
<a name="4071"><span class="lineNum">    4071 </span>            :             // printf (&quot;Push the expressions onto the bind_list \n&quot;);</a>
<a name="4072"><span class="lineNum">    4072 </span>            : </a>
<a name="4073"><span class="lineNum">    4073 </span>            :             // localList.push_back(bindExpression);</a>
<a name="4074"><span class="lineNum">    4074 </span>            :             // attributeSpecificationStatement-&gt;get_bind_list()-&gt;prepend_expression(astExpressionStack.front());</a>
<a name="4075"><span class="lineNum">    4075 </span><span class="lineNoCov">          0 :                attributeSpecificationStatement-&gt;get_bind_list()-&gt;prepend_expression(bindExpression);</span></a>
<a name="4076"><span class="lineNum">    4076 </span>            : </a>
<a name="4077"><span class="lineNum">    4077 </span>            :             // astExpressionStack.pop_front();</a>
<a name="4078"><span class="lineNum">    4078 </span><span class="lineNoCov">          0 :                astNodeStack.pop_front();</span></a>
<a name="4079"><span class="lineNum">    4079 </span>            :              }</a>
<a name="4080"><span class="lineNum">    4080 </span>            : </a>
<a name="4081"><span class="lineNum">    4081 </span>            :        // This function using the names on the astNameStack to find the linkage and binding_label</a>
<a name="4082"><span class="lineNum">    4082 </span><span class="lineNoCov">          0 :           processBindingAttribute( attributeSpecificationStatement );</span></a>
<a name="4083"><span class="lineNum">    4083 </span>            :         }</a>
<a name="4084"><span class="lineNum">    4084 </span>            : </a>
<a name="4085"><span class="lineNum">    4085 </span>            :   // DQ (12/19/2007): This has been changed to use SgPntrArrRefExp expressions instead of names.</a>
<a name="4086"><span class="lineNum">    4086 </span><span class="lineCov">        549 :      if (kind != SgAttributeSpecificationStatement::e_dimensionStatement)</span></a>
<a name="4087"><span class="lineNum">    4087 </span>            :         {</a>
<a name="4088"><span class="lineNum">    4088 </span>            :        // This handling of the astNameStack, does not apply to the dimension statement</a>
<a name="4089"><span class="lineNum">    4089 </span><span class="lineCov">        549 :           while (astNameStack.empty() == false)</span></a>
<a name="4090"><span class="lineNum">    4090 </span>            :              {</a>
<a name="4091"><span class="lineNum">    4091 </span><span class="lineNoCov">          0 :                string name = astNameStack.front()-&gt;text;</span></a>
<a name="4092"><span class="lineNum">    4092 </span>            :             // printf (&quot;Push %s onto attributeSpecificationStatement name_list \n&quot;,name.c_str());</a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineNoCov">          0 :                attributeSpecificationStatement-&gt;get_name_list().push_back(name);</span></a>
<a name="4094"><span class="lineNum">    4094 </span>            : </a>
<a name="4095"><span class="lineNum">    4095 </span>            :             // printf (&quot;In loop: attributeSpecificationStatement-&gt;get_name_list().size() = %&quot; PRIuPTR &quot; \n&quot;,attributeSpecificationStatement-&gt;get_name_list().size());</a>
<a name="4096"><span class="lineNum">    4096 </span>            : </a>
<a name="4097"><span class="lineNum">    4097 </span><span class="lineNoCov">          0 :                astNameStack.pop_front();</span></a>
<a name="4098"><span class="lineNum">    4098 </span>            :              }</a>
<a name="4099"><span class="lineNum">    4099 </span>            : </a>
<a name="4100"><span class="lineNum">    4100 </span>            :        // There should at most be a single intent on the stack (I think)</a>
<a name="4101"><span class="lineNum">    4101 </span><span class="lineCov">        549 :           ROSE_ASSERT(astIntentSpecStack.size() &lt;= 1);</span></a>
<a name="4102"><span class="lineNum">    4102 </span><span class="lineCov">        549 :           while (astIntentSpecStack.empty() == false)</span></a>
<a name="4103"><span class="lineNum">    4103 </span>            :              {</a>
<a name="4104"><span class="lineNum">    4104 </span>            :             // DQ (4/5/2010): Debugging missing INTENT keyword in ROSE output of test2009_19.f90.</a>
<a name="4105"><span class="lineNum">    4105 </span>            :             // printf (&quot;Calling attributeSpecificationStatement-&gt;set_intent(intent) \n&quot;);</a>
<a name="4106"><span class="lineNum">    4106 </span>            : </a>
<a name="4107"><span class="lineNum">    4107 </span><span class="lineNoCov">          0 :                int intent = astIntentSpecStack.front();</span></a>
<a name="4108"><span class="lineNum">    4108 </span><span class="lineNoCov">          0 :                attributeSpecificationStatement-&gt;set_intent(intent);</span></a>
<a name="4109"><span class="lineNum">    4109 </span><span class="lineNoCov">          0 :                astIntentSpecStack.pop_front();</span></a>
<a name="4110"><span class="lineNum">    4110 </span>            :              }</a>
<a name="4111"><span class="lineNum">    4111 </span>            :         }</a>
<a name="4112"><span class="lineNum">    4112 </span>            : </a>
<a name="4113"><span class="lineNum">    4113 </span>            :   // DQ (12/19/2007): The dimension statement now uses this case as well.</a>
<a name="4114"><span class="lineNum">    4114 </span>            :   // Handle any entities for both the parameter statement and the allocatable statement</a>
<a name="4115"><span class="lineNum">    4115 </span>            :   // if (kind == SgAttributeSpecificationStatement::e_parameterStatement)</a>
<a name="4116"><span class="lineNum">    4116 </span><span class="lineCov">        549 :      if ( (kind == SgAttributeSpecificationStatement::e_parameterStatement) ||</span></a>
<a name="4117"><span class="lineNum">    4117 </span><span class="lineCov">        549 :           (kind == SgAttributeSpecificationStatement::e_externalStatement) ||</span></a>
<a name="4118"><span class="lineNum">    4118 </span><span class="lineNoCov">          0 :           (kind == SgAttributeSpecificationStatement::e_dimensionStatement) ||</span></a>
<a name="4119"><span class="lineNum">    4119 </span><span class="lineNoCov">          0 :           (kind == SgAttributeSpecificationStatement::e_allocatableStatement) )</span></a>
<a name="4120"><span class="lineNum">    4120 </span>            :         {</a>
<a name="4121"><span class="lineNum">    4121 </span>            : #if 0</a>
<a name="4122"><span class="lineNum">    4122 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="4123"><span class="lineNum">    4123 </span>            :           outputState(&quot;At TOP of buildAttributeSpecificationStatement() for (parameter || external || allocatable || dimension) statement&quot;);</a>
<a name="4124"><span class="lineNum">    4124 </span>            : #endif</a>
<a name="4125"><span class="lineNum">    4125 </span>            :        // The parameter expressions are stored on the stack</a>
<a name="4126"><span class="lineNum">    4126 </span><span class="lineCov">       1098 :           while (astExpressionStack.empty() == false)</span></a>
<a name="4127"><span class="lineNum">    4127 </span>            :              {</a>
<a name="4128"><span class="lineNum">    4128 </span><span class="lineCov">        549 :                SgExpression* parameterExpression = astExpressionStack.front();</span></a>
<a name="4129"><span class="lineNum">    4129 </span>            : </a>
<a name="4130"><span class="lineNum">    4130 </span>            :             // Build the SgExprListExp in the attributeSpecificationStatement if it has not already been built</a>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineCov">        549 :                if (attributeSpecificationStatement-&gt;get_parameter_list() == NULL)</span></a>
<a name="4132"><span class="lineNum">    4132 </span>            :                   {</a>
<a name="4133"><span class="lineNum">    4133 </span><span class="lineCov">        549 :                     SgExprListExp* parameterList = new SgExprListExp();</span></a>
<a name="4134"><span class="lineNum">    4134 </span><span class="lineCov">        549 :                     attributeSpecificationStatement-&gt;set_parameter_list(parameterList);</span></a>
<a name="4135"><span class="lineNum">    4135 </span><span class="lineCov">        549 :                     parameterList-&gt;set_parent(attributeSpecificationStatement);</span></a>
<a name="4136"><span class="lineNum">    4136 </span><span class="lineCov">        549 :                     setSourcePosition(parameterList);</span></a>
<a name="4137"><span class="lineNum">    4137 </span>            :                   }</a>
<a name="4138"><span class="lineNum">    4138 </span>            : </a>
<a name="4139"><span class="lineNum">    4139 </span><span class="lineCov">        549 :                attributeSpecificationStatement-&gt;get_parameter_list()-&gt;prepend_expression(parameterExpression);</span></a>
<a name="4140"><span class="lineNum">    4140 </span>            : </a>
<a name="4141"><span class="lineNum">    4141 </span><span class="lineCov">        549 :                astExpressionStack.pop_front();</span></a>
<a name="4142"><span class="lineNum">    4142 </span>            :              }</a>
<a name="4143"><span class="lineNum">    4143 </span>            : #if 0</a>
<a name="4144"><span class="lineNum">    4144 </span>            :           ROSE_ASSERT(astScopeStack.empty() == false);</a>
<a name="4145"><span class="lineNum">    4145 </span>            :           astScopeStack.front()-&gt;print_symboltable(&quot;In buildAttributeSpecificationStatement()&quot;);</a>
<a name="4146"><span class="lineNum">    4146 </span>            : #endif</a>
<a name="4147"><span class="lineNum">    4147 </span>            : #if 0</a>
<a name="4148"><span class="lineNum">    4148 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="4149"><span class="lineNum">    4149 </span>            :           outputState(&quot;At BASE of buildAttributeSpecificationStatement() for (parameter || external || allocatable || dimension) statement&quot;);</a>
<a name="4150"><span class="lineNum">    4150 </span>            : #endif</a>
<a name="4151"><span class="lineNum">    4151 </span>            :         }</a>
<a name="4152"><span class="lineNum">    4152 </span>            : </a>
<a name="4153"><span class="lineNum">    4153 </span>            :   // Collect the data groups (data-sets) off of the astNodeStack.</a>
<a name="4154"><span class="lineNum">    4154 </span><span class="lineCov">        549 :      if (kind == SgAttributeSpecificationStatement::e_dataStatement)</span></a>
<a name="4155"><span class="lineNum">    4155 </span>            :         {</a>
<a name="4156"><span class="lineNum">    4156 </span>            :        // Put into local list so that we can reverse the list entries when inserting them into the attributeSpecificationStatement</a>
<a name="4157"><span class="lineNum">    4157 </span><span class="lineNoCov">          0 :           SgDataStatementGroupPtrList localList;</span></a>
<a name="4158"><span class="lineNum">    4158 </span><span class="lineNoCov">          0 :           while (astNodeStack.empty() == false)</span></a>
<a name="4159"><span class="lineNum">    4159 </span>            :              {</a>
<a name="4160"><span class="lineNum">    4160 </span><span class="lineNoCov">          0 :                SgDataStatementGroup* dataGroup = isSgDataStatementGroup(astNodeStack.front());</span></a>
<a name="4161"><span class="lineNum">    4161 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(dataGroup != NULL);</span></a>
<a name="4162"><span class="lineNum">    4162 </span>            : </a>
<a name="4163"><span class="lineNum">    4163 </span>            :             // attributeSpecificationStatement-&gt;get_data_statement_group_list().push_back(dataGroup);</a>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineNoCov">          0 :                localList.push_back(dataGroup);</span></a>
<a name="4165"><span class="lineNum">    4165 </span>            :             // ROSE_ASSERT(attributeSpecificationStatement-&gt;get_data_statement_group_list().empty() == false);</a>
<a name="4166"><span class="lineNum">    4166 </span>            : </a>
<a name="4167"><span class="lineNum">    4167 </span><span class="lineNoCov">          0 :                astNodeStack.pop_front();</span></a>
<a name="4168"><span class="lineNum">    4168 </span>            :              }</a>
<a name="4169"><span class="lineNum">    4169 </span>            : </a>
<a name="4170"><span class="lineNum">    4170 </span>            :        // Reverse the list</a>
<a name="4171"><span class="lineNum">    4171 </span><span class="lineNoCov">          0 :           for (int i = localList.size()-1; i &gt;= 0; i--)</span></a>
<a name="4172"><span class="lineNum">    4172 </span>            :              {</a>
<a name="4173"><span class="lineNum">    4173 </span><span class="lineNoCov">          0 :                attributeSpecificationStatement-&gt;get_data_statement_group_list().push_back(localList[i]);</span></a>
<a name="4174"><span class="lineNum">    4174 </span>            :              }</a>
<a name="4175"><span class="lineNum">    4175 </span>            :         }</a>
<a name="4176"><span class="lineNum">    4176 </span>            : </a>
<a name="4177"><span class="lineNum">    4177 </span>            :   // printf (&quot;attributeSpecificationStatement-&gt;get_name_list().size() = %&quot; PRIuPTR &quot; \n&quot;,attributeSpecificationStatement-&gt;get_name_list().size());</a>
<a name="4178"><span class="lineNum">    4178 </span>            : </a>
<a name="4179"><span class="lineNum">    4179 </span><span class="lineCov">        549 :      astScopeStack.front()-&gt;append_statement(attributeSpecificationStatement);     </span></a>
<a name="4180"><span class="lineNum">    4180 </span>            : </a>
<a name="4181"><span class="lineNum">    4181 </span>            :   // Set the numeric label if it exists</a>
<a name="4182"><span class="lineNum">    4182 </span><span class="lineCov">        549 :      setStatementNumericLabel(attributeSpecificationStatement,label);</span></a>
<a name="4183"><span class="lineNum">    4183 </span>            : </a>
<a name="4184"><span class="lineNum">    4184 </span>            :      // DXN (02/08/2012): to facilitate the handling of the computed attribute specification statement in FortranParserActionRose</a>
<a name="4185"><span class="lineNum">    4185 </span><span class="lineCov">        549 :      return attributeSpecificationStatement;</span></a>
<a name="4186"><span class="lineNum">    4186 </span>            : </a>
<a name="4187"><span class="lineNum">    4187 </span>            :   // printf (&quot;In buildAttributeSpecificationStatement(): attributeSpecificationStatement: start = %d end = %d \n&quot;,attributeSpecificationStatement-&gt;get_startOfConstruct()-&gt;get_line(),attributeSpecificationStatement-&gt;get_endOfConstruct()-&gt;get_line());</a>
<a name="4188"><span class="lineNum">    4188 </span>            :    }</a>
<a name="4189"><span class="lineNum">    4189 </span>            : </a>
<a name="4190"><span class="lineNum">    4190 </span>            : </a>
<a name="4191"><span class="lineNum">    4191 </span>            : void</a>
<a name="4192"><span class="lineNum">    4192 </span><span class="lineCov">          8 : setDeclarationAttributeSpec ( SgDeclarationStatement* variableDeclaration, int astAttributeSpec )</span></a>
<a name="4193"><span class="lineNum">    4193 </span>            :    {</a>
<a name="4194"><span class="lineNum">    4194 </span>            :   // This could either be a variable declaration or a class declaration</a>
<a name="4195"><span class="lineNum">    4195 </span>            : </a>
<a name="4196"><span class="lineNum">    4196 </span>            : #if 0</a>
<a name="4197"><span class="lineNum">    4197 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="4198"><span class="lineNum">    4198 </span>            :      outputState(&quot;At TOP of setDeclarationAttributeSpec()&quot;);</a>
<a name="4199"><span class="lineNum">    4199 </span>            :      printf (&quot;In setDeclarationAttributeSpec(): variableDeclaration = %p astAttributeSpec = %d \n&quot;,variableDeclaration,astAttributeSpec);</a>
<a name="4200"><span class="lineNum">    4200 </span>            : #endif</a>
<a name="4201"><span class="lineNum">    4201 </span>            : </a>
<a name="4202"><span class="lineNum">    4202 </span><span class="lineCov">          8 :      switch(astAttributeSpec)</span></a>
<a name="4203"><span class="lineNum">    4203 </span>            :         {</a>
<a name="4204"><span class="lineNum">    4204 </span><span class="lineNoCov">          0 :           case AttrSpec_none:</span></a>
<a name="4205"><span class="lineNum">    4205 </span><span class="lineNoCov">          0 :                printf (&quot;Error: Unsupported option for astAttributeSpec = %d \n&quot;,astAttributeSpec);</span></a>
<a name="4206"><span class="lineNum">    4206 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4207"><span class="lineNum">    4207 </span>            : </a>
<a name="4208"><span class="lineNum">    4208 </span><span class="lineNoCov">          0 :           case AttrSpec_access:</span></a>
<a name="4209"><span class="lineNum">    4209 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4210"><span class="lineNum">    4210 </span>            :             // DQ (5/20/2008): This is a redundant specifier, it appears to only be used with AttrSpec_PUBLIC or AttrSpec_PRIVATE</a>
<a name="4211"><span class="lineNum">    4211 </span>            :             // It should be filtered out so that will not see this case in this function.</a>
<a name="4212"><span class="lineNum">    4212 </span><span class="lineNoCov">          0 :                printf (&quot;Error: Unsupported option for astAttributeSpec = %d \n&quot;,astAttributeSpec);</span></a>
<a name="4213"><span class="lineNum">    4213 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4214"><span class="lineNum">    4214 </span>            :              }</a>
<a name="4215"><span class="lineNum">    4215 </span>            : </a>
<a name="4216"><span class="lineNum">    4216 </span><span class="lineNoCov">          0 :           case AttrSpec_language_binding:</span></a>
<a name="4217"><span class="lineNum">    4217 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4218"><span class="lineNum">    4218 </span><span class="lineNoCov">          0 :                variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setBind();</span></a>
<a name="4219"><span class="lineNum">    4219 </span>            : </a>
<a name="4220"><span class="lineNum">    4220 </span>            : #if 0</a>
<a name="4221"><span class="lineNum">    4221 </span>            :             // Output debugging information about saved state (stack) information.</a>
<a name="4222"><span class="lineNum">    4222 </span>            :                outputState(&quot;In setDeclarationAttributeSpec()&quot;);</a>
<a name="4223"><span class="lineNum">    4223 </span>            : #endif</a>
<a name="4224"><span class="lineNum">    4224 </span>            : </a>
<a name="4225"><span class="lineNum">    4225 </span><span class="lineNoCov">          0 :                processBindingAttribute(variableDeclaration);</span></a>
<a name="4226"><span class="lineNum">    4226 </span>            : </a>
<a name="4227"><span class="lineNum">    4227 </span>            :             // printf (&quot;Exiting after processing AttrSpec_language_binding = %d \n&quot;,(int)AttrSpec_language_binding);</a>
<a name="4228"><span class="lineNum">    4228 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4229"><span class="lineNum">    4229 </span>            :              }</a>
<a name="4230"><span class="lineNum">    4230 </span>            : </a>
<a name="4231"><span class="lineNum">    4231 </span>            :        // This maps to a C/C++ modifier setting.</a>
<a name="4232"><span class="lineNum">    4232 </span><span class="lineNoCov">          0 :           case AttrSpec_PUBLIC:</span></a>
<a name="4233"><span class="lineNum">    4233 </span><span class="lineNoCov">          0 :                variableDeclaration-&gt;get_declarationModifier().get_accessModifier().setPublic();</span></a>
<a name="4234"><span class="lineNum">    4234 </span>            :             // printf (&quot;astNameStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astNameStack.size());</a>
<a name="4235"><span class="lineNum">    4235 </span>            : </a>
<a name="4236"><span class="lineNum">    4236 </span>            :             // DQ (10/24/2010): Verify that the name on the astNameStack is &quot;PUBLIC&quot; and then pop the token from the stack.</a>
<a name="4237"><span class="lineNum">    4237 </span>            : </a>
<a name="4238"><span class="lineNum">    4238 </span>            : #if 0</a>
<a name="4239"><span class="lineNum">    4239 </span>            :             // Output debugging information about saved state (stack) information.</a>
<a name="4240"><span class="lineNum">    4240 </span>            :                outputState(&quot;In setDeclarationAttributeSpec()&quot;);</a>
<a name="4241"><span class="lineNum">    4241 </span>            : #endif</a>
<a name="4242"><span class="lineNum">    4242 </span>            :             // printf (&quot;Exiting after processing AttrSpec_PUBLIC = %d \n&quot;,(int)AttrSpec_PUBLIC);</a>
<a name="4243"><span class="lineNum">    4243 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4244"><span class="lineNum">    4244 </span>            : </a>
<a name="4245"><span class="lineNum">    4245 </span><span class="lineNoCov">          0 :           case AttrSpec_PRIVATE:   variableDeclaration-&gt;get_declarationModifier().get_accessModifier().setPrivate();   break;</span></a>
<a name="4246"><span class="lineNum">    4246 </span>            : </a>
<a name="4247"><span class="lineNum">    4247 </span>            :        // DQ (9/11/2010): Fortran protected attribute is not the same a C++ protected attribute, so we use a different mechanism </a>
<a name="4248"><span class="lineNum">    4248 </span>            :        // that can be associated with individual variables if required (as required with the protected statment is used with </a>
<a name="4249"><span class="lineNum">    4249 </span>            :        // subsets of variables that might appear in a variable declaration).</a>
<a name="4250"><span class="lineNum">    4250 </span>            :        // case AttrSpec_PROTECTED:    variableDeclaration-&gt;get_declarationModifier().get_accessModifier().setProtected(); break;</a>
<a name="4251"><span class="lineNum">    4251 </span><span class="lineNoCov">          0 :           case AttrSpec_PROTECTED:</span></a>
<a name="4252"><span class="lineNum">    4252 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4253"><span class="lineNum">    4253 </span>            :             // variableDeclaration-&gt;get_declarationModifier().get_accessModifier().setProtected(); break;</a>
<a name="4254"><span class="lineNum">    4254 </span>            :             // Using new support for fortran &quot;protected&quot; specification of variables.</a>
<a name="4255"><span class="lineNum">    4255 </span><span class="lineNoCov">          0 :                SgVariableDeclaration* local_variableDeclaration = isSgVariableDeclaration(variableDeclaration);</span></a>
<a name="4256"><span class="lineNum">    4256 </span>            :             // printf (&quot;Setting all the variables in a variable declaration as protected \n&quot;);</a>
<a name="4257"><span class="lineNum">    4257 </span><span class="lineNoCov">          0 :                SgInitializedNamePtrList::iterator i = local_variableDeclaration-&gt;get_variables().begin();</span></a>
<a name="4258"><span class="lineNum">    4258 </span><span class="lineNoCov">          0 :                while (i != local_variableDeclaration-&gt;get_variables().end())</span></a>
<a name="4259"><span class="lineNum">    4259 </span>            :                   {</a>
<a name="4260"><span class="lineNum">    4260 </span><span class="lineNoCov">          0 :                     (*i)-&gt;set_protected_declaration(true);</span></a>
<a name="4261"><span class="lineNum">    4261 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="4262"><span class="lineNum">    4262 </span>            :                   }</a>
<a name="4263"><span class="lineNum">    4263 </span>            : #if 0</a>
<a name="4264"><span class="lineNum">    4264 </span>            :                printf (&quot;Exiting after setting all the variables in a variable declaration as protected \n&quot;);</a>
<a name="4265"><span class="lineNum">    4265 </span>            :                ROSE_ABORT();</a>
<a name="4266"><span class="lineNum">    4266 </span>            : #endif</a>
<a name="4267"><span class="lineNum">    4267 </span>            :                break;</a>
<a name="4268"><span class="lineNum">    4268 </span>            :              }</a>
<a name="4269"><span class="lineNum">    4269 </span>            : </a>
<a name="4270"><span class="lineNum">    4270 </span>            :        // These represent special Fortran specific support in ROSE.</a>
<a name="4271"><span class="lineNum">    4271 </span><span class="lineNoCov">          0 :           case AttrSpec_ALLOCATABLE:</span></a>
<a name="4272"><span class="lineNum">    4272 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_allocatable:</span></a>
<a name="4273"><span class="lineNum">    4273 </span><span class="lineNoCov">          0 :               variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setAllocatable();</span></a>
<a name="4274"><span class="lineNum">    4274 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="4275"><span class="lineNum">    4275 </span><span class="lineNoCov">          0 :           case AttrSpec_ASYNCHRONOUS: variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setAsynchronous(); break;</span></a>
<a name="4276"><span class="lineNum">    4276 </span><span class="lineNoCov">          0 :           case AttrSpec_DIMENSION:</span></a>
<a name="4277"><span class="lineNum">    4277 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_dimension:</span></a>
<a name="4278"><span class="lineNum">    4278 </span><span class="lineNoCov">          0 :               variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setDimension();</span></a>
<a name="4279"><span class="lineNum">    4279 </span><span class="lineNoCov">          0 :               break;</span></a>
<a name="4280"><span class="lineNum">    4280 </span><span class="lineNoCov">          0 :           case AttrSpec_CODIMENSION:</span></a>
<a name="4281"><span class="lineNum">    4281 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_codimension:</span></a>
<a name="4282"><span class="lineNum">    4282 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4283"><span class="lineNum">    4283 </span>            :                // DXN: TODO - there is no codimension attribute specifier for SgTypeModifier.</a>
<a name="4284"><span class="lineNum">    4284 </span>            :                // setDefault for now.</a>
<a name="4285"><span class="lineNum">    4285 </span><span class="lineNoCov">          0 :                variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setDefault();</span></a>
<a name="4286"><span class="lineNum">    4286 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4287"><span class="lineNum">    4287 </span>            :              }</a>
<a name="4288"><span class="lineNum">    4288 </span><span class="lineNoCov">          0 :           case AttrSpec_INTENT:</span></a>
<a name="4289"><span class="lineNum">    4289 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4290"><span class="lineNum">    4290 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(astIntentSpecStack.empty() == false);</span></a>
<a name="4291"><span class="lineNum">    4291 </span><span class="lineNoCov">          0 :                switch(astIntentSpecStack.front())</span></a>
<a name="4292"><span class="lineNum">    4292 </span>            :                   {</a>
<a name="4293"><span class="lineNum">    4293 </span><span class="lineNoCov">          0 :                     case IntentSpec_IN:    variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setIntent_in();    break;</span></a>
<a name="4294"><span class="lineNum">    4294 </span><span class="lineNoCov">          0 :                     case IntentSpec_OUT:   variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setIntent_out();   break;</span></a>
<a name="4295"><span class="lineNum">    4295 </span><span class="lineNoCov">          0 :                     case IntentSpec_INOUT: variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setIntent_inout(); break;</span></a>
<a name="4296"><span class="lineNum">    4296 </span><span class="lineNoCov">          0 :                     default:</span></a>
<a name="4297"><span class="lineNum">    4297 </span><span class="lineNoCov">          0 :                        {</span></a>
<a name="4298"><span class="lineNum">    4298 </span><span class="lineNoCov">          0 :                          printf (&quot;Error: default reached in switch(astIntentSpecStack.front()) astIntentSpecStack.front() = %d \n&quot;,astIntentSpecStack.front());</span></a>
<a name="4299"><span class="lineNum">    4299 </span><span class="lineNoCov">          0 :                          ROSE_ABORT();</span></a>
<a name="4300"><span class="lineNum">    4300 </span>            :                        }</a>
<a name="4301"><span class="lineNum">    4301 </span>            :                   }</a>
<a name="4302"><span class="lineNum">    4302 </span><span class="lineNoCov">          0 :                astIntentSpecStack.pop_front();</span></a>
<a name="4303"><span class="lineNum">    4303 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4304"><span class="lineNum">    4304 </span>            :              }</a>
<a name="4305"><span class="lineNum">    4305 </span>            : </a>
<a name="4306"><span class="lineNum">    4306 </span><span class="lineNoCov">          0 :           case AttrSpec_INTRINSIC:    variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setIntrinsic();    break;</span></a>
<a name="4307"><span class="lineNum">    4307 </span><span class="lineNoCov">          0 :           case AttrSpec_BINDC:        variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setBind();         break;</span></a>
<a name="4308"><span class="lineNum">    4308 </span><span class="lineNoCov">          0 :           case AttrSpec_OPTIONAL:     variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setOptional();     break;</span></a>
<a name="4309"><span class="lineNum">    4309 </span><span class="lineNoCov">          0 :           case AttrSpec_SAVE:         variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setSave();         break;</span></a>
<a name="4310"><span class="lineNum">    4310 </span><span class="lineCov">          4 :           case AttrSpec_TARGET:       variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setTarget();       break;</span></a>
<a name="4311"><span class="lineNum">    4311 </span>            :           case AttrSpec_COTARGET:     break; // DXN (04/11/2011): TODO</a>
<a name="4312"><span class="lineNum">    4312 </span><span class="lineNoCov">          0 :           case AttrSpec_VALUE:        variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setValue();        break;</span></a>
<a name="4313"><span class="lineNum">    4313 </span>            : </a>
<a name="4314"><span class="lineNum">    4314 </span>            :        // DQ (8/28/2010): Added support required for type-attributes-spec values (TypeAttrSpec_bind does the same as AttrSpec_BINDC).</a>
<a name="4315"><span class="lineNum">    4315 </span><span class="lineNoCov">          0 :           case TypeAttrSpec_extends:  variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setExtends();      break;</span></a>
<a name="4316"><span class="lineNum">    4316 </span><span class="lineNoCov">          0 :           case TypeAttrSpec_abstract: variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setAbstract();     break;</span></a>
<a name="4317"><span class="lineNum">    4317 </span><span class="lineNoCov">          0 :           case TypeAttrSpec_bind:     variableDeclaration-&gt;get_declarationModifier().get_typeModifier().setBind();         break;</span></a>
<a name="4318"><span class="lineNum">    4318 </span>            : </a>
<a name="4319"><span class="lineNum">    4319 </span>            :        // This maps to C/C++ modifier settings.</a>
<a name="4320"><span class="lineNum">    4320 </span><span class="lineNoCov">          0 :           case AttrSpec_EXTERNAL:     variableDeclaration-&gt;get_declarationModifier().get_storageModifier().setExtern();    break;</span></a>
<a name="4321"><span class="lineNum">    4321 </span><span class="lineNoCov">          0 :           case AttrSpec_VOLATILE:     variableDeclaration-&gt;get_declarationModifier().get_typeModifier().get_constVolatileModifier().setVolatile(); break;</span></a>
<a name="4322"><span class="lineNum">    4322 </span>            : </a>
<a name="4323"><span class="lineNum">    4323 </span><span class="lineNoCov">          0 :           case AttrSpec_PARAMETER:</span></a>
<a name="4324"><span class="lineNum">    4324 </span>            :             // printf (&quot;Error: PARAMETER is an attribute that implies constant value ('const' in C/C++) \n&quot;);</a>
<a name="4325"><span class="lineNum">    4325 </span><span class="lineNoCov">          0 :                variableDeclaration-&gt;get_declarationModifier().get_typeModifier().get_constVolatileModifier().setConst();</span></a>
<a name="4326"><span class="lineNum">    4326 </span>            : </a>
<a name="4327"><span class="lineNum">    4327 </span>            :             // Output debugging information about saved state (stack) information.</a>
<a name="4328"><span class="lineNum">    4328 </span><span class="lineNoCov">          0 :                outputState(&quot;In setDeclarationAttributeSpec(): case AttrSpec_PARAMETER&quot;);</span></a>
<a name="4329"><span class="lineNum">    4329 </span>            : </a>
<a name="4330"><span class="lineNum">    4330 </span><span class="lineNoCov">          0 :                if (astBaseTypeStack.empty() == false)</span></a>
<a name="4331"><span class="lineNum">    4331 </span>            :                   {</a>
<a name="4332"><span class="lineNum">    4332 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4333"><span class="lineNum">    4333 </span><span class="lineNoCov">          0 :                          printf (&quot;Processing AttrSpec_PARAMETER case, astBaseTypeStack not empty: astBaseTypeStack.front() = %p = %s = %s (CLEARING astBaseTypeStack) \n&quot;,</span></a>
<a name="4334"><span class="lineNum">    4334 </span><span class="lineNoCov">          0 :                               astBaseTypeStack.front(),astBaseTypeStack.front()-&gt;class_name().c_str(),SageInterface::get_name(astBaseTypeStack.front()).c_str());</span></a>
<a name="4335"><span class="lineNum">    4335 </span>            : </a>
<a name="4336"><span class="lineNum">    4336 </span><span class="lineNoCov">          0 :                     SgModifierType* modifierType = isSgModifierType(astBaseTypeStack.front());</span></a>
<a name="4337"><span class="lineNum">    4337 </span>            :                  // ROSE_ASSERT(modifierType != NULL);</a>
<a name="4338"><span class="lineNum">    4338 </span><span class="lineNoCov">          0 :                     if (modifierType != NULL)</span></a>
<a name="4339"><span class="lineNum">    4339 </span>            :                        {</a>
<a name="4340"><span class="lineNum">    4340 </span><span class="lineNoCov">          0 :                          modifierType-&gt;get_typeModifier().get_constVolatileModifier().setConst();</span></a>
<a name="4341"><span class="lineNum">    4341 </span>            :                        }</a>
<a name="4342"><span class="lineNum">    4342 </span>            :                       else</a>
<a name="4343"><span class="lineNum">    4343 </span>            :                        {</a>
<a name="4344"><span class="lineNum">    4344 </span>            :                       // printf (&quot;This was not a modifier Type \n&quot;);</a>
<a name="4345"><span class="lineNum">    4345 </span>            :                        }</a>
<a name="4346"><span class="lineNum">    4346 </span>            : </a>
<a name="4347"><span class="lineNum">    4347 </span>            :                  // DQ (4/7/2010): This might be the perfect place to pop the stack, and avoid the warning later!</a>
<a name="4348"><span class="lineNum">    4348 </span>            :                  // astBaseTypeStack.pop();</a>
<a name="4349"><span class="lineNum">    4349 </span>            :                   }</a>
<a name="4350"><span class="lineNum">    4350 </span>            : </a>
<a name="4351"><span class="lineNum">    4351 </span>            :                break;</a>
<a name="4352"><span class="lineNum">    4352 </span>            : </a>
<a name="4353"><span class="lineNum">    4353 </span><span class="lineNoCov">          0 :           case AttrSpec_CONTIGUOUS:   variableDeclaration-&gt;get_declarationModifier().get_storageModifier().setContiguous();    break;</span></a>
<a name="4354"><span class="lineNum">    4354 </span>            :           case AttrSpec_POINTER:</a>
<a name="4355"><span class="lineNum">    4355 </span>            :           case AttrSpec_COPOINTER:</a>
<a name="4356"><span class="lineNum">    4356 </span>            :           case ComponentAttrSpec_pointer:</a>
<a name="4357"><span class="lineNum">    4357 </span>            :             // POINTER/COPOINTER are attribute specifiers that affect the associated type (no flag is provided);</a>
<a name="4358"><span class="lineNum">    4358 </span>            :                break;</a>
<a name="4359"><span class="lineNum">    4359 </span>            : </a>
<a name="4360"><span class="lineNum">    4360 </span>            :           case AttrSpec_PASS:</a>
<a name="4361"><span class="lineNum">    4361 </span>            :           case AttrSpec_NOPASS:</a>
<a name="4362"><span class="lineNum">    4362 </span>            :           case AttrSpec_NON_OVERRIDABLE:</a>
<a name="4363"><span class="lineNum">    4363 </span>            :           case AttrSpec_DEFERRED:</a>
<a name="4364"><span class="lineNum">    4364 </span>            :             // printf (&quot;Error: Are these F08 attribute specs? astAttributeSpec = %d \n&quot;,astAttributeSpec);</a>
<a name="4365"><span class="lineNum">    4365 </span>            :                break;</a>
<a name="4366"><span class="lineNum">    4366 </span>            : </a>
<a name="4367"><span class="lineNum">    4367 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_access_spec:</span></a>
<a name="4368"><span class="lineNum">    4368 </span><span class="lineNoCov">          0 :                printf (&quot;Error: ComponentAttrSpec_access_spec used as an attribute specifier (unclear how to process this) \n&quot;);</span></a>
<a name="4369"><span class="lineNum">    4369 </span>            :                break;</a>
<a name="4370"><span class="lineNum">    4370 </span>            : </a>
<a name="4371"><span class="lineNum">    4371 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_kind:</span></a>
<a name="4372"><span class="lineNum">    4372 </span><span class="lineNoCov">          0 :                printf (&quot;Error: ComponentAttrSpec_kind used as an attribute specifier (unclear how to process this) \n&quot;);</span></a>
<a name="4373"><span class="lineNum">    4373 </span>            :                break;</a>
<a name="4374"><span class="lineNum">    4374 </span>            : </a>
<a name="4375"><span class="lineNum">    4375 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_len:</span></a>
<a name="4376"><span class="lineNum">    4376 </span>            :             // DQ (8/28/2010): Uncommented this out (problems here are likely due to another bug where the ComponentAttrSpec_len is not set properly.</a>
<a name="4377"><span class="lineNum">    4377 </span>            :             // FMZ 6/15/2009 : this should be ok</a>
<a name="4378"><span class="lineNum">    4378 </span><span class="lineNoCov">          0 :                printf (&quot;Error: ComponentAttrSpec_len used as an attribute specifier (unclear how to process this) \n&quot;);</span></a>
<a name="4379"><span class="lineNum">    4379 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4380"><span class="lineNum">    4380 </span>            : </a>
<a name="4381"><span class="lineNum">    4381 </span><span class="lineNoCov">          0 :           case ComponentAttrSpec_contiguous:</span></a>
<a name="4382"><span class="lineNum">    4382 </span>            :             // Pei-Hung(03/26/2021) set storage modifier to contiguous attribute</a>
<a name="4383"><span class="lineNum">    4383 </span><span class="lineNoCov">          0 :                variableDeclaration-&gt;get_declarationModifier().get_storageModifier().setContiguous();    </span></a>
<a name="4384"><span class="lineNum">    4384 </span><span class="lineNoCov">          0 :                break;</span></a>
<a name="4385"><span class="lineNum">    4385 </span>            : </a>
<a name="4386"><span class="lineNum">    4386 </span><span class="lineNoCov">          0 :           default:</span></a>
<a name="4387"><span class="lineNum">    4387 </span><span class="lineNoCov">          0 :              {</span></a>
<a name="4388"><span class="lineNum">    4388 </span><span class="lineNoCov">          0 :                printf (&quot;Error: default reached astAttributeSpec = %d \n&quot;,astAttributeSpec);</span></a>
<a name="4389"><span class="lineNum">    4389 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="4390"><span class="lineNum">    4390 </span>            :              }</a>
<a name="4391"><span class="lineNum">    4391 </span>            :         }</a>
<a name="4392"><span class="lineNum">    4392 </span><span class="lineCov">          8 :    }</span></a>
<a name="4393"><span class="lineNum">    4393 </span>            : </a>
<a name="4394"><span class="lineNum">    4394 </span>            : void</a>
<a name="4395"><span class="lineNum">    4395 </span><span class="lineNoCov">          0 : processBindingAttribute( SgDeclarationStatement* declaration)</span></a>
<a name="4396"><span class="lineNum">    4396 </span>            :    {</a>
<a name="4397"><span class="lineNum">    4397 </span>            :   // This function sets the binding details for functions, variables, and type declarations.</a>
<a name="4398"><span class="lineNum">    4398 </span>            : </a>
<a name="4399"><span class="lineNum">    4399 </span><span class="lineNoCov">          0 :      declaration-&gt;get_declarationModifier().setBind();</span></a>
<a name="4400"><span class="lineNum">    4400 </span>            : </a>
<a name="4401"><span class="lineNum">    4401 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="4402"><span class="lineNum">    4402 </span>            :   // outputState(&quot;Process binding spec in R1232 c_action_subroutine_stmt()&quot;);</a>
<a name="4403"><span class="lineNum">    4403 </span>            : </a>
<a name="4404"><span class="lineNum">    4404 </span><span class="lineNoCov">          0 :      string targetLanguage = astNameStack.front()-&gt;text;</span></a>
<a name="4405"><span class="lineNum">    4405 </span>            :   // printf (&quot;targetLanguage = %s \n&quot;,targetLanguage.c_str());</a>
<a name="4406"><span class="lineNum">    4406 </span><span class="lineNoCov">          0 :      astNameStack.pop_front();</span></a>
<a name="4407"><span class="lineNum">    4407 </span>            : </a>
<a name="4408"><span class="lineNum">    4408 </span>            :   // I think it is always &quot;C&quot;, we use the linkage string in ROSE to hold this information</a>
<a name="4409"><span class="lineNum">    4409 </span>            :   // (used for C/C++ and now Fortran).</a>
<a name="4410"><span class="lineNum">    4410 </span>            :   // declaration-&gt;set_bind_language(targetLanguage);</a>
<a name="4411"><span class="lineNum">    4411 </span><span class="lineNoCov">          0 :      declaration-&gt;set_linkage(targetLanguage);</span></a>
<a name="4412"><span class="lineNum">    4412 </span>            : </a>
<a name="4413"><span class="lineNum">    4413 </span>            :   // Note that the use of &quot;NAME=&quot;c_language_name&quot; is optional.</a>
<a name="4414"><span class="lineNum">    4414 </span>            :   // ROSE_ASSERT(astNameStack.empty() == false);</a>
<a name="4415"><span class="lineNum">    4415 </span>            : </a>
<a name="4416"><span class="lineNum">    4416 </span>            :   // printf (&quot;In processBindingAttribute(): astNameStack.empty()       = %s \n&quot;,astNameStack.empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4417"><span class="lineNum">    4417 </span>            :   // printf (&quot;In processBindingAttribute(): astExpressionStack.empty() = %s \n&quot;,astExpressionStack.empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="4418"><span class="lineNum">    4418 </span>            : </a>
<a name="4419"><span class="lineNum">    4419 </span><span class="lineNoCov">          0 :      if (astNameStack.empty() == false &amp;&amp; astExpressionStack.empty() == false)</span></a>
<a name="4420"><span class="lineNum">    4420 </span>            :         {</a>
<a name="4421"><span class="lineNum">    4421 </span>            :        // There is a &quot;NAME&quot; = string_literal to be processed.</a>
<a name="4422"><span class="lineNum">    4422 </span><span class="lineNoCov">          0 :           string optionString = astNameStack.front()-&gt;text;</span></a>
<a name="4423"><span class="lineNum">    4423 </span>            :        // printf (&quot;optionString = %s \n&quot;,optionString.c_str());</a>
<a name="4424"><span class="lineNum">    4424 </span><span class="lineNoCov">          0 :           astNameStack.pop_front();</span></a>
<a name="4425"><span class="lineNum">    4425 </span>            : </a>
<a name="4426"><span class="lineNum">    4426 </span>            :        // SgExpression* stringLiteralExp = isSgStringVal(astExpressionStack.front());</a>
<a name="4427"><span class="lineNum">    4427 </span><span class="lineNoCov">          0 :           SgStringVal* stringLiteralExp = isSgStringVal(astExpressionStack.front());</span></a>
<a name="4428"><span class="lineNum">    4428 </span><span class="lineNoCov">          0 :           astExpressionStack.pop_front();</span></a>
<a name="4429"><span class="lineNum">    4429 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(stringLiteralExp != NULL);</span></a>
<a name="4430"><span class="lineNum">    4430 </span>            : </a>
<a name="4431"><span class="lineNum">    4431 </span><span class="lineNoCov">          0 :           string bindingLabel = stringLiteralExp-&gt;get_value();</span></a>
<a name="4432"><span class="lineNum">    4432 </span>            : </a>
<a name="4433"><span class="lineNum">    4433 </span>            :        // We don't need the string literal IR node that we just got from the stack (we just want the string)</a>
<a name="4434"><span class="lineNum">    4434 </span><span class="lineNoCov">          0 :           delete stringLiteralExp;</span></a>
<a name="4435"><span class="lineNum">    4435 </span><span class="lineNoCov">          0 :           stringLiteralExp = NULL;</span></a>
<a name="4436"><span class="lineNum">    4436 </span>            : </a>
<a name="4437"><span class="lineNum">    4437 </span>            :        // printf (&quot;Binding label = %s \n&quot;,bindingLabel.c_str());</a>
<a name="4438"><span class="lineNum">    4438 </span><span class="lineNoCov">          0 :           declaration-&gt;set_binding_label(bindingLabel);</span></a>
<a name="4439"><span class="lineNum">    4439 </span>            :         }</a>
<a name="4440"><span class="lineNum">    4440 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="4441"><span class="lineNum">    4441 </span>            : </a>
<a name="4442"><span class="lineNum">    4442 </span>            : void</a>
<a name="4443"><span class="lineNum">    4443 </span><span class="lineCov">          1 : convertVariableSymbolToFunctionCallExp( SgVariableSymbol* variableSymbol, Token_t* nameToken )</span></a>
<a name="4444"><span class="lineNum">    4444 </span>            :    {</a>
<a name="4445"><span class="lineNum">    4445 </span><span class="lineCov">          2 :      SgName name = variableSymbol-&gt;get_name();</span></a>
<a name="4446"><span class="lineNum">    4446 </span>            : </a>
<a name="4447"><span class="lineNum">    4447 </span><span class="lineCov">          1 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4448"><span class="lineNum">    4448 </span><span class="lineNoCov">          0 :           printf (&quot;Converting a SgVarRefExp to a SgFunctionCallExp \n&quot;);</span></a>
<a name="4449"><span class="lineNum">    4449 </span>            : </a>
<a name="4450"><span class="lineNum">    4450 </span><span class="lineCov">          1 :      SgExprListExp* expressionList = new SgExprListExp();</span></a>
<a name="4451"><span class="lineNum">    4451 </span><span class="lineCov">          1 :      ROSE_ASSERT(expressionList != NULL);</span></a>
<a name="4452"><span class="lineNum">    4452 </span><span class="lineCov">          1 :      setSourcePosition(expressionList);</span></a>
<a name="4453"><span class="lineNum">    4453 </span><span class="lineCov">          1 :      astExpressionStack.push_front(expressionList);</span></a>
<a name="4454"><span class="lineNum">    4454 </span>            : </a>
<a name="4455"><span class="lineNum">    4455 </span>            :   // Sg_File_Info* filePosition = varRefExp-&gt;get_file_info();</a>
<a name="4456"><span class="lineNum">    4456 </span>            :   // ROSE_ASSERT(filePosition != NULL);</a>
<a name="4457"><span class="lineNum">    4457 </span>            :   // filePosition-&gt;display(&quot;In c_action_procedure_designator()&quot;);</a>
<a name="4458"><span class="lineNum">    4458 </span>            : </a>
<a name="4459"><span class="lineNum">    4459 </span>            :   // Token_t* nameToken = create_token(filePosition-&gt;get_line(),filePosition-&gt;get_col(),0,name.str());</a>
<a name="4460"><span class="lineNum">    4460 </span>            : </a>
<a name="4461"><span class="lineNum">    4461 </span><span class="lineCov">          1 :      ROSE_ASSERT(nameToken != NULL);</span></a>
<a name="4462"><span class="lineNum">    4462 </span>            : </a>
<a name="4463"><span class="lineNum">    4463 </span>            :   // printf (&quot;In convertVariableSymbolToFunctionCallExp(): This function call to generateFunctionCall() is ignoring its new SgFunctionSymbol return type. \n&quot;);</a>
<a name="4464"><span class="lineNum">    4464 </span>            : </a>
<a name="4465"><span class="lineNum">    4465 </span><span class="lineCov">          1 :      generateFunctionCall(nameToken);</span></a>
<a name="4466"><span class="lineNum">    4466 </span><span class="lineCov">          1 :    }</span></a>
<a name="4467"><span class="lineNum">    4467 </span>            : </a>
<a name="4468"><span class="lineNum">    4468 </span>            : void</a>
<a name="4469"><span class="lineNum">    4469 </span><span class="lineCov">         10 : convertExpressionOnStackToFunctionCallExp()</span></a>
<a name="4470"><span class="lineNum">    4470 </span>            :    {</a>
<a name="4471"><span class="lineNum">    4471 </span>            :   // This function is only called by R1219 c_action_procedure_designator()</a>
<a name="4472"><span class="lineNum">    4472 </span>            : </a>
<a name="4473"><span class="lineNum">    4473 </span>            :   // This function takes a varRefExp on the astExpressionStack and converts it to a function call of the same name.</a>
<a name="4474"><span class="lineNum">    4474 </span>            :   // This addresses to need to be able to change the type of construct represented initially with little information </a>
<a name="4475"><span class="lineNum">    4475 </span>            :   // and so for which we assumed it was a variable and only later in the sequence of parsing actions discovered that </a>
<a name="4476"><span class="lineNum">    4476 </span>            :   // it was a function.  In general everything is a function unless there is a hint that it is an array.</a>
<a name="4477"><span class="lineNum">    4477 </span>            : </a>
<a name="4478"><span class="lineNum">    4478 </span>            : #if 0</a>
<a name="4479"><span class="lineNum">    4479 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="4480"><span class="lineNum">    4480 </span>            :      outputState(&quot;At TOP of convertExpressionOnStackToFunctionCallExp()&quot;);</a>
<a name="4481"><span class="lineNum">    4481 </span>            : #endif</a>
<a name="4482"><span class="lineNum">    4482 </span>            : </a>
<a name="4483"><span class="lineNum">    4483 </span><span class="lineCov">         10 :      ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="4484"><span class="lineNum">    4484 </span><span class="lineCov">         10 :      SgExpression* expression = astExpressionStack.front();</span></a>
<a name="4485"><span class="lineNum">    4485 </span>            :   // printf (&quot;In convertExpressionOnStackToFunctionCallExp(): expression = %p = %s \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="4486"><span class="lineNum">    4486 </span><span class="lineCov">         10 :      SgVarRefExp* varRefExp = isSgVarRefExp(expression);</span></a>
<a name="4487"><span class="lineNum">    4487 </span><span class="lineCov">         10 :      if (varRefExp != NULL)</span></a>
<a name="4488"><span class="lineNum">    4488 </span>            :         {</a>
<a name="4489"><span class="lineNum">    4489 </span>            :        // Take the varRefExp off the expression stack.</a>
<a name="4490"><span class="lineNum">    4490 </span><span class="lineCov">          1 :           astExpressionStack.pop_front();</span></a>
<a name="4491"><span class="lineNum">    4491 </span><span class="lineCov">          1 :           SgVariableSymbol* variableSymbol = varRefExp-&gt;get_symbol();</span></a>
<a name="4492"><span class="lineNum">    4492 </span>            : </a>
<a name="4493"><span class="lineNum">    4493 </span><span class="lineCov">          2 :           SgName name = variableSymbol-&gt;get_name();</span></a>
<a name="4494"><span class="lineNum">    4494 </span><span class="lineCov">          1 :           Sg_File_Info* filePosition = varRefExp-&gt;get_file_info();</span></a>
<a name="4495"><span class="lineNum">    4495 </span><span class="lineCov">          1 :           ROSE_ASSERT(filePosition != NULL);</span></a>
<a name="4496"><span class="lineNum">    4496 </span><span class="lineCov">          1 :           Token_t* nameToken = create_token(filePosition-&gt;get_line(),filePosition-&gt;get_col(),0,name.str());</span></a>
<a name="4497"><span class="lineNum">    4497 </span>            : </a>
<a name="4498"><span class="lineNum">    4498 </span><span class="lineCov">          1 :           convertVariableSymbolToFunctionCallExp(variableSymbol,nameToken);</span></a>
<a name="4499"><span class="lineNum">    4499 </span>            :         }</a>
<a name="4500"><span class="lineNum">    4500 </span>            :        else</a>
<a name="4501"><span class="lineNum">    4501 </span>            :         {</a>
<a name="4502"><span class="lineNum">    4502 </span>            :        // DQ (1/20/2008): Added support to fix test2007_164.f (calling functions without the &quot;()&quot; syntax)</a>
<a name="4503"><span class="lineNum">    4503 </span><span class="lineCov">          9 :           SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(expression);</span></a>
<a name="4504"><span class="lineNum">    4504 </span><span class="lineCov">          9 :           if (functionRefExp != NULL)</span></a>
<a name="4505"><span class="lineNum">    4505 </span>            :              {</a>
<a name="4506"><span class="lineNum">    4506 </span><span class="lineNoCov">          0 :                SgExprListExp* functionArguments = new SgExprListExp();</span></a>
<a name="4507"><span class="lineNum">    4507 </span><span class="lineNoCov">          0 :                setSourcePosition(functionArguments);</span></a>
<a name="4508"><span class="lineNum">    4508 </span>            : </a>
<a name="4509"><span class="lineNum">    4509 </span>            :             // Take the SgFunctionRefExp off the stack</a>
<a name="4510"><span class="lineNum">    4510 </span><span class="lineNoCov">          0 :                astExpressionStack.pop_front();</span></a>
<a name="4511"><span class="lineNum">    4511 </span>            : </a>
<a name="4512"><span class="lineNum">    4512 </span><span class="lineNoCov">          0 :                SgFunctionCallExp* functionCallExp  = new SgFunctionCallExp(functionRefExp,functionArguments,NULL);</span></a>
<a name="4513"><span class="lineNum">    4513 </span><span class="lineNoCov">          0 :                setSourcePosition(functionCallExp);</span></a>
<a name="4514"><span class="lineNum">    4514 </span>            : </a>
<a name="4515"><span class="lineNum">    4515 </span>            :             // Now push the function call to the implicit function onto the astExpressionStack</a>
<a name="4516"><span class="lineNum">    4516 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(functionCallExp != NULL);</span></a>
<a name="4517"><span class="lineNum">    4517 </span><span class="lineNoCov">          0 :                astExpressionStack.push_front(functionCallExp);</span></a>
<a name="4518"><span class="lineNum">    4518 </span>            :              }</a>
<a name="4519"><span class="lineNum">    4519 </span>            :             else</a>
<a name="4520"><span class="lineNum">    4520 </span>            :              {</a>
<a name="4521"><span class="lineNum">    4521 </span>            :             // printf (&quot;In convertExpressionOnStackToFunctionCallExp(): expression = %p = %s \n&quot;,expression,expression-&gt;class_name().c_str());</a>
<a name="4522"><span class="lineNum">    4522 </span>            :              }</a>
<a name="4523"><span class="lineNum">    4523 </span>            :         }</a>
<a name="4524"><span class="lineNum">    4524 </span><span class="lineCov">         10 :    }</span></a>
<a name="4525"><span class="lineNum">    4525 </span>            : </a>
<a name="4526"><span class="lineNum">    4526 </span>            : </a>
<a name="4527"><span class="lineNum">    4527 </span>            : // Note: it might make more sense for &quot;convert&quot; function to not have return types and leave their result on the stack.</a>
<a name="4528"><span class="lineNum">    4528 </span>            : SgArrayType*</a>
<a name="4529"><span class="lineNum">    4529 </span><span class="lineNoCov">          0 : convertTypeOnStackToArrayType( int count )</span></a>
<a name="4530"><span class="lineNum">    4530 </span>            :    {</a>
<a name="4531"><span class="lineNum">    4531 </span>            :   // This function uses the entry on the top of the type stack and the expressions on the astExpressionStack</a>
<a name="4532"><span class="lineNum">    4532 </span>            :   // and replaced the top o the typeStack with a SgArrayType.  This conversion of base type to array type is</a>
<a name="4533"><span class="lineNum">    4533 </span>            :   // required because we often find out later after having declarated a variable that it is an array (either</a>
<a name="4534"><span class="lineNum">    4534 </span>            :   // in the process of building the variable declaration or because an &quot;allocatable statement&quot; is seen after</a>
<a name="4535"><span class="lineNum">    4535 </span>            :   // the variable declaration).</a>
<a name="4536"><span class="lineNum">    4536 </span>            : </a>
<a name="4537"><span class="lineNum">    4537 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4538"><span class="lineNum">    4538 </span><span class="lineNoCov">          0 :           printf (&quot;In convertTypeOnStackToArrayType(count = %d) \n&quot;,count);</span></a>
<a name="4539"><span class="lineNum">    4539 </span>            : </a>
<a name="4540"><span class="lineNum">    4540 </span>            : #if 0</a>
<a name="4541"><span class="lineNum">    4541 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="4542"><span class="lineNum">    4542 </span>            :      outputState(&quot;At TOP of convertTypeOnStackToArrayType()&quot;);</a>
<a name="4543"><span class="lineNum">    4543 </span>            : #endif</a>
<a name="4544"><span class="lineNum">    4544 </span>            : </a>
<a name="4545"><span class="lineNum">    4545 </span>            :   // Use the type on the astTypeStack and build an array from it (at least if the type == 700)</a>
<a name="4546"><span class="lineNum">    4546 </span>            :   // SgType* baseType = getTopOfTypeStack();</a>
<a name="4547"><span class="lineNum">    4547 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="4548"><span class="lineNum">    4548 </span>            : </a>
<a name="4549"><span class="lineNum">    4549 </span>            :   // DQ (1/24/2011): If there is an entry on the astTypeStack then we are supposed to turn it into an array.</a>
<a name="4550"><span class="lineNum">    4550 </span>            :   // Most of the time astTypeStack.empty() == true, so this hanppend mostly for multipart </a>
<a name="4551"><span class="lineNum">    4551 </span>            :   // specifications such as &quot;character A(2)*7&quot; array of strings of length 7.</a>
<a name="4552"><span class="lineNum">    4552 </span>            :   // SgType* baseType = astBaseTypeStack.front();</a>
<a name="4553"><span class="lineNum">    4553 </span><span class="lineNoCov">          0 :      SgType* baseType = NULL;</span></a>
<a name="4554"><span class="lineNum">    4554 </span><span class="lineNoCov">          0 :      if (astTypeStack.empty() == false)</span></a>
<a name="4555"><span class="lineNum">    4555 </span>            :         {</a>
<a name="4556"><span class="lineNum">    4556 </span><span class="lineNoCov">          0 :           printf (&quot;Unusual case of declaration such as: character A(2)*7 \n&quot;);</span></a>
<a name="4557"><span class="lineNum">    4557 </span><span class="lineNoCov">          0 :           baseType = astTypeStack.front();</span></a>
<a name="4558"><span class="lineNum">    4558 </span>            :         }</a>
<a name="4559"><span class="lineNum">    4559 </span>            :        else</a>
<a name="4560"><span class="lineNum">    4560 </span>            :         {</a>
<a name="4561"><span class="lineNum">    4561 </span>            :        // This is the typical case...</a>
<a name="4562"><span class="lineNum">    4562 </span><span class="lineNoCov">          0 :           baseType = astBaseTypeStack.front();</span></a>
<a name="4563"><span class="lineNum">    4563 </span>            :         }</a>
<a name="4564"><span class="lineNum">    4564 </span>            : </a>
<a name="4565"><span class="lineNum">    4565 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(baseType != NULL);</span></a>
<a name="4566"><span class="lineNum">    4566 </span>            : </a>
<a name="4567"><span class="lineNum">    4567 </span>            :   // Leave this on the stack so that other arrays or references to it can use it as a </a>
<a name="4568"><span class="lineNum">    4568 </span>            :   // base type (e.g. for a differently dimensioned array).</a>
<a name="4569"><span class="lineNum">    4569 </span>            :   // astTypeStack.pop_front();</a>
<a name="4570"><span class="lineNum">    4570 </span>            : </a>
<a name="4571"><span class="lineNum">    4571 </span>            :   // At this point we have not seen the &quot;dimension&quot;</a>
<a name="4572"><span class="lineNum">    4572 </span>            : #if 0</a>
<a name="4573"><span class="lineNum">    4573 </span>            :   // Debugging code</a>
<a name="4574"><span class="lineNum">    4574 </span>            :      if (astAttributeSpecStack.empty() == false)</a>
<a name="4575"><span class="lineNum">    4575 </span>            :         {</a>
<a name="4576"><span class="lineNum">    4576 </span>            :           std::list&lt;int&gt;::iterator i = astAttributeSpecStack.begin();</a>
<a name="4577"><span class="lineNum">    4577 </span>            :           while (i != astAttributeSpecStack.end())</a>
<a name="4578"><span class="lineNum">    4578 </span>            :              {</a>
<a name="4579"><span class="lineNum">    4579 </span>            :                printf (&quot;astAttributeSpecStack i = %d \n&quot;,*i);</a>
<a name="4580"><span class="lineNum">    4580 </span>            :                i++;</a>
<a name="4581"><span class="lineNum">    4581 </span>            :              }</a>
<a name="4582"><span class="lineNum">    4582 </span>            :         }</a>
<a name="4583"><span class="lineNum">    4583 </span>            : #endif</a>
<a name="4584"><span class="lineNum">    4584 </span>            : </a>
<a name="4585"><span class="lineNum">    4585 </span>            :   // depending on the syntax type used to declare the array).</a>
<a name="4586"><span class="lineNum">    4586 </span>            :   // ROSE_ASSERT (astAttributeSpecStack.empty() == true);</a>
<a name="4587"><span class="lineNum">    4587 </span>            : </a>
<a name="4588"><span class="lineNum">    4588 </span>            :   // Generate a NULL expression that we can fixup later when we see a dimension statement or when we see more of the declaration.</a>
<a name="4589"><span class="lineNum">    4589 </span>            :   // Actually the p_index is used for C/C++ and the the p_dim_info is used for Fortran, we need to make this more uniform.</a>
<a name="4590"><span class="lineNum">    4590 </span><span class="lineNoCov">          0 :      SgExpression* sizeExpression = new SgNullExpression();</span></a>
<a name="4591"><span class="lineNum">    4591 </span><span class="lineNoCov">          0 :      setSourcePosition(sizeExpression);</span></a>
<a name="4592"><span class="lineNum">    4592 </span>            : </a>
<a name="4593"><span class="lineNum">    4593 </span>            : #if 0</a>
<a name="4594"><span class="lineNum">    4594 </span>            :      printf (&quot;I think we need to call the SgArrayType::createType() interface instead of new SgArrayType()\n&quot;);</a>
<a name="4595"><span class="lineNum">    4595 </span>            : #endif</a>
<a name="4596"><span class="lineNum">    4596 </span>            : </a>
<a name="4597"><span class="lineNum">    4597 </span>            :   // Build the array type</a>
<a name="4598"><span class="lineNum">    4598 </span><span class="lineNoCov">          0 :      SgArrayType* arrayType = new SgArrayType(baseType,sizeExpression);</span></a>
<a name="4599"><span class="lineNum">    4599 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(arrayType != NULL);</span></a>
<a name="4600"><span class="lineNum">    4600 </span>            : </a>
<a name="4601"><span class="lineNum">    4601 </span>            :   // Need to set the parent of the sizeExpression since we don't traverse the types to set such things in the AST postprocessing.</a>
<a name="4602"><span class="lineNum">    4602 </span><span class="lineNoCov">          0 :      sizeExpression-&gt;set_parent(arrayType);</span></a>
<a name="4603"><span class="lineNum">    4603 </span>            : </a>
<a name="4604"><span class="lineNum">    4604 </span>            :   // DQ (1/17/2011): We now use R510 to gather the indexing and build the multidimensional array dimension.</a>
<a name="4605"><span class="lineNum">    4605 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(arrayType-&gt;get_dim_info() == NULL);</span></a>
<a name="4606"><span class="lineNum">    4606 </span>            : </a>
<a name="4607"><span class="lineNum">    4607 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="4608"><span class="lineNum">    4608 </span><span class="lineNoCov">          0 :      SgExprListExp* expresssionList = isSgExprListExp(astExpressionStack.front());</span></a>
<a name="4609"><span class="lineNum">    4609 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(expresssionList != NULL);</span></a>
<a name="4610"><span class="lineNum">    4610 </span><span class="lineNoCov">          0 :      astExpressionStack.pop_front();</span></a>
<a name="4611"><span class="lineNum">    4611 </span><span class="lineNoCov">          0 :      arrayType-&gt;set_dim_info(expresssionList);</span></a>
<a name="4612"><span class="lineNum">    4612 </span>            :   // setSourcePosition(expresssionList);</a>
<a name="4613"><span class="lineNum">    4613 </span><span class="lineNoCov">          0 :      expresssionList-&gt;set_parent(arrayType);</span></a>
<a name="4614"><span class="lineNum">    4614 </span>            : </a>
<a name="4615"><span class="lineNum">    4615 </span>            :   // Mark the rank as count, even though we have not seen the dimension expressions yet.</a>
<a name="4616"><span class="lineNum">    4616 </span><span class="lineNoCov">          0 :      arrayType-&gt;set_rank(expresssionList-&gt;get_expressions().size());</span></a>
<a name="4617"><span class="lineNum">    4617 </span>            :   // printf (&quot;arrayType built with rank = %d (set from the input count parameter) \n&quot;,arrayType-&gt;get_rank());</a>
<a name="4618"><span class="lineNum">    4618 </span>            : </a>
<a name="4619"><span class="lineNum">    4619 </span>            :   // Set the scope so that we can cal unparseToString()</a>
<a name="4620"><span class="lineNum">    4620 </span>            :   // sizeExpression-&gt;set_scope(getTopOfScopeStack());</a>
<a name="4621"><span class="lineNum">    4621 </span>            : </a>
<a name="4622"><span class="lineNum">    4622 </span>            :   // printf (&quot;sizeExpression-&gt;unparseToString() = %s \n&quot;,sizeExpression-&gt;unparseToString().c_str());</a>
<a name="4623"><span class="lineNum">    4623 </span>            : </a>
<a name="4624"><span class="lineNum">    4624 </span>            :   // This is an error since we never know when it is the base_type and when it is an original type in a variable declaration.</a>
<a name="4625"><span class="lineNum">    4625 </span>            :   // Remove the base_type from the astTypeStack, before we push the new arrayType</a>
<a name="4626"><span class="lineNum">    4626 </span>            :   // astTypeStack.pop_front();</a>
<a name="4627"><span class="lineNum">    4627 </span>            : </a>
<a name="4628"><span class="lineNum">    4628 </span>            : #if 0</a>
<a name="4629"><span class="lineNum">    4629 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="4630"><span class="lineNum">    4630 </span>            :      outputState(&quot;At BOTTOM of convertTypeOnStackToArrayType()&quot;);</a>
<a name="4631"><span class="lineNum">    4631 </span>            : #endif</a>
<a name="4632"><span class="lineNum">    4632 </span>            : </a>
<a name="4633"><span class="lineNum">    4633 </span>            :   // printf (&quot;Exiting at base of convertTypeOnStackToArrayType \n&quot;);</a>
<a name="4634"><span class="lineNum">    4634 </span>            :   // ROSE_ASSERT(false);</a>
<a name="4635"><span class="lineNum">    4635 </span>            : </a>
<a name="4636"><span class="lineNum">    4636 </span>            :   // Put the array type onto the type stack</a>
<a name="4637"><span class="lineNum">    4637 </span>            :   // astTypeStack.push_front(arrayType);</a>
<a name="4638"><span class="lineNum">    4638 </span><span class="lineNoCov">          0 :      return arrayType;</span></a>
<a name="4639"><span class="lineNum">    4639 </span>            :    }</a>
<a name="4640"><span class="lineNum">    4640 </span>            : </a>
<a name="4641"><span class="lineNum">    4641 </span>            : </a>
<a name="4642"><span class="lineNum">    4642 </span>            : void</a>
<a name="4643"><span class="lineNum">    4643 </span><span class="lineCov">          2 : processFunctionPrefix( SgFunctionDeclaration* functionDeclaration )</span></a>
<a name="4644"><span class="lineNum">    4644 </span>            :    {</a>
<a name="4645"><span class="lineNum">    4645 </span><span class="lineCov">          2 :      while (astFunctionAttributeStack.empty() == false)</span></a>
<a name="4646"><span class="lineNum">    4646 </span>            :         {</a>
<a name="4647"><span class="lineNum">    4647 </span>            :        // string prefixString = astNameStack.front()-&gt;text;</a>
<a name="4648"><span class="lineNum">    4648 </span><span class="lineNoCov">          0 :           string prefixString = astFunctionAttributeStack.front()-&gt;text;</span></a>
<a name="4649"><span class="lineNum">    4649 </span>            : </a>
<a name="4650"><span class="lineNum">    4650 </span>            :        // printf (&quot;prefixString = %s \n&quot;,prefixString.c_str());</a>
<a name="4651"><span class="lineNum">    4651 </span>            :        // astNameStack.pop_front();</a>
<a name="4652"><span class="lineNum">    4652 </span><span class="lineNoCov">          0 :           astFunctionAttributeStack.pop_front();</span></a>
<a name="4653"><span class="lineNum">    4653 </span>            : </a>
<a name="4654"><span class="lineNum">    4654 </span>            :        // This needs to be a case insensitive test for equality (use C since C++ does not have a simple mechanism for this).</a>
<a name="4655"><span class="lineNum">    4655 </span><span class="lineNoCov">          0 :           if ( strncasecmp(prefixString.c_str(),&quot;pure&quot;,4) == 0 )</span></a>
<a name="4656"><span class="lineNum">    4656 </span>            :              {</a>
<a name="4657"><span class="lineNum">    4657 </span>            :             // printf (&quot;Marking this function as PURE \n&quot;);</a>
<a name="4658"><span class="lineNum">    4658 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;get_functionModifier().setPure();</span></a>
<a name="4659"><span class="lineNum">    4659 </span>            :              }</a>
<a name="4660"><span class="lineNum">    4660 </span><span class="lineNoCov">          0 :             else if ( strncasecmp(prefixString.c_str(),&quot;elemental&quot;,9) == 0 )</span></a>
<a name="4661"><span class="lineNum">    4661 </span>            :              {</a>
<a name="4662"><span class="lineNum">    4662 </span>            :             // printf (&quot;Marking this function as ELEMENTAL \n&quot;);</a>
<a name="4663"><span class="lineNum">    4663 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;get_functionModifier().setElemental();</span></a>
<a name="4664"><span class="lineNum">    4664 </span>            :              }</a>
<a name="4665"><span class="lineNum">    4665 </span><span class="lineNoCov">          0 :             else if ( strncasecmp(prefixString.c_str(),&quot;recursive&quot;,9) == 0 )</span></a>
<a name="4666"><span class="lineNum">    4666 </span>            :              {</a>
<a name="4667"><span class="lineNum">    4667 </span>            :             // printf (&quot;Marking this function as RECURSIVE \n&quot;);</a>
<a name="4668"><span class="lineNum">    4668 </span><span class="lineNoCov">          0 :                functionDeclaration-&gt;get_functionModifier().setRecursive();</span></a>
<a name="4669"><span class="lineNum">    4669 </span>            :              }</a>
<a name="4670"><span class="lineNum">    4670 </span>            :         }</a>
<a name="4671"><span class="lineNum">    4671 </span><span class="lineCov">          2 :    }</span></a>
<a name="4672"><span class="lineNum">    4672 </span>            : </a>
<a name="4673"><span class="lineNum">    4673 </span>            : </a>
<a name="4674"><span class="lineNum">    4674 </span>            : </a>
<a name="4675"><span class="lineNum">    4675 </span>            : SgFunctionRefExp*</a>
<a name="4676"><span class="lineNum">    4676 </span><span class="lineCov">        457 : generateFunctionRefExp( Token_t* nameToken )</span></a>
<a name="4677"><span class="lineNum">    4677 </span>            :    {</a>
<a name="4678"><span class="lineNum">    4678 </span>            :   // This function will generate a SgFunctionRefExp using just the function name and the current scope.</a>
<a name="4679"><span class="lineNum">    4679 </span>            :   // If the function is found in a symbol table (iterating from the current scope to the global scope)</a>
<a name="4680"><span class="lineNum">    4680 </span>            :   // then the SgFunctionRefExp is built using the found SgFunctionSymbol.  </a>
<a name="4681"><span class="lineNum">    4681 </span>            :   // If no SgFunctionSymbol is found in the symbol tables from iterating through all the scopes, then </a>
<a name="4682"><span class="lineNum">    4682 </span>            :   // a new SgProcedureHeaderStatement (function declaration) is built and an associated SgFunctionSymbol </a>
<a name="4683"><span class="lineNum">    4683 </span>            :   // is inserted into the global scope.  </a>
<a name="4684"><span class="lineNum">    4684 </span>            : </a>
<a name="4685"><span class="lineNum">    4685 </span>            :   // Note that the global scope may not be correct if the function will be seen later in </a>
<a name="4686"><span class="lineNum">    4686 </span>            :   // a different scope (e.g. the current module's scope).  So a fixup is required and is </a>
<a name="4687"><span class="lineNum">    4687 </span>            :   // called from R1106 c_action_end_module_stmt().</a>
<a name="4688"><span class="lineNum">    4688 </span>            : </a>
<a name="4689"><span class="lineNum">    4689 </span><span class="lineCov">        457 :      ROSE_ASSERT(nameToken != NULL);</span></a>
<a name="4690"><span class="lineNum">    4690 </span><span class="lineCov">        457 :      std::string name = nameToken-&gt;text;</span></a>
<a name="4691"><span class="lineNum">    4691 </span>            : </a>
<a name="4692"><span class="lineNum">    4692 </span><span class="lineCov">        457 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4693"><span class="lineNum">    4693 </span><span class="lineNoCov">          0 :           printf (&quot;Generating a SgFunctionRefExp for name = %s \n&quot;,name.c_str());</span></a>
<a name="4694"><span class="lineNum">    4694 </span>            : </a>
<a name="4695"><span class="lineNum">    4695 </span><span class="lineCov">        914 :      SgFunctionType* functionType = generateImplicitFunctionType(name);</span></a>
<a name="4696"><span class="lineNum">    4696 </span><span class="lineCov">        457 :      ROSE_ASSERT(functionType != NULL);</span></a>
<a name="4697"><span class="lineNum">    4697 </span>            : </a>
<a name="4698"><span class="lineNum">    4698 </span>            :   // The next element on the stack is the expression list of function arguments</a>
<a name="4699"><span class="lineNum">    4699 </span>            :   // ROSE_ASSERT(astExpressionStack.empty() == false);</a>
<a name="4700"><span class="lineNum">    4700 </span>            :   // SgExprListExp* functionArguments = isSgExprListExp(astExpressionStack.front());</a>
<a name="4701"><span class="lineNum">    4701 </span>            :   // astExpressionStack.pop_front();</a>
<a name="4702"><span class="lineNum">    4702 </span>            : </a>
<a name="4703"><span class="lineNum">    4703 </span><span class="lineCov">        457 :      SgFunctionRefExp* functionRefExp = NULL;</span></a>
<a name="4704"><span class="lineNum">    4704 </span><span class="lineCov">        914 :      SgName functionName              = nameToken-&gt;text;</span></a>
<a name="4705"><span class="lineNum">    4705 </span><span class="lineCov">        457 :      SgFunctionSymbol* functionSymbol = trace_back_through_parent_scopes_lookup_function_symbol(functionName,astScopeStack.front());</span></a>
<a name="4706"><span class="lineNum">    4706 </span>            : </a>
<a name="4707"><span class="lineNum">    4707 </span>            : #if 0</a>
<a name="4708"><span class="lineNum">    4708 </span>            :      printf (&quot;In generateFunctionRefExp(): called trace_back_through_parent_scopes_lookup_function_symbol() -- functionSymbol = %p \n&quot;,functionSymbol);</a>
<a name="4709"><span class="lineNum">    4709 </span>            : #endif</a>
<a name="4710"><span class="lineNum">    4710 </span>            : </a>
<a name="4711"><span class="lineNum">    4711 </span><span class="lineCov">        457 :      if (functionSymbol != NULL)</span></a>
<a name="4712"><span class="lineNum">    4712 </span>            :         {</a>
<a name="4713"><span class="lineNum">    4713 </span>            :        // Found the function symbol, so build the function ref expression using the existing symbol...</a>
<a name="4714"><span class="lineNum">    4714 </span>            :        // printf (&quot;Found the function symbol, so build the function ref expression using the existing symbol... \n&quot;);</a>
<a name="4715"><span class="lineNum">    4715 </span>            : </a>
<a name="4716"><span class="lineNum">    4716 </span><span class="lineCov">         79 :           functionRefExp = new SgFunctionRefExp(functionSymbol,NULL);</span></a>
<a name="4717"><span class="lineNum">    4717 </span><span class="lineCov">         79 :           setSourcePosition(functionRefExp);</span></a>
<a name="4718"><span class="lineNum">    4718 </span>            :         }</a>
<a name="4719"><span class="lineNum">    4719 </span>            :        else</a>
<a name="4720"><span class="lineNum">    4720 </span>            :         {</a>
<a name="4721"><span class="lineNum">    4721 </span>            :        // If the function has not been seen yet, it does not mean that it is an array.  It could be a function </a>
<a name="4722"><span class="lineNum">    4722 </span>            :        // to be declared later or an intrinsic function.  But the point is that it is a function!</a>
<a name="4723"><span class="lineNum">    4723 </span>            : </a>
<a name="4724"><span class="lineNum">    4724 </span>            :        // For implicit function we build non-defining declarations</a>
<a name="4725"><span class="lineNum">    4725 </span><span class="lineCov">        378 :           SgFunctionDefinition* functionDefinition = NULL;</span></a>
<a name="4726"><span class="lineNum">    4726 </span>            :        // SgFunctionDeclaration* functionDeclaration = new SgFunctionDeclaration(name,functionType,functionDefinition);</a>
<a name="4727"><span class="lineNum">    4727 </span>            :        // SgProgramHeaderStatement* functionDeclaration = new SgProgramHeaderStatement(name,functionType,functionDefinition);</a>
<a name="4728"><span class="lineNum">    4728 </span><span class="lineCov">        378 :           SgProcedureHeaderStatement* functionDeclaration = new SgProcedureHeaderStatement(name,functionType,functionDefinition);</span></a>
<a name="4729"><span class="lineNum">    4729 </span>            : </a>
<a name="4730"><span class="lineNum">    4730 </span><span class="lineCov">        378 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4731"><span class="lineNum">    4731 </span><span class="lineNoCov">          0 :                printf (&quot;Generated a SgProcedureHeaderStatement for name = %s functionDeclaration = %p \n&quot;,name.c_str(),functionDeclaration);</span></a>
<a name="4732"><span class="lineNum">    4732 </span>            : </a>
<a name="4733"><span class="lineNum">    4733 </span>            :        // This is the first function declaration for this function name so we have to set it as the firstNondefiningDeclaration.</a>
<a name="4734"><span class="lineNum">    4734 </span>            :        // Note that the first nondefining declaration is what is always used for building symbols.</a>
<a name="4735"><span class="lineNum">    4735 </span><span class="lineCov">        378 :           functionDeclaration-&gt;set_firstNondefiningDeclaration(functionDeclaration);</span></a>
<a name="4736"><span class="lineNum">    4736 </span><span class="lineCov">        378 :           functionDeclaration-&gt;set_definingDeclaration(NULL);</span></a>
<a name="4737"><span class="lineNum">    4737 </span>            : </a>
<a name="4738"><span class="lineNum">    4738 </span>            :        // Set the parent to the global scope, mostly just to have it be non-NULL (checked by internal error checking).</a>
<a name="4739"><span class="lineNum">    4739 </span><span class="lineCov">        378 :           ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="4740"><span class="lineNum">    4740 </span>            : </a>
<a name="4741"><span class="lineNum">    4741 </span>            :        // We really want the nearest module scope or global scope is there is no module scope.</a>
<a name="4742"><span class="lineNum">    4742 </span>            :        // See test2010_140.f90</a>
<a name="4743"><span class="lineNum">    4743 </span>            :        // SgScopeStatement* currentScope = astScopeStack.front();</a>
<a name="4744"><span class="lineNum">    4744 </span><span class="lineCov">        378 :           SgScopeStatement* currentScope = isSgClassDefinition(astScopeStack.front());</span></a>
<a name="4745"><span class="lineNum">    4745 </span><span class="lineCov">        378 :           if (currentScope == NULL)</span></a>
<a name="4746"><span class="lineNum">    4746 </span>            :              {</a>
<a name="4747"><span class="lineNum">    4747 </span><span class="lineCov">        378 :                currentScope = TransformationSupport::getClassDefinition(astScopeStack.front());</span></a>
<a name="4748"><span class="lineNum">    4748 </span><span class="lineCov">        378 :                if (currentScope == NULL)</span></a>
<a name="4749"><span class="lineNum">    4749 </span>            :                   {</a>
<a name="4750"><span class="lineNum">    4750 </span><span class="lineCov">        378 :                     currentScope = TransformationSupport::getGlobalScope(astScopeStack.front());</span></a>
<a name="4751"><span class="lineNum">    4751 </span><span class="lineCov">        378 :                     ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="4752"><span class="lineNum">    4752 </span>            :                   }</a>
<a name="4753"><span class="lineNum">    4753 </span>            :              }</a>
<a name="4754"><span class="lineNum">    4754 </span><span class="lineCov">        378 :           ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="4755"><span class="lineNum">    4755 </span>            : </a>
<a name="4756"><span class="lineNum">    4756 </span><span class="lineCov">        378 :           functionDeclaration-&gt;set_parent(currentScope);</span></a>
<a name="4757"><span class="lineNum">    4757 </span><span class="lineCov">        378 :           functionDeclaration-&gt;set_scope(currentScope);</span></a>
<a name="4758"><span class="lineNum">    4758 </span><span class="lineCov">        378 :           functionDeclaration-&gt;set_subprogram_kind(SgProcedureHeaderStatement::e_function_subprogram_kind); </span></a>
<a name="4759"><span class="lineNum">    4759 </span><span class="lineCov">        378 :           setSourcePosition(functionDeclaration,nameToken);</span></a>
<a name="4760"><span class="lineNum">    4760 </span>            :        // We should not have to set this explicitly!</a>
<a name="4761"><span class="lineNum">    4761 </span><span class="lineCov">        378 :           setSourcePosition(functionDeclaration-&gt;get_parameterList(),nameToken);</span></a>
<a name="4762"><span class="lineNum">    4762 </span>            : </a>
<a name="4763"><span class="lineNum">    4763 </span>            :        // Now build the function call and use the arguments from the ExprList on the top of the astExpressionStack!</a>
<a name="4764"><span class="lineNum">    4764 </span><span class="lineCov">        378 :           SgFunctionSymbol* functionSymbol = new SgFunctionSymbol(functionDeclaration);</span></a>
<a name="4765"><span class="lineNum">    4765 </span>            : </a>
<a name="4766"><span class="lineNum">    4766 </span>            :        // Insert the function into the global scope so that we can find it later</a>
<a name="4767"><span class="lineNum">    4767 </span><span class="lineCov">        378 :           currentScope-&gt;insert_symbol(functionName,functionSymbol);</span></a>
<a name="4768"><span class="lineNum">    4768 </span>            : </a>
<a name="4769"><span class="lineNum">    4769 </span><span class="lineCov">        378 :           functionRefExp = new SgFunctionRefExp(functionSymbol,NULL);</span></a>
<a name="4770"><span class="lineNum">    4770 </span><span class="lineCov">        378 :           setSourcePosition(functionRefExp);</span></a>
<a name="4771"><span class="lineNum">    4771 </span>            :         }</a>
<a name="4772"><span class="lineNum">    4772 </span>            : </a>
<a name="4773"><span class="lineNum">    4773 </span>            :   // Now push the function call to the implicit function onto the astExpressionStack</a>
<a name="4774"><span class="lineNum">    4774 </span><span class="lineCov">        457 :      ROSE_ASSERT(functionRefExp != NULL);</span></a>
<a name="4775"><span class="lineNum">    4775 </span>            :   // astExpressionStack.push_front(functionRefExp);</a>
<a name="4776"><span class="lineNum">    4776 </span>            : </a>
<a name="4777"><span class="lineNum">    4777 </span><span class="lineCov">        914 :      return functionRefExp;</span></a>
<a name="4778"><span class="lineNum">    4778 </span>            :    }</a>
<a name="4779"><span class="lineNum">    4779 </span>            : </a>
<a name="4780"><span class="lineNum">    4780 </span>            : </a>
<a name="4781"><span class="lineNum">    4781 </span>            : // DQ (12/29/2010): Modified to return the associated SgFunctionSymbol so</a>
<a name="4782"><span class="lineNum">    4782 </span>            : // that we can support greater uniformity in handling of R612 and R613.</a>
<a name="4783"><span class="lineNum">    4783 </span>            : // void generateFunctionCall( Token_t* nameToken )</a>
<a name="4784"><span class="lineNum">    4784 </span>            : SgFunctionSymbol*</a>
<a name="4785"><span class="lineNum">    4785 </span><span class="lineCov">         21 : generateFunctionCall( Token_t* nameToken )</span></a>
<a name="4786"><span class="lineNum">    4786 </span>            :    {</a>
<a name="4787"><span class="lineNum">    4787 </span><span class="lineCov">         21 :      ROSE_ASSERT(nameToken != NULL);</span></a>
<a name="4788"><span class="lineNum">    4788 </span>            : </a>
<a name="4789"><span class="lineNum">    4789 </span><span class="lineCov">         21 :      if ( ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL ) || (astExpressionStack.empty() != false) )</span></a>
<a name="4790"><span class="lineNum">    4790 </span><span class="lineNoCov">          0 :           printf (&quot;Inside of generateFunctionCall(): nameToken = %s \n&quot;,nameToken-&gt;text);</span></a>
<a name="4791"><span class="lineNum">    4791 </span>            : </a>
<a name="4792"><span class="lineNum">    4792 </span>            :   // The next element on the stack is the expression list of function arguments</a>
<a name="4793"><span class="lineNum">    4793 </span>            :   // However, test2010_169.f90 demonstrates that an implicit function can be called </a>
<a name="4794"><span class="lineNum">    4794 </span>            :   // without &quot;()&quot;, so it should not be an error to not have a SgExprListExp IR node</a>
<a name="4795"><span class="lineNum">    4795 </span>            :   // on the stack.</a>
<a name="4796"><span class="lineNum">    4796 </span>            : </a>
<a name="4797"><span class="lineNum">    4797 </span>            :   // ROSE_ASSERT(astExpressionStack.empty() == false);</a>
<a name="4798"><span class="lineNum">    4798 </span>            :   // SgExprListExp* functionArguments = isSgExprListExp(astExpressionStack.front());</a>
<a name="4799"><span class="lineNum">    4799 </span>            :   // astExpressionStack.pop_front();</a>
<a name="4800"><span class="lineNum">    4800 </span><span class="lineCov">         21 :      SgExprListExp* functionArguments = NULL;</span></a>
<a name="4801"><span class="lineNum">    4801 </span><span class="lineCov">         21 :      if (astExpressionStack.empty() == false)</span></a>
<a name="4802"><span class="lineNum">    4802 </span>            :         {</a>
<a name="4803"><span class="lineNum">    4803 </span><span class="lineCov">         21 :           functionArguments = isSgExprListExp(astExpressionStack.front());</span></a>
<a name="4804"><span class="lineNum">    4804 </span><span class="lineCov">         21 :           astExpressionStack.pop_front();</span></a>
<a name="4805"><span class="lineNum">    4805 </span>            :         }</a>
<a name="4806"><span class="lineNum">    4806 </span>            :        else</a>
<a name="4807"><span class="lineNum">    4807 </span>            :         {</a>
<a name="4808"><span class="lineNum">    4808 </span>            :        // printf (&quot;Special case of function not called with () \n&quot;);</a>
<a name="4809"><span class="lineNum">    4809 </span><span class="lineNoCov">          0 :           functionArguments = new SgExprListExp();</span></a>
<a name="4810"><span class="lineNum">    4810 </span><span class="lineNoCov">          0 :           setSourcePosition(functionArguments);</span></a>
<a name="4811"><span class="lineNum">    4811 </span>            :         }</a>
<a name="4812"><span class="lineNum">    4812 </span>            : </a>
<a name="4813"><span class="lineNum">    4813 </span>            : #if 0</a>
<a name="4814"><span class="lineNum">    4814 </span>            :      SgExpressionPtrList &amp; argList = functionArguments-&gt;get_expressions();</a>
<a name="4815"><span class="lineNum">    4815 </span>            :      printf (&quot;\n\n\n\n############### In generateFunctionCall() ################# \n&quot;);</a>
<a name="4816"><span class="lineNum">    4816 </span>            :      for (size_t i = 0; i &lt; argList.size(); i++)</a>
<a name="4817"><span class="lineNum">    4817 </span>            :         {</a>
<a name="4818"><span class="lineNum">    4818 </span>            :           printf (&quot;argList[%&quot; PRIuPTR &quot;] = %s \n&quot;,i,SageInterface::get_name(argList[i]).c_str());</a>
<a name="4819"><span class="lineNum">    4819 </span>            :         }</a>
<a name="4820"><span class="lineNum">    4820 </span>            : #endif</a>
<a name="4821"><span class="lineNum">    4821 </span>            : #if 0</a>
<a name="4822"><span class="lineNum">    4822 </span>            :      printf (&quot;Exting after test! \n&quot;);</a>
<a name="4823"><span class="lineNum">    4823 </span>            :      ROSE_ABORT();</a>
<a name="4824"><span class="lineNum">    4824 </span>            : #endif</a>
<a name="4825"><span class="lineNum">    4825 </span>            : </a>
<a name="4826"><span class="lineNum">    4826 </span>            :   // DQ (12/11/2010): If the name of this function is not found a function of this </a>
<a name="4827"><span class="lineNum">    4827 </span>            :   // name will be added to the current scope (see details in generateFunctionRefExp()).</a>
<a name="4828"><span class="lineNum">    4828 </span><span class="lineCov">         21 :      SgFunctionRefExp* functionRefExp = generateFunctionRefExp(nameToken);</span></a>
<a name="4829"><span class="lineNum">    4829 </span>            : </a>
<a name="4830"><span class="lineNum">    4830 </span><span class="lineCov">         21 :      SgFunctionCallExp* functionCallExp  = new SgFunctionCallExp(functionRefExp,functionArguments,NULL);</span></a>
<a name="4831"><span class="lineNum">    4831 </span><span class="lineCov">         21 :      setSourcePosition(functionCallExp,nameToken);</span></a>
<a name="4832"><span class="lineNum">    4832 </span>            : </a>
<a name="4833"><span class="lineNum">    4833 </span>            :   // Now push the function call to the implicit function onto the astExpressionStack</a>
<a name="4834"><span class="lineNum">    4834 </span><span class="lineCov">         21 :      ROSE_ASSERT(functionCallExp != NULL);</span></a>
<a name="4835"><span class="lineNum">    4835 </span><span class="lineCov">         21 :      astExpressionStack.push_front(functionCallExp);</span></a>
<a name="4836"><span class="lineNum">    4836 </span>            : </a>
<a name="4837"><span class="lineNum">    4837 </span>            : </a>
<a name="4838"><span class="lineNum">    4838 </span>            :   // DQ (5/14/2008): Now cleanup the SgInitializedName, the SgVariableSymbol, and the </a>
<a name="4839"><span class="lineNum">    4839 </span>            :   // SgVariableDeclarationStatement; since these are now invalid now that the name is </a>
<a name="4840"><span class="lineNum">    4840 </span>            :   // interpreted as a function call.  Note that we see R619 a little bit too late in the</a>
<a name="4841"><span class="lineNum">    4841 </span>            :   // parsing (after we have interpreted the name as a variable).</a>
<a name="4842"><span class="lineNum">    4842 </span>            : </a>
<a name="4843"><span class="lineNum">    4843 </span>            :   // Look up the name, </a>
<a name="4844"><span class="lineNum">    4844 </span><span class="lineCov">         21 :      SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="4845"><span class="lineNum">    4845 </span><span class="lineCov">         21 :      SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="4846"><span class="lineNum">    4846 </span><span class="lineCov">         21 :      SgClassSymbol*    classSymbol    = NULL;</span></a>
<a name="4847"><span class="lineNum">    4847 </span>            :      </a>
<a name="4848"><span class="lineNum">    4848 </span><span class="lineCov">         21 :      SgName variableName            = nameToken-&gt;text;</span></a>
<a name="4849"><span class="lineNum">    4849 </span><span class="lineCov">         21 :      SgScopeStatement* currentScope = astScopeStack.front();</span></a>
<a name="4850"><span class="lineNum">    4850 </span>            : </a>
<a name="4851"><span class="lineNum">    4851 </span><span class="lineCov">         21 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="4852"><span class="lineNum">    4852 </span>            : </a>
<a name="4853"><span class="lineNum">    4853 </span>            : #if 0</a>
<a name="4854"><span class="lineNum">    4854 </span>            :      printf (&quot;currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="4855"><span class="lineNum">    4855 </span>            : #endif</a>
<a name="4856"><span class="lineNum">    4856 </span>            : </a>
<a name="4857"><span class="lineNum">    4857 </span><span class="lineCov">         21 :      trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(variableName,currentScope,variableSymbol,functionSymbol,classSymbol);</span></a>
<a name="4858"><span class="lineNum">    4858 </span>            : </a>
<a name="4859"><span class="lineNum">    4859 </span>            :   // DQ (12/29/2010): Can we assert this if we just build a SgFunctionRefExp? (fails in case of test2007_158.f90).</a>
<a name="4860"><span class="lineNum">    4860 </span>            :   // ROSE_ASSERT(functionSymbol != NULL);</a>
<a name="4861"><span class="lineNum">    4861 </span>            : </a>
<a name="4862"><span class="lineNum">    4862 </span>            : #if 0</a>
<a name="4863"><span class="lineNum">    4863 </span>            :      if (functionSymbol == NULL)</a>
<a name="4864"><span class="lineNum">    4864 </span>            :         {</a>
<a name="4865"><span class="lineNum">    4865 </span>            :        // In this case the function has no declaration but is being called.  So it can have no symbol.</a>
<a name="4866"><span class="lineNum">    4866 </span>            :           printf (&quot;Interesting case of functionSymbol == NULL \n&quot;);</a>
<a name="4867"><span class="lineNum">    4867 </span>            :         }</a>
<a name="4868"><span class="lineNum">    4868 </span>            : #endif</a>
<a name="4869"><span class="lineNum">    4869 </span>            : </a>
<a name="4870"><span class="lineNum">    4870 </span><span class="lineCov">         21 :      if (variableSymbol != NULL)</span></a>
<a name="4871"><span class="lineNum">    4871 </span>            :         {</a>
<a name="4872"><span class="lineNum">    4872 </span><span class="lineCov">          1 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="4873"><span class="lineNum">    4873 </span><span class="lineNoCov">          0 :                printf (&quot;Found variableSymbol = %p nameToken = %s (erasing all traces of this variable so it can be supported as a function) \n&quot;,variableSymbol,nameToken-&gt;text);</span></a>
<a name="4874"><span class="lineNum">    4874 </span>            :        // ROSE_ASSERT(false);</a>
<a name="4875"><span class="lineNum">    4875 </span>            : </a>
<a name="4876"><span class="lineNum">    4876 </span><span class="lineCov">          1 :           SgSymbolTable* symbolTable = isSgSymbolTable(variableSymbol-&gt;get_parent());</span></a>
<a name="4877"><span class="lineNum">    4877 </span><span class="lineCov">          1 :           ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="4878"><span class="lineNum">    4878 </span>            : #if 0</a>
<a name="4879"><span class="lineNum">    4879 </span>            :           printf (&quot;Calling symbolTable-&gt;remove(variableSymbol) for variableSymbol = %p name = %s \n&quot;,variableSymbol,variableName.str());</a>
<a name="4880"><span class="lineNum">    4880 </span>            : #endif</a>
<a name="4881"><span class="lineNum">    4881 </span>            : #if 0</a>
<a name="4882"><span class="lineNum">    4882 </span>            :           symbolTable-&gt;print(&quot;symbolTable-&gt;remove(variableSymbol)&quot;);</a>
<a name="4883"><span class="lineNum">    4883 </span>            : #endif</a>
<a name="4884"><span class="lineNum">    4884 </span><span class="lineCov">          1 :           symbolTable-&gt;remove(variableSymbol);</span></a>
<a name="4885"><span class="lineNum">    4885 </span>            : #if 0</a>
<a name="4886"><span class="lineNum">    4886 </span>            :        // if (symbolTable-&gt;exists(variableSymbol) == true)</a>
<a name="4887"><span class="lineNum">    4887 </span>            :           if (symbolTable-&gt;exists(variableName) == true)</a>
<a name="4888"><span class="lineNum">    4888 </span>            :              {</a>
<a name="4889"><span class="lineNum">    4889 </span>            :                if (symbolTable-&gt;exists(variableSymbol) == true)</a>
<a name="4890"><span class="lineNum">    4890 </span>            :                   {</a>
<a name="4891"><span class="lineNum">    4891 </span>            : #if 0</a>
<a name="4892"><span class="lineNum">    4892 </span>            :                     printf (&quot;Found the variableSymbol in symbolTable = %p \n&quot;,symbolTable);</a>
<a name="4893"><span class="lineNum">    4893 </span>            : #endif</a>
<a name="4894"><span class="lineNum">    4894 </span>            :                     symbolTable-&gt;remove(variableSymbol);</a>
<a name="4895"><span class="lineNum">    4895 </span>            :                   }</a>
<a name="4896"><span class="lineNum">    4896 </span>            :                  else</a>
<a name="4897"><span class="lineNum">    4897 </span>            :                   {</a>
<a name="4898"><span class="lineNum">    4898 </span>            : #if 0</a>
<a name="4899"><span class="lineNum">    4899 </span>            :                     printf (&quot;variableSymbol NOT found in symbolTable = %p \n&quot;,symbolTable);</a>
<a name="4900"><span class="lineNum">    4900 </span>            : #endif</a>
<a name="4901"><span class="lineNum">    4901 </span>            :                   }</a>
<a name="4902"><span class="lineNum">    4902 </span>            :              }</a>
<a name="4903"><span class="lineNum">    4903 </span>            : #endif</a>
<a name="4904"><span class="lineNum">    4904 </span>            : #if 0</a>
<a name="4905"><span class="lineNum">    4905 </span>            :           printf (&quot;DONE: Calling symbolTable-&gt;remove(variableSymbol) for variableSymbol = %p \n&quot;,variableSymbol);</a>
<a name="4906"><span class="lineNum">    4906 </span>            : #endif</a>
<a name="4907"><span class="lineNum">    4907 </span><span class="lineCov">          1 :           SgInitializedName* initializedName = variableSymbol-&gt;get_declaration();</span></a>
<a name="4908"><span class="lineNum">    4908 </span><span class="lineCov">          1 :           ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="4909"><span class="lineNum">    4909 </span>            : </a>
<a name="4910"><span class="lineNum">    4910 </span><span class="lineCov">          1 :           SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName-&gt;get_parent());</span></a>
<a name="4911"><span class="lineNum">    4911 </span><span class="lineCov">          1 :           ROSE_ASSERT(variableDeclaration != NULL);</span></a>
<a name="4912"><span class="lineNum">    4912 </span>            : </a>
<a name="4913"><span class="lineNum">    4913 </span><span class="lineCov">          1 :           SgVariableDefinition* variableDefinition = isSgVariableDefinition(initializedName-&gt;get_declptr());</span></a>
<a name="4914"><span class="lineNum">    4914 </span><span class="lineCov">          1 :           ROSE_ASSERT(variableDefinition != NULL);</span></a>
<a name="4915"><span class="lineNum">    4915 </span>            : </a>
<a name="4916"><span class="lineNum">    4916 </span>            : #if 1</a>
<a name="4917"><span class="lineNum">    4917 </span>            :        // DQ (8/16/2020): Original code.</a>
<a name="4918"><span class="lineNum">    4918 </span><span class="lineCov">          1 :           delete variableDefinition;</span></a>
<a name="4919"><span class="lineNum">    4919 </span><span class="lineCov">          1 :           variableDefinition = NULL;</span></a>
<a name="4920"><span class="lineNum">    4920 </span>            : </a>
<a name="4921"><span class="lineNum">    4921 </span><span class="lineCov">          1 :           delete variableDeclaration;</span></a>
<a name="4922"><span class="lineNum">    4922 </span><span class="lineCov">          1 :           variableDeclaration = NULL;</span></a>
<a name="4923"><span class="lineNum">    4923 </span>            : </a>
<a name="4924"><span class="lineNum">    4924 </span><span class="lineCov">          1 :           delete initializedName;</span></a>
<a name="4925"><span class="lineNum">    4925 </span><span class="lineCov">          1 :           initializedName = NULL;</span></a>
<a name="4926"><span class="lineNum">    4926 </span>            : </a>
<a name="4927"><span class="lineNum">    4927 </span><span class="lineCov">          1 :           delete variableSymbol;</span></a>
<a name="4928"><span class="lineNum">    4928 </span><span class="lineCov">          1 :           variableSymbol = NULL;</span></a>
<a name="4929"><span class="lineNum">    4929 </span>            : #else</a>
<a name="4930"><span class="lineNum">    4930 </span>            :           variableDefinition  = NULL;</a>
<a name="4931"><span class="lineNum">    4931 </span>            :           variableDeclaration = NULL;</a>
<a name="4932"><span class="lineNum">    4932 </span>            :           initializedName     = NULL;</a>
<a name="4933"><span class="lineNum">    4933 </span>            :           variableSymbol      = NULL;</a>
<a name="4934"><span class="lineNum">    4934 </span>            : #endif</a>
<a name="4935"><span class="lineNum">    4935 </span>            :         }</a>
<a name="4936"><span class="lineNum">    4936 </span>            :        else</a>
<a name="4937"><span class="lineNum">    4937 </span>            :         {</a>
<a name="4938"><span class="lineNum">    4938 </span>            :        // DQ (8/28/2010): Report more diagnostics.</a>
<a name="4939"><span class="lineNum">    4939 </span>            :        // printf (&quot;Warning: In generateFunctionCall() there was no SgVariableSymbol found to convert to a SgFunctionSymbol \n&quot;);</a>
<a name="4940"><span class="lineNum">    4940 </span>            :         }</a>
<a name="4941"><span class="lineNum">    4941 </span>            : </a>
<a name="4942"><span class="lineNum">    4942 </span>            :   // This works the 2nd time because the function id by default defined in global scope and the variable symbol just removed </a>
<a name="4943"><span class="lineNum">    4943 </span>            :   // was in the function's body (where the function was called).</a>
<a name="4944"><span class="lineNum">    4944 </span>            :   // printf (&quot;In generateFunctionCall(): second try to isolate the functionSymbol! \n&quot;);</a>
<a name="4945"><span class="lineNum">    4945 </span><span class="lineCov">         21 :      trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(variableName,currentScope,variableSymbol,functionSymbol,classSymbol);</span></a>
<a name="4946"><span class="lineNum">    4946 </span>            : </a>
<a name="4947"><span class="lineNum">    4947 </span>            :   // DQ (12/29/2010): Can we assert this if we just build a SgFunctionRefExp? (fails in case of test2007_158.f90).</a>
<a name="4948"><span class="lineNum">    4948 </span><span class="lineCov">         21 :      ROSE_ASSERT(functionSymbol != NULL);</span></a>
<a name="4949"><span class="lineNum">    4949 </span>            : </a>
<a name="4950"><span class="lineNum">    4950 </span>            : #if 0</a>
<a name="4951"><span class="lineNum">    4951 </span>            :      if (functionSymbol == NULL)</a>
<a name="4952"><span class="lineNum">    4952 </span>            :         {</a>
<a name="4953"><span class="lineNum">    4953 </span>            :        // In this case the function has no declaration but is being called.  So it can have no symbol.</a>
<a name="4954"><span class="lineNum">    4954 </span>            :           printf (&quot;Interesting case #2 of functionSymbol == NULL \n&quot;);</a>
<a name="4955"><span class="lineNum">    4955 </span>            :         }</a>
<a name="4956"><span class="lineNum">    4956 </span>            : #endif</a>
<a name="4957"><span class="lineNum">    4957 </span>            : </a>
<a name="4958"><span class="lineNum">    4958 </span><span class="lineCov">         21 :      return functionSymbol;</span></a>
<a name="4959"><span class="lineNum">    4959 </span>            :    }</a>
<a name="4960"><span class="lineNum">    4960 </span>            : </a>
<a name="4961"><span class="lineNum">    4961 </span>            : </a>
<a name="4962"><span class="lineNum">    4962 </span>            : void</a>
<a name="4963"><span class="lineNum">    4963 </span><span class="lineCov">         13 : buildProcedureSupport(SgProcedureHeaderStatement* procedureDeclaration, bool hasDummyArgList)</span></a>
<a name="4964"><span class="lineNum">    4964 </span>            :    {</a>
<a name="4965"><span class="lineNum">    4965 </span>            :   // This does not do everything required to build a function or subroutine, but it does as much as possible</a>
<a name="4966"><span class="lineNum">    4966 </span>            :   // (factors out code so that it can be called for R1117, R1224, and R1232.</a>
<a name="4967"><span class="lineNum">    4967 </span>            : </a>
<a name="4968"><span class="lineNum">    4968 </span>            :   // This will be the defining declaration</a>
<a name="4969"><span class="lineNum">    4969 </span><span class="lineCov">         13 :      ROSE_ASSERT(procedureDeclaration != NULL);</span></a>
<a name="4970"><span class="lineNum">    4970 </span>            : </a>
<a name="4971"><span class="lineNum">    4971 </span><span class="lineCov">         13 :      procedureDeclaration-&gt;set_definingDeclaration(procedureDeclaration);</span></a>
<a name="4972"><span class="lineNum">    4972 </span><span class="lineCov">         13 :      procedureDeclaration-&gt;set_firstNondefiningDeclaration(NULL);</span></a>
<a name="4973"><span class="lineNum">    4973 </span>            : </a>
<a name="4974"><span class="lineNum">    4974 </span><span class="lineCov">         13 :      ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="4975"><span class="lineNum">    4975 </span><span class="lineCov">         13 :      SgScopeStatement* currentScopeOfFunctionDeclaration = astScopeStack.front();</span></a>
<a name="4976"><span class="lineNum">    4976 </span>            : </a>
<a name="4977"><span class="lineNum">    4977 </span><span class="lineCov">         13 :      ROSE_ASSERT(currentScopeOfFunctionDeclaration != NULL);</span></a>
<a name="4978"><span class="lineNum">    4978 </span>            : </a>
<a name="4979"><span class="lineNum">    4979 </span>            :   // This should not be a SgFunctionDefinition, but it can be a SgBasicBlock (currently) if it is declared in an Interface.</a>
<a name="4980"><span class="lineNum">    4980 </span>            :   // ROSE_ASSERT(isSgBasicBlock(currentScopeOfFunctionDeclaration) == NULL);</a>
<a name="4981"><span class="lineNum">    4981 </span><span class="lineCov">         13 :      ROSE_ASSERT(isSgFunctionDefinition(currentScopeOfFunctionDeclaration) == NULL);</span></a>
<a name="4982"><span class="lineNum">    4982 </span>            : </a>
<a name="4983"><span class="lineNum">    4983 </span><span class="lineCov">         13 :      if (astInterfaceStack.empty() == false)</span></a>
<a name="4984"><span class="lineNum">    4984 </span>            :         {</a>
<a name="4985"><span class="lineNum">    4985 </span><span class="lineNoCov">          0 :           SgInterfaceStatement* interfaceStatement = astInterfaceStack.front();</span></a>
<a name="4986"><span class="lineNum">    4986 </span>            : </a>
<a name="4987"><span class="lineNum">    4987 </span>            :        // DQ (10/6/2008): The use of the SgInterfaceBody IR nodes allows the details of if </a>
<a name="4988"><span class="lineNum">    4988 </span>            :        // it was a procedure name or a procedure declaration to be abstracted away and saves </a>
<a name="4989"><span class="lineNum">    4989 </span>            :        // this detail of how it was structured in the source code in the AST (for the unparser).</a>
<a name="4990"><span class="lineNum">    4990 </span><span class="lineNoCov">          0 :           SgName name = procedureDeclaration-&gt;get_name();</span></a>
<a name="4991"><span class="lineNum">    4991 </span>            :        // Pei-Hung (04/07/2020): procedureDeclaration from other modules should not be added into</a>
<a name="4992"><span class="lineNum">    4992 </span>            :        // the SgInterfaceBody.  Check if interfaceStatement and the procedureDeclaration are in</a>
<a name="4993"><span class="lineNum">    4993 </span>            :        // the same scope.</a>
<a name="4994"><span class="lineNum">    4994 </span><span class="lineNoCov">          0 :           SgScopeStatement* interfaceStmtScope = interfaceStatement-&gt;get_scope();</span></a>
<a name="4995"><span class="lineNum">    4995 </span><span class="lineNoCov">          0 :           if (SgProject::get_verbose() &gt; DEBUG_RULE_COMMENT_LEVEL)</span></a>
<a name="4996"><span class="lineNum">    4996 </span>            :              {</a>
<a name="4997"><span class="lineNum">    4997 </span><span class="lineNoCov">          0 :                printf(&quot;interfacestmt %p scope: %p\n&quot;,interfaceStatement, interfaceStmtScope);</span></a>
<a name="4998"><span class="lineNum">    4998 </span><span class="lineNoCov">          0 :                printf(&quot;procedure %p scope: %p\n&quot;,procedureDeclaration, currentScopeOfFunctionDeclaration);</span></a>
<a name="4999"><span class="lineNum">    4999 </span>            :              }</a>
<a name="5000"><span class="lineNum">    5000 </span><span class="lineNoCov">          0 :           if (interfaceStmtScope == currentScopeOfFunctionDeclaration)</span></a>
<a name="5001"><span class="lineNum">    5001 </span>            :              {</a>
<a name="5002"><span class="lineNum">    5002 </span><span class="lineNoCov">          0 :                SgInterfaceBody* interfaceBody = new SgInterfaceBody(name,procedureDeclaration,/*use_function_name*/ false);</span></a>
<a name="5003"><span class="lineNum">    5003 </span><span class="lineNoCov">          0 :                procedureDeclaration-&gt;set_parent(interfaceStatement);</span></a>
<a name="5004"><span class="lineNum">    5004 </span><span class="lineNoCov">          0 :                interfaceStatement-&gt;get_interface_body_list().push_back(interfaceBody);</span></a>
<a name="5005"><span class="lineNum">    5005 </span><span class="lineNoCov">          0 :                interfaceBody-&gt;set_parent(interfaceStatement);</span></a>
<a name="5006"><span class="lineNum">    5006 </span><span class="lineNoCov">          0 :                setSourcePosition(interfaceBody);</span></a>
<a name="5007"><span class="lineNum">    5007 </span>            :             }</a>
<a name="5008"><span class="lineNum">    5008 </span>            :         }</a>
<a name="5009"><span class="lineNum">    5009 </span>            :        else</a>
<a name="5010"><span class="lineNum">    5010 </span>            :         {</a>
<a name="5011"><span class="lineNum">    5011 </span>            :        // The function was not processed as part of an interface so add it to the current scope.</a>
<a name="5012"><span class="lineNum">    5012 </span><span class="lineCov">         13 :           currentScopeOfFunctionDeclaration-&gt;append_statement(procedureDeclaration);</span></a>
<a name="5013"><span class="lineNum">    5013 </span>            :         }</a>
<a name="5014"><span class="lineNum">    5014 </span>            : </a>
<a name="5015"><span class="lineNum">    5015 </span>            :   // Go looking for if this was a previously declared function</a>
<a name="5016"><span class="lineNum">    5016 </span>            :   // SgFunctionSymbol* functionSymbol = trace_back_through_parent_scopes_lookup_function_symbol(procedureDeclaration-&gt;get_name(),astScopeStack.front());</a>
<a name="5017"><span class="lineNum">    5017 </span><span class="lineCov">         13 :      SgFunctionSymbol* functionSymbol = trace_back_through_parent_scopes_lookup_function_symbol(procedureDeclaration-&gt;get_name(),currentScopeOfFunctionDeclaration);</span></a>
<a name="5018"><span class="lineNum">    5018 </span>            : </a>
<a name="5019"><span class="lineNum">    5019 </span>            : #if 0</a>
<a name="5020"><span class="lineNum">    5020 </span>            :      printf (&quot;In buildProcedureSupport(): functionSymbol = %p from trace_back_through_parent_scopes_lookup_function_symbol() \n&quot;,functionSymbol);</a>
<a name="5021"><span class="lineNum">    5021 </span>            :   // printf (&quot;In buildProcedureSupport(): procedureDeclaration scope = %p = %s \n&quot;,procedureDeclaration-&gt;get_scope(),procedureDeclaration-&gt;get_scope()-&gt;class_name().c_str());</a>
<a name="5022"><span class="lineNum">    5022 </span>            :      printf (&quot;In buildProcedureSupport(): procedureDeclaration scope = %p \n&quot;,procedureDeclaration-&gt;get_scope());</a>
<a name="5023"><span class="lineNum">    5023 </span>            :      printf (&quot;In buildProcedureSupport(): currentScopeOfFunctionDeclaration = %p = %s \n&quot;,currentScopeOfFunctionDeclaration,currentScopeOfFunctionDeclaration-&gt;class_name().c_str());</a>
<a name="5024"><span class="lineNum">    5024 </span>            : #endif</a>
<a name="5025"><span class="lineNum">    5025 </span>            : </a>
<a name="5026"><span class="lineNum">    5026 </span><span class="lineCov">         13 :      if (functionSymbol != NULL)</span></a>
<a name="5027"><span class="lineNum">    5027 </span>            :         {</a>
<a name="5028"><span class="lineNum">    5028 </span><span class="lineCov">          3 :           SgFunctionDeclaration* nondefiningDeclaration = functionSymbol-&gt;get_declaration();</span></a>
<a name="5029"><span class="lineNum">    5029 </span><span class="lineCov">          3 :           ROSE_ASSERT(nondefiningDeclaration != NULL);</span></a>
<a name="5030"><span class="lineNum">    5030 </span>            : </a>
<a name="5031"><span class="lineNum">    5031 </span><span class="lineCov">          3 :           procedureDeclaration-&gt;set_firstNondefiningDeclaration(nondefiningDeclaration);</span></a>
<a name="5032"><span class="lineNum">    5032 </span>            : </a>
<a name="5033"><span class="lineNum">    5033 </span>            :        // And set the defining declaration in the non-defining declaration</a>
<a name="5034"><span class="lineNum">    5034 </span><span class="lineCov">          3 :           nondefiningDeclaration-&gt;set_definingDeclaration(procedureDeclaration);</span></a>
<a name="5035"><span class="lineNum">    5035 </span>            : </a>
<a name="5036"><span class="lineNum">    5036 </span>            :        // update scope information</a>
<a name="5037"><span class="lineNum">    5037 </span><span class="lineCov">          3 :           if (nondefiningDeclaration-&gt;get_scope()-&gt;symbol_exists(functionSymbol))</span></a>
<a name="5038"><span class="lineNum">    5038 </span>            :              {</a>
<a name="5039"><span class="lineNum">    5039 </span><span class="lineCov">          3 :                 nondefiningDeclaration-&gt;get_scope()-&gt;remove_symbol(functionSymbol);</span></a>
<a name="5040"><span class="lineNum">    5040 </span>            :              }</a>
<a name="5041"><span class="lineNum">    5041 </span><span class="lineCov">          3 :           nondefiningDeclaration-&gt;set_scope(currentScopeOfFunctionDeclaration);</span></a>
<a name="5042"><span class="lineNum">    5042 </span><span class="lineCov">          3 :           nondefiningDeclaration-&gt;set_parent(currentScopeOfFunctionDeclaration);</span></a>
<a name="5043"><span class="lineNum">    5043 </span><span class="lineCov">          3 :           currentScopeOfFunctionDeclaration-&gt;insert_symbol(nondefiningDeclaration-&gt;get_name(), functionSymbol);</span></a>
<a name="5044"><span class="lineNum">    5044 </span><span class="lineCov">          3 :           functionSymbol-&gt;set_declaration(procedureDeclaration);  // update the defining declaration</span></a>
<a name="5045"><span class="lineNum">    5045 </span>            :         }</a>
<a name="5046"><span class="lineNum">    5046 </span>            :        else</a>
<a name="5047"><span class="lineNum">    5047 </span>            :         {</a>
<a name="5048"><span class="lineNum">    5048 </span>            :        // Build the function symbol and put it into the symbol table for the current scope</a>
<a name="5049"><span class="lineNum">    5049 </span>            :        // It might be that we should build a nondefining declaration for use in the symbol.</a>
<a name="5050"><span class="lineNum">    5050 </span><span class="lineCov">         10 :           functionSymbol = new SgFunctionSymbol(procedureDeclaration);</span></a>
<a name="5051"><span class="lineNum">    5051 </span><span class="lineCov">         10 :           currentScopeOfFunctionDeclaration-&gt;insert_symbol(procedureDeclaration-&gt;get_name(), functionSymbol);</span></a>
<a name="5052"><span class="lineNum">    5052 </span>            : #if 0</a>
<a name="5053"><span class="lineNum">    5053 </span>            :           printf (&quot;In buildProcedureSupport(): Added SgFunctionSymbol = %p to scope = %p = %s \n&quot;,functionSymbol,currentScopeOfFunctionDeclaration,currentScopeOfFunctionDeclaration-&gt;class_name().c_str());</a>
<a name="5054"><span class="lineNum">    5054 </span>            : #endif</a>
<a name="5055"><span class="lineNum">    5055 </span>            :         }</a>
<a name="5056"><span class="lineNum">    5056 </span>            : </a>
<a name="5057"><span class="lineNum">    5057 </span>            :   // Now push the function definition and the function body (SgBasicBlock) onto the astScopeStack</a>
<a name="5058"><span class="lineNum">    5058 </span><span class="lineCov">         13 :      SgBasicBlock* procedureBody               = new SgBasicBlock();</span></a>
<a name="5059"><span class="lineNum">    5059 </span><span class="lineCov">         13 :      SgFunctionDefinition* procedureDefinition = new SgFunctionDefinition(procedureDeclaration,procedureBody);</span></a>
<a name="5060"><span class="lineNum">    5060 </span>            : </a>
<a name="5061"><span class="lineNum">    5061 </span><span class="lineCov">         13 :      ROSE_ASSERT(procedureDeclaration-&gt;get_definition() != NULL);</span></a>
<a name="5062"><span class="lineNum">    5062 </span>            : </a>
<a name="5063"><span class="lineNum">    5063 </span>            :   // Specify of case insensitivity for Fortran.</a>
<a name="5064"><span class="lineNum">    5064 </span><span class="lineCov">         13 :      procedureBody-&gt;setCaseInsensitive(true);</span></a>
<a name="5065"><span class="lineNum">    5065 </span><span class="lineCov">         13 :      procedureDefinition-&gt;setCaseInsensitive(true);</span></a>
<a name="5066"><span class="lineNum">    5066 </span><span class="lineCov">         13 :      procedureDeclaration-&gt;set_scope(currentScopeOfFunctionDeclaration);</span></a>
<a name="5067"><span class="lineNum">    5067 </span><span class="lineCov">         13 :      procedureDeclaration-&gt;set_parent(currentScopeOfFunctionDeclaration);</span></a>
<a name="5068"><span class="lineNum">    5068 </span>            : </a>
<a name="5069"><span class="lineNum">    5069 </span>            :   // Now push the function definition onto the astScopeStack (so that the function parameters will be build in the correct scope)</a>
<a name="5070"><span class="lineNum">    5070 </span><span class="lineCov">         13 :      astScopeStack.push_front(procedureDefinition);</span></a>
<a name="5071"><span class="lineNum">    5071 </span>            : </a>
<a name="5072"><span class="lineNum">    5072 </span>            :   // This code is specific to the case where the procedureDeclaration is a Fortran function (not a subroutine or data block)</a>
<a name="5073"><span class="lineNum">    5073 </span>            :   // If there was a result specificed for the function then the SgInitializedName list is returned on the astNodeStack.</a>
<a name="5074"><span class="lineNum">    5074 </span><span class="lineCov">         13 :      if (astNodeStack.empty() == false)</span></a>
<a name="5075"><span class="lineNum">    5075 </span>            :         {</a>
<a name="5076"><span class="lineNum">    5076 </span><span class="lineNoCov">          0 :           SgInitializedName* returnVar = isSgInitializedName(astNodeStack.front());</span></a>
<a name="5077"><span class="lineNum">    5077 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(returnVar != NULL);</span></a>
<a name="5078"><span class="lineNum">    5078 </span>            :        // returnVar-&gt;set_scope(functionBody);</a>
<a name="5079"><span class="lineNum">    5079 </span><span class="lineNoCov">          0 :           returnVar-&gt;set_parent(procedureDeclaration);</span></a>
<a name="5080"><span class="lineNum">    5080 </span><span class="lineNoCov">          0 :           returnVar-&gt;set_scope(procedureDefinition);</span></a>
<a name="5081"><span class="lineNum">    5081 </span><span class="lineNoCov">          0 :           procedureDeclaration-&gt;set_result_name(returnVar);</span></a>
<a name="5082"><span class="lineNum">    5082 </span><span class="lineNoCov">          0 :           astNodeStack.pop_front();</span></a>
<a name="5083"><span class="lineNum">    5083 </span>            : </a>
<a name="5084"><span class="lineNum">    5084 </span><span class="lineNoCov">          0 :           SgFunctionType* functionType = procedureDeclaration-&gt;get_type();</span></a>
<a name="5085"><span class="lineNum">    5085 </span><span class="lineNoCov">          0 :           returnVar-&gt;set_type(functionType-&gt;get_return_type());</span></a>
<a name="5086"><span class="lineNum">    5086 </span>            : </a>
<a name="5087"><span class="lineNum">    5087 </span>            :        // Now build associated SgVariableSymbol and put it into the current scope (function definition scope)</a>
<a name="5088"><span class="lineNum">    5088 </span><span class="lineNoCov">          0 :           SgVariableSymbol* returnVariableSymbol = new SgVariableSymbol(returnVar);</span></a>
<a name="5089"><span class="lineNum">    5089 </span><span class="lineNoCov">          0 :           procedureDefinition-&gt;insert_symbol(returnVar-&gt;get_name(),returnVariableSymbol);</span></a>
<a name="5090"><span class="lineNum">    5090 </span>            : </a>
<a name="5091"><span class="lineNum">    5091 </span>            :        // printf (&quot;Processing the return var in a function \n&quot;);</a>
<a name="5092"><span class="lineNum">    5092 </span>            :        // ROSE_ASSERT(false);</a>
<a name="5093"><span class="lineNum">    5093 </span>            :         }</a>
<a name="5094"><span class="lineNum">    5094 </span>            : </a>
<a name="5095"><span class="lineNum">    5095 </span><span class="lineCov">         13 :      if (hasDummyArgList == true)</span></a>
<a name="5096"><span class="lineNum">    5096 </span>            :         {</a>
<a name="5097"><span class="lineNum">    5097 </span>            : #if 0</a>
<a name="5098"><span class="lineNum">    5098 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="5099"><span class="lineNum">    5099 </span>            :           outputState(&quot;In buildProcedureSupport(): building the function parameters&quot;);</a>
<a name="5100"><span class="lineNum">    5100 </span>            : #endif</a>
<a name="5101"><span class="lineNum">    5101 </span>            :        // Take the arguments off of the token stack (astNameStack).</a>
<a name="5102"><span class="lineNum">    5102 </span><span class="lineCov">         32 :           while (astNameStack.empty() == false)</span></a>
<a name="5103"><span class="lineNum">    5103 </span>            :              {</a>
<a name="5104"><span class="lineNum">    5104 </span>            :             // Capture the procedure parameters.</a>
<a name="5105"><span class="lineNum">    5105 </span><span class="lineCov">         42 :                SgName arg_name = astNameStack.front()-&gt;text;</span></a>
<a name="5106"><span class="lineNum">    5106 </span>            : </a>
<a name="5107"><span class="lineNum">    5107 </span>            :             // printf (&quot;arg_name = %s \n&quot;,arg_name.str());</a>
<a name="5108"><span class="lineNum">    5108 </span>            : </a>
<a name="5109"><span class="lineNum">    5109 </span>            :             // Build a SgInitializedName with a SgTypeDefault and fixup the type later when we see the declaration inside the procedure.</a>
<a name="5110"><span class="lineNum">    5110 </span>            :             // SgInitializedName* initializedName = new SgInitializedName(arg_name,SgTypeDefault::createType());</a>
<a name="5111"><span class="lineNum">    5111 </span>            :             // SgInitializedName* initializedName = new SgInitializedName(arg_name,SgTypeDefault::createType(),NULL,NULL,NULL);</a>
<a name="5112"><span class="lineNum">    5112 </span>            :             // SgInitializedName* initializedName = new SgInitializedName(arg_name,SgTypeDefault::createType());</a>
<a name="5113"><span class="lineNum">    5113 </span>            :             // SgInitializedName* initializedName = new SgInitializedName(arg_name,SgTypeDefault::createType(),NULL,procedureDeclaration,NULL);</a>
<a name="5114"><span class="lineNum">    5114 </span>            :             // SgInitializedName* initializedName = new SgInitializedName(arg_name,generateImplicitType(arg_name.str()),NULL,procedureDeclaration,NULL);</a>
<a name="5115"><span class="lineNum">    5115 </span>            : </a>
<a name="5116"><span class="lineNum">    5116 </span>            :             // DQ (1/31/2010): The argument could be a alternate-return dummy argument</a>
<a name="5117"><span class="lineNum">    5117 </span><span class="lineCov">         21 :                SgInitializedName* initializedName = NULL;</span></a>
<a name="5118"><span class="lineNum">    5118 </span><span class="lineCov">         21 :                bool isAnAlternativeReturnParameter = (arg_name == &quot;*&quot;);</span></a>
<a name="5119"><span class="lineNum">    5119 </span><span class="lineCov">         21 :                if (isAnAlternativeReturnParameter == true)</span></a>
<a name="5120"><span class="lineNum">    5120 </span>            :                   {</a>
<a name="5121"><span class="lineNum">    5121 </span>            :                  // DQ (2/1/2011): Since we will generate a label and with name &quot;*&quot; and independently resolve which </a>
<a name="5122"><span class="lineNum">    5122 </span>            :                  // label argument is referenced in the return statement, we need not bury the name directly into </a>
<a name="5123"><span class="lineNum">    5123 </span>            :                  // the arg_name (unless we need to have the references be seperate in the symbol table, so maybe we do!).</a>
<a name="5124"><span class="lineNum">    5124 </span>            : </a>
<a name="5125"><span class="lineNum">    5125 </span>            :                  // Note that alternate return is an obsolescent feature in Fortran 95 and Fortran 90</a>
<a name="5126"><span class="lineNum">    5126 </span>            :                  // initializedName = new SgInitializedName(arg_name,SgTypeVoid::createType(),NULL,procedureDeclaration,NULL);</a>
<a name="5127"><span class="lineNum">    5127 </span><span class="lineNoCov">          0 :                     initializedName = new SgInitializedName(arg_name,SgTypeLabel::createType(),NULL,procedureDeclaration,NULL);</span></a>
<a name="5128"><span class="lineNum">    5128 </span>            :                   }</a>
<a name="5129"><span class="lineNum">    5129 </span>            :                  else</a>
<a name="5130"><span class="lineNum">    5130 </span>            :                   {</a>
<a name="5131"><span class="lineNum">    5131 </span>            :                  // DQ (2/2/2011): The type might not be specified using implicit type rules, so we should likely define </a>
<a name="5132"><span class="lineNum">    5132 </span>            :                  // the type as SgTypeUnknown and then fix it up later (at the end of the functions declarations).</a>
<a name="5133"><span class="lineNum">    5133 </span><span class="lineCov">         21 :                     initializedName = new SgInitializedName(arg_name,generateImplicitType(arg_name.str()),NULL,procedureDeclaration,NULL);</span></a>
<a name="5134"><span class="lineNum">    5134 </span>            :                   }</a>
<a name="5135"><span class="lineNum">    5135 </span>            : </a>
<a name="5136"><span class="lineNum">    5136 </span><span class="lineCov">         21 :                procedureDeclaration-&gt;append_arg(initializedName);</span></a>
<a name="5137"><span class="lineNum">    5137 </span>            : </a>
<a name="5138"><span class="lineNum">    5138 </span><span class="lineCov">         21 :                initializedName-&gt;set_parent(procedureDeclaration-&gt;get_parameterList());</span></a>
<a name="5139"><span class="lineNum">    5139 </span><span class="lineCov">         21 :                ROSE_ASSERT(initializedName-&gt;get_parent() != NULL);</span></a>
<a name="5140"><span class="lineNum">    5140 </span>            : </a>
<a name="5141"><span class="lineNum">    5141 </span>            :             // DQ (12/17/2007): set the scope</a>
<a name="5142"><span class="lineNum">    5142 </span><span class="lineCov">         21 :                initializedName-&gt;set_scope(astScopeStack.front());</span></a>
<a name="5143"><span class="lineNum">    5143 </span>            : </a>
<a name="5144"><span class="lineNum">    5144 </span><span class="lineCov">         21 :                setSourcePosition(initializedName,astNameStack.front());</span></a>
<a name="5145"><span class="lineNum">    5145 </span>            : </a>
<a name="5146"><span class="lineNum">    5146 </span><span class="lineCov">         21 :                ROSE_ASSERT(astNameStack.empty() == false);</span></a>
<a name="5147"><span class="lineNum">    5147 </span><span class="lineCov">         21 :                astNameStack.pop_front();</span></a>
<a name="5148"><span class="lineNum">    5148 </span>            : </a>
<a name="5149"><span class="lineNum">    5149 </span><span class="lineCov">         21 :                if (isAnAlternativeReturnParameter == true)</span></a>
<a name="5150"><span class="lineNum">    5150 </span>            :                   {</a>
<a name="5151"><span class="lineNum">    5151 </span>            :                  // If this is a label argument then build a SgLabelSymbol.</a>
<a name="5152"><span class="lineNum">    5152 </span>            :                  // We might want them to be positionally relevant rather than name relevent,</a>
<a name="5153"><span class="lineNum">    5153 </span>            :                  // this would define a mechanism that was insensitive to transformations.</a>
<a name="5154"><span class="lineNum">    5154 </span>            :                  // We need a new SgLabelSymbol constructor to support the use here.</a>
<a name="5155"><span class="lineNum">    5155 </span>            :                  // SgLabelSymbol* labelSymbol = new SgLabelSymbol(arg_name);</a>
<a name="5156"><span class="lineNum">    5156 </span><span class="lineNoCov">          0 :                     SgLabelSymbol* labelSymbol = new SgLabelSymbol(initializedName);</span></a>
<a name="5157"><span class="lineNum">    5157 </span><span class="lineNoCov">          0 :                     procedureDefinition-&gt;insert_symbol(arg_name,labelSymbol);</span></a>
<a name="5158"><span class="lineNum">    5158 </span>            :                   }</a>
<a name="5159"><span class="lineNum">    5159 </span>            :                  else</a>
<a name="5160"><span class="lineNum">    5160 </span>            :                   {</a>
<a name="5161"><span class="lineNum">    5161 </span>            :                  // Now build associated SgVariableSymbol and put it into the current scope (function definition scope)</a>
<a name="5162"><span class="lineNum">    5162 </span><span class="lineCov">         21 :                     SgVariableSymbol* variableSymbol = new SgVariableSymbol(initializedName);</span></a>
<a name="5163"><span class="lineNum">    5163 </span><span class="lineCov">         21 :                     procedureDefinition-&gt;insert_symbol(arg_name,variableSymbol);</span></a>
<a name="5164"><span class="lineNum">    5164 </span>            :                   }</a>
<a name="5165"><span class="lineNum">    5165 </span>            : </a>
<a name="5166"><span class="lineNum">    5166 </span>            :             // DQ (12/17/2007): Make sure the scope was set!</a>
<a name="5167"><span class="lineNum">    5167 </span><span class="lineCov">         21 :                ROSE_ASSERT(initializedName-&gt;get_scope() != NULL);</span></a>
<a name="5168"><span class="lineNum">    5168 </span>            :              }</a>
<a name="5169"><span class="lineNum">    5169 </span>            : </a>
<a name="5170"><span class="lineNum">    5170 </span><span class="lineCov">         11 :           ROSE_ASSERT(procedureDeclaration-&gt;get_args().empty() == false);</span></a>
<a name="5171"><span class="lineNum">    5171 </span>            : </a>
<a name="5172"><span class="lineNum">    5172 </span><span class="lineCov">         11 :           SgFunctionType* functionType = isSgFunctionType(procedureDeclaration-&gt;get_type());</span></a>
<a name="5173"><span class="lineNum">    5173 </span><span class="lineCov">         11 :           ROSE_ASSERT(functionType != NULL);</span></a>
<a name="5174"><span class="lineNum">    5174 </span>            : </a>
<a name="5175"><span class="lineNum">    5175 </span>            :        // DQ (2/2/2011): This should be empty at this point, it will be fixed up either as we process declarations </a>
<a name="5176"><span class="lineNum">    5176 </span>            :        // in the function that will defin the types or types will be assigned using the implicit type rules (which </a>
<a name="5177"><span class="lineNum">    5177 </span>            :        // might not have even been seen yet for the function) when we are finished processing all of the functions </a>
<a name="5178"><span class="lineNum">    5178 </span>            :        // declarations.  Note that this information will be need by the alternative return support when we compute</a>
<a name="5179"><span class="lineNum">    5179 </span>            :        // the index for the unparsed code.</a>
<a name="5180"><span class="lineNum">    5180 </span><span class="lineCov">         11 :           ROSE_ASSERT(functionType-&gt;get_arguments().empty() == true);</span></a>
<a name="5181"><span class="lineNum">    5181 </span>            :         }</a>
<a name="5182"><span class="lineNum">    5182 </span>            : </a>
<a name="5183"><span class="lineNum">    5183 </span>            :   // printf (&quot;Added function programName = %s (symbol = %p) to scope = %p = %s \n&quot;,tempName.str(),functionSymbol,astScopeStack.front(),astScopeStack.front()-&gt;class_name().c_str());</a>
<a name="5184"><span class="lineNum">    5184 </span>            : </a>
<a name="5185"><span class="lineNum">    5185 </span>            :   // Now push the function definition and the function body (SgBasicBlock) onto the astScopeStack</a>
<a name="5186"><span class="lineNum">    5186 </span><span class="lineCov">         13 :      astScopeStack.push_front(procedureBody);</span></a>
<a name="5187"><span class="lineNum">    5187 </span>            : </a>
<a name="5188"><span class="lineNum">    5188 </span><span class="lineCov">         13 :      procedureBody-&gt;set_parent(procedureDefinition);</span></a>
<a name="5189"><span class="lineNum">    5189 </span><span class="lineCov">         13 :      procedureDefinition-&gt;set_parent(procedureDeclaration);</span></a>
<a name="5190"><span class="lineNum">    5190 </span>            : </a>
<a name="5191"><span class="lineNum">    5191 </span><span class="lineCov">         13 :      ROSE_ASSERT(procedureDeclaration-&gt;get_parameterList() != NULL);</span></a>
<a name="5192"><span class="lineNum">    5192 </span>            : </a>
<a name="5193"><span class="lineNum">    5193 </span>            :   // DQ (1/23/2008): This is not set with the function declaration</a>
<a name="5194"><span class="lineNum">    5194 </span>            :   // setSourcePosition(procedureDeclaration-&gt;get_parameterList());</a>
<a name="5195"><span class="lineNum">    5195 </span>            : </a>
<a name="5196"><span class="lineNum">    5196 </span>            :   // Unclear if we should use the same token list for resetting the source position in all three IR nodes.</a>
<a name="5197"><span class="lineNum">    5197 </span><span class="lineCov">         13 :      setSourcePosition(procedureDefinition);</span></a>
<a name="5198"><span class="lineNum">    5198 </span><span class="lineCov">         13 :      setSourcePosition(procedureBody);</span></a>
<a name="5199"><span class="lineNum">    5199 </span>            : </a>
<a name="5200"><span class="lineNum">    5200 </span>            :   // DQ (1/21/2008): This has been set earlier so that it could be done more accurately</a>
<a name="5201"><span class="lineNum">    5201 </span>            :   // setSourcePosition(procedureDeclaration);</a>
<a name="5202"><span class="lineNum">    5202 </span>            : </a>
<a name="5203"><span class="lineNum">    5203 </span>            :   // Now setup the function type and reset it in the procedureDeclaration</a>
<a name="5204"><span class="lineNum">    5204 </span>            :   // SgFunctionType* functionType = new SgFunctionType(SgTypeVoid::createType(),false);</a>
<a name="5205"><span class="lineNum">    5205 </span>            :   // procedureDeclaration-&gt;set_type(functionType);</a>
<a name="5206"><span class="lineNum">    5206 </span>            : </a>
<a name="5207"><span class="lineNum">    5207 </span>            : #if 0</a>
<a name="5208"><span class="lineNum">    5208 </span>            :   // DQ (10/10/2010): Added tests to make sure that start and end positions are set reasonably.</a>
<a name="5209"><span class="lineNum">    5209 </span>            :      ROSE_ASSERT(procedureDeclaration-&gt;get_startOfConstruct()-&gt;get_line() &gt; 0);</a>
<a name="5210"><span class="lineNum">    5210 </span>            :      ROSE_ASSERT(procedureDefinition-&gt;get_startOfConstruct()-&gt;get_line()  &gt; 0);</a>
<a name="5211"><span class="lineNum">    5211 </span>            :      ROSE_ASSERT(procedureBody-&gt;get_startOfConstruct()-&gt;get_line()        &gt; 0);</a>
<a name="5212"><span class="lineNum">    5212 </span>            :      ROSE_ASSERT(procedureDeclaration-&gt;get_endOfConstruct()-&gt;get_line() &gt;= procedureDeclaration-&gt;get_startOfConstruct()-&gt;get_line());</a>
<a name="5213"><span class="lineNum">    5213 </span>            :      ROSE_ASSERT(procedureDefinition-&gt;get_endOfConstruct()-&gt;get_line()  &gt;= procedureDefinition-&gt;get_startOfConstruct()-&gt;get_line());</a>
<a name="5214"><span class="lineNum">    5214 </span>            :      ROSE_ASSERT(procedureBody-&gt;get_endOfConstruct()-&gt;get_line()        &gt;= procedureBody-&gt;get_startOfConstruct()-&gt;get_line());</a>
<a name="5215"><span class="lineNum">    5215 </span>            : #endif</a>
<a name="5216"><span class="lineNum">    5216 </span><span class="lineCov">         13 :    }</span></a>
<a name="5217"><span class="lineNum">    5217 </span>            : </a>
<a name="5218"><span class="lineNum">    5218 </span>            : </a>
<a name="5219"><span class="lineNum">    5219 </span>            : void</a>
<a name="5220"><span class="lineNum">    5220 </span><span class="lineCov">         19 : markDoLoopAsUsingEndDo()</span></a>
<a name="5221"><span class="lineNum">    5221 </span>            :    {</a>
<a name="5222"><span class="lineNum">    5222 </span>            :   // Fixed (as well as some refactoring) to also work with an SgForAllStatement</a>
<a name="5223"><span class="lineNum">    5223 </span>            :   // This may be needed as SgForAllStatement also represents DO CONCURRENT [Rasmussen 2019.08.23].</a>
<a name="5224"><span class="lineNum">    5224 </span>            : </a>
<a name="5225"><span class="lineNum">    5225 </span>            :   // Look for the last statement (it should be a SgFortranDo, SgWhileStmt or SgForAllStatement)</a>
<a name="5226"><span class="lineNum">    5226 </span><span class="lineCov">         19 :      SgScopeStatement* currentScope = astScopeStack.front();</span></a>
<a name="5227"><span class="lineNum">    5227 </span><span class="lineCov">         19 :      ROSE_ASSERT(currentScope != NULL);</span></a>
<a name="5228"><span class="lineNum">    5228 </span>            : </a>
<a name="5229"><span class="lineNum">    5229 </span>            : #if 0</a>
<a name="5230"><span class="lineNum">    5230 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="5231"><span class="lineNum">    5231 </span>            :      outputState(&quot;In markDoLoopAsUsingEndDo()&quot;);</a>
<a name="5232"><span class="lineNum">    5232 </span>            :      printf (&quot;In markDoLoopAsUsingEndDo: currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="5233"><span class="lineNum">    5233 </span>            : #endif</a>
<a name="5234"><span class="lineNum">    5234 </span>            : </a>
<a name="5235"><span class="lineNum">    5235 </span><span class="lineCov">         19 :      SgFortranDo* doStatement = isSgFortranDo(currentScope);</span></a>
<a name="5236"><span class="lineNum">    5236 </span><span class="lineCov">         19 :      SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);</span></a>
<a name="5237"><span class="lineNum">    5237 </span><span class="lineCov">         19 :      SgForAllStatement* forallStatement = isSgForAllStatement(currentScope);</span></a>
<a name="5238"><span class="lineNum">    5238 </span>            : </a>
<a name="5239"><span class="lineNum">    5239 </span><span class="lineCov">         19 :      if (doStatement != NULL)</span></a>
<a name="5240"><span class="lineNum">    5240 </span>            :         {</a>
<a name="5241"><span class="lineNum">    5241 </span>            :        // DQ (12/26/2007): This field is depricated in favor of the has_end_statement boolean field used uniformally in several IR nodes).</a>
<a name="5242"><span class="lineNum">    5242 </span>            :        // doStatement-&gt;set_old_style(false);</a>
<a name="5243"><span class="lineNum">    5243 </span><span class="lineCov">         19 :           doStatement-&gt;set_has_end_statement(true);</span></a>
<a name="5244"><span class="lineNum">    5244 </span>            :         }</a>
<a name="5245"><span class="lineNum">    5245 </span><span class="lineNoCov">          0 :      else if (whileStatement != NULL)</span></a>
<a name="5246"><span class="lineNum">    5246 </span>            :         {</a>
<a name="5247"><span class="lineNum">    5247 </span><span class="lineNoCov">          0 :            whileStatement-&gt;set_has_end_statement(true);</span></a>
<a name="5248"><span class="lineNum">    5248 </span>            :         }</a>
<a name="5249"><span class="lineNum">    5249 </span><span class="lineNoCov">          0 :      else if (forallStatement != NULL)</span></a>
<a name="5250"><span class="lineNum">    5250 </span>            :         {</a>
<a name="5251"><span class="lineNum">    5251 </span><span class="lineNoCov">          0 :            forallStatement-&gt;set_has_end_statement(true);</span></a>
<a name="5252"><span class="lineNum">    5252 </span>            :         }</a>
<a name="5253"><span class="lineNum">    5253 </span>            :      else</a>
<a name="5254"><span class="lineNum">    5254 </span>            :         {</a>
<a name="5255"><span class="lineNum">    5255 </span><span class="lineNoCov">          0 :            printf (&quot;Error: do-loop, while-loop, or forall-loop should be at the top of the astScopeStack! currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</span></a>
<a name="5256"><span class="lineNum">    5256 </span><span class="lineNoCov">          0 :            ROSE_ABORT();</span></a>
<a name="5257"><span class="lineNum">    5257 </span>            :         }</a>
<a name="5258"><span class="lineNum">    5258 </span><span class="lineCov">         19 :    }</span></a>
<a name="5259"><span class="lineNum">    5259 </span>            : </a>
<a name="5260"><span class="lineNum">    5260 </span>            : </a>
<a name="5261"><span class="lineNum">    5261 </span>            : SgExpression*</a>
<a name="5262"><span class="lineNum">    5262 </span><span class="lineCov">         29 : buildSubscriptExpression ( bool hasLowerBound, bool hasUpperBound, bool hasStride, bool isAmbiguous )</span></a>
<a name="5263"><span class="lineNum">    5263 </span>            :    {</a>
<a name="5264"><span class="lineNum">    5264 </span>            :   // DQ (4/26/2008): Note that test2008_21.f90 demonstrates that this function is called to evaluate </a>
<a name="5265"><span class="lineNum">    5265 </span>            :   // the initialization of types in structures (fortran types).  </a>
<a name="5266"><span class="lineNum">    5266 </span>            : </a>
<a name="5267"><span class="lineNum">    5267 </span>            :   // DQ (4/26/2008): Later... This function should not be called for initialization now!</a>
<a name="5268"><span class="lineNum">    5268 </span>            : </a>
<a name="5269"><span class="lineNum">    5269 </span><span class="lineCov">         29 :      SgExpression* subscript = NULL;</span></a>
<a name="5270"><span class="lineNum">    5270 </span>            : </a>
<a name="5271"><span class="lineNum">    5271 </span><span class="lineCov">         29 :      if (hasUpperBound == true)</span></a>
<a name="5272"><span class="lineNum">    5272 </span>            :         {</a>
<a name="5273"><span class="lineNum">    5273 </span>            :        // SgSubscriptColon* subscript = new SgSubscriptColon();</a>
<a name="5274"><span class="lineNum">    5274 </span>            : </a>
<a name="5275"><span class="lineNum">    5275 </span><span class="lineNoCov">          0 :           if (hasLowerBound == true)</span></a>
<a name="5276"><span class="lineNum">    5276 </span>            :              {</a>
<a name="5277"><span class="lineNum">    5277 </span><span class="lineNoCov">          0 :                if (hasStride == true)</span></a>
<a name="5278"><span class="lineNum">    5278 </span>            :                   {</a>
<a name="5279"><span class="lineNum">    5279 </span>            :                  // Get three values off of the stack!</a>
<a name="5280"><span class="lineNum">    5280 </span><span class="lineNoCov">          0 :                     SgExpression* stride = astExpressionStack.front();</span></a>
<a name="5281"><span class="lineNum">    5281 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5282"><span class="lineNum">    5282 </span><span class="lineNoCov">          0 :                     SgExpression* upperBound = astExpressionStack.front();</span></a>
<a name="5283"><span class="lineNum">    5283 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5284"><span class="lineNum">    5284 </span><span class="lineNoCov">          0 :                     SgExpression* lowerBound = astExpressionStack.front();</span></a>
<a name="5285"><span class="lineNum">    5285 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5286"><span class="lineNum">    5286 </span>            : </a>
<a name="5287"><span class="lineNum">    5287 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5288"><span class="lineNum">    5288 </span>            :                   }</a>
<a name="5289"><span class="lineNum">    5289 </span>            :                  else</a>
<a name="5290"><span class="lineNum">    5290 </span>            :                   {</a>
<a name="5291"><span class="lineNum">    5291 </span>            :                  // Case of a single literal specified, the expression is already on the stack!</a>
<a name="5292"><span class="lineNum">    5292 </span>            :                  // ROSE_ASSERT(isAmbiguous == true);</a>
<a name="5293"><span class="lineNum">    5293 </span>            : </a>
<a name="5294"><span class="lineNum">    5294 </span>            :                  // SgExpression* stride = new SgNullExpression();</a>
<a name="5295"><span class="lineNum">    5295 </span><span class="lineNoCov">          0 :                     SgExpression* stride = new SgIntVal(1,&quot;1&quot;);</span></a>
<a name="5296"><span class="lineNum">    5296 </span><span class="lineNoCov">          0 :                     SgExpression* upperBound = astExpressionStack.front();</span></a>
<a name="5297"><span class="lineNum">    5297 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5298"><span class="lineNum">    5298 </span><span class="lineNoCov">          0 :                     SgExpression* lowerBound = astExpressionStack.front();</span></a>
<a name="5299"><span class="lineNum">    5299 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5300"><span class="lineNum">    5300 </span>            : </a>
<a name="5301"><span class="lineNum">    5301 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5302"><span class="lineNum">    5302 </span>            : </a>
<a name="5303"><span class="lineNum">    5303 </span><span class="lineNoCov">          0 :                     setSourcePosition(stride);</span></a>
<a name="5304"><span class="lineNum">    5304 </span>            :                   }</a>
<a name="5305"><span class="lineNum">    5305 </span>            :              }</a>
<a name="5306"><span class="lineNum">    5306 </span>            :             else</a>
<a name="5307"><span class="lineNum">    5307 </span>            :              {</a>
<a name="5308"><span class="lineNum">    5308 </span><span class="lineNoCov">          0 :                SgExpression* lowerBound = new SgNullExpression();</span></a>
<a name="5309"><span class="lineNum">    5309 </span>            : </a>
<a name="5310"><span class="lineNum">    5310 </span><span class="lineNoCov">          0 :                if (hasStride == true)</span></a>
<a name="5311"><span class="lineNum">    5311 </span>            :                   {</a>
<a name="5312"><span class="lineNum">    5312 </span>            :                  // Get three values off oc the stack!</a>
<a name="5313"><span class="lineNum">    5313 </span><span class="lineNoCov">          0 :                     SgExpression* stride = astExpressionStack.front();</span></a>
<a name="5314"><span class="lineNum">    5314 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5315"><span class="lineNum">    5315 </span><span class="lineNoCov">          0 :                     SgExpression* upperBound = astExpressionStack.front();</span></a>
<a name="5316"><span class="lineNum">    5316 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5317"><span class="lineNum">    5317 </span>            : </a>
<a name="5318"><span class="lineNum">    5318 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5319"><span class="lineNum">    5319 </span>            :                   }</a>
<a name="5320"><span class="lineNum">    5320 </span>            :                  else</a>
<a name="5321"><span class="lineNum">    5321 </span>            :                   {</a>
<a name="5322"><span class="lineNum">    5322 </span><span class="lineNoCov">          0 :                     SgExpression* stride = new SgIntVal(1,&quot;1&quot;);</span></a>
<a name="5323"><span class="lineNum">    5323 </span>            : </a>
<a name="5324"><span class="lineNum">    5324 </span><span class="lineNoCov">          0 :                     SgExpression* upperBound = astExpressionStack.front();</span></a>
<a name="5325"><span class="lineNum">    5325 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5326"><span class="lineNum">    5326 </span>            : </a>
<a name="5327"><span class="lineNum">    5327 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5328"><span class="lineNum">    5328 </span>            : </a>
<a name="5329"><span class="lineNum">    5329 </span><span class="lineNoCov">          0 :                     setSourcePosition(stride);</span></a>
<a name="5330"><span class="lineNum">    5330 </span>            :                   }</a>
<a name="5331"><span class="lineNum">    5331 </span>            : </a>
<a name="5332"><span class="lineNum">    5332 </span><span class="lineNoCov">          0 :                setSourcePosition(lowerBound);</span></a>
<a name="5333"><span class="lineNum">    5333 </span>            :              }</a>
<a name="5334"><span class="lineNum">    5334 </span>            :         }</a>
<a name="5335"><span class="lineNum">    5335 </span>            :        else</a>
<a name="5336"><span class="lineNum">    5336 </span>            :         {</a>
<a name="5337"><span class="lineNum">    5337 </span><span class="lineCov">         29 :           if (hasLowerBound == true)</span></a>
<a name="5338"><span class="lineNum">    5338 </span>            :              {</a>
<a name="5339"><span class="lineNum">    5339 </span><span class="lineCov">         29 :                if (hasStride == true)</span></a>
<a name="5340"><span class="lineNum">    5340 </span>            :                   {</a>
<a name="5341"><span class="lineNum">    5341 </span><span class="lineNoCov">          0 :                     SgExpression* stride = astExpressionStack.front();</span></a>
<a name="5342"><span class="lineNum">    5342 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5343"><span class="lineNum">    5343 </span><span class="lineNoCov">          0 :                     SgExpression* upperBound = new SgNullExpression();</span></a>
<a name="5344"><span class="lineNum">    5344 </span><span class="lineNoCov">          0 :                     SgExpression* lowerBound = astExpressionStack.front();</span></a>
<a name="5345"><span class="lineNum">    5345 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5346"><span class="lineNum">    5346 </span>            : </a>
<a name="5347"><span class="lineNum">    5347 </span><span class="lineNoCov">          0 :                     setSourcePosition(upperBound);</span></a>
<a name="5348"><span class="lineNum">    5348 </span>            : </a>
<a name="5349"><span class="lineNum">    5349 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5350"><span class="lineNum">    5350 </span>            :                   }</a>
<a name="5351"><span class="lineNum">    5351 </span>            :                  else</a>
<a name="5352"><span class="lineNum">    5352 </span>            :                   {</a>
<a name="5353"><span class="lineNum">    5353 </span>            :                  // This is the case of scalar indexing, so generate a scalar value instead of a SgSubscriptExpression.</a>
<a name="5354"><span class="lineNum">    5354 </span>            : </a>
<a name="5355"><span class="lineNum">    5355 </span>            :                  // The isAmbiguous flag helps distinguish between the cases of array(1) and array(1:)</a>
<a name="5356"><span class="lineNum">    5356 </span><span class="lineCov">         29 :                     if (isAmbiguous == false)</span></a>
<a name="5357"><span class="lineNum">    5357 </span>            :                        {</a>
<a name="5358"><span class="lineNum">    5358 </span>            :                       // This is the case of array(1:)</a>
<a name="5359"><span class="lineNum">    5359 </span><span class="lineNoCov">          0 :                          SgExpression* stride = new SgIntVal(1,&quot;1&quot;);</span></a>
<a name="5360"><span class="lineNum">    5360 </span>            : </a>
<a name="5361"><span class="lineNum">    5361 </span><span class="lineNoCov">          0 :                          SgExpression* lowerBound = astExpressionStack.front();</span></a>
<a name="5362"><span class="lineNum">    5362 </span><span class="lineNoCov">          0 :                          astExpressionStack.pop_front();</span></a>
<a name="5363"><span class="lineNum">    5363 </span><span class="lineNoCov">          0 :                          SgExpression* upperBound = new SgNullExpression();</span></a>
<a name="5364"><span class="lineNum">    5364 </span>            : </a>
<a name="5365"><span class="lineNum">    5365 </span><span class="lineNoCov">          0 :                          setSourcePosition(upperBound);</span></a>
<a name="5366"><span class="lineNum">    5366 </span>            : </a>
<a name="5367"><span class="lineNum">    5367 </span><span class="lineNoCov">          0 :                          subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5368"><span class="lineNum">    5368 </span><span class="lineNoCov">          0 :                          setSourcePosition(stride);</span></a>
<a name="5369"><span class="lineNum">    5369 </span>            :                        }</a>
<a name="5370"><span class="lineNum">    5370 </span>            :                       else</a>
<a name="5371"><span class="lineNum">    5371 </span>            :                        {</a>
<a name="5372"><span class="lineNum">    5372 </span>            :                       // This is the case of array(1)</a>
<a name="5373"><span class="lineNum">    5373 </span>            :                       // See also that this is used for type initialization (see test2008_21.f90)</a>
<a name="5374"><span class="lineNum">    5374 </span><span class="lineCov">         29 :                          ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="5375"><span class="lineNum">    5375 </span><span class="lineCov">         29 :                          if (astExpressionStack.empty() == false)</span></a>
<a name="5376"><span class="lineNum">    5376 </span>            :                             {</a>
<a name="5377"><span class="lineNum">    5377 </span><span class="lineCov">         29 :                               subscript = astExpressionStack.front();</span></a>
<a name="5378"><span class="lineNum">    5378 </span><span class="lineCov">         29 :                               astExpressionStack.pop_front();</span></a>
<a name="5379"><span class="lineNum">    5379 </span>            :                             }</a>
<a name="5380"><span class="lineNum">    5380 </span>            :                            else</a>
<a name="5381"><span class="lineNum">    5381 </span>            :                             {</a>
<a name="5382"><span class="lineNum">    5382 </span>            :                            // This branch should not be called now!  This function should not be used in initialization.</a>
<a name="5383"><span class="lineNum">    5383 </span><span class="lineNoCov">          0 :                               printf (&quot;subscript evaluation used in type initialization \n&quot;);</span></a>
<a name="5384"><span class="lineNum">    5384 </span><span class="lineNoCov">          0 :                               ROSE_ABORT();</span></a>
<a name="5385"><span class="lineNum">    5385 </span>            :                             }</a>
<a name="5386"><span class="lineNum">    5386 </span>            :                        }</a>
<a name="5387"><span class="lineNum">    5387 </span>            :                   }</a>
<a name="5388"><span class="lineNum">    5388 </span>            :              }</a>
<a name="5389"><span class="lineNum">    5389 </span>            :             else</a>
<a name="5390"><span class="lineNum">    5390 </span>            :              {</a>
<a name="5391"><span class="lineNum">    5391 </span><span class="lineNoCov">          0 :                SgExpression* lowerBound = new SgNullExpression();</span></a>
<a name="5392"><span class="lineNum">    5392 </span><span class="lineNoCov">          0 :                SgExpression* upperBound = new SgNullExpression();</span></a>
<a name="5393"><span class="lineNum">    5393 </span>            : </a>
<a name="5394"><span class="lineNum">    5394 </span><span class="lineNoCov">          0 :                if (hasStride == true)</span></a>
<a name="5395"><span class="lineNum">    5395 </span>            :                   {</a>
<a name="5396"><span class="lineNum">    5396 </span><span class="lineNoCov">          0 :                     SgExpression* stride = astExpressionStack.front();</span></a>
<a name="5397"><span class="lineNum">    5397 </span><span class="lineNoCov">          0 :                     astExpressionStack.pop_front();</span></a>
<a name="5398"><span class="lineNum">    5398 </span>            : </a>
<a name="5399"><span class="lineNum">    5399 </span>            :                  // subscript = new SgSubscriptColon(lowerBound,stride);</a>
<a name="5400"><span class="lineNum">    5400 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5401"><span class="lineNum">    5401 </span>            :                   }</a>
<a name="5402"><span class="lineNum">    5402 </span>            :                  else</a>
<a name="5403"><span class="lineNum">    5403 </span>            :                   {</a>
<a name="5404"><span class="lineNum">    5404 </span>            :                  // DQ (4/30/2008): This case makes no requirement of the astExpressionStack</a>
<a name="5405"><span class="lineNum">    5405 </span>            : </a>
<a name="5406"><span class="lineNum">    5406 </span>            :                  // SgExpression* stride     = new SgNullExpression();</a>
<a name="5407"><span class="lineNum">    5407 </span><span class="lineNoCov">          0 :                     SgExpression* stride     = new SgIntVal(1,&quot;1&quot;);</span></a>
<a name="5408"><span class="lineNum">    5408 </span>            : </a>
<a name="5409"><span class="lineNum">    5409 </span><span class="lineNoCov">          0 :                     setSourcePosition(stride);</span></a>
<a name="5410"><span class="lineNum">    5410 </span>            : </a>
<a name="5411"><span class="lineNum">    5411 </span>            :                  // subscript = new SgSubscriptColon(lowerBound,stride);</a>
<a name="5412"><span class="lineNum">    5412 </span><span class="lineNoCov">          0 :                     subscript = new SgSubscriptExpression(lowerBound,upperBound,stride);</span></a>
<a name="5413"><span class="lineNum">    5413 </span>            :                   }</a>
<a name="5414"><span class="lineNum">    5414 </span>            : </a>
<a name="5415"><span class="lineNum">    5415 </span><span class="lineNoCov">          0 :                setSourcePosition(lowerBound);</span></a>
<a name="5416"><span class="lineNum">    5416 </span><span class="lineNoCov">          0 :                setSourcePosition(upperBound);</span></a>
<a name="5417"><span class="lineNum">    5417 </span>            :              }           </a>
<a name="5418"><span class="lineNum">    5418 </span>            : </a>
<a name="5419"><span class="lineNum">    5419 </span>            :         }</a>
<a name="5420"><span class="lineNum">    5420 </span>            : </a>
<a name="5421"><span class="lineNum">    5421 </span><span class="lineCov">         29 :      ROSE_ASSERT(subscript != NULL);</span></a>
<a name="5422"><span class="lineNum">    5422 </span>            : </a>
<a name="5423"><span class="lineNum">    5423 </span>            :   // This could be a integer expression or a SgSubscriptExpression</a>
<a name="5424"><span class="lineNum">    5424 </span><span class="lineCov">         29 :      SgSubscriptExpression* subscriptExpression = isSgSubscriptExpression(subscript);</span></a>
<a name="5425"><span class="lineNum">    5425 </span><span class="lineCov">         29 :      if (subscriptExpression != NULL)</span></a>
<a name="5426"><span class="lineNum">    5426 </span>            :         {</a>
<a name="5427"><span class="lineNum">    5427 </span>            :        // Set the parents of all the parts of the SgSubscriptExpression</a>
<a name="5428"><span class="lineNum">    5428 </span><span class="lineNoCov">          0 :           subscriptExpression-&gt;get_lowerBound()-&gt;set_parent(subscript);</span></a>
<a name="5429"><span class="lineNum">    5429 </span><span class="lineNoCov">          0 :           subscriptExpression-&gt;get_upperBound()-&gt;set_parent(subscript);</span></a>
<a name="5430"><span class="lineNum">    5430 </span><span class="lineNoCov">          0 :           subscriptExpression-&gt;get_stride()-&gt;set_parent(subscript);</span></a>
<a name="5431"><span class="lineNum">    5431 </span>            : </a>
<a name="5432"><span class="lineNum">    5432 </span>            :        // Only set the position of the new SgSubscriptExpression, not a previously built integer expression.</a>
<a name="5433"><span class="lineNum">    5433 </span><span class="lineNoCov">          0 :           setSourcePosition(subscriptExpression);</span></a>
<a name="5434"><span class="lineNum">    5434 </span>            :         }</a>
<a name="5435"><span class="lineNum">    5435 </span>            : </a>
<a name="5436"><span class="lineNum">    5436 </span><span class="lineCov">         29 :      ROSE_ASSERT(subscript != NULL);</span></a>
<a name="5437"><span class="lineNum">    5437 </span><span class="lineCov">         29 :      return subscript;</span></a>
<a name="5438"><span class="lineNum">    5438 </span>            :    }</a>
<a name="5439"><span class="lineNum">    5439 </span>            : </a>
<a name="5440"><span class="lineNum">    5440 </span>            : </a>
<a name="5441"><span class="lineNum">    5441 </span>            : </a>
<a name="5442"><span class="lineNum">    5442 </span>            : bool</a>
<a name="5443"><span class="lineNum">    5443 </span><span class="lineNoCov">          0 : isPubliclyAccessible( SgSymbol* symbol )</span></a>
<a name="5444"><span class="lineNum">    5444 </span>            :    {</a>
<a name="5445"><span class="lineNum">    5445 </span><span class="lineNoCov">          0 :      bool returnValue = false;</span></a>
<a name="5446"><span class="lineNum">    5446 </span><span class="lineNoCov">          0 :      SgNode* symbol_basis = symbol-&gt;get_symbol_basis();</span></a>
<a name="5447"><span class="lineNum">    5447 </span>            : </a>
<a name="5448"><span class="lineNum">    5448 </span><span class="lineNoCov">          0 :      SgDeclarationStatement* declaration = isSgDeclarationStatement(symbol_basis);</span></a>
<a name="5449"><span class="lineNum">    5449 </span><span class="lineNoCov">          0 :      if (declaration != NULL)</span></a>
<a name="5450"><span class="lineNum">    5450 </span>            :         {</a>
<a name="5451"><span class="lineNum">    5451 </span>            :        // printf (&quot;In isPubliclyAccessible(): declaration = %p = %s symbol = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),symbol-&gt;get_name().str());</a>
<a name="5452"><span class="lineNum">    5452 </span>            : </a>
<a name="5453"><span class="lineNum">    5453 </span>            :        // Publically accessible is either declared explicitly as public, or not defined as anything (default in Fortran is public).</a>
<a name="5454"><span class="lineNum">    5454 </span>            : #if 1</a>
<a name="5455"><span class="lineNum">    5455 </span>            :        // DQ (8/16/2020): We changed the definition of isDefault to not be equivalent to isPublic (required for C++ handling).</a>
<a name="5456"><span class="lineNum">    5456 </span><span class="lineNoCov">          0 :           if (declaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true ||</span></a>
<a name="5457"><span class="lineNum">    5457 </span><span class="lineNoCov">          0 :               declaration-&gt;get_declarationModifier().get_accessModifier().isDefault() == true ||</span></a>
<a name="5458"><span class="lineNum">    5458 </span><span class="lineNoCov">          0 :               declaration-&gt;get_declarationModifier().get_accessModifier().isUndefined() == true)</span></a>
<a name="5459"><span class="lineNum">    5459 </span>            : #else</a>
<a name="5460"><span class="lineNum">    5460 </span>            :           if (declaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true ||</a>
<a name="5461"><span class="lineNum">    5461 </span>            :               declaration-&gt;get_declarationModifier().get_accessModifier().isUndefined() == true)</a>
<a name="5462"><span class="lineNum">    5462 </span>            : #endif</a>
<a name="5463"><span class="lineNum">    5463 </span>            :              {</a>
<a name="5464"><span class="lineNum">    5464 </span>            :                returnValue = true;</a>
<a name="5465"><span class="lineNum">    5465 </span>            :              }</a>
<a name="5466"><span class="lineNum">    5466 </span>            : </a>
<a name="5467"><span class="lineNum">    5467 </span>            :        // declaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;In isPubliclyAccessible()&quot;);</a>
<a name="5468"><span class="lineNum">    5468 </span>            :         }</a>
<a name="5469"><span class="lineNum">    5469 </span>            :        else</a>
<a name="5470"><span class="lineNum">    5470 </span>            :         {</a>
<a name="5471"><span class="lineNum">    5471 </span><span class="lineNoCov">          0 :           SgInitializedName* initializedName = isSgInitializedName(symbol_basis);</span></a>
<a name="5472"><span class="lineNum">    5472 </span><span class="lineNoCov">          0 :           if (initializedName != NULL)</span></a>
<a name="5473"><span class="lineNum">    5473 </span>            :              {</a>
<a name="5474"><span class="lineNum">    5474 </span><span class="lineNoCov">          0 :                SgNode* parent = initializedName-&gt;get_parent();</span></a>
<a name="5475"><span class="lineNum">    5475 </span><span class="lineNoCov">          0 :                SgDeclarationStatement* declaration = isSgDeclarationStatement(parent);</span></a>
<a name="5476"><span class="lineNum">    5476 </span><span class="lineNoCov">          0 :                if (declaration != NULL)</span></a>
<a name="5477"><span class="lineNum">    5477 </span>            :                   {</a>
<a name="5478"><span class="lineNum">    5478 </span>            : #if 0</a>
<a name="5479"><span class="lineNum">    5479 </span>            :                  // printf (&quot;declaration (from SgInitializedName) = %p = %s \n&quot;,declaration,declaration-&gt;class_name().c_str());</a>
<a name="5480"><span class="lineNum">    5480 </span>            :                     printf (&quot;In isPubliclyAccessible(): declaration = %p = %s symbol = %s \n&quot;,declaration,declaration-&gt;class_name().c_str(),symbol-&gt;get_name().str());</a>
<a name="5481"><span class="lineNum">    5481 </span>            :                     declaration-&gt;get_declarationModifier().display(&quot;In isPubliclyAccessible()&quot;);</a>
<a name="5482"><span class="lineNum">    5482 </span>            : #endif</a>
<a name="5483"><span class="lineNum">    5483 </span>            : #if 1</a>
<a name="5484"><span class="lineNum">    5484 </span>            :                  // DQ (8/16/2020): We changed the definition of isDefault to not be equivalent to isPublic (required for C++ handling).</a>
<a name="5485"><span class="lineNum">    5485 </span><span class="lineNoCov">          0 :                     if (declaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true ||</span></a>
<a name="5486"><span class="lineNum">    5486 </span><span class="lineNoCov">          0 :                         declaration-&gt;get_declarationModifier().get_accessModifier().isDefault() == true ||</span></a>
<a name="5487"><span class="lineNum">    5487 </span><span class="lineNoCov">          0 :                         declaration-&gt;get_declarationModifier().get_accessModifier().isUndefined() == true)</span></a>
<a name="5488"><span class="lineNum">    5488 </span>            : #else</a>
<a name="5489"><span class="lineNum">    5489 </span>            :                     if (declaration-&gt;get_declarationModifier().get_accessModifier().isPublic() == true ||</a>
<a name="5490"><span class="lineNum">    5490 </span>            :                         declaration-&gt;get_declarationModifier().get_accessModifier().isUndefined() == true)</a>
<a name="5491"><span class="lineNum">    5491 </span>            : #endif</a>
<a name="5492"><span class="lineNum">    5492 </span>            :                        {</a>
<a name="5493"><span class="lineNum">    5493 </span>            :                          returnValue = true;</a>
<a name="5494"><span class="lineNum">    5494 </span>            :                        }</a>
<a name="5495"><span class="lineNum">    5495 </span>            :                       else</a>
<a name="5496"><span class="lineNum">    5496 </span>            :                        {</a>
<a name="5497"><span class="lineNum">    5497 </span>            :                       // DQ (9/11/2010): See test2007_176.f03 for an example of the F2003 use of the &quot;protected&quot; keyword.</a>
<a name="5498"><span class="lineNum">    5498 </span>            :                       // If it was marked as protected in the variable then either it will be found in a parent scope </a>
<a name="5499"><span class="lineNum">    5499 </span>            :                       // (for module functions) or it should not be put into the current scope as an aliased variable symbol.</a>
<a name="5500"><span class="lineNum">    5500 </span>            :                       // printf (&quot;This may still be a protected variable. \n&quot;);</a>
<a name="5501"><span class="lineNum">    5501 </span>            : </a>
<a name="5502"><span class="lineNum">    5502 </span>            :                       // DQ (9/11/2010): But make sure this is not marked as protected (is so then we want to include it as an aliased symbol).</a>
<a name="5503"><span class="lineNum">    5503 </span><span class="lineNoCov">          0 :                          if (initializedName-&gt;get_protected_declaration() == true)</span></a>
<a name="5504"><span class="lineNum">    5504 </span>            :                             {</a>
<a name="5505"><span class="lineNum">    5505 </span>            :                            // This should not be considered a publicly accessible variable (don't put it into the synbol table as an aliased symbol.</a>
<a name="5506"><span class="lineNum">    5506 </span><span class="lineNoCov">          0 :                               if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5507"><span class="lineNum">    5507 </span><span class="lineNoCov">          0 :                                    printf (&quot;In isPubliclyAccessible(): Note that this variable is marked as protected (so must be included as an aliased symbol \n&quot;);</span></a>
<a name="5508"><span class="lineNum">    5508 </span>            : </a>
<a name="5509"><span class="lineNum">    5509 </span>            :                               returnValue = true;</a>
<a name="5510"><span class="lineNum">    5510 </span>            :                             }</a>
<a name="5511"><span class="lineNum">    5511 </span>            :                        }</a>
<a name="5512"><span class="lineNum">    5512 </span>            : </a>
<a name="5513"><span class="lineNum">    5513 </span>            :                  // declaration-&gt;get_declarationModifier().get_accessModifier().display(&quot;In isPubliclyAccessible()&quot;);</a>
<a name="5514"><span class="lineNum">    5514 </span>            :                   }</a>
<a name="5515"><span class="lineNum">    5515 </span>            :              }</a>
<a name="5516"><span class="lineNum">    5516 </span>            :             else</a>
<a name="5517"><span class="lineNum">    5517 </span>            :              {</a>
<a name="5518"><span class="lineNum">    5518 </span>            :             // This case is not handled yet</a>
<a name="5519"><span class="lineNum">    5519 </span><span class="lineNoCov">          0 :                printf (&quot;In isPubliclyAccessible(): Uknown symbol_basis = %p = %s \n&quot;,symbol_basis,symbol_basis-&gt;class_name().c_str());</span></a>
<a name="5520"><span class="lineNum">    5520 </span><span class="lineNoCov">          0 :                ROSE_ABORT();</span></a>
<a name="5521"><span class="lineNum">    5521 </span>            :              }</a>
<a name="5522"><span class="lineNum">    5522 </span>            :         }</a>
<a name="5523"><span class="lineNum">    5523 </span>            :        </a>
<a name="5524"><span class="lineNum">    5524 </span>            :         // Pei-Hung (07/26/2019)  Check if access attribute is given in SgAttributeSpecificationStatement</a>
<a name="5525"><span class="lineNum">    5525 </span>            :         // Test case avaiable in test2019_private_attribute.f90 &amp; test2019_private_attribute2.f90 </a>
<a name="5526"><span class="lineNum">    5526 </span><span class="lineNoCov">          0 :         SgScopeStatement* scope = symbol-&gt;get_scope();</span></a>
<a name="5527"><span class="lineNum">    5527 </span><span class="lineNoCov">          0 :         SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(scope);</span></a>
<a name="5528"><span class="lineNum">    5528 </span><span class="lineNoCov">          0 :         if (functionDefinition != NULL)</span></a>
<a name="5529"><span class="lineNum">    5529 </span>            :            {</a>
<a name="5530"><span class="lineNum">    5530 </span><span class="lineNoCov">          0 :              std::vector&lt;SgStatement*&gt;::iterator j = functionDefinition-&gt;get_body()-&gt;get_statements().begin();</span></a>
<a name="5531"><span class="lineNum">    5531 </span><span class="lineNoCov">          0 :              while ( j != functionDefinition-&gt;get_body()-&gt;get_statements().end() )</span></a>
<a name="5532"><span class="lineNum">    5532 </span>            :                 {</a>
<a name="5533"><span class="lineNum">    5533 </span>            :                // Look for the access attribute in SgAttributeSpecificationStatement</a>
<a name="5534"><span class="lineNum">    5534 </span><span class="lineNoCov">          0 :                   SgAttributeSpecificationStatement* attributeStmt = isSgAttributeSpecificationStatement(*j);</span></a>
<a name="5535"><span class="lineNum">    5535 </span><span class="lineNoCov">          0 :                   if (attributeStmt != NULL)</span></a>
<a name="5536"><span class="lineNum">    5536 </span>            :                   {</a>
<a name="5537"><span class="lineNum">    5537 </span><span class="lineNoCov">          0 :                       SgStringList&amp; nameList = attributeStmt-&gt;get_name_list();</span></a>
<a name="5538"><span class="lineNum">    5538 </span><span class="lineNoCov">          0 :                       SgStringList::iterator i = nameList.begin();</span></a>
<a name="5539"><span class="lineNum">    5539 </span><span class="lineNoCov">          0 :                       while(i != nameList.end())</span></a>
<a name="5540"><span class="lineNum">    5540 </span>            :                       {</a>
<a name="5541"><span class="lineNum">    5541 </span><span class="lineNoCov">          0 :                          if((*i).compare(symbol-&gt;get_name().str()) == 0)</span></a>
<a name="5542"><span class="lineNum">    5542 </span>            :                          {</a>
<a name="5543"><span class="lineNum">    5543 </span><span class="lineNoCov">          0 :                            if(attributeStmt-&gt;get_attribute_kind() == SgAttributeSpecificationStatement::e_accessStatement_private)</span></a>
<a name="5544"><span class="lineNum">    5544 </span>            :                               returnValue = false;</a>
<a name="5545"><span class="lineNum">    5545 </span><span class="lineNoCov">          0 :                            else if(attributeStmt-&gt;get_attribute_kind() == SgAttributeSpecificationStatement::e_accessStatement_public)</span></a>
<a name="5546"><span class="lineNum">    5546 </span><span class="lineNoCov">          0 :                               returnValue = true;</span></a>
<a name="5547"><span class="lineNum">    5547 </span>            :                          }</a>
<a name="5548"><span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                          i++;</span></a>
<a name="5549"><span class="lineNum">    5549 </span>            :                       }</a>
<a name="5550"><span class="lineNum">    5550 </span>            :                   }</a>
<a name="5551"><span class="lineNum">    5551 </span><span class="lineNoCov">          0 :                   j++;</span></a>
<a name="5552"><span class="lineNum">    5552 </span>            :                 }</a>
<a name="5553"><span class="lineNum">    5553 </span>            :            }</a>
<a name="5554"><span class="lineNum">    5554 </span>            :         // Pei-Hung (07/25/2019) search for implicit statement in modules</a>
<a name="5555"><span class="lineNum">    5555 </span><span class="lineNoCov">          0 :         SgClassDefinition* classDefinition = isSgClassDefinition(scope);</span></a>
<a name="5556"><span class="lineNum">    5556 </span><span class="lineNoCov">          0 :         if (classDefinition != NULL)</span></a>
<a name="5557"><span class="lineNum">    5557 </span>            :            {</a>
<a name="5558"><span class="lineNum">    5558 </span><span class="lineNoCov">          0 :              SgDeclarationStatementPtrList&amp; declStmtList = classDefinition-&gt;get_members();</span></a>
<a name="5559"><span class="lineNum">    5559 </span><span class="lineNoCov">          0 :              SgDeclarationStatementPtrList::const_iterator j = declStmtList.begin();</span></a>
<a name="5560"><span class="lineNum">    5560 </span><span class="lineNoCov">          0 :              while (j != declStmtList.end())</span></a>
<a name="5561"><span class="lineNum">    5561 </span>            :                {</a>
<a name="5562"><span class="lineNum">    5562 </span>            :                // Look for the access attribute in SgAttributeSpecificationStatement</a>
<a name="5563"><span class="lineNum">    5563 </span><span class="lineNoCov">          0 :                   SgAttributeSpecificationStatement* attributeStmt = isSgAttributeSpecificationStatement(*j);</span></a>
<a name="5564"><span class="lineNum">    5564 </span><span class="lineNoCov">          0 :                   if (attributeStmt != NULL)</span></a>
<a name="5565"><span class="lineNum">    5565 </span>            :                   {</a>
<a name="5566"><span class="lineNum">    5566 </span><span class="lineNoCov">          0 :                       SgStringList&amp; nameList = attributeStmt-&gt;get_name_list();</span></a>
<a name="5567"><span class="lineNum">    5567 </span><span class="lineNoCov">          0 :                       SgStringList::iterator i = nameList.begin();</span></a>
<a name="5568"><span class="lineNum">    5568 </span><span class="lineNoCov">          0 :                       while(i != nameList.end())</span></a>
<a name="5569"><span class="lineNum">    5569 </span>            :                       {</a>
<a name="5570"><span class="lineNum">    5570 </span><span class="lineNoCov">          0 :                          if((*i).compare(symbol-&gt;get_name().str()) == 0)</span></a>
<a name="5571"><span class="lineNum">    5571 </span>            :                          {</a>
<a name="5572"><span class="lineNum">    5572 </span><span class="lineNoCov">          0 :                            if(attributeStmt-&gt;get_attribute_kind() == SgAttributeSpecificationStatement::e_accessStatement_private)</span></a>
<a name="5573"><span class="lineNum">    5573 </span>            :                               returnValue = false;</a>
<a name="5574"><span class="lineNum">    5574 </span><span class="lineNoCov">          0 :                            else if(attributeStmt-&gt;get_attribute_kind() == SgAttributeSpecificationStatement::e_accessStatement_public)</span></a>
<a name="5575"><span class="lineNum">    5575 </span><span class="lineNoCov">          0 :                               returnValue = true;</span></a>
<a name="5576"><span class="lineNum">    5576 </span>            :                          }</a>
<a name="5577"><span class="lineNum">    5577 </span><span class="lineNoCov">          0 :                          i++;</span></a>
<a name="5578"><span class="lineNum">    5578 </span>            :                       }</a>
<a name="5579"><span class="lineNum">    5579 </span>            :                   }</a>
<a name="5580"><span class="lineNum">    5580 </span><span class="lineNoCov">          0 :                   j++;</span></a>
<a name="5581"><span class="lineNum">    5581 </span>            :                }</a>
<a name="5582"><span class="lineNum">    5582 </span>            :            }</a>
<a name="5583"><span class="lineNum">    5583 </span>            :         </a>
<a name="5584"><span class="lineNum">    5584 </span>            : </a>
<a name="5585"><span class="lineNum">    5585 </span><span class="lineNoCov">          0 :      return returnValue;</span></a>
<a name="5586"><span class="lineNum">    5586 </span>            :    }</a>
<a name="5587"><span class="lineNum">    5587 </span>            : </a>
<a name="5588"><span class="lineNum">    5588 </span>            : void</a>
<a name="5589"><span class="lineNum">    5589 </span><span class="lineNoCov">          0 : cleanupTypeStackAfterDeclaration()</span></a>
<a name="5590"><span class="lineNum">    5590 </span>            :    {</a>
<a name="5591"><span class="lineNum">    5591 </span>            :   // This function is called in R501 c_action_type_declaration_stmt().</a>
<a name="5592"><span class="lineNum">    5592 </span>            : </a>
<a name="5593"><span class="lineNum">    5593 </span>            :   // We should have used all the types stored on the stack at this point!</a>
<a name="5594"><span class="lineNum">    5594 </span>            :   // Except for the case of an array type which will have pushed the base type </a>
<a name="5595"><span class="lineNum">    5595 </span>            :   // onto the stack and then an array type.  In this case we will still have </a>
<a name="5596"><span class="lineNum">    5596 </span>            :   // the base type on the stack.  If there was a scalar variable then it will </a>
<a name="5597"><span class="lineNum">    5597 </span>            :   // have used the type on the stack, but we should take care of this by always </a>
<a name="5598"><span class="lineNum">    5598 </span>            :   // pushing a type onto the stack for each variable to use and then making </a>
<a name="5599"><span class="lineNum">    5599 </span>            :   // sure that we have the base type still on the stack at this point, so the </a>
<a name="5600"><span class="lineNum">    5600 </span>            :   // stack at this point should never be empty and should have the unused base </a>
<a name="5601"><span class="lineNum">    5601 </span>            :   // type on top (and the stack size should be 1).</a>
<a name="5602"><span class="lineNum">    5602 </span>            : </a>
<a name="5603"><span class="lineNum">    5603 </span><span class="lineNoCov">          0 :      if (astTypeStack.empty() == false)</span></a>
<a name="5604"><span class="lineNum">    5604 </span>            :         {</a>
<a name="5605"><span class="lineNum">    5605 </span>            :        // This should be only a base type that has been left on the stack.</a>
<a name="5606"><span class="lineNum">    5606 </span>            :        // printf (&quot;WARNING, astTypeStack not empty: astTypeStack.front() = %p = %s \n&quot;,astTypeStack.front(),astTypeStack.front()-&gt;class_name().c_str());</a>
<a name="5607"><span class="lineNum">    5607 </span>            : </a>
<a name="5608"><span class="lineNum">    5608 </span>            :        // If there was an array declaration then the base type is left on the stack, else </a>
<a name="5609"><span class="lineNum">    5609 </span>            :        // the stack is empty.  Cleanup the stack of the one possible base type left there!</a>
<a name="5610"><span class="lineNum">    5610 </span>            :        // astTypeStack.pop_front();</a>
<a name="5611"><span class="lineNum">    5611 </span>            : </a>
<a name="5612"><span class="lineNum">    5612 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5613"><span class="lineNum">    5613 </span><span class="lineNoCov">          0 :              printf (&quot;WARNING, astTypeStack not empty: astTypeStack.front() = %p = %s = %s (CLEARING astTypeStack) \n&quot;,astTypeStack.front(),astTypeStack.front()-&gt;class_name().c_str(),SageInterface::get_name(astTypeStack.front()).c_str());</span></a>
<a name="5614"><span class="lineNum">    5614 </span>            : </a>
<a name="5615"><span class="lineNum">    5615 </span><span class="lineNoCov">          0 :           astTypeStack.clear();</span></a>
<a name="5616"><span class="lineNum">    5616 </span>            : #if 0</a>
<a name="5617"><span class="lineNum">    5617 </span>            :           if (astTypeStack.empty() == false)</a>
<a name="5618"><span class="lineNum">    5618 </span>            :                outputState(&quot;Error: astTypeStack.empty() == false in R502 c_action_declaration_type_spec()&quot;);</a>
<a name="5619"><span class="lineNum">    5619 </span>            : #endif</a>
<a name="5620"><span class="lineNum">    5620 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="5621"><span class="lineNum">    5621 </span>            :         }</a>
<a name="5622"><span class="lineNum">    5622 </span>            : </a>
<a name="5623"><span class="lineNum">    5623 </span><span class="lineNoCov">          0 :      if (astBaseTypeStack.empty() == false)</span></a>
<a name="5624"><span class="lineNum">    5624 </span>            :         {</a>
<a name="5625"><span class="lineNum">    5625 </span><span class="lineNoCov">          0 :           if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5626"><span class="lineNum">    5626 </span><span class="lineNoCov">          0 :                printf (&quot;WARNING, astBaseTypeStack not empty: astBaseTypeStack.front() = %p = %s = %s (CLEARING astBaseTypeStack) \n&quot;,astBaseTypeStack.front(),astBaseTypeStack.front()-&gt;class_name().c_str(),SageInterface::get_name(astBaseTypeStack.front()).c_str());</span></a>
<a name="5627"><span class="lineNum">    5627 </span>            : </a>
<a name="5628"><span class="lineNum">    5628 </span><span class="lineNoCov">          0 :           astBaseTypeStack.clear();</span></a>
<a name="5629"><span class="lineNum">    5629 </span>            : #if 0</a>
<a name="5630"><span class="lineNum">    5630 </span>            :           if (astBaseTypeStack.empty() == false)</a>
<a name="5631"><span class="lineNum">    5631 </span>            :                outputState(&quot;Error: astBaseTypeStack.empty() == false in R502 c_action_declaration_type_spec()&quot;);</a>
<a name="5632"><span class="lineNum">    5632 </span>            : #endif</a>
<a name="5633"><span class="lineNum">    5633 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astBaseTypeStack.empty() == true);</span></a>
<a name="5634"><span class="lineNum">    5634 </span>            :         }</a>
<a name="5635"><span class="lineNum">    5635 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5636"><span class="lineNum">    5636 </span>            : </a>
<a name="5637"><span class="lineNum">    5637 </span>            : </a>
<a name="5638"><span class="lineNum">    5638 </span>            : </a>
<a name="5639"><span class="lineNum">    5639 </span>            : </a>
<a name="5640"><span class="lineNum">    5640 </span>            : void</a>
<a name="5641"><span class="lineNum">    5641 </span><span class="lineNoCov">          0 : buildVariableDeclarationAndCleanupTypeStack( Token_t * label )</span></a>
<a name="5642"><span class="lineNum">    5642 </span>            :    {</a>
<a name="5643"><span class="lineNum">    5643 </span>            :   // This function is called in R501 c_action_type_declaration_stmt().</a>
<a name="5644"><span class="lineNum">    5644 </span>            : </a>
<a name="5645"><span class="lineNum">    5645 </span>            :   // DQ (1/28/2009): Part of fix for nested include (test2009_14.f).</a>
<a name="5646"><span class="lineNum">    5646 </span>            :   // Only try to build a varialbe if there is information to support this on the stack.</a>
<a name="5647"><span class="lineNum">    5647 </span>            :   // I am trying to have variable built earlier than before since the Fortran &quot;include&quot;</a>
<a name="5648"><span class="lineNum">    5648 </span>            :   // mechanism can be called before this R501 rule and that causes problems.  Basically</a>
<a name="5649"><span class="lineNum">    5649 </span>            :   // each new include file needs to be started with an empty stack(s).</a>
<a name="5650"><span class="lineNum">    5650 </span>            : </a>
<a name="5651"><span class="lineNum">    5651 </span>            :     //    if (!astNodeStack.empty())</a>
<a name="5652"><span class="lineNum">    5652 </span>            : </a>
<a name="5653"><span class="lineNum">    5653 </span><span class="lineNoCov">          0 :      if (astNodeStack.empty() == false &amp;&amp; astBaseTypeStack.empty() == false)</span></a>
<a name="5654"><span class="lineNum">    5654 </span>            :         {</a>
<a name="5655"><span class="lineNum">    5655 </span>            : #if 0</a>
<a name="5656"><span class="lineNum">    5656 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="5657"><span class="lineNum">    5657 </span>            :           outputState(&quot;At TOP of buildVariableDeclarationAndCleanupTypeStack() (before calling buildVariableDeclaration())&quot;);</a>
<a name="5658"><span class="lineNum">    5658 </span>            : #endif</a>
<a name="5659"><span class="lineNum">    5659 </span>            : </a>
<a name="5660"><span class="lineNum">    5660 </span><span class="lineNoCov">          0 :           SgVariableDeclaration* variableDeclaration = buildVariableDeclaration(label,false);</span></a>
<a name="5661"><span class="lineNum">    5661 </span>            : </a>
<a name="5662"><span class="lineNum">    5662 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(variableDeclaration-&gt;get_file_info()-&gt;isCompilerGenerated() == false);</span></a>
<a name="5663"><span class="lineNum">    5663 </span>            : </a>
<a name="5664"><span class="lineNum">    5664 </span>            :        // DQ (11/29/2007): commented out, we can't assume this (see test2007_133.f03)</a>
<a name="5665"><span class="lineNum">    5665 </span>            :        // DQ (9/30/2007):</a>
<a name="5666"><span class="lineNum">    5666 </span>            :        // I think this is now uniformally true for all type declarations.  If so then we can</a>
<a name="5667"><span class="lineNum">    5667 </span>            :        // remove the conditionaly handling below.  See the note in R504 c_action_entity_decl()</a>
<a name="5668"><span class="lineNum">    5668 </span>            :        // for more details.</a>
<a name="5669"><span class="lineNum">    5669 </span>            :        // ROSE_ASSERT(astTypeStack.empty() == true);</a>
<a name="5670"><span class="lineNum">    5670 </span>            : #if 0</a>
<a name="5671"><span class="lineNum">    5671 </span>            :           outputState(&quot;In buildVariableDeclarationAndCleanupTypeStack() (after buildVariableDeclaration())&quot;);</a>
<a name="5672"><span class="lineNum">    5672 </span>            : #endif</a>
<a name="5673"><span class="lineNum">    5673 </span>            :        // We should have used all the types stored on the stack at this point!</a>
<a name="5674"><span class="lineNum">    5674 </span>            :        // Except for the case of an array type which will have pushed the base type </a>
<a name="5675"><span class="lineNum">    5675 </span>            :        // onto the stack and then an array type.  In this case we will still have </a>
<a name="5676"><span class="lineNum">    5676 </span>            :        // the base type on the stack.  If there was a scalar variable then it will </a>
<a name="5677"><span class="lineNum">    5677 </span>            :        // have used the type on the stack, but we should take care of this by always </a>
<a name="5678"><span class="lineNum">    5678 </span>            :        // pushing a type onto the stack for each variable to use and then making </a>
<a name="5679"><span class="lineNum">    5679 </span>            :        // sure that we have the base type still on the stack at this point, so the </a>
<a name="5680"><span class="lineNum">    5680 </span>            :        // stack at this point should never be empty and should have the unused base </a>
<a name="5681"><span class="lineNum">    5681 </span>            :        // type on top (and the stack size should be 1).</a>
<a name="5682"><span class="lineNum">    5682 </span>            :        // ROSE_ASSERT(astTypeStack.empty() == true);</a>
<a name="5683"><span class="lineNum">    5683 </span>            :        // ROSE_ASSERT(astTypeStack.size() == 1);</a>
<a name="5684"><span class="lineNum">    5684 </span>            :        // astTypeStack.pop_front();</a>
<a name="5685"><span class="lineNum">    5685 </span>            : </a>
<a name="5686"><span class="lineNum">    5686 </span>            :        // DQ (1/27/2009): Refactored code so that I can handle test2009_13.f (nested include files).</a>
<a name="5687"><span class="lineNum">    5687 </span><span class="lineNoCov">          0 :           cleanupTypeStackAfterDeclaration();</span></a>
<a name="5688"><span class="lineNum">    5688 </span>            : </a>
<a name="5689"><span class="lineNum">    5689 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(getTopOfScopeStack()-&gt;variantT() == V_SgBasicBlock || getTopOfScopeStack()-&gt;variantT() == V_SgClassDefinition);</span></a>
<a name="5690"><span class="lineNum">    5690 </span>            : </a>
<a name="5691"><span class="lineNum">    5691 </span><span class="lineNoCov">          0 :           getTopOfScopeStack()-&gt;append_statement(variableDeclaration);</span></a>
<a name="5692"><span class="lineNum">    5692 </span>            :         }</a>
<a name="5693"><span class="lineNum">    5693 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5694"><span class="lineNum">    5694 </span>            : </a>
<a name="5695"><span class="lineNum">    5695 </span>            : </a>
<a name="5696"><span class="lineNum">    5696 </span>            : bool</a>
<a name="5697"><span class="lineNum">    5697 </span><span class="lineCov">         28 : isARoseModuleFile( string filename )</span></a>
<a name="5698"><span class="lineNum">    5698 </span>            :    {</a>
<a name="5699"><span class="lineNum">    5699 </span><span class="lineCov">         28 :      bool result = false;</span></a>
<a name="5700"><span class="lineNum">    5700 </span>            : </a>
<a name="5701"><span class="lineNum">    5701 </span><span class="lineCov">         28 :      string targetSuffix = FortranModuleInfo::module_file_suffix();</span></a>
<a name="5702"><span class="lineNum">    5702 </span><span class="lineCov">         28 :      size_t filenameLength = filename.size();</span></a>
<a name="5703"><span class="lineNum">    5703 </span>            : </a>
<a name="5704"><span class="lineNum">    5704 </span><span class="lineCov">        140 :      if ( (filenameLength &gt; targetSuffix.size()) &amp;&amp; (filename.substr(filenameLength - 5) == FortranModuleInfo::module_file_suffix()) )</span></a>
<a name="5705"><span class="lineNum">    5705 </span><span class="lineNoCov">          0 :           result = true;</span></a>
<a name="5706"><span class="lineNum">    5706 </span>            : #if 0</a>
<a name="5707"><span class="lineNum">    5707 </span>            :      printf (&quot;################ filename = %s result = %s \n&quot;,filename.c_str(),(result == true) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5708"><span class="lineNum">    5708 </span>            : #endif</a>
<a name="5709"><span class="lineNum">    5709 </span>            : </a>
<a name="5710"><span class="lineNum">    5710 </span><span class="lineCov">         28 :      return result;</span></a>
<a name="5711"><span class="lineNum">    5711 </span>            :    }</a>
<a name="5712"><span class="lineNum">    5712 </span>            : </a>
<a name="5713"><span class="lineNum">    5713 </span>            : </a>
<a name="5714"><span class="lineNum">    5714 </span>            : void</a>
<a name="5715"><span class="lineNum">    5715 </span><span class="lineCov">         43 : generateAssignmentStatement(Token_t* label, bool isPointerAssignment )</span></a>
<a name="5716"><span class="lineNum">    5716 </span>            :    {</a>
<a name="5717"><span class="lineNum">    5717 </span>            :   // This function builds the SgAssignOp and the SgExprStatement and </a>
<a name="5718"><span class="lineNum">    5718 </span>            :   // inserts it into the current scope.</a>
<a name="5719"><span class="lineNum">    5719 </span>            : </a>
<a name="5720"><span class="lineNum">    5720 </span>            : #if 0</a>
<a name="5721"><span class="lineNum">    5721 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="5722"><span class="lineNum">    5722 </span>            :      outputState(&quot;At TOP of generateAssignmentStatement()&quot;);</a>
<a name="5723"><span class="lineNum">    5723 </span>            : #endif</a>
<a name="5724"><span class="lineNum">    5724 </span>            : </a>
<a name="5725"><span class="lineNum">    5725 </span><span class="lineCov">         43 :      ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="5726"><span class="lineNum">    5726 </span><span class="lineCov">         43 :      SgExpression* rhs = astExpressionStack.front();</span></a>
<a name="5727"><span class="lineNum">    5727 </span><span class="lineCov">         43 :      astExpressionStack.pop_front();</span></a>
<a name="5728"><span class="lineNum">    5728 </span>            : </a>
<a name="5729"><span class="lineNum">    5729 </span><span class="lineCov">         43 :      ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="5730"><span class="lineNum">    5730 </span><span class="lineCov">         43 :      SgExpression* lhs = astExpressionStack.front();</span></a>
<a name="5731"><span class="lineNum">    5731 </span><span class="lineCov">         43 :      astExpressionStack.pop_front();</span></a>
<a name="5732"><span class="lineNum">    5732 </span>            : </a>
<a name="5733"><span class="lineNum">    5733 </span>            :   // Note that the type provided is NULL, since ROSE will internally (dynamically) evaluate the type </a>
<a name="5734"><span class="lineNum">    5734 </span>            :   // as required.  This avoids state in the AST and better supports transformations on the AST.</a>
<a name="5735"><span class="lineNum">    5735 </span>            :   // SgAssignOp* assignmentExpr = new SgAssignOp(lhs,rhs,NULL);</a>
<a name="5736"><span class="lineNum">    5736 </span><span class="lineCov">         43 :      SgExpression* assignmentExpr = NULL;</span></a>
<a name="5737"><span class="lineNum">    5737 </span><span class="lineCov">         43 :      if (isPointerAssignment == true)</span></a>
<a name="5738"><span class="lineNum">    5738 </span>            :         {</a>
<a name="5739"><span class="lineNum">    5739 </span>            :        // This is &quot;p =&gt; x&quot;</a>
<a name="5740"><span class="lineNum">    5740 </span><span class="lineCov">          1 :           assignmentExpr = new SgPointerAssignOp(lhs,rhs,NULL);</span></a>
<a name="5741"><span class="lineNum">    5741 </span>            :         }</a>
<a name="5742"><span class="lineNum">    5742 </span>            :        else</a>
<a name="5743"><span class="lineNum">    5743 </span>            :         {</a>
<a name="5744"><span class="lineNum">    5744 </span>            :        // This is &quot;p = x&quot;</a>
<a name="5745"><span class="lineNum">    5745 </span><span class="lineCov">         42 :           assignmentExpr = new SgAssignOp(lhs,rhs,NULL);</span></a>
<a name="5746"><span class="lineNum">    5746 </span>            :         }</a>
<a name="5747"><span class="lineNum">    5747 </span>            : </a>
<a name="5748"><span class="lineNum">    5748 </span><span class="lineCov">         43 :      setSourcePosition(assignmentExpr);</span></a>
<a name="5749"><span class="lineNum">    5749 </span>            : </a>
<a name="5750"><span class="lineNum">    5750 </span>            :   // DQ (1/22/2008): Set the source position based on the internal expressions</a>
<a name="5751"><span class="lineNum">    5751 </span><span class="lineCov">         43 :      resetSourcePosition(assignmentExpr,lhs);</span></a>
<a name="5752"><span class="lineNum">    5752 </span>            :   // resetSourcePosition(assignmentExpr,rhs);</a>
<a name="5753"><span class="lineNum">    5753 </span>            : </a>
<a name="5754"><span class="lineNum">    5754 </span>            :   // Now build the expression statement required for insertion into the current </a>
<a name="5755"><span class="lineNum">    5755 </span>            :   // scope (note that expressions cannot be directly inserted into scopes).</a>
<a name="5756"><span class="lineNum">    5756 </span>            : </a>
<a name="5757"><span class="lineNum">    5757 </span><span class="lineCov">         43 :      SgExprStatement* expressionStatement = new SgExprStatement(assignmentExpr);</span></a>
<a name="5758"><span class="lineNum">    5758 </span>            : </a>
<a name="5759"><span class="lineNum">    5759 </span><span class="lineCov">         43 :      if (label != NULL)</span></a>
<a name="5760"><span class="lineNum">    5760 </span>            :         {</a>
<a name="5761"><span class="lineNum">    5761 </span>            :        // A label was provided so set the label in the expressionStatement</a>
<a name="5762"><span class="lineNum">    5762 </span>            : </a>
<a name="5763"><span class="lineNum">    5763 </span>            :        // Setup the label on the statement if it is available.</a>
<a name="5764"><span class="lineNum">    5764 </span><span class="lineNoCov">          0 :           setStatementNumericLabel(expressionStatement,label);</span></a>
<a name="5765"><span class="lineNum">    5765 </span>            : </a>
<a name="5766"><span class="lineNum">    5766 </span>            :        // If there is a label then at least try to use it to set the source </a>
<a name="5767"><span class="lineNum">    5767 </span>            :        // position approximately (better than nothing).</a>
<a name="5768"><span class="lineNum">    5768 </span><span class="lineNoCov">          0 :           setSourcePosition(expressionStatement,label);</span></a>
<a name="5769"><span class="lineNum">    5769 </span>            :         }</a>
<a name="5770"><span class="lineNum">    5770 </span>            :        else</a>
<a name="5771"><span class="lineNum">    5771 </span>            :         {</a>
<a name="5772"><span class="lineNum">    5772 </span>            :        // No source position information is available</a>
<a name="5773"><span class="lineNum">    5773 </span><span class="lineCov">         43 :           setSourcePosition(expressionStatement);</span></a>
<a name="5774"><span class="lineNum">    5774 </span>            : </a>
<a name="5775"><span class="lineNum">    5775 </span>            :        // DQ (1/22/2008): Try this</a>
<a name="5776"><span class="lineNum">    5776 </span><span class="lineCov">         43 :           resetSourcePosition(expressionStatement,assignmentExpr);</span></a>
<a name="5777"><span class="lineNum">    5777 </span>            :         }</a>
<a name="5778"><span class="lineNum">    5778 </span>            : </a>
<a name="5779"><span class="lineNum">    5779 </span><span class="lineCov">         43 :      setStatementNumericLabelUsingStack(expressionStatement);</span></a>
<a name="5780"><span class="lineNum">    5780 </span>            : </a>
<a name="5781"><span class="lineNum">    5781 </span>            :   // DQ (1/31/2009): Moved this to the TOP of the function.</a>
<a name="5782"><span class="lineNum">    5782 </span>            :   // Refactored the code to build support function</a>
<a name="5783"><span class="lineNum">    5783 </span>            :   // initialize_global_scope_if_required();</a>
<a name="5784"><span class="lineNum">    5784 </span>            :   // build_implicit_program_statement_if_required();</a>
<a name="5785"><span class="lineNum">    5785 </span>            : </a>
<a name="5786"><span class="lineNum">    5786 </span><span class="lineCov">         43 :      SgScopeStatement* currentScope = getTopOfScopeStack();</span></a>
<a name="5787"><span class="lineNum">    5787 </span><span class="lineCov">         43 :      currentScope-&gt;append_statement(expressionStatement);</span></a>
<a name="5788"><span class="lineNum">    5788 </span>            : </a>
<a name="5789"><span class="lineNum">    5789 </span><span class="lineCov">         43 :      if ( SgProject::get_verbose() &gt; DEBUG_RULE_COMMENT_LEVEL )</span></a>
<a name="5790"><span class="lineNum">    5790 </span><span class="lineNoCov">          0 :           printf (&quot;Pushing this expressionStatement onto the astNodeStack for optional use by where statement \n&quot;);</span></a>
<a name="5791"><span class="lineNum">    5791 </span>            : </a>
<a name="5792"><span class="lineNum">    5792 </span>            :   // This is needed for test2007_67.f90</a>
<a name="5793"><span class="lineNum">    5793 </span><span class="lineCov">         43 :      astNodeStack.push_front(expressionStatement);</span></a>
<a name="5794"><span class="lineNum">    5794 </span>            : </a>
<a name="5795"><span class="lineNum">    5795 </span>            : #if 0</a>
<a name="5796"><span class="lineNum">    5796 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="5797"><span class="lineNum">    5797 </span>            :      outputState(&quot;At BOTTOM of generateAssignmentStatement()&quot;);</a>
<a name="5798"><span class="lineNum">    5798 </span>            : #endif</a>
<a name="5799"><span class="lineNum">    5799 </span>            : </a>
<a name="5800"><span class="lineNum">    5800 </span>            :   // Error checking for astExpressionStack</a>
<a name="5801"><span class="lineNum">    5801 </span><span class="lineCov">         43 :      ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="5802"><span class="lineNum">    5802 </span><span class="lineCov">         43 :      ROSE_ASSERT(astScopeStack.front()-&gt;get_parent() != NULL);</span></a>
<a name="5803"><span class="lineNum">    5803 </span><span class="lineCov">         43 :      SgWhereStatement* whereStatement = isSgWhereStatement(astScopeStack.front()-&gt;get_parent());</span></a>
<a name="5804"><span class="lineNum">    5804 </span><span class="lineCov">         43 :      SgIfStmt* ifStatement = isSgIfStmt(astScopeStack.front()-&gt;get_parent());</span></a>
<a name="5805"><span class="lineNum">    5805 </span><span class="lineCov">         43 :      if (whereStatement != NULL || ifStatement != NULL)</span></a>
<a name="5806"><span class="lineNum">    5806 </span>            :         {</a>
<a name="5807"><span class="lineNum">    5807 </span>            :        // If in a where statement produced with R 619:section-subscript-list__begin then the </a>
<a name="5808"><span class="lineNum">    5808 </span>            :        // condition is on the stack, else if it was produced with R744:where-construct-stmt </a>
<a name="5809"><span class="lineNum">    5809 </span>            :        // then the condition was used directly and already cleared from the stack.</a>
<a name="5810"><span class="lineNum">    5810 </span>            :        // ROSE_ASSERT(astExpressionStack.empty() == false);</a>
<a name="5811"><span class="lineNum">    5811 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astExpressionStack.size() &lt;= 1);</span></a>
<a name="5812"><span class="lineNum">    5812 </span>            :         }</a>
<a name="5813"><span class="lineNum">    5813 </span>            :        else</a>
<a name="5814"><span class="lineNum">    5814 </span>            :         {</a>
<a name="5815"><span class="lineNum">    5815 </span>            :        // If this is NOT a where statement then the stack should be empty.</a>
<a name="5816"><span class="lineNum">    5816 </span><span class="lineCov">         43 :           ROSE_ASSERT(astExpressionStack.empty() == true);</span></a>
<a name="5817"><span class="lineNum">    5817 </span>            :         }</a>
<a name="5818"><span class="lineNum">    5818 </span><span class="lineCov">         43 :    }</span></a>
<a name="5819"><span class="lineNum">    5819 </span>            : </a>
<a name="5820"><span class="lineNum">    5820 </span>            : void</a>
<a name="5821"><span class="lineNum">    5821 </span><span class="lineNoCov">          0 : convertBaseTypeOnStackToPointer()</span></a>
<a name="5822"><span class="lineNum">    5822 </span>            :    {</a>
<a name="5823"><span class="lineNum">    5823 </span>            :   // DQ (1/20/2011): This function only uses the astBaseTypeStack if there is </a>
<a name="5824"><span class="lineNum">    5824 </span>            :   // not an entry on the astTypeStack.  So now the function is not well named!</a>
<a name="5825"><span class="lineNum">    5825 </span>            : </a>
<a name="5826"><span class="lineNum">    5826 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="5827"><span class="lineNum">    5827 </span>            :   // printf (&quot;In convertBaseTypeOnStackToPointer(): astTypeStack.empty() = %s \n&quot;,astTypeStack.empty() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="5828"><span class="lineNum">    5828 </span>            : </a>
<a name="5829"><span class="lineNum">    5829 </span>            :   // If there is already en entry on the astTypeStack, then modify it.</a>
<a name="5830"><span class="lineNum">    5830 </span>            :   // However, I am not clear if this is always the only semantics that we want.</a>
<a name="5831"><span class="lineNum">    5831 </span><span class="lineNoCov">          0 :      if (astTypeStack.empty() == true)</span></a>
<a name="5832"><span class="lineNum">    5832 </span>            :         {</a>
<a name="5833"><span class="lineNum">    5833 </span>            :        // Use the type on the astBaseTypeStack, since there is no evolving type on the astBaseTypeStack</a>
<a name="5834"><span class="lineNum">    5834 </span><span class="lineNoCov">          0 :           SgType* baseType = astBaseTypeStack.front();</span></a>
<a name="5835"><span class="lineNum">    5835 </span><span class="lineNoCov">          0 :           astBaseTypeStack.pop_front();</span></a>
<a name="5836"><span class="lineNum">    5836 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astBaseTypeStack.empty() == true);</span></a>
<a name="5837"><span class="lineNum">    5837 </span><span class="lineNoCov">          0 :           SgPointerType* pointerType = new SgPointerType(baseType);</span></a>
<a name="5838"><span class="lineNum">    5838 </span>            :        // astBaseTypeStack.push_front(pointerType);</a>
<a name="5839"><span class="lineNum">    5839 </span><span class="lineNoCov">          0 :           astBaseTypeStack.push_front(pointerType);</span></a>
<a name="5840"><span class="lineNum">    5840 </span>            :         }</a>
<a name="5841"><span class="lineNum">    5841 </span>            :        else</a>
<a name="5842"><span class="lineNum">    5842 </span>            :         {</a>
<a name="5843"><span class="lineNum">    5843 </span>            :        // If there is a type being assembled on the astTypeStack, then use it as a base type for the SgPointerType!</a>
<a name="5844"><span class="lineNum">    5844 </span><span class="lineNoCov">          0 :           SgType* baseType = astTypeStack.front();</span></a>
<a name="5845"><span class="lineNum">    5845 </span><span class="lineNoCov">          0 :           astTypeStack.pop_front();</span></a>
<a name="5846"><span class="lineNum">    5846 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="5847"><span class="lineNum">    5847 </span><span class="lineNoCov">          0 :           SgPointerType* pointerType = new SgPointerType(baseType);</span></a>
<a name="5848"><span class="lineNum">    5848 </span><span class="lineNoCov">          0 :           astTypeStack.push_front(pointerType);</span></a>
<a name="5849"><span class="lineNum">    5849 </span>            :         }</a>
<a name="5850"><span class="lineNum">    5850 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5851"><span class="lineNum">    5851 </span>            : </a>
<a name="5852"><span class="lineNum">    5852 </span>            : // FMZ(12/21/2009): added support for &quot;team_default&quot;/&quot;team_world&quot;</a>
<a name="5853"><span class="lineNum">    5853 </span>            : SgVariableSymbol*</a>
<a name="5854"><span class="lineNum">    5854 </span><span class="lineNoCov">          0 : add_external_team_decl(string teamName) {</span></a>
<a name="5855"><span class="lineNum">    5855 </span>            : </a>
<a name="5856"><span class="lineNum">    5856 </span>            :           // make external team :: team_world</a>
<a name="5857"><span class="lineNum">    5857 </span>            :               // create the team &quot;type&quot;</a>
<a name="5858"><span class="lineNum">    5858 </span><span class="lineNoCov">          0 :              SgTypeCAFTeam* cafTeamType = SgTypeCAFTeam::createType();</span></a>
<a name="5859"><span class="lineNum">    5859 </span><span class="lineNoCov">          0 :              ROSE_ASSERT( cafTeamType != NULL);</span></a>
<a name="5860"><span class="lineNum">    5860 </span>            : </a>
<a name="5861"><span class="lineNum">    5861 </span>            :              // build variable </a>
<a name="5862"><span class="lineNum">    5862 </span><span class="lineNoCov">          0 :              SgInitializedName* teamVar= NULL;</span></a>
<a name="5863"><span class="lineNum">    5863 </span>            : </a>
<a name="5864"><span class="lineNum">    5864 </span><span class="lineNoCov">          0 :              teamVar = new SgInitializedName(teamName,cafTeamType,NULL);</span></a>
<a name="5865"><span class="lineNum">    5865 </span>            : </a>
<a name="5866"><span class="lineNum">    5866 </span><span class="lineNoCov">          0 :              ROSE_ASSERT(teamVar != NULL);</span></a>
<a name="5867"><span class="lineNum">    5867 </span><span class="lineNoCov">          0 :              setSourcePosition(teamVar);</span></a>
<a name="5868"><span class="lineNum">    5868 </span>            : </a>
<a name="5869"><span class="lineNum">    5869 </span><span class="lineNoCov">          0 :              SgVariableDeclaration* teamDec = new SgVariableDeclaration();</span></a>
<a name="5870"><span class="lineNum">    5870 </span><span class="lineNoCov">          0 :              ROSE_ASSERT(teamDec!=NULL);</span></a>
<a name="5871"><span class="lineNum">    5871 </span><span class="lineNoCov">          0 :              setSourcePosition(teamDec);</span></a>
<a name="5872"><span class="lineNum">    5872 </span><span class="lineNoCov">          0 :              teamDec-&gt;set_parent(astScopeStack.front());</span></a>
<a name="5873"><span class="lineNum">    5873 </span><span class="lineNoCov">          0 :              teamDec-&gt;set_definingDeclaration(teamDec);</span></a>
<a name="5874"><span class="lineNum">    5874 </span><span class="lineNoCov">          0 :              teamDec-&gt;get_declarationModifier().get_storageModifier().setExtern() ;</span></a>
<a name="5875"><span class="lineNum">    5875 </span>            : </a>
<a name="5876"><span class="lineNum">    5876 </span><span class="lineNoCov">          0 :              teamDec-&gt;append_variable(teamVar,NULL);</span></a>
<a name="5877"><span class="lineNum">    5877 </span><span class="lineNoCov">          0 :              teamVar-&gt;set_declptr(teamDec);</span></a>
<a name="5878"><span class="lineNum">    5878 </span><span class="lineNoCov">          0 :              teamVar-&gt;set_scope(astScopeStack.front());</span></a>
<a name="5879"><span class="lineNum">    5879 </span>            : </a>
<a name="5880"><span class="lineNum">    5880 </span><span class="lineNoCov">          0 :              SgVariableSymbol* teamId = new SgVariableSymbol(teamVar);</span></a>
<a name="5881"><span class="lineNum">    5881 </span><span class="lineNoCov">          0 :              ROSE_ASSERT(teamId != NULL);</span></a>
<a name="5882"><span class="lineNum">    5882 </span>            : </a>
<a name="5883"><span class="lineNum">    5883 </span><span class="lineNoCov">          0 :              astScopeStack.front()-&gt;insert_symbol(teamName,teamId);</span></a>
<a name="5884"><span class="lineNum">    5884 </span>            : </a>
<a name="5885"><span class="lineNum">    5885 </span><span class="lineNoCov">          0 :              return teamId;</span></a>
<a name="5886"><span class="lineNum">    5886 </span>            :  }</a>
<a name="5887"><span class="lineNum">    5887 </span>            : </a>
<a name="5888"><span class="lineNum">    5888 </span>            : </a>
<a name="5889"><span class="lineNum">    5889 </span>            : void</a>
<a name="5890"><span class="lineNum">    5890 </span><span class="lineNoCov">          0 : fixupModuleScope( SgClassDefinition* moduleScope )</span></a>
<a name="5891"><span class="lineNum">    5891 </span>            :    {</a>
<a name="5892"><span class="lineNum">    5892 </span>            :   // Fixes up function symbols to be in the correct scope when the function call appears before the function declaration.</a>
<a name="5893"><span class="lineNum">    5893 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(moduleScope != NULL);</span></a>
<a name="5894"><span class="lineNum">    5894 </span>            : </a>
<a name="5895"><span class="lineNum">    5895 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(moduleScope-&gt;containsOnlyDeclarations() == true);</span></a>
<a name="5896"><span class="lineNum">    5896 </span><span class="lineNoCov">          0 :      const SgDeclarationStatementPtrList &amp; declarationList = moduleScope-&gt;getDeclarationList();</span></a>
<a name="5897"><span class="lineNum">    5897 </span>            : </a>
<a name="5898"><span class="lineNum">    5898 </span>            :   // printf (&quot;Inside of fixupModuleScope(moduleScope = %p) \n&quot;,moduleScope);</a>
<a name="5899"><span class="lineNum">    5899 </span>            : </a>
<a name="5900"><span class="lineNum">    5900 </span><span class="lineNoCov">          0 :      SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();</span></a>
<a name="5901"><span class="lineNum">    5901 </span><span class="lineNoCov">          0 :      while (i != declarationList.end())</span></a>
<a name="5902"><span class="lineNum">    5902 </span>            :         {</a>
<a name="5903"><span class="lineNum">    5903 </span><span class="lineNoCov">          0 :           SgProcedureHeaderStatement* functionDeclaration = isSgProcedureHeaderStatement(*i);</span></a>
<a name="5904"><span class="lineNum">    5904 </span><span class="lineNoCov">          0 :           if (functionDeclaration != NULL)</span></a>
<a name="5905"><span class="lineNum">    5905 </span>            :              {</a>
<a name="5906"><span class="lineNum">    5906 </span>            :             // Note that at this point where fixupModuleScope() is called the astScopeStack has already poped the module scope.</a>
<a name="5907"><span class="lineNum">    5907 </span>            :             // So a valid local_symbol means that the declaration was not placed into the module scope (e.g incorrectly placed</a>
<a name="5908"><span class="lineNum">    5908 </span>            :             // into the global scope).</a>
<a name="5909"><span class="lineNum">    5909 </span>            : </a>
<a name="5910"><span class="lineNum">    5910 </span>            :             // Test if there is a valid symbol associated with each function declaration.</a>
<a name="5911"><span class="lineNum">    5911 </span><span class="lineNoCov">          0 :                SgSymbol* tempSymbol = functionDeclaration-&gt;get_symbol_from_symbol_table();</span></a>
<a name="5912"><span class="lineNum">    5912 </span><span class="lineNoCov">          0 :                if (tempSymbol == NULL)</span></a>
<a name="5913"><span class="lineNum">    5913 </span>            :                   {</a>
<a name="5914"><span class="lineNum">    5914 </span>            :                  // These function without a valid symbol need to be fixed up.</a>
<a name="5915"><span class="lineNum">    5915 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt; 0 )</span></a>
<a name="5916"><span class="lineNum">    5916 </span><span class="lineNoCov">          0 :                          printf (&quot;(tempSymbol == NULL): Identified a function declaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</span></a>
<a name="5917"><span class="lineNum">    5917 </span>            : </a>
<a name="5918"><span class="lineNum">    5918 </span><span class="lineNoCov">          0 :                     SgName variableName              = functionDeclaration-&gt;get_name();</span></a>
<a name="5919"><span class="lineNum">    5919 </span><span class="lineNoCov">          0 :                     SgVariableSymbol* variableSymbol = NULL;</span></a>
<a name="5920"><span class="lineNum">    5920 </span><span class="lineNoCov">          0 :                     SgFunctionSymbol* functionSymbol = NULL;</span></a>
<a name="5921"><span class="lineNum">    5921 </span><span class="lineNoCov">          0 :                     SgClassSymbol*    classSymbol    = NULL;</span></a>
<a name="5922"><span class="lineNum">    5922 </span>            : </a>
<a name="5923"><span class="lineNum">    5923 </span><span class="lineNoCov">          0 :                     trace_back_through_parent_scopes_lookup_variable_symbol_but_do_not_build_variable(variableName,moduleScope,variableSymbol,functionSymbol,classSymbol);</span></a>
<a name="5924"><span class="lineNum">    5924 </span>            : </a>
<a name="5925"><span class="lineNum">    5925 </span><span class="lineNoCov">          0 :                     if (functionSymbol != NULL)</span></a>
<a name="5926"><span class="lineNum">    5926 </span>            :                        {</a>
<a name="5927"><span class="lineNum">    5927 </span><span class="lineNoCov">          0 :                          if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5928"><span class="lineNum">    5928 </span><span class="lineNoCov">          0 :                               printf (&quot;Found functionSymbol = %p function name = %s (erasing all traces of this function in the wrong scope) \n&quot;,functionSymbol,variableName.str());</span></a>
<a name="5929"><span class="lineNum">    5929 </span>            : </a>
<a name="5930"><span class="lineNum">    5930 </span><span class="lineNoCov">          0 :                          SgSymbolTable* symbolTable = isSgSymbolTable(functionSymbol-&gt;get_parent());</span></a>
<a name="5931"><span class="lineNum">    5931 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(symbolTable != NULL);</span></a>
<a name="5932"><span class="lineNum">    5932 </span>            : </a>
<a name="5933"><span class="lineNum">    5933 </span>            :                       // Remove the symbol from the scope were it was first put (incorrectly).</a>
<a name="5934"><span class="lineNum">    5934 </span><span class="lineNoCov">          0 :                          symbolTable-&gt;remove(functionSymbol);</span></a>
<a name="5935"><span class="lineNum">    5935 </span>            : </a>
<a name="5936"><span class="lineNum">    5936 </span>            :                       // Insert the functionSymbol into the moduleScope</a>
<a name="5937"><span class="lineNum">    5937 </span><span class="lineNoCov">          0 :                          moduleScope-&gt;insert_symbol(variableName,functionSymbol);</span></a>
<a name="5938"><span class="lineNum">    5938 </span>            :                        }</a>
<a name="5939"><span class="lineNum">    5939 </span>            :                       else</a>
<a name="5940"><span class="lineNum">    5940 </span>            :                        {</a>
<a name="5941"><span class="lineNum">    5941 </span>            :                       // DQ (8/28/2010): Report more diagnostics.</a>
<a name="5942"><span class="lineNum">    5942 </span><span class="lineNoCov">          0 :                          printf (&quot;Warning: In fixupModuleScope() there was no SgFunctionSymbol found reset into the module scope \n&quot;);</span></a>
<a name="5943"><span class="lineNum">    5943 </span>            :                        }</a>
<a name="5944"><span class="lineNum">    5944 </span>            :                   }</a>
<a name="5945"><span class="lineNum">    5945 </span>            :                  else</a>
<a name="5946"><span class="lineNum">    5946 </span>            :                   {</a>
<a name="5947"><span class="lineNum">    5947 </span>            :                  // These functions don't require any fixup.</a>
<a name="5948"><span class="lineNum">    5948 </span>            :                  // printf (&quot;(local_symbol != NULL): Identified a function declaration = %p = %s = %s \n&quot;,functionDeclaration,functionDeclaration-&gt;class_name().c_str(),functionDeclaration-&gt;get_name().str());</a>
<a name="5949"><span class="lineNum">    5949 </span>            :                   }</a>
<a name="5950"><span class="lineNum">    5950 </span>            :              }</a>
<a name="5951"><span class="lineNum">    5951 </span>            : </a>
<a name="5952"><span class="lineNum">    5952 </span><span class="lineNoCov">          0 :           i++;</span></a>
<a name="5953"><span class="lineNum">    5953 </span>            :         }</a>
<a name="5954"><span class="lineNum">    5954 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="5955"><span class="lineNum">    5955 </span>            : </a>
<a name="5956"><span class="lineNum">    5956 </span>            : </a>
<a name="5957"><span class="lineNum">    5957 </span>            : </a>
<a name="5958"><span class="lineNum">    5958 </span>            : SgClassSymbol* </a>
<a name="5959"><span class="lineNum">    5959 </span><span class="lineNoCov">          0 : buildIntrinsicModule_ISO_C_BINDING()</span></a>
<a name="5960"><span class="lineNum">    5960 </span>            :    {</a>
<a name="5961"><span class="lineNum">    5961 </span><span class="lineNoCov">          0 :      SgClassSymbol* moduleSymbol = NULL;</span></a>
<a name="5962"><span class="lineNum">    5962 </span>            : </a>
<a name="5963"><span class="lineNum">    5963 </span><span class="lineNoCov">          0 :      const string name = &quot;ISO_C_BINDING&quot;;</span></a>
<a name="5964"><span class="lineNum">    5964 </span>            : </a>
<a name="5965"><span class="lineNum">    5965 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5966"><span class="lineNum">    5966 </span><span class="lineNoCov">          0 :           printf (&quot;Building the module file for ISO_C_BINDING \n&quot;);</span></a>
<a name="5967"><span class="lineNum">    5967 </span>            : </a>
<a name="5968"><span class="lineNum">    5968 </span><span class="lineNoCov">          0 :      return moduleSymbol;</span></a>
<a name="5969"><span class="lineNum">    5969 </span>            :    }</a>
<a name="5970"><span class="lineNum">    5970 </span>            : </a>
<a name="5971"><span class="lineNum">    5971 </span>            : SgClassSymbol*</a>
<a name="5972"><span class="lineNum">    5972 </span><span class="lineNoCov">          0 : buildIntrinsicModule_OMP_LIB()</span></a>
<a name="5973"><span class="lineNum">    5973 </span>            :    {</a>
<a name="5974"><span class="lineNum">    5974 </span><span class="lineNoCov">          0 :      SgClassSymbol* moduleSymbol = NULL;</span></a>
<a name="5975"><span class="lineNum">    5975 </span>            : </a>
<a name="5976"><span class="lineNum">    5976 </span><span class="lineNoCov">          0 :      const string name = &quot;OMP_LIB&quot;;</span></a>
<a name="5977"><span class="lineNum">    5977 </span>            : </a>
<a name="5978"><span class="lineNum">    5978 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5979"><span class="lineNum">    5979 </span><span class="lineNoCov">          0 :           printf (&quot;Building the module file for OMP_LIB \n&quot;);</span></a>
<a name="5980"><span class="lineNum">    5980 </span>            : </a>
<a name="5981"><span class="lineNum">    5981 </span><span class="lineNoCov">          0 :      return moduleSymbol;</span></a>
<a name="5982"><span class="lineNum">    5982 </span>            :    }</a>
<a name="5983"><span class="lineNum">    5983 </span>            : </a>
<a name="5984"><span class="lineNum">    5984 </span>            : </a>
<a name="5985"><span class="lineNum">    5985 </span>            : SgClassSymbol*</a>
<a name="5986"><span class="lineNum">    5986 </span><span class="lineNoCov">          0 : buildIntrinsicModule_OMP_LIB_KINDS()</span></a>
<a name="5987"><span class="lineNum">    5987 </span>            :    {</a>
<a name="5988"><span class="lineNum">    5988 </span><span class="lineNoCov">          0 :      SgClassSymbol* moduleSymbol = NULL;</span></a>
<a name="5989"><span class="lineNum">    5989 </span>            : </a>
<a name="5990"><span class="lineNum">    5990 </span><span class="lineNoCov">          0 :      const string name = &quot;OMP_LIB_KINDS&quot;;</span></a>
<a name="5991"><span class="lineNum">    5991 </span>            : </a>
<a name="5992"><span class="lineNum">    5992 </span><span class="lineNoCov">          0 :      if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="5993"><span class="lineNum">    5993 </span><span class="lineNoCov">          0 :           printf (&quot;Building the module file for OMP_LIB_KINDS \n&quot;);</span></a>
<a name="5994"><span class="lineNum">    5994 </span>            : </a>
<a name="5995"><span class="lineNum">    5995 </span><span class="lineNoCov">          0 :      return moduleSymbol;</span></a>
<a name="5996"><span class="lineNum">    5996 </span>            :    }</a>
<a name="5997"><span class="lineNum">    5997 </span>            : </a>
<a name="5998"><span class="lineNum">    5998 </span>            : </a>
<a name="5999"><span class="lineNum">    5999 </span>            : </a>
<a name="6000"><span class="lineNum">    6000 </span>            : </a>
<a name="6001"><span class="lineNum">    6001 </span>            : SgClassSymbol* </a>
<a name="6002"><span class="lineNum">    6002 </span><span class="lineNoCov">          0 : buildIntrinsicModule ( const string &amp; name )</span></a>
<a name="6003"><span class="lineNum">    6003 </span>            :    {</a>
<a name="6004"><span class="lineNum">    6004 </span><span class="lineNoCov">          0 :      SgClassSymbol*  moduleSymbol = NULL;</span></a>
<a name="6005"><span class="lineNum">    6005 </span>            : </a>
<a name="6006"><span class="lineNum">    6006 </span>            : #if 0</a>
<a name="6007"><span class="lineNum">    6007 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="6008"><span class="lineNum">    6008 </span>            :      outputState(&quot;At TOP of buildIntrinsicModule()&quot;);</a>
<a name="6009"><span class="lineNum">    6009 </span>            : #endif</a>
<a name="6010"><span class="lineNum">    6010 </span>            : </a>
<a name="6011"><span class="lineNum">    6011 </span>            :   // DQ (10/23/2010): Intrinsic module must be filtered out since they are special.</a>
<a name="6012"><span class="lineNum">    6012 </span>            :   // These include: ISO_C_BINDING, ISO_FORTRAN_ENV, OMP_LIB, OMP_LIB_KINDS.  There </a>
<a name="6013"><span class="lineNum">    6013 </span>            :   // are no others that I know of.</a>
<a name="6014"><span class="lineNum">    6014 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;ISO_C_BINDING&quot;) == true)</span></a>
<a name="6015"><span class="lineNum">    6015 </span>            :         {</a>
<a name="6016"><span class="lineNum">    6016 </span>            :        // This is the ISO_C_BINDING intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6017"><span class="lineNum">    6017 </span>            :        // printf (&quot;Insert types and variables from ISO_C_BINDING into the local scope \n&quot;);</a>
<a name="6018"><span class="lineNum">    6018 </span>            : </a>
<a name="6019"><span class="lineNum">    6019 </span>            :        // DQ (10/26/2010): This support has been refactored.</a>
<a name="6020"><span class="lineNum">    6020 </span><span class="lineNoCov">          0 :           moduleSymbol = buildIntrinsicModule_ISO_C_BINDING();</span></a>
<a name="6021"><span class="lineNum">    6021 </span>            :         }</a>
<a name="6022"><span class="lineNum">    6022 </span>            : </a>
<a name="6023"><span class="lineNum">    6023 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;ISO_FORTRAN_ENV&quot;) == true)</span></a>
<a name="6024"><span class="lineNum">    6024 </span>            :         {</a>
<a name="6025"><span class="lineNum">    6025 </span>            :        // This is the ISO_FORTRAN_ENV intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6026"><span class="lineNum">    6026 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from ISO_FORTRAN_ENV into the local scope \n&quot;);</span></a>
<a name="6027"><span class="lineNum">    6027 </span>            : </a>
<a name="6028"><span class="lineNum">    6028 </span><span class="lineNoCov">          0 :           printf (&quot;Sorry: ISO_FORTRAN_ENV intrinsic module not implemented yet. \n&quot;);</span></a>
<a name="6029"><span class="lineNum">    6029 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="6030"><span class="lineNum">    6030 </span>            :         }</a>
<a name="6031"><span class="lineNum">    6031 </span>            : </a>
<a name="6032"><span class="lineNum">    6032 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;IEEE_EXCEPTIONS&quot;) == true)</span></a>
<a name="6033"><span class="lineNum">    6033 </span>            :         {</a>
<a name="6034"><span class="lineNum">    6034 </span>            :        // This is the IEEE_EXCEPTIONS intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6035"><span class="lineNum">    6035 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from IEEE_EXCEPTIONS into the local scope \n&quot;);</span></a>
<a name="6036"><span class="lineNum">    6036 </span>            : </a>
<a name="6037"><span class="lineNum">    6037 </span><span class="lineNoCov">          0 :           printf (&quot;Sorry: IEEE_EXCEPTIONS intrinsic module not implemented yet. \n&quot;);</span></a>
<a name="6038"><span class="lineNum">    6038 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="6039"><span class="lineNum">    6039 </span>            :         }</a>
<a name="6040"><span class="lineNum">    6040 </span>            : </a>
<a name="6041"><span class="lineNum">    6041 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;IEEE_ARITHMETIC&quot;) == true)</span></a>
<a name="6042"><span class="lineNum">    6042 </span>            :         {</a>
<a name="6043"><span class="lineNum">    6043 </span>            :        // This is the IEEE_ARITHMETIC intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6044"><span class="lineNum">    6044 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from IEEE_ARITHMETIC into the local scope \n&quot;);</span></a>
<a name="6045"><span class="lineNum">    6045 </span>            : </a>
<a name="6046"><span class="lineNum">    6046 </span><span class="lineNoCov">          0 :           printf (&quot;Sorry: IEEE_ARITHMETIC intrinsic module not implemented yet. \n&quot;);</span></a>
<a name="6047"><span class="lineNum">    6047 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="6048"><span class="lineNum">    6048 </span>            :         }</a>
<a name="6049"><span class="lineNum">    6049 </span>            : </a>
<a name="6050"><span class="lineNum">    6050 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;IEEE_FEATURES&quot;) == true)</span></a>
<a name="6051"><span class="lineNum">    6051 </span>            :         {</a>
<a name="6052"><span class="lineNum">    6052 </span>            :        // This is the IEEE_FEATURES intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6053"><span class="lineNum">    6053 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from IEEE_FEATURES into the local scope \n&quot;);</span></a>
<a name="6054"><span class="lineNum">    6054 </span>            : </a>
<a name="6055"><span class="lineNum">    6055 </span><span class="lineNoCov">          0 :           printf (&quot;Sorry: IEEE_FEATURES intrinsic module not implemented yet. \n&quot;);</span></a>
<a name="6056"><span class="lineNum">    6056 </span><span class="lineNoCov">          0 :           ROSE_ABORT();</span></a>
<a name="6057"><span class="lineNum">    6057 </span>            :         }</a>
<a name="6058"><span class="lineNum">    6058 </span>            : </a>
<a name="6059"><span class="lineNum">    6059 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;OMP_LIB&quot;) == true)</span></a>
<a name="6060"><span class="lineNum">    6060 </span>            :         {</a>
<a name="6061"><span class="lineNum">    6061 </span>            :        // This is the OMP_LIB intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6062"><span class="lineNum">    6062 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from OMP_LIB into the local scope \n&quot;);</span></a>
<a name="6063"><span class="lineNum">    6063 </span><span class="lineNoCov">          0 :           moduleSymbol = buildIntrinsicModule_OMP_LIB();</span></a>
<a name="6064"><span class="lineNum">    6064 </span>            :         }</a>
<a name="6065"><span class="lineNum">    6065 </span>            : </a>
<a name="6066"><span class="lineNum">    6066 </span><span class="lineNoCov">          0 :      if (matchingName(name,&quot;OMP_LIB_KINDS&quot;) == true)</span></a>
<a name="6067"><span class="lineNum">    6067 </span>            :         {</a>
<a name="6068"><span class="lineNum">    6068 </span>            :        // This is the OMP_LIB_KINDS intrisic module and so there is a list of names and types that need to be inserted into the local scope.</a>
<a name="6069"><span class="lineNum">    6069 </span><span class="lineNoCov">          0 :           printf (&quot;Insert types and variables from OMP_LIB_KINDS into the local scope \n&quot;);</span></a>
<a name="6070"><span class="lineNum">    6070 </span><span class="lineNoCov">          0 :           moduleSymbol = buildIntrinsicModule_OMP_LIB_KINDS();</span></a>
<a name="6071"><span class="lineNum">    6071 </span>            :         }</a>
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<a name="6073"><span class="lineNum">    6073 </span>            : #if 0</a>
<a name="6074"><span class="lineNum">    6074 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="6075"><span class="lineNum">    6075 </span>            :      outputState(&quot;At BOTTOM of buildIntrinsicModule()&quot;);</a>
<a name="6076"><span class="lineNum">    6076 </span>            : #endif</a>
<a name="6077"><span class="lineNum">    6077 </span>            : </a>
<a name="6078"><span class="lineNum">    6078 </span>            :   // printf (&quot;Leaving buildIntrinsicModule() \n&quot;);</a>
<a name="6079"><span class="lineNum">    6079 </span>            : </a>
<a name="6080"><span class="lineNum">    6080 </span>            :   // It is OK to return NULL, few modules are intrinsic.</a>
<a name="6081"><span class="lineNum">    6081 </span>            :   // ROSE_ASSERT(moduleSymbol != NULL);</a>
<a name="6082"><span class="lineNum">    6082 </span>            : </a>
<a name="6083"><span class="lineNum">    6083 </span><span class="lineNoCov">          0 :      return moduleSymbol;</span></a>
<a name="6084"><span class="lineNum">    6084 </span>            :    }</a>
<a name="6085"><span class="lineNum">    6085 </span>            : </a>
<a name="6086"><span class="lineNum">    6086 </span>            : void</a>
<a name="6087"><span class="lineNum">    6087 </span><span class="lineCov">         55 : push_token(string s)</span></a>
<a name="6088"><span class="lineNum">    6088 </span>            :    {</a>
<a name="6089"><span class="lineNum">    6089 </span>            :   // This is the case of an option not being specified, as in &quot;read(1)&quot; instead of &quot;read(UNIT=1)&quot;</a>
<a name="6090"><span class="lineNum">    6090 </span>            :   // To make the astExpressionStack match the astNameStack we have to push a default token onto the astNameStack.</a>
<a name="6091"><span class="lineNum">    6091 </span>            :   // Token_t* defaultToken = create_token(0,0,0,&quot;fmt&quot;);</a>
<a name="6092"><span class="lineNum">    6092 </span><span class="lineCov">         55 :      Token_t* defaultToken = create_token(0,0,0,s.c_str());</span></a>
<a name="6093"><span class="lineNum">    6093 </span><span class="lineCov">         55 :      ROSE_ASSERT(defaultToken != NULL);</span></a>
<a name="6094"><span class="lineNum">    6094 </span><span class="lineCov">         55 :      astNameStack.push_front(defaultToken);</span></a>
<a name="6095"><span class="lineNum">    6095 </span><span class="lineCov">         55 :    }</span></a>
<a name="6096"><span class="lineNum">    6096 </span>            : </a>
<a name="6097"><span class="lineNum">    6097 </span>            : </a>
<a name="6098"><span class="lineNum">    6098 </span>            : </a>
<a name="6099"><span class="lineNum">    6099 </span>            : void</a>
<a name="6100"><span class="lineNum">    6100 </span><span class="lineNoCov">          0 : replace_return_type (SgFunctionType* functionType, SgFunctionDeclaration* functionDeclaration, SgClassSymbol* derivedTypeSymbol)</span></a>
<a name="6101"><span class="lineNum">    6101 </span>            :    {</a>
<a name="6102"><span class="lineNum">    6102 </span><span class="lineNoCov">          0 :      bool has_ellipses = functionType-&gt;get_has_ellipses();</span></a>
<a name="6103"><span class="lineNum">    6103 </span>            :   // SgFunctionParameterTypeList* argument_list = functionType-&gt;get_argument_list();</a>
<a name="6104"><span class="lineNum">    6104 </span>            : </a>
<a name="6105"><span class="lineNum">    6105 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(derivedTypeSymbol-&gt;get_declaration() != NULL);</span></a>
<a name="6106"><span class="lineNum">    6106 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(derivedTypeSymbol-&gt;get_declaration()-&gt;get_type() != NULL);</span></a>
<a name="6107"><span class="lineNum">    6107 </span>            : </a>
<a name="6108"><span class="lineNum">    6108 </span><span class="lineNoCov">          0 :      SgFunctionType* newFunctionType = new SgFunctionType(derivedTypeSymbol-&gt;get_declaration()-&gt;get_type(),has_ellipses);</span></a>
<a name="6109"><span class="lineNum">    6109 </span>            :   // printf (&quot;newFunctionType = %p \n&quot;,newFunctionType);</a>
<a name="6110"><span class="lineNum">    6110 </span>            : </a>
<a name="6111"><span class="lineNum">    6111 </span>            : #if 0</a>
<a name="6112"><span class="lineNum">    6112 </span>            :      printf (&quot;#########################################  functionType = %p ####################################### \n&quot;,functionType);</a>
<a name="6113"><span class="lineNum">    6113 </span>            : #endif</a>
<a name="6114"><span class="lineNum">    6114 </span>            : </a>
<a name="6115"><span class="lineNum">    6115 </span>            :   // DQ (12/26/2010): Not clear if this should be allowed or not...I would like to fix it later.</a>
<a name="6116"><span class="lineNum">    6116 </span>            :   // printf (&quot;NOTE: Sharing the function type argument list in use_statement_fixup() \n&quot;);</a>
<a name="6117"><span class="lineNum">    6117 </span>            :   // newFunctionType-&gt;set_argument_list(argument_list);</a>
<a name="6118"><span class="lineNum">    6118 </span>            : </a>
<a name="6119"><span class="lineNum">    6119 </span><span class="lineNoCov">          0 :      ROSE_ASSERT(functionType-&gt;get_argument_list() != NULL);</span></a>
<a name="6120"><span class="lineNum">    6120 </span><span class="lineNoCov">          0 :      SgTypePtrList &amp; functionArgumentTypeList = functionType-&gt;get_arguments();</span></a>
<a name="6121"><span class="lineNum">    6121 </span><span class="lineNoCov">          0 :      for (unsigned int i=0; i &lt; functionArgumentTypeList.size(); i++)</span></a>
<a name="6122"><span class="lineNum">    6122 </span>            :         {</a>
<a name="6123"><span class="lineNum">    6123 </span><span class="lineNoCov">          0 :           newFunctionType-&gt;append_argument(functionArgumentTypeList[i]);</span></a>
<a name="6124"><span class="lineNum">    6124 </span>            :         }</a>
<a name="6125"><span class="lineNum">    6125 </span>            : </a>
<a name="6126"><span class="lineNum">    6126 </span>            :   // Overwrite the function type for the function we are fixing up.</a>
<a name="6127"><span class="lineNum">    6127 </span>            :   // Note that the type we are overwriting may be shared so we can't delete it.</a>
<a name="6128"><span class="lineNum">    6128 </span><span class="lineNoCov">          0 :      functionDeclaration-&gt;set_type(newFunctionType);</span></a>
<a name="6129"><span class="lineNum">    6129 </span>            : </a>
<a name="6130"><span class="lineNum">    6130 </span>            : #if 0</a>
<a name="6131"><span class="lineNum">    6131 </span>            :      printf (&quot;Resetting the function type may cause this to have the mangled name unloaded from the mangled name cache... \n&quot;);</a>
<a name="6132"><span class="lineNum">    6132 </span>            : #endif</a>
<a name="6133"><span class="lineNum">    6133 </span>            : </a>
<a name="6134"><span class="lineNum">    6134 </span>            :   // functionDeclaration-&gt;get_scope()-&gt;print_symboltable (&quot;In use_statement_fixup() (after modifications 1)&quot;);</a>
<a name="6135"><span class="lineNum">    6135 </span>            : </a>
<a name="6136"><span class="lineNum">    6136 </span>            :   // I think we have to do this explicitly...double check on this as debugging step...</a>
<a name="6137"><span class="lineNum">    6137 </span>            :   // Reinsert the function into the symbol using the new function type of the fixed up function.</a>
<a name="6138"><span class="lineNum">    6138 </span>            :   // printf (&quot;Insert the new SgFunctionType into the global function type table! \n&quot;);</a>
<a name="6139"><span class="lineNum">    6139 </span>            :   // functionDeclaration-&gt;get_scope()-&gt;insert_function(functionDeclaration);</a>
<a name="6140"><span class="lineNum">    6140 </span>            : </a>
<a name="6141"><span class="lineNum">    6141 </span>            :   // Now build the function call and use the arguments from the ExprList on the top of the astExpressionStack!</a>
<a name="6142"><span class="lineNum">    6142 </span><span class="lineNoCov">          0 :      SgFunctionSymbol* newFunctionSymbol = new SgFunctionSymbol(functionDeclaration);</span></a>
<a name="6143"><span class="lineNum">    6143 </span>            : </a>
<a name="6144"><span class="lineNum">    6144 </span>            :   // Insert the function into the global scope so that we can find it later.</a>
<a name="6145"><span class="lineNum">    6145 </span><span class="lineNoCov">          0 :      functionDeclaration-&gt;get_scope()-&gt;insert_symbol(functionDeclaration-&gt;get_name(),newFunctionSymbol);</span></a>
<a name="6146"><span class="lineNum">    6146 </span>            : </a>
<a name="6147"><span class="lineNum">    6147 </span>            :   // functionDeclaration-&gt;get_scope()-&gt;print_symboltable (&quot;In use_statement_fixup() (after modifications 2)&quot;);</a>
<a name="6148"><span class="lineNum">    6148 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6149"><span class="lineNum">    6149 </span>            : </a>
<a name="6150"><span class="lineNum">    6150 </span>            : </a>
<a name="6151"><span class="lineNum">    6151 </span>            : void</a>
<a name="6152"><span class="lineNum">    6152 </span><span class="lineNoCov">          0 : fixup_possible_incomplete_function_return_type()</span></a>
<a name="6153"><span class="lineNum">    6153 </span>            :    {</a>
<a name="6154"><span class="lineNum">    6154 </span>            :   // DQ (12/26/2010): Factor out the fixup required for where use statements are used (e.g. function return types).</a>
<a name="6155"><span class="lineNum">    6155 </span>            : </a>
<a name="6156"><span class="lineNum">    6156 </span>            : #if 0</a>
<a name="6157"><span class="lineNum">    6157 </span>            :   // Output debugging information about saved state (stack) information.</a>
<a name="6158"><span class="lineNum">    6158 </span>            :      outputState(&quot;At TOP of fixup_possible_incomplete_function_return_type()&quot;);</a>
<a name="6159"><span class="lineNum">    6159 </span>            : #endif</a>
<a name="6160"><span class="lineNum">    6160 </span>            : </a>
<a name="6161"><span class="lineNum">    6161 </span>            :   // SgFunctionDefinition* functionDefinition   = TransformationSupport::getFunctionDefinition(astScopeStack.front());</a>
<a name="6162"><span class="lineNum">    6162 </span><span class="lineNoCov">          0 :      SgFunctionDeclaration* functionDeclaration = TransformationSupport::getFunctionDeclaration(astScopeStack.front());</span></a>
<a name="6163"><span class="lineNum">    6163 </span>            : </a>
<a name="6164"><span class="lineNum">    6164 </span>            :   // printf (&quot;functionDeclaration = %p \n&quot;,functionDeclaration);</a>
<a name="6165"><span class="lineNum">    6165 </span><span class="lineNoCov">          0 :      if (functionDeclaration != NULL)</span></a>
<a name="6166"><span class="lineNum">    6166 </span>            :         {</a>
<a name="6167"><span class="lineNum">    6167 </span>            :        // printf (&quot;functionDeclaration-&gt;get_name() = %s \n&quot;,functionDeclaration-&gt;get_name().str());</a>
<a name="6168"><span class="lineNum">    6168 </span>            : </a>
<a name="6169"><span class="lineNum">    6169 </span><span class="lineNoCov">          0 :           SgFunctionType* functionType = isSgFunctionType(functionDeclaration-&gt;get_type());</span></a>
<a name="6170"><span class="lineNum">    6170 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(functionType != NULL);</span></a>
<a name="6171"><span class="lineNum">    6171 </span>            :        // printf (&quot;functionType = %p = %s \n&quot;,functionType,functionType-&gt;class_name().c_str());</a>
<a name="6172"><span class="lineNum">    6172 </span>            : </a>
<a name="6173"><span class="lineNum">    6173 </span><span class="lineNoCov">          0 :           SgType* returnType = functionType-&gt;get_return_type();</span></a>
<a name="6174"><span class="lineNum">    6174 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(returnType != NULL);</span></a>
<a name="6175"><span class="lineNum">    6175 </span>            : </a>
<a name="6176"><span class="lineNum">    6176 </span>            :        // printf (&quot;returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="6177"><span class="lineNum">    6177 </span><span class="lineNoCov">          0 :           SgTypeDefault* defaultType = isSgTypeDefault(returnType);</span></a>
<a name="6178"><span class="lineNum">    6178 </span><span class="lineNoCov">          0 :           if (defaultType != NULL)</span></a>
<a name="6179"><span class="lineNum">    6179 </span>            :              {</a>
<a name="6180"><span class="lineNum">    6180 </span>            :             // The default type has to be fixed up...</a>
<a name="6181"><span class="lineNum">    6181 </span>            : </a>
<a name="6182"><span class="lineNum">    6182 </span><span class="lineNoCov">          0 :                SgName derivedTypeName = defaultType-&gt;get_name();</span></a>
<a name="6183"><span class="lineNum">    6183 </span>            :             // printf (&quot;derivedTypeName = %s \n&quot;,derivedTypeName.str());</a>
<a name="6184"><span class="lineNum">    6184 </span>            : </a>
<a name="6185"><span class="lineNum">    6185 </span>            :             // functionDeclaration-&gt;get_scope()-&gt;print_symboltable (&quot;In use_statement_fixup() (before modifications)&quot;);</a>
<a name="6186"><span class="lineNum">    6186 </span>            : </a>
<a name="6187"><span class="lineNum">    6187 </span><span class="lineNoCov">          0 :                SgClassSymbol* derivedTypeSymbol = trace_back_through_parent_scopes_lookup_derived_type_symbol( derivedTypeName, getTopOfScopeStack() );</span></a>
<a name="6188"><span class="lineNum">    6188 </span>            :             // printf (&quot;derivedTypeSymbol = %p \n&quot;,derivedTypeSymbol);</a>
<a name="6189"><span class="lineNum">    6189 </span>            :             // ROSE_ASSERT(derivedTypeSymbol != NULL);</a>
<a name="6190"><span class="lineNum">    6190 </span><span class="lineNoCov">          0 :                if (derivedTypeSymbol != NULL)</span></a>
<a name="6191"><span class="lineNum">    6191 </span>            :                   {</a>
<a name="6192"><span class="lineNum">    6192 </span><span class="lineNoCov">          0 :                     replace_return_type (functionType,functionDeclaration,derivedTypeSymbol);</span></a>
<a name="6193"><span class="lineNum">    6193 </span>            :                   }</a>
<a name="6194"><span class="lineNum">    6194 </span>            :              }</a>
<a name="6195"><span class="lineNum">    6195 </span>            :             else</a>
<a name="6196"><span class="lineNum">    6196 </span>            :              {</a>
<a name="6197"><span class="lineNum">    6197 </span>            :             // Handle case of test2010_180.f90 (if a type name in the current scope matches the name of </a>
<a name="6198"><span class="lineNum">    6198 </span>            :             // the specified return type then we want to fixup the function return type!</a>
<a name="6199"><span class="lineNum">    6199 </span>            : </a>
<a name="6200"><span class="lineNum">    6200 </span>            :             // printf (&quot;returnType = %p = %s \n&quot;,returnType,returnType-&gt;class_name().c_str());</a>
<a name="6201"><span class="lineNum">    6201 </span><span class="lineNoCov">          0 :                SgClassType* classType = isSgClassType(returnType);</span></a>
<a name="6202"><span class="lineNum">    6202 </span><span class="lineNoCov">          0 :                if (classType != NULL)</span></a>
<a name="6203"><span class="lineNum">    6203 </span>            :                   {</a>
<a name="6204"><span class="lineNum">    6204 </span>            :                  // The current SgClassType might have to be swapped for another in the function scope (another kind of fixup)...</a>
<a name="6205"><span class="lineNum">    6205 </span>            : </a>
<a name="6206"><span class="lineNum">    6206 </span>            :                  // printf (&quot;The current SgClassType might have to be swapped for another in the function scope (another kind of fixup)... \n&quot;);</a>
<a name="6207"><span class="lineNum">    6207 </span>            : </a>
<a name="6208"><span class="lineNum">    6208 </span><span class="lineNoCov">          0 :                     SgName derivedTypeName = classType-&gt;get_name();</span></a>
<a name="6209"><span class="lineNum">    6209 </span>            :                  // printf (&quot;derivedTypeName = %s \n&quot;,derivedTypeName.str());</a>
<a name="6210"><span class="lineNum">    6210 </span>            : </a>
<a name="6211"><span class="lineNum">    6211 </span><span class="lineNoCov">          0 :                     SgClassSymbol* derivedTypeSymbol = trace_back_through_parent_scopes_lookup_derived_type_symbol( derivedTypeName, getTopOfScopeStack() );</span></a>
<a name="6212"><span class="lineNum">    6212 </span>            : </a>
<a name="6213"><span class="lineNum">    6213 </span><span class="lineNoCov">          0 :                     replace_return_type (functionType,functionDeclaration,derivedTypeSymbol);</span></a>
<a name="6214"><span class="lineNum">    6214 </span>            :                   }</a>
<a name="6215"><span class="lineNum">    6215 </span>            :              }</a>
<a name="6216"><span class="lineNum">    6216 </span>            :         }</a>
<a name="6217"><span class="lineNum">    6217 </span>            : </a>
<a name="6218"><span class="lineNum">    6218 </span>            :   // printf (&quot;Exiting at bottom of use_statement_fixup() \n&quot;);</a>
<a name="6219"><span class="lineNum">    6219 </span>            :   // ROSE_ASSERT(false);</a>
<a name="6220"><span class="lineNum">    6220 </span>            : </a>
<a name="6221"><span class="lineNum">    6221 </span>            :   // printf (&quot;Leaving fixup_possible_incomplete_function_return_type() \n&quot;);</a>
<a name="6222"><span class="lineNum">    6222 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6223"><span class="lineNum">    6223 </span>            : </a>
<a name="6224"><span class="lineNum">    6224 </span>            : void</a>
<a name="6225"><span class="lineNum">    6225 </span><span class="lineNoCov">          0 : use_statement_fixup()</span></a>
<a name="6226"><span class="lineNum">    6226 </span>            :    {</a>
<a name="6227"><span class="lineNum">    6227 </span>            :   // printf (&quot;Inside of use_statement_fixup() \n&quot;);</a>
<a name="6228"><span class="lineNum">    6228 </span>            : </a>
<a name="6229"><span class="lineNum">    6229 </span>            :   // Refactored this code to be called in R433 and R1109.</a>
<a name="6230"><span class="lineNum">    6230 </span><span class="lineNoCov">          0 :      fixup_possible_incomplete_function_return_type();</span></a>
<a name="6231"><span class="lineNum">    6231 </span>            : </a>
<a name="6232"><span class="lineNum">    6232 </span>            :   // printf (&quot;Leaving use_statement_fixup() \n&quot;);</a>
<a name="6233"><span class="lineNum">    6233 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6234"><span class="lineNum">    6234 </span>            : </a>
<a name="6235"><span class="lineNum">    6235 </span>            : </a>
<a name="6236"><span class="lineNum">    6236 </span>            : string </a>
<a name="6237"><span class="lineNum">    6237 </span><span class="lineNoCov">          0 : generateQualifiedName(const std::vector&lt;MultipartReferenceType&gt; &amp; qualifiedNameList)</span></a>
<a name="6238"><span class="lineNum">    6238 </span>            :    {</a>
<a name="6239"><span class="lineNum">    6239 </span>            :   // DQ (12/29/2010): This function isolates some of the R612 and R613 handling and support.</a>
<a name="6240"><span class="lineNum">    6240 </span><span class="lineNoCov">          0 :      string qualifiedNameString;</span></a>
<a name="6241"><span class="lineNum">    6241 </span>            : </a>
<a name="6242"><span class="lineNum">    6242 </span><span class="lineNoCov">          0 :      size_t numberOfParts = qualifiedNameList.size();</span></a>
<a name="6243"><span class="lineNum">    6243 </span><span class="lineNoCov">          0 :      for (size_t i = 0; i &lt; numberOfParts; i++)</span></a>
<a name="6244"><span class="lineNum">    6244 </span>            :         {</a>
<a name="6245"><span class="lineNum">    6245 </span><span class="lineNoCov">          0 :           qualifiedNameString = qualifiedNameString + qualifiedNameList[i].name;</span></a>
<a name="6246"><span class="lineNum">    6246 </span>            : </a>
<a name="6247"><span class="lineNum">    6247 </span><span class="lineNoCov">          0 :           if (i &lt; numberOfParts-1)</span></a>
<a name="6248"><span class="lineNum">    6248 </span><span class="lineNoCov">          0 :                qualifiedNameString = qualifiedNameString + '%';</span></a>
<a name="6249"><span class="lineNum">    6249 </span>            :         }</a>
<a name="6250"><span class="lineNum">    6250 </span>            : </a>
<a name="6251"><span class="lineNum">    6251 </span>            :   // printf (&quot;In generateQualifiedName(): qualifiedNameString = %s \n&quot;,qualifiedNameString.c_str());</a>
<a name="6252"><span class="lineNum">    6252 </span>            : </a>
<a name="6253"><span class="lineNum">    6253 </span><span class="lineNoCov">          0 :      return qualifiedNameString;</span></a>
<a name="6254"><span class="lineNum">    6254 </span>            :    }</a>
<a name="6255"><span class="lineNum">    6255 </span>            : </a>
<a name="6256"><span class="lineNum">    6256 </span>            : void</a>
<a name="6257"><span class="lineNum">    6257 </span><span class="lineCov">         40 : fixup_forward_type_declarations()</span></a>
<a name="6258"><span class="lineNum">    6258 </span>            :    {</a>
<a name="6259"><span class="lineNum">    6259 </span><span class="lineCov">         40 :      SgScopeStatement* currentScope = astScopeStack.front();</span></a>
<a name="6260"><span class="lineNum">    6260 </span><span class="lineCov">         40 :      Rose_STL_Container&lt;SgNode*&gt; typeList = NodeQuery::generateListOfTypes(currentScope);</span></a>
<a name="6261"><span class="lineNum">    6261 </span>            : #if 0</a>
<a name="6262"><span class="lineNum">    6262 </span>            :      printf (&quot;Inside of fixup_forward_type_declarations() \n&quot;);</a>
<a name="6263"><span class="lineNum">    6263 </span>            :      printf (&quot;Searching declarations in currentScope = %p = %s \n&quot;,currentScope,currentScope-&gt;class_name().c_str());</a>
<a name="6264"><span class="lineNum">    6264 </span>            :      printf (&quot;typeList.size() = %&quot; PRIuPTR &quot; \n&quot;,typeList.size());</a>
<a name="6265"><span class="lineNum">    6265 </span>            : #endif</a>
<a name="6266"><span class="lineNum">    6266 </span>            : </a>
<a name="6267"><span class="lineNum">    6267 </span><span class="lineCov">        500 :      for (size_t i = 0; i &lt; typeList.size(); i++)</span></a>
<a name="6268"><span class="lineNum">    6268 </span>            :         {</a>
<a name="6269"><span class="lineNum">    6269 </span>            : #if 0</a>
<a name="6270"><span class="lineNum">    6270 </span>            :           printf (&quot;typeList[%&quot; PRIuPTR &quot;] = %p = %s \n&quot;,i,typeList[i],typeList[i]-&gt;class_name().c_str());</a>
<a name="6271"><span class="lineNum">    6271 </span>            : #endif</a>
<a name="6272"><span class="lineNum">    6272 </span><span class="lineCov">        460 :           SgTypeDefault* defaultType = isSgTypeDefault(typeList[i]);</span></a>
<a name="6273"><span class="lineNum">    6273 </span><span class="lineCov">        460 :           if (defaultType != NULL)</span></a>
<a name="6274"><span class="lineNum">    6274 </span>            :              {</a>
<a name="6275"><span class="lineNum">    6275 </span>            :             // This uses the order of the vector generated from NodeQuery::generateListOfTypes(), this might be a problem.</a>
<a name="6276"><span class="lineNum">    6276 </span><span class="lineNoCov">          0 :                size_t parentTypeIndex = i-1;</span></a>
<a name="6277"><span class="lineNum">    6277 </span><span class="lineNoCov">          0 :                SgType* parentType = isSgType(typeList[parentTypeIndex]);</span></a>
<a name="6278"><span class="lineNum">    6278 </span><span class="lineNoCov">          0 :                ROSE_ASSERT(parentType != NULL);</span></a>
<a name="6279"><span class="lineNum">    6279 </span>            :             // ROSE_ASSERT(parentType-&gt;containsInternalTypes() == true);</a>
<a name="6280"><span class="lineNum">    6280 </span>            : #if 0</a>
<a name="6281"><span class="lineNum">    6281 </span>            :                printf (&quot;parentType-&gt;containsInternalTypes() = %s \n&quot;,parentType-&gt;containsInternalTypes() ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6282"><span class="lineNum">    6282 </span>            : #endif</a>
<a name="6283"><span class="lineNum">    6283 </span><span class="lineNoCov">          0 :                if (parentType-&gt;containsInternalTypes() == true)</span></a>
<a name="6284"><span class="lineNum">    6284 </span>            :                   {</a>
<a name="6285"><span class="lineNum">    6285 </span><span class="lineNoCov">          0 :                     string nameOfIntendedType = defaultType-&gt;get_name();</span></a>
<a name="6286"><span class="lineNum">    6286 </span>            : #if 0</a>
<a name="6287"><span class="lineNum">    6287 </span>            :                     printf (&quot;Reset the base type in parentType = %p = %s to nameOfIntendedType = %s \n&quot;,parentType,parentType-&gt;class_name().c_str(),nameOfIntendedType.c_str());</a>
<a name="6288"><span class="lineNum">    6288 </span>            : #endif</a>
<a name="6289"><span class="lineNum">    6289 </span><span class="lineNoCov">          0 :                     SgSymbol* symbolOfIntendedType = currentScope-&gt;lookup_symbol(nameOfIntendedType);</span></a>
<a name="6290"><span class="lineNum">    6290 </span>            : #if 0</a>
<a name="6291"><span class="lineNum">    6291 </span>            :                  // DQ (1/30/2011): This is a bug in OFP that is being fixed by Craig.</a>
<a name="6292"><span class="lineNum">    6292 </span>            :                     ROSE_ASSERT(symbolOfIntendedType != NULL);</a>
<a name="6293"><span class="lineNum">    6293 </span>            : </a>
<a name="6294"><span class="lineNum">    6294 </span>            :                     SgType* intendedType = symbolOfIntendedType-&gt;get_type();</a>
<a name="6295"><span class="lineNum">    6295 </span>            :                     ROSE_ASSERT(intendedType != NULL);</a>
<a name="6296"><span class="lineNum">    6296 </span>            : </a>
<a name="6297"><span class="lineNum">    6297 </span>            :                     parentType-&gt;reset_base_type(intendedType);</a>
<a name="6298"><span class="lineNum">    6298 </span>            : #else</a>
<a name="6299"><span class="lineNum">    6299 </span>            :                  // DQ (1/30/2011): For now just test to make sure it is a valid symbol before trying to fixup the type.</a>
<a name="6300"><span class="lineNum">    6300 </span><span class="lineNoCov">          0 :                     if (symbolOfIntendedType != NULL)</span></a>
<a name="6301"><span class="lineNum">    6301 </span>            :                        {</a>
<a name="6302"><span class="lineNum">    6302 </span><span class="lineNoCov">          0 :                          SgType* intendedType = symbolOfIntendedType-&gt;get_type();</span></a>
<a name="6303"><span class="lineNum">    6303 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(intendedType != NULL);</span></a>
<a name="6304"><span class="lineNum">    6304 </span>            : </a>
<a name="6305"><span class="lineNum">    6305 </span><span class="lineNoCov">          0 :                          parentType-&gt;reset_base_type(intendedType);</span></a>
<a name="6306"><span class="lineNum">    6306 </span>            :                        }</a>
<a name="6307"><span class="lineNum">    6307 </span>            :                       else</a>
<a name="6308"><span class="lineNum">    6308 </span>            :                        {</a>
<a name="6309"><span class="lineNum">    6309 </span><span class="lineNoCov">          0 :                          printf (&quot;WARNING: This is a bug in OFP (see test2011_26.f03) (ignoring the problem for now...) \n&quot;);</span></a>
<a name="6310"><span class="lineNum">    6310 </span>            :                        }                    </a>
<a name="6311"><span class="lineNum">    6311 </span>            : #endif</a>
<a name="6312"><span class="lineNum">    6312 </span>            :                   }</a>
<a name="6313"><span class="lineNum">    6313 </span>            :              }</a>
<a name="6314"><span class="lineNum">    6314 </span>            :         }</a>
<a name="6315"><span class="lineNum">    6315 </span>            : #if 0</a>
<a name="6316"><span class="lineNum">    6316 </span>            :      printf (&quot;Leaving fixup_forward_type_declarations() \n&quot;);</a>
<a name="6317"><span class="lineNum">    6317 </span>            : #endif</a>
<a name="6318"><span class="lineNum">    6318 </span><span class="lineCov">         40 :    }</span></a>
<a name="6319"><span class="lineNum">    6319 </span>            : </a>
<a name="6320"><span class="lineNum">    6320 </span>            : </a>
<a name="6321"><span class="lineNum">    6321 </span>            : void </a>
<a name="6322"><span class="lineNum">    6322 </span><span class="lineNoCov">          0 : processAttributeSpecStack(bool hasArraySpec, bool hasInitialization)</span></a>
<a name="6323"><span class="lineNum">    6323 </span>            :    {</a>
<a name="6324"><span class="lineNum">    6324 </span>            :   // DQ (1/16/2011): Now is the latest point where we can process the type.  We have now seen all of the</a>
<a name="6325"><span class="lineNum">    6325 </span>            :   // attributes and they are on the astAttributeSpecStack stack (which we can use to construct the</a>
<a name="6326"><span class="lineNum">    6326 </span>            :   // correct base type (from the current base type).  Note that if there is an initializer for the</a>
<a name="6327"><span class="lineNum">    6327 </span>            :   // variable it will be on top of the stack.  so this might be a better thing to handle AFTER the</a>
<a name="6328"><span class="lineNum">    6328 </span>            :   // initializer has been consumed...</a>
<a name="6329"><span class="lineNum">    6329 </span><span class="lineNoCov">          0 :      vector&lt;int&gt; savedAttributes;</span></a>
<a name="6330"><span class="lineNum">    6330 </span>            :   // printf (&quot;In processAttributeSpecStack(): astAttributeSpecStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astAttributeSpecStack.size());</a>
<a name="6331"><span class="lineNum">    6331 </span>            : </a>
<a name="6332"><span class="lineNum">    6332 </span><span class="lineNoCov">          0 :      std::list&lt;int&gt;::iterator i = astAttributeSpecStack.begin();</span></a>
<a name="6333"><span class="lineNum">    6333 </span>            :   // while (astAttributeSpecStack.empty() == false)</a>
<a name="6334"><span class="lineNum">    6334 </span><span class="lineNoCov">          0 :      while (i != astAttributeSpecStack.end())</span></a>
<a name="6335"><span class="lineNum">    6335 </span>            :         {</a>
<a name="6336"><span class="lineNum">    6336 </span>            :        // Some attributes that are not order dependent (are there any in Fortran) should maybe we saved and put back on the stack.</a>
<a name="6337"><span class="lineNum">    6337 </span>            : </a>
<a name="6338"><span class="lineNum">    6338 </span>            : #if 0</a>
<a name="6339"><span class="lineNum">    6339 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="6340"><span class="lineNum">    6340 </span>            :           outputState(&quot;In loop over attributes in processAttributeSpecStack()&quot;);</a>
<a name="6341"><span class="lineNum">    6341 </span>            : #endif</a>
<a name="6342"><span class="lineNum">    6342 </span>            : </a>
<a name="6343"><span class="lineNum">    6343 </span>            :        // int attr = astAttributeSpecStack.front();</a>
<a name="6344"><span class="lineNum">    6344 </span><span class="lineNoCov">          0 :           int attr = *i;</span></a>
<a name="6345"><span class="lineNum">    6345 </span>            :        // printf (&quot;attribute spec on stack = %d \n&quot;,attr);</a>
<a name="6346"><span class="lineNum">    6346 </span>            : </a>
<a name="6347"><span class="lineNum">    6347 </span>            :        // Note that we need to handle just those attributes that effect the base type of the declaration.</a>
<a name="6348"><span class="lineNum">    6348 </span>            :        // But since all attributes are stored on the stack we have to pop them all off, find the relevant </a>
<a name="6349"><span class="lineNum">    6349 </span>            :        // ones that effect the type, and then rebuild the stack.</a>
<a name="6350"><span class="lineNum">    6350 </span><span class="lineNoCov">          0 :           switch(attr)</span></a>
<a name="6351"><span class="lineNum">    6351 </span>            :              {</a>
<a name="6352"><span class="lineNum">    6352 </span>            :             // DQ (1/20/2011): Added case of ComponentAttrSpec_dimension</a>
<a name="6353"><span class="lineNum">    6353 </span><span class="lineNoCov">          0 :                case AttrSpec_DIMENSION:</span></a>
<a name="6354"><span class="lineNum">    6354 </span><span class="lineNoCov">          0 :                case ComponentAttrSpec_dimension:</span></a>
<a name="6355"><span class="lineNum">    6355 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="6356"><span class="lineNum">    6356 </span>            :                  // Handle astAttributeSpecStack.push_front(AttrSpec_DIMENSION); done previously.</a>
<a name="6357"><span class="lineNum">    6357 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="6358"><span class="lineNum">    6358 </span><span class="lineNoCov">          0 :                          printf (&quot;found a DIMENSION spec \n&quot;);</span></a>
<a name="6359"><span class="lineNum">    6359 </span>            : </a>
<a name="6360"><span class="lineNum">    6360 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="6361"><span class="lineNum">    6361 </span>            :                  // printf (&quot;Here is where we need to build an array (where the base type has finally be correctly computed = %s \n&quot;,astBaseTypeStack.front()-&gt;class_name().c_str());</a>
<a name="6362"><span class="lineNum">    6362 </span>            : </a>
<a name="6363"><span class="lineNum">    6363 </span>            :                  // At this point the array type is already built, but is built using the base type, also it is on the astTypeStack, and not the astBaseTypeStack.</a>
<a name="6364"><span class="lineNum">    6364 </span>            :                  // so we move it to the astBaseTypeStack stack.</a>
<a name="6365"><span class="lineNum">    6365 </span>            : </a>
<a name="6366"><span class="lineNum">    6366 </span>            :                  // We don't know the count yet, not clear where we get that (assume 1 for initial test).</a>
<a name="6367"><span class="lineNum">    6367 </span>            :                  // Note that this parameter is no longer used, so it should be removed!</a>
<a name="6368"><span class="lineNum">    6368 </span>            :                  // printf (&quot;REMOVE USE OF count PARAMETER IN convertTypeOnStackToArrayType() \n&quot;);</a>
<a name="6369"><span class="lineNum">    6369 </span>            : </a>
<a name="6370"><span class="lineNum">    6370 </span>            :                  // If the array spec is a part of the multi-part reference then process it as such and build the type on the astTypeStack (specific for that variable), else build it for the astBaseTypeStack for all variables.</a>
<a name="6371"><span class="lineNum">    6371 </span>            :                  // if (hasArraySpec == true)</a>
<a name="6372"><span class="lineNum">    6372 </span>            :                  // printf (&quot;In processAttributeSpecStack(): hasArraySpec = %s hasInitialization = %s \n&quot;,hasArraySpec ? &quot;true&quot; : &quot;false&quot;, hasInitialization ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="6373"><span class="lineNum">    6373 </span>            : </a>
<a name="6374"><span class="lineNum">    6374 </span>            :                  // DQ (1/22/2011): Not clear now to handle hasInitialization...</a>
<a name="6375"><span class="lineNum">    6375 </span>            :                  // if (hasArraySpec == true || hasInitialization == false)</a>
<a name="6376"><span class="lineNum">    6376 </span>            :                  // if (hasArraySpec == true)</a>
<a name="6377"><span class="lineNum">    6377 </span>            :                  // if (astTypeStack.empty() == true || hasArraySpec == true)</a>
<a name="6378"><span class="lineNum">    6378 </span>            : </a>
<a name="6379"><span class="lineNum">    6379 </span><span class="lineNoCov">          0 :                     if (hasInitialization == false)</span></a>
<a name="6380"><span class="lineNum">    6380 </span>            :                        {</a>
<a name="6381"><span class="lineNum">    6381 </span><span class="lineNoCov">          0 :                          if ((astTypeStack.empty() == true) || (hasArraySpec == true) ) // This is a problem for test2011_16.f90</span></a>
<a name="6382"><span class="lineNum">    6382 </span>            :                             {</a>
<a name="6383"><span class="lineNum">    6383 </span><span class="lineNoCov">          0 :                               if (hasArraySpec == true)</span></a>
<a name="6384"><span class="lineNum">    6384 </span>            :                                  {</a>
<a name="6385"><span class="lineNum">    6385 </span>            :                                 // DQ (1/18/2011): </a>
<a name="6386"><span class="lineNum">    6386 </span><span class="lineNoCov">          0 :                                    int count = 1;</span></a>
<a name="6387"><span class="lineNum">    6387 </span><span class="lineNoCov">          0 :                                    SgArrayType* arrayType = convertTypeOnStackToArrayType(count);</span></a>
<a name="6388"><span class="lineNum">    6388 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(arrayType != NULL);</span></a>
<a name="6389"><span class="lineNum">    6389 </span>            : </a>
<a name="6390"><span class="lineNum">    6390 </span>            :                                 // DQ (1/17/2011): Fixup the call to convertTypeOnStackToArrayType() to prepare a value on the correct type stack. See test2007_101.f90 for an example.</a>
<a name="6391"><span class="lineNum">    6391 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="6392"><span class="lineNum">    6392 </span>            : </a>
<a name="6393"><span class="lineNum">    6393 </span>            :                                 // This is false for test2011_23.f90 (&quot;character :: A(2)*7)&quot;) but true nearly everywhere else...</a>
<a name="6394"><span class="lineNum">    6394 </span>            :                                 // ROSE_ASSERT(astTypeStack.empty() == true);</a>
<a name="6395"><span class="lineNum">    6395 </span><span class="lineNoCov">          0 :                                    if (astTypeStack.empty() == false)</span></a>
<a name="6396"><span class="lineNum">    6396 </span>            :                                       {</a>
<a name="6397"><span class="lineNum">    6397 </span>            :                                      // When multiple specifiers are used (e.g. arrays of strings) to construct non-base types we</a>
<a name="6398"><span class="lineNum">    6398 </span>            :                                      // do so in place at the front of the astTypeStack.  There should be at most a single entry.</a>
<a name="6399"><span class="lineNum">    6399 </span>            :                                      // printf (&quot;Handling case of declarations such as: character :: A(2)*7) \n&quot;);</a>
<a name="6400"><span class="lineNum">    6400 </span><span class="lineNoCov">          0 :                                         astTypeStack.pop_front();</span></a>
<a name="6401"><span class="lineNum">    6401 </span>            :                                       }</a>
<a name="6402"><span class="lineNum">    6402 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="6403"><span class="lineNum">    6403 </span>            :                                    </a>
<a name="6404"><span class="lineNum">    6404 </span><span class="lineNoCov">          0 :                                    astTypeStack.push_front(arrayType);</span></a>
<a name="6405"><span class="lineNum">    6405 </span>            :                                  }</a>
<a name="6406"><span class="lineNum">    6406 </span>            :                                 else</a>
<a name="6407"><span class="lineNum">    6407 </span>            :                                  {</a>
<a name="6408"><span class="lineNum">    6408 </span>            :                                 // We want to use the type in astTypeStack, so push the base type from astBaseTypeStack</a>
<a name="6409"><span class="lineNum">    6409 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="6410"><span class="lineNum">    6410 </span>            :                                 // ROSE_ASSERT(astBaseTypeStack.empty() == true);</a>
<a name="6411"><span class="lineNum">    6411 </span>            : </a>
<a name="6412"><span class="lineNum">    6412 </span><span class="lineNoCov">          0 :                                    if (astExpressionStack.empty() == false)</span></a>
<a name="6413"><span class="lineNum">    6413 </span>            :                                       {</a>
<a name="6414"><span class="lineNum">    6414 </span><span class="lineNoCov">          0 :                                         int count = 1;</span></a>
<a name="6415"><span class="lineNum">    6415 </span><span class="lineNoCov">          0 :                                         SgArrayType* arrayType = convertTypeOnStackToArrayType(count);</span></a>
<a name="6416"><span class="lineNum">    6416 </span><span class="lineNoCov">          0 :                                         ROSE_ASSERT(arrayType != NULL);</span></a>
<a name="6417"><span class="lineNum">    6417 </span><span class="lineNoCov">          0 :                                         astBaseTypeStack.pop_front();</span></a>
<a name="6418"><span class="lineNum">    6418 </span><span class="lineNoCov">          0 :                                         astBaseTypeStack.push_front(arrayType);</span></a>
<a name="6419"><span class="lineNum">    6419 </span><span class="lineNoCov">          0 :                                         astTypeStack.push_front(astBaseTypeStack.front());</span></a>
<a name="6420"><span class="lineNum">    6420 </span>            :                                       }</a>
<a name="6421"><span class="lineNum">    6421 </span>            :                                      else</a>
<a name="6422"><span class="lineNum">    6422 </span>            :                                       {</a>
<a name="6423"><span class="lineNum">    6423 </span>            :                                      // See test2011_07.f90 for an example of why this is required.</a>
<a name="6424"><span class="lineNum">    6424 </span><span class="lineNoCov">          0 :                                         astTypeStack.push_front(astBaseTypeStack.front());</span></a>
<a name="6425"><span class="lineNum">    6425 </span>            :                                       }</a>
<a name="6426"><span class="lineNum">    6426 </span>            :                                  }</a>
<a name="6427"><span class="lineNum">    6427 </span>            : </a>
<a name="6428"><span class="lineNum">    6428 </span>            :                            // printf (&quot;Error, we want to build or modify only the the type in the astTypeStack and not touch the type in the astBaseTypeStack \n&quot;);</a>
<a name="6429"><span class="lineNum">    6429 </span>            :                            // ROSE_ASSERT(false);</a>
<a name="6430"><span class="lineNum">    6430 </span>            :                             }</a>
<a name="6431"><span class="lineNum">    6431 </span>            :                            else</a>
<a name="6432"><span class="lineNum">    6432 </span>            :                             {</a>
<a name="6433"><span class="lineNum">    6433 </span>            :                            // Nothing do do here since the array type was processed previously!</a>
<a name="6434"><span class="lineNum">    6434 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="6435"><span class="lineNum">    6435 </span>            :                            // ROSE_ASSERT(astTypeStack.empty() == false);</a>
<a name="6436"><span class="lineNum">    6436 </span>            :                            // ROSE_ASSERT(astTypeStack.empty() == true);</a>
<a name="6437"><span class="lineNum">    6437 </span>            :                             }</a>
<a name="6438"><span class="lineNum">    6438 </span>            :                        }</a>
<a name="6439"><span class="lineNum">    6439 </span>            :                       else</a>
<a name="6440"><span class="lineNum">    6440 </span>            :                        {</a>
<a name="6441"><span class="lineNum">    6441 </span>            :                       // This is the case of test2011_16.f90</a>
<a name="6442"><span class="lineNum">    6442 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(hasInitialization == true);</span></a>
<a name="6443"><span class="lineNum">    6443 </span>            : </a>
<a name="6444"><span class="lineNum">    6444 </span>            :                       // DQ (1/23/2011): In test2011_19.f90 (&quot;integer, dimension(2,kmax0) :: X(2,kmax1) = reshape( (/5,6/), (/2,kmax2/) )&quot;)</a>
<a name="6445"><span class="lineNum">    6445 </span>            :                       // since hasInitialization is true when processing X and now with R469 list c_action_ac_value_list__begin() now</a>
<a name="6446"><span class="lineNum">    6446 </span>            :                       // processing array types (e.g. for X) using convertTypeOnStackToArrayType() we don't want to process it here.</a>
<a name="6447"><span class="lineNum">    6447 </span>            : </a>
<a name="6448"><span class="lineNum">    6448 </span><span class="lineNoCov">          0 :                          if (hasArraySpec == true)</span></a>
<a name="6449"><span class="lineNum">    6449 </span>            :                             {</a>
<a name="6450"><span class="lineNum">    6450 </span>            :                            // printf (&quot;############ Sometimes we WANT to process this into an array ############## \n&quot;);</a>
<a name="6451"><span class="lineNum">    6451 </span>            : </a>
<a name="6452"><span class="lineNum">    6452 </span>            :                            // DQ (1/23/2011): If hasInitialization == true then the initializer is on the top of the stack and the array bound expression is beneath it.</a>
<a name="6453"><span class="lineNum">    6453 </span>            :                            // Save the initializer and put it back on the stack after we process the array expression.</a>
<a name="6454"><span class="lineNum">    6454 </span><span class="lineNoCov">          0 :                               ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="6455"><span class="lineNum">    6455 </span><span class="lineNoCov">          0 :                               SgExpression* initializer = astExpressionStack.front();</span></a>
<a name="6456"><span class="lineNum">    6456 </span><span class="lineNoCov">          0 :                               astExpressionStack.pop_front();</span></a>
<a name="6457"><span class="lineNum">    6457 </span>            : </a>
<a name="6458"><span class="lineNum">    6458 </span>            :                            // This is code need to handle test2011_16.f90 (but might make some other code fail, e.g. test2010_136.f90 and test2011_19.f90)!</a>
<a name="6459"><span class="lineNum">    6459 </span><span class="lineNoCov">          0 :                               SgExprListExp* exprListExp = astExpressionStack.empty() == false ? isSgExprListExp(astExpressionStack.front()) : NULL;</span></a>
<a name="6460"><span class="lineNum">    6460 </span><span class="lineNoCov">          0 :                               if (exprListExp != NULL)</span></a>
<a name="6461"><span class="lineNum">    6461 </span>            :                                  {</a>
<a name="6462"><span class="lineNum">    6462 </span><span class="lineNoCov">          0 :                                    int count = 1;</span></a>
<a name="6463"><span class="lineNum">    6463 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="6464"><span class="lineNum">    6464 </span><span class="lineNoCov">          0 :                                    SgArrayType* arrayType = convertTypeOnStackToArrayType(count);</span></a>
<a name="6465"><span class="lineNum">    6465 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(arrayType != NULL);</span></a>
<a name="6466"><span class="lineNum">    6466 </span>            : </a>
<a name="6467"><span class="lineNum">    6467 </span>            :                                 // DQ (1/17/2011): Fixup the call to convertTypeOnStackToArrayType() to prepare a value on the correct type stack. See test2007_101.f90 for an example.</a>
<a name="6468"><span class="lineNum">    6468 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astBaseTypeStack.empty() == false);</span></a>
<a name="6469"><span class="lineNum">    6469 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="6470"><span class="lineNum">    6470 </span>            : </a>
<a name="6471"><span class="lineNum">    6471 </span><span class="lineNoCov">          0 :                                    astTypeStack.push_front(arrayType);</span></a>
<a name="6472"><span class="lineNum">    6472 </span>            :                                  }</a>
<a name="6473"><span class="lineNum">    6473 </span>            :                                 else</a>
<a name="6474"><span class="lineNum">    6474 </span>            :                                  {</a>
<a name="6475"><span class="lineNum">    6475 </span>            :                                 // DQ (1/23/2011): This is the case for test2011_19.f90 and test2010_136.f90</a>
<a name="6476"><span class="lineNum">    6476 </span>            :                                 // printf (&quot;This array attribute has previously been turned into an array, so we don't have to worry about it... \n&quot;);</a>
<a name="6477"><span class="lineNum">    6477 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(astTypeStack.empty() == false);</span></a>
<a name="6478"><span class="lineNum">    6478 </span><span class="lineNoCov">          0 :                                    ROSE_ASSERT(isSgArrayType(astTypeStack.front()) != NULL);</span></a>
<a name="6479"><span class="lineNum">    6479 </span>            :                                  }</a>
<a name="6480"><span class="lineNum">    6480 </span>            : </a>
<a name="6481"><span class="lineNum">    6481 </span>            :                            // Put the initializer back</a>
<a name="6482"><span class="lineNum">    6482 </span><span class="lineNoCov">          0 :                               astExpressionStack.push_front(initializer);</span></a>
<a name="6483"><span class="lineNum">    6483 </span>            :                             }</a>
<a name="6484"><span class="lineNum">    6484 </span>            :                            else</a>
<a name="6485"><span class="lineNum">    6485 </span>            :                             {</a>
<a name="6486"><span class="lineNum">    6486 </span>            :                            // printf (&quot;############ Sometimes we DON'T want to process this into an array ############## \n&quot;);</a>
<a name="6487"><span class="lineNum">    6487 </span>            :                             }</a>
<a name="6488"><span class="lineNum">    6488 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="6489"><span class="lineNum">    6489 </span>            :                        }</a>
<a name="6490"><span class="lineNum">    6490 </span>            : #if 0</a>
<a name="6491"><span class="lineNum">    6491 </span>            :                  // Output debugging information about saved state (stack) information.</a>
<a name="6492"><span class="lineNum">    6492 </span>            :                     outputState(&quot;In processAttributeSpecStack(): After processing type for AttrSpec_DIMENSION&quot;);</a>
<a name="6493"><span class="lineNum">    6493 </span>            : #endif</a>
<a name="6494"><span class="lineNum">    6494 </span>            :                  // Increment as many times as required past this dimension case.</a>
<a name="6495"><span class="lineNum">    6495 </span><span class="lineNoCov">          0 :                     while (i != astAttributeSpecStack.end() &amp;&amp; (*i == AttrSpec_DIMENSION || *i == ComponentAttrSpec_dimension) )</span></a>
<a name="6496"><span class="lineNum">    6496 </span>            :                        {</a>
<a name="6497"><span class="lineNum">    6497 </span><span class="lineNoCov">          0 :                          i++;</span></a>
<a name="6498"><span class="lineNum">    6498 </span>            :                        }</a>
<a name="6499"><span class="lineNum">    6499 </span>            : #if 0</a>
<a name="6500"><span class="lineNum">    6500 </span>            :                  // Output debugging information about saved state (stack) information.</a>
<a name="6501"><span class="lineNum">    6501 </span>            :                     outputState(&quot;After processing AttrSpec_DIMENSION in loop over attributes in R504 R503-F2008 c_action_entity_decl()&quot;);</a>
<a name="6502"><span class="lineNum">    6502 </span>            : #endif</a>
<a name="6503"><span class="lineNum">    6503 </span>            :                     break;</a>
<a name="6504"><span class="lineNum">    6504 </span>            :                   }</a>
<a name="6505"><span class="lineNum">    6505 </span>            : </a>
<a name="6506"><span class="lineNum">    6506 </span>            :             // DQ (1/20/2011): Added case of ComponentAttrSpec_pointer</a>
<a name="6507"><span class="lineNum">    6507 </span><span class="lineNoCov">          0 :                case AttrSpec_POINTER:</span></a>
<a name="6508"><span class="lineNum">    6508 </span><span class="lineNoCov">          0 :                case ComponentAttrSpec_pointer:</span></a>
<a name="6509"><span class="lineNum">    6509 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="6510"><span class="lineNum">    6510 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="6511"><span class="lineNum">    6511 </span><span class="lineNoCov">          0 :                          printf (&quot;found a POINTER spec \n&quot;);</span></a>
<a name="6512"><span class="lineNum">    6512 </span>            : </a>
<a name="6513"><span class="lineNum">    6513 </span><span class="lineNoCov">          0 :                     if (astTypeStack.empty() == false)</span></a>
<a name="6514"><span class="lineNum">    6514 </span>            :                        {</a>
<a name="6515"><span class="lineNum">    6515 </span>            :                       // Because the pointer attribute specification applies to the base type we have to force this to be applied to the base type.</a>
<a name="6516"><span class="lineNum">    6516 </span>            :                       // So clear the astTypeStack so that the convertBaseTypeOnStackToPointer() will leave the generate type on the astBaseTypeStack.</a>
<a name="6517"><span class="lineNum">    6517 </span>            :                       // Since the convertBaseTypeOnStackToPointer() is only called from this function we could change the semantics of that function</a>
<a name="6518"><span class="lineNum">    6518 </span>            :                       // to include this semantics.</a>
<a name="6519"><span class="lineNum">    6519 </span>            :                       // printf (&quot;Clear the type on the astTypeStack so that it can be recreated! \n&quot;);</a>
<a name="6520"><span class="lineNum">    6520 </span><span class="lineNoCov">          0 :                          astTypeStack.pop_front();</span></a>
<a name="6521"><span class="lineNum">    6521 </span>            :                        }</a>
<a name="6522"><span class="lineNum">    6522 </span>            : </a>
<a name="6523"><span class="lineNum">    6523 </span>            :                  // DQ (2/1/2009): Change the type on the astBaseTypeStack </a>
<a name="6524"><span class="lineNum">    6524 </span>            :                  // to be a pointer with that base type. This attribute </a>
<a name="6525"><span class="lineNum">    6525 </span>            :                  // really should have an immediate effect.</a>
<a name="6526"><span class="lineNum">    6526 </span><span class="lineNoCov">          0 :                     convertBaseTypeOnStackToPointer();</span></a>
<a name="6527"><span class="lineNum">    6527 </span>            : </a>
<a name="6528"><span class="lineNum">    6528 </span>            :                  // Increment once past this pointer case.</a>
<a name="6529"><span class="lineNum">    6529 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="6530"><span class="lineNum">    6530 </span>            : </a>
<a name="6531"><span class="lineNum">    6531 </span>            :                  // astAttributeSpecStack.pop_front();</a>
<a name="6532"><span class="lineNum">    6532 </span>            :                     break;</a>
<a name="6533"><span class="lineNum">    6533 </span>            :                   }</a>
<a name="6534"><span class="lineNum">    6534 </span>            : </a>
<a name="6535"><span class="lineNum">    6535 </span><span class="lineNoCov">          0 :                case AttrSpec_COPOINTER:</span></a>
<a name="6536"><span class="lineNum">    6536 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="6537"><span class="lineNum">    6537 </span><span class="lineNoCov">          0 :                     if ( SgProject::get_verbose() &gt; DEBUG_COMMENT_LEVEL )</span></a>
<a name="6538"><span class="lineNum">    6538 </span><span class="lineNoCov">          0 :                          printf (&quot;found a COPOINTER spec \n&quot;);</span></a>
<a name="6539"><span class="lineNum">    6539 </span>            : </a>
<a name="6540"><span class="lineNum">    6540 </span><span class="lineNoCov">          0 :                     ROSE_ASSERT(!astBaseTypeStack.empty());</span></a>
<a name="6541"><span class="lineNum">    6541 </span>            : </a>
<a name="6542"><span class="lineNum">    6542 </span>            :                     // if (!astTypeStack.empty()) astTypeStack.pop_front();  // DXN (06/13/2011)</a>
<a name="6543"><span class="lineNum">    6543 </span>            : </a>
<a name="6544"><span class="lineNum">    6544 </span><span class="lineNoCov">          0 :                     SgPointerType* pointerType = astTypeStack.empty()?</span></a>
<a name="6545"><span class="lineNum">    6545 </span><span class="lineNoCov">          0 :                             new SgPointerType(astBaseTypeStack.front()):</span></a>
<a name="6546"><span class="lineNum">    6546 </span><span class="lineNoCov">          0 :                             new SgPointerType(astTypeStack.front());  // use the top of astTypeStack as the base type.</span></a>
<a name="6547"><span class="lineNum">    6547 </span><span class="lineNoCov">          0 :                     pointerType-&gt;set_isCoArray(true);                 // a copointer is a pointer whose isCoArray flag is true.</span></a>
<a name="6548"><span class="lineNum">    6548 </span>            : </a>
<a name="6549"><span class="lineNum">    6549 </span><span class="lineNoCov">          0 :                     if (astTypeStack.empty())</span></a>
<a name="6550"><span class="lineNum">    6550 </span>            :                        {</a>
<a name="6551"><span class="lineNum">    6551 </span><span class="lineNoCov">          0 :                          astBaseTypeStack.pop_front();</span></a>
<a name="6552"><span class="lineNum">    6552 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(astBaseTypeStack.empty());</span></a>
<a name="6553"><span class="lineNum">    6553 </span><span class="lineNoCov">          0 :                          astBaseTypeStack.push_front(pointerType);</span></a>
<a name="6554"><span class="lineNum">    6554 </span>            :                        }</a>
<a name="6555"><span class="lineNum">    6555 </span>            :                       else</a>
<a name="6556"><span class="lineNum">    6556 </span>            :                        {</a>
<a name="6557"><span class="lineNum">    6557 </span><span class="lineNoCov">          0 :                          astTypeStack.pop_front();</span></a>
<a name="6558"><span class="lineNum">    6558 </span><span class="lineNoCov">          0 :                          ROSE_ASSERT(astTypeStack.empty());</span></a>
<a name="6559"><span class="lineNum">    6559 </span><span class="lineNoCov">          0 :                          astTypeStack.push_front(pointerType);</span></a>
<a name="6560"><span class="lineNum">    6560 </span>            :                        }</a>
<a name="6561"><span class="lineNum">    6561 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="6562"><span class="lineNum">    6562 </span>            :                     break;</a>
<a name="6563"><span class="lineNum">    6563 </span>            :                   }</a>
<a name="6564"><span class="lineNum">    6564 </span>            : </a>
<a name="6565"><span class="lineNum">    6565 </span><span class="lineNoCov">          0 :                default:</span></a>
<a name="6566"><span class="lineNum">    6566 </span><span class="lineNoCov">          0 :                   {</span></a>
<a name="6567"><span class="lineNum">    6567 </span>            :                  // This is really an error because it means that we are ignoring all of attributes except </a>
<a name="6568"><span class="lineNum">    6568 </span>            :                  // for the specific cases handled above. so we have to save these attributes and use them</a>
<a name="6569"><span class="lineNum">    6569 </span>            :                  // to rebuild the stack without the attributes processed above.  This is because some</a>
<a name="6570"><span class="lineNum">    6570 </span>            :                  // attributes effect the type and some are just attributes to the save in the declaration.</a>
<a name="6571"><span class="lineNum">    6571 </span>            : </a>
<a name="6572"><span class="lineNum">    6572 </span>            :                  // savedAttributes.push_back(attr);</a>
<a name="6573"><span class="lineNum">    6573 </span>            :                  // astAttributeSpecStack.pop_front();</a>
<a name="6574"><span class="lineNum">    6574 </span>            : </a>
<a name="6575"><span class="lineNum">    6575 </span>            :                  // Increment once past this default case.</a>
<a name="6576"><span class="lineNum">    6576 </span><span class="lineNoCov">          0 :                     i++;</span></a>
<a name="6577"><span class="lineNum">    6577 </span>            :                   }</a>
<a name="6578"><span class="lineNum">    6578 </span>            :              }</a>
<a name="6579"><span class="lineNum">    6579 </span>            : </a>
<a name="6580"><span class="lineNum">    6580 </span>            :        // DQ (1/16/2011): We can't cal this since we don't yet have a declaration to use.</a>
<a name="6581"><span class="lineNum">    6581 </span>            :        // So we will have to save the entries that we don't process in the stack and push </a>
<a name="6582"><span class="lineNum">    6582 </span>            :        // those back onto the stack so that the variable declaration can be set properly later.</a>
<a name="6583"><span class="lineNum">    6583 </span>            :        // setDeclarationAttributeSpec(variableDeclaration,astAttributeSpecStack.front());</a>
<a name="6584"><span class="lineNum">    6584 </span>            : </a>
<a name="6585"><span class="lineNum">    6585 </span>            :        // astAttributeSpecStack.pop_front();</a>
<a name="6586"><span class="lineNum">    6586 </span>            : </a>
<a name="6587"><span class="lineNum">    6587 </span>            :        // printf (&quot;At bottom of loop over the attrubutes (next attribute = %d = %s ) \n&quot;,i != astAttributeSpecStack.end() ? *i : -1,i != astAttributeSpecStack.end() ? &quot;valid&quot; : &quot;end of list&quot;);</a>
<a name="6588"><span class="lineNum">    6588 </span>            : </a>
<a name="6589"><span class="lineNum">    6589 </span>            : #if 0</a>
<a name="6590"><span class="lineNum">    6590 </span>            :        // Output debugging information about saved state (stack) information.</a>
<a name="6591"><span class="lineNum">    6591 </span>            :           outputState(&quot;In BOTTOM of loop over attributes in processAttributeSpecStack()&quot;);</a>
<a name="6592"><span class="lineNum">    6592 </span>            : #endif</a>
<a name="6593"><span class="lineNum">    6593 </span>            :        // i++;</a>
<a name="6594"><span class="lineNum">    6594 </span>            :         }</a>
<a name="6595"><span class="lineNum">    6595 </span>            : </a>
<a name="6596"><span class="lineNum">    6596 </span>            :   // DQ (1/21/2011): Handling code such as &quot;integer :: a(5), b(7)&quot;</a>
<a name="6597"><span class="lineNum">    6597 </span>            :   // if (hasArraySpec == true)</a>
<a name="6598"><span class="lineNum">    6598 </span><span class="lineNoCov">          0 :         {</span></a>
<a name="6599"><span class="lineNum">    6599 </span>            :        // If this is a declarations such as &quot;integer :: a(5)&quot; then &quot;hasArraySpec&quot; is TRUE and we want to</a>
<a name="6600"><span class="lineNum">    6600 </span>            :        // remove the dimension attribute so that an additional veriable will use either the correct base </a>
<a name="6601"><span class="lineNum">    6601 </span>            :        // type or a new dimension attribute (and associated array length expression).</a>
<a name="6602"><span class="lineNum">    6602 </span>            : </a>
<a name="6603"><span class="lineNum">    6603 </span>            :        // Remove the dimension spec AND any pointer!!!</a>
<a name="6604"><span class="lineNum">    6604 </span><span class="lineNoCov">          0 :           std::vector&lt;int&gt; savedAttributes;</span></a>
<a name="6605"><span class="lineNum">    6605 </span><span class="lineNoCov">          0 :           std::list&lt;int&gt;::iterator j = astAttributeSpecStack.begin();</span></a>
<a name="6606"><span class="lineNum">    6606 </span><span class="lineNoCov">          0 :           while (j != astAttributeSpecStack.end())</span></a>
<a name="6607"><span class="lineNum">    6607 </span>            :              {</a>
<a name="6608"><span class="lineNum">    6608 </span>            :             // DQ (1/22/2011): The base type has already been computed and it will have include both pointer </a>
<a name="6609"><span class="lineNum">    6609 </span>            :             // and array concepts already. We will not want to repeat these in another array type used for </a>
<a name="6610"><span class="lineNum">    6610 </span>            :             // subsequent variables.</a>
<a name="6611"><span class="lineNum">    6611 </span>            :             // if ( (*j != AttrSpec_DIMENSION) &amp;&amp; (*j != ComponentAttrSpec_dimension) )</a>
<a name="6612"><span class="lineNum">    6612 </span><span class="lineNoCov">          0 :                if ( (*j != AttrSpec_DIMENSION) &amp;&amp; (*j != ComponentAttrSpec_dimension) &amp;&amp;</span></a>
<a name="6613"><span class="lineNum">    6613 </span><span class="lineNoCov">          0 :                     (*j != AttrSpec_POINTER)   &amp;&amp; (*j != ComponentAttrSpec_pointer) &amp;&amp; (*j != AttrSpec_COPOINTER))</span></a>
<a name="6614"><span class="lineNum">    6614 </span>            :                   {</a>
<a name="6615"><span class="lineNum">    6615 </span>            :                  // printf (&quot;Save the attribute = %d \n&quot;,*j);</a>
<a name="6616"><span class="lineNum">    6616 </span><span class="lineNoCov">          0 :                     savedAttributes.push_back(*j);</span></a>
<a name="6617"><span class="lineNum">    6617 </span>            :                   }</a>
<a name="6618"><span class="lineNum">    6618 </span>            :                  else</a>
<a name="6619"><span class="lineNum">    6619 </span>            :                   {</a>
<a name="6620"><span class="lineNum">    6620 </span>            :                  // printf (&quot;Found a dimension attribute \n&quot;);</a>
<a name="6621"><span class="lineNum">    6621 </span>            :                  // printf (&quot;Found a dimension or pointer attribute (already incorporated into the base type) \n&quot;);</a>
<a name="6622"><span class="lineNum">    6622 </span>            :                   }</a>
<a name="6623"><span class="lineNum">    6623 </span>            : </a>
<a name="6624"><span class="lineNum">    6624 </span><span class="lineNoCov">          0 :                j++;</span></a>
<a name="6625"><span class="lineNum">    6625 </span>            :              }</a>
<a name="6626"><span class="lineNum">    6626 </span>            : </a>
<a name="6627"><span class="lineNum">    6627 </span>            :        // Clear the astAttributeSpecStack, so that we avoid redundant entries when we put back </a>
<a name="6628"><span class="lineNum">    6628 </span>            :        // the saved entries.  See test2011_11.f90 for an example of where this is required.</a>
<a name="6629"><span class="lineNum">    6629 </span>            :        // astAttributeSpecStack.clear();</a>
<a name="6630"><span class="lineNum">    6630 </span><span class="lineNoCov">          0 :           while (astAttributeSpecStack.empty() == false)</span></a>
<a name="6631"><span class="lineNum">    6631 </span>            :              {</a>
<a name="6632"><span class="lineNum">    6632 </span><span class="lineNoCov">          0 :                astAttributeSpecStack.pop_front();</span></a>
<a name="6633"><span class="lineNum">    6633 </span>            :              }</a>
<a name="6634"><span class="lineNum">    6634 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astAttributeSpecStack.empty() == true);</span></a>
<a name="6635"><span class="lineNum">    6635 </span>            : </a>
<a name="6636"><span class="lineNum">    6636 </span>            :        // Replace the saved attributes on the stack (preserve the order as in the original stack).</a>
<a name="6637"><span class="lineNum">    6637 </span><span class="lineNoCov">          0 :           vector&lt;int&gt;::reverse_iterator k = savedAttributes.rbegin();</span></a>
<a name="6638"><span class="lineNum">    6638 </span><span class="lineNoCov">          0 :           while (k != savedAttributes.rend())</span></a>
<a name="6639"><span class="lineNum">    6639 </span>            :              {</a>
<a name="6640"><span class="lineNum">    6640 </span>            :             // printf (&quot;Adding *k = %d saved from first trip back onto the astAttributeSpecStack \n&quot;,*k);</a>
<a name="6641"><span class="lineNum">    6641 </span><span class="lineNoCov">          0 :                astAttributeSpecStack.push_front(*k);</span></a>
<a name="6642"><span class="lineNum">    6642 </span><span class="lineNoCov">          0 :                k++;</span></a>
<a name="6643"><span class="lineNum">    6643 </span>            :              }</a>
<a name="6644"><span class="lineNum">    6644 </span>            :         }</a>
<a name="6645"><span class="lineNum">    6645 </span>            : </a>
<a name="6646"><span class="lineNum">    6646 </span>            :   // printf (&quot;Leaving processAttributeSpecStack(): astAttributeSpecStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astAttributeSpecStack.size());</a>
<a name="6647"><span class="lineNum">    6647 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6648"><span class="lineNum">    6648 </span>            : </a>
<a name="6649"><span class="lineNum">    6649 </span>            : </a>
<a name="6650"><span class="lineNum">    6650 </span>            : void</a>
<a name="6651"><span class="lineNum">    6651 </span><span class="lineCov">         12 : processMultidimensionalSubscriptsIntoExpressionList(int count)</span></a>
<a name="6652"><span class="lineNum">    6652 </span>            :    {</a>
<a name="6653"><span class="lineNum">    6653 </span>            :   // DQ (1/18/2011): Refactored this code so it could be called in R510 and R443.</a>
<a name="6654"><span class="lineNum">    6654 </span>            : </a>
<a name="6655"><span class="lineNum">    6655 </span>            :   // printf (&quot;In processMultidimensionalSubscriptsIntoExpressionList( count = %d ) \n&quot;,count);</a>
<a name="6656"><span class="lineNum">    6656 </span>            : </a>
<a name="6657"><span class="lineNum">    6657 </span>            :   // DQ (1/17/2011): Moved the code to build the array index expression list from convertTypeOnStackToArrayType().</a>
<a name="6658"><span class="lineNum">    6658 </span><span class="lineCov">         12 :      SgExprListExp* expresssionList = new SgExprListExp();</span></a>
<a name="6659"><span class="lineNum">    6659 </span>            :   // arrayType-&gt;set_dim_info(expresssionList);</a>
<a name="6660"><span class="lineNum">    6660 </span><span class="lineCov">         12 :      setSourcePosition(expresssionList);</span></a>
<a name="6661"><span class="lineNum">    6661 </span>            :   // expresssionList-&gt;set_parent(arrayType);</a>
<a name="6662"><span class="lineNum">    6662 </span>            : </a>
<a name="6663"><span class="lineNum">    6663 </span><span class="lineCov">         24 :      for (int i=0; i &lt; count; i++)</span></a>
<a name="6664"><span class="lineNum">    6664 </span>            :         {</a>
<a name="6665"><span class="lineNum">    6665 </span><span class="lineCov">         12 :           ROSE_ASSERT(astExpressionStack.empty() == false);</span></a>
<a name="6666"><span class="lineNum">    6666 </span>            :        // printf (&quot;Adding an expression to the array type dimension information = %s \n&quot;,SageInterface::get_name(astExpressionStack.front()).c_str());</a>
<a name="6667"><span class="lineNum">    6667 </span>            : </a>
<a name="6668"><span class="lineNum">    6668 </span>            :        // ROSE_ASSERT(arrayType-&gt;get_dim_info() != NULL);</a>
<a name="6669"><span class="lineNum">    6669 </span>            :        // arrayType-&gt;get_dim_info()-&gt;prepend_expression(astExpressionStack.front());</a>
<a name="6670"><span class="lineNum">    6670 </span><span class="lineCov">         12 :           expresssionList-&gt;prepend_expression(astExpressionStack.front());</span></a>
<a name="6671"><span class="lineNum">    6671 </span><span class="lineCov">         12 :           astExpressionStack.pop_front();</span></a>
<a name="6672"><span class="lineNum">    6672 </span>            :         }</a>
<a name="6673"><span class="lineNum">    6673 </span>            : </a>
<a name="6674"><span class="lineNum">    6674 </span>            :   // Put the SgExprListExp onto the stack</a>
<a name="6675"><span class="lineNum">    6675 </span><span class="lineCov">         12 :      astExpressionStack.push_front(expresssionList);</span></a>
<a name="6676"><span class="lineNum">    6676 </span><span class="lineCov">         12 :    }</span></a>
<a name="6677"><span class="lineNum">    6677 </span>            : </a>
<a name="6678"><span class="lineNum">    6678 </span>            : </a>
<a name="6679"><span class="lineNum">    6679 </span>            : </a>
<a name="6680"><span class="lineNum">    6680 </span>            : void</a>
<a name="6681"><span class="lineNum">    6681 </span><span class="lineNoCov">          0 : convertBaseTypeToArrayWhereAppropriate()</span></a>
<a name="6682"><span class="lineNum">    6682 </span>            :    {</a>
<a name="6683"><span class="lineNum">    6683 </span>            :   // This is the latest point for building the base type to be used in the declaration of multiple variables.</a>
<a name="6684"><span class="lineNum">    6684 </span>            :   // DQ (1/20/2011): Refactored the code below so it could be called from R443 as well as R504.</a>
<a name="6685"><span class="lineNum">    6685 </span><span class="lineNoCov">          0 :      bool hasArraySpec      = false;</span></a>
<a name="6686"><span class="lineNum">    6686 </span><span class="lineNoCov">          0 :      bool hasInitialization = false;</span></a>
<a name="6687"><span class="lineNum">    6687 </span>            :   // printf (&quot;In convertBaseTypeToArrayWhereAppropriate (called by R504 (list__begin) c_action_entity_decl_list__begin()) calling processAttributeSpecStack(false,false): astAttributeSpecStack.size() = %&quot; PRIuPTR &quot; \n&quot;,astAttributeSpecStack.size());</a>
<a name="6688"><span class="lineNum">    6688 </span><span class="lineNoCov">          0 :      processAttributeSpecStack(hasArraySpec,hasInitialization);</span></a>
<a name="6689"><span class="lineNum">    6689 </span>            : </a>
<a name="6690"><span class="lineNum">    6690 </span>            :   // Note that if there are array or pointer attributes to process then processAttributeSpecStack() </a>
<a name="6691"><span class="lineNum">    6691 </span>            :   // sets up the astBaseTypeStack and astTypeStack, and we don't want an entry on the astTypeStack.</a>
<a name="6692"><span class="lineNum">    6692 </span>            :   // ROSE_ASSERT(astTypeStack.empty() == false);</a>
<a name="6693"><span class="lineNum">    6693 </span><span class="lineNoCov">          0 :      if (astTypeStack.empty() == false)</span></a>
<a name="6694"><span class="lineNum">    6694 </span>            :         {</a>
<a name="6695"><span class="lineNum">    6695 </span>            :        // printf (&quot;In convertBaseTypeToArrayWhereAppropriate (called by R504 (list__begin) c_action_entity_decl_list__begin()): Clearing the top entry on the astTypeStack \n&quot;);</a>
<a name="6696"><span class="lineNum">    6696 </span><span class="lineNoCov">          0 :           astTypeStack.pop_front();</span></a>
<a name="6697"><span class="lineNum">    6697 </span><span class="lineNoCov">          0 :           ROSE_ASSERT(astTypeStack.empty() == true);</span></a>
<a name="6698"><span class="lineNum">    6698 </span>            :         }</a>
<a name="6699"><span class="lineNum">    6699 </span><span class="lineNoCov">          0 :    }</span></a>
<a name="6700"><span class="lineNum">    6700 </span>            : </a>
<a name="6701"><span class="lineNum">    6701 </span>            : </a>
<a name="6702"><span class="lineNum">    6702 </span>            : </a>
<a name="6703"><span class="lineNum">    6703 </span>            : SgInitializedName*</a>
<a name="6704"><span class="lineNum">    6704 </span><span class="lineCov">        401 : buildInitializedNameAndPutOntoStack(const SgName &amp; name, SgType* type, SgInitializer* initializer)</span></a>
<a name="6705"><span class="lineNum">    6705 </span>            :    {</a>
<a name="6706"><span class="lineNum">    6706 </span>            :   // DQ (1/30/2011): Refactored code to support R504.</a>
<a name="6707"><span class="lineNum">    6707 </span>            : </a>
<a name="6708"><span class="lineNum">    6708 </span>            :   // printf (&quot;Building a new SgInitializedName that will be assembled into a variable declaration later. \n&quot;);</a>
<a name="6709"><span class="lineNum">    6709 </span><span class="lineCov">        401 :      SgInitializedName* initializedName = new SgInitializedName(name,type,initializer,NULL,NULL);</span></a>
<a name="6710"><span class="lineNum">    6710 </span>            : </a>
<a name="6711"><span class="lineNum">    6711 </span>            :   // DQ (9/11/2010): There is not associated SgVariableSymbol associated with this, so we need to build one.</a>
<a name="6712"><span class="lineNum">    6712 </span>            :   // This fixes test2010_45.f90 which references a variable declared in the same variable declaration.</a>
<a name="6713"><span class="lineNum">    6713 </span><span class="lineCov">        401 :      SgVariableSymbol* variableSymbol = new SgVariableSymbol(initializedName);</span></a>
<a name="6714"><span class="lineNum">    6714 </span>            : </a>
<a name="6715"><span class="lineNum">    6715 </span>            :   // DQ (11/29/2010): Set the scope for the SgInitializedName IR node (caught when trying to output (print) the symbol table).</a>
<a name="6716"><span class="lineNum">    6716 </span><span class="lineCov">        401 :      initializedName-&gt;set_scope(getTopOfScopeStack());</span></a>
<a name="6717"><span class="lineNum">    6717 </span>            : </a>
<a name="6718"><span class="lineNum">    6718 </span><span class="lineCov">        401 :      ROSE_ASSERT(astScopeStack.empty() == false);</span></a>
<a name="6719"><span class="lineNum">    6719 </span><span class="lineCov">        401 :      astScopeStack.front()-&gt;insert_symbol(name,variableSymbol);</span></a>
<a name="6720"><span class="lineNum">    6720 </span><span class="lineCov">        401 :      ROSE_ASSERT (initializedName-&gt;get_symbol_from_symbol_table () != NULL);</span></a>
<a name="6721"><span class="lineNum">    6721 </span>            : </a>
<a name="6722"><span class="lineNum">    6722 </span>            :   // Test the symbol tables and the new support for case insensitive symbol tables.</a>
<a name="6723"><span class="lineNum">    6723 </span><span class="lineCov">        401 :      ROSE_ASSERT(astScopeStack.front()-&gt;symbol_exists(name) == true);</span></a>
<a name="6724"><span class="lineNum">    6724 </span><span class="lineCov">        401 :      ROSE_ASSERT(astScopeStack.front()-&gt;isCaseInsensitive() == true);</span></a>
<a name="6725"><span class="lineNum">    6725 </span><span class="lineCov">        401 :      SgName invertedCaseName = name.invertCase();</span></a>
<a name="6726"><span class="lineNum">    6726 </span><span class="lineCov">        401 :      ROSE_ASSERT(astScopeStack.front()-&gt;symbol_exists(invertedCaseName) == true);</span></a>
<a name="6727"><span class="lineNum">    6727 </span><span class="lineCov">        401 :      ROSE_ASSERT(initializedName != NULL);</span></a>
<a name="6728"><span class="lineNum">    6728 </span>            : </a>
<a name="6729"><span class="lineNum">    6729 </span><span class="lineCov">        401 :      return initializedName;</span></a>
<a name="6730"><span class="lineNum">    6730 </span>            :    }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
